{
  "Title": "M-13: All collateral in Velodrome vault will be permantly locked if either asset in liquidity pair stays outside of min/max price",
  "Content": "# Issue M-13: All collateral in Velodrome vault will be permantly locked if either asset in liquidity pair stays outside of min/max price \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/70 \n\n## Found by \nclems4ever, 0x52\n\n## Summary\n\nThe oracles used have a built in safeguard to revert the transaction if the queried asset is outside of a defined price range. The issue with this is that every vault interaction requires the underlying collateral to be valued. If one of the assets in the pair goes outside it's immutable range then the entire vault will be frozen and all collateral will be permanently stuck.\n\n## Vulnerability Detail\n\n    function getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256 ) {\n        (\n            /*uint80 roundID*/,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            /*uint80 answeredInRound*/\n        ) = _priceFeed.latestRoundData();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n\n        //@audit revert if price is outside of immutable bounds\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n        uint256 price = uint256(signedPrice);\n        return price;\n    }\n\nThe lines above are called each time and asset is priced. If the oracle returns outside of the predefined range then the transaction will revert.\n\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n        //@audit contract prices withdraw collateral\n        uint256 colInUSD = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore debts less than $0.001\n            uint256 collateralLeft = totalCollateralValue(_collateralAddress, msg.sender) - colInUSD;\n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(collateralLeft > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n\nWhen closing a loan the vault attempts to price the users collateral. Since this is the only way for a user to remove collateral is to call closeLoan, if the price of either asset in the LP goes outside of its bounds then all user deposits will be lost. \n\n## Impact\n\nEntire vault will be frozen and all collateral will be permanently stuck\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Velo.sol#L527-L587\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf a user is closing their entire loan then there is no need to check the value of the withdraw collateral because there is no longer any debt to collateralize. Move the check inside the inequality to allow the closeLoan to always function:\n\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n    -   uint256 colInUSD = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n    +   uint256 colInUSD;\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore debts less than $0.001\n    +       uint256 colInUSD = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n            uint256 collateralLeft = totalCollateralValue(_collateralAddress, msg.sender) - colInUSD;\n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(collateralLeft > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. \n\nAlso by fixing issue #145 and refreshing the minPrice and maxPrice on each call we will reduce the likelihood of a price getting stuck outside of the aggregator price range.\n\n\n\n\n**kree-dotcom**\n\nProposed solution no longer works as the solution to issue #161 changed line 553 in `Vault_Velo.sol` to `if((outstandingisoUSD > 0) && (colInUSD > 0)){ ` meaning that the calculation of colInUSD must occur before entering the if clause. \n\nHowever with issue #145 fixed this problem is less terminal as now we update the minPrice and maxPrice with each call. \nWe then have two situations in which the minPrice or maxPrice protection is triggered:\n\n1.  Slow approach, i.e. like ETH reaching $1,000,000 over the span of a year. It is likely that Chainlink would update the aggregator maxPrice before it was reached and so this situation does not pose a problem.\n2.  Flash crash, a collateral is hacked or manipulated so that it drops below the minPrice faster than Chainlink can react and so the collateral is now stuck for our system. While this situation is not solved the assets backing the loan are now likely worthless anyway. This does not address the situation when the price rises suddenly. In that case the collateral will become inaccessible for a short while, it is assumed that if the price persists Chainlink would then alter the maxPrice and so collateral would become accessible again.\n\nTherefore this has become a \"won't fix\" issue\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Isomorph/contracts/Vault_Velo.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Vault_Velo.sol for isomorph.loans\n// Bug bounties available\n\npragma solidity =0.8.9; \npragma abicoder v2;\n\nimport \"./interfaces/IisoUSDToken.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/ICollateralBook.sol\";\nimport \"./interfaces/IDepositReceipt.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"./RoleControl.sol\";\n\nuint256 constant VAULT_VELO_TIME_DELAY = 3 days;\n\n\ncontract Vault_Velo is RoleControl(VAULT_VELO_TIME_DELAY), Pausable {\n\n    //Constants\n    uint256 public constant LIQUIDATION_RETURN = 95 ether /100; //95% returned on liquidiation\n    uint256 private constant LOAN_SCALE = 1 ether; //base for division/decimal maths\n    uint256 private constant NOT_OWNED = 999; //used to determine if a user owns an NFT\n\n    //users can only hold 8 NFTS relating to a loan so returning 999 is clearly out of bounds, not owned. 888 is no NFT to return, also out of bounds.\n    uint256 private constant NFT_LIMIT = 8; //the number of slots available on each loan for storing NFTs, used as loop bound. \n    uint256 private constant TENTH_OF_CENT = 1 ether /1000; //$0.001\n\n    //structure to store up to 8 NFTids for each loan, if more are required use a different address.\n    //could be packed more efficiently probably but we're on optimism so not as important.\n    struct NFTids {\n        uint256[NFT_LIMIT] ids;\n    }\n\n    //structure used to store loan NFT ids and which slots in the array ids they are stored in \n    struct CollateralNFTs{\n        uint256[NFT_LIMIT] ids;\n        uint256[NFT_LIMIT] slots;\n    }\n\n    //these mappings store the loan details of each users loan against each collateral.\n    //loan and interest, stored as a virtualPrice adjusted value \n    mapping(address => mapping(address => uint256)) public isoUSDLoanAndInterest;\n    //loan principle only, not adjusted by virtualPrice\n    mapping(address => mapping(address => uint256)) public isoUSDLoaned;\n    //NFT ids relating to a specific loan\n    mapping(address => mapping(address => NFTids)) internal loanNFTids;\n\n    //variables relating to access control and setting new roles\n    bytes32 private constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    \n    //Variables \n    //These three control max loans opened per day\n    uint256 public dailyMax = 1_000_000 ether; //one million with 18d.p.\n    uint256 public dayCounter = block.timestamp;\n    uint256 public dailyTotal = 0;\n\n    //This handles the opening fee paid to the protocol by users \n    uint256 public loanOpenFee = 1 ether /100; //1 percent opening fee.\n \n   \n\n    \n    //The treasury is where moUSD fees are paid, to keep this upgradable we allow changing by the admin, after a timelock period\n    address public treasury;\n    address public pendingTreasury;\n    uint256 public updateTreasuryTimestamp;\n\n    IisoUSDToken public isoUSD;\n    ICollateralBook public collateralBook;\n    \n\n    \n    event OpenOrIncreaseLoanNFT(address indexed user, uint256 loanTaken, bytes32 indexed collateralToken, uint256 collateralAmount); \n    event IncreaseCollateralNFT(address indexed user, bytes32 indexed collateralToken, uint256 collateralAmount); \n    \n    event ClosedLoanNFT(address indexed user, uint256 loanAmountReturned, bytes32 indexed collateralToken, uint256 returnedCapitaltoUser);\n    event LiquidationNFT(address indexed loanHolder, address indexed Liquidator, uint256 loanAmountReturned, bytes32 indexed collateralToken, uint256 liquidatedCapital);\n    event BadDebtClearedNFT(address indexed loanHolder, address indexed Liquidator, uint256 debtCleared, bytes32 indexed collateralToken);\n    \n    event ChangeDailyMax(uint256 newDailyMax, uint256 oldDailyMax);\n    event ChangeOpenLoanFee(uint256 newOpenLoanFee, uint256 oldOpenLoanFee);\n    event ChangeTreasury(address oldTreasury, address newTreasury);\n\n    event SystemPaused(address indexed pausedBy);\n    event SystemUnpaused(address indexed unpausedBy);\n    \n\n\n    /**\n     * modifiers and 'modifiers' two modifiers were turned into internal functions due to contract size constraints.\n     */\n\n    /// @notice basic checks to verify collateral being used exists and sanity check for loan holder\n    /// @dev should be called by any external function modifying another users loan in some way\n    function _validMarketConditions(address _collateralAddress, address _loanHolder) internal view{\n        _collateralExists(_collateralAddress);\n        require(_loanHolder != address(0), \"Zero address used\"); \n        \n    }\n    \n    /// @notice stripped down version of validMarketConditions used when checks of loanHolder aren't necessary\n    /// @dev should be called by any external function modifying the msg.sender's loan\n    function _collateralExists(address _collateralAddress) internal view {\n        require(collateralBook.collateralValid(_collateralAddress), \"Unsupported collateral!\");\n        \n    }\n\n    modifier onlyPauser{\n        bool validUser = hasRole(ADMIN_ROLE, msg.sender) || hasRole(PAUSER_ROLE, msg.sender);\n        require(validUser, \"Caller is not able to call pause\");\n        _;\n    }\n    \n    constructor(\n        address _isoUSD, //isoUSD address\n        address _treasury, //treasury address\n        address _collateralBook //collateral structure book address\n        ){\n        \n        require(_isoUSD != address(0), \"Zero Address used isoUSD\");\n        require(_treasury != address(0), \"Zero Address used Treasury\");\n        require(_collateralBook != address(0), \"Zero Address used Collateral\");\n        isoUSD = IisoUSDToken(_isoUSD);\n        treasury = _treasury;\n        collateralBook = ICollateralBook(_collateralBook);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(PAUSER_ROLE, msg.sender);\n       \n    } \n\n    /**\n        External restricted governance functions\n     */\n\n\n    /// @notice sets state to paused only triggerable by pauser (all admins can call Pauser functions also)\n    function pause() external onlyPauser {\n        _pause();\n        emit SystemPaused(msg.sender);\n    }\n    /// @notice sets state to unpaused only triggerable by admin\n    function unpause() external onlyAdmin {\n        _unpause();\n        emit SystemUnpaused(msg.sender);\n    }\n\n    /// @notice dailyMax can be set to 0 effectively preventing anyone from opening new loans.\n    function setDailyMax(uint256 _dailyMax) external onlyAdmin {\n        require(_dailyMax < 100_000_000 ether ); //sanity check, require less than 100 million opened per day\n        emit ChangeDailyMax(_dailyMax, dailyMax);\n        dailyMax = _dailyMax;\n        \n    }\n\n    /// @notice openLoanFee can be set to 10% max, fee applied to all loans on opening\n    function setOpenLoanFee(uint256 _newOpenLoanFee) external onlyAdmin {\n        require(_newOpenLoanFee <= 1 ether /10 ); \n        emit ChangeOpenLoanFee(_newOpenLoanFee, loanOpenFee);  \n        loanOpenFee = _newOpenLoanFee;\n    }\n\n    /// @notice admin only function to queue treasury address change which must wait the timelock period before being implemented\n    function proposeTreasury(address _newTreasury) external onlyAdmin {\n        require(_newTreasury != address(0)); \n        pendingTreasury = _newTreasury;\n        updateTreasuryTimestamp = block.timestamp + VAULT_VELO_TIME_DELAY;\n    }\n\n    /// @notice admin only function to change treasury target after timelock delay\n    function setTreasury() external onlyAdmin {\n        require(updateTreasuryTimestamp < block.timestamp); \n        address copyOfPendingTreasury = pendingTreasury;\n        require(copyOfPendingTreasury != address(0));\n        emit ChangeTreasury(treasury, copyOfPendingTreasury); //ignoring CEI pattern here\n        treasury = copyOfPendingTreasury;\n    }\n\n    //function required to receive ERC721s to this contract\n    function onERC721Received(\n        address operator,\n        address from,\n        uint tokenId,\n        bytes calldata data\n    ) external returns (bytes4){\n        return(IERC721Receiver.onERC721Received.selector);\n    }\n\n    /**\n        Internal helper and check functions\n     */\n\n\n    /// @notice while this could be abused to DOS the system, given the openLoan fee of 1% this is unlikely\n    function _checkDailyMaxLoans(uint256 _amountAdded) internal {\n        if (block.timestamp > dayCounter + 1 days ){\n            dailyTotal = _amountAdded;\n            dayCounter = block.timestamp;\n        }\n        else{\n            dailyTotal += _amountAdded;\n        }\n        require( dailyTotal  < dailyMax, \"Try again tomorrow loan opening limit hit\");\n    }\n    \n    function _priceCollateral(IDepositReceipt depositReceipt, uint256 _NFTId) internal view returns(uint256){  \n        uint256 pooledTokens = depositReceipt.pooledTokens(_NFTId);      \n        return( depositReceipt.priceLiquidity(pooledTokens));\n    }\n\n\n    /// @param _collateralAddress the address of the collateral token you are fetching\n    /// @notice returns all collateral struct fields seperately so that functions requiring \n    /// @notice them can only locally store the ones they need\n    function _getCollateral(address _collateralAddress) internal view returns(\n        bytes32 ,\n        uint256 ,\n        uint256 ,\n        uint256 ,\n        uint256 ,\n        uint256 \n        ){\n        ICollateralBook.Collateral memory collateral = collateralBook.collateralProps(_collateralAddress);\n        return (collateral.currencyKey, collateral.minOpeningMargin,\n        collateral.liquidatableMargin, collateral.interestPer3Min, collateral.lastUpdateTime, collateral.virtualPrice);\n    }\n\n\n    /// @param _percentToPay the percentage of the total sum express as a fee\n    /// @param _amount quantity of which to work out the percentage splits of\n    /// @dev internal function used to calculate treasury fees on opening loans\n    /// @return postFees is the quantity after the percentToPay has been deducted from it,\n    /// @return feeToPay is the percentToPay of original _amount.\n    function _findFees(uint256 _percentToPay, uint256 _amount) internal pure returns(uint256, uint256){\n        uint256 feeToPay = (_amount * _percentToPay) / LOAN_SCALE;\n        uint256 postFees = _amount - feeToPay;\n        return (postFees, feeToPay);\n    }\n\n\n    /// @param _currentBlockTime this should always be block.timestamp, passed in by trusted functions\n    /// @param _collateralAddress the address of the collateral token you wish to update the virtual price of \n    /// @dev this function should ONLY be called by other vault functions in which they pass in the block timestamp directly to this.\n    /// @dev currently uses interest calculations per 3 minutes to save gas and prevent DOS loop situations\n    function _updateVirtualPrice(uint256 _currentBlockTime, address _collateralAddress) internal { \n        (   ,\n            ,\n            ,\n            uint256 interestPer3Min,\n            uint256 lastUpdateTime,\n            uint256 virtualPrice\n        ) = _getCollateral(_collateralAddress);\n        uint256 timeDelta = _currentBlockTime - lastUpdateTime;\n        //exit gracefully if two users call the function for the same collateral in the same block \n        uint256 threeMinuteDelta = timeDelta / 180; \n        if(threeMinuteDelta > 0) {\n            for (uint256 i = 0; i < threeMinuteDelta; i++ ){\n            virtualPrice = (virtualPrice * interestPer3Min) / LOAN_SCALE; \n            }\n            collateralBook.vaultUpdateVirtualPriceAndTime(_collateralAddress, virtualPrice, _currentBlockTime);\n        }\n    }\n    \n\n     /**\n      * @notice Only Vaults can mint isoUSD.\n      * @dev internal function to handle increases of loan\n      * @param _loanAmount amount of isoUSD to be borrowed, some is used to pay the opening fee the rest is sent to the user.\n     **/\n    function _increaseLoan(uint256 _loanAmount) internal {\n        uint256 userMint;\n        uint256 loanFee;\n        _checkDailyMaxLoans(_loanAmount);\n        (userMint, loanFee) = _findFees(loanOpenFee, _loanAmount);\n        isoUSD.mint(_loanAmount);\n        //isoUSD reverts on transfer failure so we can safely ignore slither's warnings for it.\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transfer(msg.sender, userMint);\n        //slither-disable-next-line unchecked-transfer\n        isoUSD.transfer(treasury, loanFee);\n    }\n    /// @dev internal function used to increase user collateral on loan.\n    /// @param _depositReceipt the ERC721 compatible collateral to use, already set up in another function\n    /// @param _NFTid the unique idenfifier for this specific NFT, ownership already verified \n    function _increaseCollateral(IDepositReceipt _depositReceipt, uint256 _NFTid) internal {\n        _depositReceipt.transferFrom(msg.sender, address(this), _NFTid);\n    }\n\n    \n    /// @dev internal function used to decrease user collateral on loan by sending back an NFT\n    /// @param _collateralAddress the Liquidity Certificate ERC721 compatible collateral address \n    /// @param _loanNFTs structure containing the loan's NFT ids and the related slot it is stored in,\n    /// @dev  should already be checked and verified before inputting to this function\n    /// @param _partialPercentage percentage of the 4th NFT that will be liquidated (0-100%)\n    /// @param _USDReturned quantity of isoUSD being returned to the vault, this can be zero.\n    /// @param _interestPaid quantity of interest paid on closing loan, this is transfered to the treasury, this can be zero\n    function _decreaseLoanOrCollateral(\n        address _collateralAddress,\n        address _loanHolder, \n        CollateralNFTs calldata _loanNFTs, \n        uint256 _partialPercentage, \n        uint256 _USDReturned,\n        uint256 _interestPaid\n        ) internal {\n        //only process isoUSD if it's non-zero.\n        if (_USDReturned != 0){\n            //_interestPaid is always less than _USDReturned so this is safe.\n            uint256 USDBurning = _USDReturned - _interestPaid;\n            //slither-disable-next-line unchecked-transfer\n            isoUSD.transferFrom(msg.sender, address(this), _USDReturned);\n            //burn original loan principle\n            isoUSD.burn(address(this), USDBurning);\n            //transfer interest earned on loan to treasury\n            //slither-disable-next-line unchecked-transfer\n            isoUSD.transfer(treasury, _interestPaid);\n        }\n        _returnAndSplitNFTs(_collateralAddress, _loanHolder, _loanNFTs, _partialPercentage);\n        \n    }\n\n    function _checkNFTOwnership(address _collateralAddress, uint256 _NFTId, address _owner) internal view returns(uint256){\n        require(_NFTId != 0 , \"Zero NFTId not allowed\");\n\n        NFTids memory userNFTs = loanNFTids[_collateralAddress][_owner];\n        for(uint256 i =0; i < NFT_LIMIT; i++){\n            //check if each slot matches our specified NFT\n            if (userNFTs.ids[i] == _NFTId){\n                //if so return the slot so we know\n                \n                return (i);\n            }\n        }\n            //only slots 0-7 are valid, so if 999 is returned then we know the user has no loan against this NFT id.\n            return (NOT_OWNED);\n        \n    }\n\n\n    /**\n        Public functions \n    */\n\n    /**\n      * @notice Only Vaults can mint isoUSD.\n      * @dev Mints 'USDborrowed' amount of isoUSD to vault and transfers to msg.sender and emits transfer event.\n      * @param _collateralAddress address of deposit receipt being used as loan collateral.\n      * @param _owner the address of the loan holder\n     **/\n    function totalCollateralValue(address _collateralAddress, address _owner) public view returns(uint256){\n        NFTids memory userNFTs = loanNFTids[_collateralAddress][_owner];\n        IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 totalPooledTokens;\n        for(uint256 i =0; i < NFT_LIMIT; i++){\n            //check if each slot contains an NFT\n            if (userNFTs.ids[i] != 0){\n                totalPooledTokens += depositReceipt.pooledTokens(userNFTs.ids[i]);\n            }\n        }\n        return(depositReceipt.priceLiquidity(totalPooledTokens));\n    }\n\n    function getLoanNFTids(address _user, address _collateralAddress, uint256 _index) external view returns(uint256){\n        return(loanNFTids[_collateralAddress][_user].ids[_index]);\n    }\n\n    /**\n        External user loan interaction functions\n     */\n\n\n     /**\n      * @notice Only Vaults can mint isoUSD.\n      * @dev Mints 'USDborrowed' amount of isoUSD to vault and transfers to msg.sender and emits transfer event.\n      * @param _collateralAddress address of deposit receipt being used as loan collateral.\n      * @param _NFTId the NFT id which maps the NFT to it's characteristics\n      * @param _USDborrowed amount of isoUSD to be minted, it is then split into the amount sent and the opening fee.\n     **/\n    function openLoan(\n        address _collateralAddress,\n        uint256 _NFTId,\n        uint256 _USDborrowed,\n        bool _addingCollateral\n        ) external whenNotPaused  \n        {   \n            _collateralExists(_collateralAddress);\n            //slither-disable-next-line uninitialized-local-variables\n            IDepositReceipt depositReceipt;\n            //slither-disable-next-line uninitialized-local-variables\n            uint256 addedValue;\n            if(_addingCollateral){\n                //zero indexes cause problems with mappings and ownership, so refuse them\n                require(_NFTId != 0, \"No zero index NFTs allowed\");\n                depositReceipt = IDepositReceipt(_collateralAddress);\n                //checks msg.sender owns specified NFT id\n                require(depositReceipt.ownerOf(_NFTId) == msg.sender, \"Only NFT owner can openLoan\");\n                //get the specified certificate details\n                addedValue = _priceCollateral(depositReceipt, _NFTId);\n            }\n        \n        \n        _updateVirtualPrice(block.timestamp, _collateralAddress);  \n        \n        (   \n            bytes32 currencyKey,\n            uint256 minOpeningMargin,\n            ,\n            ,\n            ,\n            uint256 virtualPrice\n        ) = _getCollateral(_collateralAddress);\n\n        { //scoping to avoid stack too deep\n            uint256 existingLoan = isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice /LOAN_SCALE;\n            uint256 borrowMargin = ((_USDborrowed+ existingLoan) * minOpeningMargin) /LOAN_SCALE;\n            uint256 existingCollateral = totalCollateralValue(_collateralAddress, msg.sender); \n            require( addedValue + existingCollateral >= borrowMargin, \"Minimum margin not met!\");\n        }\n        if(_addingCollateral){\n            _increaseCollateral(depositReceipt, _NFTId);\n        }\n        \n        _increaseLoan(_USDborrowed);\n\n        isoUSDLoaned[_collateralAddress][msg.sender] = isoUSDLoaned[_collateralAddress][msg.sender] + _USDborrowed;\n        isoUSDLoanAndInterest[_collateralAddress][msg.sender] = isoUSDLoanAndInterest[_collateralAddress][msg.sender] + ((_USDborrowed * LOAN_SCALE) / virtualPrice);\n        NFTids storage userNFTs = loanNFTids[_collateralAddress][msg.sender];\n        if(_addingCollateral){\n            for(uint256 i =0; i < NFT_LIMIT; i++){\n                //if this id slot isn't already full assign it\n                if (userNFTs.ids[i] == 0){\n                    userNFTs.ids[i] = _NFTId;\n                    //then break so only one slot is assigned this id\n                    break;\n                }\n                else{\n                    if(i == NFT_LIMIT -1){\n                        //we have reached the final position and there are no free slots\n                        revert(\"All NFT slots for loan used\");\n                    }\n                }\n            }\n        }\n        emit OpenOrIncreaseLoanNFT(msg.sender, _USDborrowed, currencyKey, addedValue);\n    }\n\n\n    /**\n      * @dev Increases collateral supplied against an existing loan. \n      * @notice Checks adding the collateral will keep the user above liquidation, \n      * @notice this check isn't technically needed but feels fairer to end users.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _NFTId the NFT id which maps the NFT to it's characteristics\n     **/\n    \n    function increaseCollateralAmount(\n        address _collateralAddress,\n        uint256 _NFTId\n        ) external whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        //zero indexes cause problems with mappings and ownership, so refuse them\n        require(_NFTId != 0, \"No zero index NFTs allowed\");\n        uint256 existingCollateral = totalCollateralValue(_collateralAddress, msg.sender);\n        require( existingCollateral > 0, \"No existing collateral!\"); \n        //checks msg.sender owns specified NFT id\n        IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n        require(depositReceipt.ownerOf(_NFTId) == msg.sender, \"Only NFT owner can openLoan\");\n        //get the specified collateral's value\n        uint256 addedValue = _priceCollateral(depositReceipt, _NFTId);\n        require( addedValue > 0 , \"Zero value added\"); //Not strictly needed, prevents event spamming though\n        //make sure virtual price is related to current time before fetching collateral details\n        _updateVirtualPrice(block.timestamp, _collateralAddress);\n        (   \n            bytes32 currencyKey,\n            ,\n            uint256 liquidatableMargin,\n            ,\n            ,\n            uint256 virtualPrice\n        ) = _getCollateral(_collateralAddress);\n        //We check adding the collateral brings the user above the liquidation point to avoid instantly being liquidated, poor UX \n        uint256 USDborrowed = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        uint256 borrowMargin = (USDborrowed * liquidatableMargin) / LOAN_SCALE;\n        require(existingCollateral + addedValue >= borrowMargin, \"Liquidation margin not met!\");\n    \n        //update mapping with new collateral amount \n        emit IncreaseCollateralNFT(msg.sender, currencyKey, addedValue);\n        NFTids storage userNFTs = loanNFTids[_collateralAddress][msg.sender];\n        for(uint256 i =0; i < NFT_LIMIT; i++){\n            //if this id slot isn't already full assign it\n            if (userNFTs.ids[i] == 0){\n                userNFTs.ids[i] = _NFTId;\n                //then break so only one slot is assigned this id\n                break;\n            }\n            else{\n                if(i == NFT_LIMIT -1){\n                    //we have reached the final position and there are no free slots\n                    revert(\"All NFT slots for loan used\");\n                }\n            }\n        }\n        _increaseCollateral(depositReceipt, _NFTId);\n        \n    }\n\n\n\n     /**\n      * @notice Only Vaults can destroy isoUSD.\n      * @dev destroys USDreturned of isoUSD held by caller, returns user collateral, close debt \n      * @dev if debt remains, checks minimum collateral ratio is upheld \n      * @dev we ignore debt less than $0.001 this value must be less than the tx cost of a transaction to avoid slowly draining value with microloans\n      * @param _collateralAddress address of collateral token being used.\n      * @param _loanNFTs structure containing the loan's NFT ids being returned and the related slot it is stored in,\n      * @dev don't trust user input for this, always verify the ids match the user given slot before using.\n      * @notice the final nftId slot is always used for the partially returning NFT (if any are used, it can also be fully returned in this slot)\n      * @param _USDToVault amount of isoUSD to be burnt.\n      * @param _partialPercentage percentage of the final NFT that will be returned (0-100% in 10^18 scale)\n     **/\n\n    \n    function closeLoan(\n        address _collateralAddress,\n        CollateralNFTs calldata _loanNFTs,\n        uint256 _USDToVault,\n        uint256 _partialPercentage\n        ) external whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        //check input NFT slots and ids are correct\n        for(uint256 i = 0; i < NFT_LIMIT; i++){\n                require(_loanNFTs.slots[i] == \n                    _checkNFTOwnership(_collateralAddress, _loanNFTs.ids[i], msg.sender),\n                     \"Incorrect NFT details inputted\");\n            }\n        _updateVirtualPrice(block.timestamp, _collateralAddress);\n        (   \n            bytes32 currencyKey,\n            uint256 minOpeningMargin,\n            ,\n            ,\n            ,\n            uint256 virtualPrice\n        ) = _getCollateral(_collateralAddress);\n        \n        \n        uint256 isoUSDdebt = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        require( isoUSDdebt >= _USDToVault, \"Trying to return more isoUSD than borrowed!\");\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n        uint256 colInUSD = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore debts less than $0.001\n            uint256 collateralLeft = totalCollateralValue(_collateralAddress, msg.sender) - colInUSD;\n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(collateralLeft > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n\n        //record paying off loan principle before interest\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 interestPaid;\n        {\n        uint256 loanPrinciple = isoUSDLoaned[_collateralAddress][msg.sender];\n        if( loanPrinciple >= _USDToVault){\n            //pay off loan principle first\n            isoUSDLoaned[_collateralAddress][msg.sender] = loanPrinciple - _USDToVault;\n        }\n        else{\n            interestPaid = _USDToVault - loanPrinciple;\n            //loan principle is fully repaid so record this.\n            isoUSDLoaned[_collateralAddress][msg.sender] = 0;\n        }\n        }\n\n        isoUSDLoanAndInterest[_collateralAddress][msg.sender] = isoUSDLoanAndInterest[_collateralAddress][msg.sender] - ((_USDToVault * LOAN_SCALE) / virtualPrice);\n        \n        \n        //process return of NFTs now data validation is finished.\n        // loanNFTids mapping is updated here too\n        _decreaseLoanOrCollateral(_collateralAddress, msg.sender, _loanNFTs, _partialPercentage, _USDToVault, interestPaid);\n        \n        \n        emit ClosedLoanNFT(msg.sender, _USDToVault, currencyKey, colInUSD);\n        }\n\n    /**\n        Liquidation functions\n     */\n    \n    function _calculateProposedReturnedCapital(\n        address _collateralAddress, \n        CollateralNFTs calldata _loanNFTs, \n        uint256 _partialPercentage\n        ) internal view returns(uint256){\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 proposedLiquidationAmount;\n        require(_partialPercentage <= LOAN_SCALE, \"partialPercentage greater than 100%\");\n        for(uint256 i = 0; i < NFT_LIMIT; i++){\n                if(_loanNFTs.slots[i] < NFT_LIMIT){\n                    if((i == NFT_LIMIT -1) && (_partialPercentage > 0) && (_partialPercentage < LOAN_SCALE) ){\n                        //final slot is NFT that will be split if necessary\n                        proposedLiquidationAmount += \n                                                    (( _priceCollateral(IDepositReceipt(_collateralAddress), _loanNFTs.ids[i]) \n                                                    *_partialPercentage)/ LOAN_SCALE);\n                        \n                    } \n                    else{\n                        \n                        proposedLiquidationAmount += _priceCollateral(IDepositReceipt(_collateralAddress), _loanNFTs.ids[i]);\n                    }\n                }\n                \n            }\n            \n            return proposedLiquidationAmount;\n    }\n\n    function _returnAndSplitNFTs(\n        address _collateralAddress, \n        address _loanHolder, \n        CollateralNFTs calldata _loanNFTs, \n        uint256 _partialPercentage\n        ) internal{\n\n        IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n        NFTids storage userNFTs = loanNFTids[_collateralAddress][_loanHolder];\n        for(uint256 i = 0; i < NFT_LIMIT; i++){\n             //then we check this slot is being used, if not the slot number should be set to `NOT_OWNED`\n            if (_loanNFTs.slots[i] < NFT_LIMIT){\n                //final slot is NFT that will be split if necessary, we skip this loop if partialPercentage = 100% or 0%\n                if((i == NFT_LIMIT -1) && (_partialPercentage > 0) && (_partialPercentage < LOAN_SCALE) ){\n                    //split the NFT based on the partialPercentage proposed\n                    uint256 newId = depositReceipt.split(_loanNFTs.ids[i], _partialPercentage);\n                    //send the new NFT to the user, no mapping to update as original id NFT remains with the vault.\n                    depositReceipt.transferFrom(address(this), msg.sender, newId);\n                    }\n                else{\n                    userNFTs.ids[_loanNFTs.slots[i]] = 0;\n                    depositReceipt.transferFrom(address(this), msg.sender, _loanNFTs.ids[i]);\n                } \n            }\n        }\n    }\n    function _liquidate(\n        address _loanHolder,\n        address _collateralAddress,\n        uint256 _collateralLiquidated,\n        CollateralNFTs calldata _loanNFTs,\n        uint256 _partialPercentage,\n        uint256 _isoUSDReturned,\n        bytes32 _currencyKey, \n        uint256 _virtualPrice\n        ) internal {\n        //record paying off loan principle before interest\n        uint256 loanPrinciple = isoUSDLoaned[_collateralAddress][_loanHolder];\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 interestPaid;\n        if( loanPrinciple >= _isoUSDReturned){\n            //pay off loan principle first\n            isoUSDLoaned[_collateralAddress][_loanHolder] = loanPrinciple - _isoUSDReturned;\n        }\n        else {\n            interestPaid = _isoUSDReturned - loanPrinciple;\n            //loan principle is fully repaid so record this.\n            isoUSDLoaned[_collateralAddress][_loanHolder] = 0;\n        }\n\n        //if non-zero we are not handling a bad debt so the loanAndInterest will need updating\n        // this is semantic overloading so we must be careful here\n        if(isoUSDLoanAndInterest[_collateralAddress][_loanHolder] > 0){\n            isoUSDLoanAndInterest[_collateralAddress][_loanHolder] = \n                isoUSDLoanAndInterest[_collateralAddress][_loanHolder] - \n                ((_isoUSDReturned * LOAN_SCALE) / _virtualPrice);\n        }\n        else{ //here as isoUSDLoanAndInterest are zero we must be handling a baddebt or complete payoff \n            //so  we wipe the principle as we are finished using it\n            isoUSDLoaned[_collateralAddress][_loanHolder] = 0;\n        }\n        \n\n        _decreaseLoanOrCollateral(\n            _collateralAddress,\n            _loanHolder,\n            _loanNFTs,\n            _partialPercentage,\n            _isoUSDReturned,\n            interestPaid\n        );\n        \n        emit LiquidationNFT(\n            _loanHolder, \n            msg.sender,\n            _isoUSDReturned, \n            _currencyKey, \n            _collateralLiquidated\n        );\n    }\n\n\n       \n    \n    function viewLiquidatableAmount(\n        uint256 _collateralAmount,\n        uint256 _collateralPrice,\n        uint256 _userDebt,\n        uint256 _liquidatableMargin\n        ) public pure returns(uint256){\n        uint256 minimumCollateralPoint = _userDebt*_liquidatableMargin;\n        uint256 actualCollateralPoint = _collateralAmount*_collateralPrice;\n        if(minimumCollateralPoint <=  actualCollateralPoint){\n            //in this case the loan is not liquidatable at all and so we return zero\n            return 0;\n        }\n        uint256 numerator =  minimumCollateralPoint - actualCollateralPoint; \n        uint256 denominator = (_collateralPrice*LIQUIDATION_RETURN*_liquidatableMargin/LOAN_SCALE - _collateralPrice*LOAN_SCALE)/LOAN_SCALE;\n        return(numerator  / denominator);\n\n    }\n\n     /**\n      * @notice Anyone can liquidate any other undercollateralised loan.\n      * @notice The max acceptable liquidation quantity is calculated using viewLiquidatableAmount\n      * @notice this prevents full liquidation when partial liquidation would return recollaterize the loanHolder's debt \n      * @dev caller is p"
    }
  ]
}