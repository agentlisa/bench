{
  "Title": "[M-24] Salt Rewards - Rewards related to Arbitrage profits for pools can be lost",
  "Content": "\nArbitrage profits are distributed to pools that played a part in generating them. This is distributed via calling the performUpkeep function with upkeep.sol.\n\nThe process of upkeep is multi step, and any failure in any step does not disable next steps to trigger because each step is wrapped in a try catch. lets delve into steps 5 and 7.\n\n    \t// 5. Convert remaining WETH to SALT and sends it to SaltRewards.\n    function step5() public onlySameContract\n    \t{\n    \tuint256 wethBalance = weth.balanceOf( address(this) );\n    \tif ( wethBalance == 0 )\n    \t\treturn;\n\n    \t// Convert remaining WETH to SALT and send it to SaltRewards\n    \t// @audit arbitrage profits sent to saltrewards here, pools contract\n    \t// has allowance to withdrawm unlimited WETH from the upkeep contract\n    \t// but this swap operation can fail, if arbitrage profits are too large\n    \t// and not enough reserves of salt are there\n    \tuint256 amountSALT = pools.depositSwapWithdraw( weth, salt, wethBalance, 0, block.timestamp );\n    \tsalt.safeTransfer(address(saltRewards), amountSALT);\n    \t}\n\nstep 5 converts the arbitrage profits from WETH to Salt. Next, after which they are distributed to SaltRewards contract. If the operation to swap WETH to Salt fails due to reserves going below dust for example, then no Salt will be transferred to the salt rewards contract. this will impact step 7.\n\n    \t// 7. Distribute SALT from SaltRewards to the stakingRewardsEmitter and liquidityRewardsEmitter.\n    function step7() public onlySameContract\n    \t{\n    \t// @audit line below can return a list with arbitrage profits assigned for a pool\n    \tuint256[] memory profitsForPools = pools.profitsForWhitelistedPools();\n\n    \tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n    \t// @audit if more than 1 week passed, less rewards passed to the emitters in step 8.\n    \tsaltRewards.performUpkeep(poolIDs, profitsForPools );\n    \t// @audit can arbitrage profits be cleared without distributing?\n    \tpools.clearProfitsForPools();\n    \t}\n\nStep 6 will distribute the salt emissions to the saltrewards contract.  so the saltrewards contract will have only salt related to emissions but not arbitrage profits.\n\nStep 7 will distribute all salt rewards(including those arbitrage profits in Salt to all the pools) via calling performUpkeep function in salt rewards contrat, but this assumes the SaltRewards contract will have a salt balance containing the arbitrage profits (from step 5), which might not be the case.\n\n    \t\tuint256 saltRewardsToDistribute = salt.balanceOf(address(this));\n    \tif ( saltRewardsToDistribute == 0 ){ // @audit function simply returns, this could be problematic\n    \t\treturn;\n    \t}\n\n    \t// Determine the total profits so we can calculate proportional share for the liquidity rewards\n    \tuint256 totalProfits = 0;\n    \tfor( uint256 i = 0; i < poolIDs.length; i++ ) {\n    \t\ttotalProfits += profitsForPools[i];\n    \t}\n\n    \t// Make sure that there are some profits to determine the proportional liquidity rewards.\n    \t// Otherwise just handle the SALT balance later so it can be divided between stakingRewardsEmitter and liquidityRewardsEmitter without further accounting.\n    \tif ( totalProfits == 0 ) {\n    \t\treturn;\n    \t}\n\n    \t// Determine how much of the SALT rewards will be directly awarded to the SALT/USDS pool.\n    \t// This is because SALT/USDS is important, but not included in other arbitrage trades - which would normally yield additional rewards for the pool by being part of arbitrage swaps.\n    \tuint256 directRewardsForSaltUSDS = ( saltRewardsToDistribute * rewardsConfig.percentRewardsSaltUSDS() ) / 100;\n    \tuint256 remainingRewards = saltRewardsToDistribute - directRewardsForSaltUSDS;\n\n    \t// Divide up the remaining rewards between SALT stakers and liquidity providers\n    \tuint256 stakingRewardsAmount = ( remainingRewards * rewardsConfig.stakingRewardsPercent() ) / 100;\n    \tuint256 liquidityRewardsAmount = remainingRewards - stakingRewardsAmount;\n    \t_sendStakingRewards(stakingRewardsAmount);\n    \t_sendLiquidityRewards(liquidityRewardsAmount, directRewardsForSaltUSDS, poolIDs, profitsForPools, totalProfits); // @audit salt rewards for liquidity will not include amounts related to pool arbitrate profits\n\nAs you can see above, the performupkeep checks the contracts salt balance and based off that the liquidity rewards amounts are determined. but given that actual balance does not include those profits, these figures will be inaccurate.\n\nIt would then return back to step 7 and 'Clear' the profits assigned to each pool via calling pools.clearProfitsForPools().\n\nThis essentially means that profits assigned to pools are cleared from storage without actually being distributed fairly as Salt rewards to pool liquidity providers.\n\nThe likelihood of this bug occuring is low to medium, because it is dependant on failure in the WETH to Salt swap in step 5 which might occur if the pool was maliciously targeted or in extreme market conditions and volatility. However the impact is medium to high since pool liquidity providers will most certainly lose out on arbitrage profits(dependant the frequency of calling upkeep and trading dynamics, this could potentially be a large arbitrage profit), so given the potential for lost rewards, a rating of atleast high here is appropriate.\n\n### Proof of Concept\n\nThe POC below succesfully simulates this situation, by making sure the attempt to swap WETH to Salt in step 5 fails. this is done by manipulating pool reserve amounts. There are two versions, one with call to step 6 and one without.The one without the call to step6 more clearly displays the 'loss' in rewards.\n\n</details>\n\n    function testSuccessStep5NoStep6() public\n    \t{\n    \t_setupLiquidity();\n    \tvm.warp( block.timestamp + 1 days );\n    \t_generateArbitrageProfits(true);\n\n    \t// stakingRewardsEmitter and liquidityRewardsEmitter have initial bootstrapping rewards\n    \tbytes32[] memory poolIDsB = new bytes32[](1);\n    \tpoolIDsB[0] = PoolUtils._poolID(salt, usds);\n    \tuint256 initialRewardsB = liquidityRewardsEmitter.pendingRewardsForPools(poolIDsB)[0];\n\n    \tbool errorRaised = false;\n\n    \t//Mimic depositing arbitrage profits.\n    \tvm.prank(DEPLOYER);\n    \tweth.transfer(address(dao), 700 ether);\n    \t\n\n    \tvm.startPrank(address(dao));\n    \tweth.approve(address(pools), 700 ether );\n    \tpools.deposit( weth, 700 ether);\n    \tvm.stopPrank();\n\n    \tassertEq( salt.balanceOf(address(saltRewards)), 0 );\n\n        vm.startPrank(address(upkeep));\n    \tITestUpkeep(address(upkeep)).step2(alice);\n    \tITestUpkeep(address(upkeep)).step3();\n    \tITestUpkeep(address(upkeep)).step4();\n    \ttry ITestUpkeep(address(upkeep)).step5() {}\n    \tcatch (bytes memory error) {errorRaised = true; }\n    \tassertEq( errorRaised, true ); // proves that the swap from WETH to Salt in step 5 failed\n\n    \t// No SALT was sent to SaltRewards, because swap from WETH to SALT failed due to low reserves.\n    \t// which means arbitrage profits reward wont be sent to pools\n    \tassertEq( salt.balanceOf(address(saltRewards)), 0);\n\n    \t// Check that the rewards were recorded in storage\n    \tbool poolsHaveProfit = false;\n    \tuint256[] memory profitsForPools = IPoolStats(address(pools)).profitsForWhitelistedPools();\n    \tfor( uint256 i = 0; i < profitsForPools.length; i++ ) {\n    \t\tconsole.log(\"pool profit for pool before:\", i);\n    \t\tconsole.log(profitsForPools[i]);\n    \t\tif (profitsForPools[i] > 0){\n    \t\t\tpoolsHaveProfit = true;\n    \t\t}\n    \t\t\n    \t}\n    \tassertEq( poolsHaveProfit, true );\n\n    \tITestUpkeep(address(upkeep)).step7();\n    \tbool poolsDontHaveProfit = false;\n    \t// Check that the rewards for pools no longer recorded in storage\n    \tuint256[] memory profitsForPools2 = IPoolStats(address(pools)).profitsForWhitelistedPools();\n    \tfor( uint256 i = 0; i < profitsForPools2.length; i++ ) {\n    \t\tconsole.log(\"pool profit for pool:\", i);\n    \t\tconsole.log(profitsForPools2[i]);\n    \t\tif (profitsForPools2[i] > 0){\n    \t\t\tpoolsDontHaveProfit = true;\n    \t\t}\n    \t}\n        // test proves that in the case a pool doesnt have enough reserve to swap the arbitrage profits to SALT, the upkeep sequence\n    \t// can lead to arbitrage profits being cleared from storage, effectively meaning they can not be distributed\n    \t// to anyone, hence lost funds. ie  the pools that have taken part in generating recent arbitrage profits so that those pools \n    \t// will be unable to can receive proportional pending rewards on the next call to performUpkeep(), because their record has been cleared from storage.\n    \tassertEq( poolsDontHaveProfit, false );\n\n    \tbytes32[] memory poolIDs = new bytes32[](4);\n    \tpoolIDs[0] = PoolUtils._poolID(salt,weth);\n    \tpoolIDs[1] = PoolUtils._poolID(salt,wbtc);\n    \tpoolIDs[2] = PoolUtils._poolID(wbtc,weth);\n    \tpoolIDs[3] = PoolUtils._poolID(salt,usds);\n\n    \t// Check that rewards were not sentto the three pools involved in generating the test arbitrage\n    \tassertEq( liquidityRewardsEmitter.pendingRewardsForPools(poolIDs)[0], initialRewardsB );\n    \tassertEq( liquidityRewardsEmitter.pendingRewardsForPools(poolIDs)[1], initialRewardsB );\n    \tassertEq( liquidityRewardsEmitter.pendingRewardsForPools(poolIDs)[2], initialRewardsB );\n\n    \tvm.stopPrank();\n    \t}\n\n\n\n        function testSuccessStep5Withstep6() public\n    \t{\n    \t_setupLiquidity();\n    \tvm.warp( block.timestamp + 1 days );\n    \t_generateArbitrageProfits(true);\n\n    \t// stakingRewardsEmitter and liquidityRewardsEmitter have initial bootstrapping rewards\n    \tbytes32[] memory poolIDsB = new bytes32[](1);\n    \tpoolIDsB[0] = PoolUtils._poolID(salt, usds);\n    \tuint256 initialRewardsB = liquidityRewardsEmitter.pendingRewardsForPools(poolIDsB)[0];\n\n    \tbool errorRaised = false;\n\n    \t//Mimic depositing arbitrage profits.\n    \tvm.prank(DEPLOYER);\n    \tweth.transfer(address(dao), 700 ether);\n    \t\n\n    \tvm.startPrank(address(dao));\n    \tweth.approve(address(pools), 700 ether );\n    \tpools.deposit( weth, 700 ether);\n    \tvm.stopPrank();\n\n    \tassertEq( salt.balanceOf(address(saltRewards)), 0 );\n\n        vm.startPrank(address(upkeep));\n    \tITestUpkeep(address(upkeep)).step2(alice);\n    \tITestUpkeep(address(upkeep)).step3();\n    \tITestUpkeep(address(upkeep)).step4();\n    \ttry ITestUpkeep(address(upkeep)).step5() {}\n    \tcatch (bytes memory error) {errorRaised = true; }\n    \tassertEq( errorRaised, true ); // proves that the swap from WETH to Salt in step 5 failed\n\n    \t// No SALT was sent to SaltRewards, because swap from WETH to SALT failed due to low reserves.\n    \t// which means salt rewards related to arbitrage profits reward wont be sent to pools\n    \tassertEq( salt.balanceOf(address(saltRewards)), 0);\n\n    \t// Check that the rewards were recorded in storage\n    \tbool poolsHaveProfit = false;\n    \tuint256[] memory profitsForPools = IPoolStats(address(pools)).profitsForWhitelistedPools();\n    \tfor( uint256 i = 0; i < profitsForPools.length; i++ ) {\n    \t\tconsole.log(\"pool profit for pool before:\", i);\n    \t\tconsole.log(profitsForPools[i]);\n    \t\tif (profitsForPools[i] > 0){\n    \t\t\tpoolsHaveProfit = true;\n    \t\t}\n    \t\t\n    \t}\n    \tassertEq( poolsHaveProfit, true );\n\n\n    \tITestUpkeep(address(upkeep)).step6();\n    \tITestUpkeep(address(upkeep)).step7();\n    \tbool poolsDontHaveProfit = false;\n    \t// Check that the rewards for pools no longer recorded in storage\n    \tuint256[] memory profitsForPools2 = IPoolStats(address(pools)).profitsForWhitelistedPools();\n    \tfor( uint256 i = 0; i < profitsForPools2.length; i++ ) {\n    \t\tconsole.log(\"pool profit for pool:\", i);\n    \t\tconsole.log(profitsForPools2[i]);\n    \t\tif (profitsForPools2[i] > 0){\n    \t\t\tpoolsDontHaveProfit = true;\n    \t\t}\n    \t}\n        // test proves that in the case a pool doesnt have enough reserve to swap the arbitrage profits to SALT, the upkeep sequence\n    \t// can lead to arbitrage profits being cleared from storage, effectively meaning they can not be distributed\n    \t// to anyone, hence lost funds. ie  the pools that have taken part in generating recent arbitrage profits so that those pools \n    \t// will be unable to can receive proportional pending rewards on the next call to performUpkeep(), because their record has been cleared from storage.\n    \tassertEq( poolsDontHaveProfit, false );\n\n\n    \tvm.stopPrank();\n    \t}\n\n     function _setupLiquidity() internal\n    \t{\n    \tvm.prank(address(collateralAndLiquidity));\n    \tusds.mintTo(DEPLOYER, 100000 ether );\n\n    \tvm.prank(address(teamVestingWallet));\n    \tsalt.transfer(DEPLOYER, 100000 ether );\n\n    \tvm.startPrank(DEPLOYER);\n    \tweth.approve( address(collateralAndLiquidity), 300000 ether);\n    \tusds.approve( address(collateralAndLiquidity), 100000 ether);\n    \tdai.approve( address(collateralAndLiquidity), 100000 ether);\n    \tsalt.approve( address(collateralAndLiquidity), 100000 ether);\n\n    \tcollateralAndLiquidity.depositLiquidityAndIncreaseShare(weth, usds, 100000 ether, 100000 ether, 0, block.timestamp, false);\n    \tcollateralAndLiquidity.depositLiquidityAndIncreaseShare(weth, dai, 100000 ether, 100000 ether, 0, block.timestamp, false);\n    \tcollateralAndLiquidity.depositLiquidityAndIncreaseShare(weth, salt, 100000000000 wei, 100000000000 wei, 0, block.timestamp, false);\n\n    \tvm.stopPrank();\n    \t}\n\n     function _generateArbitrageProfits( bool despositSaltUSDS ) internal\n    \t{\n    \t/// Pull some SALT from the daoVestingWallet\n    \tvm.prank(address(daoVestingWallet));\n    \tsalt.transfer(DEPLOYER, 100000 ether);\n\n    \t// Mint some USDS\n    \tvm.prank(address(collateralAndLiquidity));\n    \tusds.mintTo(DEPLOYER, 1000 ether);\n\n    \tvm.startPrank(DEPLOYER);\n    \tsalt.approve(address(collateralAndLiquidity), type(uint256).max);\n    \twbtc.approve(address(collateralAndLiquidity), type(uint256).max);\n    \tweth.approve(address(collateralAndLiquidity), type(uint256).max);\n    \twbtc.approve(address(collateralAndLiquidity), type(uint256).max);\n    \tweth.approve(address(collateralAndLiquidity), type(uint256).max);\n\n    \tif ( despositSaltUSDS )\n    \t\t//collateralAndLiquidity.depositLiquidityAndIncreaseShare( salt, weth, 1000 ether, 1000 ether, 0, block.timestamp, false );\n    \t\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare( salt, weth, 100000000000 wei, 100000000000 wei, 0, block.timestamp, false );\n\n    \tcollateralAndLiquidity.depositLiquidityAndIncreaseShare( wbtc, salt, 1000 * 10**8, 1000 ether, 0, block.timestamp, false );\n    \tcollateralAndLiquidity.depositCollateralAndIncreaseShare( 1000 * 10**8, 1000 ether, 0, block.timestamp, false );\n\n    \tsalt.approve(address(pools), type(uint256).max);\n    \twbtc.approve(address(pools), type(uint256).max);\n    \tweth.approve(address(pools), type(uint256).max);\n    \tvm.stopPrank();\n\n    \t// Place some sample trades to create arbitrage profits\n    \t_swapToGenerateProfits();\n    \t}\n\n</details>\n\n### Recommended Mitigation Steps\n\nGiven the interdependencies between step 5 and step 7, a failure in step 5 due to a failed swap implies that step 7 should also not proceed because its calculations are dependent on the success of step 5. Appropriate logic should be added to handle this.\n\n**[othernet-global (Salty.IO) disputed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/239#issuecomment-1933589958):**\n > It is acceptable for step 7 to not distribute rewards if step 5 has not functioned correctly.  Assuming step 5 functions correctly later, then step 7 will function correctly later as well.\n\n**[Picodes (Judge) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/239#issuecomment-1952516157):**\n > It seems to me that rewards are just delayed here as the step 5 uses the contract's balance so there is no issue.\n\n**[genesiscrew (Warden) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/239#issuecomment-1958800791):**\n > There is no guarantee that the rewards that were delayed will be later distributed fairly to the pools that generated them. This is due to the fact that in the case of distribution failure, profits assigned to pools are cleared from storage as is shown in the POC. \n> \n> Imagine pool A accumulated most of the rewards in interval 1, reward distribution fails, in interval two pool B accumulated most of the rewards, they will be rewarded more than they should be because the balance will include rewards from interval 1 and interval 2. \n> \n> https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/rewards/SaltRewards.sol#L68\n> \n> The line above shows how rewards are distributed for each pool. in this formula profitsForPools[i] and totalProfits will not  factor in delayed rewards. while liquidityRewardsAmount will because its based off contract balance. so this means pool B in interval 2 will be effectively earning more rewards than it should, hence lost rewards for pool A.\n\n**[Picodes (Judge) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/239#issuecomment-1963481998):**\n > Thanks @genesiscrew. On second read it seems you are right. We could imagine a scenario where an attacker forces step 5 to fail to clear the storage and then distribute profits to a pool he is in. But the scenario wouldn't be simple because you need to take into account the fact that automatic arbitrages increases the cost of manipulating pool reserves.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/rewards/SaltRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/ISaltRewards.sol\";\nimport \"../interfaces/ISalt.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// A utility contract that temporarily holds SALT rewards from emissions and arbitrage profits during performUpkeep().\n// Sends SALT rewards to the stakingRewardsEmitter and liquidityRewardsEmitter (with proportions for the latter based on each pool's share in generating recent arbitrage profits).\ncontract SaltRewards is ISaltRewards\n    {\n    using SafeERC20 for ISalt;\n\n\tIRewardsEmitter immutable public stakingRewardsEmitter;\n\tIRewardsEmitter immutable public liquidityRewardsEmitter;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tISalt immutable public salt;\n\n\tbytes32 immutable saltUSDSPoolID;\n\n\n    constructor( IRewardsEmitter _stakingRewardsEmitter, IRewardsEmitter _liquidityRewardsEmitter, IExchangeConfig _exchangeConfig, IRewardsConfig _rewardsConfig )\n\t\t{\n\t\tstakingRewardsEmitter = _stakingRewardsEmitter;\n\t\tliquidityRewardsEmitter = _liquidityRewardsEmitter;\n\t\texchangeConfig = _exchangeConfig;\n\t\trewardsConfig = _rewardsConfig;\n\n\t\t// Cached for efficiency\n\t\tsalt = _exchangeConfig.salt();\n\t\tsaltUSDSPoolID = PoolUtils._poolID(salt, _exchangeConfig.usds());\n\n\t\t// Gas saving approval for rewards distribution on performUpkeep().\n\t\t// This contract only has a temporary SALT balance during the performUpkeep transaction.\n\t\tsalt.approve( address(stakingRewardsEmitter), type(uint256).max );\n\t\tsalt.approve( address(liquidityRewardsEmitter), type(uint256).max );\n\t\t}\n\n\n\t// Send the pending SALT rewards to the stakingRewardsEmitter\n\tfunction _sendStakingRewards(uint256 stakingRewardsAmount) internal\n\t\t{\n\t\tAddedReward[] memory addedRewards = new AddedReward[](1);\n\t\taddedRewards[0] = AddedReward( PoolUtils.STAKED_SALT, stakingRewardsAmount );\n\n\t\tstakingRewardsEmitter.addSALTRewards(addedRewards);\n\t\t}\n\n\n\t// Transfer SALT rewards to pools in the liquidityRewardsEmitter proportional to each pool's share in generating recent arbitrage profits.\n\t// Also send the direct rewards specified by the DAO to the SALT/USDS pool.\n\tfunction _sendLiquidityRewards( uint256 liquidityRewardsAmount, uint256 directRewardsForSaltUSDS, bytes32[] memory poolIDs, uint256[] memory profitsForPools, uint256 totalProfits ) internal\n\t\t{\n\t\trequire( poolIDs.length == profitsForPools.length, \"Incompatible array lengths\" );\n\n\t\t// Send SALT rewards (with an amount of pendingLiquidityRewards) proportional to the profits generated by each pool\n\t\tAddedReward[] memory addedRewards = new AddedReward[]( poolIDs.length );\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\t\t\tuint256 rewardsForPool = ( liquidityRewardsAmount * profitsForPools[i] ) / totalProfits;\n\n\t\t\t// The SALT/USDS pool is entitled to additional rewards - as specified by RewardsConfig.percentRewardsSaltUSDS\n\t\t\tif ( poolID == saltUSDSPoolID )\n\t\t\t\trewardsForPool += directRewardsForSaltUSDS;\n\n\t\t\taddedRewards[i] = AddedReward( poolID, rewardsForPool );\n\t\t\t}\n\n\t\t// Send the SALT rewards to the LiquidityRewardsEmitter\n\t\tliquidityRewardsEmitter.addSALTRewards( addedRewards );\n\t\t}\n\n\n\tfunction _sendInitialLiquidityRewards( uint256 liquidityBootstrapAmount, bytes32[] memory poolIDs ) internal\n\t\t{\n\t\t// Divide the liquidityBootstrapAmount evenly across all the initial pools\n\t\tuint256 amountPerPool = liquidityBootstrapAmount / poolIDs.length; // poolIDs.length is guaranteed to not be zero\n\n\t\tAddedReward[] memory addedRewards = new AddedReward[]( poolIDs.length );\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\taddedRewards[i] = AddedReward( poolIDs[i], amountPerPool );\n\n\t\t// Send the liquidity bootstrap rewards to the liquidityRewardsEmitter\n\t\tliquidityRewardsEmitter.addSALTRewards( addedRewards );\n\t\t}\n\n\n\tfunction _sendInitialStakingRewards( uint256 stakingBootstrapAmount ) internal\n\t\t{\n\t\t// Send the stakingBootstrapAmount to the stakingRewardsEmitter\n\t\tAddedReward[] memory addedRewards = new AddedReward[](1);\n\t\taddedRewards[0] = AddedReward( PoolUtils.STAKED_SALT, stakingBootstrapAmount );\n\n\t\tstakingRewardsEmitter.addSALTRewards( addedRewards );\n\t\t}\n\n\n    // Sends an expected 5 million SALT to the liquidityRewardsEmitter (evenly divided amongst the pools) and 3 million SALT to the stakingRewardsEmitter.\n\tfunction sendInitialSaltRewards( uint256 liquidityBootstrapAmount, bytes32[] calldata poolIDs ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.initialDistribution()), \"SaltRewards.sendInitialRewards is only callable from the InitialDistribution contract\" );\n\n\t\t_sendInitialLiquidityRewards(liquidityBootstrapAmount, poolIDs);\n\n\t\t// Remaining SALT balance goes to stakingRewardsEmitter\n\t\t_sendInitialStakingRewards( salt.balanceOf(address(this)) );\n\t\t}\n\n\n\tfunction performUpkeep( bytes32[] calldata poolIDs, uint256[] calldata profitsForPools ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"SaltRewards.performUpkeep is only callable from the Upkeep contract\" );\n\t\trequire( poolIDs.length == profitsForPools.length, \"Incompatible array lengths\" );\n\n\t\t// Distribute all SALT currently in the contract.\n\t\tuint256 saltRewardsToDistribute = salt.balanceOf(address(this));\n\t\tif ( saltRewardsToDistribute == 0 )\n\t\t\treturn;\n\n\t\t// Determine the total profits so we can calculate proportional share for the liquidity rewards\n\t\tuint256 totalProfits = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\ttotalProfits += profitsForPools[i];\n\n\t\t// Make sure that there are some profits to determine the proportional liquidity rewards.\n\t\t// Otherwise just handle the SALT balance later so it can be divided between stakingRewardsEmitter and liquidityRewardsEmitter without further accounting.\n\t\tif ( totalProfits == 0 )\n\t\t\treturn;\n\n\t\t// Determine how much of the SALT rewards will be directly awarded to the SALT/USDS pool.\n\t\t// This is because SALT/USDS is important, but not included in other arbitrage trades - which would normally yield additional rewards for the pool by being part of arbitrage swaps.\n\t\tuint256 directRewardsForSaltUSDS = ( saltRewardsToDistribute * rewardsConfig.percentRewardsSaltUSDS() ) / 100;\n\t\tuint256 remainingRewards = saltRewardsToDistribute - directRewardsForSaltUSDS;\n\n\t\t// Divide up the remaining rewards between SALT stakers and liquidity providers\n\t\tuint256 stakingRewardsAmount = ( remainingRewards * rewardsConfig.stakingRewardsPercent() ) / 100;\n\t\tuint256 liquidityRewardsAmount = remainingRewards - stakingRewardsAmount;\n\n\t\t_sendStakingRewards(stakingRewardsAmount);\n\t\t_sendLiquidityRewards(liquidityRewardsAmount, directRewardsForSaltUSDS, poolIDs, profitsForPools, totalProfits);\n\t\t}\n\t}"
    }
  ]
}