{
  "Title": "[L-02] Divide before multiply",
  "Content": "- Severity: Low\n- Confidence: Medium\n\n### Description\nSolidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.\n\n<details>\n\n<summary>\nThere are 2 instances of this issue:\n\n</summary>\n\n###\n- File: solidity/contracts/core/AMPHClaimer.sol\n```\n \nLine: 202          function _calculate(uint256 _tokenAmountToSend) internal view returns (uint256 _amphAmount) \n```\n\nperforms a multiplication on the result of a division:<br>\n- File: solidity/contracts/core/AMPHClaimer.sol\n\n```\n \nLine: 222          _amphForThisTurn = ((_rate * _tempAmountReceived) / 1e12) / 1e6\n```\n\n- File: solidity/contracts/core/AMPHClaimer.sol\n```\n \nLine: 241          _amphToMint += (_amphForThisTurn * 1e12)\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/AMPHClaimer.sol#L202-L246](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/AMPHClaimer.sol#L202-L246)\n\n- File: solidity/contracts/utils/ThreeLines0_100.sol\n```\n \nLine: 76          function _linearInterpolation(\n    int256 _rise,\n    int256 _run,\n    int256 _distance,\n    int256 _b\n  ) private pure returns (int256 _result) \n```\n\nperforms a multiplication on the result of a division:<br>\n- File: solidity/contracts/utils/ThreeLines0_100.sol\n```\n \nLine: 83          int256 _mE6 = (_rise * 1e6) / _run\n```\n\n- File: solidity/contracts/utils/ThreeLines0_100.sol\n```\n \nLine: 86          _result = (_mE6 * _distance) / 1e6 + _b\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/ThreeLines0_100.sol#L76-L88](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/ThreeLines0_100.sol#L76-L88)\n\n</details>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/AMPHClaimer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {SafeERC20, IERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\n\n/// @notice AMPHClaimer contract, used to exchange CVX and CRV at a fixed rate for AMPH\ncontract AMPHClaimer is IAMPHClaimer, Ownable {\n  using SafeERC20 for IERC20;\n\n  uint256 internal constant _BASE = 1 ether;\n\n  /// @dev Constant used in the formula\n  uint256 internal constant _FIFTY_MILLIONS = 50_000_000 * 1e6;\n\n  /// @dev Constant used in the formula\n  uint256 internal constant _TWENTY_FIVE_THOUSANDS = 25_000 * 1e6;\n\n  /// @dev Constant used in the formula\n  uint256 internal constant _FIFTY = 50 * 1e6;\n\n  /// @dev The base supply of AMPH per cliff, denominated in 1e6\n  uint256 public constant BASE_SUPPLY_PER_CLIFF = 8_000_000 * 1e6;\n\n  /// @dev The total number of cliffs (for both tokens)\n  uint256 public constant TOTAL_CLIFFS = 1000;\n\n  /// @dev The CVX token\n  IERC20 public immutable CVX;\n\n  /// @dev The CRV token\n  IERC20 public immutable CRV;\n\n  /// @dev The AMPH token\n  IERC20 public immutable AMPH;\n\n  /// @dev The total amount of AMPH minted for rewards in CRV, denominated in 1e6\n  uint256 public distributedAmph;\n\n  /// @dev Percentage of rewards taken in CVX (1e18 == 100%)\n  uint256 public cvxRewardFee;\n\n  /// @dev Percentage of rewards taken in CRV (1e18 == 100%)\n  uint256 public crvRewardFee;\n\n  /// @dev The vault controller\n  IVaultController public vaultController;\n\n  constructor(\n    address _vaultController,\n    IERC20 _amph,\n    IERC20 _cvx,\n    IERC20 _crv,\n    uint256 _cvxRewardFee,\n    uint256 _crvRewardFee\n  ) {\n    vaultController = IVaultController(_vaultController);\n    CVX = _cvx;\n    CRV = _crv;\n    AMPH = _amph;\n\n    cvxRewardFee = _cvxRewardFee;\n    crvRewardFee = _crvRewardFee;\n  }\n\n  /// @notice Claims an amount of AMPH given a CVX and CRV quantity\n  /// @param _vaultId The vault id that is claiming\n  /// @param _cvxTotalRewards The max CVX amount to exchange from the sender\n  /// @param _crvTotalRewards The max CVR amount to exchange from the sender\n  /// @param _beneficiary The receiver of the AMPH rewards\n  /// @return _cvxAmountToSend The amount of CVX that the treasury got\n  /// @return _crvAmountToSend The amount of CRV that the treasury got\n  /// @return _claimedAmph The amount of AMPH received by the beneficiary\n  function claimAmph(\n    uint96 _vaultId,\n    uint256 _cvxTotalRewards,\n    uint256 _crvTotalRewards,\n    address _beneficiary\n  ) external override returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimedAmph) {\n    (_cvxAmountToSend, _crvAmountToSend, _claimedAmph) =\n      _claimable(msg.sender, _vaultId, _cvxTotalRewards, _crvTotalRewards);\n\n    /// Update the state\n    if (_crvAmountToSend != 0 && _claimedAmph != 0) distributedAmph += (_claimedAmph / 1e12); // scale back to 1e6\n\n    CVX.safeTransferFrom(msg.sender, owner(), _cvxAmountToSend);\n    CRV.safeTransferFrom(msg.sender, owner(), _crvAmountToSend);\n\n    // transfer AMPH token to minter\n    AMPH.safeTransfer(_beneficiary, _claimedAmph);\n\n    emit ClaimedAmph(msg.sender, _cvxAmountToSend, _crvAmountToSend, _claimedAmph);\n  }\n\n  /// @notice Returns the claimable amount of AMPH given a CVX and CRV quantity\n  /// @param _sender The address of the account claiming\n  /// @param _vaultId The vault id that is claiming\n  /// @param _cvxTotalRewards The max CVX amount to exchange from the sender\n  /// @param _crvTotalRewards The max CVR amount to exchange from the sender\n  /// @return _cvxAmountToSend The amount of CVX the user will have to send\n  /// @return _crvAmountToSend The amount of CRV the user will have to send\n  /// @return _claimableAmph The amount of AMPH that would be received by the beneficiary\n  function claimable(\n    address _sender,\n    uint96 _vaultId,\n    uint256 _cvxTotalRewards,\n    uint256 _crvTotalRewards\n  ) external view override returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimableAmph) {\n    (_cvxAmountToSend, _crvAmountToSend, _claimableAmph) =\n      _claimable(_sender, _vaultId, _cvxTotalRewards, _crvTotalRewards);\n  }\n\n  /// @notice Used by governance to change the vault controller\n  /// @param _newVaultController The new vault controller\n  function changeVaultController(address _newVaultController) external override onlyOwner {\n    vaultController = IVaultController(_newVaultController);\n\n    emit ChangedVaultController(_newVaultController);\n  }\n\n  /// @notice Used by governance to recover tokens from the contract\n  /// @param _token The token to recover\n  /// @param _amount The amount to recover\n  function recoverDust(address _token, uint256 _amount) external override onlyOwner {\n    IERC20(_token).transfer(owner(), _amount);\n\n    emit RecoveredDust(_token, owner(), _amount);\n  }\n\n  /// @notice Used by governance to change the fee taken from the CVX reward\n  /// @param _newFee The new reward fee\n  function changeCvxRewardFee(uint256 _newFee) external override onlyOwner {\n    cvxRewardFee = _newFee;\n\n    emit ChangedCvxRewardFee(_newFee);\n  }\n\n  /// @notice Used by governance to change the fee taken from the CRV reward\n  /// @param _newFee The new reward fee\n  function changeCrvRewardFee(uint256 _newFee) external override onlyOwner {\n    crvRewardFee = _newFee;\n\n    emit ChangedCrvRewardFee(_newFee);\n  }\n\n  /// @dev Receives a total and a percentage, returns the amount equivalent of the percentage\n  function _totalToFraction(uint256 _total, uint256 _fraction) internal pure returns (uint256 _amount) {\n    if (_total == 0) return 0;\n    _amount = (_total * _fraction) / _BASE;\n  }\n\n  /// @dev Doesn't revert but returns 0 so the vault contract doesn't revert on calling the claim function\n  /// @dev Returns the claimable amount of AMPH, also the CVX and CRV the contract will take from the user\n  function _claimable(\n    address _sender,\n    uint96 _vaultId,\n    uint256 _cvxTotalRewards,\n    uint256 _crvTotalRewards\n  ) internal view returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimableAmph) {\n    if (_sender != vaultController.vaultIdVaultAddress(_vaultId)) return (0, 0, 0);\n\n    uint256 _amphBalance = AMPH.balanceOf(address(this));\n\n    // if amounts are zero, or AMPH balance is zero simply return all zeros\n    if (_crvTotalRewards == 0 || _amphBalance == 0) return (0, 0, 0);\n\n    uint256 _cvxRewardsFeeToExchange = _totalToFraction(_cvxTotalRewards, cvxRewardFee);\n    uint256 _crvRewardsFeeToExchange = _totalToFraction(_crvTotalRewards, crvRewardFee);\n\n    uint256 _amphByCrv = _calculate(_crvRewardsFeeToExchange);\n\n    // Check if all cliffs consumed\n    if (_getCliff((_amphByCrv / 1e12) + distributedAmph) >= TOTAL_CLIFFS) return (0, 0, 0);\n\n    // check for rounding errors\n    if (_amphByCrv == 0) return (0, 0, 0);\n\n    if (_amphBalance >= _amphByCrv) {\n      // contract has the full amount\n      _cvxAmountToSend = _cvxRewardsFeeToExchange;\n      _crvAmountToSend = _crvRewardsFeeToExchange;\n      _claimableAmph = _amphByCrv;\n    } else {\n      // contract doesnt have the full amount\n      return (0, 0, 0);\n    }\n  }\n\n  /// @dev Returns the rate of the token, denominated in 1e6\n  function _getRate(uint256 _distributedAmph) internal pure returns (uint256 _rate) {\n    uint256 _foo = (_TWENTY_FIVE_THOUSANDS * BASE_SUPPLY_PER_CLIFF) / Math.max(_distributedAmph, _FIFTY_MILLIONS);\n    uint256 _bar = (_distributedAmph * 1e12) / (BASE_SUPPLY_PER_CLIFF * _FIFTY);\n\n    _rate = 1e6 + (_foo - _bar);\n  }\n\n  /// @dev Returns how much AMPH would be minted given a token amount\n  function _calculate(uint256 _tokenAmountToSend) internal view returns (uint256 _amphAmount) {\n    if (_tokenAmountToSend == 0) return 0;\n\n    uint256 _tempAmountReceived = _tokenAmountToSend; // CRV, 1e18\n    uint256 _amphToMint; // 1e18\n\n    uint256 _distributedAmph = distributedAmph;\n\n    while (_tempAmountReceived > 0) {\n      uint256 _amphForThisTurn;\n\n      // all cliffs start when a certain amount of CRV is accumulated and finish when a certain amount is reached, this is the start of the current cliff\n      uint256 _bottomLastCliff = _getCliff(_distributedAmph) * BASE_SUPPLY_PER_CLIFF;\n\n      // get rate\n      uint256 _rate = _getRate(_distributedAmph); // 1e6\n\n      // calculate how many AMPH to mint given that rate.\n      // transform the CRV amount to 1e6 and multiply.\n      // perform the mul first to avoid rounding errors.\n      _amphForThisTurn = ((_rate * _tempAmountReceived) / 1e12) / 1e6; // 1e6\n\n      // calculate the amph available for this cliff\n      uint256 _amphAvailableForThisCliff = (_bottomLastCliff + BASE_SUPPLY_PER_CLIFF) - _distributedAmph; // 1e6\n\n      // check if the amount of amph to mint surpasses the cliff\n      if (_amphAvailableForThisCliff < _amphForThisTurn) {\n        /// surpassing the cliff\n        _amphForThisTurn = _amphAvailableForThisCliff;\n        // calculate how many CRV are entering this cliff\n        uint256 _amountTokenToEnter = (_amphAvailableForThisCliff * 1e18) / _rate;\n        _tempAmountReceived -= _amountTokenToEnter;\n      } else {\n        /// within the cliff\n        _tempAmountReceived = 0;\n      }\n\n      _distributedAmph += _amphForThisTurn; // 1e6\n\n      _amphToMint += (_amphForThisTurn * 1e12); // 1e18\n    }\n\n    // return\n    _amphAmount = _amphToMint;\n  }\n\n  /// @dev Returns the current cliff, it will round down but is on purpose\n  function _getCliff(uint256 _distributedAmph) internal pure returns (uint256 _cliff) {\n    _cliff = _distributedAmph / BASE_SUPPLY_PER_CLIFF;\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/utils/ThreeLines0_100.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ICurveSlave} from '@interfaces/utils/ICurveSlave.sol';\n\n/// @title Piecewise linear curve f(x)\n/// @notice returns values for input values 0 to 1e18,\n/// described by variables R0, R1, and R2, along with S1 and S2\n/// graph of function appears below code\n// solhint-disable-next-line contract-name-camelcase\ncontract ThreeLines0_100 is ICurveSlave {\n  /// @notice Thrown when the curve is invalid\n  error ThreeLines0_100_InvalidCurve();\n\n  /// @notice Thrown when the breakpoint values are invalid\n  error ThreeLines0_100_InvalidBreakpointValues();\n\n  /// @notice Thrown when the input value is too small\n  error ThreeLines0_100_InputTooSmall();\n\n  int256 public immutable R0;\n  int256 public immutable R1;\n  int256 public immutable R2;\n  int256 public immutable S1;\n  int256 public immutable S2;\n\n  /// @notice curve is constructed on deploy and may not be modified\n  /// @param _r0 y value at x=0\n  /// @param _r1 y value at the x=S1\n  /// @param _r2 y value at x >= S2 && x < 1e18\n  /// @param _s1 x value of first breakpoint\n  /// @param _s2 x value of second breakpoint\n  constructor(int256 _r0, int256 _r1, int256 _r2, int256 _s1, int256 _s2) {\n    if (!((0 < _r2) && (_r2 < _r1) && (_r1 < _r0))) revert ThreeLines0_100_InvalidCurve();\n    if (!((0 < _s1) && (_s1 < _s2) && (_s2 < 1e18))) revert ThreeLines0_100_InvalidBreakpointValues();\n\n    R0 = _r0;\n    R1 = _r1;\n    R2 = _r2;\n    S1 = _s1;\n    S2 = _s2;\n  }\n\n  /// @notice calculates f(x)\n  /// @param _xValue x value to evaluate\n  /// @return _value value of f(x)\n  function valueAt(int256 _xValue) external view override returns (int256 _value) {\n    // the x value must be between 0 (0%) and 1e18 (100%)\n    if (_xValue < 0) revert ThreeLines0_100_InputTooSmall();\n\n    if (_xValue > 1e18) _xValue = 1e18;\n\n    // first piece of the piece wise function\n    if (_xValue < S1) {\n      int256 _rise = R1 - R0;\n      int256 _run = S1;\n      return _linearInterpolation(_rise, _run, _xValue, R0);\n    }\n    // second piece of the piece wise function\n    if (_xValue < S2) {\n      int256 _rise = R2 - R1;\n      int256 _run = S2 - S1;\n      return _linearInterpolation(_rise, _run, _xValue - S1, R1);\n    }\n    // the third and final piece of piecewise function, simply a line\n    // since we already know that _xValue <= 1e18, this is safe\n    return R2;\n  }\n\n  /// @notice linear interpolation, calculates g(x) = (_rise/_run)x+b\n  /// @param _rise x delta, used to calculate, '_rise' in our equation\n  /// @param _run y delta, used to calculate '_run' in our equation\n  /// @param _distance distance to interpolate. 'x' in our equation\n  /// @param _b y intercept, 'b' in our equation\n  /// @return _result value of g(x)\n  function _linearInterpolation(\n    int256 _rise,\n    int256 _run,\n    int256 _distance,\n    int256 _b\n  ) private pure returns (int256 _result) {\n    // 6 digits of precision should be more than enough\n    int256 _mE6 = (_rise * 1e6) / _run;\n    // simply multiply the slope by the distance traveled and add the intercept\n    // don't forget to unscale the 1e6 by dividing. b is never scaled, and so it is not unscaled\n    _result = (_mE6 * _distance) / 1e6 + _b;\n    return _result;\n  }\n}\n/// (0, R0)\n///      |\\\n///      | -\\\n///      |   \\\n///      |    -\\\n///      |      -\\\n///      |        \\\n///      |         -\\\n///      |           \\\n///      |            -\\\n///      |              -\\\n///      |                \\\n///      |                 -\\\n///      |                   \\\n///      |                    -\\\n///      |                      -\\\n///      |                        \\\n///      |                         -\\\n///      |                          ***----\\\n///      |                     (S1, R1)   ----\\\n///      |                                       ----\\\n///      |                                            ----\\\n///      |                                                 ----\\ (S2, R2)\n///      |                                                             ***--------------------------------------------------------------\\\n///      |\n///      |\n///      |\n///      |\n///      +---------------------------------------------------------------------------------------------------------------------------------\n/// (0,0)                                                                                                                            (100, R2)"
    }
  ]
}