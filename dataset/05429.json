{
  "Title": "[M-08] Repayers using EOA accounts can be affected if bad debt is generated when they are repaying loans",
  "Content": "\nRepayers using EOA accounts will need to spend more PeggedTokens than what they should to get the needed CreditTokens to repay a loan if the market accrues bad debt while the repayer is doing the repayment.\n\n### Proof of Concept\n\nWhen repaying loans, the [`LendingTerm::_repay()` function](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L625) computes the total `loanDebt` to be repaid (includes interest). It pulls the CreditTokens from the repayer the computed value of the `loanDebt`, then distributes interest, burns the principal, updates the issuance and finally transfers back the borrower's collateral to the borrower.\n\nThe problem is that this existing implementation forces the repayer to mint in advance the amount of `loanDebt` to be repaid. The thing is that EOA accounts can't do the minting of the required CreditTokens and also repay the loan in the same transaction. EOA accounts will first mint the CreditTokens and then will send a separate tx to repay the loan. If bad debt is generated in the system and the `creditMultiplier` is decremented (between the time when tx of the repayer to mint the CreditTokens and when the tx to repay the loan is actually executed), the repayer will be impacted by the bad debt, because the amount of minted CreditTokens won't be enough to cover the new value that will be computed for the `loanDebt` (since the `creditMultiplier` shrank, more CreditTokens will be required to cover the same debt). This will cause the tx to repay the loan to revert, since the repayer won't have enough CreditTokens in its balance.\n\nMore importantly, now, the repayer will be forced to mint more CreditTokens; which means the repayer will need to spend more PeggedTokens to mint the extra CreditTokens that are required to cover the new value of the `loanDebt`. That means the repayer was impacted by the bad debt that was generated in the system. The design of the protocol is such that bad debt is covered by stakers, surplus buffer, and CreditToken holders. However, it is important to make a distinction between a holder who is holding the CreditTokens expecting a return on his investments, and a repayer who was forced to mint CreditTokens before repaying his loan. Repayers are already paying interests and fees, it is not fair to impact them if bad debt is generated in the system while they are repaying their loans.\n\nLet's run some numbers to demonstrate the impact of this current implementation.\n\n1. Assume `creditMultiplier` is 1e18 (has not been updated), UserA borrowed 100 CreditTokens and the current value of the `loanDebt` to repay the loan is 120 CreditTokens to cover the interests and fees.\n2. UserA goes to the PSM module and deposits 120 PeggedTokens in exchange for 120 CreditTokens.\n3. The user now goes ahead to call the `repay()` to repay his loan. Before the UserA tx to repay the loan is executed, some loans accrue bad debt in the system and cause the `creditMultiplier` to shrink to 0.9e18.\n4. Now, when the user tx is finally executed, the new value of the `loanDebt` will be `~133 CreditTokens`. This will cause the tx to revert because UserA only minted the required amount of `loanDebt` which was 120 CreditTokens.\n5. Now, the user will need to go again to the PSM module to mint the extra CreditTokens and will need to spend more collateral to mint those extra CreditTokens (`~14` more PeggedToken).\n\nAs a result of the current implementation, UserA was forced to spend more PeggedTokens to repay his debt. If we assume CreditTokens are gUSDC and PeggedTokens are USDC, now, to repay the loan, the UserA was forced to spend `~134` USDC instead of 120USDC that is the real value of the debt to be repaid.\n\nIn LendingTerm.sol:\n\n```solidity\n\n//@audit-issue => A repayer could compute how much CreditTokens are required to repay a loan by calling this function, the computed value will be based on the current value of the creditMultiplier\n//@audit-issue => The repayer would then go and mint the amount returned by this function before calling the `repay()` to finally repay his loan\n\n/// @notice outstanding borrowed amount of a loan, including interests\nfunction getLoanDebt(bytes32 loanId) public view returns (uint256) {\n    ...\n\n    // compute interest owed\n    uint256 borrowAmount = loan.borrowAmount;\n    uint256 interest = (borrowAmount *\n        params.interestRate *\n        (block.timestamp - borrowTime)) /\n        YEAR /\n        1e18;\n    uint256 loanDebt = borrowAmount + interest;\n    uint256 _openingFee = params.openingFee;\n    if (_openingFee != 0) {\n        loanDebt += (borrowAmount * _openingFee) / 1e18;\n    }\n    uint256 creditMultiplier = ProfitManager(refs.profitManager)\n        .creditMultiplier();\n    \n    //@audit-info => The loanDebt is normalized using the current value of the `creditMultiplier`. loanDebt includes interests and fees accrued by the original borrowAmount\n    loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;\n\n    return loanDebt;\n}\n\n\n//@audit-issue => The problem when repaying the loan is if bad debt was generated in the system, now, the value of the `creditMultiplier` will be slightly lower than when the user queried the total amount of CreditTokens to be repaid by calling the `getLoanDebt()`\n\nfunction _repay(address repayer, bytes32 loanId) internal {\n    ...\n    ...\n    ...\n\n    // compute interest owed\n    //@audit-issue => Now, when repaying the loan, the creditMultiplier will be different, thus, the computed value of the loanDebt will be greater than before, thus, more CreditTokens will be required to repay the same loan\n    uint256 loanDebt = getLoanDebt(loanId);\n    uint256 borrowAmount = loan.borrowAmount;\n    uint256 creditMultiplier = ProfitManager(refs.profitManager)\n        .creditMultiplier();\n    uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /\n        creditMultiplier;\n    uint256 interest = loanDebt - principal;\n\n    //@audit-issue => The amount of `loanDebt` CreditTokens are pulled from the repayer, this means, the repayer must have already minted the CreditTokens and it also granted enough allowance to the LendingTerm contract to spend on his behalf!\n    /// pull debt from the borrower and replenish the buffer of available debt that can be minted.\n    CreditToken(refs.creditToken).transferFrom(\n        repayer,\n        address(this),\n        loanDebt\n    );\n\n    ...\n    ...\n    ...\n}\n```\n\n### Recommended Mitigation Steps\n\nThe most straightforward solution to mitigate this problem is to allow the repayers to mint the exact required amount of CreditTokens to repay their loans within the same tx when the loan is actually being repaid. It can be added as an option for any repayer who wants to go that route and protect themselves against bad debt generated in the system while they are repaying their loans.\n \nThose who don't want to mint the exact amount of CreditTokens that are required to repay the loan can follow the current implementation where the CreditTokens will be pulled from their balance. If enabled, the LendingTerm based on the computed `loanDebt` will pull the exact amount of PeggedTokens that are required to mint the exact amount of CreditTokens to repay the loan, and by using the PSM module, the LendingTerm will mint the exact required amount of CreditTokens and will transfer the PeggedTokens that were pulled from the repayer.\n\nLendingTerm.sol\n\n```solidity\n+ function _repay(address repayer, bytes32 loanId, bool mintCreditTokens) internal {\n    ...\n\n    // compute interest owed\n    uint256 loanDebt = getLoanDebt(loanId);\n    ...    \n\n-   /// pull debt from the borrower and replenish the buffer of available debt that can be minted.\n-   CreditToken(refs.creditToken).transferFrom(\n-       repayer,\n-       address(this),\n-       loanDebt\n-   );\n\n+   if(mintCreditTokens) {\n+     //@audit-info => Computes the exact amount of peggedTokens that are required to repay the debt\n+     uint256 peggedTokensToRepay = SimplePSM(refs.psmModule).getRedeemAmountOut(loanDebt);\n+     address pegToken = SimplePSM(refs.psmModule).pegToken();\n\n+     //@audit-info => Pull the peggedTokens to repay the debt from the repayer into the LendingTerm\n+     ERC20(pegToken).safeTransferFrom(repayer, address(this), peggedTokensToRepay);\n\n+     //@audit-info => Mint the exact CreditTokens to repay the debt\n+     //@audit-info => The PSM module will pull the PeggedTokens from the LendingTerm and will mint the CreditTokens to the LendingTerm contract\n+     uint256 repaidCreditTokens = SimplePSM(refs.psmModule).mint(peggedTokensToRepay);\n\n+     assert(repaidCreditTokens == loanDebt)\n+   } else {\n+      /// Pull debt from the borrower and replenish the buffer of available debt that can be minted.\n+      CreditToken(refs.creditToken).transferFrom(\n+          repayer,\n+          address(this),\n+          loanDebt\n+      );\n+   }\n\n    if (interest != 0) {\n        // forward profit portion to the ProfitManager\n        CreditToken(refs.creditToken).transfer(\n            refs.profitManager,\n            interest\n        );\n\n        // report profit\n        ProfitManager(refs.profitManager).notifyPnL(\n            address(this),\n            int256(interest)\n        );\n    }\n\n    // burn loan principal\n    CreditToken(refs.creditToken).burn(principal);\n    RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);\n\n    // close the loan\n    loan.closeTime = block.timestamp;\n    issuance -= borrowAmount;\n\n    // return the collateral to the borrower\n    IERC20(params.collateralToken).safeTransfer(\n        loan.borrower,\n        loan.collateralAmount\n    );\n\n    // emit event\n    emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);\n}\n```\n\n### Assessed type\n\nContext\n\n**[eswak (Ethereum Credit Guild) confirmed and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1041#issuecomment-1895370454):**\n > This is interesting. I'm not sure whether to describe this as a vulnerability, since it is already in our plan to have a \"smart account\" or \"router\" tool for borrowers to atomically unwind their position/repay the exact correct amount according to the credit multiplier, that allows to multicall on `term.borrow+psm.redeem` and `psm.mint+term.repay` for instance. I can see how this feature could be made part of the base lending term, rather than something on top. Seems like a thoughtful consideration so I don't mind confirming.\n\n**[btk (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1041#issuecomment-1924015420):**\n > @TrungOre - I don't see how this is an issue. It's akin to saying that if token prices drop, repayments might increase slightly. The impact is limited and falls within the realm of crypto. Consider a lending protocol where users deposit ETH as collateral for a volatile asset loan. If, during partial repayment, the token's price drops between the minting and the actual loan repayment transaction, it's a crypto fluctuation, not a bug.\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1041#issuecomment-1924721726):**\n > @btk - The thing is that borrowers borrowed `CreditTokens` which their value is tight to the `creditMultiplier`, it is not tied to a specific market price. If a borrower borrowed a specific amount of CreditTokens it should repay the same amount of borrowed tokens + interest. In this case, if the `creditMultiplier` drops, this will force the borrower to buy more creditTokens than what they should really bought. Thus, the total amount of repaid debt will be bigger than what it really should. As I explained in the report, the existing implementation can cause users to end up paying more value for what they borrowed.\n> \n>  Important to emphasise that the drop of the `creditMultiplier` has nothing to do with the collateral that was used to back up the loan, that is a different thing. `creditMultiplier` only matters for the CreditToken and the PeggedToken.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/loan/LendingTerm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {AuctionHouse} from \"@src/loan/AuctionHouse.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice Lending Term contract of the Ethereum Credit Guild, a base implementation of\n/// smart contract issuing CREDIT debt and escrowing collateral assets.\n/// Note that interest rate is non-compounding and the percentage is expressed per\n/// period of `YEAR` seconds.\ncontract LendingTerm is CoreRef {\n    using SafeERC20 for IERC20;\n\n    // events for the lifecycle of loans that happen in the lending term\n    /// @notice emitted when new loans are opened (mint debt to borrower, pull collateral from borrower).\n    event LoanOpen(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount,\n        uint256 borrowAmount\n    );\n    /// @notice emitted when a loan is called.\n    event LoanCall(uint256 indexed when, bytes32 indexed loanId);\n    /// @notice emitted when a loan is closed (repay, onBid after a call, forgive).\n    enum LoanCloseType {\n        Repay,\n        Call,\n        Forgive\n    }\n    event LoanClose(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        LoanCloseType indexed closeType,\n        uint256 debtRepaid\n    );\n    /// @notice emitted when someone adds collateral to a loan\n    event LoanAddCollateral(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount\n    );\n    /// @notice emitted when someone partially repays a loan\n    event LoanPartialRepay(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed repayer,\n        uint256 repayAmount\n    );\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice timestamp of last partial repayment for a given loanId.\n    /// during borrow(), this is initialized to the borrow timestamp, if\n    /// maxDelayBetweenPartialRepay is != 0\n    mapping(bytes32 => uint256) public lastPartialRepay;\n\n    struct Loan {\n        address borrower; // address of a loan's borrower\n        uint256 borrowTime; // the time the loan was initiated\n        uint256 borrowAmount; // initial CREDIT debt of a loan\n        uint256 borrowCreditMultiplier; // creditMultiplier when loan was opened\n        uint256 collateralAmount; // balance of collateral token provided by the borrower\n        address caller; // a caller of 0 indicates that the loan has not been called\n        uint256 callTime; // a call time of 0 indicates that the loan has not been called\n        uint256 callDebt; // the CREDIT debt when the loan was called\n        uint256 closeTime; // the time the loan was closed (repaid or call+bid or forgive)\n    }\n\n    /// @notice the list of all loans that existed or are still active.\n    /// @dev see public getLoan(loanId) getter.\n    mapping(bytes32 => Loan) internal loans;\n\n    /// @notice current number of CREDIT issued in active loans on this term\n    /// @dev this can be lower than the sum of all loan's CREDIT debts because\n    /// interests accrue and some loans might have been opened before the creditMultiplier\n    /// was last updated, resulting in higher CREDIT debt than what was originally borrowed.\n    uint256 public issuance;\n\n    struct LendingTermReferences {\n        /// @notice reference to the ProfitManager\n        address profitManager;\n        /// @notice reference to the GUILD token\n        address guildToken;\n        /// @notice reference to the auction house contract used to\n        /// sell loan collateral for CREDIT if loans are called.\n        address auctionHouse;\n        /// @notice reference to the credit minter contract\n        address creditMinter;\n        /// @notice reference to the CREDIT token\n        address creditToken;\n    }\n\n    /// @notice References to other protocol contracts (see struct for more details)\n    LendingTermReferences internal refs;\n\n    struct LendingTermParams {\n        /// @notice reference to the collateral token\n        address collateralToken;\n        /// @notice max number of debt tokens issued per collateral token.\n        /// @dev be mindful of the decimals here, because if collateral\n        /// token doesn't have 18 decimals, this variable is used to scale\n        /// the decimals.\n        /// For example, for USDC collateral, this variable should be around\n        /// ~1e30, to allow 1e6 * 1e30 / 1e18 ~= 1e18 CREDIT to be borrowed for\n        /// each 1e6 units (1 USDC) of collateral, if CREDIT is targeted to be\n        /// worth around 1 USDC.\n        uint256 maxDebtPerCollateralToken;\n        /// @notice interest rate paid by the borrower, expressed as an APR\n        /// with 18 decimals (0.01e18 = 1% APR). The base for 1 year is the YEAR constant.\n        uint256 interestRate;\n        /// @notice maximum delay, in seconds, between partial debt repayments.\n        /// if set to 0, no periodic partial repayments are expected.\n        /// if a partial repayment is missed (delay has passed), the loan\n        /// can be called.\n        uint256 maxDelayBetweenPartialRepay;\n        /// @notice minimum percent of the total debt (principal + interests) to\n        /// repay during partial debt repayments.\n        /// percentage is expressed with 18 decimals, e.g. 0.05e18 = 5% debt.\n        uint256 minPartialRepayPercent;\n        /// @notice the opening fee is a percent of interest that instantly accrues\n        /// when the loan is opened.\n        /// The opening fee is expressed as a percentage of the borrowAmount, with 18\n        /// decimals, e.g. 0.05e18 = 5% of the borrowed amount.\n        /// A loan with 2% openingFee and 3% interestRate will owe 102% of the borrowed\n        /// amount just after being open, and after 1 year will owe 105%.\n        uint256 openingFee;\n        /// @notice the absolute maximum amount of debt this lending term can issue\n        /// at any given time, regardless of the gauge allocations.\n        uint256 hardCap;\n    }\n\n    /// @notice Params of the LendingTerm (see struct for more details)\n    LendingTermParams internal params;\n\n    constructor() CoreRef(address(1)) {\n        // core is set to address(1) to prevent implementation from being initialized,\n        // only proxies on the implementation can be initialized.\n    }\n\n    /// @notice initialize storage with references to other protocol contracts\n    /// and the lending term parameters for this instance.\n    function initialize(\n        address _core,\n        LendingTermReferences calldata _refs,\n        LendingTermParams calldata _params\n    ) external {\n        // can initialize only once\n        assert(address(core()) == address(0));\n        assert(_core != address(0));\n\n        // initialize storage\n        _setCore(_core);\n        refs = _refs;\n        params = _params;\n    }\n\n    /// @notice get references of this term to other protocol contracts\n    function getReferences()\n        external\n        view\n        returns (LendingTermReferences memory)\n    {\n        return refs;\n    }\n\n    /// @notice get parameters of this term\n    function getParameters() external view returns (LendingTermParams memory) {\n        return params;\n    }\n\n    /// @notice get parameter 'collateralToken' of this term\n    function collateralToken() external view returns (address) {\n        return params.collateralToken;\n    }\n\n    /// @notice get a loan\n    function getLoan(bytes32 loanId) external view returns (Loan memory) {\n        return loans[loanId];\n    }\n\n    /// @notice outstanding borrowed amount of a loan, including interests\n    function getLoanDebt(bytes32 loanId) public view returns (uint256) {\n        Loan storage loan = loans[loanId];\n        uint256 borrowTime = loan.borrowTime;\n\n        if (borrowTime == 0) {\n            return 0;\n        }\n\n        if (loan.closeTime != 0) {\n            return 0;\n        }\n\n        if (loan.callTime != 0) {\n            return loan.callDebt;\n        }\n\n        // compute interest owed\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 interest = (borrowAmount *\n            params.interestRate *\n            (block.timestamp - borrowTime)) /\n            YEAR /\n            1e18;\n        uint256 loanDebt = borrowAmount + interest;\n        uint256 _openingFee = params.openingFee;\n        if (_openingFee != 0) {\n            loanDebt += (borrowAmount * _openingFee) / 1e18;\n        }\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;\n\n        return loanDebt;\n    }\n\n    /// @notice returns true if the term has a maximum delay between partial repays\n    /// and the loan has passed the delay for partial repayments.\n    function partialRepayDelayPassed(\n        bytes32 loanId\n    ) public view returns (bool) {\n        // if no periodic partial repays are expected, always return false\n        if (params.maxDelayBetweenPartialRepay == 0) return false;\n\n        // if loan doesn't exist, return false\n        if (loans[loanId].borrowTime == 0) return false;\n\n        // if loan is closed, return false\n        if (loans[loanId].closeTime != 0) return false;\n\n        // return true if delay is passed\n        return\n            lastPartialRepay[loanId] <\n            block.timestamp - params.maxDelayBetweenPartialRepay;\n    }\n\n    /// @notice returns the maximum amount of debt that can be issued by this term\n    /// according to the current gauge allocations.\n    /// Note that the debt ceiling can be lower than the current issuance under 4 conditions :\n    /// - params.hardCap is lower than since last borrow happened\n    /// - gauge votes are fewer than when last borrow happened\n    /// - profitManager.totalBorrowedCredit() decreased since last borrow\n    /// - creditMinter.buffer() is close to being depleted\n    /// @dev this solves the following equation :\n    /// borrowAmount + issuance <=\n    /// (totalBorrowedCredit + borrowAmount) * gaugeWeight * gaugeWeightTolerance / totalWeight / 1e18\n    /// which is the formula to check debt ceiling in the borrow function.\n    /// This gives the maximum borrowable amount to achieve 100% utilization of the debt\n    /// ceiling, and if we add the current issuance to it, we get the current debt ceiling.\n    /// @param gaugeWeightDelta an hypothetical change in gauge weight\n    /// @return the maximum amount of debt that can be issued by this term\n    function debtCeiling(\n        int256 gaugeWeightDelta\n    ) public view returns (uint256) {\n        address _guildToken = refs.guildToken; // cached SLOAD\n        uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(\n            address(this)\n        );\n        gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);\n        uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this));\n        uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(\n            gaugeType\n        );\n        uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)\n            .buffer();\n        uint256 _hardCap = params.hardCap; // cached SLOAD\n        if (gaugeWeight == 0) {\n            return 0; // no gauge vote, 0 debt ceiling\n        } else if (gaugeWeight == totalWeight) {\n            // one gauge, unlimited debt ceiling\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 _issuance = issuance; // cached SLOAD\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        if (totalBorrowedCredit == 0 && gaugeWeight != 0) {\n            // first-ever CREDIT mint on a non-zero gauge weight term\n            // does not check the relative debt ceilings\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /\n            1e18;\n        uint256 debtCeilingBefore = (totalBorrowedCredit *\n            toleratedGaugeWeight) / totalWeight;\n        if (_issuance >= debtCeilingBefore) {\n            return debtCeilingBefore; // no more borrows allowed\n        }\n        uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; // always >0\n        if (toleratedGaugeWeight >= totalWeight) {\n            // if the gauge weight is above 100% when we include tolerance,\n            // the gauge relative debt ceilings are not constraining.\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; // always >0\n        uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /\n            otherGaugesWeight;\n        uint256 _debtCeiling = _issuance + maxBorrow;\n        // return min(creditMinterBuffer, hardCap, debtCeiling)\n        if (creditMinterBuffer < _debtCeiling) {\n            return creditMinterBuffer;\n        }\n        if (_hardCap < _debtCeiling) {\n            return _hardCap;\n        }\n        return _debtCeiling;\n    }\n\n    /// @notice returns the debt ceiling without change to gauge weight\n    function debtCeiling() external view returns (uint256) {\n        return debtCeiling(0);\n    }\n\n    /// @notice initiate a new loan\n    function _borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) internal returns (bytes32 loanId) {\n        require(borrowAmount != 0, \"LendingTerm: cannot borrow 0\");\n        require(collateralAmount != 0, \"LendingTerm: cannot stake 0\");\n\n        loanId = keccak256(\n            abi.encode(borrower, address(this), block.timestamp)\n        );\n\n        // check that the loan doesn't already exist\n        require(loans[loanId].borrowTime == 0, \"LendingTerm: loan exists\");\n\n        // check that enough collateral is provided\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 maxBorrow = (collateralAmount *\n            params.maxDebtPerCollateralToken) / creditMultiplier;\n        require(\n            borrowAmount <= maxBorrow,\n            \"LendingTerm: not enough collateral\"\n        );\n\n        // check that enough CREDIT is borrowed\n        require(\n            borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),\n            \"LendingTerm: borrow amount too low\"\n        );\n\n        // check the hardcap\n        uint256 _issuance = issuance;\n        uint256 _postBorrowIssuance = _issuance + borrowAmount;\n        require(\n            _postBorrowIssuance <= params.hardCap,\n            \"LendingTerm: hardcap reached\"\n        );\n\n        // check the debt ceiling\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        uint256 _debtCeiling = (GuildToken(refs.guildToken)\n            .calculateGaugeAllocation(\n                address(this),\n                totalBorrowedCredit + borrowAmount\n            ) * gaugeWeightTolerance) / 1e18;\n        if (totalBorrowedCredit == 0) {\n            // if the lending term is deprecated, `calculateGaugeAllocation` will return 0, and the borrow\n            // should revert because the debt ceiling is reached (no borrows should be allowed anymore).\n            // first borrow in the system does not check proportions of issuance, just that the term is not deprecated.\n            require(_debtCeiling != 0, \"LendingTerm: debt ceiling reached\");\n        } else {\n            require(\n                _postBorrowIssuance <= _debtCeiling,\n                \"LendingTerm: debt ceiling reached\"\n            );\n        }\n\n        // save loan in state\n        loans[loanId] = Loan({\n            borrower: borrower,\n            borrowTime: block.timestamp,\n            borrowAmount: borrowAmount,\n            borrowCreditMultiplier: creditMultiplier,\n            collateralAmount: collateralAmount,\n            caller: address(0),\n            callTime: 0,\n            callDebt: 0,\n            closeTime: 0\n        });\n        issuance = _postBorrowIssuance;\n        if (params.maxDelayBetweenPartialRepay != 0) {\n            lastPartialRepay[loanId] = block.timestamp;\n        }\n\n        // mint debt to the borrower\n        RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralAmount\n        );\n\n        // emit event\n        emit LoanOpen(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralAmount,\n            borrowAmount\n        );\n    }\n\n    /// @notice initiate a new loan\n    function borrow(\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) external whenNotPaused returns (bytes32 loanId) {\n        loanId = _borrow(msg.sender, borrowAmount, collateralAmount);\n    }\n\n    /// @notice add collateral on an open loan.\n    /// a borrower might want to add collateral so that his position does not go underwater due to\n    /// interests growing up over time.\n    function _addCollateral(\n        address borrower,\n        bytes32 loanId,\n        uint256 collateralToAdd\n    ) internal {\n        require(collateralToAdd != 0, \"LendingTerm: cannot add 0\");\n\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // update loan in state\n        loans[loanId].collateralAmount += collateralToAdd;\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralToAdd\n        );\n\n        // emit event\n        emit LoanAddCollateral(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralToAdd\n        );\n    }\n\n    /// @notice add collateral on an open loan.\n    function addCollateral(bytes32 loanId, uint256 collateralToAdd) external {\n        _addCollateral(msg.sender, loanId, collateralToAdd);\n    }\n\n    /// @notice partially repay an open loan.\n    /// a borrower might want to partially repay debt so that his position does not go underwater\n    /// due to interests building up.\n    /// some lending terms might also impose periodic partial repayments.\n    function _partialRepay(\n        address repayer,\n        bytes32 loanId,\n        uint256 debtToRepay\n    ) internal {\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        uint256 borrowTime = loan.borrowTime;\n        require(borrowTime != 0, \"LendingTerm: loan not found\");\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // compute partial repayment\n        uint256 loanDebt = getLoanDebt(loanId);\n        require(debtToRepay < loanDebt, \"LendingTerm: full repayment\");\n        uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; // [0, 1e18[\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /\n            creditMultiplier;\n        uint256 principalRepaid = (principal * percentRepaid) / 1e18;\n        uint256 interestRepaid = debtToRepay - principalRepaid;\n        uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;\n        require(\n            principalRepaid != 0 && interestRepaid != 0,\n            \"LendingTerm: repay too small\"\n        );\n        require(\n            debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,\n            \"LendingTerm: repay below min\"\n        );\n        require(\n            borrowAmount - issuanceDecrease >\n                ProfitManager(refs.profitManager).minBorrow(),\n            \"LendingTerm: below min borrow\"\n        );\n\n        // update loan in state\n        loans[loanId].borrowAmount -= issuanceDecrease;\n        lastPartialRepay[loanId] = block.timestamp;\n        issuance -= issuanceDecrease;\n\n        // pull the debt from the borrower\n        CreditToken(refs.creditToken).transferFrom(\n            repayer,\n            address(this),\n            debtToRepay\n        );\n\n        // forward profit portion to the ProfitManager, burn the rest\n        CreditToken(refs.creditToken).transfer(\n            refs.profitManager,\n            interestRepaid\n        );\n        ProfitManager(refs.profitManager).notifyPnL(\n            address(this),\n            int256(interestRepaid)\n        );\n        CreditToken(refs.creditToken).burn(principalRepaid);\n        RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);\n\n        // emit event\n        emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);\n    }\n\n    /// @notice partially repay an open loan.\n    function partialRepay(bytes32 loanId, uint256 debtToRepay) external {\n        _partialRepay(msg.sender, loanId, debtToRepay);\n    }\n\n    /// @notice repay an open loan\n    function _repay(address repayer, bytes32 loanId) internal {\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        uint256 borrowTime = loan.borrowTime;\n        require(borrowTime != 0, \"LendingTerm: loan not found\");\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // compute interest owed\n        uint256 loanDebt = getLoanDebt(loanId);\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /\n            creditMultiplier;\n        uint256 interest = loanDebt - principal;\n\n        /// pull debt from the borrower and replenish the buffer of available debt that can be minted.\n        CreditToken(refs.creditToken).transferFrom(\n            repayer,\n            address(this),\n            loanDebt\n        );\n        if (interest != 0) {\n            // forward profit portion to the ProfitManager\n            CreditToken(refs.creditToken).transfer(\n                refs.profitManager,\n                interest\n            );\n\n            // report profit\n            ProfitManager(refs.profitManager).notifyPnL(\n                address(this),\n                int256(interest)\n            );\n        }\n\n        // burn loan principal\n        CreditToken(refs.creditToken).burn(principal);\n        RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);\n\n        // close the loan\n        loan.closeTime = block.timestamp;\n        issuance -= borrowAmount;\n\n        // return the collateral to the borrower\n        IERC20(params.collateralToken).safeTransfer(\n            loan.borrower,\n            loan.collateralAmount\n        );\n\n        // emit event\n        emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);\n    }\n\n    /// @notice repay an open loan\n    function repay(bytes32 loanId) external {\n        _repay(msg.sender, loanId);\n    }\n\n    /// @notice call a loan, the collateral will be auctioned to repay outstanding debt.\n    /// Loans can be called only if the term has been offboarded or if a loan missed a periodic partialRepay.\n    function _call(\n        address caller,\n        bytes32 loanId,\n        address _auctionHouse\n    ) internal {\n        Loan storage loan = loans[loanId];\n\n        // check that the loan exists\n        uint256 borrowTime = loan.borrowTime;\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n\n        // check that the loan is not already closed\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n\n        // check that the loan is not already called\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // check that the loan can be called\n        require(\n            GuildToken(refs.guildToken).isDeprecatedGauge(address(this)) ||\n                partialRepayDelayPassed(loanId),\n            \"LendingTerm: cannot call\"\n        );\n\n        // check that the loan has been running for at least 1 block\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n\n        // update loan in state\n        uint256 loanDebt = getLoanDebt(loanId);\n        loans[loanId].callTime = block.timestamp;\n        loans[loanId].callDebt = loanDebt;\n        loans[loanId].caller = caller;\n\n        // auction the loan collateral\n        AuctionHouse(_auctionHouse).startAuction(loanId, loanDebt);\n\n        // emit event\n        emit LoanCall(block.timestamp, loanId);\n    }\n\n    /// @notice call a single loan\n    function call(bytes32 loanId) external {\n        _call(msg.sender, loanId, refs.auctionHouse);\n    }\n\n    /// @notice call a list of loans\n    function callMany(bytes32[] memory loanIds) public {\n        address _auctionHouse = refs.auctionHouse;\n        for (uint256 i = 0; i < loanIds.length; i++) {\n            _call(msg.sender, loanIds[i], _auctionHouse);\n        }\n    }\n\n    /// @notice forgive a loan, marking its debt as a total loss to the system.\n    /// The loan is closed (borrower keeps the CREDIT), and the collateral stays on the LendingTerm.\n    /// Governance can later unstuck the collateral through `emergencyAction`.\n    /// This function is made for emergencies where collateral is frozen or other reverting\n    /// conditions on collateral transfers that prevent regular repay() or call() loan closing.\n    function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        Loan storage loan = loans[loanId];\n\n        // check that the loan exists\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n\n        // check that the loan is not already closed\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n\n        // close the loan\n        loans[loanId].closeTime = block.timestamp;\n        issuance -= loan.borrowAmount;\n\n        // mark loan as a total loss\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 borrowAmount = loans[loanId].borrowAmount;\n        uint256 principal = (borrowAmount *\n            loans[loanId].borrowCreditMultiplier) / creditMultiplier;\n        int256 pnl = -int256(principal);\n        ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);\n\n        // set hardcap to 0 to prevent new borrows\n        params.hardCap = 0;\n\n        // emit event\n        emit LoanClose(block.timestamp, loanId, LoanCloseType.Forgive, 0);\n    }\n\n    /// @notice callback from the auctionHouse when au auction concludes\n    function onBid(\n        bytes32 loanId,\n        address bidder,\n        uint256 collateralToBorrower,\n        uint256 collateralToBidder,\n        uint256 creditFromBidder\n    ) external {\n        // preliminary checks\n        require(msg.sender == refs.auctionHouse, \"LendingTerm: invalid caller\");\n        require(\n            loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,\n            \"LendingTerm: loan not called\"\n        );\n        require(loans[loanId].closeTime == 0, \"LendingTerm: loan closed\");\n\n        // sanity check on collateral movement\n        // these should never fail for a properly implemented AuctionHouse contract\n        // collateralOut == 0 if forgive() while in auctionHouse\n        uint256 collateralOut = collateralToBorrower + collateralToBidder;\n        require(\n            collateralOut == loans[loanId].collateralAmount ||\n                collateralOut == 0,\n            \"LendingTerm: invalid collateral movements\"\n        );\n\n        // compute pnl\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 borrowAmount = loans[loanId].borrowAmount;\n        uint256 principal = (borrowAmount *\n            loans[loanId].borrowCreditMultiplier) / creditMultiplier;\n        int256 pnl;\n        uint256 interest;\n        if (creditFromBidder >= principal) {\n            interest = creditFromBidder - principal;\n            pnl = int256(interest);\n        } else {\n            pnl = int256(creditFromBidder) - int256(principal);\n            principal = creditFromBidder;\n            require(\n                collateralToBorrower == 0,\n                \"LendingTerm: invalid collateral movement\"\n            );\n        }\n\n        // save loan state\n        loans[loanId].closeTime = block.timestamp;\n\n        // pull credit from bidder\n        if (creditFromBidder != 0) {\n            CreditToken(refs.creditToken).transferFrom(\n                bidder,\n                address(this),\n                creditFromBidder\n            );\n        }\n\n        // burn credit principal, replenish buffer\n        if (principal != 0) {\n            CreditToken(refs.creditToken).burn(principal);\n            RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);\n        }\n\n        // handle profit & losses\n        if (pnl != 0) {\n            // forward profit, if any\n            if (interest != 0) {\n                CreditToken(refs.creditToken).transfer(\n                    refs.profitManager,\n                    interest\n                );\n            }\n            ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);\n        }\n\n        // decrease issuance\n        issuance -= borrowAmount;\n\n        // send collateral to borrower\n        if (collateralToBorrower != 0) {\n            IERC20(params.collateralToken).safeTransfer(\n                loans[loanId].borrower,\n                collateralToBorrower\n            );\n        }\n\n        // send collateral to bidder\n        if (collateralToBidder != 0) {\n            IERC20(params.collateralToken).safeTransfer(\n                bidder,\n                collateralToBidder\n            );\n        }\n\n        emit LoanClose(\n            block.timestamp,\n            loanId,\n            LoanCloseType.Call,\n            creditFromBidder\n        );\n    }\n\n    /// @notice set the address of the auction house.\n    /// governor-only, to allow full governance to update the auction mechanisms.\n    function setAuctionHouse(\n        address _newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        // allow configuration changes only when there are no auctions in progress.\n        // updating the auction house while auctions are in progress could break the loan\n        // lifecycle, as it would prevent the former auctionHouse (that have active auctions)\n        // from reporting the result to the lending term.\n        require(\n            AuctionHouse(refs.auctionHouse).nAuctionsInProgress() == 0,\n            \"LendingTerm: auctions in progress\"\n        );\n\n        refs.auctionHouse = _newValue;\n    }\n\n    /// @notice set the hardcap of CREDIT mintable in this term.\n    /// allows to update a term's arbitrary hardcap without doing a gauge & loans migration.\n    function setHardCap(\n        uint256 _newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        params.hardCap = _newValue;\n    }\n}"
    }
  ]
}