{
  "Title": "[L05] Pauser accounts can reset the pause period indefinitely",
  "Content": "The [`HoldefiPauser` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol) implements a pausable functionality for certain cases. [Each one of them](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L9-L16) are assigned to a specific index. Then, the timestamp of when a pause action has been triggered for a specific case is tracked in [the `paused` array](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L19) by using its index.\n\n\nThis feature provides child contracts with a system overhaul in cases that an unexpected event occurs and part of the code needs to be stopped. This feature can only [be called by the owner or the pauser](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L29), but on the other hand, the [`unpause` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L60) can only be called by the owner.\n\n\nNevertheless, if a particular functionality has been paused, in which [a `pauseDuration` should be waited](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L21) to have the paused functionality back, the pauser can re-call the [`pause` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L55) and reset the timer for that functionality, being possible to extend indefinitely the paused period. If this duality of having a bounded period that can be extended is the intended, the same could be implemented with a better design using a flag variable instead of a timestamp variable.\n\n\nConsider modifying the functionality to prevent multiple resets of the pause period by the pausers accounts, or documenting this if it is the expected behavior.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/HoldefiPauser.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\n// Taking ideas from Open Zeppelin's Pausable contract\r\ncontract HoldefiPauser is Ownable {    \r\n    address public pauser;\r\n\r\n     // '0' -> supply\r\n     // '1' -> withdrawSupply\r\n     // '2' -> collatralize\r\n     // '3' -> withdrawCollateral\r\n     // '4' -> borrow\r\n     // '5' -> repayBorrrow\r\n     // '6' -> liquidateBorrowerCollateral\r\n     // '7' -> buyLiquidatedCollateral\r\n    \r\n    uint constant functionsNum = 8;\r\n    uint[8] public paused;\r\n\r\n    uint public pauseDuration = 2592000;\r\n\r\n     \r\n    constructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\r\n    }\r\n\r\n    // Modifier to make a function callable only by owner or pauser   \r\n    modifier onlyPausers() {\r\n        require(msg.sender == owner || msg.sender == pauser , 'Sender should be Owner or Pauser');\r\n        _;\r\n    }\r\n    \r\n    // Modifier to make a function callable only when a functions is not paused.\r\n    modifier whenNotPaused(uint index) {\r\n        require(!isPause(index), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to make a function callable only when a functions is paused.\r\n    modifier whenPaused(uint index) {\r\n        require(isPause(index), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function isPause(uint index) public view returns(bool res) {\r\n        if (block.timestamp - paused[index] >= pauseDuration) {\r\n            res = false;\r\n        }\r\n        else {\r\n            res = true;\r\n        }\r\n    }\r\n    \r\n    // Called by pausers to pause, triggers stopped state.\r\n    function pause(uint index) public onlyPausers {\r\n        paused[index] = block.timestamp;\r\n    }\r\n\r\n    // Called by owner to unpause, returns to normal state.\r\n    function unpause(uint index) public onlyOwner {\r\n        paused[index] = 0;\r\n    }\r\n\r\n    // Called by pausers to pause, triggers stopped state for selected functions\r\n    function batchPause(bool[8] memory newPaused) public onlyPausers {\r\n        for (uint i=0; i<functionsNum; i++) {\r\n            if (newPaused[i] == true){\r\n                pause(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Called by pausers to pause, returns to normal state for selected functions\r\n    function batchUnpause(bool[8] memory newUnpaused) public onlyOwner {\r\n        for (uint i=0; i<functionsNum; i++) {\r\n            if (newUnpaused[i] == true){\r\n                unpause(i);\r\n            }\r\n        }\r\n    }\r\n    // Called by owner to set a new pauser\r\n    function setPauser(address newPauser) external onlyOwner {\r\n        pauser = newPauser;\r\n    }\r\n\r\n    function setPauseDuration(uint newPauseDuration) external onlyOwner {\r\n        pauseDuration = newPauseDuration;\r\n    }\r\n}"
    },
    {
      "filename": "contracts/HoldefiPauser.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\n// Taking ideas from Open Zeppelin's Pausable contract\r\ncontract HoldefiPauser is Ownable {    \r\n    address public pauser;\r\n\r\n     // '0' -> supply\r\n     // '1' -> withdrawSupply\r\n     // '2' -> collatralize\r\n     // '3' -> withdrawCollateral\r\n     // '4' -> borrow\r\n     // '5' -> repayBorrrow\r\n     // '6' -> liquidateBorrowerCollateral\r\n     // '7' -> buyLiquidatedCollateral\r\n    \r\n    uint constant functionsNum = 8;\r\n    uint[8] public paused;\r\n\r\n    uint public pauseDuration = 2592000;\r\n\r\n     \r\n    constructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\r\n    }\r\n\r\n    // Modifier to make a function callable only by owner or pauser   \r\n    modifier onlyPausers() {\r\n        require(msg.sender == owner || msg.sender == pauser , 'Sender should be Owner or Pauser');\r\n        _;\r\n    }\r\n    \r\n    // Modifier to make a function callable only when a functions is not paused.\r\n    modifier whenNotPaused(uint index) {\r\n        require(!isPause(index), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to make a function callable only when a functions is paused.\r\n    modifier whenPaused(uint index) {\r\n        require(isPause(index), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function isPause(uint index) public view returns(bool res) {\r\n        if (block.timestamp - paused[index] >= pauseDuration) {\r\n            res = false;\r\n        }\r\n        else {\r\n            res = true;\r\n        }\r\n    }\r\n    \r\n    // Called by pausers to pause, triggers stopped state.\r\n    function pause(uint index) public onlyPausers {\r\n        paused[index] = block.timestamp;\r\n    }\r\n\r\n    // Called by owner to unpause, returns to normal state.\r\n    function unpause(uint index) public onlyOwner {\r\n        paused[index] = 0;\r\n    }\r\n\r\n    // Called by pausers to pause, triggers stopped state for selected functions\r\n    function batchPause(bool[8] memory newPaused) public onlyPausers {\r\n        for (uint i=0; i<functionsNum; i++) {\r\n            if (newPaused[i] == true){\r\n                pause(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Called by pausers to pause, returns to normal state for selected functions\r\n    function batchUnpause(bool[8] memory newUnpaused) public onlyOwner {\r\n        for (uint i=0; i<functionsNum; i++) {\r\n            if (newUnpaused[i] == true){\r\n                unpause(i);\r\n            }\r\n        }\r\n    }\r\n    // Called by owner to set a new pauser\r\n    function setPauser(address newPauser) external onlyOwner {\r\n        pauser = newPauser;\r\n    }\r\n\r\n    function setPauseDuration(uint newPauseDuration) external onlyOwner {\r\n        pauseDuration = newPauseDuration;\r\n    }\r\n}"
    }
  ]
}