{
  "Title": "[L11] Number of oracle sources can exceed reversion threshold",
  "Content": "The [`AggregatorOracle`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol) facilitates the retrieval of token prices in terms of ETH from multiple sources, which it then aggregates. It then either reverts, or returns the mean or median retrieved price depending on some thresholds for deviation and the number of sources. If there are ever more than three sources for a given token, then the price retrieval function, [`getETHPx`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L71), will [revert](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L124). This effectively sets an upper bound on the number of sources per token.\n\n\nHowever, the governor can currently add an unlimited number of sources, because the [functions for adding sources for tokens](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L26-L54) do not take the effective upper bound of three into consideration. Given that it would be detrimental to have in excess of three sources per token, consider limiting the number of sources that can be added.\n\n\n***Update:** Fixed in [PR#105](https://github.com/AlphaFinanceLab/homora-v2/pull/105).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracle/AggregatorOracle.sol",
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\n\nimport '../Governable.sol';\nimport '../../interfaces/IBaseOracle.sol';\n\ncontract AggregatorOracle is IBaseOracle, Governable {\n  using SafeMath for uint;\n\n  event SetPrimarySource(address indexed token, uint maxPriceDeviation, IBaseOracle[] oracles);\n\n  mapping(address => uint) public primarySourceCount; // Mapping from token to number of sources\n  mapping(address => mapping(uint => IBaseOracle)) public primarySources; // Mapping from token to (mapping from index to oracle source)\n  mapping(address => uint) public maxPriceDeviations; // Mapping from token to max price deviation (in bps)\n\n  constructor() public {\n    __Governable__init();\n  }\n\n  /// @dev Set oracle primary sources for the token\n  /// @param token Token address to set oracle sources\n  /// @param maxPriceDeviation Max price deviation (in bps) for token\n  /// @param sources Oracle sources for the token\n  function setPrimarySources(\n    address token,\n    uint maxPriceDeviation,\n    IBaseOracle[] memory sources\n  ) external onlyGov {\n    _setPrimarySources(token, maxPriceDeviation, sources);\n  }\n\n  /// @dev Set oracle primary sources for multiple tokens\n  /// @param tokens List of token addresses to set oracle sources\n  /// @param maxPriceDeviationList List of max price deviations (in bps) for tokens\n  /// @param allSources List of oracle sources for tokens\n  function setMultiPrimarySources(\n    address[] memory tokens,\n    uint[] memory maxPriceDeviationList,\n    IBaseOracle[][] memory allSources\n  ) external onlyGov {\n    require(tokens.length == allSources.length, 'inconsistent length');\n    require(tokens.length == maxPriceDeviationList.length, 'inconsistent length');\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      _setPrimarySources(tokens[idx], maxPriceDeviationList[idx], allSources[idx]);\n    }\n  }\n\n  /// @dev Set oracle primary sources for tokens\n  /// @param token Token to set oracle sources\n  /// @param maxPriceDeviation Max price deviation (in bps) for token\n  /// @param sources Oracle sources for the token\n  function _setPrimarySources(\n    address token,\n    uint maxPriceDeviation,\n    IBaseOracle[] memory sources\n  ) internal {\n    primarySourceCount[token] = sources.length;\n    require(maxPriceDeviation >= 1e18 && maxPriceDeviation <= 1.5e18, 'bad max deviation value');\n    maxPriceDeviations[token] = maxPriceDeviation;\n    for (uint idx = 0; idx < sources.length; idx++) {\n      primarySources[token][idx] = sources[idx];\n    }\n    emit SetPrimarySource(token, maxPriceDeviation, sources);\n  }\n\n  /// @dev Return token price relative to ETH, multiplied by 2**112\n  /// @param token Token to get price of\n  /// NOTE: Support at most 3 oracle sources per token\n  function getETHPx(address token) external view override returns (uint) {\n    uint candidateSourceCount = primarySourceCount[token];\n    require(candidateSourceCount > 0, 'no primary source');\n    uint[] memory prices = new uint[](candidateSourceCount);\n\n    // Get valid oracle sources\n    uint validSourceCount = 0;\n    for (uint idx = 0; idx < candidateSourceCount; idx++) {\n      try primarySources[token][idx].getETHPx(token) returns (uint px) {\n        prices[validSourceCount++] = px;\n      } catch {}\n    }\n    require(validSourceCount > 0, 'no valid source');\n    for (uint i = 0; i < validSourceCount - 1; i++) {\n      for (uint j = 0; j < validSourceCount - i - 1; j++) {\n        if (prices[j] > prices[j + 1]) {\n          (prices[j], prices[j + 1]) = (prices[j + 1], prices[j]);\n        }\n      }\n    }\n    uint maxPriceDeviation = maxPriceDeviations[token];\n    require(maxPriceDeviation >= 1e18 && maxPriceDeviation <= 1.5e18, 'bad max deviation value');\n\n    // Algo:\n    // - 1 valid source --> return price\n    // - 2 valid sources\n    //     --> if the prices within deviation threshold, return average\n    //     --> else revert\n    // - 3 valid sources --> check deviation threshold of each pair\n    //     --> if all within threshold, return median\n    //     --> if one pair within threshold, return average of the pair\n    //     --> if none, revert\n    // - revert otherwise\n    if (validSourceCount == 1) {\n      return prices[0]; // if 1 valid source, return\n    } else if (validSourceCount == 2) {\n      require(\n        prices[1].mul(1e18) / prices[0] <= maxPriceDeviation,\n        'too much deviation (2 valid sources)'\n      );\n      return prices[0].add(prices[1]) / 2; // if 2 valid sources, return average\n    } else if (validSourceCount == 3) {\n      bool midMinOk = prices[1].mul(1e18) / prices[0] <= maxPriceDeviation;\n      bool maxMidOk = prices[2].mul(1e18) / prices[1] <= maxPriceDeviation;\n      if (midMinOk && maxMidOk) {\n        return prices[1]; // if 3 valid sources, and each pair is within thresh, return median\n      } else if (midMinOk) {\n        return prices[0].add(prices[1]) / 2; // return average of pair within thresh\n      } else if (maxMidOk) {\n        return prices[1].add(prices[2]) / 2; // return average of pair within thresh\n      } else {\n        revert('too much deviation (3 valid sources)');\n      }\n    } else {\n      revert('more than 3 valid sources not supported');\n    }\n  }\n}"
    }
  ]
}