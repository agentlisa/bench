{
  "Title": "[L16] Incorrect parsing of booleans in RLP library",
  "Content": "The [`readBool` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol#L336) of the `Lib_RLPReader` library converts an RLP-encoded boolean value into a boolean type. The function returns [`false` only if the provided value is `0`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol#L361). However, in [Geth](https://github.com/ethereum/go-ethereum/blob/v1.10.2/rlp/encode_test.go#L93) `false` is encoded as `0x80`, not `0x00`. For this encoding of `false`, the `readBool` function would [incorrectly revert](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol#L356-L359). The flawed behavior can be reproduced by simply attempting to execute `Lib_RLPReader.readBool(Lib_RLPWriter.writeBool(false))`, which currently triggers a revert with message `Invalid RLP boolean value, must be 0 or 1`.\n\n\nConsider updating the implementation of the `readBool` function to check for the case that the input is `0x80` and return `false`accordingly. Alternatively, given that this function is never used, consider removing it from the code base.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_RLPReader\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\n */\nlibrary Lib_RLPReader {\n\n    /*************\n     * Constants *\n     *************/\n\n    uint256 constant internal MAX_LIST_LENGTH = 32;\n\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    \n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n    \n\n    /**********************\n     * Internal Functions *\n     **********************/\n    \n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem memory\n        )\n    {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({\n            length: _in.length,\n            ptr: ptr\n        });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        (\n            uint256 listOffset,\n            ,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.LIST_ITEM,\n            \"Invalid RLP list value.\"\n        );\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(\n                itemCount < MAX_LIST_LENGTH,\n                \"Provided RLP list exceeds max list length.\"\n            );\n\n            (\n                uint256 itemOffset,\n                uint256 itemLength,\n            ) = _decodeLength(RLPItem({\n                length: _in.length - offset,\n                ptr: _in.ptr + offset\n            }));\n\n            out[itemCount] = RLPItem({\n                length: itemLength + itemOffset,\n                ptr: _in.ptr + offset\n            });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        return readList(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes value.\"\n        );\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return readBytes(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return readString(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        require(\n            _in.length <= 33,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return readBytes32(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return readUint256(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        require(\n            _in.length == 1,\n            \"Invalid RLP boolean value.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        require(\n            out == 0 || out == 1,\n            \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\"\n        );\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        return readBool(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(\n            _in.length == 21,\n            \"Invalid RLP address value.\"\n        );\n\n        return address(readUint256(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        return readAddress(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP Uint64 value into a uint64.\n     * @param _in RLP uint64 value.\n     * @return Decoded uint64.\n     */\n    function readUint64(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            uint64\n        )\n    {\n        require(\n            _in.length <= 9,\n            \"Invalid RLP uint64 value.\"\n        );\n\n        return uint64(readUint256(_in));\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in);\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(\n            _in.length > 0,\n            \"RLP item cannot be null.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            uint256 strLen = prefix - 0x80;\n            \n            require(\n                _in.length > strLen,\n                \"Invalid RLP short string.\"\n            );\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(\n                _in.length > lenOfStrLen,\n                \"Invalid RLP long string length.\"\n            );\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfStrLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfStrLen + strLen,\n                \"Invalid RLP long string.\"\n            );\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            uint256 listLen = prefix - 0xc0;\n\n            require(\n                _in.length > listLen,\n                \"Invalid RLP short list.\"\n            );\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(\n                _in.length > lenOfListLen,\n                \"Invalid RLP long list length.\"\n            );\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfListLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfListLen + listLen,\n                \"Invalid RLP long list.\"\n            );\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\n        assembly {\n            mstore(\n                dest,\n                or(\n                    and(mload(src), not(mask)),\n                    and(mload(dest), mask)\n                )\n            )\n        }\n\n        return out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}"
    }
  ]
}