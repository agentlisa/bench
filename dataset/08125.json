{
  "Title": "[M-16] Inconsistant parameter requirements between `constructor()` and `Set() functions` in `RANGE.sol` and `Operator.sol`.",
  "Content": "_Submitted by hansfriese, also found by datapunk and itsmeSTYJ_\n\nInconsistant parameter requirements between `constructor` and `Set() functions` in `RANGE.sol` and `Operator.sol`.\n\nThe contracts might work unexpectedly when the params are set improperly using `constructor()`.\n\n### Proof of Concept\n\n*   In `RANGE.sol`, [setSpreads()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L244-L250) and [setThresholdFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L264) has some requirements but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L80) doesn't check at all.\n\n```\n    File: 2022-08-olympus\\src\\modules\\RANGE.sol\n    242:     function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n    243:         // Confirm spreads are within allowed values\n    244:         if (\n    245:             wallSpread_ > 10000 ||\n    246:             wallSpread_ < 100 ||\n    247:             cushionSpread_ > 10000 ||\n    248:             cushionSpread_ < 100 ||\n    249:             cushionSpread_ > wallSpread_\n    250:         ) revert RANGE_InvalidParams();\n    251: \n    252:         // Set spreads\n    253:         _range.wall.spread = wallSpread_;\n    254:         _range.cushion.spread = cushionSpread_;\n    255: \n    256:         emit SpreadsChanged(wallSpread_, cushionSpread_);\n    257:     }\n```\n```\n\n    File: 2022-08-olympus\\src\\modules\\RANGE.sol\n    263:     function setThresholdFactor(uint256 thresholdFactor_) external permissioned {\n    264:         if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();\n    265:         thresholdFactor = thresholdFactor_;\n    266: \n    267:         emit ThresholdFactorChanged(thresholdFactor_);\n    268:     }\n    269: \n```\n\n*   In `Operator.sol`, [setCushionFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L518) checks the requirement but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L134) doesn't check it.\n\n```\n\n    File: 2022-08-olympus\\src\\policies\\Operator.sol\n    516:     function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {\n    517:         /// Confirm factor is within allowed values\n    518:         if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\n    519: \n    520:         /// Set factor\n    521:         _config.cushionFactor = cushionFactor_;\n    522: \n    523:         emit CushionFactorChanged(cushionFactor_);\n    524:     }\n    525: \n```\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nRecommend adding same validation for the parameters between `constructor()` and `Set()` functions.\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/379#issuecomment-1238786025):**\n > Agree that the constructor should validate these parameters, but it is only an issue if configured improperly. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/379#issuecomment-1251087775):**\n > While I am typically weary of marking input validations as medium severity, I do think in this case it's warranted as it directly leads to malfunctions at the protocol level and it seems that the sponsors thought it important enough to add the checks elsewhere. Hard call, but will award it at medium severity.   \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/modules/RANGE.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport \"src/Kernel.sol\";\n\nerror RANGE_InvalidParams();\n\n/// @notice Olympus Range data storage module\n/// @dev    The Olympus Range contract stores information about the Olympus Range market operations status.\n///         It provides a standard interface for Range data, including range prices and capacities of each range side.\n///         The data provided by this contract is used by the Olympus Range Operator to perform market operations.\n///         The Olympus Range Data is updated each epoch by the Olympus Range Operator contract.\ncontract OlympusRange is Module {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    event WallUp(bool high_, uint256 timestamp_, uint256 capacity_);\n    event WallDown(bool high_, uint256 timestamp_, uint256 capacity_);\n    event CushionUp(bool high_, uint256 timestamp_, uint256 capacity_);\n    event CushionDown(bool high_, uint256 timestamp_);\n    event PricesChanged(\n        uint256 wallLowPrice_,\n        uint256 cushionLowPrice_,\n        uint256 cushionHighPrice_,\n        uint256 wallHighPrice_\n    );\n    event SpreadsChanged(uint256 cushionSpread_, uint256 wallSpread_);\n    event ThresholdFactorChanged(uint256 thresholdFactor_);\n\n    struct Line {\n        uint256 price; // Price for the specified level\n    }\n\n    struct Band {\n        Line high; // Price of the high side of the band\n        Line low; // Price of the low side of the band\n        uint256 spread; // Spread of the band (increase/decrease from the moving average to set the band prices), percent with 2 decimal places (i.e. 1000 = 10% spread)\n    }\n\n    struct Side {\n        bool active; // Whether or not the side is active (i.e. the Operator is performing market operations on this side, true = active, false = inactive)\n        uint48 lastActive; // Unix timestamp when the side was last active (in seconds)\n        uint256 capacity; // Amount of tokens that can be used to defend the side of the range. Specified in OHM tokens on the high side and Reserve tokens on the low side.\n        uint256 threshold; // Amount of tokens under which the side is taken down. Specified in OHM tokens on the high side and Reserve tokens on the low side.\n        uint256 market; // Market ID of the cushion bond market for the side. If no market is active, the market ID is set to max uint256 value.\n    }\n\n    struct Range {\n        Side low; // Data specific to the low side of the range\n        Side high; // Data specific to the high side of the range\n        Band cushion; // Data relevant to cushions on both sides of the range\n        Band wall; // Data relevant to walls on both sides of the range\n    }\n\n    // Range data singleton. See range().\n    Range internal _range;\n\n    /// @notice Threshold factor for the change, a percent in 2 decimals (i.e. 1000 = 10%). Determines how much of the capacity must be spent before the side is taken down.\n    /// @dev    A threshold is required so that a wall is not \"active\" with a capacity near zero, but unable to be depleted practically (dust).\n    uint256 public thresholdFactor;\n\n    uint256 public constant FACTOR_SCALE = 1e4;\n\n    /// @notice OHM token contract address\n    ERC20 public immutable ohm;\n\n    /// @notice Reserve token contract address\n    ERC20 public immutable reserve;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        ERC20[2] memory tokens_,\n        uint256[3] memory rangeParams_ // [thresholdFactor, cushionSpread, wallSpread]\n    ) Module(kernel_) {\n        _range = Range({\n            low: Side({\n                active: false,\n                lastActive: uint48(block.timestamp),\n                capacity: 0,\n                threshold: 0,\n                market: type(uint256).max\n            }),\n            high: Side({\n                active: false,\n                lastActive: uint48(block.timestamp),\n                capacity: 0,\n                threshold: 0,\n                market: type(uint256).max\n            }),\n            cushion: Band({low: Line({price: 0}), high: Line({price: 0}), spread: rangeParams_[1]}),\n            wall: Band({low: Line({price: 0}), high: Line({price: 0}), spread: rangeParams_[2]})\n        });\n\n        thresholdFactor = rangeParams_[0];\n        ohm = tokens_[0];\n        reserve = tokens_[1];\n\n        emit SpreadsChanged(rangeParams_[1], rangeParams_[2]);\n        emit ThresholdFactorChanged(rangeParams_[0]);\n    }\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"RANGE\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Update the capacity for a side of the range.\n    /// @notice Access restricted to activated policies.\n    /// @param  high_ - Specifies the side of the range to update capacity for (true = high side, false = low side).\n    /// @param  capacity_ - Amount to set the capacity to (OHM tokens for high side, Reserve tokens for low side).\n    function updateCapacity(bool high_, uint256 capacity_) external permissioned {\n        if (high_) {\n            // Update capacity\n            _range.high.capacity = capacity_;\n\n            // If the new capacity is below the threshold, deactivate the wall if they are currently active\n            if (capacity_ < _range.high.threshold && _range.high.active) {\n                // Set wall to inactive\n                _range.high.active = false;\n                _range.high.lastActive = uint48(block.timestamp);\n\n                emit WallDown(true, block.timestamp, capacity_);\n            }\n        } else {\n            // Update capacity\n            _range.low.capacity = capacity_;\n\n            // If the new capacity is below the threshold, deactivate the wall if they are currently active\n            if (capacity_ < _range.low.threshold && _range.low.active) {\n                // Set wall to inactive\n                _range.low.active = false;\n                _range.low.lastActive = uint48(block.timestamp);\n\n                emit WallDown(false, block.timestamp, capacity_);\n            }\n        }\n    }\n\n    /// @notice Update the prices for the low and high sides.\n    /// @notice Access restricted to activated policies.\n    /// @param  movingAverage_ - Current moving average price to set range prices from.\n    function updatePrices(uint256 movingAverage_) external permissioned {\n        // Cache the spreads\n        uint256 wallSpread = _range.wall.spread;\n        uint256 cushionSpread = _range.cushion.spread;\n\n        // Calculate new wall and cushion values from moving average and spread\n        _range.wall.low.price = (movingAverage_ * (FACTOR_SCALE - wallSpread)) / FACTOR_SCALE;\n        _range.wall.high.price = (movingAverage_ * (FACTOR_SCALE + wallSpread)) / FACTOR_SCALE;\n\n        _range.cushion.low.price = (movingAverage_ * (FACTOR_SCALE - cushionSpread)) / FACTOR_SCALE;\n        _range.cushion.high.price =\n            (movingAverage_ * (FACTOR_SCALE + cushionSpread)) /\n            FACTOR_SCALE;\n\n        emit PricesChanged(\n            _range.wall.low.price,\n            _range.cushion.low.price,\n            _range.cushion.high.price,\n            _range.wall.high.price\n        );\n    }\n\n    /// @notice Regenerate a side of the range to a specific capacity.\n    /// @notice Access restricted to activated policies.\n    /// @param  high_ - Specifies the side of the range to regenerate (true = high side, false = low side).\n    /// @param  capacity_ - Amount to set the capacity to (OHM tokens for high side, Reserve tokens for low side).\n    function regenerate(bool high_, uint256 capacity_) external permissioned {\n        uint256 threshold = (capacity_ * thresholdFactor) / FACTOR_SCALE;\n\n        if (high_) {\n            // Re-initialize the high side\n            _range.high = Side({\n                active: true,\n                lastActive: uint48(block.timestamp),\n                capacity: capacity_,\n                threshold: threshold,\n                market: _range.high.market\n            });\n        } else {\n            // Reinitialize the low side\n            _range.low = Side({\n                active: true,\n                lastActive: uint48(block.timestamp),\n                capacity: capacity_,\n                threshold: threshold,\n                market: _range.low.market\n            });\n        }\n\n        emit WallUp(high_, block.timestamp, capacity_);\n    }\n\n    /// @notice Update the market ID (cushion) for a side of the range.\n    /// @notice Access restricted to activated policies.\n    /// @param  high_ - Specifies the side of the range to update market for (true = high side, false = low side).\n    /// @param  market_ - Market ID to set for the side.\n    /// @param  marketCapacity_ - Amount to set the last market capacity to (OHM tokens for high side, Reserve tokens for low side).\n    function updateMarket(\n        bool high_,\n        uint256 market_,\n        uint256 marketCapacity_\n    ) public permissioned {\n        // If market id is max uint256, then marketCapacity must be 0\n        if (market_ == type(uint256).max && marketCapacity_ != 0) revert RANGE_InvalidParams();\n\n        // Store updated state\n        if (high_) {\n            _range.high.market = market_;\n        } else {\n            _range.low.market = market_;\n        }\n\n        if (market_ == type(uint256).max) {\n            emit CushionDown(high_, block.timestamp);\n        } else {\n            emit CushionUp(high_, block.timestamp, marketCapacity_);\n        }\n    }\n\n    /// @notice Set the wall and cushion spreads.\n    /// @notice Access restricted to activated policies.\n    /// @param  cushionSpread_ - Percent spread to set the cushions at above/below the moving average, assumes 2 decimals (i.e. 1000 = 10%).\n    /// @param  wallSpread_ - Percent spread to set the walls at above/below the moving average, assumes 2 decimals (i.e. 1000 = 10%).\n    /// @dev    The new spreads will not go into effect until the next time updatePrices() is called.\n    function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n        // Confirm spreads are within allowed values\n        if (\n            wallSpread_ > 10000 ||\n            wallSpread_ < 100 ||\n            cushionSpread_ > 10000 ||\n            cushionSpread_ < 100 ||\n            cushionSpread_ > wallSpread_\n        ) revert RANGE_InvalidParams();\n\n        // Set spreads\n        _range.wall.spread = wallSpread_;\n        _range.cushion.spread = cushionSpread_;\n\n        emit SpreadsChanged(wallSpread_, cushionSpread_);\n    }\n\n    /// @notice Set the threshold factor for when a wall is considered \"down\".\n    /// @notice Access restricted to activated policies.\n    /// @param  thresholdFactor_ - Percent of capacity that the wall should close below, assumes 2 decimals (i.e. 1000 = 10%).\n    /// @dev    The new threshold factor will not go into effect until the next time regenerate() is called for each side of the wall.\n    function setThresholdFactor(uint256 thresholdFactor_) external permissioned {\n        if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();\n        thresholdFactor = thresholdFactor_;\n\n        emit ThresholdFactorChanged(thresholdFactor_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the full Range data in a struct.\n    function range() external view returns (Range memory) {\n        return _range;\n    }\n\n    /// @notice Get the capacity for a side of the range.\n    /// @param  high_ - Specifies the side of the range to get capacity for (true = high side, false = low side).\n    function capacity(bool high_) external view returns (uint256) {\n        if (high_) {\n            return _range.high.capacity;\n        } else {\n            return _range.low.capacity;\n        }\n    }\n\n    /// @notice Get the status of a side of the range (whether it is active or not).\n    /// @param  high_ - Specifies the side of the range to get status for (true = high side, false = low side).\n    function active(bool high_) external view returns (bool) {\n        if (high_) {\n            return _range.high.active;\n        } else {\n            return _range.low.active;\n        }\n    }\n\n    /// @notice Get the price for the wall or cushion for a side of the range.\n    /// @param  wall_ - Specifies the band to get the price for (true = wall, false = cushion).\n    /// @param  high_ - Specifies the side of the range to get the price for (true = high side, false = low side).\n    function price(bool wall_, bool high_) external view returns (uint256) {\n        if (wall_) {\n            if (high_) {\n                return _range.wall.high.price;\n            } else {\n                return _range.wall.low.price;\n            }\n        } else {\n            if (high_) {\n                return _range.cushion.high.price;\n            } else {\n                return _range.cushion.low.price;\n            }\n        }\n    }\n\n    /// @notice Get the spread for the wall or cushion band.\n    /// @param  wall_ - Specifies the band to get the spread for (true = wall, false = cushion).\n    function spread(bool wall_) external view returns (uint256) {\n        if (wall_) {\n            return _range.wall.spread;\n        } else {\n            return _range.cushion.spread;\n        }\n    }\n\n    /// @notice Get the market ID for a side of the range.\n    /// @param  high_ - Specifies the side of the range to get market for (true = high side, false = low side).\n    function market(bool high_) external view returns (uint256) {\n        if (high_) {\n            return _range.high.market;\n        } else {\n            return _range.low.market;\n        }\n    }\n\n    /// @notice Get the timestamp when the range was last active.\n    /// @param  high_ - Specifies the side of the range to get timestamp for (true = high side, false = low side).\n    function lastActive(bool high_) external view returns (uint256) {\n        if (high_) {\n            return _range.high.lastActive;\n        } else {\n            return _range.low.lastActive;\n        }\n    }\n}"
    },
    {
      "filename": "src/policies/Operator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\n\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n/// @title  Olympus Range Operator\n/// @notice Olympus Range Operator (Policy) Contract\n/// @dev    The Olympus Range Operator performs market operations to enforce OlympusDAO's OHM price range\n///         guidance policies against a specific reserve asset. The Operator is maintained by a keeper-triggered\n///         function on the Olympus Heart contract, which orchestrates state updates in the correct order to ensure\n///         market operations use up to date information. When the price of OHM against the reserve asset exceeds\n///         the cushion spread, the Operator deploys bond markets to support the price. The Operator also offers\n///         zero slippage swaps at prices dictated by the wall spread from the moving average. These market operations\n///         are performed up to a specific capacity before the market must stabilize to regenerate the capacity.\ncontract Operator is IOperator, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS =========== */\n\n    error Operator_InvalidParams();\n    error Operator_InsufficientCapacity();\n    error Operator_AmountLessThanMinimum(uint256 amountOut, uint256 minAmountOut);\n    error Operator_WallDown();\n    error Operator_AlreadyInitialized();\n    error Operator_NotInitialized();\n    error Operator_Inactive();\n\n    /* ========== EVENTS =========== */\n    event Swap(\n        ERC20 indexed tokenIn_,\n        ERC20 indexed tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOut_\n    );\n    event CushionFactorChanged(uint32 cushionFactor_);\n    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);\n    event ReserveFactorChanged(uint32 reserveFactor_);\n    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// Operator variables, defined in the interface on the external getter functions\n    Status internal _status;\n    Config internal _config;\n\n    /// @notice    Whether the Operator has been initialized\n    bool public initialized;\n\n    /// @notice    Whether the Operator is active\n    bool public active;\n\n    /// Modules\n    OlympusPrice internal PRICE;\n    OlympusRange internal RANGE;\n    OlympusTreasury internal TRSRY;\n    OlympusMinter internal MINTR;\n\n    /// External contracts\n    /// @notice     Auctioneer contract used for cushion bond market deployments\n    IBondAuctioneer public auctioneer;\n    /// @notice     Callback contract used for cushion bond market payouts\n    IBondCallback public callback;\n\n    /// Tokens\n    /// @notice     OHM token contract\n    ERC20 public immutable ohm;\n    uint8 public immutable ohmDecimals;\n    /// @notice     Reserve token contract\n    ERC20 public immutable reserve;\n    uint8 public immutable reserveDecimals;\n\n    /// Constants\n    uint32 public constant FACTOR_SCALE = 1e4;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        Kernel kernel_,\n        IBondAuctioneer auctioneer_,\n        IBondCallback callback_,\n        ERC20[2] memory tokens_, // [ohm, reserve]\n        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]\n    ) Policy(kernel_) {\n        /// Check params are valid\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n\n        if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))\n            revert Operator_InvalidParams();\n\n        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();\n\n        if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])\n            revert Operator_InvalidParams();\n\n        if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();\n\n        if (\n            configParams[5] < 1 hours ||\n            configParams[6] > configParams[7] ||\n            configParams[7] == uint32(0)\n        ) revert Operator_InvalidParams();\n\n        auctioneer = auctioneer_;\n        callback = callback_;\n        ohm = tokens_[0];\n        ohmDecimals = tokens_[0].decimals();\n        reserve = tokens_[1];\n        reserveDecimals = tokens_[1].decimals();\n\n        Regen memory regen = Regen({\n            count: uint32(0),\n            lastRegen: uint48(block.timestamp),\n            nextObservation: uint32(0),\n            observations: new bool[](configParams[7])\n        });\n\n        _config = Config({\n            cushionFactor: configParams[0],\n            cushionDuration: configParams[1],\n            cushionDebtBuffer: configParams[2],\n            cushionDepositInterval: configParams[3],\n            reserveFactor: configParams[4],\n            regenWait: configParams[5],\n            regenThreshold: configParams[6],\n            regenObserve: configParams[7]\n        });\n\n        _status = Status({low: regen, high: regen});\n\n        emit CushionFactorChanged(configParams[0]);\n        emit CushionParamsChanged(configParams[1], configParams[2], configParams[3]);\n        emit ReserveFactorChanged(configParams[4]);\n        emit RegenParamsChanged(configParams[5], configParams[6], configParams[7]);\n    }\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"PRICE\");\n        dependencies[1] = toKeycode(\"RANGE\");\n        dependencies[2] = toKeycode(\"TRSRY\");\n        dependencies[3] = toKeycode(\"MINTR\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n        RANGE = OlympusRange(getModuleAddress(dependencies[1]));\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[2]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\n\n        /// Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](9);\n        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    modifier onlyWhileActive() {\n        if (!active) revert Operator_Inactive();\n        _;\n    }\n\n    /* ========== HEART FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function operate() external override onlyWhileActive onlyRole(\"operator_operate\") {\n        /// Revert if not initialized\n        if (!initialized) revert Operator_NotInitialized();\n\n        /// Update the prices for the range, save new regen observations, and update capacities based on bond market activity\n        _updateRangePrices();\n        _addObservation();\n        _updateCapacity(true, 0);\n        _updateCapacity(false, 0);\n\n        /// Cache config in memory\n        Config memory config_ = _config;\n\n        /// Check if walls can regenerate capacity\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\n            _status.high.count >= config_.regenThreshold\n        ) {\n            _regenerate(true);\n        }\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\n            _status.low.count >= config_.regenThreshold\n        ) {\n            _regenerate(false);\n        }\n\n        /// Cache range data after potential regeneration\n        OlympusRange.Range memory range = RANGE.range();\n\n        /// Get latest price\n        /// See note in addObservation() for more details\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Check if the cushion bond markets are active\n        /// if so, determine if it should stay open or close\n        /// if not, check if a new one should be opened\n        if (range.low.active) {\n            if (auctioneer.isLive(range.low.market)) {\n                /// if active, check if the price is back above the cushion\n                /// or if the price is below the wall\n                /// if so, close the market\n                if (currentPrice > range.cushion.low.price || currentPrice < range.wall.low.price) {\n                    _deactivate(false);\n                }\n            } else {\n                /// if not active, check if the price is below the cushion\n                /// if so, open a new bond market\n                if (currentPrice < range.cushion.low.price && currentPrice > range.wall.low.price) {\n                    _activate(false);\n                }\n            }\n        }\n        if (range.high.active) {\n            if (auctioneer.isLive(range.high.market)) {\n                /// if active, check if the price is back under the cushion\n                /// or if the price is above the wall\n                /// if so, close the market\n                if (\n                    currentPrice < range.cushion.high.price || currentPrice > range.wall.high.price\n                ) {\n                    _deactivate(true);\n                }\n            } else {\n                /// if not active, check if the price is above the cushion\n                /// if so, open a new bond market\n                if (\n                    currentPrice > range.cushion.high.price && currentPrice < range.wall.high.price\n                ) {\n                    _activate(true);\n                }\n            }\n        }\n    }\n\n    /* ========== OPEN MARKET OPERATIONS (WALL) ========== */\n    /// @inheritdoc IOperator\n    function swap(\n        ERC20 tokenIn_,\n        uint256 amountIn_,\n        uint256 minAmountOut_\n    ) external override onlyWhileActive nonReentrant returns (uint256 amountOut) {\n        if (tokenIn_ == ohm) {\n            /// Revert if lower wall is inactive\n            if (!RANGE.active(false)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(false, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(false);\n\n            /// Transfer OHM from sender\n            ohm.safeTransferFrom(msg.sender, address(this), amountIn_);\n\n            /// Burn OHM\n            MINTR.burnOhm(address(this), amountIn_);\n\n            /// Withdraw and transfer reserve to sender\n            TRSRY.withdrawReserves(msg.sender, reserve, amountOut);\n\n            emit Swap(ohm, reserve, amountIn_, amountOut);\n        } else if (tokenIn_ == reserve) {\n            /// Revert if upper wall is inactive\n            if (!RANGE.active(true)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(true, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(true);\n\n            /// Transfer reserves to treasury\n            reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n\n            /// Mint OHM to sender\n            MINTR.mintOhm(msg.sender, amountOut);\n\n            emit Swap(reserve, ohm, amountIn_, amountOut);\n        } else {\n            revert Operator_InvalidParams();\n        }\n    }\n\n    /* ========== BOND MARKET OPERATIONS (CUSHION) ========== */\n    /// @notice             Records a bond purchase and updates capacity correctly\n    /// @notice             Access restricted (BondCallback)\n    /// @param id_          ID of the bond market\n    /// @param amountOut_   Amount of capacity expended\n    function bondPurchase(uint256 id_, uint256 amountOut_)\n        external\n        onlyWhileActive\n        onlyRole(\"operator_reporter\")\n    {\n        if (id_ == RANGE.market(true)) {\n            _updateCapacity(true, amountOut_);\n            _checkCushion(true);\n        }\n        if (id_ == RANGE.market(false)) {\n            _updateCapacity(false, amountOut_);\n            _checkCushion(false);\n        }\n    }\n\n    /// @notice      Activate a cushion by deploying a bond market\n    /// @param high_ Whether the cushion is for the high or low side of the range (true = high, false = low)\n    function _activate(bool high_) internal {\n        OlympusRange.Range memory range = RANGE.range();\n\n        if (high_) {\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecimals = _getPriceDecimals(range.cushion.high.price);\n            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\n\n            /// Calculate oracle scale and bond scale with scale adjustment and format prices for bond market\n            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\n            uint256 bondScale = 10 **\n                uint8(\n                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\n                );\n\n            uint256 initialPrice = range.wall.high.price.mulDiv(bondScale, oracleScale);\n            uint256 minimumPrice = range.cushion.high.price.mulDiv(bondScale, oracleScale);\n\n            /// Cache config struct to avoid multiple SLOADs\n            Config memory config_ = _config;\n\n            /// Calculate market capacity from the cushion factor\n            uint256 marketCapacity = range.high.capacity.mulDiv(\n                config_.cushionFactor,\n                FACTOR_SCALE\n            );\n\n            /// Create new bond market to buy the reserve with OHM\n            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\n                payoutToken: ohm,\n                quoteToken: reserve,\n                callbackAddr: address(callback),\n                capacityInQuote: false,\n                capacity: marketCapacity,\n                formattedInitialPrice: initialPrice,\n                formattedMinimumPrice: minimumPrice,\n                debtBuffer: config_.cushionDebtBuffer,\n                vesting: uint48(0), // Instant swaps\n                conclusion: uint48(block.timestamp + config_.cushionDuration),\n                depositInterval: config_.cushionDepositInterval,\n                scaleAdjustment: scaleAdjustment\n            });\n\n            uint256 market = auctioneer.createMarket(params);\n\n            /// Whitelist the bond market on the callback\n            callback.whitelist(address(auctioneer.getTeller()), market);\n\n            /// Update the market information on the range module\n            RANGE.updateMarket(true, market, marketCapacity);\n        } else {\n            /// Calculate inverse prices from the oracle feed for the low side\n            uint8 oracleDecimals = PRICE.decimals();\n            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;\n            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\n\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the persp"
    }
  ]
}