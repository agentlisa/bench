{
  "Title": "[G-18] Refactor event to avoid emitting empty data",
  "Content": "\n\n```solidity\nfile: /src/Aquifer.sol\n\n58                if (returnData.length < 68) revert InitFailed(\"\"); ///@audit: \"\" ,  no data reverted\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Aquifer.sol#L58\n\n\n**[publiuss (Basin) acknowledged and commented](https://github.com/code-423n4/2023-07-basin-findings/issues/272#issuecomment-1690777881):**\n>G-01 No remediation<br>\nG-02 Fixed<br>\nG-03 No remediation - costs more gas<br>\nG-04 No remediation<br>\nG-05 Fixed<br>\nG-06 No remediation - costs more gas<br>\nG-07 No remediation - costs more gas<br>\nG-08 No remediation - the initializer modifier is necessary.<br>\nG-09 No remediation - costs more gas<br>\nG-10 No remediation - This is in a script and not in a contract.<br>\nG-11 Fixed<br>\nG-12 No remediation - This is in a script and not in a contract.<br>\nG-13 No remediation - This code has already been removed.<br>\nG-14 No remediation<br>\nG-15 No remediation<br>\nG-16 No remediation - costs more gas<br>\nG-17 No remediation<br>\nG-18 No remediation<br>\n\n\n***\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/Aquifer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuard} from \"oz/security/ReentrancyGuard.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {IAquifer} from \"src/interfaces/IAquifer.sol\";\nimport {Well, IWell, Call, IERC20} from \"src/Well.sol\";\nimport {LibClone} from \"src/libraries/LibClone.sol\";\n\n/**\n * @title Aquifer\n * @author Publius, Silo Chad, Brean\n * @notice Aquifer is a permissionless Well registry and factory.\n * @dev Aquifer deploys Wells by cloning a pre-deployed Well implementation.\n */\ncontract Aquifer is IAquifer, ReentrancyGuard {\n    using SafeCast for uint256;\n    using LibClone for address;\n\n    // A mapping of Well address to the Well implementation addresses\n    // Mapping gets set on Well deployment\n    mapping(address => address) wellImplementations;\n\n    constructor() ReentrancyGuard() {}\n\n    /**\n     * @dev\n     * Use `salt == 0` to deploy a new Well with `create`\n     * Use `salt > 0` to deploy a new Well with `create2`\n     */\n    function boreWell(\n        address implementation,\n        bytes calldata immutableData,\n        bytes calldata initFunctionCall,\n        bytes32 salt\n    ) external nonReentrant returns (address well) {\n        if (immutableData.length > 0) {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(immutableData, salt);\n            } else {\n                well = implementation.clone(immutableData);\n            }\n        } else {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(salt);\n            } else {\n                well = implementation.clone();\n            }\n        }\n\n        if (initFunctionCall.length > 0) {\n            (bool success, bytes memory returnData) = well.call(initFunctionCall);\n            if (!success) {\n                // Next 5 lines are based on https://ethereum.stackexchange.com/a/83577\n                if (returnData.length < 68) revert InitFailed(\"\");\n                assembly {\n                    returnData := add(returnData, 0x04)\n                }\n                revert InitFailed(abi.decode(returnData, (string)));\n            }\n        }\n\n        // The Aquifer address MUST be set, either (a) via immutable data during cloning,\n        // or (b) as a storage variable during an init function call. In either case,\n        // the address MUST match the address of the Aquifer that performed deployment.\n        if (IWell(well).aquifer() != address(this)) {\n            revert InvalidConfig();\n        }\n\n        // Save implementation\n        wellImplementations[well] = implementation;\n\n        emit BoreWell(\n            well,\n            implementation,\n            IWell(well).tokens(),\n            IWell(well).wellFunction(),\n            IWell(well).pumps(),\n            IWell(well).wellData()\n        );\n    }\n\n    function wellImplementation(address well) external view returns (address implementation) {\n        return wellImplementations[well];\n    }\n}"
    }
  ]
}