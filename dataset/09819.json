{
  "Title": "[M-18] Fees Are Incorrectly Charged on Unfinalized NFT Sales",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L255-L271\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L557\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L510-L515\nhttps://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketFees.sol#L188-L189\n\n\n# Vulnerability details\n\n## Impact\n\nOnce an auction has ended, the highest bidder now has sole rights to the underlying NFT. By finalizing the auction, fees are charged on the sale and the NFT is transferred to `auction.bidder`. However, if `auction.bidder` accepts an offer before finalization, fees will be charged on the `auction.bidder` sale before the original sale. As a result, it is possible to avoid paying the primary foundation fee as a creator if the NFT is sold by `auction.bidder` before finalization.\n\n## Proof of Concept\n\nConsider the following scenario:\n- Alice creates an auction and is the NFT creator.\n- Bob bids on the auction and is the highest bidder.\n- The auction ends but Alice leaves it in an unfinalized state.\n- Carol makes an offer on the NFT which Bob accepts.\n- `_acceptOffer()` will distribute funds on the sale between Bob and Carol before distributing funds on the sale between Alice and Bob.\n- The first call to `_distributeFunds()` will set the `_nftContractToTokenIdToFirstSaleCompleted` to true, meaning that future sales will only be charged the secondary foundation fee.\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nEnsure the `_nftContractToTokenIdToFirstSaleCompleted` is correctly tracked. It might be useful to ensure the distribution of funds are in the order of when the trades occurred. For example, an unfinalized auction should always have its fees paid before other sales.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-foundation-contest",
  "Code": [
    {
      "filename": "contracts/mixins/NFTMarketOffer.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./NFTMarketCore.sol\";\nimport \"./NFTMarketFees.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nerror NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();\n/// @param currentOfferAmount The current highest offer available for this NFT.\nerror NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);\n/// @param expiry The time at which the offer had expired.\nerror NFTMarketOffer_Offer_Expired(uint256 expiry);\n/// @param currentOfferFrom The address of the collector which has made the current highest offer.\nerror NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);\n/// @param minOfferAmount The minimum amount that must be offered in order for it to be accepted.\nerror NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);\nerror NFTMarketOffer_Reason_Required();\n\n/**\n * @title Allows collectors to make an offer for an NFT, valid for 24-25 hours.\n * @notice Funds are escrowed in the FETH ERC-20 token contract.\n */\nabstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {\n  using AddressUpgradeable for address;\n\n  /// @notice Stores offer details for a specific NFT.\n  struct Offer {\n    // Slot 1: When increasing an offer, only this slot is updated.\n    /// @notice The expiration timestamp of when this offer expires.\n    uint32 expiration;\n    /// @notice The amount, in wei, of the highest offer.\n    uint96 amount;\n    // 128 bits are available in slot 1\n\n    // Slot 2: When the buyer changes, both slots need updating\n    /// @notice The address of the collector who made this offer.\n    address buyer;\n  }\n\n  /// @notice Stores the highest offer for each NFT.\n  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;\n\n  /**\n   * @notice Emitted when an offer is accepted,\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\n   * @dev The accepted total offer amount is `f8nFee` + `creatorFee` + `ownerRev`.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyer The address of the collector that made the offer which was accepted.\n   * @param seller The address of the seller which accepted the offer.\n   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\n   * @param ownerRev The amount of ETH that was sent to the owner for this sale.\n   */\n  event OfferAccepted(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address indexed buyer,\n    address seller,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev\n  );\n  /**\n   * @notice Emitted when an offer is canceled by a Foundation admin.\n   * @dev This should only be used for extreme cases such as DMCA takedown requests.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param reason The reason for the cancellation (a required field).\n   */\n  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);\n  /**\n   * @notice Emitted when an offer is invalidated due to other market activity.\n   * When this occurs, the collector which made the offer has their FETH balance unlocked\n   * and the funds are available to place other offers or to be withdrawn.\n   * @dev This occurs when the offer is no longer eligible to be accepted,\n   * e.g. when a bid is placed in an auction for this NFT.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   */\n  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);\n  /**\n   * @notice Emitted when an offer is made.\n   * @dev The `amount` of the offer is locked in the FETH ERC-20 contract, guaranteeing that the funds\n   * remain available until the `expiration` date.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyer The address of the collector that made the offer to buy this NFT.\n   * @param amount The amount, in wei, of the offer.\n   * @param expiration The expiration timestamp for the offer.\n   */\n  event OfferMade(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address indexed buyer,\n    uint256 amount,\n    uint256 expiration\n  );\n\n  /**\n   * @notice Accept the highest offer for an NFT.\n   * @dev The offer must not be expired and the NFT owned + approved by the seller or\n   * available in the market contract's escrow.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param offerFrom The address of the collector that you wish to sell to.\n   * If the current highest offer is not from this user, the transaction will revert.\n   * This could happen if a last minute offer was made by another collector,\n   * and would require the seller to try accepting again.\n   * @param minAmount The minimum value of the highest offer for it to be accepted.\n   * If the value is less than this amount, the transaction will revert.\n   * This could happen if the original offer expires and is replaced with a smaller offer.\n   */\n  function acceptOffer(\n    address nftContract,\n    uint256 tokenId,\n    address offerFrom,\n    uint256 minAmount\n  ) external nonReentrant {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    // Validate offer expiry and amount\n    if (offer.expiration < block.timestamp) {\n      revert NFTMarketOffer_Offer_Expired(offer.expiration);\n    } else if (offer.amount < minAmount) {\n      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);\n    }\n    // Validate the buyer\n    if (offer.buyer != offerFrom) {\n      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);\n    }\n\n    _acceptOffer(nftContract, tokenId);\n  }\n\n  /**\n   * @notice Allows Foundation to cancel offers.\n   * This will unlock the funds in the FETH ERC-20 contract for the highest offer\n   * and prevent the offer from being accepted.\n   * @dev This should only be used for extreme cases such as DMCA takedown requests.\n   * @param nftContracts The addresses of the NFT contracts to cancel. This must be the same length as `tokenIds`.\n   * @param tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`.\n   * @param reason The reason for the cancellation (a required field).\n   */\n  function adminCancelOffers(\n    address[] calldata nftContracts,\n    uint256[] calldata tokenIds,\n    string calldata reason\n  ) external onlyFoundationAdmin nonReentrant {\n    if (bytes(reason).length == 0) {\n      revert NFTMarketOffer_Reason_Required();\n    }\n\n    // The array length cannot overflow 256 bits\n    unchecked {\n      for (uint256 i = 0; i < nftContracts.length; ++i) {\n        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];\n        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];\n\n        if (offer.expiration >= block.timestamp) {\n          // Unlock from escrow and emit an event only if the offer is still active\n          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);\n          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);\n        }\n        // Else continue on so the rest of the batch transaction can process successfully\n      }\n    }\n  }\n\n  /**\n   * @notice Make an offer for any NFT which is valid for 24-25 hours.\n   * The funds will be locked in the FETH token contract and become available once the offer is outbid or has expired.\n   * @dev An offer may be made for an NFT before it is minted, although we generally not recommend you do that.\n   * If there is a buy price set at this price or lower, that will be accepted instead of making an offer.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param amount The amount to offer for this NFT.\n   * @return expiration The timestamp for when this offer will expire.\n   * This is provided as a return value in case another contract would like to leverage this information,\n   * user's should refer to the expiration in the `OfferMade` event log.\n   * If the buy price is accepted instead, `0` is returned as the expiration since that's n/a.\n   */\n  function makeOffer(\n    address nftContract,\n    uint256 tokenId,\n    uint256 amount\n  ) external payable returns (uint256 expiration) {\n    // If there is a buy price set at this price or lower, accept that instead.\n    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {\n      // If the buy price is accepted, `0` is returned as the expiration since that's n/a.\n      return 0;\n    }\n\n    if (_isInActiveAuction(nftContract, tokenId)) {\n      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();\n    }\n\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n\n    if (offer.expiration < block.timestamp) {\n      // This is a new offer for the NFT (no other offer found or the previous offer expired)\n\n      // Lock the offer amount in FETH until the offer expires in 24-25 hours.\n      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);\n    } else {\n      // A previous offer exists and has not expired\n\n      if (amount < _getMinIncrement(offer.amount)) {\n        // A non-trivial increase in price is required to avoid sniping\n        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));\n      }\n\n      // Unlock the previous offer so that the FETH tokens are available for other offers or to transfer / withdraw\n      // and lock the new offer amount in FETH until the offer expires in 24-25 hours.\n      expiration = feth.marketChangeLockup{ value: msg.value }(\n        offer.buyer,\n        offer.expiration,\n        offer.amount,\n        msg.sender,\n        amount\n      );\n    }\n\n    // Record offer details\n    offer.buyer = msg.sender;\n    // The FETH contract guarantees that the expiration fits into 32 bits.\n    offer.expiration = uint32(expiration);\n    // `amount` is capped by the ETH provided, which cannot realistically overflow 96 bits.\n    offer.amount = uint96(amount);\n\n    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);\n  }\n\n  /**\n   * @notice Accept the highest offer for an NFT from the `msg.sender` account.\n   * The NFT will be transferred to the buyer and revenue from the sale will be distributed.\n   * @dev The caller must validate the expiry and amount before calling this helper.\n   * This may invalidate other market tools, such as clearing the buy price if set.\n   */\n  function _acceptOffer(address nftContract, uint256 tokenId) private {\n    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];\n\n    // Remove offer\n    delete nftContractToIdToOffer[nftContract][tokenId];\n    // Withdraw ETH from the buyer's account in the FETH token contract.\n    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);\n\n    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.\n    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(\n      nftContract,\n      tokenId,\n      payable(msg.sender),\n      offer.amount\n    );\n\n    // Transfer the NFT to the buyer.\n    try\n      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks\n    {\n      // NFT was in the seller's wallet so the transfer is complete.\n    } catch {\n      // If the transfer fails then attempt to transfer from escrow instead.\n      // This should revert if the NFT is not in escrow of the `msg.sender` is not the owner of this NFT.\n      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);\n    }\n\n    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Invalidates the highest offer when an auction is kicked off, if one is found.\n   */\n  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {\n    _invalidateOffer(nftContract, tokenId);\n    super._afterAuctionStarted(nftContract, tokenId);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   * @dev Invalidates the highest offer if it's from the same user that purchased the NFT\n   * using a different market tool such as accepting the buy price.\n   */\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address buyer,\n    address seller\n  ) internal virtual override {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.buyer == buyer) {\n      // The highest offer is from the same user that purchased the NFT using a different market tool.\n      _invalidateOffer(nftContract, tokenId);\n    }\n    // For other users, the offer remains valid for consideration by the new owner.\n    super._transferFromEscrow(nftContract, tokenId, buyer, seller);\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _autoAcceptOffer(\n    address nftContract,\n    uint256 tokenId,\n    uint256 minAmount\n  ) internal override returns (bool) {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.expiration < block.timestamp || offer.amount < minAmount) {\n      // No offer found, the most recent offer is now expired, or the highest offer is below the minimum amount.\n      return false;\n    }\n\n    _acceptOffer(nftContract, tokenId);\n    return true;\n  }\n\n  /**\n   * @inheritdoc NFTMarketCore\n   */\n  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.buyer == msg.sender) {\n      _invalidateOffer(nftContract, tokenId);\n    }\n  }\n\n  /**\n   * @notice Invalidates the offer and frees ETH from escrow, if the offer has not already expired.\n   */\n  function _invalidateOffer(address nftContract, uint256 tokenId) private {\n    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {\n      // An offer was found and it has not already expired\n      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];\n\n      // Remove offer\n      delete nftContractToIdToOffer[nftContract][tokenId];\n      // Unlock the offer so that the FETH tokens are available for other offers or to transfer / withdraw\n      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);\n\n      emit OfferInvalidated(nftContract, tokenId);\n    }\n  }\n\n  /**\n   * @notice Returns the minimum amount a collector must offer for this NFT in order for the offer to be valid.\n   * @dev Offers for this NFT which are less than this value will revert.\n   * Once the previous offer has expired smaller offers can be made.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @return minimum The minimum amount that must be offered for this NFT.\n   */\n  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.expiration >= block.timestamp) {\n      return _getMinIncrement(offer.amount);\n    }\n    // Absolute min is anything > 0\n    return 1;\n  }\n\n  /**\n   * @notice Returns details about the current highest offer for an NFT.\n   * @dev Default values are returned if there is no offer or the offer has expired.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @return buyer The address of the buyer that made the current highest offer.\n   * Returns `address(0)` if there is no offer or the most recent offer has expired.\n   * @return expiration The timestamp that the current highest offer expires.\n   * Returns `0` if there is no offer or the most recent offer has expired.\n   * @return amount The amount being offered for this NFT.\n   * Returns `0` if there is no offer or the most recent offer has expired.\n   */\n  function getOffer(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (\n      address buyer,\n      uint256 expiration,\n      uint256 amount\n    )\n  {\n    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];\n    if (offer.expiration < block.timestamp) {\n      // Offer not found or has expired\n      return (address(0), 0, 0);\n    }\n\n    // An offer was found and it has not yet expired.\n    return (offer.buyer, offer.expiration, offer.amount);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}"
    },
    {
      "filename": "contracts/mixins/NFTMarketReserveAuction.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../libraries/AccountMigrationLibrary.sol\";\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./NFTMarketAuction.sol\";\nimport \"./NFTMarketCore.sol\";\nimport \"./NFTMarketFees.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @param minAmount The minimum amount that must be bid in order for it to be accepted.\nerror NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);\nerror NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n/// @param reservePrice The current reserve price.\nerror NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);\n/// @param endTime The timestamp at which the auction had ended.\nerror NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);\nerror NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\n/// @param endTime The timestamp at which the auction will end.\nerror NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);\n/// @param seller The current owner of the NFT.\nerror NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);\nerror NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\nerror NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.\nerror NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);\n/// @param extensionDuration The extension duration, in seconds.\nerror NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);\nerror NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n/// @param seller The current owner of the NFT.\nerror NFTMarketReserveAuction_Not_Matching_Seller(address seller);\n/// @param owner The current owner of the NFT.\nerror NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);\nerror NFTMarketReserveAuction_Too_Much_Value_Provided();\n\n/**\n * @title Allows the owner of an NFT to list it in auction.\n * @notice NFTs in auction are escrowed in the market contract.\n * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.\n * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.\n */\nabstract contract NFTMarketReserveAuction is\n  Constants,\n  FoundationTreasuryNode,\n  NFTMarketCore,\n  ReentrancyGuardUpgradeable,\n  SendValueWithFallbackWithdraw,\n  NFTMarketFees,\n  NFTMarketAuction\n{\n  using AccountMigrationLibrary for address;\n\n  /// @notice Stores the auction configuration for a specific NFT.\n  struct ReserveAuction {\n    /// @notice The address of the NFT contract.\n    address nftContract;\n    /// @notice The id of the NFT.\n    uint256 tokenId;\n    /// @notice The owner of the NFT which listed it in auction.\n    address payable seller;\n    /// @notice The duration for this auction.\n    uint256 duration;\n    /// @notice The extension window for this auction.\n    uint256 extensionDuration;\n    /// @notice The time at which this auction will not accept any new bids.\n    /// @dev This is `0` until the first bid is placed.\n    uint256 endTime;\n    /// @notice The current highest bidder in this auction.\n    /// @dev This is `address(0)` until the first bid is placed.\n    address payable bidder;\n    /// @notice The latest price of the NFT in this auction.\n    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.\n    uint256 amount;\n  }\n\n  /// @notice The auction configuration for a specific auction id.\n  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;\n  /// @notice The auction id for a specific NFT.\n  /// @dev This is deleted when an auction is finalized or canceled.\n  mapping(uint256 => ReserveAuction) private auctionIdToAuction;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private __gap_was_minPercentIncrementInBasisPoints;\n   * uint256 private __gap_was_maxBidIncrementRequirement;\n   * uint256 private __gap_was_duration;\n   * uint256 private __gap_was_extensionDuration;\n   * uint256 private __gap_was_goLiveDate;\n   */\n  uint256[5] private __gap_was_config;\n\n  /// @notice How long an auction lasts for once the first bid has been received.\n  uint256 private immutable DURATION;\n\n  /// @notice The window for auction extensions, any bid placed in the final 15 minutes\n  /// of an auction will reset the time remaining to 15 minutes.\n  uint256 private constant EXTENSION_DURATION = 15 minutes;\n\n  /// @notice Caps the max duration that may be configured so that overflows will not occur.\n  uint256 private constant MAX_MAX_DURATION = 1000 days;\n\n  /**\n   * @notice Emitted when a bid is placed.\n   * @param auctionId The id of the auction this bid was for.\n   * @param bidder The address of the bidder.\n   * @param amount The amount of the bid.\n   * @param endTime The new end time of the auction (which may have been set or extended by this bid).\n   */\n  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);\n  /**\n   * @notice Emitted when an auction is cancelled.\n   * @dev This is only possible if the auction has not received any bids.\n   * @param auctionId The id of the auction that was cancelled.\n   */\n  event ReserveAuctionCanceled(uint256 indexed auctionId);\n  /**\n   * @notice Emitted when an auction is canceled by a Foundation admin.\n   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.\n   * @param auctionId The id of the auction that was cancelled.\n   * @param reason The reason for the cancellation.\n   */\n  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);\n  /**\n   * @notice Emitted when an NFT is listed for auction.\n   * @param seller The address of the seller.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param duration The duration of the auction (always 24-hours).\n   * @param extensionDuration The duration of the auction extension window (always 15-minutes).\n   * @param reservePrice The reserve price to kick off the auction.\n   * @param auctionId The id of the auction that was created.\n   */\n  event ReserveAuctionCreated(\n    address indexed seller,\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    uint256 duration,\n    uint256 extensionDuration,\n    uint256 reservePrice,\n    uint256 auctionId\n  );\n  /**\n   * @notice Emitted when an auction that has already ended is finalized,\n   * indicating that the NFT has been transferred and revenue from the sale distributed.\n   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.\n   * @param auctionId The id of the auction that was finalized.\n   * @param seller The address of the seller.\n   * @param bidder The address of the highest bidder that won the NFT.\n   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.\n   * @param creatorFee The amount of ETH that was sent to the creator for this sale.\n   * @param ownerRev The amount of ETH that was sent to the owner for this sale.\n   */\n  event ReserveAuctionFinalized(\n    uint256 indexed auctionId,\n    address indexed seller,\n    address indexed bidder,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev\n  );\n  /**\n   * @notice Emitted when an auction is invalidated due to other market activity.\n   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.\n   * @param auctionId The id of the auction that was invalidated.\n   */\n  event ReserveAuctionInvalidated(uint256 indexed auctionId);\n  /**\n   * @notice Emitted when the seller for an auction has been changed to a new account.\n   * @dev Account migrations require approval from both the original account and Foundation.\n   * @param auctionId The id of the auction that was updated.\n   * @param originalSellerAddress The original address of the auction's seller.\n   * @param newSellerAddress The new address for the auction's seller.\n   */\n  event ReserveAuctionSellerMigrated(\n    uint256 indexed auctionId,\n    address indexed originalSellerAddress,\n    address indexed newSellerAddress\n  );\n  /**\n   * @notice Emitted when the auction's reserve price is changed.\n   * @dev This is only possible if the auction has not received any bids.\n   * @param auctionId The id of the auction that was updated.\n   * @param reservePrice The new reserve price for the auction.\n   */\n  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);\n\n  /// @notice Confirms that the reserve price is not zero.\n  modifier onlyValidAuctionConfig(uint256 reservePrice) {\n    if (reservePrice == 0) {\n      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n    }\n    _;\n  }\n\n  /**\n   * @notice Configures the duration for auctions.\n   * @param duration The duration for auctions, in seconds.\n   */\n  constructor(uint256 duration) {\n    if (duration > MAX_MAX_DURATION) {\n      // This ensures that math in this file will not overflow due to a huge duration.\n      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);\n    }\n    if (duration < EXTENSION_DURATION) {\n      // The auction duration configuration must be greater than the extension window of 15 minutes\n      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);\n    }\n    DURATION = duration;\n  }\n\n  /**\n   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to\n   * the seller (if not active buy price set).\n   * This should only be used for extreme cases such as DMCA takedown requests.\n   * @param auctionId The id of the auction to cancel.\n   * @param reason The reason for the cancellation (a required field).\n   */\n  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)\n    external\n    onlyFoundationAdmin\n    nonReentrant\n  {\n    if (bytes(reason).length == 0) {\n      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n    }\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.amount == 0) {\n      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\n    }\n\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    // Return the NFT to the owner.\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    if (auction.bidder != address(0)) {\n      // Refund the highest bidder if any bids were placed in this auction.\n      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    }\n\n    emit ReserveAuctionCanceledByAdmin(auctionId, reason);\n  }\n\n  /**\n   * @notice Allows an NFT owner and Foundation to work together in order to update the seller\n   * for auctions they have listed to a new account.\n   * @dev This will gracefully skip any auctions that have already been finalized.\n   * @param listedAuctionIds The ids of the auctions to update.\n   * @param originalAddress The original address of the seller of these auctions.\n   * @param newAddress The new address for the seller of these auctions.\n   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`\n   * signed by the original account.\n   */\n  function adminAccountMigration(\n    uint256[] calldata listedAuctionIds,\n    address originalAddress,\n    address payable newAddress,\n    bytes memory signature\n  ) external onlyFoundationOperator {\n    // Validate the owner of the original account has approved this change.\n    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);\n\n    unchecked {\n      // The array length cannot overflow 256 bits.\n      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {\n        uint256 auctionId = listedAuctionIds[i];\n        ReserveAuction storage auction = auctionIdToAuction[auctionId];\n        if (auction.seller != address(0)) {\n          // Only if the auction was found and not finalized before this transaction.\n\n          if (auction.seller != originalAddress) {\n            // Confirm that the signature approval was the correct owner of this auction.\n            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);\n          }\n\n          // Update the auction's seller address.\n          auction.seller = newAddress;\n\n          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.\n   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.\n   * @param auctionId The id of the auction to cancel.\n   */\n  function cancelReserveAuction(uint256 auctionId) external nonReentrant {\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.seller != msg.sender) {\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\n    }\n    if (auction.endTime != 0) {\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n    }\n\n    // Remove the auction.\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    // Transfer the NFT unless it still has a buy price set.\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    emit ReserveAuctionCanceled(auctionId);\n  }\n\n  /**\n   * @notice Creates an auction for the given NFT.\n   * The NFT is held in escrow until the auction is finalized or canceled.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param reservePrice The initial reserve price for the auction.\n   */\n  function createReserveAuction(\n    address nftContract,\n    uint256 tokenId,\n    uint256 reservePrice\n  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {\n    uint256 auctionId = _getNextAndIncrementAuctionId();\n\n    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.\n    _transferToEscrow(nftContract, tokenId);\n\n    // Store the auction details\n    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;\n    auctionIdToAuction[auctionId] = ReserveAuction(\n      nftContract,\n      tokenId,\n      payable(msg.sender),\n      DURATION,\n      EXTENSION_DURATION,\n      0, // endTime is only known once the reserve price is met\n      payable(0), // bidder is only known once a bid has been placed\n      reservePrice\n    );\n\n    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);\n  }\n\n  /**\n   * @notice Once the countdown has expired for an auction, anyone can settle the auction.\n   * This will send the NFT to the highest bidder and distribute revenue for this sale.\n   * @param auctionId The id of the auction to settle.\n   */\n  func"
    }
  ]
}