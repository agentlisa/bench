{
  "Title": "Assembly Block Diverges from Solidity's Memory Model",
  "Content": "[One of the assembly blocks](https://github.com/1inch/solidity-utils/blob/5fdd4c2c02525855e9f64d9a43d779013c6444ea/contracts/libraries/SafeERC20.sol#L423-L430) marked as memory safe contains [operations](https://github.com/1inch/solidity-utils/blob/5fdd4c2c02525855e9f64d9a43d779013c6444ea/contracts/libraries/SafeERC20.sol#L426-L427) that might be memory unsafe [according to the Solidity documentation](https://docs.soliditylang.org/en/v0.8.20/assembly.html#memory-safety). The reason is that the return data size might be greater than the scratch space for some WETH implementations.\n\n\nConsider using the free memory pointer to retrieve an unused memory location as implemented in the [`safeWithdraw` function](https://github.com/1inch/solidity-utils/blob/5fdd4c2c02525855e9f64d9a43d779013c6444ea/contracts/libraries/SafeERC20.sol#L445-L447).\n\n\n***Update:** Resolved in [pull request #104](https://github.com/1inch/solidity-utils/pull/104) at commit [ac7d637](https://github.com/1inch/solidity-utils/commit/ac7d637afd2b426f6288f555a138cc7502319a3d).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"../interfaces/IDaiLikePermit.sol\";\nimport \"../interfaces/IPermit2.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/RevertReasonForwarder.sol\";\n\n/**\n * @title Implements efficient safe methods for ERC20 interface.\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\n * 1. more gas-efficient, providing significant savings in transaction costs.\n * 2. support for different permit implementations\n * 3. forceApprove functionality\n * 4. support for WETH deposit and withdraw\n */\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n    error Permit2TransferAmountTooHigh();\n\n    // Uniswap Permit2 address\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n\n    /**\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\n     * Consumes less gas then regular `ERC20.balanceOf`.\n     * @param token The IERC20 token contract for which the balance will be fetched.\n     * @param account The address of the account whose token balance will be fetched.\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\n     */\n    function safeBalanceOf(\n        IERC20 token,\n        address account\n    ) internal view returns(uint256 tokenBalance) {\n        bytes4 selector = IERC20.balanceOf.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0x00, selector)\n            mstore(0x04, account)\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\n            tokenBalance := mload(0)\n\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another.\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom. \n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\n     */\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, amount);\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(_PERMIT2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens to another address.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /**\n     * @notice Safely increases the allowance of a spender.\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /**\n     * @notice Safely decreases the allowance of a spender.\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to decrease the allowance by.\n     */\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with custom owner and spender parameters. \n     * Permit type is determined automatically based on permit calldata (IERC20Permit, IDaiLikePermit, and IPermit2).\n     * @dev Wraps `tryPermit` function and forwards revert reason if permit fails.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param owner The owner of the tokens for which the permit is made.\n     * @param spender The spender allowed to spend the tokens by the permit.\n     * @param permit The permit data to be used in the function call.\n     */\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    /**\n     * @notice Attempts to execute the `permit` function on the provided token with the sender and contract as parameters.\n     * @dev Invokes `tryPermit` with sender as owner and contract as spender.\n     * @param token The IERC20 token to execute the permit function on.\n     * @param permit The permit data to be used in the function call.\n     * @return success Returns true if the permit function was successfully executed, false otherwise.\n     */\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\n        return tryPermit(token, msg.sender, address(this), permit);\n    }\n\n    /**\n     * @notice The function attempts to call the permit function on a given ERC20 token.\n     * @dev The function is designed to support a variety of permit functions, namely: IERC20Permit, IDaiLikePermit, and IPermit2.\n     * It accommodates both Compact and Full formats of these permit types.\n     * Please note, it is expected that the `expiration` parameter for the compact Permit2 and the `deadline` parameter \n     * for the compact Permit are to be incremented by one before invoking this function. This approach is motivated by\n     * gas efficiency considerations; as the unlimited expiration period is likely to be the most common scenario, and \n     * zeros are cheaper to pass in terms of gas cost. Thus, callers should increment the expiration or deadline by one\n     * before invocation for optimized performance.\n     * @param token The address of the ERC20 token on which to call the permit function.\n     * @param owner The owner of the tokens. This address should have signed the off-chain permit.\n     * @param spender The address which will be approved for transfer of tokens.\n     * @param permit The off-chain permit data, containing different fields depending on the type of permit function.\n     * @return success A boolean indicating whether the permit call was successful.\n     */\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\n        // load function selectors for different permit standards\n        bytes4 permitSelector = IERC20Permit.permit.selector;\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\n        bytes4 permit2Selector = IPermit2.permit.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // Switch case for different permit lengths, indicating different permit standards\n            switch permit.length\n            // Compact IERC20Permit\n            case 100 {\n                mstore(ptr, permitSelector)     // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20))) // loads permit.offset 0x20..0x23\n                    let vs := calldataload(add(permit.offset, 0x44))                 // loads permit.offset 0x44..0x63\n\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20)            // store value     = copy permit.offset 0x00..0x19\n                    mstore(add(ptr, 0x64), sub(deadline, 1))                     // store deadline  = deadline - 1\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))                // store v         = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // store r         = copy permit.offset 0x24..0x43\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))                   // store s         = vs without most significant bit\n                }\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // Compact IDaiLikePermit\n            case 72 {\n                mstore(ptr, daiPermitSelector)  // store selector\n                mstore(add(ptr, 0x04), owner)   // store owner\n                mstore(add(ptr, 0x24), spender) // store spender\n\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04))) // loads permit.offset 0x04..0x07\n                    let vs := calldataload(add(permit.offset, 0x28))               // loads permit.offset 0x28..0x47\n\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset))) // store nonce   = copy permit.offset 0x00..0x03\n                    mstore(add(ptr, 0x64), sub(expiry, 1))                        // store expiry  = expiry - 1\n                    mstore(add(ptr, 0x84), true)                                  // store allowed = true\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))                 // store v       = most significant bit of vs + 27 (27 or 28)\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20)  // store r       = copy permit.offset 0x08..0x27\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))                    // store s       = vs without most significant bit\n                }\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // IERC20Permit\n            case 224 {\n                mstore(ptr, permitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            // IDaiLikePermit\n            case 256 {\n                mstore(ptr, daiPermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            // Compact IPermit2\n            case 96 {\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\n                mstore(ptr, permit2Selector)  // store selector\n                mstore(add(ptr, 0x04), owner) // store owner\n                mstore(add(ptr, 0x24), token) // store token\n\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14)             // store amount = copy permit.offset 0x00..0x13\n                // and(0xffffffffffff, ...) - conversion to uint48 \n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // store expiration = ((permit.offset 0x14..0x17 - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // store nonce = copy permit.offset 0x18..0x1b\n                mstore(add(ptr, 0xa4), spender)                               // store spender\n                // and(0xffffffffffff, ...) - conversion to uint48\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // store sigDeadline = ((permit.offset 0x1c..0x1f - 1) & 0xffffffffffff)\n                mstore(add(ptr, 0xe4), 0x100)                                 // store offset = 256\n                mstore(add(ptr, 0x104), 0x40)                                 // store length = 64\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // store r      = copy permit.offset 0x20..0x3f\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // store vs     = copy permit.offset 0x40..0x5f\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // IPermit2\n            case 352 {\n                mstore(ptr, permit2Selector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length) // copy permit calldata\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\n            }\n            // Unknown\n            default {\n                mstore(ptr, _PERMIT_LENGTH_ERROR)\n                revert(ptr, 4)\n            }\n        }\n    }\n\n    /**\n     * @dev Executes a low level call to a token contract, making it resistant to reversion and erroneous boolean returns.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param selector The function signature that is to be called on the token contract.\n     * @param to The address to which the token amount will be transferred.\n     * @param amount The token amount to be transferred.\n     * @return success A boolean indicating if the call was successful. Returns 'true' on success and 'false' on failure. \n     * In case of success but no returned data, validates that the contract code exists.\n     * In case of returned data, ensures that it's a boolean `true`.\n     */\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely deposits a specified amount of Ether into the IWETH contract. Consumes less gas then regular `IWETH.deposit`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of Ether to deposit into the IWETH contract.\n     */\n    function safeDeposit(IWETH weth, uint256 amount) internal {\n        if (amount > 0) {\n            bytes4 selector = IWETH.deposit.selector;\n            assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n                mstore(0, selector)\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract. Consumes less gas then regular `IWETH.withdraw`.\n     * @dev Uses inline assembly to interact with the IWETH contract.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     */\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.withdraw.selector;\n        assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            mstore(4, amount)\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Safely withdraws a specified amount of wrapped Ether from the IWETH contract to a specified recipient.\n     * Consumes less gas then regular `IWETH.withdraw`.\n     * @param weth The IWETH token contract.\n     * @param amount The amount of wrapped Ether to withdraw from the IWETH contract.\n     * @param to The recipient of the withdrawn Ether.\n     */\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\n        safeWithdraw(weth, amount);\n        if (to != address(this)) {\n            assembly (\"memory-safe\") {  // solhint-disable-line no-inline-assembly\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0, returndatasize())\n                    revert(ptr, returndatasize())\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"../interfaces/IDaiLikePermit.sol\";\nimport \"../interfaces/IPermit2.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/RevertReasonForwarder.sol\";\n\n/**\n * @title Implements efficient safe methods for ERC20 interface.\n * @notice Compared to the standard ERC20, this implementation offers several enhancements:\n * 1. more gas-efficient, providing significant savings in transaction costs.\n * 2. support for different permit implementations\n * 3. forceApprove functionality\n * 4. support for WETH deposit and withdraw\n */\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n    error Permit2TransferAmountTooHigh();\n\n    // Uniswap Permit2 address\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n\n    /**\n     * @notice Fetches the balance of a specific ERC20 token held by an account.\n     * Consumes less gas then regular `ERC20.balanceOf`.\n     * @param token The IERC20 token contract for which the balance will be fetched.\n     * @param account The address of the account whose token balance will be fetched.\n     * @return tokenBalance The balance of the specified ERC20 token held by the account.\n     */\n    function safeBalanceOf(\n        IERC20 token,\n        address account\n    ) internal view returns(uint256 tokenBalance) {\n        bytes4 selector = IERC20.balanceOf.selector;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            mstore(0x00, selector)\n            mstore(0x04, account)\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\n            tokenBalance := mload(0)\n\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another.\n     * @dev If permit2 is true, uses the Permit2 standard; otherwise uses the standard ERC20 transferFrom. \n     * Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     * @param permit2 If true, uses the Permit2 standard for the transfer; otherwise uses the standard ERC20 transferFrom.\n     */\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, amount);\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the ERC20 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens from one address to another using the Permit2 standard.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        assembly (\"memory-safe\") { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(_PERMIT2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /**\n     * @notice Attempts to safely transfer tokens to another address.\n     * @dev Either requires `true` in return data, or requires target to be smart-contract and empty return data.\n     * @param token The IERC20 token contract from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Attempts to approve a spender to spend a certain amount of tokens.\n     * @dev If `approve(from, to, amount)` fails, it tries to set the allowance to zero, and retries the `approve` call.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /**\n     * @notice Safely increases the allowance of a spender.\n     * @dev Increases with safe math check. Checks if the increased allowance will overflow, if yes, then it reverts the transaction.\n     * Then uses `forceApprove` to increase the allowance.\n     * @param token The IERC20 token contract on which the call will be made.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /**\n     * @notice Safely decreases the allowance of a spender.\n     * @dev Decreases with safe math check. Checks if the decreased allowance will underflow, if yes, then it reverts the transaction.\n     *"
    }
  ]
}