{
  "Title": "[M-03] Fund loss when insufficient call value to cover fee",
  "Content": "_Submitted by gzeon_.\n\nFund can be lost if the L1 call value provided is insufficient to cover `_maxSubmissionCost`, or stuck if insufficient to cover `_maxSubmissionCost + (_maxGas * _gasPriceBid)`.\n\n#### Proof of Concept\n\n`outboundTransfer` in `L1LPTGateway` does not check if the call value is sufficient, if it is `< _maxSubmissionCost` the retryable ticket creation will fail and fund is lost; if it is `<_maxSubmissionCost + (_maxGas * _gasPriceBid)` the ticket would require manual execution.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1LPTGateway.sol#L80>\n```solidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) external payable override whenNotPaused returns (bytes memory) {\n    require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n    // nested scope to avoid stack too deep errors\n    address from;\n    uint256 seqNum;\n    bytes memory extraData;\n    {\n        uint256 maxSubmissionCost;\n        (from, maxSubmissionCost, extraData) = parseOutboundData(_data);\n        require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n        // transfer tokens to escrow\n        TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);\n\n        bytes memory outboundCalldata = getOutboundCalldata(\n            _l1Token,\n            from,\n            _to,\n            _amount,\n            extraData\n        );\n\n        seqNum = sendTxToL2(\n            l2Counterpart,\n            from,\n            maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            outboundCalldata\n        );\n    }\n\n    emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);\n\n    return abi.encode(seqNum);\n}\n```\n#### Recommended Mitigation Steps\n\nAdd check similar to the one used in `L1GatewayRouter` provided by Arbitrum team\n\n<https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L236>\n```solidity\nuint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);\nrequire(_maxSubmissionCost > 0, \"NO_SUBMISSION_COST\");\nrequire(msg.value == expectedEth, \"WRONG_ETH_VALUE\");\n```\n\n**[yondonfu (Livepeer) confirmed and disagreed with severity](https://github.com/code-423n4/2022-01-livepeer-findings/issues/238#issuecomment-1018693125):**\n > Labeled as disagree with severity because we think this is a 2 - Med finding. We think that the likelihood of this occurring is low because in almost all cases users should be interacting with this contract using an application that handles calculating the maxSubmissionCost properly which would prevent the reported issue. However, we do think that the impact *if* this occurs is high since LPT *and* ETH could be lost if the reported issue happens. Thus, we think 2 - Med is appropriate given that assets are not at direct risk, but there is a low probability path for assets to be lost.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-livepeer-findings/issues/238#issuecomment-1025009724):**\n > I agree, there is potential for unintentional loss of funds, however, the attack vector makes assumptions on how this might occur. Due to the unlikely nature, I agree that this should be a `medium` severity issue..\n\n**[yondonfu (Livepeer) resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/238#issuecomment-1026220888):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/commit/6615bb8ce0fced895acd0e5d3e826c1e7b5d0138\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-livepeer",
  "Code": [
    {
      "filename": "contracts/L1/gateway/L1LPTGateway.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ControlledGateway} from \"../../ControlledGateway.sol\";\nimport {L1ArbitrumMessenger} from \"./L1ArbitrumMessenger.sol\";\nimport {IL1LPTGateway} from \"./IL1LPTGateway.sol\";\nimport {IL2LPTGateway} from \"../../L2/gateway/IL2LPTGateway.sol\";\n\ninterface TokenLike {\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IMinter {\n    function bridgeMint(address _to, uint256 _amount) external;\n}\n\n/**\n * @title L1LPTGateway\n * @notice Manages inbound and outbound transfers of LPT between L1 and Arbitrum Rollup\n * @dev the contract can be paused by the governor which will prevent any outbound transfers\n * but pausing the contract does not affect inbound transfers (tokens coming from L2)\n */\ncontract L1LPTGateway is IL1LPTGateway, ControlledGateway, L1ArbitrumMessenger {\n    address public immutable l1Router;\n    address public immutable l1LPTEscrow;\n    address public l2Counterpart;\n    address public minter;\n\n    constructor(\n        address _l1Router,\n        address _l1LPTEscrow,\n        address _l1Lpt,\n        address _l2Lpt,\n        address _inbox\n    ) ControlledGateway(_l1Lpt, _l2Lpt) L1ArbitrumMessenger(_inbox) {\n        l1Router = _l1Router;\n        l1LPTEscrow = _l1LPTEscrow;\n    }\n\n    /**\n     * @notice Sets address of companion L2LPTGateway\n     * @dev Only address with the governor role is allowed to change the value of l2Counterpart\n     * @param _l2Counterpart L2 Address of the counterpart\n     */\n    function setCounterpart(address _l2Counterpart)\n        external\n        onlyRole(GOVERNOR_ROLE)\n    {\n        l2Counterpart = _l2Counterpart;\n    }\n\n    /**\n     * @notice Sets address of Minter\n     * @dev Only address with the governor role is allowed to change the value of minter\n     * @param _minter L1 Address of minter\n     */\n    function setMinter(address _minter) external onlyRole(GOVERNOR_ROLE) {\n        minter = _minter;\n    }\n\n    /**\n     * @notice Creates and sends a retryable ticket to migrate LPT to L2 using arbitrum Inbox.\n     * The tokens are sent to the Escrow contract for safekeeping until they are withdrawn\n     * The ticket must be redeemed on L2 to receive tokens at the specified address.\n     * @dev maxGas and gasPriceBid must be set using arbitrum's Inbox.estimateRetryableTicket method.\n     * @param _l1Token L1 Address of LPT\n     * @param _to Recepient address on L2\n     * @param _amount Amount of tokens to tranfer\n     * @param _maxGas Gas limit for L2 execution of the ticket\n     * @param _gasPriceBid Price per gas on L2\n     * @param _data Encoded maxSubmission cost and sender address along with additional calldata\n     * @return seqNum Sequence number of the retryable ticket created by Inbox\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable override whenNotPaused returns (bytes memory) {\n        require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n        // nested scope to avoid stack too deep errors\n        address from;\n        uint256 seqNum;\n        bytes memory extraData;\n        {\n            uint256 maxSubmissionCost;\n            (from, maxSubmissionCost, extraData) = parseOutboundData(_data);\n            require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n            // transfer tokens to escrow\n            TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);\n\n            bytes memory outboundCalldata = getOutboundCalldata(\n                _l1Token,\n                from,\n                _to,\n                _amount,\n                extraData\n            );\n\n            seqNum = sendTxToL2(\n                l2Counterpart,\n                from,\n                maxSubmissionCost,\n                _maxGas,\n                _gasPriceBid,\n                outboundCalldata\n            );\n        }\n\n        emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);\n\n        return abi.encode(seqNum);\n    }\n\n    /**\n     * @notice Receives withdrawn token amount from L2\n     * The equivalent tokens are released from the Escrow contract and sent to the destination\n     * In case the escrow doesn't have enough balance, new tokens are minted\n     * @dev can only accept txs coming directly from L2 LPT Gateway\n     * @param l1Token L1 Address of LPT\n     * @param from Address of the sender\n     * @param to Recepient address on L1\n     * @param amount Amount of tokens transferred\n     * @param data Contains exitNum which is always set to 0\n     */\n    function finalizeInboundTransfer(\n        address l1Token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external override onlyL2Counterpart(l2Counterpart) {\n        require(l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n        (uint256 exitNum, ) = abi.decode(data, (uint256, bytes));\n\n        uint256 escrowBalance = TokenLike(l1Token).balanceOf(l1LPTEscrow);\n\n        // mint additional tokens if requested amount exceeds escrowed amount\n        if (amount <= escrowBalance) {\n            TokenLike(l1Token).transferFrom(l1LPTEscrow, to, amount);\n        } else {\n            if (escrowBalance > 0) {\n                TokenLike(l1Token).transferFrom(l1LPTEscrow, to, escrowBalance);\n            }\n            IMinter(minter).bridgeMint(to, amount - escrowBalance);\n        }\n\n        emit WithdrawalFinalized(l1Token, from, to, exitNum, amount);\n    }\n\n    /**\n     * @notice decodes calldata required for migration of tokens\n     * @dev data must include maxSubmissionCost, extraData can be left empty\n     * @param data encoded callhook data\n     * @return from sender of the tx\n     * @return maxSubmissionCost base ether value required to keep retyrable ticket alive\n     * @return extraData any other data sent to L2\n     */\n    function parseOutboundData(bytes memory data)\n        internal\n        view\n        returns (\n            address from,\n            uint256 maxSubmissionCost,\n            bytes memory extraData\n        )\n    {\n        if (msg.sender == l1Router) {\n            // router encoded\n            (from, extraData) = abi.decode(data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = data;\n        }\n        // user encoded\n        (maxSubmissionCost, extraData) = abi.decode(\n            extraData,\n            (uint256, bytes)\n        );\n    }\n\n    /**\n     * @notice returns address of L2 LPT Gateway\n     */\n    function counterpartGateway() external view override returns (address) {\n        return l2Counterpart;\n    }\n\n    /**\n     * @notice returns address of L2 version of LPT\n     */\n    function calculateL2TokenAddress(address l1Token)\n        external\n        view\n        override\n        returns (address)\n    {\n        if (l1Token != l1Lpt) {\n            return address(0);\n        }\n\n        return l2Lpt;\n    }\n\n    /**\n     * @notice Creates calldata required to create a retryable ticket\n     * @dev encodes the target function with its params which\n     * will be called on L2 when the retryable ticket is redeemed\n     */\n    function getOutboundCalldata(\n        address l1Token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data\n    ) public pure returns (bytes memory outboundCalldata) {\n        bytes memory emptyBytes = \"\";\n\n        outboundCalldata = abi.encodeWithSelector(\n            IL2LPTGateway.finalizeInboundTransfer.selector,\n            l1Token,\n            from,\n            to,\n            amount,\n            abi.encode(emptyBytes, data)\n        );\n\n        return outboundCalldata;\n    }\n}"
    }
  ]
}