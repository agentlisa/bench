{
  "Title": "H-5: Malicious registrant can front-run `RFPSimpleStrategy._allocate()` in order to change the `proposalBid` and get a bigger payout in the distribution",
  "Content": "# Issue H-5: Malicious registrant can front-run `RFPSimpleStrategy._allocate()` in order to change the `proposalBid` and get a bigger payout in the distribution \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/497 \n\n## Found by \n0xbepresent, 0xdeadbeef, WATCHPUG, detectiveking, honeymewn, jah, jkoppel, qbs, rvierdiiev\nThe `RFPSimpleStrategy::_allocate()` function can be frontrun by a malicious `registrant` chainging the `proposalBid` and get a bigger payout in the `RFPSimpleStrategy::_distribute()` function.\n\n## Vulnerability Detail\n\nUsers can register to the pool strategy using the [RFPSimpleStrategy::_registerRecipient()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L314C14-L314C32) function specifying the [proposalBid](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L378) in the registration. Then the pool manager [accepts the `registrant recipient`](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L404) using the [RFPSimpleStrategy::_allocate()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L386) function.\n\nThe problem is that the execution of the `RFPSimpleStrategy::_allocate()` function by the `pool manager` can be frontun by a malicious `registrant recipient`. Consider the next scenario:\n\n1. `UserA` call the `RFPSimpleStrategy::_registerRecipient()` using a `proposalBid=10`.\n2. Pool manager accepts the proposal by `UserA` and call the `RFPSimpleStrategy::_allocate()` function.\n3. `UserA` monitors the mempool and frontrun the manager `_allocate()` execution changing the proposal now `proposalBid=50`.\n4. The `step 2` call finally is executed but the using non-agreed proposal `proposalBid=50`.\n\nNow the `UserA` is accepted registrant recipient with non-agreed proposal bid (`proposalBid=50`).\n\n## Impact\n\nMalicious registrant can change the `proposalBid` to a non-agreed term causing that he can receive a bigger payout in the [RFPSimpleStrategy::_distribute()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L417) function because in the [code line 435](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L435) the `proposalBid` is used to calculate the amount to pay to the `accepted registrant recipient`:\n\n```solidity\nFile: RFPSimpleStrategy.sol\n417:     function _distribute(address[] memory, bytes memory, address _sender)\n418:         internal\n419:         virtual\n420:         override\n421:         onlyInactivePool\n422:         onlyPoolManager(_sender)\n423:     {\n...\n...\n433: \n434:         // Calculate the amount to be distributed for the milestone\n435:         uint256 amount = (recipient.proposalBid * milestone.amountPercentage) / 1e18;\n436: \n437:         // Get the pool, subtract the amount and transfer to the recipient\n438:         poolAmount -= amount;\n439:         _transferAmount(pool.token, recipient.recipientAddress, amount);\n...\n...\n450:     }\n```\n\nThe malicious accepted registrant can drain all funds from the pool strategy using one milestone.\n\n## Code Snippet\n\n- [RFPSimpleStrategy::_registerRecipient()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L314C14-L314C32)\n- [RFPSimpleStrategy::_allocate()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L386)\n- [RFPSimpleStrategy::_distribute()](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L417)\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nVerify the `proposalBid` when the `_allocate()` occurs:\n\n```diff\n    function _allocate(bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        nonReentrant\n        onlyActivePool\n        onlyPoolManager(_sender)\n    {\n        // Decode the '_data'\n--      acceptedRecipientId = abi.decode(_data, (address));\n++      (acceptedRecipientId, uint256 expectedProposalBid) = abi.decode(_data, (address, uint256));\n\n        Recipient storage recipient = _recipients[acceptedRecipientId];\n\n--      if (acceptedRecipientId == address(0) || recipient.recipientStatus != Status.Pending) {\n++      if (acceptedRecipientId == address(0) || recipient.recipientStatus != Status.Pending || recipient.proposalBid != expectedProposalBid) {\n            revert RECIPIENT_ERROR(acceptedRecipientId);\n        }\n\n        // Update status of acceptedRecipientId to accepted\n        recipient.recipientStatus = Status.Accepted;\n\n        _setPoolActive(false);\n\n        IAllo.Pool memory pool = allo.getPool(poolId);\n\n        // Emit event for the allocation\n        emit Allocated(acceptedRecipientId, recipient.proposalBid, pool.token, _sender);\n    }\n```\n\n\n\n## Discussion\n\n**thelostone-mc**\n\nYup this does feel safer. The only downside is that the pool manager could now put in a big lower than what was proposed by the recipient but this seems alright as the pool manager is a trusted actor \n\n**kadenzipfel**\n\nEscalate\nThis is simply a less severe version of frontrunning `_distribute` by flipping the unprotected `setPoolActive` flag, as described in https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/458. \n\nThere are two directions which may be reasonable in reclassifying this:\n\n1) Reduce the severity to medium since the pool manager can become aware of this attack vector and not fulfill distributions for attackers (note that there is a `withdraw` function and thus not all funds must be distributed). This is inline with the medium severity classifications as, \"There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost.\" Whereas for https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/458, the high severity classification of, \"This vulnerability _would_ result in a material loss of funds\" is true because the pool manager cannot prevent distribution after already submitting the transaction.\n\n2) If however, this vulnerability is maintained as high severity (which I would disagree with), it should be duplicated with https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/458 as they are both fundamentally the same attack vector, although this one is less significant.\n\n**sherlock-admin2**\n\n > Escalate\n> This is simply a less severe version of frontrunning `_distribute` by flipping the unprotected `setPoolActive` flag, as described in https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/458. \n> \n> There are two directions which may be reasonable in reclassifying this:\n> \n> 1) Reduce the severity to medium since the pool manager can become aware of this attack vector and not fulfill distributions for attackers (note that there is a `withdraw` function and thus not all funds must be distributed). This is inline with the medium severity classifications as, \"There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost.\" Whereas for https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/458, the high severity classification of, \"This vulnerability _would_ result in a material loss of funds\" is true because the pool manager cannot prevent distribution after already submitting the transaction.\n> \n> 2) If however, this vulnerability is maintained as high severity (which I would disagree with), it should be duplicated with https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/458 as they are both fundamentally the same attack vector, although this one is less significant.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**jkoppel**\n\nSimilar attack vector, different issue. Fixing #458  does not fix this. The proposed fix of this issue has no impact on #458. See #378 for a way to use this attack which is far harder to defend against.\n\n**neeksec**\n\nSide with @jkoppel and sugguest to keep the orginal judging.\n\n**jacksanford1**\n\nhttps://github.com/allo-protocol/allo-v2/pull/346\n\n**Evert0x**\n\nPlanning to reject escalation and keep issue state as is.\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [kadenzipfel](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/497/#issuecomment-1763179377): rejected\n\n**jack-the-pug**\n\nFixed.\n\nA better fix would be to make it impossible to change the proposal once it is in the allocation stage: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/657\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {ReentrancyGuard} from \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title RFP Simple Strategy\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Strategy for Request for Proposal (RFP) allocation with milestone submission and management.\ncontract RFPSimpleStrategy is BaseStrategy, ReentrancyGuard {\n    /// ================================\n    /// ========== Struct ==============\n    /// ================================\n\n    /// @notice Stores the details of the recipients.\n    struct Recipient {\n        bool useRegistryAnchor;\n        address recipientAddress;\n        uint256 proposalBid;\n        Status recipientStatus;\n    }\n\n    /// @notice Stores the details of the milestone\n    struct Milestone {\n        uint256 amountPercentage;\n        Metadata metadata;\n        Status milestoneStatus;\n    }\n\n    /// @notice Stores the details needed for initializing strategy\n    struct InitializeParams {\n        uint256 maxBid;\n        bool useRegistryAnchor;\n        bool metadataRequired;\n    }\n\n    /// ===============================\n    /// ========== Errors =============\n    /// ===============================\n\n    /// @notice Thrown when the milestone is invalid\n    error INVALID_MILESTONE();\n\n    /// @notice Thrown when the milestone is already accepted\n    error MILESTONE_ALREADY_ACCEPTED();\n\n    /// @notice Thrown when the proposal bid exceeds maximum bid\n    error EXCEEDING_MAX_BID();\n\n    /// @notice Thrown when the milestone are already approved and cannot be changed\n    error MILESTONES_ALREADY_SET();\n\n    /// @notice Thrown when the pool manager attempts to the lower the max bid\n    error AMOUNT_TOO_LOW();\n\n    /// ===============================\n    /// ========== Events =============\n    /// ===============================\n\n    /// @notice Emitted when the maximum bid is increased.\n    /// @param maxBid The mew maximum bid\n    event MaxBidIncreased(uint256 maxBid);\n\n    /// @notice Emitted when a milestone is submitted.\n    /// @param milestoneId Id of the milestone\n    event MilstoneSubmitted(uint256 milestoneId);\n\n    /// @notice Emitted for the status change of a milestone.\n    event MilestoneStatusChanged(uint256 milestoneId, Status status);\n\n    /// @notice Emitted when milestones are set.\n    event MilestonesSet();\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId Id of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender);\n\n    /// ================================\n    /// ========== Storage =============\n    /// ================================\n\n    /// @notice Flag to indicate whether to use the registry anchor or not.\n    bool public useRegistryAnchor;\n\n    /// @notice Flag to indicate whether metadata is required or not.\n    bool public metadataRequired;\n\n    /// @notice The accepted recipient who can submit milestones.\n    address public acceptedRecipientId;\n\n    /// @notice The registry contract interface.\n    IRegistry private _registry;\n\n    /// @notice The maximum bid for the RFP pool.\n    uint256 public maxBid;\n\n    /// @notice The upcoming milestone which is to be paid.\n    uint256 public upcomingMilestone;\n\n    /// @notice Internal collection of recipients\n    address[] private _recipientIds;\n\n    /// @notice Collection of milestones submitted by the 'acceptedRecipientId'\n    Milestone[] public milestones;\n\n    /// @notice This maps accepted recipients to their details\n    /// @dev 'recipientId' to 'Recipient'\n    mapping(address => Recipient) internal _recipients;\n\n    /// ===============================\n    /// ======== Constructor ==========\n    /// ===============================\n\n    /// @notice Constructor for the RFP Simple Strategy\n    /// @param _allo The 'Allo' contract\n    /// @param _name The name of the strategy\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    // @notice Initialize the strategy\n    /// @param _poolId ID of the pool\n    /// @param _data The data to be decoded\n    /// @custom:data (uint256 _maxBid, bool registryGating, bool metadataRequired)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override {\n        (InitializeParams memory initializeParams) = abi.decode(_data, (InitializeParams));\n        __RFPSimpleStrategy_init(_poolId, initializeParams);\n    }\n\n    /// @notice This initializes the BaseStrategy\n    /// @dev You only need to pass the 'poolId' to initialize the BaseStrategy and the rest is specific to the strategy\n    /// @param _initializeParams The initialize params\n    function __RFPSimpleStrategy_init(uint256 _poolId, InitializeParams memory _initializeParams) internal {\n        // Initialize the BaseStrategy\n        __BaseStrategy_init(_poolId);\n\n        // Set the strategy specific variables\n        useRegistryAnchor = _initializeParams.useRegistryAnchor;\n        metadataRequired = _initializeParams.metadataRequired;\n        _registry = allo.getRegistry();\n        _increaseMaxBid(_initializeParams.maxBid);\n\n        // Set the pool to active - this is required for the strategy to work and distribute funds\n        // NOTE: There may be some cases where you may want to not set this here, but will be strategy specific\n        _setPoolActive(true);\n    }\n\n    /// ===============================\n    /// ============ Views ============\n    /// ===============================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return Recipient Returns the recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Checks if msg.sender is eligible for RFP allocation\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Return the payout for acceptedRecipientId\n    function getPayouts(address[] memory, bytes[] memory) external view override returns (PayoutSummary[] memory) {\n        PayoutSummary[] memory payouts = new PayoutSummary[](1);\n        payouts[0] = _getPayout(acceptedRecipientId, \"\");\n\n        return payouts;\n    }\n\n    /// @notice Get the milestone\n    /// @param _milestoneId ID of the milestone\n    /// @return Milestone Returns the milestone\n    function getMilestone(uint256 _milestoneId) external view returns (Milestone memory) {\n        return milestones[_milestoneId];\n    }\n\n    /// @notice Get the status of the milestone\n    /// @param _milestoneId Id of the milestone\n    function getMilestoneStatus(uint256 _milestoneId) external view returns (Status) {\n        return milestones[_milestoneId].milestoneStatus;\n    }\n\n    /// ===============================\n    /// ======= External/Custom =======\n    /// ===============================\n\n    /// @notice Toggle the status between active and inactive.\n    /// @dev 'msg.sender' must be a pool manager to close the pool. Emits a 'PoolActive()' event.\n    /// @param _flag The flag to set the pool to active or inactive\n    function setPoolActive(bool _flag) external {\n        _setPoolActive(_flag);\n        emit PoolActive(_flag);\n    }\n\n    /// @notice Set the milestones for the acceptedRecipientId.\n    /// @dev 'msg.sender' must be a pool manager to set milestones. Emits 'MilestonesSet' event\n    /// @param _milestones Milestone[] The milestones to be set\n    function setMilestones(Milestone[] memory _milestones) external onlyPoolManager(msg.sender) {\n        if (upcomingMilestone != 0) revert MILESTONES_ALREADY_SET();\n\n        uint256 totalAmountPercentage;\n\n        // Loop through the milestones and add them to the milestones array\n        uint256 milestonesLength = _milestones.length;\n        for (uint256 i; i < milestonesLength;) {\n            totalAmountPercentage += _milestones[i].amountPercentage;\n            milestones.push(_milestones[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        // Check if the all milestone amount percentage totals to 1e18(100%)\n        if (totalAmountPercentage != 1e18) revert INVALID_MILESTONE();\n\n        emit MilestonesSet();\n    }\n\n    /// @notice Submit milestone by the acceptedRecipientId.\n    /// @dev 'msg.sender' must be the 'acceptedRecipientId' and must be a member\n    ///      of a 'Profile' to sumbit a milestone. Emits a 'MilestonesSubmitted()' event.\n    /// @param _metadata The proof of work\n    function submitUpcomingMilestone(Metadata calldata _metadata) external {\n        // Check if the 'msg.sender' is the 'acceptedRecipientId' and is a member of the 'Profile'\n        if (acceptedRecipientId != msg.sender && !_isProfileMember(acceptedRecipientId, msg.sender)) {\n            revert UNAUTHORIZED();\n        }\n\n        // Check if the upcoming milestone is in fact upcoming\n        if (upcomingMilestone >= milestones.length) revert INVALID_MILESTONE();\n\n        // Get the milestone and update the metadata and status\n        Milestone storage milestone = milestones[upcomingMilestone];\n        milestone.metadata = _metadata;\n\n        // Set the milestone status to 'Pending' to indicate that the milestone is submitted\n        milestone.milestoneStatus = Status.Pending;\n\n        // Emit event for the milestone\n        emit MilstoneSubmitted(upcomingMilestone);\n    }\n\n    /// @notice Update max bid for RFP pool\n    /// @dev 'msg.sender' must be a pool manager to update the max bid.\n    /// @param _maxBid The max bid to be set\n    function increaseMaxBid(uint256 _maxBid) external onlyPoolManager(msg.sender) {\n        _increaseMaxBid(_maxBid);\n    }\n\n    /// @notice Reject pending milestone submmited by the acceptedRecipientId.\n    /// @dev 'msg.sender' must be a pool manager to reject a milestone. Emits a 'MilestoneStatusChanged()' event.\n    /// @param _milestoneId ID of the milestone\n    function rejectMilestone(uint256 _milestoneId) external onlyPoolManager(msg.sender) {\n        // Check if the milestone is already accepted\n        if (milestones[_milestoneId].milestoneStatus == Status.Accepted) revert MILESTONE_ALREADY_ACCEPTED();\n\n        milestones[_milestoneId].milestoneStatus = Status.Rejected;\n\n        emit MilestoneStatusChanged(_milestoneId, milestones[_milestoneId].milestoneStatus);\n    }\n\n    /// @notice Withdraw funds from pool.\n    /// @dev 'msg.sender' must be a pool manager to withdraw funds.\n    /// @param _amount The amount to be withdrawn\n    function withdraw(uint256 _amount) external onlyPoolManager(msg.sender) onlyInactivePool {\n        // Decrement the pool amount\n        poolAmount -= _amount;\n\n        // Transfer the amount to the pool manager\n        _transferAmount(allo.getPool(poolId).token, msg.sender, _amount);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Submit a proposal to RFP pool\n    /// @dev Emits a 'Registered()' event\n    /// @param _data The data to be decoded\n    /// @custom:data when 'useRegistryAnchor' is 'true' -> (address recipientId, uint256 proposalBid, Metadata metadata)\n    ///              when 'useRegistryAnchor' is 'false' -> (address recipientAddress, address registryAnchor, uint256 proposalBid, Metadata metadata)\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The id of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        override\n        onlyActivePool\n        returns (address recipientId)\n    {\n        bool isUsingRegistryAnchor;\n        address recipientAddress;\n        address registryAnchor;\n        uint256 proposalBid;\n        Metadata memory metadata;\n\n        // Decode '_data' depending on the 'useRegistryAnchor' flag\n        if (useRegistryAnchor) {\n            /// @custom:data when 'true' -> (address recipientId, uint256 proposalBid, Metadata metadata)\n            (recipientId, proposalBid, metadata) = abi.decode(_data, (address, uint256, Metadata));\n\n            // If the sender is not a profile member this will revert\n            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        } else {\n            //  @custom:data when 'false' -> (address recipientAddress, address registryAnchor, uint256 proposalBid, Metadata metadata)\n            (recipientAddress, registryAnchor, proposalBid, metadata) =\n                abi.decode(_data, (address, address, uint256, Metadata));\n\n            // Check if the registry anchor is valid so we know whether to use it or not\n            isUsingRegistryAnchor = registryAnchor != address(0);\n\n            // Ternerary to set the recipient id based on whether or not we are using the 'registryAnchor' or '_sender'\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // Checks if the '_sender' is a member of the profile 'anchor' being used and reverts if not\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        }\n\n        // Check if the metadata is required and if it is, check if it is valid, otherwise revert\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        if (proposalBid > maxBid) {\n            // If the proposal bid is greater than the max bid this will revert\n            revert EXCEEDING_MAX_BID();\n        } else if (proposalBid == 0) {\n            // If the proposal bid is 0, set it to the max bid\n            proposalBid = maxBid;\n        }\n\n        // If the recipient address is the zero address this will revert\n        if (recipientAddress == address(0)) revert RECIPIENT_ERROR(recipientId);\n\n        // Get the recipient\n        Recipient storage recipient = _recipients[recipientId];\n\n        if (recipient.recipientStatus == Status.None) {\n            // If the recipient status is 'None' add the recipient to the '_recipientIds' array\n            _recipientIds.push(recipientId);\n            emit Registered(recipientId, _data, _sender);\n        } else {\n            emit UpdatedRegistration(recipientId, _data, _sender);\n        }\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.useRegistryAnchor = isUsingRegistryAnchor ? true : recipient.useRegistryAnchor;\n        recipient.proposalBid = proposalBid;\n        recipient.recipientStatus = Status.Pending;\n    }\n\n    /// @notice Select recipient for RFP allocation\n    /// @dev '_sender' must be a pool manager to allocate.\n    /// @param _data The data to be decoded\n    /// @param _sender The sender of the allocation\n    function _allocate(bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        nonReentrant\n        onlyActivePool\n        onlyPoolManager(_sender)\n    {\n        // Decode the '_data'\n        acceptedRecipientId = abi.decode(_data, (address));\n\n        Recipient storage recipient = _recipients[acceptedRecipientId];\n\n        if (acceptedRecipientId == address(0) || recipient.recipientStatus != Status.Pending) {\n            revert RECIPIENT_ERROR(acceptedRecipientId);\n        }\n\n        // Update status of acceptedRecipientId to accepted\n        recipient.recipientStatus = Status.Accepted;\n\n        _setPoolActive(false);\n\n        IAllo.Pool memory pool = allo.getPool(poolId);\n\n        // Emit event for the allocation\n        emit Allocated(acceptedRecipientId, recipient.proposalBid, pool.token, _sender);\n    }\n\n    /// @notice Distribute the upcoming milestone to acceptedRecipientId.\n    /// @dev '_sender' must be a pool manager to distribute.\n    /// @param _sender The sender of the distribution\n    function _distribute(address[] memory, bytes memory, address _sender)\n        internal\n        virtual\n        override\n        onlyInactivePool\n        onlyPoolManager(_sender)\n    {\n        // check to make sure there is a pending milestone\n        if (upcomingMilestone >= milestones.length) revert INVALID_MILESTONE();\n\n        IAllo.Pool memory pool = allo.getPool(poolId);\n        Milestone storage milestone = milestones[upcomingMilestone];\n        Recipient memory recipient = _recipients[acceptedRecipientId];\n\n        // make sure has enough funds to distribute based on the proposal bid\n        if (recipient.proposalBid > poolAmount) revert NOT_ENOUGH_FUNDS();\n\n        // Calculate the amount to be distributed for the milestone\n        uint256 amount = (recipient.proposalBid * milestone.amountPercentage) / 1e18;\n\n        // Get the pool, subtract the amount and transfer to the recipient\n        poolAmount -= amount;\n        _transferAmount(pool.token, recipient.recipientAddress, amount);\n\n        // Set the milestone status to 'Accepted'\n        milestone.milestoneStatus = Status.Accepted;\n\n        // Increment the upcoming milestone\n        upcomingMilestone++;\n\n        // Emit events for the milestone and the distribution\n        emit MilestoneStatusChanged(upcomingMilestone, Status.Accepted);\n        emit Distributed(acceptedRecipientId, recipient.recipientAddress, amount, _sender);\n    }\n\n    /// @notice Check if sender is a profile owner or member.\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return 'true' if the sender is the owner or member of the profile, otherwise 'false'\n    function _isProfileMember(address _anchor, address _sender) internal view returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Get the recipient.\n    /// @param _recipientId ID of the recipient\n    /// @return recipient Returns the recipient information\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory recipient) {\n        recipient = _recipients[_recipientId];\n\n        if (acceptedRecipientId != address(0) && acceptedRecipientId != _recipientId) {\n            recipient.recipientStatus = recipient.recipientStatus > Status.None ? Status.Rejected : Status.None;\n        }\n    }\n\n    /// @notice Increase max bid for RFP pool\n    /// @param _maxBid The new max bid to be set\n    function _increaseMaxBid(uint256 _maxBid) internal {\n        // make sure the new max bid is greater than the current max bid\n        if (_maxBid < maxBid) revert AMOUNT_TOO_LOW();\n\n        maxBid = _maxBid;\n\n        // emit the new max mid\n        emit MaxBidIncreased(maxBid);\n    }\n\n    /// @notice Get the payout summary for the accepted recipient.\n    /// @return Returns the payout summary for the accepted recipient\n    function _getPayout(address _recipientId, bytes memory) internal view override returns (PayoutSummary memory) {\n        Recipient memory recipient = _recipients[_recipientId];\n        return PayoutSummary(recipient.recipientAddress, recipient.proposalBid);\n    }\n\n    /// @notice Checks if address is eligible allocator.\n    /// @dev This is used to check if the allocator is a pool manager and able to allocate funds from the pool\n    /// @param _allocator Address of the allocator\n    /// @return 'true' if the allocator is a pool manager, otherwise false\n    function _isValidAllocator(address _allocator) internal view override returns (bool) {\n        return allo.isPoolManager(poolId, _allocator);\n    }\n\n    /// @notice This contract should be able to receive native token\n    receive() external payable {}\n}"
    },
    {
      "filename": "allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {ReentrancyGuard} from \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title RFP Simple Strategy\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Strategy for Request for Proposal (RFP) allocation with milestone submission and management.\ncontract RFPSimpleStrategy is BaseStrategy, ReentrancyGuard {\n    /// ================================\n    /// ========== Struct ==============\n    /// ================================\n\n    /// @notice Stores the details of the recipients.\n    struct Recipient {\n        bool useRegistryAnchor;\n        address recipientAddress;\n        uint256 proposalBid;\n        Status recipientStatus;\n    }\n\n    /// @notice Stores the details of the milestone\n    struct Milestone {\n        uint256 amountPercentage;\n        Metadata metadata;\n        Status milestoneStatus;\n    }\n\n    /// @notice Stores the details needed for initializing strategy\n    struct InitializeParams {\n        uint256 maxBid;\n        bool useRegistryAnchor;\n        bool metadataRequired;\n    }\n\n    /// ===============================\n    /// ========== Errors =============\n    /// ===============================\n\n    /// @notice Thrown when the milestone is invalid\n    error INVALID_MILESTONE();\n\n    /// @notice Thrown when the milestone is already accepted\n    error MILESTONE_ALREADY_ACCEPTED();\n\n    /// @notice Thrown when the proposal bid exceeds maximum bid\n    error EXCEEDING_MAX_BID();\n\n    /// @notice Thrown when the milestone are already approved and cannot be changed\n    error MILESTONES_ALREADY_SET();\n\n    /// @notice Thrown when the pool manager attempts to the lower the max bid\n    error AMOUNT_TOO_LOW();\n\n    /// ===============================\n    /// ========== Events =============\n    /// ===============================\n\n    /// @notice Emitted when the maximum bid is increased.\n    /// @param maxBid The mew maximum bid\n    event MaxBidIncreased(uint256 maxBid);\n\n    /// @notice Emitted when a milestone is submitted.\n    /// @param milestoneId Id of the milestone\n    event MilstoneSubmitted(uint256 milestoneId);\n\n    /// @notice Emitted for the status change of a milestone.\n    event MilestoneStatusChanged(uint256 milestoneId, Status status);\n\n    /// @notice Emitted when milestones are set.\n    event MilestonesSet();\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId Id of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender);\n\n    /// ================================\n    /// ========== Storage =============\n    /// ================================\n\n    /// @notice Flag to indicate whether to use the registry anchor or not.\n    bool public useRegistryAnchor;\n\n    /// @notice Flag to indicate whether metadata is required or not.\n    bool public metadataRequired;\n\n    /// @notice The accepted recipient who can submit milestones.\n    address public acceptedRecipientId;\n\n    /// @notice The registry contract interface.\n    IRegistry private _registry;\n\n    /// @notice The maximum bid for the RFP pool.\n    uint256 public maxBid;\n\n    /// @notice The upcoming milestone which is to be paid.\n    uint256 public upcomingMilestone;\n\n    /// @notice Internal collection of recipients\n    address[] private _recipientIds;\n\n    /// @notice Collection of milestones submitted by the 'acceptedRecipientId'\n    Milestone[] public milestones;\n\n    /// @notice This maps accepted recipients to their details\n    /// @dev 'recipientId' to 'Recipient'\n    mapping(address => Recipient) internal _recipients;\n\n    /// ===============================\n    /// ======== Constructor ==========\n    /// ===============================\n\n    /// @notice Constructor for the RFP Simple Strategy\n    /// @param _allo The 'Allo' contract\n    /// @param _name The name of the strategy\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    // @notice Initialize the strategy\n    /// @param _poolId ID of the pool\n    /// @param _data The data to be decoded\n    /// @custom:data (uint256 _maxBid, bool registryGating, bool metadataRequired)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override {\n        (InitializeParams memory initializeParams) = abi.decode(_data, (InitializeParams));\n        __RFPSimpleStrategy_init(_poolId, initializeParams);\n    }\n\n    /// @notice This initializes the BaseStrategy\n    /// @dev You only need to pass the 'poolId' to initialize the BaseStrategy and the rest is specific to the strategy\n    /// @param _initializeParams The initialize params\n    function __RFPSimpleStrategy_init(uint256 _poolId, InitializeParams memory _initializeParams) internal {\n        // Initialize the BaseStrategy\n        __BaseStrategy_init(_poolId);\n\n        // Set the strategy specific variables\n        useRegistryAnchor = _initializeParams.useRegistryAnchor;\n        metadataRequired = _initializeParams.metadataRequired;\n        _registry = allo.getRegistry();\n        _increaseMaxBid(_initializeParams.maxBid);\n\n        // Set the pool to active - this is required for the strategy to work and distribute funds\n        // NOTE: There may be some cases where you may want to not set this here, but will be strategy specific\n        _setPoolActive(true);\n    }\n\n    /// ===============================\n    /// ============ Views ============\n    /// ===============================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return Recipient Returns the recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Checks if msg.sender is eligible for RFP allocation\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Return the payout for acceptedRecipientId\n    function getPayouts(address[] memory, bytes[] memory) external view override returns (PayoutSummary[] memory) {\n        PayoutSummary[] memory payouts = new PayoutSummary[](1);\n        payouts[0] = _getPayout(acceptedRecipientId, \"\");\n\n        return payouts;\n    }\n\n    /// @notice Get the milestone\n    /// @param _milestoneId ID of the milestone\n    /// @return Milestone Returns the milestone\n    function getMilestone(uint256 _milestoneId) external view returns (Milestone memory) {\n        return milestones[_milestoneId];\n    }\n\n    /// @notice Get the status of the milestone\n    /// @param _milestoneId Id of the milestone\n    function getMilestoneStatus(uint256 _milestoneId) external view returns (Status) {\n        return milestones[_milestoneId].milestoneStatus;\n    }\n\n    /// ===============================\n    /// ======= External/Custom =======\n    /// ===============================\n\n    /// @notice Toggle the status between active and inactive.\n    /// @dev 'msg.sender' must be a pool manager to close the pool. Emits a 'PoolActive()' event.\n    /// @param _flag The flag to set the pool to active or inactive\n    function setPoolActive(bool _flag) external {\n        _setPoolActive(_flag);\n        emit PoolActive(_flag);\n    }\n\n    /// @notice Set the milestones for the acceptedRecipientId.\n    /// @dev 'msg.sender' must be a pool manager to set milestones. Emits 'MilestonesSet' event\n    /// @param _milestones Milestone[] The milestones to be set\n    function setMilestones(Milestone[] memory _milestones) external onlyPoolManager(msg.sender) {\n        if (upcomingMilestone != 0) revert MILESTONES_ALREADY_SET();\n\n        uint256 totalAmountPercentage;\n\n        // Loop through the milestones and add them to the milestones array\n        uint256 milestonesLength = _milestones.length;\n        for (uint256 i; i < milestonesLength;) {\n            totalAmountPercentage += _milestones[i].amountPercentage;\n            milestones.push(_milestones[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        // Check if the all milestone amount percentage totals to 1e18(100%)\n        if (totalAmountPercentage != 1e18) revert INVALID_MILESTONE();\n\n        emit MilestonesSet();\n    }\n\n    /// @notice Submit milestone by the acceptedRecipientId.\n    /// @dev 'msg.sender' must be the 'acceptedRecipientId' and must be a member\n    ///      of a 'Profile' to sumbit a milestone. Emits a 'MilestonesSubmitted()' event.\n    /// @param _metadata The proof of work\n    function submitUpcomingMilestone(Metadata calldata _metadata) external {\n        // C"
    }
  ]
}