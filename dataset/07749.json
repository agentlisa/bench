{
  "Title": "[M-02] Solmate's ERC20 does not check for token contract's existence, which opens up possibility for a honeypot attack",
  "Content": "\nWhen bidding, the contract pulls the quote token from the bidder to itself.\n\n<https://github.com/code-423n4/2022-11-size/blob/main/src/SizeSealed.sol#L163>\n\n```solidity\nSafeTransferLib.safeTransferFrom(ERC20(a.params.quoteToken), msg.sender, address(this), quoteAmount);\n```\n\nHowever, since the contract uses Solmate's [SafeTransferLib](https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9)\n\n> /// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\n\nTherefore if the token address is empty, the transfer will succeed silently, but not crediting the contract with any tokens.\n\nThis error opens up room for a honeypot attack similar to the [Qubit Finance hack](https://halborn.com/explained-the-qubit-hack-january-2022/) in January 2022.\n\nIn particular, it has became popular for protocols to deploy their token across multiple networks using the same deploying address, so that they can control the address nonce and ensuring a consistent token address across different networks.\n\nE.g. **1INCH** has the same token address on Ethereum and BSC, and GEL token has the same address on Ethereum, Fantom and Polygon. There are other protocols have same contract addresses across different chains, and it's not hard to imagine such thing for their protocol token too, if any.\n\n### Proof of Concept\n\nAssuming that Alice is the attacker, Bob is the victim. Alice has two accounts, namely Alice1 and Alice2. Denote token Q as the quote token.\n\n0.  **Token Q has been launched on other chains, but not on the local chain yet.** It is expected that token Q will be launched on the local chain with a consistent address as other chains.\n1.  Alice1 places an auction with some `baseToken`, and a token Q as the `quoteToken`.\n2.  Alice2 places a bid with `1000e18` quote tokens.\n    *   The transfer succeeds, but the contract is not credited any tokens.\n3.  **Token Q is launched on the local chain.**\n4.  Bob places a bid with `1001e18` quote tokens.\n5.  Alice2 cancels her own bid, recovering her (supposedly) `1000e18` refund bid back.\n6.  Alice1 cancels her auction, recovering her base tokens back.\n\nAs a result, the contract's Q token balance is `1e18`, Alice gets away with all her base tokens and `1000e18` Q tokens that are Bob's. Alice has stolen Bob's funds.\n\n### Recommended Mitigation Steps\n\nConsider using OpenZeppelin's SafeERC20 instead, which has checks that an address does indeed have a contract.\n\n\n**[Ragepit (SIZE) confirmed and commented on duplicate issue #318](https://github.com/code-423n4/2022-11-size-findings/issues/318#issuecomment-1319229833):**\n> Incredibly unlikely but confirming as Medium given the good argument in [#48](https://github.com/code-423n4/2022-11-size-findings/issues/48)\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-size-contest",
  "Code": [
    {
      "filename": "src/SizeSealed.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ECCMath} from \"./util/ECCMath.sol\";\nimport {ISizeSealed} from \"./interfaces/ISizeSealed.sol\";\nimport {CommonTokenMath} from \"./util/CommonTokenMath.sol\";\n\n/// @title Size Sealed Auction\n/// @author Size Market\ncontract SizeSealed is ISizeSealed {\n    ///////////////////////////////\n    ///          STATE          ///\n    ///////////////////////////////\n\n    uint256 public currentAuctionId;\n\n    mapping(uint256 => Auction) public idToAuction;\n\n    ///////////////////////////////////////////////////\n    ///                  MODIFIERS                  ///\n    ///////////////////////////////////////////////////\n\n    modifier atState(Auction storage a, States _state) {\n        if (block.timestamp < a.timings.startTimestamp) {\n            if (_state != States.Created) revert InvalidState();\n        } else if (block.timestamp < a.timings.endTimestamp) {\n            if (_state != States.AcceptingBids) revert InvalidState();\n        } else if (a.data.lowestQuote != type(uint128).max) {\n            if (_state != States.Finalized) revert InvalidState();\n        } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {\n            if (_state != States.RevealPeriod) revert InvalidState();\n        } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {\n            if (_state != States.Voided) revert InvalidState();\n        } else {\n            revert();\n        }\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                          AUCTION LOGIC                          ///\n    ///////////////////////////////////////////////////////////////////////\n\n    /// @notice Creates a new sealed auction\n    /// @dev Transfers the `baseToken` from `msg.sender` to the contract\n    /// @return `auctionId` unique to that auction\n    /// @param auctionParams Parameters used during the auction\n    /// @param timings The timestamps at which the auction starts/ends\n    /// @param encryptedSellerPrivKey Encrypted seller's ephemeral private key\n    function createAuction(\n        AuctionParameters calldata auctionParams,\n        Timings calldata timings,\n        bytes calldata encryptedSellerPrivKey\n    ) external returns (uint256) {\n        if (timings.endTimestamp <= block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.startTimestamp >= timings.endTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.endTimestamp > timings.vestingStartTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.vestingStartTimestamp > timings.vestingEndTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.cliffPercent > 1e18) {\n            revert InvalidCliffPercent();\n        }\n        // Revert if the min bid is more than the total reserve of the auction\n        if (\n            FixedPointMathLib.mulDivDown(\n                auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount\n            ) > auctionParams.reserveQuotePerBase\n        ) {\n            revert InvalidReserve();\n        }\n\n        uint256 auctionId = ++currentAuctionId;\n\n        Auction storage a = idToAuction[auctionId];\n        a.timings = timings;\n\n        a.data.seller = msg.sender;\n        a.data.lowestQuote = type(uint128).max;\n\n        a.params = auctionParams;\n\n        // Passes https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n        // Transfer base tokens to auction contract and check for tax tokens\n        uint256 balanceBeforeTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n\n        SafeTransferLib.safeTransferFrom(\n            ERC20(auctionParams.baseToken), msg.sender, address(this), auctionParams.totalBaseAmount\n        );\n\n        uint256 balanceAfterTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n        if (balanceAfterTransfer - balanceBeforeTransfer != auctionParams.totalBaseAmount) {\n            revert UnexpectedBalanceChange();\n        }\n\n        emit AuctionCreated(auctionId, msg.sender, auctionParams, timings, encryptedSellerPrivKey);\n\n        return auctionId;\n    }\n\n    /// @notice Bid on a runnning auction\n    /// @dev Transfers `quoteAmount` of `quoteToken` from bidder to contract\n    /// @return Index of the bid\n    /// @param auctionId Id of the auction to bid on\n    /// @param quoteAmount Amount of `quoteTokens` bidding on a committed amount of `baseTokens`\n    /// @param commitment Hash commitment of the `baseAmount`\n    /// @param pubKey Public key used to encrypt `baseAmount`\n    /// @param encryptedMessage `baseAmount` encrypted to the seller's public key\n    /// @param encryptedPrivateKey Encrypted private key for on-chain storage\n    /// @param proof Merkle proof that checks seller against `merkleRoot` if there is a whitelist\n    function bid(\n        uint256 auctionId,\n        uint128 quoteAmount,\n        bytes32 commitment,\n        ECCMath.Point calldata pubKey,\n        bytes32 encryptedMessage,\n        bytes calldata encryptedPrivateKey,\n        bytes32[] calldata proof\n    ) external atState(idToAuction[auctionId], States.AcceptingBids) returns (uint256) {\n        Auction storage a = idToAuction[auctionId];\n        if (a.params.merkleRoot != bytes32(0)) {\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n            if (!MerkleProofLib.verify(proof, a.params.merkleRoot, leaf)) {\n                revert InvalidProof();\n            }\n        }\n\n        // Seller cannot bid on their own auction\n        if (msg.sender == a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n\n        if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {\n            revert InvalidBidAmount();\n        }\n\n        EncryptedBid memory ebid;\n        ebid.sender = msg.sender;\n        ebid.quoteAmount = quoteAmount;\n        ebid.commitment = commitment;\n        ebid.pubKey = pubKey;\n        ebid.encryptedMessage = encryptedMessage;\n\n        uint256 bidIndex = a.bids.length;\n        // Max of 1000 bids on an auction to prevent DOS\n        if (bidIndex >= 1000) {\n            revert InvalidState();\n        }\n\n        a.bids.push(ebid);\n\n        SafeTransferLib.safeTransferFrom(ERC20(a.params.quoteToken), msg.sender, address(this), quoteAmount);\n\n        emit Bid(\n            msg.sender, auctionId, bidIndex, quoteAmount, commitment, pubKey, encryptedMessage, encryptedPrivateKey\n        );\n\n        return bidIndex;\n    }\n\n    /// @notice Reveals the private key of the seller\n    /// @dev All valid bids are decrypted after this\n    ///      finalizeData should be empty if seller does not wish to finalize in this tx\n    /// @param privateKey Private key corresponding to the auctions public key\n    /// @param finalizeData Calldata that will be sent to finalize()\n    function reveal(uint256 auctionId, uint256 privateKey, bytes calldata finalizeData)\n        external\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        if (a.data.seller != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        ECCMath.Point memory pubKey = ECCMath.publicKey(privateKey);\n        if (pubKey.x != a.params.pubKey.x || pubKey.y != a.params.pubKey.y || (pubKey.x == 1 && pubKey.y == 1)) {\n            revert InvalidPrivateKey();\n        }\n\n        a.data.privKey = privateKey;\n\n        emit RevealedKey(auctionId, privateKey);\n\n        if (finalizeData.length != 0) {\n            (uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote) =\n                abi.decode(finalizeData, (uint256[], uint128, uint128));\n            finalize(auctionId, bidIndices, clearingBase, clearingQuote);\n        }\n    }\n\n    // Used to get around stack too deep errors -- even with viaIr\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n    }\n\n    /// @notice Finalises an auction by revealing all bids\n    /// @dev Calculates the minimum `quotePerBase` and marks successful bids\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndices Bids sorted by price descending\n    /// @param clearingBase Denominator in the clearing price calculation\n    /// @param clearingQuote Numerator in the clearing price calculation\n    function finalize(uint256 auctionId, uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote)\n        public\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        uint256 sellerPriv = a.data.privKey;\n        if (sellerPriv == 0) {\n            revert InvalidPrivateKey();\n        }\n\n        if (bidIndices.length != a.bids.length) {\n            revert InvalidCalldata();\n        }\n\n        FinalizeData memory data;\n        data.reserveQuotePerBase = a.params.reserveQuotePerBase;\n        data.totalBaseAmount = a.params.totalBaseAmount;\n        data.previousQuotePerBase = type(uint256).max;\n\n        // Last filled bid is the clearing price\n        a.data.lowestBase = clearingBase;\n        a.data.lowestQuote = clearingQuote;\n\n        // Bitmap of all the bid indices that have been processed\n        uint256[] memory seenBidMap = new uint256[]((bidIndices.length/256)+1);\n\n        // Fill orders from highest price to lowest price\n        for (uint256 i; i < bidIndices.length; i++) {\n            uint256 bidIndex = bidIndices[i];\n            EncryptedBid storage b = a.bids[bidIndex];\n\n            // Verify this bid index hasn't been seen before\n            uint256 bitmapIndex = bidIndex / 256;\n            uint256 bitMap = seenBidMap[bitmapIndex];\n            uint256 indexBit = 1 << (bidIndex % 256);\n            if (bitMap & indexBit == 1) revert InvalidState();\n            seenBidMap[bitmapIndex] = bitMap | indexBit;\n\n            // G^k1^k2 == G^k2^k1\n            ECCMath.Point memory sharedPoint = ECCMath.ecMul(b.pubKey, sellerPriv);\n            // If the bidder public key isn't on the bn128 curve\n            if (sharedPoint.x == 1 && sharedPoint.y == 1) continue;\n\n            bytes32 decryptedMessage = ECCMath.decryptMessage(sharedPoint, b.encryptedMessage);\n            // If the bidder didn't faithfully submit commitment or pubkey\n            // Or the bid was cancelled\n            if (computeCommitment(decryptedMessage) != b.commitment) continue;\n\n            // First 128 bits are the base amount, last are random salt\n            uint128 baseAmount = uint128(uint256(decryptedMessage >> 128));\n\n            // Require that bids are passed in descending price\n            uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);\n            if (quotePerBase >= data.previousQuotePerBase) {\n                // If last bid was the same price, make sure we filled the earliest bid first\n                if (quotePerBase == data.previousQuotePerBase) {\n                    if (data.previousIndex > bidIndex) revert InvalidSorting();\n                } else {\n                    revert InvalidSorting();\n                }\n            }\n\n            // Only fill if above reserve price\n            if (quotePerBase < data.reserveQuotePerBase) continue;\n\n            // Auction has been fully filled\n            if (data.filledBase == data.totalBaseAmount) continue;\n\n            data.previousQuotePerBase = quotePerBase;\n            data.previousIndex = bidIndex;\n\n            // Fill the remaining unfilled base amount\n            if (data.filledBase + baseAmount > data.totalBaseAmount) {\n                baseAmount = data.totalBaseAmount - data.filledBase;\n            }\n\n            b.filledBaseAmount = baseAmount;\n            data.filledBase += baseAmount;\n        }\n\n        if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {\n            revert InvalidCalldata();\n        }\n\n        // seenBidMap[0:len-1] should be full\n        for (uint256 i; i < seenBidMap.length - 1; i++) {\n            if (seenBidMap[i] != type(uint256).max) {\n                revert InvalidState();\n            }\n        }\n\n        // seenBidMap[-1] should only have the last N bits set\n        if (seenBidMap[seenBidMap.length - 1] != (1 << (bidIndices.length % 256)) - 1) {\n            revert InvalidState();\n        }\n\n        if (data.filledBase > data.totalBaseAmount) {\n            revert InvalidState();\n        }\n\n        // Transfer the left over baseToken\n        if (data.totalBaseAmount != data.filledBase) {\n            uint128 unsoldBase = data.totalBaseAmount - data.filledBase;\n            a.params.totalBaseAmount = data.filledBase;\n            SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase);\n        }\n\n        // Calculate quote amount based on clearing price\n        uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote);\n\n        emit AuctionFinalized(auctionId, bidIndices, data.filledBase, filledQuote);\n    }\n\n    /// @notice Called after finalize for unsuccessful bidders to return funds\n    /// @dev Returns all `quoteToken` to the original bidder\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndex Index of the failed bid to be refunded\n    function refund(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        if (b.filledBaseAmount != 0) {\n            revert InvalidState();\n        }\n\n        b.sender = address(0);\n\n        emit BidRefund(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    /// @notice Called after finalize for successful bidders\n    /// @dev Returns won `baseToken` & any unfilled `quoteToken` to the bidder\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param bidIndex Index of the successful bid\n    function withdraw(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        uint128 baseAmount = b.filledBaseAmount;\n        if (baseAmount == 0) {\n            revert InvalidState();\n        }\n\n        uint128 baseTokensAvailable = tokensAvailableForWithdrawal(auctionId, baseAmount);\n        baseTokensAvailable = baseTokensAvailable - b.baseWithdrawn;\n\n        b.baseWithdrawn += baseTokensAvailable;\n\n        // Refund unfilled quoteAmount on first withdraw\n        if (b.quoteAmount != 0) {\n            uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);\n            uint256 refundedQuote = b.quoteAmount - quoteBought;\n            b.quoteAmount = 0;\n\n            SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);\n        }\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, baseTokensAvailable);\n\n        emit Withdrawal(auctionId, bidIndex, baseTokensAvailable, baseAmount - b.baseWithdrawn);\n    }\n\n    /// @dev Transfers `baseToken` back to seller and will enable withdraws for bidders\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    function cancelAuction(uint256 auctionId) external {\n        Auction storage a = idToAuction[auctionId];\n        if (msg.sender != a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n        // Only allow cancellations before finalization\n        // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)\n        if (a.data.lowestQuote != type(uint128).max) {\n            revert InvalidState();\n        }\n\n        // Allowing bidders to cancel bids (withdraw quote)\n        // Auction considered forever States.AcceptingBids but nobody can finalize\n        a.data.seller = address(0);\n        a.timings.endTimestamp = type(uint32).max;\n\n        emit AuctionCancelled(auctionId);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount);\n    }\n\n    /// @dev Transfers `quoteToken` back to bidder and prevents bid from being finalised\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    /// @param bidIndex Index of the bid to be cancelled\n    function cancelBid(uint256 auctionId, uint256 bidIndex)\n        external\n    {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        // Only allow bid cancellations while not finalized or in the reveal period\n        if (block.timestamp >= a.timings.endTimestamp) {\n            if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {\n                revert InvalidState();\n            }\n        }\n\n        // Prevent any futher access to this EncryptedBid\n        b.sender = address(0);\n\n        // Prevent seller from finalizing a cancelled bid\n        b.commitment = 0;\n\n        emit BidCancelled(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    ///                            UTIL FUNCTIONS                            ///\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Calculates available unlocked tokens for an auction\n    /// @dev Uses vesting parameters to account for cliff & linearity\n    /// @return tokensAvailable Amount of unlocked `baseToken` at the current time\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param baseAmount Amount of total vested `baseToken`\n    function tokensAvailableForWithdrawal(uint256 auctionId, uint128 baseAmount)\n        public\n        view\n        returns (uint128 tokensAvailable)\n    {\n        Auction storage a = idToAuction[auctionId];\n        return CommonTokenMath.tokensAvailableAtTime(\n            a.timings.vestingStartTimestamp,\n            a.timings.vestingEndTimestamp,\n            uint32(block.timestamp),\n            a.timings.cliffPercent,\n            baseAmount\n        );\n    }\n\n    function computeCommitment(bytes32 message) public pure returns (bytes32) {\n        return keccak256(abi.encode(message));\n    }\n\n    function computeMessage(uint128 baseAmount, bytes16 salt) external pure returns (bytes32) {\n        return bytes32(abi.encodePacked(baseAmount, salt));\n    }\n\n    function getTimings(uint256 auctionId) external view returns (Timings memory timings) {\n        timings = idToAuction[auctionId].timings;\n    }\n\n    function getAuctionData(uint256 auctionId) external view returns (AuctionData memory data) {\n        data = idToAuction[auctionId].data;\n    }\n}"
    },
    {
      "filename": "src/utils/SafeTransferLib.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}"
    }
  ]
}