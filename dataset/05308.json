{
  "Title": "[M-11] Protocol does not implement EIP712 correctly on multiple occasions",
  "Content": "\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L151-L151> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L373-L375> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L384-L386> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L232-L238> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L636>\n\nBeing not EIP712 compliant can lead to issues with integrators and possibly DOS.\n\n### Problem 1\n\nThe implementation of the hook hash ([here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L151C56-L151C56)) is done incorrectly. `hook.extraData` is of type `bytes` which according to EIP712 it is referred to as a `dynamic type`. Dynamic types must be first hashed with `keccak256` to become one 32-byte word before being encoded and hashed together with the typeHash and the other values.\n\n### Mitigation to Problem 1:\n\n```diff\nfunction _deriveHookHash(Hook memory hook) internal view returns (bytes32) {\n  // Derive and return the hook as specified by EIP-712.\n    return\n        keccak256(\n-           abi.encode(_HOOK_TYPEHASH, hook.target, hook.itemIndex, hook.extraData)\n+           abi.encode(_HOOK_TYPEHASH, hook.target, hook.itemIndex, keccak256(hook.extraData))\n        );\n}\n```\n\n### Problem 2\n\nSome TypeHashes are computed by using `abi.encode` instead of `abi.encodePacked` ([here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L373C1-L375)) which makes the typeHash value and the whole final hash different from the hash that correctly implementing EIP712 entities would get.\n\n```solidity\n// Construct the Item type string.\nbytes memory itemTypeString = abi.encodePacked(\n    \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n);\n\n// Construct the Hook type string.\nbytes memory hookTypeString = abi.encodePacked(\n    \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n);\n\n// Construct the RentalOrder type string.\nbytes memory rentalOrderTypeString = abi.encodePacked(\n    \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n);\n\n...\n\nrentalOrderTypeHash = keccak256(\n    abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n);\n```\n\nThe problem with this is that abi.encode-ing strings results in bytes with arbitrary length. In such cases (like the one here) there is a high chance that the bytes will not represent an exact N words in length (X &ast; 32 bytes length) and the data is padded to conform uniformly to 32-byte words. This padding results in an incorrect hash of the typeHash and it will make the digest hash invalid when compared with properly implemented hashes from widely used libraries such as ethers.\n\n### Proof of Concept\n\nPlace the following code in any of the tests and run `forge test -—mt test_EIP712_encoding`\n\n```solidity\nfunction test_EIP712_encoding() public {\n\t\t// Copied from the reNFT codebase\n    bytes memory itemTypeString = abi.encodePacked(\n        \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n    );\n    bytes memory hookTypeString = abi.encodePacked(\n        \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n    );\n    bytes memory rentalOrderTypeString = abi.encodePacked(\n        \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n    );\n\t\t// protocol implementation\n    bytes32 rentalOrderTypeHash = keccak256(\n        abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString) // <-----\n    );\n\n    // correct implementation\n    bytes32 rentalOrderTypeHashCorrect = keccak256(\n        abi.encodePacked(rentalOrderTypeString, hookTypeString, itemTypeString) // <-----\n    );\n\n    // the correct typehash\n    bytes32 correctTypeHash = keccak256(\n        \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)Hook(address target,uint256 itemIndex,bytes extraData)Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n    );\n\n    assertNotEq(rentalOrderTypeHash, rentalOrderTypeHashCorrect);\n    assertNotEq(rentalOrderTypeHash, correctTypeHash);\n    assertEq(rentalOrderTypeHashCorrect, correctTypeHash);\n}\n```\n\nThis test shows that the `rentalOrderTypeHashCorrect` is the correct typeHash.\n\n### Mitigation to Problem 2\n\n```diff\nrentalOrderTypeHash = keccak256(\n-    abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n+    abi.encodePacked(rentalOrderTypeString, hookTypeString, itemTypeString)\n);\n```\n\n### Problem 3\n\n`_deriveOrderMetadataHash`  constructs the hash incorrectly because \\_ORDER_METADATA_TYPEHASH includes `uint8 orderType` and `bytes emittedExtraData` (it can be seen [here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L384-L386C15)) but these values are not provided below the typeHash (it can be seen [here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L232-L238)).\n\n```solidity\nfunction _deriveOrderMetadataHash(\n    OrderMetadata memory metadata\n) internal view returns (bytes32) {\n    bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n\n    for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n        hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n    }\n\n    return\n        keccak256(\n            abi.encode(\n                _ORDER_METADATA_TYPEHASH,// OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\n\t\t\t\t\t\t\t\t// <---- misses uint8 orderType\n                metadata.rentDuration,\n                keccak256(abi.encodePacked(hookHashes))\n\t\t\t\t\t\t\t\t// <---- misses bytes emittedExtraData\n            )\n        );\n}\n```\n\nThis hash is important because it is compared to the zoneHash inside `Create.sol:validateOrder → _rentFromZone → _isValidOrderMetadata` ([link](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L636)): So if the provided zoneHash from Seaport was generated correctly and it is not the same as the one generated by reNFT, the protocol will not be able to create any rentalOrders resulting in **DOS**.\n\nIn any case, this implementation is not according to EIP712 and either the fields must be included or the `_ORDER_METADATA_TYPEHASH` must remove `uint8 orderType` and `bytes emittedExtraData`\n\n### Tools Used\n\nFoundry\n\n### Recommendations\n\nApply the described fixes for each example.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/239#issuecomment-1908739770)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/2) - Properly implements EIP-712.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/17), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/62) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/58).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/packages/Signer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n\nimport {\n    RentPayload,\n    Hook,\n    RentalOrder,\n    OrderFulfillment,\n    OrderMetadata,\n    Item\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Signer\n * @notice Contains logic related to signed payloads and signature verification when\n *         creating rentals.\n */\nabstract contract Signer {\n    using ECDSA for bytes32;\n\n    // Declare constants for name and version.\n    string internal constant _NAME = \"ReNFT-Rentals\";\n    string internal constant _VERSION = \"1.0.0\";\n\n    // Precompute hashes, original chainId, and domain separator on deployment.\n    bytes32 internal immutable _NAME_HASH;\n    bytes32 internal immutable _VERSION_HASH;\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\n    uint256 internal immutable _CHAIN_ID;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    bytes32 internal immutable _ITEM_TYPEHASH;\n    bytes32 internal immutable _HOOK_TYPEHASH;\n    bytes32 internal immutable _RENTAL_ORDER_TYPEHASH;\n    bytes32 internal immutable _ORDER_FULFILLMENT_TYPEHASH;\n    bytes32 internal immutable _ORDER_METADATA_TYPEHASH;\n    bytes32 internal immutable _RENT_PAYLOAD_TYPEHASH;\n\n    /**\n     * @dev Sets up the type hashes and sets the chain ID.\n     */\n    constructor() {\n        // Derive name, version, and EIP-712 typehashes.\n        (\n            _NAME_HASH,\n            _VERSION_HASH,\n            _EIP_712_DOMAIN_TYPEHASH,\n            _DOMAIN_SEPARATOR\n        ) = _deriveTypehashes();\n\n        // Derive name and version hashes alongside required EIP-712 typehashes.\n        (\n            _ITEM_TYPEHASH,\n            _HOOK_TYPEHASH,\n            _RENTAL_ORDER_TYPEHASH,\n            _ORDER_FULFILLMENT_TYPEHASH,\n            _ORDER_METADATA_TYPEHASH,\n            _RENT_PAYLOAD_TYPEHASH\n        ) = _deriveRentalTypehashes();\n\n        // Store the current chainId and derive the current domain separator.\n        _CHAIN_ID = block.chainid;\n    }\n\n    /**\n     * @dev Validates that the expected fulfiller of the order is the same as the address\n     *      executed the order. This check is meant to prevent order sniping where one\n     *      party receives a server-side signature but another party intercepts the\n     *      signature and uses it.\n     *\n     * @param intendedFulfiller Address that was expected to execute the order.\n     * @param actualFulfiller   Address that actually executed the order.\n     */\n    function _validateFulfiller(\n        address intendedFulfiller,\n        address actualFulfiller\n    ) internal pure {\n        // Check actual fulfiller against the intended fulfiller.\n        if (intendedFulfiller != actualFulfiller) {\n            revert Errors.SignerPackage_UnauthorizedFulfiller(\n                actualFulfiller,\n                intendedFulfiller\n            );\n        }\n    }\n\n    /**\n     * @dev Validates that the server-side signature has not expired.\n     *\n     * @param expiration Expiration time of the signature.\n     */\n    function _validateProtocolSignatureExpiration(uint256 expiration) internal view {\n        // Check that the signature provided by the protocol signer has not expired.\n        if (block.timestamp > expiration) {\n            revert Errors.SignerPackage_SignatureExpired(block.timestamp, expiration);\n        }\n    }\n\n    /**\n     * @dev Recovers the signer of the payload hash.\n     *\n     * @param payloadHash The payload hash which was signed.\n     * @param signature   The signature data for the payload hash.\n     */\n    function _recoverSignerFromPayload(\n        bytes32 payloadHash,\n        bytes memory signature\n    ) internal view returns (address) {\n        // Derive original EIP-712 digest using domain separator and order hash.\n        bytes32 digest = _DOMAIN_SEPARATOR.toTypedDataHash(payloadHash);\n\n        // Recover the signer address of the signature.\n        return digest.recover(signature);\n    }\n\n    /**\n     * @dev Derives the hash of a given item using a type hash.\n     *\n     * @param item Item to hash.\n     *\n     * @return The hash of the item.\n     */\n    function _deriveItemHash(Item memory item) internal view returns (bytes32) {\n        // Derive and return the item as specified by EIP-712.\n        return\n            keccak256(\n                abi.encode(\n                    _ITEM_TYPEHASH,\n                    item.itemType,\n                    item.settleTo,\n                    item.token,\n                    item.amount,\n                    item.identifier\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the hash of a given hook using a type hash.\n     *\n     * @param hook Hook to hash.\n     *\n     * @return The hash of the hook.\n     */\n    function _deriveHookHash(Hook memory hook) internal view returns (bytes32) {\n        // Derive and return the hook as specified by EIP-712.\n        return\n            keccak256(\n                abi.encode(_HOOK_TYPEHASH, hook.target, hook.itemIndex, hook.extraData)\n            );\n    }\n\n    /**\n     * @dev Derives the hash of a given rental order using a type hash.\n     *\n     * @param order Rental order to hash.\n     *\n     * @return The hash of the rental order.\n     */\n    function _deriveRentalOrderHash(\n        RentalOrder memory order\n    ) internal view returns (bytes32) {\n        // Create arrays for items and hooks.\n        bytes32[] memory itemHashes = new bytes32[](order.items.length);\n        bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n\n        // Iterate over each item.\n        for (uint256 i = 0; i < order.items.length; ++i) {\n            // Hash the item.\n            itemHashes[i] = _deriveItemHash(order.items[i]);\n        }\n\n        // Iterate over each hook.\n        for (uint256 i = 0; i < order.hooks.length; ++i) {\n            // Hash the hook.\n            hookHashes[i] = _deriveHookHash(order.hooks[i]);\n        }\n\n        return\n            keccak256(\n                abi.encode(\n                    _RENTAL_ORDER_TYPEHASH,\n                    order.seaportOrderHash,\n                    keccak256(abi.encodePacked(itemHashes)),\n                    keccak256(abi.encodePacked(hookHashes)),\n                    order.orderType,\n                    order.lender,\n                    order.renter,\n                    order.startTimestamp,\n                    order.endTimestamp\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the hash of a given fulfillment using a type hash.\n     *\n     * @param fulfillment Order fulfillment to hash.\n     *\n     * @return The hash of the order fulfillment.\n     */\n    function _deriveOrderFulfillmentHash(\n        OrderFulfillment memory fulfillment\n    ) internal view returns (bytes32) {\n        // Derive and return the fulfilmment hash as specified by EIP-712\n        return keccak256(abi.encode(_ORDER_FULFILLMENT_TYPEHASH, fulfillment.recipient));\n    }\n\n    /**\n     * @dev Derives the hash of a given order metadata using a type hash.\n     *\n     * @param metadata Order metadata to hash.\n     *\n     * @return The hash of the order metadata.\n     */\n    function _deriveOrderMetadataHash(\n        OrderMetadata memory metadata\n    ) internal view returns (bytes32) {\n        // Create array for hooks.\n        bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n\n        // Iterate over each hook.\n        for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n            // Hash the hook\n            hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n        }\n\n        // Derive and return the metadata hash as specified by EIP-712.\n        return\n            keccak256(\n                abi.encode(\n                    _ORDER_METADATA_TYPEHASH,\n                    metadata.rentDuration,\n                    keccak256(abi.encodePacked(hookHashes))\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the hash of a given payload using a type hash.\n     *\n     * @param payload Rent payload to hash.\n     *\n     * @return The hash of the rent payload.\n     */\n    function _deriveRentPayloadHash(\n        RentPayload memory payload\n    ) internal view returns (bytes32) {\n        // Derive and return the rent payload hash as specified by EIP-712.\n        return\n            keccak256(\n                abi.encode(\n                    _RENT_PAYLOAD_TYPEHASH,\n                    _deriveOrderFulfillmentHash(payload.fulfillment),\n                    _deriveOrderMetadataHash(payload.metadata),\n                    payload.expiration,\n                    payload.intendedFulfiller\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the hash of the domain separator.\n     *\n     * @param _eip712DomainTypeHash The standard EIP-712 domain type string.\n     * @param _nameHash             Hash of the contract name.\n     * @param _versionHash          Hash of the contract version.\n     *\n     * @return The hash of the domain separator.\n     */\n    function _deriveDomainSeparator(\n        bytes32 _eip712DomainTypeHash,\n        bytes32 _nameHash,\n        bytes32 _versionHash\n    ) internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    _eip712DomainTypeHash,\n                    _nameHash,\n                    _versionHash,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the standard EIP-712 type hashes.\n     *\n     * @return nameHash             Hash of the contract name.\n     * @return versionHash          Hash of the contract version.\n     * @return eip712DomainTypehash Hash of the EIP-712 Domain.\n     * @return domainSeparator      The constructed domain separator.\n     */\n    function _deriveTypehashes()\n        internal\n        view\n        returns (\n            bytes32 nameHash,\n            bytes32 versionHash,\n            bytes32 eip712DomainTypehash,\n            bytes32 domainSeparator\n        )\n    {\n        // Derive the name type hash.\n        nameHash = keccak256(bytes(_NAME));\n\n        // Derive the version type hash.\n        versionHash = keccak256(bytes(_VERSION));\n\n        // Construct the primary EIP-712 domain type string.\n        eip712DomainTypehash = keccak256(\n            abi.encodePacked(\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n            )\n        );\n\n        // Construct the domain separator.\n        domainSeparator = _deriveDomainSeparator(\n            eip712DomainTypehash,\n            nameHash,\n            versionHash\n        );\n    }\n\n    /**\n     * @dev Derives the protocol-specific type hashes.\n     *\n     * @return itemTypeHash             Type hash of the item.\n     * @return hookTypeHash             Type hash of the hook.\n     * @return rentalOrderTypeHash      Type hash of the rental order.\n     * @return orderFulfillmentTypeHash Type hash of the order fulfillment.\n     * @return orderMetadataTypeHash    Type hash of the order metadata.\n     * @return rentPayloadTypeHash      Type hash of the rent payload.\n     */\n    function _deriveRentalTypehashes()\n        internal\n        pure\n        returns (\n            bytes32 itemTypeHash,\n            bytes32 hookTypeHash,\n            bytes32 rentalOrderTypeHash,\n            bytes32 orderFulfillmentTypeHash,\n            bytes32 orderMetadataTypeHash,\n            bytes32 rentPayloadTypeHash\n        )\n    {\n        // Construct the Item type string.\n        bytes memory itemTypeString = abi.encodePacked(\n            \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n        );\n\n        // Construct the Hook type string.\n        bytes memory hookTypeString = abi.encodePacked(\n            \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n        );\n\n        // Construct the RentalOrder type string.\n        bytes memory rentalOrderTypeString = abi.encodePacked(\n            \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n        );\n\n        // Derive the Item type hash using the corresponding type string.\n        itemTypeHash = keccak256(itemTypeString);\n\n        // Derive the Hook type hash using the corresponding type string.\n        hookTypeHash = keccak256(hookTypeString);\n\n        // Derive the RentalOrder type hash using the corresponding type string.\n        rentalOrderTypeHash = keccak256(\n            abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n        );\n\n        {\n            // Construct the OrderFulfillment type string.\n            bytes memory orderFulfillmentTypeString = abi.encodePacked(\n                \"OrderFulfillment(address recipient)\"\n            );\n\n            // Construct the OrderMetadata type string.\n            bytes memory orderMetadataTypeString = abi.encodePacked(\n                \"OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\"\n            );\n\n            // Construct the RentPayload type string.\n            bytes memory rentPayloadTypeString = abi.encodePacked(\n                \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\"\n            );\n\n            // Derive RentPayload type hash via combination of relevant type strings.\n            rentPayloadTypeHash = keccak256(\n                abi.encodePacked(\n                    rentPayloadTypeString,\n                    orderMetadataTypeString,\n                    orderFulfillmentTypeString\n                )\n            );\n\n            // Derive the OrderFulfillment type hash using the corresponding type string.\n            orderFulfillmentTypeHash = keccak256(orderFulfillmentTypeString);\n\n            // Derive the OrderMetadata type hash using the corresponding type string.\n            orderMetadataTypeHash = keccak256(orderMetadataTypeString);\n        }\n    }\n}"
    },
    {
      "filename": "src/packages/Signer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n\nimport {\n    RentPayload,\n    Hook,\n    RentalOrder,\n    OrderFulfillment,\n    OrderMetadata,\n    Item\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Signer\n * @notice Contains logic related to signed payloads and signature verification when\n *         creating rentals.\n */\nabstract contract Signer {\n    using ECDSA for bytes32;\n\n    // Declare constants for name and version.\n    string internal constant _NAME = \"ReNFT-Rentals\";\n    string internal constant _VERSION = \"1.0.0\";\n\n    // Precompute hashes, original chainId, and domain separator on deployment.\n    bytes32 internal immutable _NAME_HASH;\n    bytes32 internal immutable _VERSION_HASH;\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\n    uint256 internal immutable _CHAIN_ID;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    bytes32 internal immutable _ITEM_TYPEHASH;\n    bytes32 internal immutable _HOOK_TYPEHASH;\n    bytes32 internal immutable _RENTAL_ORDER_TYPEHASH;\n    bytes32 internal immutable _ORDER_FULFILLMENT_TYPEHASH;\n    bytes32 internal immutable _ORDER_METADATA_TYPEHASH;\n    bytes32 internal immutable _RENT_PAYLOAD_TYPEHASH;\n\n    /**\n     * @dev Sets up the type hashes and sets the chain ID.\n     */\n    constructor() {\n        // Derive name, version, and EIP-712 typehashes.\n        (\n            _NAME_HASH,\n            _VERSION_HASH,\n            _EIP_712_DOMAIN_TYPEHASH,\n            _DOMAIN_SEPARATOR\n        ) = _deriveTypehashes();\n\n        // Derive name and version hashes alongside required EIP-712 typehashes.\n        (\n            _ITEM_TYPEHASH,\n            _HOOK_TYPEHASH,\n            _RENTAL_ORDER_TYPEHASH,\n            _ORDER_FULFILLMENT_TYPEHASH,\n            _ORDER_METADATA_TYPEHASH,\n            _RENT_PAYLOAD_TYPEHASH\n        ) = _deriveRentalTypehashes();\n\n        // Store the current chainId and derive the current domain separator.\n        _CHAIN_ID = block.chainid;\n    }\n\n    /**\n     * @dev Validates that the expected fulfiller of the order is the same as the address\n     *      executed the order. This check is meant to prevent order sniping where one\n     *      party receives a server-side signature but another party intercepts the\n     *      signature and uses it.\n     *\n     * @param intendedFulfiller Address that was expected to execute the order.\n     * @param actualFulfiller   Address that actually executed the order.\n     */\n    function _validateFulfiller(\n        address intendedFulfiller,\n        address actualFulfiller\n    ) internal pure {\n        // Check actual fulfiller against the intended fulfiller.\n        if (intendedFulfiller != actualFulfiller) {\n            revert Errors.SignerPackage_UnauthorizedFulfiller(\n                actualFulfiller,\n                intendedFulfiller\n            );\n        }\n    }\n\n    /**\n     * @dev Validates that the server-side signature has not expired.\n     *\n     * @param expiration Expiration time of the signature.\n     */\n    function _validateProtocolSignatureExpiration(uint256 expiration) internal view {\n        // Check that the signature provided by the protocol signer has not expired.\n        if (block.timestamp > expiration) {\n            revert Errors.SignerPackage_SignatureExpired(block.timestamp, expiration);\n        }\n    }\n\n    /**\n     * @dev Recovers the signer of the payload hash.\n     *\n     * @param payloadHash The payload hash which was signed.\n     * @param signature   The signature data for the payload hash.\n     */\n    function _recoverSignerFromPayload(\n        bytes32 payloadHash,\n        bytes memory signature\n    ) internal view returns (address) {\n        // Derive original EIP-712 digest using domain separator and order hash.\n        bytes32 digest = _DOMAIN_SEPARATOR.toTypedDataHash(payloadHash);\n\n        // Recover the signer address of the signature.\n        return digest.recover(signature);\n    }\n\n    /**\n     * @dev Derives the hash of a given item using a type hash.\n     *\n     * @param item Item to hash.\n     *\n     * @return The hash of the item.\n     */\n    function _deriveItemHash(Item memory item) internal view returns (bytes32) {\n        // Derive and return the item as specified by EIP-712.\n        return\n            keccak256(\n                abi.encode(\n                    _ITEM_TYPEHASH,\n                    item.itemType,\n                    item.settleTo,\n                    item.token,\n                    item.amount,\n                    item.identifier\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the hash of a given hook using a type hash.\n     *\n     * @param hook Hook to hash.\n     *\n     * @return The hash of the hook.\n     */\n    function _deriveHookHash(Hook memory hook) internal view returns (bytes32) {\n        // Derive and return the hook as specified by EIP-712.\n        return\n            keccak256(\n                abi.encode(_HOOK_TYPEHASH, hook.target, hook.itemIndex, hook.extraData)\n            );\n    }\n\n    /**\n     * @dev Derives the hash of a given rental order using a type hash.\n     *\n     * @param order Rental order to hash.\n     *\n     * @return The hash of the rental order.\n     */\n    function _deriveRentalOrderHash(\n        RentalOrder memory order\n    ) internal view returns (bytes32) {\n        // Create arrays for items and hooks.\n        bytes32[] memory itemHashes = new bytes32[](order.items.length);\n        bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n\n        // Iterate over each item.\n        for (uint256 i = 0; i < order.items.length; ++i) {\n            // Hash the item.\n            itemHashes[i] = _deriveItemHash(order.items[i]);\n        }\n\n        // Iterate over each hook.\n        for (uint256 i = 0; i < order.hooks.length; ++i) {\n            // Hash the hook.\n            hookHashes[i] = _deriveHookHash(order.hooks[i]);\n        }\n\n        return\n            keccak256(\n                abi.encode(\n                    _RENTAL_ORDER_TYPEHASH,\n                    order.seaportOrderHash,\n                    keccak256(abi.encodePacked(itemHashes)),\n                    keccak256(abi.encodePacked(hookHashes)),\n                    order.orderType,\n                    order.lender,\n                    order.renter,\n                    order.startTimestamp,\n                    order.endTimestamp\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the hash of a given fulfillment using a type hash.\n     *\n     * @param fulfillment Order fulfillment to hash.\n     *\n     * @return The hash of the order fulfillment.\n     */\n    function _deriveOrderFulfillmentHash(\n        OrderFulfillment memory fulfillment\n    ) internal view returns (bytes32) {\n        // Derive and return the fulfilmment hash as specified by EIP-712\n        return keccak256(abi.encode(_ORDER_FULFILLMENT_TYPEHASH, fulfillment.recipient));\n    }\n\n    /**\n     * @dev Derives the hash of a given order metadata using a type hash.\n     *\n     * @param metadata Order metadata to hash.\n     *\n     * @return The hash of the order metadata.\n     */\n    function _deriveOrderMetadataHash(\n        OrderMetadata memory metadata\n    ) internal view returns (bytes32) {\n        // Create array for hooks.\n        bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n\n        // Iterate over each hook.\n        for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n            // Hash the hook\n            hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n        }\n\n        // Derive and return the metadata hash as specified by EIP-712.\n        return\n            keccak256(\n                abi.encode(\n                    _ORDER_METADATA_TYPEHASH,\n                    metadata.rentDuration,\n                    keccak256(abi.encodePacked(hookHashes))\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the hash of a given payload using a type hash.\n     *\n     * @param payload Rent payload to hash.\n     *\n     * @return The hash of the rent payload.\n     */\n    function _deriveRentPayloadHash(\n        RentPayload memory payload\n    ) internal view returns (bytes32) {\n        // Derive and return the rent payload hash as specified by EIP-712.\n        return\n            keccak256(\n                abi.encode(\n                    _RENT_PAYLOAD_TYPEHASH,\n                    _deriveOrderFulfillmentHash(payload.fulfillment),\n                    _deriveOrderMetadataHash(payload.metadata),\n                    payload.expiration,\n                    payload.intendedFulfiller\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the hash of the domain separator.\n     *\n     * @param _eip712DomainTypeHash The standard EIP-712 domain type string.\n     * @param _nameHash             Hash of the contract name.\n     * @param _versionHash          Hash of the contract version.\n     *\n     * @return The hash of the domain separator.\n     */\n    function _deriveDomainSeparator(\n        bytes32 _eip712DomainTypeHash,\n        bytes32 _nameHash,\n        bytes32 _versionHash\n    ) internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    _eip712DomainTypeHash,\n                    _nameHash,\n                    _versionHash,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @dev Derives the standard EIP-712 type hashes.\n     *\n     * @return nameHash             Hash of the contract name.\n     * @return versionHash          Hash of the contract version.\n     * @return eip712DomainTypehash Hash of the EIP-712 Domain.\n     * @return domainSeparator      The constructed domain separator.\n     */\n    function _deriveTypehashes()\n        internal\n        view\n        returns (\n            bytes32 nameHash,\n            bytes32 versionHash,\n            bytes32 eip712DomainTypehash,\n            bytes32 domainSeparator\n        )\n    {\n        // Derive the name type hash.\n        nameHash = keccak256(bytes(_NAME));\n\n        // Derive the version type hash.\n        versionHash = keccak256(bytes(_VERSION));\n\n        // Construct the primary EIP-712 domain type string.\n        eip712DomainTypehash = keccak256(\n            abi.encodePacked(\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n            )\n        );\n\n        // Construct the domain separator.\n        domainSeparator = _deriveDomainSeparator(\n            eip712DomainTypehash,\n            nameHash,\n            versionHash\n        );\n    }\n\n    /**\n     * @dev Derives the protocol-specific type hashes.\n     *\n     * @return itemTypeHash             Type hash of the item.\n     * @return hookTypeHash             Type hash of the hook.\n     * @return rentalOrderTypeHash      Type hash of the rental order.\n     * @return orderFulfillmentTypeHash Type hash of the order fulfillment.\n     * @return orderMetadataTypeHash    Type hash of the order metadata.\n     * @return rentPayloadTypeHash      Type hash of the rent payload.\n     */\n    function _deriveRentalTypehashes()\n        internal\n        pure\n        returns (\n            bytes32 itemTypeHash,\n            bytes32 hookTypeHash,\n            bytes32 rentalOrderTypeHash,\n            bytes32 orderFulfillmentTypeHash,\n            bytes32 orderMetadataTypeHash,\n            bytes32 rentPayloadTypeHash\n        )\n    {\n        // Construct the Item type string.\n        bytes memory itemTypeString = abi.encodePacked(\n            \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n        );\n\n        // Construct the Hook type string.\n        bytes memory hookTypeString = abi.encodePacked(\n            \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n        );\n\n        // Construct the RentalOrder type string.\n        bytes memory rentalOrderTypeString = abi.encodePacked(\n            \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n        );\n\n        // Derive the Item type hash using the corresponding type string.\n        itemTypeHash = keccak256(itemTypeString);\n\n        // Derive the Hook type hash using the corresponding type string.\n        hookTypeHash = keccak256(hookTypeString);\n\n        // Derive the RentalOrder type hash using the corresponding type string.\n        rentalOrderTypeHash = keccak256(\n            abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n        );\n\n        {\n            // Construct the OrderFulfillment type string.\n            bytes memory orderFulfillmentTypeString = abi.encodePacked(\n                \"OrderFulfillment(address recipient)\"\n            );\n\n            // Construct the OrderMetadata type string.\n            bytes memory orderMetadataTypeString = abi.encodePacked(\n                \"OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\"\n            );\n\n            // Construct the RentPayload type string.\n            bytes memory rentPayloadTypeString = abi.encodePacked(\n                \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\"\n            );\n\n            // Derive RentPayload type hash via combination of relevant type strings.\n            rentPayloadTypeHash = keccak256(\n                abi.encodePacked(\n                    rentPayloadTypeString,\n                    orderMetadataTypeString,\n                    orderFulfillmentTypeString\n                )\n            );\n\n            // Derive the OrderFulfillment type hash using the corresponding type string.\n            orderFulfillmentTypeHash = keccak256(orderFulfillmentTypeString);\n\n            // Derive the OrderMetadata type hash using the corresponding type string.\n            orderMetadataTypeHash = keccak256(orderMetadataTypeString);\n        }\n    }\n}"
    },
    {
      "filename": "src/packages/Signer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n\nimport {\n    RentPayload,\n    Hook,\n    RentalOrder,\n    OrderFulfillment,\n    OrderMetadata,\n    Item\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Signer\n * @notice Contains logic related to signed payloads and signature verification when\n *         creating rentals.\n */\nabstract contract Signer {\n    using ECDSA for bytes32;\n\n    // Declare constants for name and version.\n    string internal constant _NAME = \"ReNFT-Rentals\";\n    string internal constant _VERSION = \"1.0.0\";\n\n    // Precompute hashes, original chainId, and domain separator on deployment.\n    bytes32 internal immutable _NAME_HASH;\n    bytes32 internal immutable _VERSION_HASH;\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\n    uint256 internal immutable _CHAIN_ID;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    bytes32 internal immutable _ITEM_TYPEHASH;\n    bytes32 internal immutable _HOOK_TYPEHASH;\n    bytes32 internal immutable _RENTAL_ORDER_TYPEHASH;\n    bytes32 internal immutable _ORDER_FULFILLMENT_TYPEHASH;\n    bytes32 internal immutable _ORDER_METADATA_TYPEHASH;\n    bytes32 internal immutable _RENT_PAYLOAD_TYPEHASH;\n\n    /**\n     * @dev Sets up the type hashes and sets the chain ID.\n     */\n    constructor() {\n        // Derive name, version, and EIP-712 typehashes.\n        (\n            _NAME_HASH,\n            _VERSION_HASH,\n            _EIP_712_DOMAIN_TYPEHASH,\n            _DOMAIN_SEPARATOR\n        ) = _deriveTypehashes();\n\n        // Derive name and version hashes alongside required EIP-712 typehashes.\n        (\n            _ITEM_TYPEHASH,\n            _HOOK_TYPEHASH,\n            _RENTAL_ORDER_TYPEHASH,\n            _ORDER_FULFILLMENT_TYPEHASH,\n            _ORDER_METADATA_TYPEHASH,\n            _RENT_PAYLOAD_TYPEHASH\n        ) = _deriveRentalTypehashes();\n\n        // Store the current chainId and derive the current domain separator.\n        _CHAIN_ID = block.chainid;\n    }\n\n    /**\n     * @dev Validates that the expected fulfiller of the order is the same as the address\n     *      executed the order. This check is meant to prevent order sniping where one\n     *      party receives a server-side signature but another party intercepts the\n     *      signature and uses it.\n     *\n     * @param intendedFulfiller Address that was expected to execute the order.\n     * @param actualFulfiller   Address that actually executed the order.\n     */\n    function _validateFulfiller(\n        address intendedFulfiller,\n        address actualFulfiller\n    ) internal pure {\n        // Check actual fulfiller against the intended fulfiller.\n        if (intendedFulfiller != actualFulfiller) {\n            revert Errors.SignerPackage_UnauthorizedFulfiller(\n                actualFulfiller,\n                intendedFulfiller\n            );\n        }\n    }\n\n    /**\n     * @dev Validates that the server-side signature has not expired.\n     *\n     * @param expiration Expiration time of the signature.\n     */\n    function _validateProtocolSignatureExpiration(uint256 expiration) internal view {\n        // Check that the signature provided by the protocol signer has not expired.\n        if (block.timestamp > expiration) {\n            revert Errors.SignerPackage_SignatureExpired(block.timestamp, expiration);\n        }\n    }\n\n    /**\n     * @dev Recovers the signer of the payload hash.\n     *\n     * @param payloadHash The payload hash which was signed.\n     * @param signature   The signature data for the payload hash.\n     */\n    function _recoverSignerFromPayload(\n        bytes32 payloadHash,\n        bytes memory signature\n    ) internal view returns (address) {\n        // Derive original EIP-712 digest using domain separator and order hash.\n        bytes32 digest = _DOMAIN_SEPARATOR.toTypedDataHash(payloadHash);\n\n        // Recover the signer address of the signature.\n        return digest.recover(signature);\n    }\n\n    /**\n     * @dev Derives the hash of a given item using a type hash.\n     *\n     * @param item Item to hash.\n     *\n     * @return The hash of the item.\n     */\n    function _deriveItemHash(Item memory item) internal view returns (bytes32) {\n        // Derive and return the item as specified by EIP-712.\n        return\n            keccak256(\n                abi.encode("
    }
  ]
}