{
  "Title": "Duplicated code",
  "Content": "There are instances of duplicated code within the codebase. This can lead to issues later on in the development lifecycle, and leaves the project more prone to the introduction of errors. Errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical. One example of duplicated code is the function `_calcWsqueethToMintAndFee` which is defined both in the [`FlashBull`](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/FlashBull.sol#L297-L323) and [`AuctionBull`](https://github.com/opynfinance/squeeth-monorepo/blob/521203dc26e5a2c3e26c6d4ad02d513e7df63237/packages/bull-vault/src/AuctionBull.sol#L822-L843) contracts.\n\n\nInstead of duplicating code, consider having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/bull-vault/src/FlashBull.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\n\npragma abicoder v2;\n\n// interface\nimport { IController } from \"squeeth-monorepo/interfaces/IController.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { IWETH9 } from \"squeeth-monorepo/interfaces/IWETH9.sol\";\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { ICrabStrategyV2 } from \"./interface/ICrabStrategyV2.sol\";\nimport { IBullStrategy } from \"./interface/IBullStrategy.sol\";\n// contract\nimport { UniFlash } from \"./UniFlash.sol\";\n// lib\nimport { StrategyMath } from \"squeeth-monorepo/strategy/base/StrategyMath.sol\"; // StrategyMath licensed under AGPL-3.0-only\nimport { Address } from \"openzeppelin/utils/Address.sol\";\nimport { UniOracle } from \"./UniOracle.sol\";\nimport { VaultLib } from \"squeeth-monorepo/libs/VaultLib.sol\";\n\n/**\n * @notice FlashBull contract\n * @dev handle the flashswap interactions\n * @author opyn team\n */\ncontract FlashBull is UniFlash {\n    using StrategyMath for uint256;\n    using Address for address payable;\n\n    uint256 private constant ONE = 1e18;\n    uint32 private constant TWAP = 420;\n\n    /// @dev enum to differentiate between Uniswap swap callback function source\n    enum FLASH_SOURCE {\n        GENERAL_SWAP,\n        FLASH_DEPOSIT_CRAB,\n        FLASH_DEPOSIT_LENDING_COLLATERAL,\n        FLASH_SWAP_WPOWERPERP,\n        FLASH_WITHDRAW_BULL\n    }\n\n    /// @dev wPowerPerp address\n    address private immutable wPowerPerp;\n    /// @dev weth address\n    address private immutable weth;\n    /// @dev usdc address\n    address private immutable usdc;\n    /// @dev Crab V2 address\n    address private immutable crab;\n    /// @dev ETH:wSqueeth Uniswap pool\n    address private immutable ethWSqueethPool;\n    /// @dev ETH:USDC Uniswap pool\n    address private immutable ethUSDCPool;\n    /// @dev bull stratgey address\n    address public immutable bullStrategy;\n    /// @dev power perp controller address\n    address private immutable powerTokenController;\n\n    /// @dev data structs from Uni v3 callback\n    struct FlashDepositCrabData {\n        uint256 ethToDepositInCrab;\n    }\n\n    struct FlashDepositCollateralData {\n        uint256 crabToDeposit;\n        uint256 wethToLend;\n    }\n\n    struct FlashWithdrawBullData {\n        uint256 bullToRedeem;\n        uint256 usdcToRepay;\n    }\n\n    struct FlashSwapWPowerPerpData {\n        uint256 bullToRedeem;\n        uint256 crabToRedeem;\n        uint256 wPowerPerpToRedeem;\n        uint256 usdcToRepay;\n        uint256 maxEthForUsdc;\n        uint256 usdcPoolFee;\n    }\n\n    /// @dev flashDeposit params structs\n    struct FlashDepositParams {\n        uint256 ethToCrab;\n        uint256 minEthFromSqth;\n        uint256 minEthFromUsdc;\n        uint24 wPowerPerpPoolFee;\n        uint24 usdcPoolFee;\n    }\n\n    /// @dev flashWithdraw params structs\n    struct FlashWithdrawParams {\n        uint256 bullAmount;\n        uint256 maxEthForSqueeth;\n        uint256 maxEthForUsdc;\n        uint24 wPowerPerpPoolFee;\n        uint24 usdcPoolFee;\n    }\n\n    event FlashWithdraw(uint256 bullAmount, uint256 ethReturned);\n    event FlashDeposit(\n        uint256 crabAmount,\n        uint256 ethDeposited,\n        uint256 wSqueethToMint,\n        uint256 usdcToBorrow,\n        uint256 wethToLend\n    );\n\n    constructor(address _bull, address _factory) UniFlash(_factory) {\n        bullStrategy = _bull;\n        crab = IBullStrategy(_bull).crab();\n        powerTokenController = IBullStrategy(_bull).powerTokenController();\n        wPowerPerp = IController(IBullStrategy(_bull).powerTokenController()).wPowerPerp();\n        weth = IController(IBullStrategy(_bull).powerTokenController()).weth();\n        usdc = IController(IBullStrategy(_bull).powerTokenController()).quoteCurrency();\n        ethWSqueethPool = IController(IBullStrategy(_bull).powerTokenController()).wPowerPerpPool();\n        ethUSDCPool =\n            IController(IBullStrategy(_bull).powerTokenController()).ethQuoteCurrencyPool();\n    }\n\n    /**\n     * @notice receive function to allow ETH transfer to this contract\n     */\n    receive() external payable {\n        require(msg.sender == weth || msg.sender == bullStrategy);\n    }\n\n    /**\n     * @notice flash deposit into strategy, providing ETH, selling wSqueeth and USDC, and receiving strategy tokens\n     * @dev this function will execute a flash swap where it receives ETH, deposits, mints, and collateralizes the loan using flash swap proceeds and msg.value, and then repays the flash swap with wSqueeth and USDC\n     * @param _params FlashDepositParams params\n     */\n    function flashDeposit(FlashDepositParams calldata _params) external payable {\n        uint256 crabAmount;\n        uint256 wSqueethToMint;\n        uint256 ethInCrab;\n        uint256 squeethInCrab;\n        {\n            (ethInCrab, squeethInCrab) = _getCrabVaultDetails();\n\n            uint256 ethFee;\n            (wSqueethToMint, ethFee) =\n                _calcWsqueethToMintAndFee(_params.ethToCrab, squeethInCrab, ethInCrab);\n            crabAmount = _calcSharesToMint(\n                _params.ethToCrab.sub(ethFee), ethInCrab, IERC20(crab).totalSupply()\n            );\n        }\n\n        // oSQTH-ETH swap\n        _exactInFlashSwap(\n            wPowerPerp,\n            weth,\n            _params.wPowerPerpPoolFee,\n            wSqueethToMint,\n            _params.minEthFromSqth,\n            uint8(FLASH_SOURCE.FLASH_DEPOSIT_CRAB),\n            abi.encodePacked(_params.ethToCrab)\n        );\n\n        (ethInCrab, squeethInCrab) = _getCrabVaultDetails();\n        uint256 share;\n        if (IERC20(bullStrategy).totalSupply() == 0) {\n            share = ONE;\n        } else {\n            share = crabAmount.wdiv(IBullStrategy(bullStrategy).getCrabBalance().add(crabAmount));\n        }\n        (uint256 wethToLend, uint256 usdcToBorrow) = IBullStrategy(bullStrategy).calcLeverageEthUsdc(\n            crabAmount, share, ethInCrab, squeethInCrab, IERC20(crab).totalSupply()\n        );\n\n        // ETH-USDC swap\n        _exactInFlashSwap(\n            usdc,\n            weth,\n            _params.usdcPoolFee,\n            usdcToBorrow,\n            _params.minEthFromUsdc,\n            uint8(FLASH_SOURCE.FLASH_DEPOSIT_LENDING_COLLATERAL),\n            abi.encodePacked(crabAmount, wethToLend)\n        );\n\n        // return excess eth to the user that was not needed for slippage\n        if (address(this).balance > 0) {\n            payable(msg.sender).sendValue(address(this).balance);\n        }\n\n        IERC20(bullStrategy).transfer(msg.sender, IERC20(bullStrategy).balanceOf(address(this)));\n\n        emit FlashDeposit(crabAmount, msg.value, wSqueethToMint, usdcToBorrow, wethToLend);\n    }\n\n    /**\n     * @notice flash withdraw from strategy, receiving ETH, providing wSqueeth and USDC, and providing strategy tokens\n     * @param _params FlashWithdrawParams struct\n     */\n    function flashWithdraw(FlashWithdrawParams calldata _params) external {\n        IERC20(bullStrategy).transferFrom(msg.sender, address(this), _params.bullAmount);\n\n        uint256 usdcToRepay;\n        uint256 crabToRedeem;\n        uint256 wPowerPerpToRedeem;\n\n        {\n            uint256 bullShare = _params.bullAmount.wdiv(IERC20(bullStrategy).totalSupply());\n            crabToRedeem = bullShare.wmul(IBullStrategy(bullStrategy).getCrabBalance());\n            (, uint256 squeethInCrab) = _getCrabVaultDetails();\n            wPowerPerpToRedeem = crabToRedeem.wmul(squeethInCrab).wdiv(IERC20(crab).totalSupply());\n            usdcToRepay = IBullStrategy(bullStrategy).calcUsdcToRepay(bullShare);\n        }\n\n        // oSQTH-ETH swap\n        _exactOutFlashSwap(\n            weth,\n            wPowerPerp,\n            _params.wPowerPerpPoolFee,\n            wPowerPerpToRedeem,\n            _params.maxEthForSqueeth,\n            uint8(FLASH_SOURCE.FLASH_SWAP_WPOWERPERP),\n            abi.encodePacked(\n                _params.bullAmount,\n                crabToRedeem,\n                wPowerPerpToRedeem,\n                usdcToRepay,\n                _params.maxEthForUsdc,\n                uint256(_params.usdcPoolFee)\n            )\n        );\n\n        uint256 ethToReturn = address(this).balance;\n        payable(msg.sender).sendValue(ethToReturn);\n\n        emit FlashWithdraw(_params.bullAmount, ethToReturn);\n    }\n\n    /**\n     * @notice uniswap flash swap callback function\n     * @dev this function will be called by flashswap callback function uniswapV3SwapCallback()\n     * @param _uniFlashSwapData UniFlashswapCallbackData struct\n     */\n    function _uniFlashSwap(UniFlashswapCallbackData memory _uniFlashSwapData) internal override {\n        if (FLASH_SOURCE(_uniFlashSwapData.callSource) == FLASH_SOURCE.FLASH_DEPOSIT_CRAB) {\n            FlashDepositCrabData memory data =\n                abi.decode(_uniFlashSwapData.callData, (FlashDepositCrabData));\n\n            // convert WETH to ETH as Uniswap uses WETH\n            IWETH9(weth).withdraw(IWETH9(weth).balanceOf(address(this)));\n            ICrabStrategyV2(crab).deposit{value: data.ethToDepositInCrab}();\n\n            // repay the squeeth flash swap\n            IERC20(wPowerPerp).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        } else if (\n            FLASH_SOURCE(_uniFlashSwapData.callSource)\n                == FLASH_SOURCE.FLASH_DEPOSIT_LENDING_COLLATERAL\n        ) {\n            FlashDepositCollateralData memory data =\n                abi.decode(_uniFlashSwapData.callData, (FlashDepositCollateralData));\n            IWETH9(weth).withdraw(IWETH9(weth).balanceOf(address(this)));\n\n            ICrabStrategyV2(crab).approve(bullStrategy, data.crabToDeposit);\n            IBullStrategy(bullStrategy).deposit{value: data.wethToLend}(data.crabToDeposit);\n\n            // repay the dollars flash swap\n            IERC20(usdc).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        } else if (FLASH_SOURCE(_uniFlashSwapData.callSource) == FLASH_SOURCE.FLASH_SWAP_WPOWERPERP)\n        {\n            FlashSwapWPowerPerpData memory data =\n                abi.decode(_uniFlashSwapData.callData, (FlashSwapWPowerPerpData));\n\n            IERC20(wPowerPerp).approve(bullStrategy, data.wPowerPerpToRedeem);\n\n            // ETH-USDC swap\n            _exactOutFlashSwap(\n                weth,\n                usdc,\n                uint24(data.usdcPoolFee),\n                data.usdcToRepay,\n                data.maxEthForUsdc,\n                uint8(FLASH_SOURCE.FLASH_WITHDRAW_BULL),\n                abi.encodePacked(data.bullToRedeem, data.usdcToRepay)\n            );\n\n            IWETH9(weth).deposit{value: _uniFlashSwapData.amountToPay}();\n            IERC20(weth).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        } else if (FLASH_SOURCE(_uniFlashSwapData.callSource) == FLASH_SOURCE.FLASH_WITHDRAW_BULL) {\n            FlashWithdrawBullData memory data =\n                abi.decode(_uniFlashSwapData.callData, (FlashWithdrawBullData));\n\n            IERC20(usdc).approve(bullStrategy, data.usdcToRepay);\n            IBullStrategy(bullStrategy).withdraw(data.bullToRedeem);\n\n            IWETH9(weth).deposit{value: _uniFlashSwapData.amountToPay}();\n            IERC20(weth).transfer(_uniFlashSwapData.pool, _uniFlashSwapData.amountToPay);\n        }\n    }\n\n    /**\n     * @dev calculate amount of wSqueeth to mint and fee based on ETH to deposit into crab\n     * @param _depositedEthAmount ETH amount deposited\n     * @param _strategyDebtAmount amount of wPowerPerp debt in vault\n     * @param _strategyCollateralAmount amount of ETH collateral in vault\n     * @return wSqueeth to mint, mint fee amount\n     */\n    function _calcWsqueethToMintAndFee(\n        uint256 _depositedEthAmount,\n        uint256 _strategyDebtAmount,\n        uint256 _strategyCollateralAmount\n    ) internal view returns (uint256, uint256) {\n        uint256 feeRate = IController(powerTokenController).feeRate();\n        if (feeRate != 0) {\n            uint256 squeethEthPrice =\n                UniOracle._getTwap(ethWSqueethPool, wPowerPerp, weth, TWAP, false);\n            uint256 feeAdjustment = squeethEthPrice.mul(feeRate).div(10000);\n            uint256 wSqueethToMint = _depositedEthAmount.wmul(_strategyDebtAmount).wdiv(\n                _strategyCollateralAmount.add(_strategyDebtAmount.wmul(feeAdjustment))\n            );\n            uint256 fee = wSqueethToMint.wmul(feeAdjustment);\n            return (wSqueethToMint, fee);\n        }\n        uint256 wSqueethToMint =\n            _depositedEthAmount.wmul(_strategyDebtAmount).wdiv(_strategyCollateralAmount);\n        return (wSqueethToMint, 0);\n    }\n\n    /**\n     * @dev calculate amount of strategy token to mint for depositor\n     * @param _amount amount of ETH deposited\n     * @param _strategyCollateralAmount amount of strategy collateral\n     * @param _crabTotalSupply total supply of strategy token\n     * @return amount of strategy token to mint\n     */\n    function _calcSharesToMint(\n        uint256 _amount,\n        uint256 _strategyCollateralAmount,\n        uint256 _crabTotalSupply\n    ) internal pure returns (uint256) {\n        uint256 depositorShare = _amount.wdiv(_strategyCollateralAmount.add(_amount));\n\n        if (_crabTotalSupply != 0) {\n            return _crabTotalSupply.wmul(depositorShare).wdiv(uint256(ONE).sub(depositorShare));\n        }\n\n        return _amount;\n    }\n\n    function _getCrabVaultDetails() internal view returns (uint256, uint256) {\n        VaultLib.Vault memory strategyVault =\n            IController(powerTokenController).vaults(ICrabStrategyV2(crab).vaultId());\n\n        return (strategyVault.collateralAmount, strategyVault.shortAmount);\n    }\n}"
    }
  ]
}