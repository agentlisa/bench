{
  "Title": "M-1: Liquidation bonus scales exponentially instead of linearly.",
  "Content": "# Issue M-1: Liquidation bonus scales exponentially instead of linearly. \n\nSource: https://github.com/sherlock-audit/2024-03-wagmileverage-v2-judging/issues/7 \n\n## Found by \nbughuntoor\n## Summary\nLiquidation bonus scales exponentially instead of linearly. \n\n## Vulnerability Detail\nLet's look at the code of `getLiquidationBonus` \n```solidity\n    function getLiquidationBonus(\n        address token,\n        uint256 borrowedAmount,\n        uint256 times\n    ) public view returns (uint256 liquidationBonus) {\n        // Retrieve liquidation bonus for the given token\n        Liquidation memory liq = liquidationBonusForToken[token];\n        unchecked {\n            if (liq.bonusBP == 0) {\n                // If there is no specific bonus for the token\n                // Use default bonus\n                liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n                liq.bonusBP = dafaultLiquidationBonusBP;\n            }\n            liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n\n            if (liquidationBonus < liq.minBonusAmount) {\n                liquidationBonus = liq.minBonusAmount;\n            }\n            liquidationBonus *= (times > 0 ? times : 1);\n        }\n    }\n```\nAs we can see, the liquidation bonus is based on the entire `borrowAmount`  and multiplied by the number of new loans added.\nThe problem is that it is unfair when the user makes a borrow against multiple lenders.\n\nIf a user takes a borrow for X against 1 lender, they'll have to pay a liquidation bonus of Y.\nHowever, if they take a borrow for 3X against 3 lenders, they'll have to pay 9Y, meaning that taking a borrow against N lenders leads to overpaying liquidation bonus by N times. \n\nFurthermore, if the user simply does it in multiple transactions, they can avoid these extra fees (as they can simply call `borrow` for X 3 times and pay 3Y in Liquidation bonuses)\n\n## Impact\nLoss of funds\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-wagmileverage-v2/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L280\n\n## Tool used\n\nManual Review\n\n## Recommendation\nmake liquidation bonus simply a % of totalBorrowed\n\n\n\n## Discussion\n\n**fann95**\n\nWe discussed as a team multiplying the bonus depending on the method of taking out a loan and ultimately decided to abandon it completely.\na few days ago I made the corresponding commit https://github.com/RealWagmi/wagmi-leverage/commit/7575ab6659e99e59f5b7b7d1454649091c0295c6\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/RealWagmi/wagmi-leverage/commit/7575ab6659e99e59f5b7b7d1454649091c0295c6.\n\n**sherlock-admin3**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**WangAudit** commented:\n> decided that it's a H not an M cause even if it's intended behaviour; user can easily bypass it; or if it's not intended' then it will be applied every time when times > 2\n\n**takarez** commented:\n>  i think that is a design choice to charge whenever there's a borrow.\n\n\n\n**fann95**\n\n> 2 comment(s) were left on this issue during the judging contest.\n> \n> **WangAudit** commented:\n> \n> > decided that it's a H not an M cause even if it's intended behaviour; user can easily bypass it; or if it's not intended' then it will be applied every time when times > 2\n> \n> **takarez** commented:\n> \n> > i think that is a design choice to charge whenever there's a borrow.\n\nThe liquidation bonus was charged more than initially expected, so the user’s cunning could only lead to a fair payment. But ultimately the bonus would still be returned to the trader. The trader paid a more liquidation bonus if he extracted more than one  NFT position, which in itself is a rare case... anyway, we removed it from the code..\n\n**spacegliderrrr**\n\nFix looks good, liquidation bonus is now correctly proportional to borrow amount, no matter the number of lenders.\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/281",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/LiquidityBorrowingManager.sol",
      "content": "// SPDX-License-Identifier: SAL-1.0\n\npragma solidity 0.8.23;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./abstract/OwnerSettings.sol\";\nimport \"./abstract/DailyRateAndCollateral.sol\";\nimport \"./libraries/ErrLib.sol\";\nimport \"./interfaces/ILiquidityBorrowingManager.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * WAGMI Leverage Protocol v2.0 beta\n * wagmi.com                                                \n * \n    /  |  _  /  | /      \\  /      \\ /  \\     /  |/      | \n    $$ | / \\ $$ |/$$$$$$  |/$$$$$$  |$$  \\   /$$ |$$$$$$/ \n    $$ |/$  \\$$ |$$ |__$$ |$$ | _$$/ $$$  \\ /$$$ |  $$ |  \n    $$ /$$$  $$ |$$    $$ |$$ |/    |$$$$  /$$$$ |  $$ |  \n    $$ $$/$$ $$ |$$$$$$$$ |$$ |$$$$ |$$ $$ $$/$$ |  $$ |  \n    $$$$/  $$$$ |$$ |  $$ |$$ \\__$$ |$$ |$$$/ $$ | _$$ |_ \n    $$$/    $$$ |$$ |  $$ |$$    $$/ $$ | $/  $$ |/ $$   |  \n    $$/      $$/ $$/   $$/  $$$$$$/  $$/      $$/ $$$$$$/  \n */\n\ncontract LiquidityBorrowingManager is\n    ILiquidityBorrowingManager,\n    OwnerSettings,\n    DailyRateAndCollateral,\n    ReentrancyGuard\n{\n    using { ErrLib.revertError } for bool;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// borrowingKey=>LoanInfo\n    mapping(bytes32 => LoanInfo[]) private loansInfo;\n    /// borrowingKey=>BorrowingInfo\n    mapping(bytes32 => BorrowingInfo) public borrowingsInfo;\n    /// NonfungiblePositionManager tokenId => EnumerableSet.Bytes32Set\n    mapping(uint256 => EnumerableSet.Bytes32Set) private tokenIdToBorrowingKeys;\n    /// borrower => EnumerableSet.Bytes32Set\n    mapping(address => EnumerableSet.Bytes32Set) private userBorrowingKeys;\n\n    /// @dev Modifier to check if the current block timestamp is before or equal to the deadline.\n    modifier checkDeadline(uint256 deadline) {\n        (_blockTimestamp() > deadline).revertError(ErrLib.ErrorCode.TOO_OLD_TRANSACTION);\n        _;\n    }\n\n    modifier onlyOperator() {\n        (msg.sender != operator).revertError(ErrLib.ErrorCode.INVALID_CALLER);\n        _;\n    }\n\n    function _blockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _flashLoanAggregator,\n        address _lightQuoterV3,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    )\n        LiquidityManager(\n            _underlyingPositionManagerAddress,\n            _flashLoanAggregator,\n            _lightQuoterV3,\n            _underlyingV3Factory,\n            _underlyingV3PoolInitCodeHash\n        )\n    {}\n\n    /**\n     * @dev Adds or removes a swap call params to the whitelist.\n     * @param swapTarget The address of the target contract for the swap call.\n     * @param funcSelector The function selector of the swap call.\n     * @param isAllowed A boolean indicating whether the swap call is allowed or not.\n     */\n    function setSwapCallToWhitelist(\n        address swapTarget,\n        bytes4 funcSelector,\n        bool isAllowed\n    ) external onlyOwner {\n        (swapTarget == VAULT_ADDRESS ||\n            swapTarget == address(this) ||\n            swapTarget == address(underlyingPositionManager) ||\n            funcSelector == IERC20.transferFrom.selector).revertError(ErrLib.ErrorCode.FORBIDDEN);\n        whitelistedCall[swapTarget][funcSelector] = isAllowed;\n    }\n\n    /**\n     * @notice This function allows the owner to collect protocol fees for multiple tokens\n     * and transfer them to a specified recipient.\n     * @dev Only the contract owner can call this function.\n     * @param recipient The address of the recipient who will receive the collected fees.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectProtocol(address recipient, address[] calldata tokens) external onlyOwner {\n        uint256[] memory amounts = _collect(platformsFeesInfo, recipient, tokens);\n\n        emit CollectProtocol(recipient, tokens, amounts);\n    }\n\n    /**\n     * @notice This function allows the caller to collect their own loan fees for multiple tokens\n     * and transfer them to themselves.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectLoansFees(address[] calldata tokens) external {\n        mapping(address => uint256) storage collection = loansFeesInfo[msg.sender];\n        uint256[] memory amounts = _collect(collection, msg.sender, tokens);\n\n        emit CollectLoansFees(msg.sender, tokens, amounts);\n    }\n\n    /**\n     * @notice This function is used to update the daily rate for holding token for specific pair.\n     * @dev Only the daily rate operator can call this function.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param value The new value of the daily rate for the hold token will be calculated based\n     * on the volatility of the pair and the popularity of loans in it\n     * @dev The value must be within the range of MIN_DAILY_RATE and MAX_DAILY_RATE.\n     */\n    function updateHoldTokenDailyRate(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external onlyOperator {\n        if (value > Constants.MAX_DAILY_RATE || value < Constants.MIN_DAILY_RATE) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(saleToken, holdToken);\n        holdTokenRateInfo.currentDailyRate = value;\n        emit UpdateHoldTokenDailyRate(saleToken, holdToken, value);\n    }\n\n    function updateHoldTokenEntranceFee(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external onlyOperator {\n        if (value > Constants.MAX_ENTRANCE_FEE_BPS + 1) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenEntranceFeeInfo) = _updateHoldTokenRateInfo(\n            saleToken,\n            holdToken\n        );\n        holdTokenEntranceFeeInfo.entranceFeeBP = value;\n        emit UpdateHoldTokeEntranceFee(saleToken, holdToken, value);\n    }\n\n    /**\n     * @notice This function is used to check the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The key of the borrowing.\n     * @return balance The balance of the daily rate collateral.\n     * @return estimatedLifeTime The estimated lifetime of the collateral in seconds.\n     */\n    function checkDailyRateCollateral(\n        bytes32 borrowingKey\n    ) external view returns (int256 balance, uint256 estimatedLifeTime) {\n        (, balance, estimatedLifeTime) = _getDebtInfo(borrowingKey);\n        balance /= int256(Constants.COLLATERAL_BALANCE_PRECISION);\n    }\n\n    /**\n     * @notice Get information about loans associated with a borrowing key\n     * @dev This function retrieves an array of loan information for a given borrowing key.\n     * The loans are stored in the loansInfo mapping, which is a mapping of borrowing keys to LoanInfo arrays.\n     * @param borrowingKey The unique key associated with the borrowing\n     * @return loans An array containing LoanInfo structs representing the loans associated with the borrowing key\n     */\n    function getLoansInfo(bytes32 borrowingKey) external view returns (LoanInfo[] memory loans) {\n        loans = loansInfo[borrowingKey];\n    }\n\n    /**\n     * @notice Retrieves the borrowing information for a specific NonfungiblePositionManager tokenId.\n     * @param tokenId The unique identifier of the PositionManager token.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getLenderCreditsInfo(\n        uint256 tokenId\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = getBorrowingKeysForTokenId(tokenId);\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Retrieves the borrowing keys associated with a token ID.\n     * @param tokenId The identifier of the token.\n     * @return borrowingKeys An array of borrowing keys.\n     */\n    function getBorrowingKeysForTokenId(\n        uint256 tokenId\n    ) public view returns (bytes32[] memory borrowingKeys) {\n        borrowingKeys = tokenIdToBorrowingKeys[tokenId].values();\n    }\n\n    /**\n     * @dev Retrieves the borrowing keys for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return borrowingKeys An array of borrowing keys.\n     */\n    function getBorrowingKeysForBorrower(\n        address borrower\n    ) public view returns (bytes32[] memory borrowingKeys) {\n        borrowingKeys = userBorrowingKeys[borrower].values();\n    }\n\n    /**\n     * @notice Retrieves the debts information for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getBorrowerDebtsInfo(\n        address borrower\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower].values();\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Returns the current daily rate for holding token.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @return  holdTokenRateInfo The structured data containing detailed information for the hold token.\n     */\n    function getHoldTokenInfo(\n        address saleToken,\n        address holdToken\n    ) external view returns (TokenInfo memory holdTokenRateInfo) {\n        holdTokenRateInfo = _getHoldTokenInfo(saleToken, holdToken);\n    }\n\n    /**\n     * @dev Returns the fees information for multiple tokens in an array.\n     * @param feesOwner The address of the owner of the fees.\n     * @param tokens An array of token addresses for which the fees are to be retrieved.\n     * @return fees An array containing the fees for each token.\n     */\n    function getFeesInfo(\n        address feesOwner,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        mapping(address => uint256) storage collection = loansFeesInfo[feesOwner];\n        fees = _getFees(collection, tokens);\n    }\n\n    /**\n     * @dev Get the platform fees information for a list of tokens.\n     *\n     * This function returns an array of fees corresponding to the list of input tokens provided.\n     * Each fee is retrieved from the `platformsFeesInfo` mapping which stores the fee for each token address.\n     *\n     * @param tokens An array of token addresses for which to retrieve the fees information.\n     * @return fees Returns an array of fees, one per each token given as input in the same order.\n     */\n    function getPlatformFeesInfo(\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        mapping(address => uint256) storage collection = platformsFeesInfo;\n        fees = _getFees(collection, tokens);\n    }\n\n    /**\n     * @dev Calculates the liquidation bonus for a given token, borrowed amount, and times factor.\n     * @param token The address of the token.\n     * @param borrowedAmount The amount of tokens borrowed.\n     * @param times The times factor to apply to the liquidation bonus calculation.\n     * @return liquidationBonus The calculated liquidation bonus.\n     */\n    function getLiquidationBonus(\n        address token,\n        uint256 borrowedAmount,\n        uint256 times\n    ) public view returns (uint256 liquidationBonus) {\n        // Retrieve liquidation bonus for the given token\n        Liquidation memory liq = liquidationBonusForToken[token];\n        unchecked {\n            if (liq.bonusBP == 0) {\n                // If there is no specific bonus for the token\n                // Use default bonus\n                liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n                liq.bonusBP = dafaultLiquidationBonusBP;\n            }\n            liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n\n            if (liquidationBonus < liq.minBonusAmount) {\n                liquidationBonus = liq.minBonusAmount;\n            }\n            liquidationBonus *= (times > 0 ? times : 1);\n        }\n    }\n\n    /**\n     * @dev Calculates the collateral amount required for a lifetime in seconds.\n     *\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param lifetimeInSeconds The duration of the borrowing in seconds.\n     * @return collateralAmt The calculated collateral amount that is needed.\n     */\n    function calculateCollateralAmtForLifetime(\n        bytes32 borrowingKey,\n        uint256 lifetimeInSeconds\n    ) external view returns (uint256 collateralAmt) {\n        // Retrieve the BorrowingInfo struct associated with the borrowing key\n        BorrowingInfo memory borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowed position is existing\n        if (borrowing.borrowedAmount > 0) {\n            // Get the current daily rate for the hold token\n            uint256 currentDailyRate = _getHoldTokenInfo(borrowing.saleToken, borrowing.holdToken)\n                .currentDailyRate;\n            // Calculate the collateral amount per second\n            uint256 everySecond = _everySecond(borrowing.borrowedAmount, currentDailyRate);\n            // Calculate the total collateral amount for the borrowing lifetime\n            collateralAmt = FullMath.mulDivRoundingUp(\n                everySecond,\n                lifetimeInSeconds,\n                Constants.COLLATERAL_BALANCE_PRECISION\n            );\n            // Ensure that the collateral amount is at least 1\n            if (collateralAmt == 0) collateralAmt = 1;\n        }\n    }\n\n    /**\n     * @notice This function is used to increase the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param collateralAmt The amount of collateral to be added.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     */\n    function increaseCollateralBalance(\n        bytes32 borrowingKey,\n        uint256 collateralAmt,\n        uint256 deadline\n    ) external checkDeadline(deadline) {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists and the borrower is the message sender\n        (borrowing.borrowedAmount == 0 || borrowing.borrower != address(msg.sender)).revertError(\n            ErrLib.ErrorCode.INVALID_BORROWING_KEY\n        );\n        // Increase the daily rate collateral balance by the specified collateral amount\n        borrowing.dailyRateCollateralBalance +=\n            collateralAmt *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        _pay(borrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt);\n        emit IncreaseCollateralBalance(msg.sender, borrowingKey, collateralAmt);\n    }\n\n    /**\n     * @notice Borrow function allows a user to borrow tokens by providing collateral and taking out loans.\n     * The trader opens a long position by borrowing the liquidity of Uniswap V3 and extracting it into a pair of tokens,\n     * one of which will be swapped into a desired(holdToken).The tokens will be kept in storage until the position is closed.\n     * The margin is calculated on the basis that liquidity must be restored with any price movement.\n     * The time the position is held is paid by the trader.\n     * @dev Emits a Borrow event upon successful borrowing.\n     * @param params The BorrowParams struct containing the necessary parameters for borrowing.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     *\n     * @return borrowedAmount The total amount of `params.holdToken` borrowed.\n     * @return marginDeposit The required collateral deposit amount for initiating the loan.\n     * @return liquidationBonus An additional amount added to the debt as a bonus in case of liquidation.\n     * @return dailyRateCollateral The collateral deposit to hold the transaction for a day.\n     */\n    function borrow(\n        BorrowParams calldata params,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        returns (uint256, uint256, uint256, uint256, uint256)\n    {\n        BorrowCache memory cache;\n        BorrowingInfo storage borrowing;\n        {\n            // Update the token rate information and retrieve the dailyRate and TokenInfo for the holdTokenRateInfo\n            TokenInfo storage holdTokenRateInfo;\n            (cache.dailyRateCollateral, holdTokenRateInfo) = _updateHoldTokenRateInfo(\n                params.saleToken,\n                params.holdToken\n            );\n            uint256 entranceFee = _checkEntranceFee(holdTokenRateInfo.entranceFeeBP);\n            // Precalculating borrowing details and storing them in cache\n            _precalculateBorrowing(cache, params, entranceFee);\n\n            // Initializing borrowing variables and obtaining borrowing key\n            borrowing = borrowingsInfo[cache.borrowingKey];\n            _initOrUpdateBorrowing(\n                params.saleToken,\n                params.holdToken,\n                params.maxDailyRate,\n                cache,\n                borrowing,\n                holdTokenRateInfo\n            );\n        }\n        uint256 liquidationBonus;\n        {\n            // Adding borrowing key and loans information to storage\n            uint256 pushCounter = _addKeysAndLoansInfo(cache.borrowingKey, params.loans);\n            // Calculating liquidation bonus based on hold token, borrowed amount, and number of used loans\n            liquidationBonus = getLiquidationBonus(\n                params.holdToken,\n                cache.borrowedAmount,\n                pushCounter\n            );\n        }\n        uint256 marginDeposit;\n        // positive slippage\n        if (cache.holdTokenBalance > cache.borrowedAmount) {\n            // Thus, we stimulate the platform to look for the best conditions for swapping on external aggregators.\n            platformsFeesInfo[params.holdToken] +=\n                (cache.holdTokenBalance - cache.borrowedAmount) *\n                Constants.COLLATERAL_BALANCE_PRECISION;\n        } else {\n            unchecked {\n                marginDeposit = cache.borrowedAmount - cache.holdTokenBalance;\n            }\n            (marginDeposit > params.maxMarginDeposit).revertError(\n                ErrLib.ErrorCode.TOO_BIG_MARGIN_DEPOSIT\n            );\n        }\n\n        uint256 amountToPay;\n        unchecked {\n            // Updating borrowing details\n            borrowing.borrowedAmount += cache.borrowedAmount;\n            borrowing.liquidationBonus += liquidationBonus;\n            // Transfer the required tokens to the VAULT_ADDRESS for collateral and holdTokenBalance\n            borrowing.dailyRateCollateralBalance +=\n                cache.dailyRateCollateral *\n                Constants.COLLATERAL_BALANCE_PRECISION;\n            amountToPay =\n                marginDeposit +\n                liquidationBonus +\n                cache.dailyRateCollateral +\n                cache.holdTokenEntranceFee;\n        }\n        _pay(params.holdToken, msg.sender, VAULT_ADDRESS, amountToPay);\n        // Transferring holdTokenBalance to VAULT_ADDRESS\n        _pay(params.holdToken, address(this), VAULT_ADDRESS, cache.holdTokenBalance);\n        // Emit the Borrow event with the borrower, borrowing key, and borrowed amount\n        emit Borrow(\n            msg.sender,\n            cache.borrowingKey,\n            cache.borrowedAmount,\n            marginDeposit,\n            liquidationBonus,\n            cache.dailyRateCollateral,\n            cache.holdTokenEntranceFee\n        );\n        return (\n            cache.borrowedAmount,\n            marginDeposit,\n            liquidationBonus,\n            cache.dailyRateCollateral,\n            cache.holdTokenEntranceFee\n        );\n    }\n\n    /**\n     * @notice Allows lenders to harvest the fees accumulated from their loans.\n     * @dev Retrieves and updates fee amounts for all loans associated with a borrowing position.\n     * The function iterates through each loan, calculating and updating the amount of fees due.\n     *\n     * Requirements:\n     * - The borrowingKey must correspond to an active and valid borrowing position.\n     * - The collateral balance must be above zero or the current fees must be above the minimum required amount.\n     *\n     * @param borrowingKey The unique identifier for the specific borrowing position.\n     *\n     * @return harvestedAmt The total amount of fees harvested by the borrower.\n     */\n    function harvest(bytes32 borrowingKey) external nonReentrant returns (uint256 harvestedAmt) {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowing key is valid\n        _existenceCheck(borrowing.borrowedAmount);\n\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n        return _harvest(borrowingKey, borrowing, holdTokenRateInfo);\n    }\n\n    /**\n     * @notice Used for repaying loans, optionally with liquidation or emergency liquidity withdrawal.\n     * The position is closed either by the trader or by the liquidator if the trader has not paid for holding the position\n     * and the moment of liquidation has arrived.The positions borrowed from liquidation providers are restored from the held\n     * token and the remainder is sent to the caller.In the event of liquidation, the liquidity provider\n     * whose liquidity is present in the trader’s position can use the emergency mode and withdraw their liquidity.In this case,\n     * he will receive hold tokens and liquidity will not be restored in the uniswap pool.\n     * @param params The repayment parameters including\n     *  activation of the emergency liquidity restoration mode (available only to the lender)\n     *  internal swap pool fee,\n     *  external swap parameters,\n     *  borrowing key,\n     *  swap slippage allowance.\n     * @param deadline The deadline by which the repayment must be made.\n     *\n     * @return saleTokenOut The amount of saleToken returned back to the user after repayment.\n     * @return holdTokenOut The amount of holdToken returned back to the user after repayment or emergency withdrawal.\n     */\n    function repay(\n        RepayParams calldata params,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        returns (uint256 saleTokenOut, uint256 holdTokenOut)\n    {\n        BorrowingInfo memory borrowing = borrowingsInfo[params.borrowingKey];\n        // Check if the borrowing key is valid\n        _existenceCheck(borrowing.borrowedAmount);\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n        uint256 liquidationBonus = borrowing.liquidationBonus;\n        int256 collateralBalance;\n        uint256 currentFees;\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n        bool underLiquidation;\n        {\n            // Calculate collateral balance and validate caller\n            uint256 accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n\n            (collateralBalance, currentFees) = _calculateCollateralBalance(\n                borrowing.borrowedAmount,\n                borrowing.accLoanRatePerSeconds,\n                borrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n            underLiquidation = collateralBalance < 0;\n\n            (msg.sender != borrowing.borrower && !underLiquidation).revertError(\n                ErrLib.ErrorCode.INVALID_CALLER\n            );\n\n            // Calculate liquidation bonus and adjust fees owed\n            if (collateralBalance > 0) {\n                unchecked {\n                    liquidationBonus +=\n                        uint256(collateralBalance) /\n                        Constants.COLLATERAL_BALANCE_PRECISION;\n                }\n            } else {\n                currentFees = borrowing.dailyRateCollateralBalance;\n            }\n        }\n        // Check if it's an emergency repayment\n        if (params.isEmergency) {\n            (!underLiquidation).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            (\n                uint256 removedAmt,\n                uint256 feesAmt,\n                bool completeRepayment\n            ) = _calculateEmergencyLoanClosure(\n                    zeroForSaleToken,\n                    params.borrowingKey,\n                    currentFees,\n                    borrowing.borrowedAmount\n                );\n            (removedAmt == 0).revertError(ErrLib.ErrorCode.LIQUIDITY_IS_ZERO);\n            // Subtract the removed amount and fees from borrowedAmount and feesOwed\n            borrowing.borrowedAmount -= removedAmt;\n            borrowing.dailyRateCollateralBalance -= feesAmt;\n            feesAmt =\n                _pickUpPlatformFees(borrowing.holdToken, feesAmt) /\n                Constants.COLLATERAL_BALANCE_PRECISION;\n            // Deduct the removed amount from totalBorrowed\n            unchecked {\n                holdTokenRateInfo.totalBorrowed -= removedAmt;\n            }\n            // If loansInfoLength is 0, remove the borrowing key from storage and get the liquidation bonus\n            if (completeRepayment) {\n                LoanInfo[] memory empty;\n                _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, empty);\n                feesAmt =\n                    _pickUpPlatformFees(borrowing.holdToken, currentFees) /\n                    Constants.COLLATERAL_BALANCE_PRECISION +\n                    liquidationBonus;\n            } else {\n                // make changes to the storage\n                BorrowingInfo storage borrowingStorage = borrowingsInfo[params.borrowingKey];\n                borrowingStorage.dailyRateCollateralBalance = borrowing.dailyRateCollateralBalance;\n                borrowingStorage.borrowedAmount = borrowing.borrowedAmount;\n            }\n            unchecked {\n                holdTokenOut = removedAmt + feesAmt;\n            }\n            // Transfer removedAmt + feesAmt to msg.sender and emit EmergencyLoanClosure event\n            Vault(VAULT_ADDRESS).transferToken(borrowing.holdToken, msg.sender, holdTokenOut);\n            emit EmergencyLoanClosure(borrowing.borrower, msg.sender, params.borrowingKey);\n        } else {\n            // Calculate platform fees and adjust fees owed\n            currentFees = _pickUpPlatformFees(borrowing.holdToken, currentFees);\n            // Deduct borrowedAmount from totalBorrowed\n            unchecked {\n                holdTokenRateInfo.totalBorrowed -= borrowing.borrowedAmount;\n            }\n\n            // Transfer the borrowed amount and liquidation bonus from the VAULT to this contract\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n\n            // Restore liquidity using the borrowed amount and pay a daily rate fee\n            LoanInfo[] memory loans = loansInfo[params.borrowingKey];\n\n            _maxApproveIfNecessary(borrowing.holdToken, address(underlyingPositionManager));\n            _maxApproveIfNecessary(borrowing.saleToken, address(underlyingPositionManager));\n\n            _restoreLiquidity(\n                RestoreLiquidityParams({\n                    zeroForSaleToken: zeroForSaleToken,\n                    totalfeesOwed: currentFees,\n                    totalBorrowedAmount: borrowing.borrowedAmount,\n                    routes: params.routes,\n                    loans: loans\n                })\n            );\n\n            // Remove borrowing key from related data structures\n            _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n\n            // Get the remaining balance of saleToken and holdToken\n            (saleTokenOut, holdTokenOut) = _getPairBalance(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n\n            (holdTokenOut < params.minHoldTokenOut || saleTokenOut < params.minSaleTokenOut)\n                .revertError(ErrLib.ErrorCode.PRICE_SLIPPAGE_CHECK);\n\n            // Pay a profit to a msg.sender\n            _pay(borrowing.holdToken, address(this), msg.sender, holdTokenOut);\n            _pay(borrowing.saleToken, address(this), msg.sender, saleTokenOut);\n\n            emit Repay(borrowing.borrower, msg.sender, params.borrowingKey);\n        }\n    }\n\n    /// @notice Calculates the collateral balance, picks up platform fees, updates rates, and distributes the fees to creditors.\n    /// @custom:throw \"FORBIDDEN\" When the calculated collateral balance is less than or equal to zero, indicating the caller is not allowed to initiate harvest.\n    function _harvest(\n        bytes32 borrowingKey,\n        BorrowingInfo storage borrowing,\n        TokenInfo storage holdTokenRateInfo\n    ) private returns (uint256 harvestedAmt) {\n        // Calculate collateral balance and validate caller\n        (int256 collateralBalance, uint256 currentFees) = _calculateCollateralBalance(\n            borrowing.borrowedAmount,\n            borrowing.accLoanRatePerSeconds,\n            borrowing.dailyRateCollateralBalance,\n            holdTokenRateInfo.accLoanRatePerSeconds\n        );\n        (collateralBalance <= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n\n        // Calculate platform fees and adjust fees owed\n        unchecked {\n            borrowing.dailyRateCollateralBalance -= currentFees;\n        }\n        uint256 feesOwed = _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        // Set the accumulated loan rate per second for the borrowing position\n        borrowing.accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n\n        uint256 borrowedAmount = borrowing.borrowedAmount;\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n\n        // Create a memory struct to store liquidity cache information.\n        NftPositionCache memory cache;\n        // Get the array of LoanInfo structs associated with the given borrowing key.\n        LoanInfo[] memory loans = loansInfo[borrowingKey];\n        // Iterate through each loan in the loans array.\n        for (uint256 i; i < loans.length; ) {\n            LoanInfo memory loan = loans[i];\n            // Get the owner address of the loan's token ID using the underlyingPositionManager contract.\n            address creditor = _getOwnerOf(loan.tokenId);\n            // Check if the owner of the loan's token ID is equal to the `msg.sender`.\n            if (creditor != address(0)) {\n                // Update the liquidity cache based on the loan information.\n                _upNftPositionCache(zeroForSaleToken, loan, cache);\n                uint256 feesAmt = FullMath.mulDiv(feesOwed, cache.holdTokenDebt, borrowedAmount);\n                // Calculate the fees amount based on the total fees owed and holdTokenDebt.\n                unchecked {\n                    loansFeesInfo[creditor][cache.holdToken] += feesAmt;\n                    harvestedAmt += feesAmt;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit Harvest(borrowingKey, harvestedAmt);\n    }\n\n    /**\n     * @notice Calculates the amount to be repaid in an emergency situation.\n     * @dev This function removes loans associated with a borrowing key owned by the `msg.sender`.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param borrowingKey The identifier for the borrowing key.\n     * @param totalfeesOwed The total fees owed.\n     * @param totalBorrowedAmount The total borrowed amount.\n     * @return removedAmt The amount of debt removed from the loan.\n     * @return feesAmt The calculated fees amount.\n     * @return c"
    }
  ]
}