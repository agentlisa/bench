{
  "Title": "M-8: EMI last payment not handled perfectly could lead to borrower losing collaterals",
  "Content": "# Issue M-8: EMI last payment not handled perfectly could lead to borrower losing collaterals \n\nSource: https://github.com/sherlock-audit/2023-03-teller-judging/issues/315 \n\n## Found by \nRaymondFam\n## Summary\nThe ternary logic of `calculateAmountOwed()` could have the last EMI payment under calculated, leading to borrower not paying the owed principal and possibly losing the collaterals if care has not been given to.\n\n## Vulnerability Detail\nSupposing Bob has a loan duration of 100 days such that the payment cycle is evenly spread out, i.e payment due every 10 days, here is a typical scenario:\n\n1. Bob has been making his payment due on time to avoid getting marked delinquent. For the last payment due, Bob decides to make it 5 minutes earlier just to make sure he will not miss it.\n2. However, `duePrincipal_` ends up assigned the minimum of `owedAmount - interest_` and `owedPrincipal_`, where the former is chosen since `oweTime` is less than `_bid.terms.paymentCycle`:\n\n```solidity\n        } else {\n            // Default to PaymentType.EMI\n            // Max payable amount in a cycle\n            // NOTE: the last cycle could have less than the calculated payment amount\n            uint256 maxCycleOwed = isLastPaymentCycle\n                ? owedPrincipal_ + interest_\n                : _bid.terms.paymentCycleAmount;\n\n            // Calculate accrued amount due since last repayment\n            uint256 owedAmount = (maxCycleOwed * owedTime) /\n                _bid.terms.paymentCycle;\n            duePrincipal_ = Math.min(owedAmount - interest_, owedPrincipal_);\n        }\n```\n3. Hence, in `_repayLoan()`, `paymentAmount >= _owedAmount` equals false failing to  close the loan to have the collaterals returned to Bob:\n\n```solidity\n        if (paymentAmount >= _owedAmount) {\n            paymentAmount = _owedAmount;\n            bid.state = BidState.PAID;\n\n            // Remove borrower's active bid\n            _borrowerBidsActive[bid.borrower].remove(_bidId);\n\n            // If loan is is being liquidated and backed by collateral, withdraw and send to borrower\n            if (_shouldWithdrawCollateral) {\n                collateralManager.withdraw(_bidId);\n            }\n\n            emit LoanRepaid(_bidId);\n```\n4. While lingering and not paying too much attention to the collateral still in escrow, Bob presumes his loan is now settled.\n5. Next, Alex the lender has been waiting for this golden opportunity and proceeds to calling [`CollateralManager.withdraw()`](https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L250-L260) to claim all collaterals as soon as the loan turns defaulted.\n\n## Impact\nBob ended up losing all collaterals for the sake of the minute amount of loan unpaid whereas Alex receives almost all principal plus interests on top of the collaterals. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol#L107-L119\n\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/TellerV2.sol#L727-L739\n\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol#L250-L260\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider refactoring the affected ternary logic as follows:\n\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol#L107-L119\n\n```diff\n        } else {\n+            duePrincipal = isLastPaymentCycle\n+                ? owedPrincipal\n+               : (_bid.terms.paymentCycleAmount * owedTime) / _bid.terms.paymentCycle;\n\n            // Default to PaymentType.EMI\n            // Max payable amount in a cycle\n            // NOTE: the last cycle could have less than the calculated payment amount\n-            uint256 maxCycleOwed = isLastPaymentCycle\n-                ? owedPrincipal_ + interest_\n-                : _bid.terms.paymentCycleAmount;\n\n            // Calculate accrued amount due since last repayment\n-            uint256 owedAmount = (maxCycleOwed * owedTime) /\n-                _bid.terms.paymentCycle;\n-            duePrincipal_ = Math.min(owedAmount - interest_, owedPrincipal_);\n        }\n```\n\n\n\n\n## Discussion\n\n**iamjakethehuman**\n\nEscalate for 10 USDC\nDisagree with severity. Issue should be considered QA/ Low. \nUpon repaying, the user will see whether the final repayment has been successful. In fact, a corresponding event is emitted. If the final repayment was successful `LoanRepaid(_bidId)` is emitted. If the collateral isn't withdrawn `LoanRepayment(_bidId)` is emitted.\nAlso, the said scenario requires the user to not see that they haven't received their collateral back for at least `bidDefaultDuration[_bidId])` which makes the scenario even more unrealistic.\nhttps://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/TellerV2.sol#L965-#L968\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> Disagree with severity. Issue should be considered QA/ Low. \n> Upon repaying, the user will see whether the final repayment has been successful. In fact, a corresponding event is emitted. If the final repayment was successful `LoanRepaid(_bidId)` is emitted. If the collateral isn't withdrawn `LoanRepayment(_bidId)` is emitted.\n> Also, the said scenario requires the user to not see that they haven't received their collateral back for at least `bidDefaultDuration[_bidId])` which makes the scenario even more unrealistic.\n> https://github.com/sherlock-audit/2023-03-teller/blob/main/teller-protocol-v2/packages/contracts/contracts/TellerV2.sol#L965-#L968\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**raymondfam**\n\nMost borrowers would form a habit making the recurring payments in time by doing it slightly earlier just like anyone would be making a car, credit card or house payment just to make sure no late payments could tarnish their credit reputation. The protocol logic is intuitive in making adjustments to users forming this good habit. However, the current ternary logic could trap/trick many unsavvy borrowers when handling the last payment. The adept users might notice the event emitted but would run into the same issue again unless function repayLoanFull is used instead of function repayLoan. As a borrower, I would expect the system handle the transaction all clean come the last payment.\n\nAdditionally, function isLoanDefaulted does not care how much principal and interest has been paid in the past; all it cares is whether or not `(uint32(block.timestamp) - _liquidationDelay - lastRepaidTimestamp(_bidId) > bidDefaultDuration[_bidId])` where `_liquidationDelay == 0` in this case. Depending on the value of `bidDefaultDuration[_bidId]`, the amount of seconds elapsed could transpire quickly. Imagine doing this before sleep, and then getting caught up with a full  day of chores and work the next day, and before too long  the position is already deemed delinquent without the borrower even aware of it.\n\n**ethereumdegen**\n\nYour updated logic does compile, however it makes 5 tests fail.  Are you also implying that these 5 tests are incorrect?   Or does that mean that there is an issue with your suggested logic?  In any case, more deeply investigating.  \n\n[FAIL. Reason: Assertion failed.] test_01_calculateAmountOwed() (gas: 442923)\n[FAIL. Reason: Assertion failed.] test_02_calculateAmountOwed() (gas: 483615)\n[FAIL. Reason: Assertion failed.] test_03_calculateAmountOwed() (gas: 336240)\n[FAIL. Reason: Assertion failed.] test_04_calculateAmountOwed() (gas: 441542)\n[FAIL. Reason: Assertion failed.] test_05_calculateAmountOwed() (gas: 335700)\n\n\n\n\n**hrishibhat**\n\nEscalation rejected\n\nValid medium\nThis is a valid issue where it gives an incorrect amount during the last payment cycle. \nSponsor comment:\n> is most certainly a valid issue, there is a fix .  The issue is if a user makes all their payments normally and on time, then in the last payment cycle, their amount owed fluctutes over time however the intent is that in the last payment cycle the amount owed should be  'the entire remaining balance' . Not fluctuating over time.  (the time fluctuation is because of code that, for cycles that arent the last payment cycle, amount owed is (current cycle amount + amount unpaid from previous cycles) )\n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid medium\n> This is a valid issue where it gives an incorrect amount during the last payment cycle. \n> Sponsor comment:\n> > is most certainly a valid issue, there is a fix .  The issue is if a user makes all their payments normally and on time, then in the last payment cycle, their amount owed fluctutes over time however the intent is that in the last payment cycle the amount owed should be  'the entire remaining balance' . Not fluctuating over time.  (the time fluctuation is because of code that, for cycles that arent the last payment cycle, amount owed is (current cycle amount + amount unpaid from previous cycles) )\n> \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n**ethereumdegen**\n\nPR fix: https://github.com/teller-protocol/teller-protocol-v2/pull/99\n\n**IAm0x52**\n\nFix looks good. owedAmount calculation has been slightly modified so that it will won't final payment amount by owedTime which will result in a complete repayment of the principal \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/62",
  "Code": [
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/CollateralManager.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\n// Interfaces\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"./interfaces/ICollateralManager.sol\";\nimport { Collateral, CollateralType, ICollateralEscrowV1 } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\nimport \"./interfaces/ITellerV2.sol\";\n\ncontract CollateralManager is OwnableUpgradeable, ICollateralManager {\n    /* Storage */\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    ITellerV2 public tellerV2;\n    address private collateralEscrowBeacon; // The address of the escrow contract beacon\n    mapping(uint256 => address) public _escrows; // bidIds -> collateralEscrow\n    // bidIds -> validated collateral info\n    mapping(uint256 => CollateralInfo) internal _bidCollaterals;\n\n    /**\n     * Since collateralInfo is mapped (address assetAddress => Collateral) that means\n     * that only a single tokenId per nft per loan can be collateralized.\n     * Ex. Two bored apes cannot be used as collateral for a single loan.\n     */\n    struct CollateralInfo {\n        EnumerableSetUpgradeable.AddressSet collateralAddresses;\n        mapping(address => Collateral) collateralInfo;\n    }\n\n    /* Events */\n    event CollateralEscrowDeployed(uint256 _bidId, address _collateralEscrow);\n    event CollateralCommitted(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n    event CollateralClaimed(uint256 _bidId);\n    event CollateralDeposited(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n    event CollateralWithdrawn(\n        uint256 _bidId,\n        CollateralType _type,\n        address _collateralAddress,\n        uint256 _amount,\n        uint256 _tokenId,\n        address _recipient\n    );\n\n    /* Modifiers */\n    modifier onlyTellerV2() {\n        require(_msgSender() == address(tellerV2), \"Sender not authorized\");\n        _;\n    }\n\n    /* External Functions */\n\n    /**\n     * @notice Initializes the collateral manager.\n     * @param _collateralEscrowBeacon The address of the escrow implementation.\n     * @param _tellerV2 The address of the protocol.\n     */\n    function initialize(address _collateralEscrowBeacon, address _tellerV2)\n        external\n        initializer\n    {\n        collateralEscrowBeacon = _collateralEscrowBeacon;\n        tellerV2 = ITellerV2(_tellerV2);\n        __Ownable_init_unchained();\n    }\n\n    /**\n     * @notice Sets the address of the Beacon contract used for the collateral escrow contracts.\n     * @param _collateralEscrowBeacon The address of the Beacon contract.\n     */\n    function setCollateralEscrowBeacon(address _collateralEscrowBeacon)\n        external\n        reinitializer(2)\n    {\n        collateralEscrowBeacon = _collateralEscrowBeacon;\n    }\n\n    /**\n     * @notice Checks to see if a bid is backed by collateral.\n     * @param _bidId The id of the bid to check.\n     */\n\n    function isBidCollateralBacked(uint256 _bidId)\n        public\n        virtual\n        returns (bool)\n    {\n        return _bidCollaterals[_bidId].collateralAddresses.length() > 0;\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral assets.\n     * @return validation_ Boolean indicating if the collateral balances were validated.\n     */\n    function commitCollateral(\n        uint256 _bidId,\n        Collateral[] calldata _collateralInfo\n    ) public returns (bool validation_) {\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        (validation_, ) = checkBalances(borrower, _collateralInfo);\n\n        if (validation_) {\n            for (uint256 i; i < _collateralInfo.length; i++) {\n                Collateral memory info = _collateralInfo[i];\n                _commitCollateral(_bidId, info);\n            }\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's collateral balance and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral asset.\n     * @return validation_ Boolean indicating if the collateral balance was validated.\n     */\n    function commitCollateral(\n        uint256 _bidId,\n        Collateral calldata _collateralInfo\n    ) public returns (bool validation_) {\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        validation_ = _checkBalance(borrower, _collateralInfo);\n        if (validation_) {\n            _commitCollateral(_bidId, _collateralInfo);\n        }\n    }\n\n    /**\n     * @notice Re-checks the validity of a borrower's collateral balance committed to a bid.\n     * @param _bidId The id of the associated bid.\n     * @return validation_ Boolean indicating if the collateral balance was validated.\n     */\n    function revalidateCollateral(uint256 _bidId)\n        external\n        returns (bool validation_)\n    {\n        Collateral[] memory collateralInfos = getCollateralInfo(_bidId);\n        address borrower = tellerV2.getLoanBorrower(_bidId);\n        (validation_, ) = _checkBalances(borrower, collateralInfos, true);\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral assets.\n     */\n    function checkBalances(\n        address _borrowerAddress,\n        Collateral[] calldata _collateralInfo\n    ) public returns (bool validated_, bool[] memory checks_) {\n        return _checkBalances(_borrowerAddress, _collateralInfo, false);\n    }\n\n    /**\n     * @notice Deploys a new collateral escrow and deposits collateral.\n     * @param _bidId The associated bidId of the collateral escrow.\n     */\n    function deployAndDeposit(uint256 _bidId) external onlyTellerV2 {\n        if (isBidCollateralBacked(_bidId)) {\n            (address proxyAddress, ) = _deployEscrow(_bidId);\n            _escrows[_bidId] = proxyAddress;\n\n            for (\n                uint256 i;\n                i < _bidCollaterals[_bidId].collateralAddresses.length();\n                i++\n            ) {\n                _deposit(\n                    _bidId,\n                    _bidCollaterals[_bidId].collateralInfo[\n                        _bidCollaterals[_bidId].collateralAddresses.at(i)\n                    ]\n                );\n            }\n\n            emit CollateralEscrowDeployed(_bidId, proxyAddress);\n        }\n    }\n\n    /**\n     * @notice Gets the address of a deployed escrow.\n     * @notice _bidId The bidId to return the escrow for.\n     * @return The address of the escrow.\n     */\n    function getEscrow(uint256 _bidId) external view returns (address) {\n        return _escrows[_bidId];\n    }\n\n    /**\n     * @notice Gets the collateral info for a given bid id.\n     * @param _bidId The bidId to return the collateral info for.\n     * @return infos_ The stored collateral info.\n     */\n    function getCollateralInfo(uint256 _bidId)\n        public\n        view\n        returns (Collateral[] memory infos_)\n    {\n        CollateralInfo storage collateral = _bidCollaterals[_bidId];\n        address[] memory collateralAddresses = collateral\n            .collateralAddresses\n            .values();\n        infos_ = new Collateral[](collateralAddresses.length);\n        for (uint256 i; i < collateralAddresses.length; i++) {\n            infos_[i] = collateral.collateralInfo[collateralAddresses[i]];\n        }\n    }\n\n    /**\n     * @notice Gets the collateral asset amount for a given bid id on the TellerV2 contract.\n     * @param _bidId The ID of a bid on TellerV2.\n     * @param _collateralAddress An address used as collateral.\n     * @return amount_ The amount of collateral of type _collateralAddress.\n     */\n    function getCollateralAmount(uint256 _bidId, address _collateralAddress)\n        public\n        view\n        returns (uint256 amount_)\n    {\n        amount_ = _bidCollaterals[_bidId]\n            .collateralInfo[_collateralAddress]\n            ._amount;\n    }\n\n    /**\n     * @notice Withdraws deposited collateral from the created escrow of a bid that has been successfully repaid.\n     * @param _bidId The id of the bid to withdraw collateral for.\n     */\n    function withdraw(uint256 _bidId) external {\n        BidState bidState = tellerV2.getBidState(_bidId);\n        if (bidState == BidState.PAID) {\n            _withdraw(_bidId, tellerV2.getLoanBorrower(_bidId));\n        } else if (tellerV2.isLoanDefaulted(_bidId)) {\n            _withdraw(_bidId, tellerV2.getLoanLender(_bidId));\n            emit CollateralClaimed(_bidId);\n        } else {\n            revert(\"collateral cannot be withdrawn\");\n        }\n    }\n\n    /**\n     * @notice Sends the deposited collateral to a liquidator of a bid.\n     * @notice Can only be called by the protocol.\n     * @param _bidId The id of the liquidated bid.\n     * @param _liquidatorAddress The address of the liquidator to send the collateral to.\n     */\n    function liquidateCollateral(uint256 _bidId, address _liquidatorAddress)\n        external\n        onlyTellerV2\n    {\n        if (isBidCollateralBacked(_bidId)) {\n            BidState bidState = tellerV2.getBidState(_bidId);\n            require(\n                bidState == BidState.LIQUIDATED,\n                \"Loan has not been liquidated\"\n            );\n            _withdraw(_bidId, _liquidatorAddress);\n        }\n    }\n\n    /* Internal Functions */\n\n    /**\n     * @notice Deploys a new collateral escrow.\n     * @param _bidId The associated bidId of the collateral escrow.\n     */\n    function _deployEscrow(uint256 _bidId)\n        internal\n        virtual\n        returns (address proxyAddress_, address borrower_)\n    {\n        proxyAddress_ = _escrows[_bidId];\n        // Get bid info\n        borrower_ = tellerV2.getLoanBorrower(_bidId);\n        if (proxyAddress_ == address(0)) {\n            require(borrower_ != address(0), \"Bid does not exist\");\n\n            BeaconProxy proxy = new BeaconProxy(\n                collateralEscrowBeacon,\n                abi.encodeWithSelector(\n                    ICollateralEscrowV1.initialize.selector,\n                    _bidId\n                )\n            );\n            proxyAddress_ = address(proxy);\n        }\n    }\n\n    /*\n        * @notice Deploys a new collateral escrow contract. Deposits collateral into a collateral escrow.\n        * @param _bidId The associated bidId of the collateral escrow.\n        * @param collateralInfo The collateral info to deposit.\n\n    */\n    function _deposit(uint256 _bidId, Collateral memory collateralInfo)\n        internal\n        virtual\n    {\n        require(collateralInfo._amount > 0, \"Collateral not validated\");\n        (address escrowAddress, address borrower) = _deployEscrow(_bidId);\n        ICollateralEscrowV1 collateralEscrow = ICollateralEscrowV1(\n            escrowAddress\n        );\n        // Pull collateral from borrower & deposit into escrow\n        if (collateralInfo._collateralType == CollateralType.ERC20) {\n            IERC20Upgradeable(collateralInfo._collateralAddress).transferFrom(\n                borrower,\n                address(this),\n                collateralInfo._amount\n            );\n            IERC20Upgradeable(collateralInfo._collateralAddress).approve(\n                escrowAddress,\n                collateralInfo._amount\n            );\n            collateralEscrow.depositAsset(\n                CollateralType.ERC20,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                0\n            );\n        } else if (collateralInfo._collateralType == CollateralType.ERC721) {\n            IERC721Upgradeable(collateralInfo._collateralAddress).transferFrom(\n                borrower,\n                address(this),\n                collateralInfo._tokenId\n            );\n            IERC721Upgradeable(collateralInfo._collateralAddress).approve(\n                escrowAddress,\n                collateralInfo._tokenId\n            );\n            collateralEscrow.depositAsset(\n                CollateralType.ERC721,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                collateralInfo._tokenId\n            );\n        } else if (collateralInfo._collateralType == CollateralType.ERC1155) {\n            bytes memory data;\n            IERC1155Upgradeable(collateralInfo._collateralAddress)\n                .safeTransferFrom(\n                    borrower,\n                    address(this),\n                    collateralInfo._tokenId,\n                    collateralInfo._amount,\n                    data\n                );\n            IERC1155Upgradeable(collateralInfo._collateralAddress)\n                .setApprovalForAll(escrowAddress, true);\n            collateralEscrow.depositAsset(\n                CollateralType.ERC1155,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                collateralInfo._tokenId\n            );\n        } else {\n            revert(\"Unexpected collateral type\");\n        }\n        emit CollateralDeposited(\n            _bidId,\n            collateralInfo._collateralType,\n            collateralInfo._collateralAddress,\n            collateralInfo._amount,\n            collateralInfo._tokenId\n        );\n    }\n\n    /**\n     * @notice Withdraws collateral to a given receiver's address.\n     * @param _bidId The id of the bid to withdraw collateral for.\n     * @param _receiver The address to withdraw the collateral to.\n     */\n    function _withdraw(uint256 _bidId, address _receiver) internal virtual {\n        for (\n            uint256 i;\n            i < _bidCollaterals[_bidId].collateralAddresses.length();\n            i++\n        ) {\n            // Get collateral info\n            Collateral storage collateralInfo = _bidCollaterals[_bidId]\n                .collateralInfo[\n                    _bidCollaterals[_bidId].collateralAddresses.at(i)\n                ];\n            // Withdraw collateral from escrow and send it to bid lender\n            ICollateralEscrowV1(_escrows[_bidId]).withdraw(\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                _receiver\n            );\n            emit CollateralWithdrawn(\n                _bidId,\n                collateralInfo._collateralType,\n                collateralInfo._collateralAddress,\n                collateralInfo._amount,\n                collateralInfo._tokenId,\n                _receiver\n            );\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's collateral balance and commits it to a bid.\n     * @param _bidId The id of the associated bid.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function _commitCollateral(\n        uint256 _bidId,\n        Collateral memory _collateralInfo\n    ) internal virtual {\n        CollateralInfo storage collateral = _bidCollaterals[_bidId];\n        collateral.collateralAddresses.add(_collateralInfo._collateralAddress);\n        collateral.collateralInfo[\n            _collateralInfo._collateralAddress\n        ] = _collateralInfo;\n        emit CollateralCommitted(\n            _bidId,\n            _collateralInfo._collateralType,\n            _collateralInfo._collateralAddress,\n            _collateralInfo._amount,\n            _collateralInfo._tokenId\n        );\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's multiple collateral balances.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral assets.\n     * @param _shortCircut  if true, will return immediately until an invalid balance\n     */\n    function _checkBalances(\n        address _borrowerAddress,\n        Collateral[] memory _collateralInfo,\n        bool _shortCircut\n    ) internal virtual returns (bool validated_, bool[] memory checks_) {\n        checks_ = new bool[](_collateralInfo.length);\n        validated_ = true;\n        for (uint256 i; i < _collateralInfo.length; i++) {\n            bool isValidated = _checkBalance(\n                _borrowerAddress,\n                _collateralInfo[i]\n            );\n            checks_[i] = isValidated;\n            if (!isValidated) {\n                validated_ = false;\n                if (_shortCircut) {\n                    return (validated_, checks_);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Checks the validity of a borrower's single collateral balance.\n     * @param _borrowerAddress The address of the borrower holding the collateral.\n     * @param _collateralInfo Additional information about the collateral asset.\n     * @return validation_ Boolean indicating if the collateral balances were validated.\n     */\n    function _checkBalance(\n        address _borrowerAddress,\n        Collateral memory _collateralInfo\n    ) internal virtual returns (bool) {\n        CollateralType collateralType = _collateralInfo._collateralType;\n\n        if (collateralType == CollateralType.ERC20) {\n            return\n                _collateralInfo._amount <=\n                IERC20Upgradeable(_collateralInfo._collateralAddress).balanceOf(\n                    _borrowerAddress\n                );\n        } else if (collateralType == CollateralType.ERC721) {\n            return\n                _borrowerAddress ==\n                IERC721Upgradeable(_collateralInfo._collateralAddress).ownerOf(\n                    _collateralInfo._tokenId\n                );\n        } else if (collateralType == CollateralType.ERC1155) {\n            return\n                _collateralInfo._amount <=\n                IERC1155Upgradeable(_collateralInfo._collateralAddress)\n                    .balanceOf(_borrowerAddress, _collateralInfo._tokenId);\n        } else {\n            return false;\n        }\n    }\n\n    // On NFT Received handlers\n\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return\n            bytes4(\n                keccak256(\"onERC721Received(address,address,uint256,bytes)\")\n            );\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256 id,\n        uint256 value,\n        bytes calldata\n    ) external returns (bytes4) {\n        return\n            bytes4(\n                keccak256(\n                    \"onERC1155Received(address,address,uint256,uint256,bytes)\"\n                )\n            );\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata\n    ) external returns (bytes4) {\n        require(\n            _ids.length == 1,\n            \"Only allowed one asset batch transfer per transaction.\"\n        );\n        return\n            bytes4(\n                keccak256(\n                    \"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"\n                )\n            );\n    }\n}"
    },
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/libraries/V2Calculations.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n\n// SPDX-License-Identifier: MIT\n\n// Libraries\nimport \"./NumbersLib.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Bid } from \"../TellerV2Storage.sol\";\n\nenum PaymentType {\n    EMI,\n    Bullet\n}\n\nenum PaymentCycleType {\n    Seconds,\n    Monthly\n}\n\nlibrary V2Calculations {\n    using NumbersLib for uint256;\n\n    /**\n     * @notice Returns the timestamp of the last payment made for a loan.\n     * @param _bid The loan bid struct to get the timestamp for.\n     */\n    function lastRepaidTimestamp(Bid storage _bid)\n        internal\n        view\n        returns (uint32)\n    {\n        return\n            _bid.loanDetails.lastRepaidTimestamp == 0\n                ? _bid.loanDetails.acceptedTimestamp\n                : _bid.loanDetails.lastRepaidTimestamp;\n    }\n\n    /**\n     * @notice Calculates the amount owed for a loan.\n     * @param _bid The loan bid struct to get the owed amount for.\n     * @param _timestamp The timestamp at which to get the owed amount at.\n     * @param _paymentCycleType The payment cycle type of the loan (Seconds or Monthly).\n     */\n    function calculateAmountOwed(\n        Bid storage _bid,\n        uint256 _timestamp,\n        PaymentCycleType _paymentCycleType\n    )\n        internal\n        view\n        returns (\n            uint256 owedPrincipal_,\n            uint256 duePrincipal_,\n            uint256 interest_\n        )\n    {\n        // Total principal left to pay\n        return\n            calculateAmountOwed(\n                _bid,\n                lastRepaidTimestamp(_bid),\n                _timestamp,\n                _paymentCycleType\n            );\n    }\n\n    function calculateAmountOwed(\n        Bid storage _bid,\n        uint256 _lastRepaidTimestamp,\n        uint256 _timestamp,\n        PaymentCycleType _paymentCycleType\n    )\n        internal\n        view\n        returns (\n            uint256 owedPrincipal_,\n            uint256 duePrincipal_,\n            uint256 interest_\n        )\n    {\n        owedPrincipal_ =\n            _bid.loanDetails.principal -\n            _bid.loanDetails.totalRepaid.principal;\n\n        uint256 daysInYear = _paymentCycleType == PaymentCycleType.Monthly\n            ? 360 days\n            : 365 days;\n\n        uint256 interestOwedInAYear = owedPrincipal_.percent(_bid.terms.APR);\n        uint256 owedTime = _timestamp - uint256(_lastRepaidTimestamp);\n        interest_ = (interestOwedInAYear * owedTime) / daysInYear;\n\n        // Cast to int265 to avoid underflow errors (negative means loan duration has passed)\n        int256 durationLeftOnLoan = int256(\n            uint256(_bid.loanDetails.loanDuration)\n        ) -\n            (int256(_timestamp) -\n                int256(uint256(_bid.loanDetails.acceptedTimestamp)));\n        bool isLastPaymentCycle = durationLeftOnLoan <\n            int256(uint256(_bid.terms.paymentCycle)) || // Check if current payment cycle is within or beyond the last one\n            owedPrincipal_ + interest_ <= _bid.terms.paymentCycleAmount; // Check if what is left to pay is less than the payment cycle amount\n\n        if (_bid.paymentType == PaymentType.Bullet) {\n            if (isLastPaymentCycle) {\n                duePrincipal_ = owedPrincipal_;\n            }\n        } else {\n            // Default to PaymentType.EMI\n            // Max payable amount in a cycle\n            // NOTE: the last cycle could have less than the calculated payment amount\n            uint256 maxCycleOwed = isLastPaymentCycle\n                ? owedPrincipal_ + interest_\n                : _bid.terms.paymentCycleAmount;\n\n            // Calculate accrued amount due since last repayment\n            uint256 owedAmount = (maxCycleOwed * owedTime) /\n                _bid.terms.paymentCycle;\n            duePrincipal_ = Math.min(owedAmount - interest_, owedPrincipal_);\n        }\n    }\n\n    /**\n     * @notice Calculates the amount owed for a loan for the next payment cycle.\n     * @param _type The payment type of the loan.\n     * @param _cycleType The cycle type set for the loan. (Seconds or Monthly)\n     * @param _principal The starting amount that is owed on the loan.\n     * @param _duration The length of the loan.\n     * @param _paymentCycle The length of the loan's payment cycle.\n     * @param _apr The annual percentage rate of the loan.\n     */\n    function calculatePaymentCycleAmount(\n        PaymentType _type,\n        PaymentCycleType _cycleType,\n        uint256 _principal,\n        uint32 _duration,\n        uint32 _paymentCycle,\n        uint16 _apr\n    ) internal returns (uint256) {\n        uint256 daysInYear = _cycleType == PaymentCycleType.Monthly\n            ? 360 days\n            : 365 days;\n        if (_type == PaymentType.Bullet) {\n            return\n                _principal.percent(_apr).percent(\n                    uint256(_paymentCycle).ratioOf(daysInYear, 10),\n                    10\n                );\n        }\n        // Default to PaymentType.EMI\n        return\n            NumbersLib.pmt(\n                _principal,\n                _duration,\n                _paymentCycle,\n                _apr,\n                daysInYear\n            );\n    }\n}"
    },
    {
      "filename": "teller-protocol-v2/packages/contracts/contracts/TellerV2.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./ProtocolFee.sol\";\nimport \"./TellerV2Storage.sol\";\nimport \"./TellerV2Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\nimport { Collateral } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/NumbersLib.sol\";\nimport { BokkyPooBahsDateTimeLibrary as BPBDTL } from \"./libraries/DateTimeLib.sol\";\nimport { V2Calculations, PaymentCycleType } from \"./libraries/V2Calculations.sol\";\n\n/* Errors */\n/**\n * @notice This error is reverted when the action isn't allowed\n * @param bidId The id of the bid.\n * @param action The action string (i.e: 'repayLoan', 'cancelBid', 'etc)\n * @param message The message string to return to the user explaining why the tx was reverted\n */\nerror ActionNotAllowed(uint256 bidId, string action, string message);\n\n/**\n * @notice This error is reverted when repayment amount is less than the required minimum\n * @param bidId The id of the bid the borrower is attempting to repay.\n * @param payment The payment made by the borrower\n * @param minimumOwed The minimum owed value\n */\nerror PaymentNotMinimum(uint256 bidId, uint256 payment, uint256 minimumOwed);\n\ncontract TellerV2 is\n    ITellerV2,\n    OwnableUpgradeable,\n    ProtocolFee,\n    PausableUpgradeable,\n    TellerV2Storage,\n    TellerV2Context\n{\n    using Address for address;\n    using SafeERC20 for ERC20;\n    using NumbersLib for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /** Events */\n\n    /**\n     * @notice This event is emitted when a new bid is submitted.\n     * @param bidId The id of the bid submitted.\n     * @param borrower The address of the bid borrower.\n     * @param metadataURI URI for additional bid information as part of loan bid.\n     */\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    /**\n     * @notice This event is emitted when a bid has been accepted by a lender.\n     * @param bidId The id of the bid accepted.\n     * @param lender The address of the accepted bid lender.\n     */\n    event AcceptedBid(uint256 indexed bidId, address indexed lender);\n\n    /**\n     * @notice This event is emitted when a previously submitted bid has been cancelled.\n     * @param bidId The id of the cancelled bid.\n     */\n    event CancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when market owner has cancelled a pending bid in their market.\n     * @param bidId The id of the bid funded.\n     *\n     * Note: The `CancelledBid` event will also be emitted.\n     */\n    event MarketOwnerCancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a payment is made towards an active loan.\n     * @param bidId The id of the bid/loan to which the payment was made.\n     */\n    event LoanRepayment(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanRepaid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanLiquidated(uint256 indexed bidId, address indexed liquidator);\n\n    /**\n     * @notice This event is emitted when a fee has been paid related to a bid.\n     * @param bidId The id of the bid.\n     * @param feeType The name of the fee being paid.\n     * @param amount The amount of the fee being paid.\n     */\n    event FeePaid(\n        uint256 indexed bidId,\n        string indexed feeType,\n        uint256 indexed amount\n    );\n\n    /** Modifiers */\n\n    /**\n     * @notice This modifier is used to check if the state of a bid is pending, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier pendingBid(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.PENDING) {\n            revert ActionNotAllowed(_bidId, _action, \"Bid must be pending\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to check if the state of a loan has been accepted, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier acceptedLoan(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.ACCEPTED) {\n            revert ActionNotAllowed(_bidId, _action, \"Loan must be accepted\");\n        }\n\n        _;\n    }\n\n    /** Constant Variables **/\n\n    uint8 public constant CURRENT_CODE_VERSION = 9;\n\n    uint32 public constant LIQUIDATION_DELAY = 86400; //ONE DAY IN SECONDS\n\n    /** Constructor **/\n\n    constructor(address trustedForwarder) TellerV2Context(trustedForwarder) {}\n\n    /** External Functions **/\n\n    /**\n     * @notice Initializes the proxy.\n     * @param _protocolFee The fee collected by the protocol for loan processing.\n     * @param _marketRegistry The address of the market registry contract for the protocol.\n     * @param _reputationManager The address of the reputation manager contract.\n     * @param _lenderCommitmentForwarder The address of the lender commitment forwarder contract.\n     * @param _collateralManager The address of the collateral manager contracts.\n     * @param _lenderManager The address of the lender manager contract for loans on the protocol.\n     */\n    function initialize(\n        uint16 _protocolFee,\n        address _marketRegistry,\n        address _reputationManager,\n        address _lenderCommitmentForwarder,\n        address _collateralManager,\n        address _lenderManager\n    ) external initializer {\n        __ProtocolFee_init(_protocolFee);\n\n        __Pausable_init();\n\n        require(\n            _lenderCommitmentForwarder.isContract(),\n            \"LenderCommitmentForwarder must be a contract\"\n        );\n        lenderCommitmentForwarder = _lenderCommitmentForwarder;\n\n        require(\n            _marketRegistry.isContract(),\n            \"MarketRegistry must be a contract\"\n        );\n        marketRegistry = IMarketRegistry(_marketRegistry);\n\n        require(\n            _reputationManager.isContract(),\n            \"ReputationManager must be a contract\"\n        );\n        reputationManager = IReputationManager(_reputationManager);\n\n        require(\n            _collateralManager.isContract(),\n            \"CollateralManager must be a contract\"\n        );\n        collateralManager = ICollateralManager(_collateralManager);\n\n        _setLenderManager(_lenderManager);\n    }\n\n    function setLenderManager(address _lenderManager)\n        external\n        reinitializer(8)\n        onlyOwner\n    {\n        _setLenderManager(_lenderManager);\n    }\n\n    function _setLenderManager(address _lenderManager)\n        internal\n        onlyInitializing\n    {\n        require"
    }
  ]
}