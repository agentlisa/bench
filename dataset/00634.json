{
  "Title": "H-4: Asymmetry in profit and loss (PnL) calculations",
  "Content": "# Issue H-4: Asymmetry in profit and loss (PnL) calculations \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/186 \n\n## Found by \nKingNFT, xiaoming90\n## Summary\n\nAn asymmetry arises in profit and loss (PnL) calculations due to relative price changes. This discrepancy emerges when adjustments to a position lead to differing PnL outcomes despite equivalent absolute price shifts in rETH, leading to loss of assets.\n\n## Vulnerability Detail\n\n#### Scenario 1\n\nAssume at $T0$, the price of rETH is \\$1000. Bob opened a long position with the following state:\n\n- Position Size = 40 ETH\n- Margin = $x$ ETH\n\nAt $T2$, the price of rETH increased to \\$2000. Thus, Bob's PnL is as follows: he gains 20 rETH.\n\n```solidity\nPnL = Position Size * Price Shift / Current Price\nPnL = Position Size * (Current Price - Last Price) / Current Price\nPnL = 40 rETH * ($2000 - $1000) / $2000\nPnL = $40000 / $2000 = 20 rETH\n```\n\nImportant Note: In terms of dollars, each ETH earns \\$1000. Since the position held 40 ETH, the position gained \\$40000.\n\n#### Scenario 2\n\nAssume at $T0$, the price of rETH is \\$1000. Bob opened a long position with the following state:\n\n- Position Size = 40 ETH\n- Margin = $x$ ETH\n\nAt $T1$, the price of rETH dropped to \\$500. An adjustment is executed against Bob's long position, and a `newMargin` is computed to account for the PnL accrued till now, as shown in Line 191 below. Thus, Bob's PnL is as follows: he lost 40 rETH.\n\n```solidity\nPnL = Position Size * Price Shift / Current Price\nPnL = Position Size * (Current Price - Last Price) / Current Price\nPnL = 40 rETH * ($500 - $1000) / $500\nPnL = -$20000 / $500 = -40 rETH\n```\n\nAt this point, the position's `marginDeposited` will be $(x - 40)\\ rETH$ and `lastPrice` set to \\$500.\n\nImportant Note 1: In terms of dollars, each ETH lost $500. Since the position held 40 ETH, the position lost \\$20000\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LeverageModule.sol#L211\n\n```solidity\nFile: LeverageModule.sol\n190:         // This accounts for the profit loss and funding fees accrued till now.\n191:         uint256 newMargin = (marginAdjustment +\n192:             PerpMath\n193:                 ._getPositionSummary({position: position, nextFundingEntry: cumulativeFunding, price: adjustPrice})\n194:                 .marginAfterSettlement).toUint256();\n..SNIP..\n211:         vault.setPosition(\n212:             FlatcoinStructs.Position({\n213:                 lastPrice: adjustPrice,\n214:                 marginDeposited: newMargin,\n215:                 additionalSize: newAdditionalSize,\n216:                 entryCumulativeFunding: cumulativeFunding\n217:             }),\n218:             announcedAdjust.tokenId\n219:         );\n```\n\nAt $T2$, the price of rETH increases from \\$500 to \\$2000. Thus, Bob's PnL is as follows:\n\n```solidity\nPnL = Position Size * Price Shift / Current Price\nPnL = Position Size * (Current Price - Last Price) / Current Price\nPnL = 40 rETH * ($2000 - $500) / $500\nPnL = $60000 / $2000 = 30 rETH\n```\n\nAt this point, the position's `marginDeposited` will be $(x - 40 + 30)\\ rETH$, which is equal to $(x - 10)\\ rETH$. This effectively means that Bob has lost 10 rETH of the total margin he deposited.\n\nImportant Note 2: In terms of dollars, each ETH gains $1500. Since the position held 40 ETH, the position gained \\$60000.\n\nImportant Note 3: If we add up the loss of \\$20000 at ùëá1 and the gain of \\$60000 at ùëá2, the overall PnL is a gain of \\$40000 at the end.\n\n#### Analysis\n\nThe final PnL of a position should be equivalent regardless of the number of adjustments/position updates made between $T0$ and $T2$. However, the current implementation does not conform to this property. Bob gains 20 rETH in the first scenario, while Bob loses 10 rETH in the second scenario. \n\nThere are several reasons that lead to this issue:\n\n- The PnL calculation emphasizes relative price changes (percentage) rather than absolute price changes (dollar value). This leads to asymmetric rETH outcomes for the same absolute dollar gains/losses. If we have used the dollar to compute the PnL, both scenarios will return the same correct result, with a gain of $40000 at the end, as shown in the examples above. (Refer to the important note above)\n- The formula for PnL calculation is sensitive to the proportion of the price change relative to the current price. This causes the rETH gains/losses to be non-linear even when the absolute dollar gains/losses are the same.\n\n#### Extra Example\n\nThe current approach to computing the PnL will also cause issues in another area besides the one shown above. The following example aims to demonstrate that it can cause a desync between the PnL accumulated by the global positions AND the PnL of all the individual open positions in the system.\n\nThe following shows the two open positions owned by Alice and Bob. The current price of ETH is \\$1000 and the current time is $T0$\n\n| Alice's Long Position                             | Bob's Long Position                              |\n| ------------------------------------------------- | ------------------------------------------------ |\n| Position Size = 100 ETH<br />Entry Price = \\$1000 | Position Size = 50 ETH<br />Entry Price = \\$1000 |\n\nAt $T1$, the price of ETH drops from \\$1000 to $750, and the `updateGlobalPositionData` function is executed. The `profitLossTotal` is computed as below. Thus, the `marginDepositedTotal` decreased by 50 ETH.\n\n```solidity\npriceShift = $750 - $1000 = -$250\nprofitLossTotal = (globalPosition.sizeOpenedTotal * priceShift) / price\nprofitLossTotal = (150 ETH * -$250) / $750 = -50 ETH\n```\n\nAt $T2$, the price of ETH drops from \\$750 to \\$500, and the `updateGlobalPositionData` function is executed. The `profitLossTotal` is computed as below. Thus, the `marginDepositedTotal` decreased by 75 ETH.\n\n```solidity\npriceShift = $500 - $750 = -$250\nprofitLossTotal = (globalPosition.sizeOpenedTotal * priceShift) / price\nprofitLossTotal = (150 ETH * -$250) / $500 = -75 ETH\n```\n\nIn total, the `marginDepositedTotal` decreased by 125 ETH (50 + 75), which means that the long traders lost 125 ETH from $T0$ to $T2$.\n\nHowever, when we compute the loss of Alice and Bob's positions at $T2$, they lost a total of 150 ETH, which deviated from the loss of 125 ETH in the global position data.\n\n```solidity\nAlice's PNL\npriceShift = current price - entry price = $500 - $1000 = -$500\nPnL = (position size * priceShift) / current price\nPnL = (100 ETH * -$500) / $500 = -100 ETH\n\nBob's PNL\npriceShift = current price - entry price = $500 - $1000 = -$500\nPnL = (position size * priceShift) / current price\nPnL = (50 ETH * -$500) / $500 = -50 ETH\n```\n\n## Impact\n\nLoss of assets, as demonstrated in the second scenario in the first example above. The tracking of profit and loss, which is the key component within the protocol, both on the position level and global level, is broken.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LeverageModule.sol#L211\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider tracking the PnL in dollar value/term to ensure consistency between the rETH and dollar representations of gains and losses.\n\n#### Appendix\n\nCompared to SNX V2, it is not vulnerable to this issue. The reason is that in SNX V2 when it computes the PnL, it does not \"scale\" down the result by the price. The PnL in SNXv2 is simply computed in dollar value ($positionSize \\times priceShift$), while FlatCoin protocol computes in collateral (rETH) term ($\\frac{positionSize \\times priceShift}{price}$).\n\nhttps://github.com/Synthetixio/synthetix/blob/1cfafd30deb4511cf885b4bc3cc4e9c970356800/contracts/PerpsV2MarketBase.sol#L261\n\n```solidity\nfunction _profitLoss(Position memory position, uint price) internal pure returns (int pnl) {\n    int priceShift = int(price).sub(int(position.lastPrice));\n    return int(position.size).multiplyDecimal(priceShift);\n}\n```\n\nhttps://github.com/Synthetixio/synthetix/blob/1cfafd30deb4511cf885b4bc3cc4e9c970356800/contracts/PerpsV2MarketBase.sol#L278\n\n```solidity\n/*\n * The initial margin of a position, plus any PnL and funding it has accrued. The resulting value may be negative.\n */\nfunction _marginPlusProfitFunding(Position memory position, uint price) internal view returns (int) {\n    int funding = _accruedFunding(position, price);\n    return int(position.margin).add(_profitLoss(position, price)).add(funding);\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/266.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/LeverageModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {ERC721LockableEnumerableUpgradeable} from \"./misc/ERC721LockableEnumerableUpgradeable.sol\";\n\nimport {DecimalMath} from \"./libraries/DecimalMath.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LeverageModule\n/// @author dHEDGE\n/// @notice Contains functions to create/manage leverage positions.\n/// @dev This module shouldn't hold any funds but can direct the vault to transfer funds.\ncontract LeverageModule is ILeverageModule, ModuleUpgradeable, ERC721LockableEnumerableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using DecimalMath for uint256;\n\n    /// @notice ERC721 token ID increment on mint.\n    uint256 public tokenIdNext;\n\n    /// @notice Leverage trading fee. Charged for opening, adjusting or closing a position.\n    /// @dev 1e18 = 100%\n    uint256 public levTradingFee; // Fee for leverage position open/close. 1e18 = 100%\n\n    /// @notice Leverage position criteria limits\n    /// @notice A minimum margin limit adds a cost to create a position and ensures it can be liquidated at high leverage\n    uint256 public marginMin;\n\n    /// @notice Minimum leverage limit ensures that the position is valuable and adds long open interest\n    uint256 public leverageMin;\n\n    /// @notice Maximum leverage limit ensures that the position is safely liquidatable by keepers\n    uint256 public leverageMax;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _vault,\n        uint256 _levTradingFee,\n        uint256 _marginMin,\n        uint256 _leverageMin,\n        uint256 _leverageMax\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY, _vault);\n        __ERC721_init(\"Flatmoney Leveraged Positions\", \"LEV\");\n\n        setLevTradingFee(_levTradingFee);\n        setLeverageCriteria(_marginMin, _leverageMin, _leverageMax);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions         //\n    /////////////////////////////////////////////\n\n    /// @notice Leverage open function. Mints ERC721 token receipt.\n    /// @dev Has to be used in conjunction with the DelayedOrder module.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param _account The user account which has a pending open leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    /// @return _newTokenId The ERC721 token ID of the new leverage position.\n    function executeOpen(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _newTokenId) {\n        // Make sure the oracle price is after the order executability time\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageOpen memory announcedOpen = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageOpen)\n        );\n\n        // Check that buy price doesn't exceed requested price.\n        (uint256 entryPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (entryPrice > announcedOpen.maxFillPrice)\n            revert FlatcoinErrors.HighSlippage(entryPrice, announcedOpen.maxFillPrice);\n\n        vault.checkSkewMax({additionalSkew: announcedOpen.additionalSize});\n\n        {\n            // The margin change is equal to funding fees accrued to longs and the margin deposited by the trader.\n            vault.updateGlobalPositionData({\n                price: entryPrice,\n                marginDelta: int256(announcedOpen.margin),\n                additionalSizeDelta: int256(announcedOpen.additionalSize)\n            });\n\n            _newTokenId = _mint(_account);\n\n            vault.setPosition(\n                FlatcoinStructs.Position({\n                    lastPrice: entryPrice,\n                    marginDeposited: announcedOpen.margin,\n                    additionalSize: announcedOpen.additionalSize,\n                    entryCumulativeFunding: vault.cumulativeFundingRate()\n                }),\n                _newTokenId\n            );\n        }\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).canLiquidate(\n                _newTokenId\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintLeverageOpen(_account, announcedOpen.additionalSize);\n\n        // Settle the collateral\n        vault.updateStableCollateralTotal(int256(announcedOpen.tradeFee)); // pay the trade fee to stable LPs\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee}); // pay the keeper their fee\n\n        emit FlatcoinEvents.LeverageOpen(_account, _newTokenId);\n    }\n\n    /// @notice Leverage adjust function.\n    /// @dev Needs to be used in conjunction with the DelayedOrder module.\n    /// @param _account The user account which has a pending adjust leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    function executeAdjust(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule {\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageAdjust memory announcedAdjust = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageAdjust)\n        );\n\n        (uint256 adjustPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (announcedAdjust.additionalSizeAdjustment >= 0) {\n            // Given that the size of a position is being increased, it's necessary to check that\n            // it doesn't exceed the max skew limit.\n            vault.checkSkewMax(uint256(announcedAdjust.additionalSizeAdjustment));\n\n            if (adjustPrice > announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        } else {\n            if (adjustPrice < announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        }\n\n        FlatcoinStructs.Position memory position = vault.getPosition(announcedAdjust.tokenId);\n\n        // Fees come out from the margin if the margin is being reduced or remains unchanged (meaning the size is being modified).\n        int256 marginAdjustment = (announcedAdjust.marginAdjustment > 0)\n            ? announcedAdjust.marginAdjustment\n            : announcedAdjust.marginAdjustment - int256(announcedAdjust.totalFee);\n\n        vault.updateGlobalPositionData({\n            price: adjustPrice,\n            marginDelta: marginAdjustment,\n            additionalSizeDelta: announcedAdjust.additionalSizeAdjustment\n        });\n\n        int256 cumulativeFunding = vault.cumulativeFundingRate();\n\n        // This accounts for the profit loss and funding fees accrued till now.\n        uint256 newMargin = (marginAdjustment +\n            PerpMath\n                ._getPositionSummary({position: position, nextFundingEntry: cumulativeFunding, price: adjustPrice})\n                .marginAfterSettlement).toUint256();\n\n        uint256 newAdditionalSize = (int256(position.additionalSize) + announcedAdjust.additionalSizeAdjustment)\n            .toUint256();\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            newMargin <=\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).getLiquidationMargin(\n                newAdditionalSize,\n                adjustPrice\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Check that the leverage isn't too high.\n        checkLeverageCriteria(newMargin, newAdditionalSize);\n\n        vault.setPosition(\n            FlatcoinStructs.Position({\n                lastPrice: adjustPrice,\n                marginDeposited: newMargin,\n                additionalSize: newAdditionalSize,\n                entryCumulativeFunding: cumulativeFunding\n            }),\n            announcedAdjust.tokenId\n        );\n\n        // Unlock the position token to allow for transfers.\n        _unlock(announcedAdjust.tokenId);\n\n        // Mint points.\n        if (announcedAdjust.additionalSizeAdjustment > 0) {\n            address positionOwner = ownerOf(announcedAdjust.tokenId);\n            IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n\n            pointsModule.mintLeverageOpen(positionOwner, uint256(announcedAdjust.additionalSizeAdjustment));\n        }\n\n        if (announcedAdjust.tradeFee > 0) vault.updateStableCollateralTotal(int256(announcedAdjust.tradeFee));\n\n        // Sending keeper fee from order contract to the executor.\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee});\n\n        if (announcedAdjust.marginAdjustment < 0) {\n            // We send the user that much margin they requested during announceLeverageAdjust().\n            // However their remaining margin is reduced by the fees.\n            // It is accounted in announceLeverageAdjust().\n            uint256 marginToWithdraw = uint256(announcedAdjust.marginAdjustment * -1);\n\n            // Withdrawing margin from the vault and sending it to the user.\n            vault.sendCollateral({to: _account, amount: marginToWithdraw});\n        }\n\n        emit FlatcoinEvents.LeverageAdjust(announcedAdjust.tokenId);\n    }\n\n    /// @notice Leverage close function.\n    /// @dev Needs to be used in conjunction with the DelayedOrder module.\n    /// @param _account The user account which has a pending close leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    function executeClose(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule returns (int256 settledMargin) {\n        FlatcoinStructs.AnnouncedLeverageClose memory announcedClose = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageClose)\n        );\n        FlatcoinStructs.Position memory position = vault.getPosition(announcedClose.tokenId);\n\n        // Make sure the oracle price is after the order executability time\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        // check that sell price doesn't exceed requested price\n        (uint256 exitPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n        if (exitPrice < announcedClose.minFillPrice)\n            revert FlatcoinErrors.HighSlippage(exitPrice, announcedClose.minFillPrice);\n\n        uint256 totalFee;\n        {\n            FlatcoinStructs.PositionSummary memory positionSummary = PerpMath._getPositionSummary(\n                position,\n                vault.cumulativeFundingRate(),\n                exitPrice\n            );\n\n            settledMargin = positionSummary.marginAfterSettlement;\n            totalFee = announcedClose.tradeFee + _order.keeperFee;\n\n            if (settledMargin <= 0) revert FlatcoinErrors.ValueNotPositive(\"settledMargin\");\n            // Make sure there is enough margin in the position to pay the keeper fee\n            if (settledMargin < int256(totalFee)) revert FlatcoinErrors.NotEnoughMarginForFees(settledMargin, totalFee);\n\n            vault.updateGlobalPositionData({\n                price: exitPrice,\n                marginDelta: -settledMargin,\n                additionalSizeDelta: -int256(position.additionalSize)\n            });\n\n            // Delete position storage\n            vault.deletePosition(announcedClose.tokenId);\n        }\n\n        // Cancel any existing limit order on the position\n        ILimitOrder(vault.moduleAddress(FlatcoinModuleKeys._LIMIT_ORDER_KEY)).cancelExistingLimitOrder(\n            announcedClose.tokenId\n        );\n\n        // A position NFT has to be unlocked before burning otherwise, the transfer to address(0) will fail.\n        _unlock(announcedClose.tokenId);\n        _burn(announcedClose.tokenId);\n\n        vault.updateStableCollateralTotal(int256(announcedClose.tradeFee)); // pay the trade fee to stable LPs\n\n        // Settle the collateral.\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee}); // pay the keeper their fee\n        vault.sendCollateral({to: _account, amount: uint256(settledMargin) - totalFee}); // transfer remaining amount to the trader\n\n        emit FlatcoinEvents.LeverageClose(announcedClose.tokenId);\n    }\n\n    /// @notice Burns the ERC721 token representing the leverage position.\n    /// @param _tokenId The ERC721 token ID of the leverage position.\n    function burn(uint256 _tokenId) external onlyAuthorizedModule {\n        _burn(_tokenId);\n    }\n\n    /// @notice Locks the ERC721 token representing the leverage position.\n    /// @param _tokenId The ERC721 token ID of the leverage position.\n    function lock(uint256 _tokenId) public onlyAuthorizedModule {\n        _lock(_tokenId);\n    }\n\n    /// @notice Unlocks the ERC721 token representing the leverage position.\n    /// @param tokenId The ERC721 token ID of the leverage position.\n    function unlock(uint256 tokenId) public onlyAuthorizedModule {\n        _unlock(tokenId);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the lock status of a leverage NFT position.\n    /// @param _tokenId The ERC721 token ID of the leverage position.\n    /// @return _lockStatus The lock status of the leverage position.\n    function isLocked(uint256 _tokenId) public view override returns (bool _lockStatus) {\n        return _isLocked[_tokenId];\n    }\n\n    /// @notice Returns a summary of a leverage position.\n    /// @param _tokenId The ERC721 token ID of the leverage position.\n    /// @return _positionSummary The summary of the leverage position.\n    function getPositionSummary(\n        uint256 _tokenId\n    ) public view returns (FlatcoinStructs.PositionSummary memory _positionSummary) {\n        FlatcoinStructs.Position memory position = vault.getPosition(_tokenId);\n        FlatcoinStructs.VaultSummary memory vaultSummary = vault.getVaultSummary();\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Get the nextFundingEntry for the market.\n        int256 nextFundingEntry = PerpMath._nextFundingEntry(\n            vaultSummary,\n            vault.maxFundingVelocity(),\n            vault.maxVelocitySkew()\n        );\n\n        return PerpMath._getPositionSummary(position, nextFundingEntry, currentPrice);\n    }\n\n    /// @notice Returns a summary of the market.\n    /// @dev This includes all the parameters which are related mostly with the leverage traders.\n    /// @return _marketSummary The summary of the market.\n    function getMarketSummary() public view returns (FlatcoinStructs.MarketSummary memory _marketSummary) {\n        FlatcoinStructs.VaultSummary memory vaultSummary = vault.getVaultSummary();\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return\n            PerpMath._getMarketSummaryLongs(\n                vaultSummary,\n                vault.maxFundingVelocity(),\n                vault.maxVelocitySkew(),\n                currentPrice\n            );\n    }\n\n    /// @notice Returns the total profit and loss of all the leverage positions.\n    /// @dev Adjusts for the funding fees accrued.\n    /// @return _fundingAdjustedPnL The total profit and loss of all the leverage positions.\n    function fundingAdjustedLongPnLTotal() public view returns (int256 _fundingAdjustedPnL) {\n        return fundingAdjustedLongPnLTotal({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Returns the total profit and loss of all the leverage positions.\n    /// @dev Adjusts for the funding fees accrued.\n    /// @param _maxAge The maximum age of the oracle price to be used.\n    /// @return _fundingAdjustedPnL The total profit and loss of all the leverage positions.\n    function fundingAdjustedLongPnLTotal(uint32 _maxAge) public view returns (int256 _fundingAdjustedPnL) {\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: _maxAge\n        });\n\n        FlatcoinStructs.VaultSummary memory vaultSummary = vault.getVaultSummary();\n        FlatcoinStructs.MarketSummary memory marketSummary = PerpMath._getMarketSummaryLongs(\n            vaultSummary,\n            vault.maxFundingVelocity(),\n            vault.maxVelocitySkew(),\n            currentPrice\n        );\n\n        return marketSummary.profitLossTotalByLongs + marketSummary.accruedFundingTotalByLongs;\n    }\n\n    /// @notice Asserts that the position to be opened meets margin and size criteria.\n    /// @param _margin The margin to be deposited.\n    /// @param _size The size of the position.\n    function checkLeverageCriteria(uint256 _margin, uint256 _size) public view {\n        uint256 leverage = ((_margin + _size) * 1e18) / _margin;\n\n        if (leverage < leverageMin) revert FlatcoinErrors.LeverageTooLow(leverageMin, leverage);\n        if (leverage > leverageMax) revert FlatcoinErrors.LeverageTooHigh(leverageMax, leverage);\n        if (_margin < marginMin) revert FlatcoinErrors.MarginTooSmall(marginMin, _margin);\n    }\n\n    /// @notice Returns the trade fee for a given size.\n    /// @param _size The size of the trade.\n    /// @return _tradeFee The trade fee.\n    function getTradeFee(uint256 _size) external view returns (uint256 _tradeFee) {\n        return levTradingFee._multiplyDecimal(_size);\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Handles incrementing the tokenIdNext and minting the nft\n    /// @param _to the minter's address\n    /// @return _tokenId the tokenId of the new NFT.\n    function _mint(address _to) internal returns (uint256 _tokenId) {\n        _tokenId = tokenIdNext;\n\n        _safeMint(_to, tokenIdNext);\n\n        tokenIdNext += 1;\n    }\n\n    /// @notice Returns the maximum age of the oracle price to be used.\n    /// @param _executableAtTime The time at which the order is executable.\n    /// @return _maxAge The maximum age of the oracle price to be used.\n    function _getMaxAge(uint64 _executableAtTime) internal view returns (uint32 _maxAge) {\n        return (block.timestamp - _executableAtTime).toUint32();\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Setter for the leverage open/close fee.\n    /// @dev Fees can be set to 0 if needed.\n    /// @param _levTradingFee The new leverage trading fee.\n    function setLevTradingFee(uint256 _levTradingFee) public onlyOwner {\n        // Set fee cap to max 1%.\n        // This is to avoid fat fingering but if any change is needed, the owner needs to\n        // upgrade this module.\n        if (_levTradingFee > 0.01e18) revert FlatcoinErrors.InvalidFee(_levTradingFee);\n\n        levTradingFee = _levTradingFee;\n    }\n\n    /// @notice Setter for the leverage position criteria limits.\n    /// @dev The limits are used to ensure that the position is valuable and there is an incentive to liquidate it.\n    /// @param _marginMin The new minimum margin limit.\n    /// @param _leverageMin The new minimum leverage limit.\n    /// @param _leverageMax The new maximum leverage limit.\n    function setLeverageCriteria(uint256 _marginMin, uint256 _leverageMin, uint256 _leverageMax) public onlyOwner {\n        if (_leverageMax <= _leverageMin) revert FlatcoinErrors.InvalidLeverageCriteria();\n\n        marginMin = _marginMin;\n        leverageMin = _leverageMin;\n        leverageMax = _leverageMax;\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/LeverageModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {ERC721LockableEnumerableUpgradeable} from \"./misc/ERC721LockableEnumerableUpgradeable.sol\";\n\nimport {DecimalMath} from \"./libraries/DecimalMath.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LeverageModule\n/// @author dHEDGE\n/// @notice Contains functions to create/manage leverage positions.\n/// @dev This module shouldn't hold any funds but can direct the vault to transfer funds.\ncontract LeverageModule is ILeverageModule, ModuleUpgradeable, ERC721LockableEnumerableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using DecimalMath for uint256;\n\n    /// @notice ERC721 token ID increment on mint.\n    uint256 public tokenIdNext;\n\n    /// @notice Leverage trading fee. Charged for opening, adjusting or closing a position.\n    /// @dev 1e18 = 100%\n    uint256 public levTradingFee; // Fee for leverage position open/close. 1e18 = 100%\n\n    /// @notice Leverage position criteria limits\n    /// @notice A minimum margin limit adds a cost to create a position and ensures it can be liquidated at high leverage\n    uint256 public marginMin;\n\n    /// @notice Minimum leverage limit ensures that the position is valuable and adds long open interest\n    uint256 public leverageMin;\n\n    /// @notice Maximum leverage limit ensures that the position is safely liquidatable by keepers\n    uint256 public leverageMax;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _vault,\n        uint256 _levTradingFee,\n        uint256 _marginMin,\n        uint256 _leverageMin,\n        uint256 _leverageMax\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY, _vault);\n        __ERC721_init(\"Flatmoney Leveraged Positions\", \"LEV\");\n\n        setLevTradingFee(_levTradingFee);\n        setLeverageCriteria(_marginMin, _leverageMin, _leverageMax);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions         //\n    /////////////////////////////////////////////\n\n    /// @notice Leverage open function. Mints ERC721 token receipt.\n    /// @dev Has to be used in conjunction with the DelayedOrder module.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param _account The user account which has a pending open leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    /// @return _newTokenId The ERC721 token ID of the new leverage position.\n    function executeOpen(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _newTokenId) {\n        // Make sure the oracle price is after the order executability time\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageOpen memory announcedOpen = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageOpen)\n        );\n\n        // Check that buy price doesn't exceed requested price.\n        (uint256 entryPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (entryPrice > announcedOpen.maxFillPrice)\n            revert FlatcoinErrors.HighSlippage(entryPrice, announcedOpen.maxFillPrice);\n\n        vault.checkSkewMax({additionalSkew: announcedOpen.additionalSize});\n\n        {\n            // The margin change is equal to funding fees accrued to longs and the margin deposited by the trader.\n            vault.updateGlobalPositionData({\n                price: entryPrice,\n                marginDelta: int256(announcedOpen.margin),\n                additionalSizeDelta: int256(announcedOpen.additionalSize)\n            });\n\n            _newTokenId = _mint(_account);\n\n            vault.setPosition(\n                FlatcoinStructs.Position({\n                    lastPrice: entryPrice,\n                    marginDeposited: announcedOpen.margin,\n                    additionalSize: announcedOpen.additionalSize,\n                    entryCumulativeFunding: vault.cumulativeFundingRate()\n                }),\n                _newTokenId\n            );\n        }\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).canLiquidate(\n                _newTokenId\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintLeverageOpen(_account, announcedOpen.additionalSize);\n\n        // Settle the collateral\n        vault.updateStableCollateralTotal(int256(announcedOpen.tradeFee)); // pay the trade fee to stable LPs\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee}); // pay the keeper their fee\n\n        emit FlatcoinEvents.LeverageOpen(_account, _newTokenId);\n    }\n\n    /// @notice Leverage adjust function.\n    /// @dev Needs to be used in conjunction with the DelayedOrder module.\n    /// @param _account The user account which has a pending adjust leverage order.\n    /// @param _keeper The address of the keeper executing the order.\n    /// @param _order The order to be executed.\n    function executeAdjust(\n        address _account,\n        address _keeper,\n        FlatcoinStructs.Order calldata _order\n    ) external whenNotPaused onlyAuthorizedModule {\n        uint32 maxAge = _getMaxAge(_order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedLeverageAdjust memory announcedAdjust = abi.decode(\n            _order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageAdjust)\n        );\n\n        (uint256 adjustPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice({\n            maxAge: maxAge\n        });\n\n        if (announcedAdjust.additionalSizeAdjustment >= 0) {\n            // Given that the size of a position is being increased, it's necessary to check that\n            // it doesn't exceed the max skew limit.\n            vault.checkSkewMax(uint256(announcedAdjust.additionalSizeAdjustment));\n\n            if (adjustPrice > announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        } else {\n            if (adjustPrice < announcedAdjust.fillPrice)\n                revert FlatcoinErrors.HighSlippage(adjustPrice, announcedAdjust.fillPrice);\n        }\n\n        FlatcoinStructs.Position memory position = vault.getPosition(announcedAdjust.tokenId);\n\n        // Fees come out from the margin if the margin is being reduced or remains unchanged (meaning the size is being modified).\n        int256 marginAdjustment = (announcedAdjust.marginAdjustment > 0)\n            ? announcedAdjust.marginAdjustment\n            : announcedAdjust.marginAdjustment - int256(announcedAdjust.totalFee);\n\n        vault.updateGlobalPositionData({\n            price: adjustPrice,\n            marginDelta: marginAdjustment,\n            additionalSizeDelta: announcedAdjust.additionalSizeAdjustment\n        });\n\n        int256 cumulativeFunding = vault.cumulativeFundingRate();\n\n        // This accounts for the profit loss and funding fees accrued till now.\n        uint256 newMargin = (marginAdjustment +\n            PerpMath\n                ._getPositionSummary({position: position, nextFundingEntry: cumulativeFunding, price: adjustPrice})\n                .marginAfterSettlement).toUint256();\n\n        uint256 newAdditionalSize = (int256(position.additionalSize) + announcedAdjust.additionalSizeAdjustment)\n            .toUint256();\n\n        // Check that the new position isn't immediately liquidatable.\n        if (\n            newMargin <=\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).getLiquidationMargin(\n                newAdditionalSize,\n                adjustPrice\n            )\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        // Check that the leverage isn't too high.\n        checkLeverageCriteria(newMargin, newAdditionalSize);\n\n        vault.setPosition(\n            FlatcoinStructs.Position({\n                lastPrice: adjustPrice,\n                marginDeposited: newMargin,\n                additionalSize: newAdditionalSize,\n                entryCumulativeFunding: cumulativeFunding\n            }),\n            announcedAdjust.tokenId\n        );\n\n        // Unlock the position token to allow for transfers.\n        _unlock(announcedAdjust.tokenId);\n\n        // Mint points.\n        if (announcedAdjust.additionalSizeAdjustment > 0) {\n            address positionOwner = ownerOf(announcedAdjust.tokenId);\n            IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n\n            pointsModule.mintLeverageOpen(positionOwner, uint256(announcedAdjust.additionalSizeAdjustment));\n        }\n\n        if (announcedAdjust.tradeFee > 0) vault.updateStableCollateralTotal(int256(announcedAdjust.tradeFee));\n\n        // Sending keeper fee from order contract to the executor.\n        vault.sendCollateral({to: _keeper, amount: _order.keeperFee});\n\n        if (announcedAdjust.marginAdjustment < 0) {\n            // We send the user that much margin they requested during announceLeverageAdjust().\n            // However their remaining margin is reduced by the fees.\n            // It is accounted in announceLeverageAdjust().\n            uint256 marginToWithdraw = uint256(announcedAdjust.marginAdjustment * -1);\n\n            // Withdrawing margin from the vault and sending it to the user.\n            vault.sendCollateral({to: _account,"
    }
  ]
}