{
  "Title": "H-6: Debt write off can be prohibited by HPB depositor by continuously allocating settlement blocking dust deposits in the higher buckets",
  "Content": "# Issue H-6: Debt write off can be prohibited by HPB depositor by continuously allocating settlement blocking dust deposits in the higher buckets \n\nSource: https://github.com/sherlock-audit/2023-04-ajna-judging/issues/110 \n\n## Found by \nhyh\n## Summary\n\nHigh price bucket depositor who faces bad debt settlement can add multiple dust quote token deposits to many higher price buckets and stale settlement.\n\n## Vulnerability Detail\n\nHPB depositor have incentives to and actually can defend themselves from using their deposits in bad debt write offs by doing multiple dust quote token deposits in vast number of higher price buckets (up to and above current market price). This will stale bad debt settlement: now logic only requires amount to be positive, SettlerActions.sol#L334-L356, and it is possible to add quote token dust, Pool.sol#L146-L166, LenderActions.sol#L148-L157.\n\nThe point in doing so is that, having the deposit frozen is better then participate in a write off, which is a direct loss, as:\n\n1) other unaware depositors might come in and free the HPB depositor from liquidation debt participation, possibly taking bad debt damage,\n\n2) the HPB depositor can still bucketTake() as there is no _revertIfAuctionDebtLocked() check. As it will generate collateral instead of quote funds, it might be then retrieved by removeCollateral().\n\nWhen there is low amount of debt in liquidation, removing this dust deposits is possible, but economically not feasible: despite high price used gas cost far exceeds the profit due to quote amount being too low.\n\nWhen there is substantial amount of debt in liquidation, direct removal via removeQuoteToken() will be blocked by _revertIfAuctionDebtLocked() control, while `settle() -> settlePoolDebt()` calls will be prohibitively expensive (will go trough all the dust populated buckets) and fruitless (only dust amount will be settled), while the defending HPB depositor can simultaneously add those dust deposits back.\n\nEconomically the key point here is that incentives of the defending HPB depositor are more substantial (they will suffer principal loss on bad debt settlement) than the incentives of agents who call `settle() -> settlePoolDebt()` (they have their lower bucket deposits temporary frozen and want to free them with settling bad debt with HPB deposit).\n\n## Impact\n\nHPB depositors can effectively avoid deposit write off for bad debt settlement. I.e. in some situations when HPB depositor is a whale closely monitoring the pool and knowing that his funds are about to be used to cover a substantial amount of bad debt, the cumulative gas costs of the described strategy will be far lower than the gain of having principal funds recovered over time via `takeBucket() -> removeCollateral()`.\n\nThis will cause bad debt to pile up and stale greater share of the pool. The HPB depositor will eventually profit off from other depositors, who do not actively monitor pool state and over time participate in the bad debt settlements by placing deposits among the dust ones. This will allow the HPB depositor to obtain stable yield all this time, but off load a part of the corresponding risks.\n\nAs there is no low-probability prerequisites and the impact is a violation of system design allowing one group of users to profit off another, setting the severity to be high.\n\n## Code Snippet\n\nThere is no dust control in addQuoteToken():\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/base/Pool.sol#L146-L166\n\n```solidity\n    function addQuoteToken(\n        uint256 amount_,\n        uint256 index_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        amount_ = _roundToScale(amount_, poolState.quoteTokenScale);\n\n        uint256 newLup;\n        (bucketLP_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount: amount_,\n                index:  index_\n            })\n        );\n```\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/LenderActions.sol#L148-L157\n\n```solidity\n    function addQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        AddQuoteParams calldata params_\n    ) external returns (uint256 bucketLP_, uint256 lup_) {\n        // revert if no amount to be added\n        if (params_.amount == 0) revert InvalidAmount();\n        // revert if adding to an invalid index\n        if (params_.index == 0 || params_.index > MAX_FENWICK_INDEX) revert InvalidIndex();\n```\n\nPutting dust in lots of higher buckets will freeze the settlement as there no control over amount to operate with on every iteration, while `bucketDepth_` is limited and there is a block gas limit:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/SettlerActions.sol#L334-L356\n\n```solidity\n    function _settlePoolDebtWithDeposit(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        SettleParams memory params_,\n        Borrower memory borrower_,\n        uint256 inflator_\n    ) internal returns (uint256 remainingt0Debt_, uint256 remainingCollateral_, uint256 bucketDepth_) {\n        remainingt0Debt_     = borrower_.t0Debt;\n        remainingCollateral_ = borrower_.collateral;\n        bucketDepth_         = params_.bucketDepth;\n\n        while (bucketDepth_ != 0 && remainingt0Debt_ != 0 && remainingCollateral_ != 0) {\n            SettleLocalVars memory vars;\n\n>>          (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n            vars.hpbUnscaledDeposit    = Deposits.unscaledValueAt(deposits_, vars.index);\n            vars.unscaledDeposit       = vars.hpbUnscaledDeposit;\n            vars.price                 = _priceAt(vars.index);\n\n>>          if (vars.unscaledDeposit != 0) {\n                vars.debt              = Maths.wmul(remainingt0Debt_, inflator_);           // current debt to be settled\n                vars.maxSettleableDebt = Maths.floorWmul(remainingCollateral_, vars.price); // max debt that can be settled with existing collateral\n                vars.scaledDeposit     = Maths.wmul(vars.scale, vars.unscaledDeposit);\n```\n\n\nThe owner of such deposit can still use it for bucketTake() as there is no _revertIfAuctionDebtLocked() check there (which is ok by itself as the operation reduces the liquidation debt):\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/TakerActions.sol#L133-L164\n\n```solidity\n    function bucketTake(\n        ...\n    ) external returns (TakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n        // revert if borrower's collateral is 0\n        if (borrower.collateral == 0) revert InsufficientCollateral();\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n\n        // bucket take auction\n>>      TakeLocalVars memory vars = _takeBucket(\n            auctions_,\n            buckets_,\n            deposits_,\n            borrower,\n            BucketTakeParams({\n                borrower:        borrowerAddress_,\n                inflator:        poolState_.inflator,\n                depositTake:     depositTake_,\n                index:           index_,\n                collateralScale: collateralScale_\n            })\n        );\n```\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/TakerActions.sol#L415-L464\n\n```solidity\n    function _takeBucket(\n        ...\n    ) internal returns (TakeLocalVars memory vars_) {\n        ...\n        _rewardBucketTake(\n            auctions_,\n            deposits_,\n            buckets_,\n            liquidation,\n            params_.index,\n            params_.depositTake,\n            vars_\n        );\n```\n\nDuring _rewardBucketTake() the principal quote funds are effectively exchanged with the collateral:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/TakerActions.sol#L606-L667\n\n```solidity\n    function _rewardBucketTake(\n        ...\n    ) internal {\n\n        ...\n\n        // remove quote tokens from bucket’s deposit\n>>      Deposits.unscaledRemove(deposits_, bucketIndex_, vars.unscaledQuoteTokenAmount);\n\n        // total rewarded LP are added to the bucket LP balance\n        if (totalLPReward != 0) bucket.lps += totalLPReward;\n        // collateral is added to the bucket’s claimable collateral\n>>      bucket.collateral += vars.collateralAmount;\n```\n\nSo the HPB depositor can remove it (there is no _revertIfAuctionDebtLocked() check for collateral):\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/ERC20Pool.sol#L318-L335\n\n```solidity\n    function removeCollateral(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLP_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round the collateral amount appropriately based on token precision\n        maxAmount_ = _roundToScale(maxAmount_, _getArgUint256(COLLATERAL_SCALE));\n\n>>      (removedAmount_, redeemedLP_) = LenderActions.removeMaxCollateral(\n            buckets,\n            deposits,\n            _bucketCollateralDust(index_),\n            maxAmount_,\n            index_\n        );\n```\n\nBut this means that there is no downside in doing so, but it is a significant upside in effectively denying the bad debt settlements.\n\nI.e. the HPB depositor will place his deposit high, gain yield, and when his bucket happens to be within liquidation debt place these dust deposits to prevent settlements. Their deposit will be exchangeable to collateral on bucketTake() over a while, and it's still far better situation than taking part in debt write-off.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere might be different design approaches to limiting such a strategy. As an example, consider controlling addQuoteToken() for dust (the limit might be a pool parameter set on deployment with the corresponding explanations that it shouldn't be loo low) and/or controlling it for deposit addition to be buckets higher than current HPB when there is a liquidation debt present (this will also shield naive depositors as such deposits can be subject to write offs, which they can be unaware of, i.e. the reward-risk of such action doesn't look good, so it can be prohibited for both reasons).\n\n\n\n\n\n## Discussion\n\n**grandizzy**\n\nhttps://github.com/ajna-finance/contracts/pull/909\n\n**dmitriia**\n\nAs far as I see there still is a surface of performing such bad debt write off protection just before auction becomes clearable, say by front-running the tx that changes the state so it becomes clearable (say tx removes the last piece of collateral and `borrower.t0Debt != 0 && borrower.collateral == 0` becomes true). I.e. HPB depositor might monitor the auction and run multiple `addQuoteToken()` just before `_revertIfAuctionClearable()` starts to trigger for a big chunk of bad debt now auctioned.\n\nAlso, why can't attacker preliminary open another 'protection' deposit far from the top (to avoid liquidation debt, as its size can be small it doesn't have to be yield bearing) and use `moveQuoteToken()` to populate higher buckets with dust as described in the issue?\n\nFor this end the similar logic can be added to `moveQuoteToken()`, e.g.:\n\nhttps://github.com/ajna-finance/contracts/blob/04adfedd597ba19fd362f82d14a85a1649d87ebf/src/base/Pool.sol#L181-L187\n\n```diff\n    function moveQuoteToken(\n        uint256 maxAmount_,\n        uint256 fromIndex_,\n        uint256 toIndex_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_) {\n        _revertAfterExpiry(expiry_);\n       \n+       _revertIfAuctionClearable(auctions, loans);\n```\n\n**grandizzy**\n\n> Also, why can't attacker preliminary open another 'protection' deposit far from the top (to avoid liquidation debt, as its size can be small it doesn't have to be yield bearing) and use `moveQuoteToken()` to populate higher buckets with dust as described in the issue?\n> \n> For this end the similar logic can be added to `moveQuoteToken()`, e.g.:\n> \n> https://github.com/ajna-finance/contracts/blob/04adfedd597ba19fd362f82d14a85a1649d87ebf/src/base/Pool.sol#L181-L187\n> \n> ```diff\n>     function moveQuoteToken(\n>         uint256 maxAmount_,\n>         uint256 fromIndex_,\n>         uint256 toIndex_,\n>         uint256 expiry_\n>     ) external override nonReentrant returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_) {\n>         _revertAfterExpiry(expiry_);\n>        \n> +       _revertIfAuctionClearable(auctions, loans);\n> ```\n\nPR to add same for move quote token https://github.com/ajna-finance/contracts/pull/919\n\n**dmitriia**\n\nTo prevent the attack during ongoing auction, e.g. in the front running manner as just described, there is a good option of prohibiting the high price deposits on addition and moving:\n\nhttps://github.com/ajna-finance/contracts/blob/04adfedd597ba19fd362f82d14a85a1649d87ebf/src/base/Pool.sol#L146-L158\n\n```diff\n    function addQuoteToken(\n        uint256 amount_,\n        uint256 index_,\n        uint256 expiry_,\n        bool    revertIfBelowLup_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertAfterExpiry(expiry_);\n\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n+       _revertIfAboveHeadAuctionPrice(..., index_);\n```\n\nhttps://github.com/ajna-finance/contracts/blob/04adfedd597ba19fd362f82d14a85a1649d87ebf/src/base/Pool.sol#L180-L191\n\n```diff\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmount_,\n        uint256 fromIndex_,\n        uint256 toIndex_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, fromIndex_, poolState.inflator);\n\n+       _revertIfAboveHeadAuctionPrice(..., toIndex_);\n```\n\n`_revertIfAboveHeadAuctionPrice()` is a new control function:\n\nhttps://github.com/ajna-finance/contracts/blob/94be5c24dc448a9a0e914036450ac57b00c5ad11/src/libraries/helpers/RevertsHelper.sol#L50-L62\n\n```solidity\n    function _revertIfAboveHeadAuctionPrice(\n        ...\n        uint256 index_\n    ) view {\n        address head     = auctions_.head;\n        uint256 kickTime = auctions_.liquidations[head].kickTime;\n        ...\n        if (_auctionPrice(momp, NP, kickTime) < _priceAt(index_)) revert PriceTooHigh();\n    }\n```\n\nAs adding deposits above auction price is generally harmful for depositors (they will be a subject to immediate arbitrage), this will also shield against such uninformed user behavior. \n\n**dmitriia**\n\n> PR to add same for move quote token [ajna-finance/contracts#919](https://github.com/ajna-finance/contracts/pull/919)\n\nLooks ok\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/75",
  "Code": [
    {
      "filename": "ajna-core/src/base/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { Clone }           from '@clones/Clone.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { SafeERC20 }       from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }          from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {\n    IPool,\n    IPoolImmutables,\n    IPoolBorrowerActions,\n    IPoolLPActions,\n    IPoolLenderActions,\n    IPoolKickerActions,\n    IPoolTakerActions,\n    IPoolSettlerActions,\n    IPoolState,\n    IPoolDerivedState,\n    IERC20Token\n}                                    from '../interfaces/pool/IPool.sol';\nimport {\n    PoolState,\n    AuctionsState,\n    DepositsState,\n    LoansState,\n    InflatorState,\n    EmaState,\n    InterestState,\n    PoolBalancesState,\n    ReserveAuctionState,\n    Bucket,\n    BurnEvent,\n    Liquidation\n}                                   from '../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    SettleResult,\n    TakeResult,\n    RemoveQuoteParams,\n    MoveQuoteParams,\n    AddQuoteParams,\n    KickReserveAuctionParams\n}                                   from '../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _priceAt,\n    _roundToScale\n}                               from '../libraries/helpers/PoolHelper.sol';\nimport {\n    _revertIfAuctionDebtLocked,\n    _revertIfAuctionClearable,\n    _revertAfterExpiry\n}                               from '../libraries/helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../libraries/internal/Buckets.sol';\nimport { Deposits } from '../libraries/internal/Deposits.sol';\nimport { Loans }    from '../libraries/internal/Loans.sol';\nimport { Maths }    from '../libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from '../libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from '../libraries/external/LenderActions.sol';\nimport { LPActions }       from '../libraries/external/LPActions.sol';\nimport { KickerActions }   from '../libraries/external/KickerActions.sol';\nimport { TakerActions }    from '../libraries/external/TakerActions.sol';\nimport { PoolCommons }     from '../libraries/external/PoolCommons.sol';\n\n/**\n *  @title  Pool Contract\n *  @dev    Base contract and entrypoint for commong logic of both `ERC20` and `ERC721` pools.\n */\nabstract contract Pool is Clone, ReentrancyGuard, Multicall, IPool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /// @dev Immutable pool type arg offset.\n    uint256 internal constant POOL_TYPE          = 0;\n    /// @dev Immutable `Ajna` token address arg offset.\n    uint256 internal constant AJNA_ADDRESS       = 1;\n    /// @dev Immutable collateral token address arg offset.\n    uint256 internal constant COLLATERAL_ADDRESS = 21;\n    /// @dev Immutable quote token address arg offset.\n    uint256 internal constant QUOTE_ADDRESS      = 41;\n    /// @dev Immutable quote token scale arg offset.\n    uint256 internal constant QUOTE_SCALE        = 61;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    AuctionsState       internal auctions;\n    DepositsState       internal deposits;\n    LoansState          internal loans;\n    InflatorState       internal inflatorState;\n    EmaState            internal emaState;\n    InterestState       internal interestState;\n    PoolBalancesState   internal poolBalances;\n    ReserveAuctionState internal reserveAuction;\n\n    /// @dev deposit index -> bucket mapping\n    mapping(uint256 => Bucket) internal buckets;\n\n    bool internal isPoolInitialized;\n\n    /// @dev owner address -> new owner address -> deposit index -> allowed amount mapping\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lpAllowances;\n\n    /// @dev owner address -> transferor address -> approved flag mapping\n    mapping(address => mapping(address => bool)) public override approvedTransferors;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IPoolImmutables\n    function poolType() external pure override returns (uint8) {\n        return _getArgUint8(POOL_TYPE);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function collateralAddress() external pure override returns (address) {\n        return _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenAddress() external pure override returns (address) {\n        return _getArgAddress(QUOTE_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenScale() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /// @inheritdoc IPoolLenderActions\n    function addQuoteToken(\n        uint256 amount_,\n        uint256 index_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        amount_ = _roundToScale(amount_, poolState.quoteTokenScale);\n\n        uint256 newLup;\n        (bucketLP_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount: amount_,\n                index:  index_\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from lender to pool\n        _transferQuoteTokenFrom(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmount_,\n        uint256 fromIndex_,\n        uint256 toIndex_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, fromIndex_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            fromBucketLP_,\n            toBucketLP_,\n            movedAmount_,\n            newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            MoveQuoteParams({\n                maxAmountToMove: maxAmount_,\n                fromIndex:       fromIndex_,\n                toIndex:         toIndex_,\n                thresholdPrice:  Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function removeQuoteToken(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLP_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, index_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLP_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            RemoveQuoteParams({\n                maxAmount:      Maths.min(maxAmount_, _availableQuoteToken()),\n                index:          index_,\n                thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from pool to lender\n        _transferQuoteToken(msg.sender, removedAmount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function updateInterest() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n        _updateInterestState(poolState, Deposits.getLup(deposits, poolState.debt));\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /// @inheritdoc IPoolBorrowerActions\n    function stampLoan() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 newLup = BorrowerActions.stampLoan(\n            auctions,\n            deposits,\n            loans,\n            poolState\n        );\n\n        _updateInterestState(poolState, newLup);\n    }\n\n    /*****************************/\n    /*** Liquidation Functions ***/\n    /*****************************/\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `poolBalances.t0DebtInAuction` and `poolBalances.t0Debt` accumulators\n     *  @dev    update `t0Debt2ToCollateral` ratio, debt and collateral post action are considered 0\n     */\n    function kick(\n        address borrower_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n        KickResult memory result = KickerActions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrower_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.debt            =  Maths.wmul(result.t0PoolDebt, poolState.inflator);\n        poolState.t0Debt          =  result.t0PoolDebt;\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.debtPreAction,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0  // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          = poolState.t0Debt;\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n        // update pool interest rate state\n        _updateInterestState(poolState, result.lup);\n\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `poolBalances.t0DebtInAuction` and `poolBalances.t0Debt` accumulators\n     *  @dev    update `t0Debt2ToCollateral` ratio, debt and collateral post action are considered 0\n     */\n    function kickWithDeposit(\n        uint256 index_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auctions\n        KickResult memory result = KickerActions.kickWithDeposit(\n            auctions,\n            deposits,\n            buckets,\n            loans,\n            poolState,\n            index_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.debt            =  Maths.wmul(result.t0PoolDebt, poolState.inflator);\n        poolState.t0Debt          =  result.t0PoolDebt;\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.debtPreAction,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0 // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          = poolState.t0Debt;\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n\n        // update pool interest rate state\n        _updateInterestState(poolState, result.lup);\n\n        // transfer from kicker to pool the difference to cover bond\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    decrease kicker's `claimable` accumulator\n     *  @dev    decrease auctions `totalBondEscrowed` accumulator\n     */\n    function withdrawBonds(\n        address recipient_,\n        uint256 maxAmount_\n    ) external override nonReentrant {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n\n        // the amount to claim is constrained by the claimable balance of sender\n        // claiming escrowed bonds is not constraiend by the pool balance\n        maxAmount_ = Maths.min(maxAmount_, claimable);\n\n        // revert if no amount to claim\n        if (maxAmount_ == 0) revert InsufficientLiquidity();\n\n        // decrement total bond escrowed\n        auctions.totalBondEscrowed             -= maxAmount_;\n        auctions.kickers[msg.sender].claimable -= maxAmount_;\n\n        emit BondWithdrawn(msg.sender, recipient_, maxAmount_);\n\n        _transferQuoteToken(recipient_, maxAmount_);\n    }\n\n    /*********************************/\n    /*** Reserve Auction Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `latestBurnEpoch` counter\n     *  @dev    update `reserveAuction.latestBurnEventEpoch` and burn event `timestamp` state\n     *  @dev    === Reverts on ===\n     *  @dev    2 weeks not passed `ReserveAuctionTooSoon()`\n     *  @dev    === Emit events ===\n     *  @dev    - `KickReserveAuction`\n     */\n    function kickReserveAuction() external override nonReentrant {\n        // start a new claimable reserve auction, passing in relevant parameters such as the current pool size, debt, balance, and inflator value\n        uint256 kickerAward = KickerActions.kickReserveAuction(\n            auctions,\n            reserveAuction,\n            KickReserveAuctionParams({\n                poolSize:    Deposits.treeSum(deposits),\n                t0PoolDebt:  poolBalances.t0Debt,\n                poolBalance: _getNormalizedPoolQuoteTokenBalance(),\n                inflator:    inflatorState.inflator\n            })\n        );\n\n        // transfer kicker award to msg.sender\n        _transferQuoteToken(msg.sender, kickerAward);\n    }\n\n    /**\n     *  @inheritdoc IPoolTakerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `reserveAuction.totalAjnaBurned` accumulator\n     *  @dev    update burn event `totalInterest` and `totalBurned` accumulators\n     */\n    function takeReserves(\n        uint256 maxAmount_\n    ) external override nonReentrant returns (uint256 amount_) {\n        uint256 ajnaRequired;\n        (amount_, ajnaRequired) = TakerActions.takeReserves(\n            reserveAuction,\n            maxAmount_\n        );\n\n        // burn required number of ajna tokens to take quote from reserves\n        IERC20(_getArgAddress(AJNA_ADDRESS)).safeTransferFrom(msg.sender, address(this), ajnaRequired);\n\n        IERC20Token(_getArgAddress(AJNA_ADDRESS)).burn(ajnaRequired);\n\n        // transfer quote token to caller\n        _transferQuoteToken(msg.sender, amount_);\n    }\n\n    /*****************************/\n    /*** Transfer LP Functions ***/\n    /*****************************/\n\n    /// @inheritdoc IPoolLPActions\n    function increaseLPAllowance(\n        address spender_,\n        uint256[] calldata indexes_,\n        uint256[] calldata amounts_\n    ) external override nonReentrant {\n        LPActions.increaseLPAllowance(\n            _lpAllowances[msg.sender][spender_],\n            spender_,\n            indexes_,\n            amounts_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function decreaseLPAllowance(\n        address spender_,\n        uint256[] calldata indexes_,\n        uint256[] calldata amounts_\n    ) external override nonReentrant {\n        LPActions.decreaseLPAllowance(\n            _lpAllowances[msg.sender][spender_],\n            spender_,\n            indexes_,\n            amounts_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function revokeLPAllowance(\n        address spender_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LPActions.revokeLPAllowance(\n            _lpAllowances[msg.sender][spender_],\n            spender_,\n            indexes_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function approveLPTransferors(\n        address[] calldata transferors_\n    ) external override {\n        LPActions.approveLPTransferors(\n            approvedTransferors[msg.sender],\n            transferors_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function revokeLPTransferors(\n        address[] calldata transferors_\n    ) external override {\n        LPActions.revokeLPTransferors(\n            approvedTransferors[msg.sender],\n            transferors_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function transferLP(\n        address owner_,\n        address newOwner_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LPActions.transferLP(\n            buckets,\n            _lpAllowances,\n            approvedTransferors,\n            owner_,\n            newOwner_,\n            indexes_\n        );\n    }\n\n    /*****************************/\n    /*** Pool Helper Functions ***/\n    /*****************************/\n\n    /**\n     *  @notice Accrues pool interest in current block and returns pool details.\n     *  @dev    external libraries call: `PoolCommons.accrueInterest`\n     *  @dev    === Write state ===\n     *  @dev    - `PoolCommons.accrueInterest` - `Deposits.mult` (scale `Fenwick` tree with new interest accrued):\n     *  @dev      update scaling array state \n     *  @dev    - increment `reserveAuction.totalInterestEarned` accumulator\n     *  @return poolState_ Struct containing pool details.\n     */\n    function _accruePoolInterest() internal returns (PoolState memory poolState_) {\n        poolState_.t0Debt          = poolBalances.t0Debt;\n        poolState_.t0DebtInAuction = poolBalances.t0DebtInAuction;\n        poolState_.collateral      = poolBalances.pledgedCollateral;\n        poolState_.inflator        = inflatorState.inflator;\n        poolState_.rate            = interestState.interestRate;\n        poolState_.poolType        = _getArgUint8(POOL_TYPE);\n        poolState_.quoteTokenScale = _getArgUint256(QUOTE_SCALE);\n\n\t    // check if t0Debt is not equal to 0, indicating that there is debt to be tracked for the pool\n        if (poolState_.t0Debt != 0) {\n            // Calculate prior pool debt\n            poolState_.debt = Maths.wmul(poolState_.t0Debt, poolState_.inflator);\n\n\t        // calculate elapsed time since inflator was last updated\n            uint256 elapsed = block.timestamp - inflatorState.inflatorUpdate;\n\n\t        // set isNewInterestAccrued field to true if elapsed time is not 0, indicating that new interest may have accrued\n            poolState_.isNewInterestAccrued = elapsed != 0;\n\n            // if new interest may have accrued, call accrueInterest function and update inflator and debt fields of poolState_ struct\n            if (poolState_.isNewInterestAccrued) {\n                (uint256 newInflator, uint256 newInterest) = PoolCommons.accrueInterest(\n                    emaState,\n                    deposits,\n                    poolState_,\n                    Loans.getMax(loans).thresholdPrice,\n                    elapsed\n                );\n                poolState_.inflator = newInflator;\n                // After debt owed to lenders has accrued, calculate current debt owed by borrowers\n                poolState_.debt = Maths.wmul(poolState_.t0Debt, poolState_.inflator);\n\n                // update total interest earned accumulator with the newly accrued interest\n                reserveAuction.totalInterestEarned += newInterest;\n            }\n        }\n    }\n\n    /**\n     *  @notice Helper function to update pool state post take and bucket take actions.\n     *  @param result_    Struct containing details of take result.\n     *  @param poolState_ Struct containing pool details.\n     */\n    function _updatePostTakeState(\n        TakeResult memory result_,\n        PoolState memory poolState_\n    ) internal {\n        // update in memory pool state struct\n        poolState_.debt            =  result_.poolDebt;\n        poolState_.t0Debt          =  result_.t0PoolDebt;\n        poolState_.t0DebtInAuction += result_.t0DebtPenalty;\n        poolState_.t0DebtInAuction -= result_.t0DebtInAuctionChange;\n        poolState_.collateral      -= (result_.collateralAmount + result_.compensatedCollateral); // deduct collateral taken plus collateral compensated if NFT auction settled\n\n        // adjust t0Debt2ToCollateral ratio if auction settled by take action\n        if (result_.settledAuction) {\n            _updateT0Debt2ToCollateral(\n                0, // debt pre take (for loan in auction) not taken into account\n                result_.debtPostAction,\n                0, // collateral pre take (for loan in auction) not taken into account\n                result_.collateralPostAction\n            );\n        }\n\n        // update pool balances state\n        poolBalances.t0Debt            = poolState_.t0Debt;\n        poolBalances.t0DebtInAuction   = poolState_.t0DebtInAuction;\n        poolBalances.pledgedCollateral = poolState_.collateral;\n        // update pool interest rate state\n        _updateInterestState(poolState_, result_.newLup);\n    }\n\n    /**\n     *  @notice Helper function to update pool state post settle action.\n     *  @param result_    Struct containing details of settle result.\n     *  @param poolState_ Struct containing pool details.\n     */\n    function _updatePostSettleState(\n        SettleResult memory result_,\n        PoolState memory poolState_\n    ) internal {\n        // update in memory pool state struct\n        poolState_.debt            -= Maths.wmul(result_.t0DebtSettled, poolState_.inflator);\n        poolState_.t0Debt          -= result_.t0DebtSettled;\n        poolState_.t0DebtInAuction -= result_.t0DebtSettled;\n        poolState_.collateral      -= result_.collateralSettled;\n\n        // update pool balances state\n        poolBalances.t0Debt            = poolState_.t0Debt;\n        poolBalances.t0DebtInAuction   = poolState_.t0DebtInAuction;\n        poolBalances.pledgedCollateral = poolState_.collateral;\n        // update pool interest rate state\n        _updateInterestState(poolState_, Deposits.getLup(deposits, poolState_.debt));\n    }\n\n    /**\n     *  @notice Adjusts the `t0` debt 2 to collateral ratio, `interestState.t0Debt2ToCollateral`.\n     *  @dev    Anytime a borrower's debt or collateral changes, the `interestState.t0Debt2ToCollateral` must be updated.\n     *  @dev    === Write state ===\n     *  @dev    update `interestState.t0Debt2ToCollateral` accumulator\n     *  @param debtPreAction_  Borrower's debt before the action\n     *  @param debtPostAction_ Borrower's debt after the action\n     *  @param colPreAction_   Borrower's collateral before the action\n     *  @param colPostAction_  Borrower's collateral after the action\n     */\n    function _updateT0Debt2ToCollateral(\n        uint256 debtPreAction_,\n        uint256 debtPostAction_,\n        uint256 colPreAction_,\n        uint256 colPostAction_\n    ) internal {\n        uint256 debt2ColAccumPreAction  = colPreAction_  != 0 ? debtPreAction_  ** 2 / colPreAction_  : 0;\n        uint256 debt2ColAccumPostAction = colPostAction_ != 0 ? debtPostAction_ ** 2 / colPostAction_ : 0;\n\n        if (debt2ColAccumPreAction != 0 || debt2ColAccumPostAction != 0) {\n            uint256 curT0Debt2ToCollateral = interestState.t0Debt2ToCollateral;\n            curT0Debt2ToCollateral += debt2ColAccumPostAction;\n            curT0Debt2ToCollateral -= debt2ColAccumPreAction;\n\n            interestState.t0Debt2ToCollateral = curT0Debt2ToCollateral;\n        }\n    }\n\n    /**\n     *  @notice Update interest rate and inflator of the pool.\n     *  @dev    external libraries call: `PoolCommons.updateInterestState`\n     *  @dev    === Write state ===\n     *  @dev    - `PoolCommons.updateInterestState`\n     *  @dev      `EMA`s accumulators\n     *  @dev      interest rate accumulator and `interestRateUpdate` state\n     *  @dev      pool inflator and `inflatorUpdate` state\n     *  @dev    === Emit events ===\n     *  @dev    `PoolCommons.updateInterestState`: `UpdateInterestRate`\n     *  @param  poolState_ Struct containing pool details.\n     *  @param  lup_       Current `LUP` in pool.\n     */\n    function _updateInterestState(\n        PoolState memory poolState_,\n        uint256 lup_\n    ) internal {\n\n        PoolCommons.updateInterestState(interestState, emaState, deposits, poolState_, lup_);\n\n        // update pool inflator\n        if (poolState_.isNewInterestAccrued) {\n            inflatorState.inflator       = uint208(poolState_.inflator);\n            inflatorState.inflatorUpdate = uint48(block.timestamp);\n        // if the debt in the current pool state is 0, also update the inflator and inflatorUpdate fields in inflatorState\n        // slither-disable-next-line incorrect-equality\n        } else if (poolState_.debt == 0) {\n            inflatorState.inflator       = uint208(Maths.WAD);\n            inflatorState.inflatorUpdate = uint48(block.timestamp);\n        }\n    }\n\n    /**\n     *  @notice Helper function to transfer amount of quote tokens from sender to pool contract.\n     *  @param  from_    Sender address.\n     *  @param  amount_  Amount to transfer from sender (`WAD` precision). Scaled to quote token precision before transfer.\n     */\n    function _transferQuoteTokenFrom(address from_, uint256 amount_) internal {\n        // Transfer amount in favour of the pool\n        uint256 transferAmount = Maths.ceilDiv(amount_, _getArgUint256(QUOTE_SCALE));\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransferFrom(from_, address(this), transferAmount);\n    }\n\n    /**\n     *  @notice Helper function to transfer amount of quote tokens from pool contract.\n     *  @param  to_     Receiver address.\n     *  @param  amount_ Amount to transfer to receiver (`WAD` precision). Scaled to quote token precision before transfer.\n     */\n    function _transferQuoteToken(address to_, uint256 amount_) internal {\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransfer(to_, amount_ / _getArgUint256(QUOTE_SCALE));\n    }\n\n    /**\n     *  @notice Returns the quote token amount available to take loans or to be removed from pool.\n     *          Ensures claimable reserves and auction bonds are not used when taking loans.\n     */\n    function _availableQuoteToken() internal view returns (uint256 quoteAvailable_) {\n        uint256 poolBalance     = _getNormalizedPoolQuoteTokenBalance();\n        uint256 escrowedAmounts = auctions.totalBondEscrowed + reserveAuction.unclaimed;\n\n        if (poolBalance > escrowedAmounts) quoteAvailable_ = poolBalance - escrowedAmounts;\n    }\n\n    /**\n     *  @notice Returns the pool quote token balance normalized to `WAD` to be used for calculating pool reserves.\n     */\n    function _getNormalizedPoolQuoteTokenBalance() internal view returns (uint256) {\n        return IERC20(_getArgAddress(QUOTE_ADDRESS)).balanceOf(address(this)) * _getArgUint256(QUOTE_SCALE);\n    }\n\n    /*******************************/\n    /*** External View Functions ***/\n    /*******************************/\n\n    /// @inheritdoc IPoolState\n    function auctionInfo(\n        address borrower_\n    ) external\n    view override returns (\n        address kicker_,\n        uint256 bondFactor_,\n        uint256 bondSize_,\n        uint256 kickTime_,\n        uint256 kickMomp_,\n        uint256 neutralPrice_,\n        address head_,\n        address next_,\n        address prev_,\n        bool alreadyTaken_\n    ) {\n        Liquidation memory liquidation = auctions.liquidations[borrower_];\n        return (\n            liquidation.kicker,\n            liquidation.bondFactor,\n            liquidation.bondSize,\n            liquidation.kickTime,\n            liquidation.kickMomp,\n            liquidation.neutralPrice,\n            auctions.head,\n            liquidation.next,\n            liquidation.prev,\n            liquidation.alreadyTaken\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function borrowerInfo(\n        address borrower_\n    ) external view override returns (uint256, uint256, uint256) {\n        return (\n            loans.borrowers[borrower_].t0Debt,\n            loans.borrowers[borrower_].collateral,\n            loans.borrowers[borrower_].t0Np\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function bucketInfo(\n        uint256 index_\n    ) external view override returns (uint256, uint256, uint256, uint256, uint256) {\n        uint256 scale = Deposits.scale(deposits, index_);\n        return (\n            buckets[index_].lps,\n            buckets[index_].collateral,\n            buckets[index_].bankruptcyTime,\n            Maths.wmul(scale, Deposits.unscaledValueAt(deposits, index_)),\n            scale\n        );\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function bucketExchangeRate(\n        uint256 index_\n    ) external view returns (uint256 exchangeRate_) {\n        Bucket storage bucket = buckets[index_];\n\n        exchangeRate_ = Buckets.getExchangeRate(\n            bucket.collateral,\n            bucket.lps,\n            Deposits.valueAt(deposits, index_),\n            _priceAt(index_)\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function currentBurnEpoch() external view returns (uint256) {\n        return reserveAuction.latestBurnEventEpoch;\n    }\n\n    /// @inheritdoc IPoolState\n    function burnInfo(uint256 burnEventEpoch_) external view returns (uint256, uint256, uint256) {\n        BurnEvent memory burnEvent = reserveAuction.burnEvents[burnEventEpoch_];\n\n        return (\n            burnEvent.timestamp,\n            burnEvent.totalInterest,\n            burnEvent.totalBurned\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function debtInfo() external view returns (uint256, uint256, uint256, uint256) {\n        uint256 pendingInflator = PoolCommons.pendingInflator(\n            inflatorState.inflator,\n            inflatorState.inflatorUpdate,\n            interestState.interestRate\n        );\n        return (\n            Maths.ceilWmul(poolBalances.t0Debt, pendingInflator),\n            Maths.ceilWmul(poolBalances.t0Debt, inflatorState.inflator),\n            Maths.ceilWmul(poolBalances.t0DebtInAuction, inflatorState.inflator),\n            interestState.t0Debt2ToCollateral\n        );\n    }\n\n\n    /// @inheritdoc IPoolDerivedState\n    function depositUpToIndex(uint256 index_) external view override returns (uint256) {\n        return Deposits.prefixSum(deposits, index_);\n    }\n    \n    /// @inheritdoc IPoolDerivedState\n    function depositIndex(uint256 debt_) external view override returns (uint256) {\n        return Deposits.findIndexOfSum(deposits, debt_);\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function depositSize() external view override returns (uint256) {\n        return Deposits.treeSum(deposits);\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function depositUtilization() external view override returns (uint256) {\n        return PoolCommons.utilization(emaState);\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function depositScale(uint256 index_) external view override returns (uint256) {\n        return deposits.scaling[index_];\n    }\n\n    /// @inheritdoc IPoolState\n    function emasInfo() external view override returns (uint256, uint256, uint256, uint256) {\n        return (\n            emaState.debtColEma,\n            emaState.lupt0DebtEma,\n            emaState.debtEma,\n            emaState.depositEma\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function inflatorInfo() external view override returns (uint256, uint256) {\n        return (\n            inflatorState.inflator,\n            inflatorState.inflatorUpdate\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function interestRateInfo() external view returns (uint256, uint256) {\n        return (\n            interestState.interestRate,\n            interestState.interestRateUpdate\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function kickerInfo(\n        address kicker_\n    ) external view override returns (uint256, uint256) {\n        return(\n            auctions.kickers[kicker_].claimable,\n            auctions.kickers[kicker_].locked\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function lenderInfo(\n        uint256 index_,\n        address lender_\n    )"
    }
  ]
}