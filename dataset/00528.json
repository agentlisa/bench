{
  "Title": "M-1: Entrance fees are distributed wrongly in loans with multiple lenders",
  "Content": "# Issue M-1: Entrance fees are distributed wrongly in loans with multiple lenders \n\nSource: https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/39 \n\n## Found by \n0xDetermination\n## Summary\nEntrance fees are distributed improperly, some lenders are likely to lose some portion of their entrance fees. Also, calling `updateHoldTokenEntranceFee()` can cause improper entrance fee distribution in loans with multiple lenders.\n## Vulnerability Detail\nNote that entrance fees are added to the borrower's `feesOwed` when borrowing:\n```solidity\n        borrowing.feesOwed += entranceFee;\n```\nAlso note that the fees distributed to each lender are determined by the following calculation (https://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L546-L549):\n```solidity\n                uint256 feesAmt = FullMath.mulDiv(feesOwed, cache.holdTokenDebt, borrowedAmount); //fees owed multiplied by the individual amount lent, divided by the total amount lent\n                ...\n                loansFeesInfo[creditor][cache.holdToken] += feesAmt;\n                harvestedAmt += feesAmt;\n```\nThis is a problem because the entrance fees will be distributed among all lenders instead of credited to each lender. Example:\n1. A borrower takes a loan of 100 tokens from a lender and pays an entrance fee of 10 tokens.\n2. After some time, the lender harvests fees and fees are set to zero. (This step could be frontrunning the below step.)\n3. The borrower immediately takes out another loan of 100 tokens and pays and entrance fee of 10 tokens.\n4. When fees are harvested again, due to the calculation in the code block above, 5 tokens of the entrance fee go to the first lender and 5 tokens go to the second lender. The first lender has collected 15 tokens of entrance fees, while the second lender has collected only 5- despite both loans having the same borrowed amount.\n\nFurthermore, if the entrance fee is increased then new lenders will lose part of their entrance fee. Example:\n1. A borrower takes a loan of 100 tokens from a lender and pays an entrance fee of 10 tokens.\n2. The entrance fee is increased.\n3. The borrower increases the position by taking a loan of 100 tokens from a new lender, and pays an entrance fee of 20 tokens.\n4. `harvest()` is called, and both lenders receive 15 tokens out of the total 30 tokens paid as entrance fees. This is wrong since the first lender should receive 10 and the second lender should receive 20.\n## Impact\nLenders are likely to lose entrance fees.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L1036\nhttps://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L546-L549\n## Tool used\n\nManual Review\n\n## Recommendation\nCould add the entrance fee directly to the lender's fees balance instead of adding it to feesOwed, and then track the entrance fee in the loan data to be used in min fee enforcement calculations.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7.\n\n**fann95**\n\nYes, the problem existed and is associated with the same error as #41.\nThis issue is related to an erroneous scheme for accumulating fees and affected almost all functions in the contract, so the PR turned out to be quite large.\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; high(1)\n\n\n\n**nevillehuang**\n\n@fann95 Is the root cause the same as #41?\n\n**fann95**\n\nI think so since it was assumed that the entrance fee would be distributed the same way as the fees for borrowing.\n\n**nevillehuang**\n\n@fann95 Can you take a look at this [comment](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40#issuecomment-1974818523) and let me know your thoughts\n\n**fann95**\n\n> Can you take a look at this [comment](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40#issuecomment-1974818523) and let me know your thoughts\n\ndone\n\n\n**nevillehuang**\n\nSee comments [here](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/40#issuecomment-1982026558)\n\n**zrax-x**\n\nEscalate\n\nThis should be a duplicate of issue [41](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41), or be of Medium severity. \n\nHere are my two reasons.\n\nFirstly, all of these issues (issue [41](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41), issue [16](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/16) and this one) discuss the distribution of fees. In both issue 41 and issue 16, it was mentioned that the fees are not distributed in the function `borrow`, causing some lenders to lose fees. This issue talks about the same fee distribution problem, except it focuses on the entrance fees. In that respect, it's a Duplicate.\n\nSecondly, entrance fees are a fraction of all fees, only 0.1% is charged by default and can be set to 0. Therefore, its impact is obviously not as serious as that mentioned in issue [41](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41). I consider this to be a Medium severity issue.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This should be a duplicate of issue [41](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41), or be of Medium severity. \n> \n> Here are my two reasons.\n> \n> Firstly, all of these issues (issue [41](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41), issue [16](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/16) and this one) discuss the distribution of fees. In both issue 41 and issue 16, it was mentioned that the fees are not distributed in the function `borrow`, causing some lenders to lose fees. This issue talks about the same fee distribution problem, except it focuses on the entrance fees. In that respect, it's a Duplicate.\n> \n> Secondly, entrance fees are a fraction of all fees, only 0.1% is charged by default and can be set to 0. Therefore, its impact is obviously not as serious as that mentioned in issue [41](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41). I consider this to be a Medium severity issue.\n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**qmdddd**\n\nEscalate\n\nSee above.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> See above.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xDetermination**\n\nI disagree with the escalation's first point for the following reasons:\n1. The root [cause/fix](https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7#diff-481232aed109bd977e7bf7506f93a9d303bbbfa6e7a6d072c391c9486903b25eR181-R185) for this issue is distinct from the root [cause/fix](https://github.com/RealWagmi/wagmi-leverage/commit/84416fcedfcc7eb062917bdc69f919bba9d3c0b7#diff-19eb89909078be53347656861a11ad5cc119624558cf955fc423c728d80821bdR976) for [41](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41) (these fixes are implementing the recommendations). Fixing one issue won't fix the other.\n2. Entrance fees are a different type of fees than fees accumulated over time.\n\nAs for the second point, I agree that this may be a borderline M, but I lean more towards H for the following reasons:\n1. Entrance fees can be set up to [10%](https://github.com/sherlock-audit/2024-02-leverage-contracts/blob/main/wagmi-leverage/contracts/libraries/Constants.sol#L13) of the borrowed amount, which can be quite a lot considering that this is a high leverage protocol.\n2. I'm not sure if the loss here can be called 'highly constrained' considering that a lot of net loss can build up over time as more positions are taken in the protocol. (This issue will occur in every loan with multiple lenders.) For example, if over a period of 1 year there are 1000 multi loan positions taken by users in the protocol with $100 worth of entrance fees lost in each position, then the net loss/misallocation from this bug could be $100,000.\n3. A malicious borrower can borrow from himself or a colluding lender and then borrow from another lender to steal entrance fees (making the second position cheaper)\n\nWould like to see how @Czar102 judges this issue, since I do think the severity may be borderline.\n\n**nevillehuang**\n\n@zrax-x Can you provide code logic to prove the root cause is similar? If not I think it should remain not as duplicates given it involves different fee types.\n\nAdditionally, I believe medium severity could be more appropriate, but based on what @fann95 has highlighted, the impact is widespread throughout the whole system. @fann95 Could you shed some light on the potential impact it could have and does it justify high severity?\n\n**zrax-x**\n\nI believe High severity is not appropriate. \n\nThe entry fee rate defaults to 0.1% and entry fee is determined when borrowing (i.e. it does not increase over time), so its amount is limited. \n\nAt the same time, in order to steal the entry fees, the attacker will have to pay fees to the platform (as implemented in the function _pickUpPlatformFees), which accounts for 20% of the interest fees. So the attack cost is very high.\n\n```solidity\n    /**\n     * @dev Platform fees in basis points.\n     * 2000 BP represents a 20% fee on the daily rate.\n     */\n    uint256 public platformFeesBP = 2000;\n```\n\nIn summary, this issue will indeed cause some lenders to lose part of entry fees, but its impact is limited. I maintain it is a Medium severity issue.\n\n**0xDetermination**\n\nI think an impact that might make this issue H without needing to consider conditions like entrance fee settings is the 'net loss built up over time' example in my previous comment (edited to add the example).\n\nAddressing @zrax-x's point about platform fees- true, there is a maximum/default 20% platform fee although it can also be set lower. If we assume slippage is negligible the attack would still be profitable, but I agree that this would reduce the profitability.\n\n**Czar102**\n\n@zrax-x @qmdddd can you follow up on @nevillehuang's question?\n> Can you provide code logic to prove the root cause is similar?\n\nJust want to have clarity on the duplication status before considering the severity. Do you agree that this issue shouldn't be a duplicate of #41?\n\n**zrax-x**\n\n@Czar102 I now believe this can be a distinct issue, although it also pertains to fee distribution, the distinction lies in the calculation methods for the fees.\n\n**Czar102**\n\n@zrax-x @qmdddd @0xDetermination what is the optimal attacker's strategy to minimize their fees? How much does the lender lose in that scenario?\n\n**0xDetermination**\n\n@Czar102 @zrax-x I looked into it more and I think the minimizing fee attack is actually not profitable unless the attacker is frontrunning the admin increasing entrance fees or is colluding with another lender that the attacker legitimately wants to borrow from. So I think the highest impact for this issue may be the 'net loss' scenario as described in my earlier [comment](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/39#issuecomment-1986868811), considering that this issue will occur for every loan with multiple lenders.\n\n**zrax-x**\n\n@Czar102  Yes, I agree with @0xDetermination. First of all, it is difficult for attackers to profit from it because attackers need to pay relatively expensive platform fees. Secondly, some lenders will indeed lose a certain amount of entry fee, but I think this loss is small (considering that the entry fee rate is 0.1%, and it is not a complete loss).\n\n**0xDetermination**\n\n@zrax-x Yes, but the entrance fee can be up to 10%, and even with a 0.1% fee rate a large amount of net loss can accumulate over time- which is why I think this issue could be borderline.\n\n**zrax-x**\n\nMy opinion is that considering that the root cause of this issue and [issue#41](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41) are the same (both use the same distribution method, as @fann95 [commented](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/39#issuecomment-1975330124) before), the difference is only in the fee calculation. At the same time, the impact of [issue#41](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/41) is more serious (the attacker is profitable and the loss is greater). So, on both counts, I believe that its severity should be M.\n\n**Czar102**\n\nBecause of the heavy constraints on the exploitability (is never profitable based on what was said), and the fact that (from my understanding) the goal of this fee is mainly to prevent extremely short-term borrows and not to increase lenders' earnings, I believe this is a Medium severity issue.\n\nPlanning to accept the escalation and downgrade the issue to Medium.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [qmdddd](https://github.com/sherlock-audit/2024-02-leverage-contracts-judging/issues/39/#issuecomment-1986797762): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/234",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/LiquidityBorrowingManager.sol",
      "content": "// SPDX-License-Identifier: SAL-1.0\n\n/**\n * WAGMI Leverage Protocol v1.2\n * wagmi.com\n */\n\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./abstract/LiquidityManager.sol\";\nimport \"./abstract/OwnerSettings.sol\";\nimport \"./abstract/DailyRateAndCollateral.sol\";\nimport \"./libraries/ErrLib.sol\";\nimport \"./interfaces/ILiquidityBorrowingManager.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * @title LiquidityBorrowingManager\n * @dev This contract manages the borrowing liquidity functionality for WAGMI Leverage protocol.\n * It inherits from LiquidityManager, OwnerSettings, DailyRateAndCollateral, and ReentrancyGuard contracts.\n */\ncontract LiquidityBorrowingManager is\n    ILiquidityBorrowingManager,\n    LiquidityManager,\n    OwnerSettings,\n    DailyRateAndCollateral,\n    ReentrancyGuard\n{\n    using { ErrLib.revertError } for bool;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// borrowingKey=>LoanInfo\n    mapping(bytes32 => LoanInfo[]) private loansInfo;\n    /// borrowingKey=>BorrowingInfo\n    mapping(bytes32 => BorrowingInfo) public borrowingsInfo;\n    /// NonfungiblePositionManager tokenId => EnumerableSet.Bytes32Set\n    mapping(uint256 => EnumerableSet.Bytes32Set) private tokenIdToBorrowingKeys;\n    /// borrower => EnumerableSet.Bytes32Set\n    mapping(address => EnumerableSet.Bytes32Set) private userBorrowingKeys;\n    ///  token => FeesAmt\n    mapping(address => uint256) private platformsFeesInfo;\n\n    /// @dev Modifier to check if the current block timestamp is before or equal to the deadline.\n    modifier checkDeadline(uint256 deadline) {\n        (_blockTimestamp() > deadline).revertError(ErrLib.ErrorCode.TOO_OLD_TRANSACTION);\n        _;\n    }\n\n    modifier onlyOperator() {\n        (msg.sender != operator).revertError(ErrLib.ErrorCode.INVALID_CALLER);\n        _;\n    }\n\n    function _blockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _lightQuoterV3,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    )\n        LiquidityManager(\n            _underlyingPositionManagerAddress,\n            _lightQuoterV3,\n            _underlyingV3Factory,\n            _underlyingV3PoolInitCodeHash\n        )\n    {}\n\n    /**\n     * @dev Adds or removes a swap call params to the whitelist.\n     * @param swapTarget The address of the target contract for the swap call.\n     * @param funcSelector The function selector of the swap call.\n     * @param isAllowed A boolean indicating whether the swap call is allowed or not.\n     */\n    function setSwapCallToWhitelist(\n        address swapTarget,\n        bytes4 funcSelector,\n        bool isAllowed\n    ) external onlyOwner {\n        (swapTarget == VAULT_ADDRESS ||\n            swapTarget == address(this) ||\n            swapTarget == address(underlyingPositionManager) ||\n            funcSelector == IERC20.transferFrom.selector).revertError(ErrLib.ErrorCode.FORBIDDEN);\n        whitelistedCall[swapTarget][funcSelector] = isAllowed;\n    }\n\n    /**\n     * @notice This function allows the owner to collect protocol fees for multiple tokens\n     * and transfer them to a specified recipient.\n     * @dev Only the contract owner can call this function.\n     * @param recipient The address of the recipient who will receive the collected fees.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectProtocol(address recipient, address[] calldata tokens) external onlyOwner {\n        uint256[] memory amounts = _collect(platformsFeesInfo, recipient, tokens);\n\n        emit CollectProtocol(recipient, tokens, amounts);\n    }\n\n    /**\n     * @notice This function allows the caller to collect their own loan fees for multiple tokens\n     * and transfer them to themselves.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectLoansFees(address[] calldata tokens) external {\n        mapping(address => uint256) storage collection = loansFeesInfo[msg.sender];\n        uint256[] memory amounts = _collect(collection, msg.sender, tokens);\n\n        emit CollectLoansFees(msg.sender, tokens, amounts);\n    }\n\n    /**\n     * @notice This function is used to update the daily rate for holding token for specific pair.\n     * @dev Only the daily rate operator can call this function.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param value The new value of the daily rate for the hold token will be calculated based\n     * on the volatility of the pair and the popularity of loans in it\n     * @dev The value must be within the range of MIN_DAILY_RATE and MAX_DAILY_RATE.\n     */\n    function updateHoldTokenDailyRate(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external onlyOperator {\n        if (value > Constants.MAX_DAILY_RATE || value < Constants.MIN_DAILY_RATE) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(saleToken, holdToken);\n        holdTokenRateInfo.currentDailyRate = value;\n        emit UpdateHoldTokenDailyRate(saleToken, holdToken, value);\n    }\n\n    function updateHoldTokenEntranceFee(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external onlyOperator {\n        if (value > Constants.MAX_ENTRANCE_FEE_BPS) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenEntranceFeeInfo) = _updateHoldTokenRateInfo(\n            saleToken,\n            holdToken\n        );\n        holdTokenEntranceFeeInfo.entranceFeeBP = value;\n        emit UpdateHoldTokeEntranceFee(saleToken, holdToken, value);\n    }\n\n    /**\n     * @notice This function is used to check the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The key of the borrowing.\n     * @return balance The balance of the daily rate collateral.\n     * @return estimatedLifeTime The estimated lifetime of the collateral in seconds.\n     */\n    function checkDailyRateCollateral(\n        bytes32 borrowingKey\n    ) external view returns (int256 balance, uint256 estimatedLifeTime) {\n        (, balance, estimatedLifeTime) = _getDebtInfo(borrowingKey);\n        balance /= int256(Constants.COLLATERAL_BALANCE_PRECISION);\n    }\n\n    /**\n     * @notice Get information about loans associated with a borrowing key\n     * @dev This function retrieves an array of loan information for a given borrowing key.\n     * The loans are stored in the loansInfo mapping, which is a mapping of borrowing keys to LoanInfo arrays.\n     * @param borrowingKey The unique key associated with the borrowing\n     * @return loans An array containing LoanInfo structs representing the loans associated with the borrowing key\n     */\n    function getLoansInfo(bytes32 borrowingKey) external view returns (LoanInfo[] memory loans) {\n        loans = loansInfo[borrowingKey];\n    }\n\n    /**\n     * @notice Retrieves the borrowing information for a specific NonfungiblePositionManager tokenId.\n     * @param tokenId The unique identifier of the PositionManager token.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getLenderCreditsInfo(\n        uint256 tokenId\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = getBorrowingKeysForTokenId(tokenId);\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Retrieves the borrowing keys associated with a token ID.\n     * @param tokenId The identifier of the token.\n     * @return borrowingKeys An array of borrowing keys.\n     */\n    function getBorrowingKeysForTokenId(\n        uint256 tokenId\n    ) public view returns (bytes32[] memory borrowingKeys) {\n        borrowingKeys = tokenIdToBorrowingKeys[tokenId].values();\n    }\n\n    /**\n     * @dev Retrieves the borrowing keys for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return borrowingKeys An array of borrowing keys.\n     */\n    function getBorrowingKeysForBorrower(\n        address borrower\n    ) public view returns (bytes32[] memory borrowingKeys) {\n        borrowingKeys = userBorrowingKeys[borrower].values();\n    }\n\n    /**\n     * @notice Retrieves the debts information for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getBorrowerDebtsInfo(\n        address borrower\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower].values();\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Returns the number of loans associated with a given NonfungiblePositionManager tokenId.\n     * @param tokenId The ID of the token.\n     * @return count The total number of loans associated with the tokenId.\n     */\n    function getLenderCreditsCount(uint256 tokenId) external view returns (uint256 count) {\n        count = tokenIdToBorrowingKeys[tokenId].length();\n    }\n\n    /**\n     * @dev Returns the number of borrowings for a given borrower.\n     * @param borrower The address of the borrower.\n     * @return count The total number of borrowings for the borrower.\n     */\n    function getBorrowerDebtsCount(address borrower) external view returns (uint256 count) {\n        count = userBorrowingKeys[borrower].length();\n    }\n\n    /**\n     * @dev Returns the current daily rate for holding token.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @return  holdTokenRateInfo The structured data containing detailed information for the hold token.\n     */\n    function getHoldTokenInfo(\n        address saleToken,\n        address holdToken\n    ) external view returns (TokenInfo memory holdTokenRateInfo) {\n        holdTokenRateInfo = _getHoldTokenInfo(saleToken, holdToken);\n    }\n\n    /**\n     * @dev Returns the fees information for multiple tokens in an array.\n     * @param feesOwner The address of the owner of the fees.\n     * @param tokens An array of token addresses for which the fees are to be retrieved.\n     * @return fees An array containing the fees for each token.\n     */\n    function getFeesInfo(\n        address feesOwner,\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        mapping(address => uint256) storage collection = loansFeesInfo[feesOwner];\n        fees = _getFees(collection, tokens);\n    }\n\n    /**\n     * @dev Get the platform fees information for a list of tokens.\n     *\n     * This function returns an array of fees corresponding to the list of input tokens provided.\n     * Each fee is retrieved from the `platformsFeesInfo` mapping which stores the fee for each token address.\n     *\n     * @param tokens An array of token addresses for which to retrieve the fees information.\n     * @return fees Returns an array of fees, one per each token given as input in the same order.\n     */\n    function getPlatformFeesInfo(\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        mapping(address => uint256) storage collection = platformsFeesInfo;\n        fees = _getFees(collection, tokens);\n    }\n\n    /**\n     * @dev Calculates the liquidation bonus for a given token, borrowed amount, and times factor.\n     * @param token The address of the token.\n     * @param borrowedAmount The amount of tokens borrowed.\n     * @param times The times factor to apply to the liquidation bonus calculation.\n     * @return liquidationBonus The calculated liquidation bonus.\n     */\n    function getLiquidationBonus(\n        address token,\n        uint256 borrowedAmount,\n        uint256 times\n    ) public view returns (uint256 liquidationBonus) {\n        // Retrieve liquidation bonus for the given token\n        Liquidation memory liq = liquidationBonusForToken[token];\n\n        if (liq.bonusBP == 0) {\n            // If there is no specific bonus for the token\n            // Use default bonus\n            liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n            liq.bonusBP = dafaultLiquidationBonusBP;\n        }\n        liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n\n        if (liquidationBonus < liq.minBonusAmount) {\n            liquidationBonus = liq.minBonusAmount;\n        }\n        liquidationBonus *= (times > 0 ? times : 1);\n    }\n\n    /**\n     * @dev Calculates the collateral amount required for a lifetime in seconds.\n     *\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param lifetimeInSeconds The duration of the borrowing in seconds.\n     * @return collateralAmt The calculated collateral amount that is needed.\n     */\n    function calculateCollateralAmtForLifetime(\n        bytes32 borrowingKey,\n        uint256 lifetimeInSeconds\n    ) external view returns (uint256 collateralAmt) {\n        // Retrieve the BorrowingInfo struct associated with the borrowing key\n        BorrowingInfo memory borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowed position is existing\n        if (borrowing.borrowedAmount > 0) {\n            // Get the current daily rate for the hold token\n            uint256 currentDailyRate = _getHoldTokenInfo(borrowing.saleToken, borrowing.holdToken)\n                .currentDailyRate;\n            // Calculate the collateral amount per second\n            uint256 everySecond = (\n                FullMath.mulDivRoundingUp(\n                    borrowing.borrowedAmount,\n                    currentDailyRate * Constants.COLLATERAL_BALANCE_PRECISION,\n                    1 days * Constants.BP\n                )\n            );\n            // Calculate the total collateral amount for the borrowing lifetime\n            collateralAmt = FullMath.mulDivRoundingUp(\n                everySecond,\n                lifetimeInSeconds,\n                Constants.COLLATERAL_BALANCE_PRECISION\n            );\n            // Ensure that the collateral amount is at least 1\n            if (collateralAmt == 0) collateralAmt = 1;\n        }\n    }\n\n    /**\n     * @notice This function is used to increase the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param collateralAmt The amount of collateral to be added.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     */\n    function increaseCollateralBalance(\n        bytes32 borrowingKey,\n        uint256 collateralAmt,\n        uint256 deadline\n    ) external checkDeadline(deadline) {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists and the borrower is the message sender\n        (borrowing.borrowedAmount == 0 || borrowing.borrower != address(msg.sender)).revertError(\n            ErrLib.ErrorCode.INVALID_BORROWING_KEY\n        );\n        // Increase the daily rate collateral balance by the specified collateral amount\n        borrowing.dailyRateCollateralBalance +=\n            collateralAmt *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        _pay(borrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt);\n        emit IncreaseCollateralBalance(msg.sender, borrowingKey, collateralAmt);\n    }\n\n    /**\n     * @notice Borrow function allows a user to borrow tokens by providing collateral and taking out loans.\n     * The trader opens a long position by borrowing the liquidity of Uniswap V3 and extracting it into a pair of tokens,\n     * one of which will be swapped into a desired(holdToken).The tokens will be kept in storage until the position is closed.\n     * The margin is calculated on the basis that liquidity must be restored with any price movement.\n     * The time the position is held is paid by the trader.\n     * @dev Emits a Borrow event upon successful borrowing.\n     * @param params The BorrowParams struct containing the necessary parameters for borrowing.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     *\n     * @return borrowedAmount The total amount of `params.holdToken` borrowed.\n     * @return marginDeposit The required collateral deposit amount for initiating the loan.\n     * @return liquidationBonus An additional amount added to the debt as a bonus in case of liquidation.\n     * @return dailyRateCollateral The collateral deposit to hold the transaction for a day.\n     */\n    function borrow(\n        BorrowParams calldata params,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        returns (uint256, uint256, uint256, uint256, uint256)\n    {\n        // Precalculating borrowing details and storing them in cache\n        BorrowCache memory cache = _precalculateBorrowing(params);\n        // Initializing borrowing variables and obtaining borrowing key\n        (\n            uint256 feesDebt,\n            bytes32 borrowingKey,\n            BorrowingInfo storage borrowing\n        ) = _initOrUpdateBorrowing(\n                params.saleToken,\n                params.holdToken,\n                cache.accLoanRatePerSeconds,\n                cache.holdTokenEntraceFee\n            );\n        uint256 liquidationBonus;\n        {\n            // Adding borrowing key and loans information to storage\n            uint256 pushCounter = _addKeysAndLoansInfo(borrowingKey, params.loans);\n            // Calculating liquidation bonus based on hold token, borrowed amount, and number of used loans\n            liquidationBonus = getLiquidationBonus(\n                params.holdToken,\n                cache.borrowedAmount,\n                pushCounter\n            );\n        }\n        uint256 marginDeposit;\n        // positive slippage\n        if (cache.holdTokenBalance > cache.borrowedAmount) {\n            // Thus, we stimulate the platform to look for the best conditions for swapping on external aggregators.\n            platformsFeesInfo[params.holdToken] +=\n                (cache.holdTokenBalance - cache.borrowedAmount) *\n                Constants.COLLATERAL_BALANCE_PRECISION;\n        } else {\n            marginDeposit = cache.borrowedAmount - cache.holdTokenBalance;\n            (marginDeposit > params.maxMarginDeposit).revertError(\n                ErrLib.ErrorCode.TOO_BIG_MARGIN_DEPOSIT\n            );\n        }\n\n        // Updating borrowing details\n        borrowing.borrowedAmount += cache.borrowedAmount;\n        borrowing.liquidationBonus += liquidationBonus;\n        borrowing.dailyRateCollateralBalance +=\n            cache.dailyRateCollateral *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        //\n        cache.holdTokenEntraceFee =\n            cache.holdTokenEntraceFee /\n            Constants.COLLATERAL_BALANCE_PRECISION +\n            1;\n\n        // Transfer the required tokens to the VAULT_ADDRESS for collateral and holdTokenBalance\n        _pay(\n            params.holdToken,\n            msg.sender,\n            VAULT_ADDRESS,\n            marginDeposit +\n                liquidationBonus +\n                cache.dailyRateCollateral +\n                feesDebt +\n                cache.holdTokenEntraceFee\n        );\n        // Transferring holdTokenBalance to VAULT_ADDRESS\n        _pay(params.holdToken, address(this), VAULT_ADDRESS, cache.holdTokenBalance);\n        // Emit the Borrow event with the borrower, borrowing key, and borrowed amount\n        emit Borrow(\n            msg.sender,\n            borrowingKey,\n            cache.borrowedAmount,\n            marginDeposit,\n            liquidationBonus,\n            cache.dailyRateCollateral,\n            feesDebt,\n            cache.holdTokenEntraceFee\n        );\n        return (\n            cache.borrowedAmount,\n            marginDeposit,\n            liquidationBonus,\n            cache.dailyRateCollateral,\n            cache.holdTokenEntraceFee\n        );\n    }\n\n    /**\n     * @notice Allows lenders to harvest the fees accumulated from their loans.\n     * @dev Retrieves and updates fee amounts for all loans associated with a borrowing position.\n     * The function iterates through each loan, calculating and updating the amount of fees due.\n     *\n     * Requirements:\n     * - The borrowingKey must correspond to an active and valid borrowing position.\n     * - The collateral balance must be above zero or the current fees must be above the minimum required amount.\n     *\n     * @param borrowingKey The unique identifier for the specific borrowing position.\n     *\n     * @return harvestedAmt The total amount of fees harvested by the borrower.\n     */\n    function harvest(bytes32 borrowingKey) external nonReentrant returns (uint256 harvestedAmt) {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowing key is valid\n        _existenceCheck(borrowing.borrowedAmount);\n\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n\n        // Calculate collateral balance and validate caller\n        (int256 collateralBalance, uint256 currentFees) = _calculateCollateralBalance(\n            borrowing.borrowedAmount,\n            borrowing.accLoanRatePerSeconds,\n            borrowing.dailyRateCollateralBalance,\n            holdTokenRateInfo.accLoanRatePerSeconds\n        );\n\n        (collateralBalance < 0 ||\n            currentFees < Constants.MINIMUM_AMOUNT * Constants.COLLATERAL_BALANCE_PRECISION)\n            .revertError(ErrLib.ErrorCode.FORBIDDEN);\n\n        // Calculate platform fees and adjust fees owed\n        borrowing.dailyRateCollateralBalance -= currentFees;\n        borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        // Set the accumulated loan rate per second for the borrowing position\n        borrowing.accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n\n        uint256 feesOwed = borrowing.feesOwed;\n        uint256 borrowedAmount = borrowing.borrowedAmount;\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n\n        // Create a memory struct to store liquidity cache information.\n        NftPositionCache memory cache;\n        // Get the array of LoanInfo structs associated with the given borrowing key.\n        LoanInfo[] memory loans = loansInfo[borrowingKey];\n        // Iterate through each loan in the loans array.\n        for (uint256 i; i < loans.length; ) {\n            LoanInfo memory loan = loans[i];\n            // Get the owner address of the loan's token ID using the underlyingPositionManager contract.\n            address creditor = _getOwnerOf(loan.tokenId);\n            // Check if the owner of the loan's token ID is equal to the `msg.sender`.\n            if (creditor != address(0)) {\n                // Update the liquidity cache based on the loan information.\n                _upNftPositionCache(zeroForSaleToken, loan, cache);\n                uint256 feesAmt = FullMath.mulDiv(feesOwed, cache.holdTokenDebt, borrowedAmount);\n                // Calculate the fees amount based on the total fees owed and holdTokenDebt.\n                loansFeesInfo[creditor][cache.holdToken] += feesAmt;\n                harvestedAmt += feesAmt;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        borrowing.feesOwed -= harvestedAmt;\n\n        emit Harvest(borrowingKey, harvestedAmt);\n    }\n\n    /**\n     * @notice Used for repaying loans, optionally with liquidation or emergency liquidity withdrawal.\n     * The position is closed either by the trader or by the liquidator if the trader has not paid for holding the position\n     * and the moment of liquidation has arrived.The positions borrowed from liquidation providers are restored from the held\n     * token and the remainder is sent to the caller.In the event of liquidation, the liquidity provider\n     * whose liquidity is present in the traderâ€™s position can use the emergency mode and withdraw their liquidity.In this case,\n     * he will receive hold tokens and liquidity will not be restored in the uniswap pool.\n     * @param params The repayment parameters including\n     *  activation of the emergency liquidity restoration mode (available only to the lender)\n     *  internal swap pool fee,\n     *  external swap parameters,\n     *  borrowing key,\n     *  swap slippage allowance.\n     * @param deadline The deadline by which the repayment must be made.\n     *\n     * @return saleTokenOut The amount of saleToken returned back to the user after repayment.\n     * @return holdTokenOut The amount of holdToken returned back to the user after repayment or emergency withdrawal.\n     */\n    function repay(\n        RepayParams calldata params,\n        uint256 deadline\n    )\n        external\n        nonReentrant\n        checkDeadline(deadline)\n        returns (uint256 saleTokenOut, uint256 holdTokenOut)\n    {\n        BorrowingInfo memory borrowing = borrowingsInfo[params.borrowingKey];\n        // Check if the borrowing key is valid\n        _existenceCheck(borrowing.borrowedAmount);\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n        uint256 liquidationBonus = borrowing.liquidationBonus;\n        int256 collateralBalance;\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateHoldTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n        {\n            // Calculate collateral balance and validate caller\n            uint256 accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            uint256 currentFees;\n            (collateralBalance, currentFees) = _calculateCollateralBalance(\n                borrowing.borrowedAmount,\n                borrowing.accLoanRatePerSeconds,\n                borrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n\n            (msg.sender != borrowing.borrower && collateralBalance >= 0).revertError(\n                ErrLib.ErrorCode.INVALID_CALLER\n            );\n\n            // Calculate liquidation bonus and adjust fees owed\n\n            if (collateralBalance > 0) {\n                uint256 compensation = _calcFeeCompensationUpToMin(\n                    collateralBalance,\n                    currentFees,\n                    borrowing.feesOwed\n                );\n                currentFees += compensation;\n                collateralBalance -= int256(compensation);\n                liquidationBonus +=\n                    uint256(collateralBalance) /\n                    Constants.COLLATERAL_BALANCE_PRECISION;\n            } else {\n                currentFees = borrowing.dailyRateCollateralBalance;\n            }\n\n            // Calculate platform fees and adjust fees owed\n            borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        }\n        // Check if it's an emergency repayment\n        if (params.isEmergency) {\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            (\n                uint256 removedAmt,\n                uint256 feesAmt,\n                bool completeRepayment\n            ) = _calculateEmergencyLoanClosure(\n                    zeroForSaleToken,\n                    params.borrowingKey,\n                    borrowing.feesOwed,\n                    borrowing.borrowedAmount\n                );\n            (removedAmt == 0).revertError(ErrLib.ErrorCode.LIQUIDITY_IS_ZERO);\n            // Subtract the removed amount and fees from borrowedAmount and feesOwed\n            borrowing.borrowedAmount -= removedAmt;\n            borrowing.feesOwed -= feesAmt;\n            feesAmt /= Constants.COLLATERAL_BALANCE_PRECISION;\n            // Deduct the removed amount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= removedAmt;\n            // If loansInfoLength is 0, remove the borrowing key from storage and get the liquidation bonus\n            if (completeRepayment) {\n                LoanInfo[] memory empty;\n                _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, empty);\n                feesAmt += liquidationBonus;\n            } else {\n                // make changes to the storage\n                BorrowingInfo storage borrowingStorage = borrowingsInfo[params.borrowingKey];\n                borrowingStorage.dailyRateCollateralBalance = 0;\n                borrowingStorage.feesOwed = borrowing.feesOwed;\n                borrowingStorage.borrowedAmount = borrowing.borrowedAmount;\n            }\n            holdTokenOut = removedAmt + feesAmt;\n            // Transfer removedAmt + feesAmt to msg.sender and emit EmergencyLoanClosure event\n            Vault(VAULT_ADDRESS).transferToken(borrowing.holdToken, msg.sender, holdTokenOut);\n            emit EmergencyLoanClosure(borrowing.borrower, msg.sender, params.borrowingKey);\n        } else {\n            // Deduct borrowedAmount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= borrowing.borrowedAmount;\n\n            // Transfer the borrowed amount and liquidation bonus from the VAULT to this contract\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n\n            if (params.externalSwap.length != 0) {\n                _callExternalSwap(borrowing.holdToken, params.externalSwap);\n            }\n\n            // Restore liquidity using the borrowed amount and pay a daily rate fee\n            LoanInfo[] memory loans = loansInfo[params.borrowingKey];\n            _maxApproveIfNecessary(\n                borrowing.holdToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n            _maxApproveIfNecessary(\n                borrowing.saleToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n\n            _restoreLiquidity(\n                RestoreLiquidityParams({\n                    zeroForSaleToken: zeroForSaleToken,\n                    swapPoolfeeTier: params.internalSwapPoolfee,\n                    totalfeesOwed: borrowing.feesOwed,\n                    totalBorrowedAmount: borrowing.borrowedAmount\n                }),\n                loans\n            );\n\n            // Remove borrowing key from related data structures\n            _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n\n            // Get the remaining balance of saleToken and holdToken\n            (saleTokenOut, holdTokenOut) = _getPairBalance(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n\n            if (saleTokenOut > 0 && params.returnOnlyHoldToken) {\n                (, uint256 holdTokenAmountOut) = _simulateSwap(\n                    zeroForSaleToken,\n                    params.internalSwapPoolfee,\n                    borrowing.saleToken, // saleToken is tokenIn\n                    borrowing.holdToken,\n                    saleTokenOut\n                );\n                if (holdTokenAmountOut > 0) {\n                    // Call the internal v3SwapExactInput function\n                    holdTokenOut += _v3SwapExactInput(\n                        v3SwapExactInputParams({\n                            fee: params.internalSwapPoolfee,\n                            tokenIn: borrowing.saleToken,\n                            tokenOut: borrowing.holdToken,\n                            amountIn: saleTokenOut\n                        })\n                    );\n                    saleTokenOut = 0;\n                }\n            }\n\n            (holdTokenOut < params.minHoldTokenOut || saleTokenOut < params.minSaleTokenOut)\n                .revertError(ErrLib.ErrorCode.PRICE_SLIPPAGE_CHECK);\n\n            // Pay a"
    }
  ]
}