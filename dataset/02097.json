{
  "Title": "M-12: When underlying collateral tokens are paused, orders can't be canceled",
  "Content": "# Issue M-12: When underlying collateral tokens are paused, orders can't be canceled \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/167 \n\n## Found by \nIllIllI\n\n## Summary\n\nWhen underlying collateral tokens are paused (e.g. USDC), orders can't be canceled, and will be executed immediately after unpause\n\n\n## Vulnerability Detail\n\nPart of canceling an order is the sending back of the tokens provided. If the token is paused, the sending back will revert, preventing the cancellation.\n\n\n## Impact\n\nIf the order was a market increase order, the user gets a free look into future prices, and can decide after the token unpauses, whether to cancel the order or not, at the expense of the other side of the trade.\n\n\n## Code Snippet\n\nFor market orders, if the order reverts (e.g. due to the token being paused), the error handler attempts to cancel the order so that the user doesn't get to keep the block number (and therefore the price) that they submitted at:\n```solidity\n// File: gmx-synthetics/contracts/exchange/OrderHandler.sol : OrderHandler._handleOrderError()   #1\n\n233            Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n234            bool isMarketOrder = BaseOrderUtils.isMarketOrder(order.orderType());\n235    \n236            if (isMarketOrder) {\n237 @>             OrderUtils.cancelOrder(\n238                    dataStore,\n239                    eventEmitter,\n240                    orderVault,\n241                    key,\n242                    msg.sender,\n243                    startingGas,\n244                    reason,\n245                    reasonBytes\n246                );\n247:           } else {\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/OrderHandler.sol#L227-L247\n\nFor market increase or swap orders, canceling the order [sends back the collateral](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/OrderUtils.sol#L226) in the same transaction as the cancel.\n\nAn attacker can write a bot that front-runs token pauses, and submits very large increase orders. By the time the keeper gets to execute the order, the token will be paused, and when it tries to cancel, the cancel will revert. The attacker can watch the price movement during the pause, and if the potential position has a gain, let the keeper execute the order when the token gets unpaused. If the potential position has a loss, the bot can back-run the pause with a cancel, and prevent the keeper from opening the original position.\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nDo not send the collateral back during the cancel - have another separate 'claim' function for it\n\n\n\n\n## Discussion\n\n**xvi10**\n\nThis should be a very rare case, for the current scope this feature will not be added\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/exchange/OrderHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title OrderHandler\n// @dev Contract to handle creation, execution and cancellation of orders\ncontract OrderHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error OrderNotUpdatable(Order.OrderType orderType);\n    error InvalidKeeperForFrozenOrder(address keeper);\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev creates an order in the order store\n    // @param account the order's account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        address account,\n        BaseOrderUtils.CreateOrderParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createOrderFeatureDisabledKey(address(this), uint256(params.orderType)));\n\n        return OrderUtils.createOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            referralStorage,\n            account,\n            params\n        );\n    }\n\n    /**\n     * @dev Updates the given order with the specified size delta, acceptable price, and trigger price.\n     * The `updateOrder()` feature must be enabled for the given order type. The caller must be the owner\n     * of the order, and the order must not be a market order. The size delta, trigger price, and\n     * acceptable price are updated on the order, and the order is unfrozen. Any additional WNT that is\n     * transferred to the contract is added to the order's execution fee. The updated order is then saved\n     * in the order store, and an `OrderUpdated` event is emitted.\n     *\n     * @param key The unique ID of the order to be updated\n     * @param sizeDeltaUsd The new size delta for the order\n     * @param acceptablePrice The new acceptable price for the order\n     * @param triggerPrice The new trigger price for the order\n     */\n    function updateOrder(\n        bytes32 key,\n        uint256 sizeDeltaUsd,\n        uint256 acceptablePrice,\n        uint256 triggerPrice,\n        uint256 minOutputAmount,\n        Order.Props memory order\n    ) external payable globalNonReentrant onlyController {\n        FeatureUtils.validateFeature(dataStore, Keys.updateOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            revert OrderNotUpdatable(order.orderType());\n        }\n\n        order.setSizeDeltaUsd(sizeDeltaUsd);\n        order.setTriggerPrice(triggerPrice);\n        order.setAcceptablePrice(acceptablePrice);\n        order.setMinOutputAmount(minOutputAmount);\n        order.setIsFrozen(false);\n\n        // allow topping up of executionFee as partially filled or frozen orders\n        // will have their executionFee reduced\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 receivedWnt = orderVault.recordTransferIn(wnt);\n        order.setExecutionFee(order.executionFee() + receivedWnt);\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderUpdated(eventEmitter, key, sizeDeltaUsd, triggerPrice, acceptablePrice);\n    }\n\n    /**\n     * @dev Cancels the given order. The `cancelOrder()` feature must be enabled for the given order\n     * type. The caller must be the owner of the order, and the order must not be a market order. The\n     * order is cancelled by calling the `cancelOrder()` function in the `OrderUtils` contract. This\n     * function also records the starting gas amount and the reason for cancellation, which is passed to\n     * the `cancelOrder()` function.\n     *\n     * @param key The unique ID of the order to be cancelled\n     */\n    function cancelOrder(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Order.Props memory order = OrderStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            ExchangeUtils.validateRequestCancellation(\n                _dataStore,\n                order.updatedAtBlock(),\n                \"Order\"\n            );\n        }\n\n        OrderUtils.cancelOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            key,\n            order.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev simulate execution of an order to check for any errors\n    // @param key the order key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteOrder(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n        uint256 startingGas = gasleft();\n\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleOrderError(key, startingGas, reasonBytes);\n        }\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the order\n    // @param startingGas the starting gas\n    function _executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(key, oracleParams, keeper, startingGas);\n        // limit swaps require frozen order keeper for execution since on creation it can fail due to output amount\n        // which would automatically cause the order to be frozen\n        // limit increase and limit / trigger decrease orders may fail due to output amount as well and become frozen\n        // but only if their acceptablePrice is reached\n        if (params.order.isFrozen() || params.order.orderType() == Order.OrderType.LimitSwap) {\n            _validateFrozenOrderKeeper(keeper);\n        }\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeOrderFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n    }\n\n    // @dev handle a caught order error\n    // @param key the order's key\n    // @param startingGas the starting gas\n    // @param reason the error reason\n    // @param reasonKey the hash or the error reason\n    function _handleOrderError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (\n            OracleUtils.isEmptyPriceError(errorSelector) ||\n            errorSelector == InvalidKeeperForFrozenOrder.selector\n        ) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        bool isMarketOrder = BaseOrderUtils.isMarketOrder(order.orderType());\n\n        if (isMarketOrder) {\n            OrderUtils.cancelOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        } else {\n            if (\n                errorSelector == FeatureUtils.DisabledFeature.selector ||\n                errorSelector == PositionUtils.EmptyPosition.selector ||\n                errorSelector == BaseOrderUtils.InvalidOrderPrices.selector\n            ) {\n                ErrorUtils.revertWithCustomError(reasonBytes);\n            }\n\n            // freeze unfulfillable orders to prevent the order system from being gamed\n            // an example of gaming would be if a user creates a limit order\n            // with size greater than the available amount in the pool\n            // the user waits for their limit price to be hit, and if price\n            // moves in their favour after, they can deposit into the pool\n            // to allow the order to be executed then close the order for a profit\n            //\n            // frozen order keepers will have additional validations before executing\n            // frozen orders to prevent gaming\n            //\n            // alternatively, the user can call updateOrder to unfreeze the order\n            OrderUtils.freezeOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev validate that the keeper is a frozen order keeper\n    // @param keeper address of the keeper\n    function _validateFrozenOrderKeeper(address keeper) internal view {\n        if (!roleStore.hasRole(keeper, Role.FROZEN_ORDER_KEEPER)) {\n            revert InvalidKeeperForFrozenOrder(keeper);\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/OrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"./Order.sol\";\nimport \"./OrderVault.sol\";\nimport \"./OrderStoreUtils.sol\";\nimport \"./OrderEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"./IncreaseOrderUtils.sol\";\nimport \"./DecreaseOrderUtils.sol\";\nimport \"./SwapOrderUtils.sol\";\nimport \"./BaseOrderUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ReceiverUtils.sol\";\nimport \"../referral/ReferralUtils.sol\";\n\n// @title OrderUtils\n// @dev Library for order functions\nlibrary OrderUtils {\n    using Order for Order.Props;\n    using Position for Position.Props;\n    using Price for Price.Props;\n    using Array for uint256[];\n\n    error OrderTypeCannotBeCreated(Order.OrderType orderType);\n    error OrderAlreadyFrozen();\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\n\n    // @dev creates an order in the order store\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param account the order account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        IReferralStorage referralStorage,\n        address account,\n        BaseOrderUtils.CreateOrderParams memory params\n    ) external returns (bytes32) {\n        ReferralUtils.setTraderReferralCode(referralStorage, account, params.referralCode);\n\n        uint256 initialCollateralDeltaAmount;\n\n        address wnt = TokenUtils.wnt(dataStore);\n\n        bool shouldRecordSeparateExecutionFeeTransfer = true;\n\n        if (\n            params.orderType == Order.OrderType.MarketSwap ||\n            params.orderType == Order.OrderType.LimitSwap ||\n            params.orderType == Order.OrderType.MarketIncrease ||\n            params.orderType == Order.OrderType.LimitIncrease\n        ) {\n            initialCollateralDeltaAmount = orderVault.recordTransferIn(params.addresses.initialCollateralToken);\n            if (params.addresses.initialCollateralToken == wnt) {\n                if (initialCollateralDeltaAmount < params.numbers.executionFee) {\n                    revert InsufficientWntAmountForExecutionFee(initialCollateralDeltaAmount, params.numbers.executionFee);\n                }\n                initialCollateralDeltaAmount -= params.numbers.executionFee;\n                shouldRecordSeparateExecutionFeeTransfer = false;\n            }\n        } else if (\n            params.orderType == Order.OrderType.MarketDecrease ||\n            params.orderType == Order.OrderType.LimitDecrease ||\n            params.orderType == Order.OrderType.StopLossDecrease\n        ) {\n            initialCollateralDeltaAmount = params.numbers.initialCollateralDeltaAmount;\n        } else {\n            revert OrderTypeCannotBeCreated(params.orderType);\n        }\n\n        if (shouldRecordSeparateExecutionFeeTransfer) {\n            uint256 wntAmount = orderVault.recordTransferIn(wnt);\n            if (wntAmount < params.numbers.executionFee) {\n                revert InsufficientWntAmountForExecutionFee(wntAmount, params.numbers.executionFee);\n            }\n\n            GasUtils.handleExcessExecutionFee(\n                dataStore,\n                orderVault,\n                wntAmount,\n                params.numbers.executionFee\n            );\n        }\n\n        // validate swap path markets\n        MarketUtils.getEnabledMarkets(\n            dataStore,\n            params.addresses.swapPath\n        );\n\n        Order.Props memory order;\n\n        order.setAccount(account);\n        order.setReceiver(params.addresses.receiver);\n        order.setCallbackContract(params.addresses.callbackContract);\n        order.setMarket(params.addresses.market);\n        order.setInitialCollateralToken(params.addresses.initialCollateralToken);\n        order.setSwapPath(params.addresses.swapPath);\n        order.setOrderType(params.orderType);\n        order.setDecreasePositionSwapType(params.decreasePositionSwapType);\n        order.setSizeDeltaUsd(params.numbers.sizeDeltaUsd);\n        order.setInitialCollateralDeltaAmount(initialCollateralDeltaAmount);\n        order.setTriggerPrice(params.numbers.triggerPrice);\n        order.setAcceptablePrice(params.numbers.acceptablePrice);\n        order.setExecutionFee(params.numbers.executionFee);\n        order.setCallbackGasLimit(params.numbers.callbackGasLimit);\n        order.setMinOutputAmount(params.numbers.minOutputAmount);\n        order.setIsLong(params.isLong);\n        order.setShouldUnwrapNativeToken(params.shouldUnwrapNativeToken);\n\n        ReceiverUtils.validateReceiver(order.receiver());\n\n        if (order.initialCollateralDeltaAmount() == 0 && order.sizeDeltaUsd() == 0) {\n            revert BaseOrderUtils.EmptyOrder();\n        }\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, order.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev executes an order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function executeOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        BaseOrderUtils.validateNonEmptyOrder(params.order);\n\n        BaseOrderUtils.setExactOrderPrice(\n            params.contracts.oracle,\n            params.market.indexToken,\n            params.order.orderType(),\n            params.order.triggerPrice(),\n            params.order.isLong()\n        );\n\n        processOrder(params);\n\n        OrderEventUtils.emitOrderExecuted(params.contracts.eventEmitter, params.key);\n\n        CallbackUtils.afterOrderExecution(params.key, params.order);\n\n        // the order.executionFee for liquidation / adl orders is zero\n        // gas costs for liquidations / adl is subsidised by the treasury\n        GasUtils.payExecutionFee(\n            params.contracts.dataStore,\n            params.contracts.orderVault,\n            params.order.executionFee(),\n            params.startingGas,\n            params.keeper,\n            params.order.account()\n        );\n    }\n\n    // @dev process an order execution\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) internal {\n        if (BaseOrderUtils.isIncreaseOrder(params.order.orderType())) {\n            IncreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isDecreaseOrder(params.order.orderType())) {\n            DecreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isSwapOrder(params.order.orderType())) {\n            SwapOrderUtils.processOrder(params);\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    // @dev cancels an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to cancel\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason for cancellation\n    function cancelOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (BaseOrderUtils.isIncreaseOrder(order.orderType()) || BaseOrderUtils.isSwapOrder(order.orderType())) {\n            if (order.initialCollateralDeltaAmount() > 0) {\n                orderVault.transferOut(\n                    order.initialCollateralToken(),\n                    order.account(),\n                    order.initialCollateralDeltaAmount(),\n                    order.shouldUnwrapNativeToken()\n                );\n            }\n        }\n\n        OrderStoreUtils.remove(dataStore, key, order.account());\n\n        OrderEventUtils.emitOrderCancelled(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderCancellation(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            order.executionFee(),\n            startingGas,\n            keeper,\n            order.account()\n        );\n    }\n\n    // @dev freezes an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to freeze\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason the order was frozen\n    function freezeOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (order.isFrozen()) {\n            revert OrderAlreadyFrozen();\n        }\n\n        uint256 executionFee = order.executionFee();\n\n        order.setExecutionFee(0);\n        order.setIsFrozen(true);\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderFrozen(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderFrozen(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            executionFee,\n            startingGas,\n            keeper,\n            order.account()\n        );\n\n    }\n}"
    }
  ]
}