{
  "Title": "[M-02] `PrizePool.awardExternalERC721()` Erroneously Emits Events",
  "Content": "_Submitted by leastwood_.\n\n#### Impact\n\nThe `awardExternalERC721()` function uses solidity's try and catch statement to ensure a single tokenId cannot deny function execution. If the try statement fails, an `ErrorAwardingExternalERC721` event is emitted with the relevant error, however, the failed tokenId is not removed from the list of tokenIds emitted at the end of function execution. As a result, the `AwardedExternalERC721` is emitted with the entire list of tokenIds, regardless of failure.  An off-chain script or user could therefore be tricked into thinking an ERC721 tokenId was successfully awarded.\n\n#### Proof of Concept\n\n<https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L250-L270>\n\n#### Tools Used\n\nManual code review\n\n#### Recommended Mitigation Steps\n\nConsider emitting only successfully transferred tokenIds in the `AwardedExternalERC721` event.\n\n**[PierrickGT (PoolTogether) confirmed and patched](https://github.com/code-423n4/2021-10-pooltogether-findings/issues/62#issuecomment-943617886):**\n > PR: https://github.com/pooltogether/v4-core/pull/246\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-pooltogether-findings/issues/62#issuecomment-943857035):**\n > The sponsor acknowledged and mitigated by actively managing a list of `_awardedTokenIds` to keep track of the tokens that didn't go through the `catch` part of the error hadling\n\n\n\n \n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-pooltogether",
  "Code": [
    {
      "filename": "contracts/prize-pool/PrizePool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@pooltogether/owner-manager-contracts/contracts/Ownable.sol\";\n\nimport \"../external/compound/ICompLike.sol\";\nimport \"../interfaces/IPrizePool.sol\";\nimport \"../interfaces/ITicket.sol\";\n\n/**\n  * @title  PoolTogether V4 PrizePool\n  * @author PoolTogether Inc Team\n  * @notice Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.\n            Users deposit and withdraw from this contract to participate in Prize Pool.\n            Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.\n            Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\n*/\nabstract contract PrizePool is IPrizePool, Ownable, ReentrancyGuard, IERC721Receiver {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using ERC165Checker for address;\n\n    /// @notice Semver Version\n    string public constant VERSION = \"4.0.0\";\n\n    /// @notice Prize Pool ticket. Can only be set once by calling `setTicket()`.\n    ITicket internal ticket;\n\n    /// @notice The Prize Strategy that this Prize Pool is bound to.\n    address internal prizeStrategy;\n\n    /// @notice The total amount of tickets a user can hold.\n    uint256 internal balanceCap;\n\n    /// @notice The total amount of funds that the prize pool can hold.\n    uint256 internal liquidityCap;\n\n    /// @notice the The awardable balance\n    uint256 internal _currentAwardBalance;\n\n    /* ============ Modifiers ============ */\n\n    /// @dev Function modifier to ensure caller is the prize-strategy\n    modifier onlyPrizeStrategy() {\n        require(msg.sender == prizeStrategy, \"PrizePool/only-prizeStrategy\");\n        _;\n    }\n\n    /// @dev Function modifier to ensure the deposit amount does not exceed the liquidity cap (if set)\n    modifier canAddLiquidity(uint256 _amount) {\n        require(_canAddLiquidity(_amount), \"PrizePool/exceeds-liquidity-cap\");\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /// @notice Deploy the Prize Pool\n    /// @param _owner Address of the Prize Pool owner\n    constructor(address _owner) Ownable(_owner) ReentrancyGuard() {\n        _setLiquidityCap(type(uint256).max);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IPrizePool\n    function balance() external override returns (uint256) {\n        return _balance();\n    }\n\n    /// @inheritdoc IPrizePool\n    function awardBalance() external view override returns (uint256) {\n        return _currentAwardBalance;\n    }\n\n    /// @inheritdoc IPrizePool\n    function canAwardExternal(address _externalToken) external view override returns (bool) {\n        return _canAwardExternal(_externalToken);\n    }\n\n    /// @inheritdoc IPrizePool\n    function isControlled(ITicket _controlledToken) external view override returns (bool) {\n        return _isControlled(_controlledToken);\n    }\n\n    /// @inheritdoc IPrizePool\n    function getAccountedBalance() external view override returns (uint256) {\n        return _ticketTotalSupply();\n    }\n\n    /// @inheritdoc IPrizePool\n    function getBalanceCap() external view override returns (uint256) {\n        return balanceCap;\n    }\n\n    /// @inheritdoc IPrizePool\n    function getLiquidityCap() external view override returns (uint256) {\n        return liquidityCap;\n    }\n\n    /// @inheritdoc IPrizePool\n    function getTicket() external view override returns (ITicket) {\n        return ticket;\n    }\n\n    /// @inheritdoc IPrizePool\n    function getPrizeStrategy() external view override returns (address) {\n        return prizeStrategy;\n    }\n\n    /// @inheritdoc IPrizePool\n    function getToken() external view override returns (address) {\n        return address(_token());\n    }\n\n    /// @inheritdoc IPrizePool\n    function captureAwardBalance() external override nonReentrant returns (uint256) {\n        uint256 ticketTotalSupply = _ticketTotalSupply();\n        uint256 currentAwardBalance = _currentAwardBalance;\n\n        // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source\n        uint256 currentBalance = _balance();\n        uint256 totalInterest = (currentBalance > ticketTotalSupply)\n            ? currentBalance - ticketTotalSupply\n            : 0;\n\n        uint256 unaccountedPrizeBalance = (totalInterest > currentAwardBalance)\n            ? totalInterest - currentAwardBalance\n            : 0;\n\n        if (unaccountedPrizeBalance > 0) {\n            currentAwardBalance = totalInterest;\n            _currentAwardBalance = currentAwardBalance;\n\n            emit AwardCaptured(unaccountedPrizeBalance);\n        }\n\n        return currentAwardBalance;\n    }\n\n    /// @inheritdoc IPrizePool\n    function depositTo(address _to, uint256 _amount)\n        external\n        override\n        nonReentrant\n        canAddLiquidity(_amount)\n    {\n        _depositTo(msg.sender, _to, _amount);\n    }\n\n    /// @inheritdoc IPrizePool\n    function depositToAndDelegate(address _to, uint256 _amount, address _delegate)\n        external\n        override\n        nonReentrant\n        canAddLiquidity(_amount)\n    {\n        _depositTo(msg.sender, _to, _amount);\n        ticket.controllerDelegateFor(msg.sender, _delegate);\n    }\n\n    /// @notice Transfers tokens in from one user and mints tickets to another\n    /// @notice _operator The user to transfer tokens from\n    /// @notice _to The user to mint tickets to\n    /// @notice _amount The amount to transfer and mint\n    function _depositTo(address _operator, address _to, uint256 _amount) internal\n    {\n        require(_canDeposit(_to, _amount), \"PrizePool/exceeds-balance-cap\");\n\n        ITicket _ticket = ticket;\n\n        _token().safeTransferFrom(_operator, address(this), _amount);\n\n        _mint(_to, _amount, _ticket);\n        _supply(_amount);\n\n        emit Deposited(_operator, _to, _ticket, _amount);\n    }\n\n    /// @inheritdoc IPrizePool\n    function withdrawFrom(address _from, uint256 _amount)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        ITicket _ticket = ticket;\n\n        // burn the tickets\n        _ticket.controllerBurnFrom(msg.sender, _from, _amount);\n\n        // redeem the tickets\n        uint256 _redeemed = _redeem(_amount);\n\n        _token().safeTransfer(_from, _redeemed);\n\n        emit Withdrawal(msg.sender, _from, _ticket, _amount, _redeemed);\n\n        return _redeemed;\n    }\n\n    /// @inheritdoc IPrizePool\n    function award(address _to, uint256 _amount) external override onlyPrizeStrategy {\n        if (_amount == 0) {\n            return;\n        }\n\n        uint256 currentAwardBalance = _currentAwardBalance;\n\n        require(_amount <= currentAwardBalance, \"PrizePool/award-exceeds-avail\");\n\n        unchecked {\n            _currentAwardBalance = currentAwardBalance - _amount;\n        }\n\n        ITicket _ticket = ticket;\n\n        _mint(_to, _amount, _ticket);\n\n        emit Awarded(_to, _ticket, _amount);\n    }\n\n    /// @inheritdoc IPrizePool\n    function transferExternalERC20(\n        address _to,\n        address _externalToken,\n        uint256 _amount\n    ) external override onlyPrizeStrategy {\n        if (_transferOut(_to, _externalToken, _amount)) {\n            emit TransferredExternalERC20(_to, _externalToken, _amount);\n        }\n    }\n\n    /// @inheritdoc IPrizePool\n    function awardExternalERC20(\n        address _to,\n        address _externalToken,\n        uint256 _amount\n    ) external override onlyPrizeStrategy {\n        if (_transferOut(_to, _externalToken, _amount)) {\n            emit AwardedExternalERC20(_to, _externalToken, _amount);\n        }\n    }\n\n    /// @inheritdoc IPrizePool\n    function awardExternalERC721(\n        address _to,\n        address _externalToken,\n        uint256[] calldata _tokenIds\n    ) external override onlyPrizeStrategy {\n        require(_canAwardExternal(_externalToken), \"PrizePool/invalid-external-token\");\n\n        if (_tokenIds.length == 0) {\n            return;\n        }\n\n        uint256[] memory _awardedTokenIds = new uint256[](_tokenIds.length); \n        bool hasAwardedTokenIds;\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            try IERC721(_externalToken).safeTransferFrom(address(this), _to, _tokenIds[i]) {\n                hasAwardedTokenIds = true;\n                _awardedTokenIds[i] = _tokenIds[i];\n            } catch (\n                bytes memory error\n            ) {\n                emit ErrorAwardingExternalERC721(error);\n            }\n        }\n        if (hasAwardedTokenIds) { \n            emit AwardedExternalERC721(_to, _externalToken, _awardedTokenIds);\n        }\n    }\n\n    /// @inheritdoc IPrizePool\n    function setBalanceCap(uint256 _balanceCap) external override onlyOwner returns (bool) {\n        _setBalanceCap(_balanceCap);\n        return true;\n    }\n\n    /// @inheritdoc IPrizePool\n    function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {\n        _setLiquidityCap(_liquidityCap);\n    }\n\n    /// @inheritdoc IPrizePool\n    function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {\n        require(address(_ticket) != address(0), \"PrizePool/ticket-not-zero-address\");\n        require(address(ticket) == address(0), \"PrizePool/ticket-already-set\");\n\n        ticket = _ticket;\n\n        emit TicketSet(_ticket);\n\n        _setBalanceCap(type(uint256).max);\n\n        return true;\n    }\n\n    /// @inheritdoc IPrizePool\n    function setPrizeStrategy(address _prizeStrategy) external override onlyOwner {\n        _setPrizeStrategy(_prizeStrategy);\n    }\n\n    /// @inheritdoc IPrizePool\n    function compLikeDelegate(ICompLike _compLike, address _to) external override onlyOwner {\n        if (_compLike.balanceOf(address(this)) > 0) {\n            _compLike.delegate(_to);\n        }\n    }\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /// @notice Transfer out `amount` of `externalToken` to recipient `to`\n    /// @dev Only awardable `externalToken` can be transferred out\n    /// @param _to Recipient address\n    /// @param _externalToken Address of the external asset token being transferred\n    /// @param _amount Amount of external assets to be transferred\n    /// @return True if transfer is successful\n    function _transferOut(\n        address _to,\n        address _externalToken,\n        uint256 _amount\n    ) internal returns (bool) {\n        require(_canAwardExternal(_externalToken), \"PrizePool/invalid-external-token\");\n\n        if (_amount == 0) {\n            return false;\n        }\n\n        IERC20(_externalToken).safeTransfer(_to, _amount);\n\n        return true;\n    }\n\n    /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.\n    /// @param _to The user who is receiving the tokens\n    /// @param _amount The amount of tokens they are receiving\n    /// @param _controlledToken The token that is going to be minted\n    function _mint(\n        address _to,\n        uint256 _amount,\n        ITicket _controlledToken\n    ) internal {\n        _controlledToken.controllerMint(_to, _amount);\n    }\n\n    /// @dev Checks if `user` can deposit in the Prize Pool based on the current balance cap.\n    /// @param _user Address of the user depositing.\n    /// @param _amount The amount of tokens to be deposited into the Prize Pool.\n    /// @return True if the Prize Pool can receive the specified `amount` of tokens.\n    function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {\n        uint256 _balanceCap = balanceCap;\n\n        if (_balanceCap == type(uint256).max) return true;\n\n        return (ticket.balanceOf(_user) + _amount <= _balanceCap);\n    }\n\n    /// @dev Checks if the Prize Pool can receive liquidity based on the current cap\n    /// @param _amount The amount of liquidity to be added to the Prize Pool\n    /// @return True if the Prize Pool can receive the specified amount of liquidity\n    function _canAddLiquidity(uint256 _amount) internal view returns (bool) {\n        uint256 _liquidityCap = liquidityCap;\n        if (_liquidityCap == type(uint256).max) return true;\n        return (_ticketTotalSupply() + _amount <= _liquidityCap);\n    }\n\n    /// @dev Checks if a specific token is controlled by the Prize Pool\n    /// @param _controlledToken The address of the token to check\n    /// @return True if the token is a controlled token, false otherwise\n    function _isControlled(ITicket _controlledToken) internal view returns (bool) {\n        return (ticket == _controlledToken);\n    }\n\n    /// @notice Allows the owner to set a balance cap per `token` for the pool.\n    /// @param _balanceCap New balance cap.\n    function _setBalanceCap(uint256 _balanceCap) internal {\n        balanceCap = _balanceCap;\n        emit BalanceCapSet(_balanceCap);\n    }\n\n    /// @notice Allows the owner to set a liquidity cap for the pool\n    /// @param _liquidityCap New liquidity cap\n    function _setLiquidityCap(uint256 _liquidityCap) internal {\n        liquidityCap = _liquidityCap;\n        emit LiquidityCapSet(_liquidityCap);\n    }\n\n    /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.\n    /// @param _prizeStrategy The new prize strategy\n    function _setPrizeStrategy(address _prizeStrategy) internal {\n        require(_prizeStrategy != address(0), \"PrizePool/prizeStrategy-not-zero\");\n\n        prizeStrategy = _prizeStrategy;\n\n        emit PrizeStrategySet(_prizeStrategy);\n    }\n\n    /// @notice The current total of tickets.\n    /// @return Ticket total supply.\n    function _ticketTotalSupply() internal view returns (uint256) {\n        return ticket.totalSupply();\n    }\n\n    /// @dev Gets the current time as represented by the current block\n    /// @return The timestamp of the current block\n    function _currentTime() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /* ============ Abstract Contract Implementatiton ============ */\n\n    /// @notice Determines whether the passed token can be transferred out as an external award.\n    /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The\n    /// prize strategy should not be allowed to move those tokens.\n    /// @param _externalToken The address of the token to check\n    /// @return True if the token may be awarded, false otherwise\n    function _canAwardExternal(address _externalToken) internal view virtual returns (bool);\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function _token() internal view virtual returns (IERC20);\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function _balance() internal virtual returns (uint256);\n\n    /// @notice Supplies asset tokens to the yield source.\n    /// @param _mintAmount The amount of asset tokens to be supplied\n    function _supply(uint256 _mintAmount) internal virtual;\n\n    /// @notice Redeems asset tokens from the yield source.\n    /// @param _redeemAmount The amount of yield-bearing tokens to be redeemed\n    /// @return The actual amount of tokens that were redeemed.\n    function _redeem(uint256 _redeemAmount) internal virtual returns (uint256);\n}"
    }
  ]
}