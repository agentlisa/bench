{
  "Title": "[L-06] Arrays can grow without a way to shrink them",
  "Content": "- Severity: Low\n- Confidence: High\n\n### Description\nIt's a good practice to maintain control over the size of array state variables in Solidity, especially if they are dynamically updated. If a contract includes a mechanism to push items into an array, it should ideally also provide a mechanism to remove items. Ignoring this can lead to bloated and inefficient contracts.\n\n<details>\n\n<summary>\nThere are 1 instances of this issue:\n\n</summary>\n\n###\n\nLine: 3\n\n- File: solidity/contracts/periphery/oracles/StableCurveLpOracle.sol\n```\n \nLine: 17          IOracleRelay[] public anchoredUnderlyingTokens\n```\nArray grow:<br>File: solidity/contracts/periphery/oracles/StableCurveLpOracle.sol\n```\n \nLine: 23          anchoredUnderlyingTokens.push(_anchoredUnderlyingTokens[_i])\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/StableCurveLpOracle.sol#L17](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/oracles/StableCurveLpOracle.sol#L17)\n\n</details>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/periphery/oracles/StableCurveLpOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IOracleRelay, OracleRelay} from '@contracts/periphery/oracles/OracleRelay.sol';\nimport {IStablePool} from '@interfaces/utils/ICurvePool.sol';\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {CurveRegistryUtils} from '@contracts/periphery/oracles/CurveRegistryUtils.sol';\n\n/// @notice Oracle Relay for crv lps\ncontract StableCurveLpOracle is OracleRelay, CurveRegistryUtils {\n  /// @notice Thrown when there are too few anchored oracles\n  error StableCurveLpOracle_TooFewAnchoredOracles();\n\n  /// @notice The pool of the crv lp token\n  IStablePool public immutable CRV_POOL;\n  /// @notice The anchor oracles of the underlying tokens\n  IOracleRelay[] public anchoredUnderlyingTokens;\n\n  constructor(address _crvPool, IOracleRelay[] memory _anchoredUnderlyingTokens) OracleRelay(OracleType.Chainlink) {\n    if (_anchoredUnderlyingTokens.length < 2) revert StableCurveLpOracle_TooFewAnchoredOracles();\n    CRV_POOL = IStablePool(_crvPool);\n    for (uint256 _i; _i < _anchoredUnderlyingTokens.length;) {\n      anchoredUnderlyingTokens.push(_anchoredUnderlyingTokens[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    _setUnderlying(_getLpAddress(_crvPool));\n  }\n\n  /// @notice The current reported value of the oracle\n  /// @dev Implementation in _get()\n  /// @return _price The current value\n  function peekValue() public view virtual override returns (uint256 _price) {\n    _price = _get();\n  }\n\n  /// @notice Calculates the lastest exchange rate\n  function _get() internal view returns (uint256 _value) {\n    // As the price should never be negative, the unchecked conversion is acceptable\n    uint256 _minStable = anchoredUnderlyingTokens[0].peekValue();\n    for (uint256 _i = 1; _i < anchoredUnderlyingTokens.length;) {\n      _minStable = Math.min(_minStable, anchoredUnderlyingTokens[_i].peekValue());\n      unchecked {\n        ++_i;\n      }\n    }\n\n    uint256 _lpPrice = _getVirtualPrice() * _minStable;\n\n    _value = _lpPrice / 1e18;\n  }\n\n  /// @notice returns the updated virtual price for the pool\n  function _getVirtualPrice() internal view virtual returns (uint256 _value) {\n    _value = CRV_POOL.get_virtual_price();\n  }\n}"
    }
  ]
}