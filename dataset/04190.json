{
  "Title": "[C01] Funds can be lost",
  "Content": "The [`sweepTimelockBalances` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L471) accepts a list of users with unlocked balances to distribute. However, if there are duplicate users in the list, their balances will be counted multiple times when calculating the [total amount to withdraw](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L493) from the yield service. This has two consequences:\n\n\n* After the transaction is complete, the excess amount withdrawn will be held by the `PrizePool` contract (instead of the yield service) and will not earn interest\n* Eventually, a user will want to withdraw that amount, which will fail when the `PrizePool` attempts to [redeem it from the yield service](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L294). This means the last users to withdraw will lose their funds. Interestingly, in the case of the `CompoundPrizePool`, this is partially mitigated by the [**“[H01] Improper Error Handling”**](#h01) issue.\n\n\nConsider checking for duplicate users when calculating the amount to withdraw.\n\n\n***Update**: Fixed in [pull request #100](https://github.com/pooltogether/pooltogether-pool-contracts/pull/100). The `_sweepTimelockBalances` function now removes the user’s timelock balance after adding it to the total withdrawal amount and saving it into an auxiliary array named `balances`, which has the same size as the `users` array provided as a parameter. In this process, as the code still allows the `users` to have duplicate addresses, a zero will be saved in the `balances` array for each repeated address.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/prize-pool/PrizePool.sol",
      "content": "pragma solidity 0.6.4;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol\";\nimport \"@pooltogether/fixed-point/contracts/FixedPoint.sol\";\n\nimport \"../prize-strategy/PrizeStrategyInterface.sol\";\nimport \"../token/ControlledToken.sol\";\nimport \"../token/TokenControllerInterface.sol\";\nimport \"../utils/MappedSinglyLinkedList.sol\";\nimport \"../utils/RelayRecipient.sol\";\n\n/// @title Base Prize Pool for managing escrowed assets\n/// @notice Manages depositing and withdrawing assets from the Prize Pool\n/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\nabstract contract PrizePool is OwnableUpgradeSafe, RelayRecipient, ReentrancyGuardUpgradeSafe, TokenControllerInterface {\n  using SafeMath for uint256;\n  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;\n\n  /// @dev Helpful data structure to organize timelock sweeps\n  struct BalanceChange {\n    address user;\n    uint256 balance;\n  }\n\n  /// @dev Event emitted when assets are deposited\n  event Deposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when timelocked funds are re-deposited\n  event TimelockDeposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when interest is awarded to a winner\n  event Awarded(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n  \n  /// @dev Event emitted when external ERC20s are awarded to a winner\n  event AwardedExternalERC20(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC721s are awarded to a winner\n  event AwardedExternalERC721(\n    address indexed winner,\n    address indexed token,\n    uint256[] tokenIds\n  );\n  \n  /// @dev Event emitted when assets are withdrawn instantly\n  event InstantWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 exitFee,\n    uint256 sponsoredExitFee\n  );\n  \n  /// @dev Event emitted when assets are withdrawn into a timelock\n  event TimelockedWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 unlockTimestamp\n  );\n  \n  /// @dev Event emitted when timelocked funds are swept back to a user\n  event TimelockedWithdrawalSwept(\n    address indexed operator,\n    address indexed from,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when the prize strategy is detached from the Prize Pool.\n  event PrizeStrategyDetached();\n\n  /// @dev A linked list of all the controlled tokens\n  MappedSinglyLinkedList.Mapping internal _tokens;\n\n  /// @dev The Prize Strategy that this Prize Pool is bound to.\n  PrizeStrategyInterface public prizeStrategy;\n\n  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.\n  /// For example, if the maxExitFeeMantissa is \"0.1 ether\", then the maximum exit fee for a withdrawal of 100 will be 10.\n  uint256 public maxExitFeeMantissa;\n\n  /// @dev The maximum possible timelock duration for a timelocked withdrawal.\n  uint256 public maxTimelockDuration;\n\n  /// @dev The total funds that are timelocked.\n  uint256 public timelockTotalSupply;\n\n  /// @dev The timelocked balances for each user\n  mapping(address => uint256) internal timelockBalances;\n\n  /// @dev The unlock timestamps for each user\n  mapping(address => uint256) internal unlockTimestamps;\n\n  /// @notice Initializes the Prize Pool with required contract connections\n  /// @param _trustedForwarder Address of the Forwarding Contract for GSN Meta-Txs\n  /// @param _prizeStrategy Address of the component-controller that manages the prize-strategy\n  /// @param _controlledTokens Array of addresses for the Ticket and Sponsorship Tokens controlled by the Prize Pool\n  /// @param _maxExitFeeMantissa The maximum exit fee size, relative to the withdrawal amount\n  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock could be\n  function initialize (\n    address _trustedForwarder,\n    PrizeStrategyInterface _prizeStrategy,\n    address[] memory _controlledTokens,\n    uint256 _maxExitFeeMantissa,\n    uint256 _maxTimelockDuration\n  )\n    public\n    initializer\n  {\n    require(address(_prizeStrategy) != address(0), \"PrizePool/prizeStrategy-zero\");\n    require(_trustedForwarder != address(0), \"PrizePool/forwarder-zero\");\n    _tokens.initialize(_controlledTokens);\n    for (uint256 i = 0; i < _controlledTokens.length; i++) {\n      require(ControlledToken(_controlledTokens[i]).controller() == this, \"PrizePool/token-ctrlr-mismatch\");\n    }\n    __Ownable_init();\n    __ReentrancyGuard_init();\n    trustedForwarder = _trustedForwarder;\n    prizeStrategy = _prizeStrategy;\n    maxExitFeeMantissa = _maxExitFeeMantissa;\n    maxTimelockDuration = _maxTimelockDuration;\n  }\n\n  /// @dev Inheriting contract must determine if a specific token type may be awarded as a prize enhancement\n  /// @param _externalToken The address of the token to check\n  /// @return True if the token may be awarded, false otherwise\n  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);\n\n  /// @dev Inheriting contract must return an interface to the underlying asset token that conforms to the ERC20 spec\n  /// @return A reference to the interface of the underling asset token\n  function _token() internal virtual view returns (IERC20);\n\n  /// @dev Inheriting contract must return the balance of the underlying assets held by the Yield Service\n  /// @return The underlying balance of asset tokens\n  function _balance() internal virtual returns (uint256);\n\n  /// @dev Inheriting contract must provide the ability to supply asset tokens in exchange\n  /// for yield-bearing tokens to be held in escrow by the Yield Service\n  /// @param mintAmount The amount of asset tokens to be supplied\n  function _supply(uint256 mintAmount) internal virtual;\n\n  /// @dev Inheriting contract must provide the ability to redeem yield-bearing tokens in exchange\n  /// for the underlying asset tokens held in escrow by the Yield Service\n  /// @param redeemAmount The amount of yield-bearing tokens to be redeemed\n  function _redeem(uint256 redeemAmount) internal virtual;\n\n  /// @dev Inheriting contract must provide an estimate for the amount of accrued interest that would\n  /// be applied to the `principal` amount over a given number of `blocks`\n  /// @param principal The amount of asset tokens to provide an estimate on\n  /// @param blocks The number of blocks that the principal would accrue interest over\n  /// @return The estimated interest that would accrue on the principal\n  function estimateAccruedInterestOverBlocks(uint256 principal, uint256 blocks) public virtual view returns (uint256);\n\n  /// @dev Gets the underlying asset token used by the Yield Service\n  /// @return A reference to the interface of the underling asset token\n  function token() external virtual view returns (IERC20) {\n    return _token();\n  }\n\n  /// @dev Gets the balance of the underlying assets held by the Yield Service\n  /// @return The underlying balance of asset tokens\n  function balance() external virtual returns (uint256) {\n    return _balance();\n  }\n\n  /// @dev Checks with the Prize Pool if a specific token type may be awarded as a prize enhancement\n  /// @param _externalToken The address of the token to check\n  /// @return True if the token may be awarded, false otherwise\n  function canAwardExternal(address _externalToken) external virtual view returns (bool) {\n    return _canAwardExternal(_externalToken);\n  }\n\n  /// @notice Deposits timelocked tokens for a user back into the Prize Pool as another asset.\n  /// @param to The address receiving the tokens\n  /// @param amount The amount of timelocked assets to re-deposit\n  /// @param controlledToken The type of token to be minted in exchange (i.e. tickets or sponsorship)\n  function timelockDepositTo(\n    address to,\n    uint256 amount,\n    address controlledToken,\n    bytes calldata data\n  )\n    external\n    onlyControlledToken(controlledToken)\n    nonReentrant\n  {\n    require(_hasPrizeStrategy(), \"PrizePool/prize-strategy-detached\");\n\n    address operator = _msgSender();\n\n    ControlledToken(controlledToken).controllerMint(to, amount);\n    timelockBalances[operator] = timelockBalances[operator].sub(amount);\n    timelockTotalSupply = timelockTotalSupply.sub(amount);\n\n    prizeStrategy.afterTimelockDepositTo(operator, to, amount, controlledToken, data);\n\n    emit TimelockDeposited(operator, to, controlledToken, amount);\n  }\n\n  /// @notice Deposit assets into the Prize Pool in exchange for tokens\n  /// @param to The address receiving the newly minted tokens\n  /// @param amount The amount of assets to deposit\n  /// @param controlledToken The address of the type of token the user is minting\n  /// @param data Call data to be passed to the Prize Strategy\n  function depositTo(\n    address to,\n    uint256 amount,\n    address controlledToken,\n    bytes calldata data\n  )\n    external\n    onlyControlledToken(controlledToken)\n    nonReentrant\n  {\n    require(_hasPrizeStrategy(), \"PrizePool/prize-strategy-detached\");\n\n    address operator = _msgSender();\n\n    ControlledToken(controlledToken).controllerMint(to, amount);\n    require(_token().transferFrom(operator, address(this), amount), \"PrizePool/deposit-transfer-failed\");\n    _supply(amount);\n\n    prizeStrategy.afterDepositTo(to, amount, controlledToken, data);\n\n    emit Deposited(operator, to, controlledToken, amount);\n  }\n\n  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.\n  /// @param from The address to redeem tokens from.\n  /// @param amount The amount of tokens to redeem for assets.\n  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)\n  /// @param sponsorAmount An optional amount of assets paid by the caller to cover exit fees\n  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This can be pre-calculated.\n  /// @return exitFee The amount of the fairness fee paid\n  function withdrawInstantlyFrom(\n    address from,\n    uint256 amount,\n    address controlledToken,\n    uint256 sponsorAmount,\n    uint256 maximumExitFee,\n    bytes calldata data\n  )\n    external\n    nonReentrant\n    onlyControlledToken(controlledToken)\n    returns (uint256 exitFee)\n  {\n\n    if (_hasPrizeStrategy()) {\n      exitFee = limitExitFee(amount, prizeStrategy.beforeWithdrawInstantlyFrom(from, amount, controlledToken, data));\n    }\n\n    uint256 maxFee = FixedPoint.multiplyUintByMantissa(amount, maxExitFeeMantissa);\n    if (exitFee > maxFee) {\n      exitFee = maxFee;\n    }\n    \n    require(exitFee <= maximumExitFee, \"PrizePool/exit-fee-exceeds-user-maximum\");\n\n    uint256 sponsoredExitFeePortion = (exitFee > sponsorAmount) ? sponsorAmount : exitFee;\n    uint256 userExitFee = exitFee.sub(sponsoredExitFeePortion);\n\n    if (sponsoredExitFeePortion > 0) {\n      // transfer the fee to this contract\n      require(_token().transferFrom(_msgSender(), address(this), sponsoredExitFeePortion), \"PrizePool/sponsor-transfer-failed\");\n    }\n\n    // burn the tickets\n    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);\n\n    // redeem the tickets less the fee\n    uint256 amountLessFee = amount.sub(userExitFee);\n    _redeem(amountLessFee);\n\n    require(_token().transfer(from, amountLessFee), \"PrizePool/instant-transfer-failed\");\n\n    if (_hasPrizeStrategy()) {\n      prizeStrategy.afterWithdrawInstantlyFrom(_msgSender(), from, amount, controlledToken, exitFee, sponsoredExitFeePortion, data);\n    }\n\n    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, exitFee, sponsoredExitFeePortion);\n  }\n\n  function limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {\n    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);\n    if (exitFee > maxFee) {\n      exitFee = maxFee;\n    }\n    return exitFee;\n  }\n\n  /// @notice Withdraw assets from the Prize Pool by placing them into the timelock.\n  /// @dev The timelock is used to ensure that the tickets have contributed their fair share of the prize.\n  /// @param from The address to withdraw from\n  /// @param amount The amount to withdraw\n  /// @param controlledToken The type of token being withdrawn\n  /// @return unlockTimestamp The timestamp after which the funds can be swept\n  function withdrawWithTimelockFrom(\n    address from,\n    uint256 amount,\n    address controlledToken,\n    bytes calldata data\n  )\n    external\n    nonReentrant\n    onlyControlledToken(controlledToken)\n    returns (uint256 unlockTimestamp)\n  {\n    uint256 blockTime = _currentTime();\n\n    if (_hasPrizeStrategy()) {\n      unlockTimestamp = prizeStrategy.beforeWithdrawWithTimelockFrom(from, amount, controlledToken, data);\n    }\n\n    uint256 lockDuration = unlockTimestamp > blockTime ? unlockTimestamp.sub(blockTime) : 0;\n    if (lockDuration > maxTimelockDuration) {\n      unlockTimestamp = blockTime.add(maxTimelockDuration);\n    }\n\n    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);\n    _mintTimelock(from, amount, unlockTimestamp);\n\n    if (_hasPrizeStrategy()) {\n      prizeStrategy.afterWithdrawWithTimelockFrom(from, amount, controlledToken, data);\n    }\n\n    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);\n\n    // return the block at which the funds will be available\n    return unlockTimestamp;\n  }\n\n  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {\n    // Sweep the old balance, if any\n    address[] memory users = new address[](1);\n    users[0] = user;\n    _sweepTimelockBalances(users);\n\n    timelockTotalSupply = timelockTotalSupply.add(amount);\n    timelockBalances[user] = timelockBalances[user].add(amount);\n    unlockTimestamps[user] = timestamp;\n\n    // if the funds should already be unlocked\n    if (timestamp <= _currentTime()) {\n      _sweepTimelockBalances(users);\n    }\n  }\n\n  /// @notice Updates the Prize Strategy when tokens are transferred between holders.  Only transfers, not minting or burning.\n  /// @param from The address the tokens are being transferred from\n  /// @param to The address the tokens are being transferred to\n  /// @param amount The amount of tokens being trasferred\n  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {\n    // minting and redeeming are handled separately\n    if (from != address(0) && to != address(0) && _hasPrizeStrategy()) {\n      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);\n    }\n  }\n\n  /// @notice Updates and returns the current prize.\n  /// @dev Updates the internal rolling interest rate since the last poke\n  /// @return award The total amount of assets to be awarded for the current prize\n  function awardBalance() public returns (uint256 award) {\n    uint256 tokenTotalSupply = _tokenTotalSupply();\n    uint256 bal = _balance();\n\n    if (bal > tokenTotalSupply) {\n      return bal.sub(tokenTotalSupply);\n    } else {\n      return 0;\n    }\n  }\n\n  /// @notice Called by the Prize-Strategy to Award a Prize to a specific account\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of assets to be awarded\n  /// @param controlledToken The addess of the asset token being awarded\n  function award(\n    address to,\n    uint256 amount,\n    address controlledToken\n  )\n    external\n    onlyPrizeStrategy\n    onlyControlledToken(controlledToken)\n  {\n    if (amount == 0) {\n      return;\n    }\n\n    require(amount <= awardBalance(), \"PrizePool/award-exceeds-avail\");\n    ControlledToken(controlledToken).controllerMint(to, amount);\n\n    emit Awarded(to, controlledToken, amount);\n  }\n\n  /// @notice Called by the Prize-Strategy to Award Secondary (external) Prize amounts to a specific account\n  /// @dev Used to award any arbitrary tokens held by the Prize Pool\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of external assets to be awarded\n  /// @param externalToken The addess of the external asset token being awarded\n  function awardExternalERC20(\n    address to,\n    address externalToken,\n    uint256 amount\n  )\n    external\n    onlyPrizeStrategy\n  {\n    require(_canAwardExternal(externalToken), \"PrizePool/invalid-external-token\");\n\n    if (amount == 0) {\n      return;\n    }\n\n    require(IERC20(externalToken).transfer(to, amount), \"PrizePool/award-ex-erc20-failed\");\n\n    emit AwardedExternalERC20(to, externalToken, amount);\n  }\n\n  /// @notice Called by the Prize-Strategy to Award Secondary (external) Prize NFTs to a specific account\n  /// @dev Used to award any arbitrary NFTs held by the Prize Pool\n  /// @param to The address of the winner that receives the award\n  /// @param externalToken The addess of the external NFT token being awarded\n  /// @param tokenIds An array of NFT Token IDs to be transferred\n  function awardExternalERC721(\n    address to,\n    address externalToken,\n    uint256[] calldata tokenIds\n  )\n    external\n    onlyPrizeStrategy\n  {\n    require(_canAwardExternal(externalToken), \"PrizePool/invalid-external-token\");\n\n    if (tokenIds.length == 0) {\n      return;\n    }\n\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      IERC721(externalToken).transferFrom(address(this), to, tokenIds[i]);\n    }\n\n    emit AwardedExternalERC721(to, externalToken, tokenIds);\n  }\n\n  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts\n  /// @param users An array of account addresses to sweep balances for\n  /// @return totalWithdrawal The total amount of assets swept from the Prize Pool\n  function sweepTimelockBalances(\n    address[] calldata users\n  )\n    external\n    nonReentrant\n    returns (uint256 totalWithdrawal)\n  {\n    totalWithdrawal = _sweepTimelockBalances(users);\n  }\n\n  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts\n  /// @param users An array of account addresses to sweep balances for\n  /// @return totalWithdrawal The total amount of assets swept from the Prize Pool\n  function _sweepTimelockBalances(\n    address[] memory users\n  )\n    internal\n    returns (uint256 totalWithdrawal)\n  {\n    address operator = _msgSender();\n\n    // first gather the total withdrawal and fee\n    totalWithdrawal = _calculateTotalForSweep(users);\n    // if there is nothing to do, just quit\n    if (totalWithdrawal == 0) {\n      return 0;\n    }\n\n    _redeem(totalWithdrawal);\n\n    BalanceChange[] memory changes = new BalanceChange[](users.length);\n\n    IERC20 underlyingToken = IERC20(_token());\n    uint256 i;\n    for (i = 0; i < users.length; i++) {\n      address user = users[i];\n      if (unlockTimestamps[user] <= _currentTime()) {\n        uint256 userBalance = timelockBalances[user];\n        if (userBalance > 0) {\n          timelockTotalSupply = timelockTotalSupply.sub(userBalance);\n          delete timelockBalances[user];\n          delete unlockTimestamps[user];\n          require(underlyingToken.transfer(user, userBalance), \"PrizePool/sweep-transfer-failed\");\n          emit TimelockedWithdrawalSwept(operator, user, userBalance);\n        }\n        changes[i] = BalanceChange(user, userBalance);\n      } else {\n        changes[i] = BalanceChange(user, 0);\n      }\n    }\n\n    // Update prize strategy after sweep\n    _updateAfterSweep(changes, operator);\n  }\n\n  /// @dev Calculates the total amount of unlocked assets available to be withdrawn via Sweep\n  /// @param users An array of account addresses to sweep balances for\n  /// @return totalWithdrawal The total amount of assets that can be swept from the Prize Pool\n  function _calculateTotalForSweep(address[] memory users) internal view returns (uint256 totalWithdrawal) {\n    for (uint256 i = 0; i < users.length; i++) {\n      address user = users[i];\n      if (unlockTimestamps[user] <= _currentTime()) {\n        totalWithdrawal = totalWithdrawal.add(timelockBalances[user]);\n      }\n    }\n  }\n\n  /// @dev Updates the Prize Strategy after a sweep has been performed on timelocked balances\n  /// @param changes An array of user-balance changes\n  /// @param operator The address of the operator performing the update\n  function _updateAfterSweep(BalanceChange[] memory changes, address operator) internal {\n    if (!_hasPrizeStrategy()) { return; }\n\n    for (uint256 i = 0; i < changes.length; i++) {\n      BalanceChange memory change = changes[i];\n      if (change.balance > 0) {\n        prizeStrategy.afterSweepTimelockedWithdrawal(operator, change.user, change.balance);\n      }\n    }\n  }\n\n  /// @notice Allows the Governor to add Controlled Tokens to the Prize Pool\n  /// @param _controlledToken The address of the Controlled Token to add\n  function addControlledToken(address _controlledToken) external onlyOwner {\n    require(ControlledToken(_controlledToken).controller() == this, \"PrizePool/token-ctrlr-mismatch\");\n    _tokens.addAddress(_controlledToken);\n  }\n\n  /// @notice Emergency shutdown of the Prize Pool by detaching the Prize Strategy\n  /// @dev Called by the PrizeStrategy contract to issue an Emergency Shutdown of a corrupted Prize Strategy\n  function detachPrizeStrategy() external onlyOwner {\n    delete prizeStrategy;\n    emit PrizeStrategyDetached();\n  }\n\n  /// @notice Check if the Prize Pool has an active Prize Strategy\n  /// @dev When the prize strategy is detached deposits are disabled, and only withdrawals are permitted\n  function _hasPrizeStrategy() internal view returns (bool) {\n    return (address(prizeStrategy) != address(0x0));\n  }\n\n  /// @notice An array of the Tokens controlled by the Prize Pool (ie. Tickets, Sponsorship)\n  /// @return controlledTokens An array of controlled token addresses\n  function tokens() external view returns (address[] memory controlledTokens) {\n    return _tokens.addressArray();\n  }\n\n  /// @dev Gets the current time as represented by the current block\n  /// @return timestamp The timestamp of the current block\n  function _currentTime() internal virtual view returns (uint256 timestamp) {\n    return block.timestamp;\n  }\n\n  /// @notice The timestamp at which an accounts timelocked balance will be made available\n  /// @param user The address of an account with timelocked assets\n  /// @return unlockTimestamp The timestamp at which the locked assets will be made available\n  function timelockBalanceAvailableAt(address user) external view returns (uint256 unlockTimestamp) {\n    return unlockTimestamps[user];\n  }\n\n  /// @notice The balance of timelocked assets for an account\n  /// @param user The address of an account with timelocked assets\n  /// @return timelockBalance The amount of assets that have been timelocked\n  function timelockBalanceOf(address user) external view returns (uint256 timelockBalance) {\n    return timelockBalances[user];\n  }\n\n  /// @notice The currently accounted-for balance in relation to the rolling exchange-rate\n  /// @return totalAccounted The currently accounted-for balance\n  function accountedBalance() external view returns (uint256 totalAccounted) {\n    return _tokenTotalSupply();\n  }\n\n  /// @dev The currently accounted-for balance in relation to the rolling exchange-rate\n  /// @return total The currently accounted-for balance\n  function _tokenTotalSupply() internal view returns (uint256 total) {\n    total = timelockTotalSupply;\n    address currentToken = _tokens.addressMap[MappedSinglyLinkedList.SENTINAL];\n    while (currentToken != address(0) && currentToken != MappedSinglyLinkedList.SENTINAL) {\n      total = total.add(IERC20(currentToken).totalSupply());\n      currentToken = _tokens.addressMap[currentToken];\n    }\n  }\n\n  /// @dev Checks if a specific token is controlled by the Prize Pool\n  /// @param controlledToken The address of the token to check\n  /// @return True if the token is a controlled token, false otherwise\n  function isControlled(address controlledToken) internal view returns (bool) {\n    return _tokens.contains(controlledToken);\n  }\n\n  function _msgSender() internal override(BaseRelayRecipient, ContextUpgradeSafe) virtual view returns (address payable) {\n    return BaseRelayRecipient._msgSender();\n  }\n\n  /// @dev Function modifier to ensure usage of tokens controlled by the Prize Pool\n  /// @param controlledToken The address of the token to check\n  modifier onlyControlledToken(address controlledToken) {\n    require(isControlled(controlledToken), \"PrizePool/unknown-token\");\n    _;\n  }\n\n  /// @dev Function modifier to ensure caller is the prize-strategy\n  modifier onlyPrizeStrategy() {\n    require(msg.sender == address(prizeStrategy), \"PrizePool/only-prizeStrategy\");\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/prize-pool/PrizePool.sol",
      "content": "pragma solidity 0.6.4;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol\";\nimport \"@pooltogether/fixed-point/contracts/FixedPoint.sol\";\n\nimport \"../prize-strategy/PrizeStrategyInterface.sol\";\nimport \"../token/ControlledToken.sol\";\nimport \"../token/TokenControllerInterface.sol\";\nimport \"../utils/MappedSinglyLinkedList.sol\";\nimport \"../utils/RelayRecipient.sol\";\n\n/// @title Base Prize Pool for managing escrowed assets\n/// @notice Manages depositing and withdrawing assets from the Prize Pool\n/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\nabstract contract PrizePool is OwnableUpgradeSafe, RelayRecipient, ReentrancyGuardUpgradeSafe, TokenControllerInterface {\n  using SafeMath for uint256;\n  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;\n\n  /// @dev Helpful data structure to organize timelock sweeps\n  struct BalanceChange {\n    address user;\n    uint256 balance;\n  }\n\n  /// @dev Event emitted when assets are deposited\n  event Deposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when timelocked funds are re-deposited\n  event TimelockDeposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when interest is awarded to a winner\n  event Awarded(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n  \n  /// @dev Event emitted when external ERC20s are awarded to a winner\n  event AwardedExternalERC20(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC721s are awarded to a winner\n  event AwardedExternalERC721(\n    address indexed winner,\n    address indexed token,\n    uint256[] tokenIds\n  );\n  \n  /// @dev Event emitted when assets are withdrawn instantly\n  event InstantWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 exitFee,\n    uint256 sponsoredExitFee\n  );\n  \n  /// @dev Event emitted when assets are withdrawn into a timelock\n  event TimelockedWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 unlockTimestamp\n  );\n  \n  /// @dev Event emitted when timelocked funds are swept back to a user\n  event TimelockedWithdrawalSwept(\n    address indexed operator,\n    address indexed from,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when the prize strategy is detached from the Prize Pool.\n  event PrizeStrategyDetached();\n\n  /// @dev A linked list of all the controlled tokens\n  MappedSinglyLinkedList.Mapping internal _tokens;\n\n  /// @dev The Prize Strategy that this Prize Pool is bound to.\n  PrizeStrategyInterface public prizeStrategy;\n\n  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.\n  /// For example, if the maxExitFeeMantissa is \"0.1 ether\", then the maximum exit fee for a withdrawal of 100 will be 10.\n  uint256 public maxExitFeeMantissa;\n\n  /// @dev The maximum possible timelock duration for a timelocked withdrawal.\n  uint256 public maxTimelockDuration;\n\n  /// @dev The total funds that are timelocked.\n  uint256 public timelockTotalSupply;\n\n  /// @dev The timelocked balances for each user\n  mapping(address => uint256) internal timelockBalances;\n\n  /// @dev The unlock timestamps for each user\n  mapping(address => uint256) internal unlockTimestamps;\n\n  /// @notice Initializes the Prize Pool with required contract connections\n  /// @param _trustedForwarder Address of the Forwarding Contract for GSN Meta-Txs\n  /// @param _prizeStrategy Address of the component-controller that manages the prize-strategy\n  /// @param _controlledTokens Array of addresses for the Ticket and Sponsorship Tokens controlled by the Prize Pool\n  /// @param _maxExitFeeMantissa The maximum exit fee size, relative to the withdrawal amount\n  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock could be\n  function initialize (\n    address _trustedForwarder,\n    PrizeStrategyInterface _prizeStrategy,\n    address[] memory _controlledTokens,\n    uint256 _maxExitFeeMantissa,\n    uint256 _maxTimelockDuration\n  )\n    public\n    initializer\n  {\n    require(address(_prizeStrategy) != address(0), \"PrizePool/prizeStrategy-zero\");\n    require(_trustedForwarder != address(0), \"PrizePool/forwarder-zero\");\n    _tokens.initialize(_controlledTokens);\n    for (uint256 i = 0; i < _controlledTokens.length; i++) {\n      require(ControlledToken(_controlledTokens[i]).controller() == this, \"PrizePool/token-ctrlr-mismatch\");\n    }\n    __Ownable_init();\n    __ReentrancyGuard_init();\n    trustedForwarder = _trustedForwarder;\n    prizeStrategy = _prizeStrategy;\n    maxExitFeeMantissa = _maxExitFeeMantissa;\n    maxTimelockDuration = _maxTimelockDuration;\n  }\n\n  /// @dev Inheriting contract must determine if a specific token type may be awarded as a prize enhancement\n  /// @param _externalToken The address of the token to check\n  /// @return True if the token may be awarded, false otherwise\n  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);\n\n  /// @dev Inheriting contract must return an interface to the underlying asset token that conforms to the ERC20 spec\n  /// @return A reference to the interface of the underling asset token\n  function _token() internal virtual view returns (IERC20);\n\n  /// @dev Inheriting contract must return the balance of the underlying assets held by the Yield Service\n  /// @return The underlying balance of asset tokens\n  function _balance() internal virtual returns (uint256);\n\n  /// @dev Inheriting contract must provide the ability to supply asset tokens in exchange\n  /// for yield-bearing tokens to be held in escrow by the Yield Service\n  /// @param mintAmount The amount of asset tokens to be supplied\n  function _supply(uint256 mintAmount) internal virtual;\n\n  /// @dev Inheriting contract must provide the ability to redeem yield-bearing tokens in exchange\n  /// for the underlying asset tokens held in escrow by the Yield Service\n  /// @param redeemAmount The amount of yield-bearing tokens to be redeemed\n  function _redeem(uint256 redeemAmount) internal virtual;\n\n  /// @dev Inheriting contract must provide an estimate for the amount of accrued interest that would\n  /// be applied to the `principal` amount over a given number of `blocks`\n  /// @param principal The amount of asset tokens to provide an estimate on\n  /// @param blocks The number of blocks that the principal would accrue interest over\n  /// @return The estimated interest that would accrue on the principal\n  function estimateAccruedInterestOverBlocks(uint256 principal, uint256 blocks) public virtual view returns (uint256);\n\n  /// @dev Gets the underlying asset token used by the Yield Service\n  /// @return A reference to the interface of the underling asset token\n  function token() external virtual view returns (IERC20) {\n    return _token();\n  }\n\n  /// @dev Gets the balance of the underlying assets held by the Yield Service\n  /// @return The underlying balance of asset tokens\n  function balance() external virtual returns (uint256) {\n    return _balance();\n  }\n\n  /// @dev Checks with the Prize Pool if a specific token type may be awarded as a prize enhancement\n  /// @param _externalToken The address of the token to check\n  /// @retur"
    }
  ]
}