{
  "Title": "[M-07] `stakerewardV2pool.withdraw()` should check the user's boost lock status.",
  "Content": "\nUsers can withdraw their staking token immediately after charging more rewards using boost.\n\n### Proof of Concept\n\n`withdraw()` should prevent withdrawals during the boost lock, but there is no such logic.\n\nThe below steps show how users can charge more rewards without locking their funds.\n\n1.  Alice stakes their funds using [stake()](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/stakerewardV2pool.sol#L83).\n2.  They set the longest lock duration to get the highest boost using [setLockStatus()](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/esLBRBoost.sol#L38).\n3.  After that, when they want to withdraw their staking funds, they call [withdraw()](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/stakerewardV2pool.sol#L93).\n\n```solidity\n    function withdraw(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n        emit WithdrawToken(msg.sender, _amount, block.timestamp);\n    }\n```\n\n4.  Then, the highest boost factor will be applied to their rewards in [earned()](https://github.com/code-423n4/2023-06-lybra/blob/5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6/contracts/lybra/miner/stakerewardV2pool.sol#L106) and they can withdraw all of their staking funds and rewards immediately without checking any lock duration.\n\n```solidity\n    // Calculates and returns the earned rewards for a user\n    function earned(address _account) public view returns (uint256) {\n        return ((balanceOf[_account] * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n```\n\n### Tools Used\n\nManual Review\n\n### Recommended Mitigation Steps\n\n`withdraw()` should check the boost lock like this:\n\n```solidity\n    function withdraw(uint256 _amount) external updateReward(msg.sender) {\n        require(block.timestamp >= esLBRBoost.getUnlockTime(msg.sender), \"Your lock-in period has not ended.\");\n\n        require(_amount > 0, \"amount = 0\");\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n        emit WithdrawToken(msg.sender, _amount, block.timestamp);\n    }\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[LybraFinance acknowledged](https://github.com/code-423n4/2023-06-lybra-findings/issues/773#issuecomment-1635523068)**\n\n**[0xean (judge) decreased severity to Medium](https://github.com/code-423n4/2023-06-lybra-findings/issues/773#issuecomment-1655658314)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/stakerewardV2pool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract StakingRewardsV2 is Ownable {\n    // Immutable variables for staking and rewards tokens\n    IERC20 public immutable stakingToken;\n    IesLBR public immutable rewardsToken;\n    IesLBRBoost public esLBRBoost;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n\n    // Total staked\n    uint256 public totalSupply;\n    // User address => staked amount\n    mapping(address => uint256) public balanceOf;\n\n    ///events\n    event StakeToken(address indexed user, uint256 amount, uint256 time);\n    event WithdrawToken(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    constructor(address _stakingToken, address _rewardToken, address _boost) {\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IesLBR(_rewardToken);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    // Update user's claimable reward data and record the timestamp.\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    // Returns the last time the reward was applicable\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    // Calculates and returns the reward per token\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalSupply;\n    }\n\n    // Allows users to stake a specified amount of tokens\n    function stake(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        bool success = stakingToken.transferFrom(msg.sender, address(this), _amount);\n        require(success, \"TF\");\n        balanceOf[msg.sender] += _amount;\n        totalSupply += _amount;\n        emit StakeToken(msg.sender, _amount, block.timestamp);\n    }\n\n    // Allows users to withdraw a specified amount of staked tokens\n    function withdraw(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n        emit WithdrawToken(msg.sender, _amount, block.timestamp);\n    }\n\n    function getBoost(address _account) public view returns (uint256) {\n        return 100 * 1e18 + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    // Calculates and returns the earned rewards for a user\n    function earned(address _account) public view returns (uint256) {\n        return ((balanceOf[_account] * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    // Allows users to claim their earned rewards\n    function getReward() external updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    // Allows the owner to set the rewards duration\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    // Allows the owner to set the boost contract address\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    // Allows the owner to set the mining rewards.\n    function notifyRewardAmount(uint256 _amount) external onlyOwner updateReward(address(0)) {\n        if (block.timestamp >= finishAt) {\n            rewardRatio = _amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (_amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(_amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/esLBRBoost.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract esLBRBoost is Ownable {\n    esLBRLockSetting[] public esLBRLockSettings;\n    mapping(address => LockStatus) public userLockStatus;\n\n    // Define a struct for the lock settings\n    struct esLBRLockSetting {\n        uint256 duration;\n        uint256 miningBoost;\n    }\n\n    // Define a struct for the user's lock status\n    struct LockStatus {\n        uint256 unlockTime;\n        uint256 duration;\n        uint256 miningBoost;\n    }\n\n    // Constructor to initialize the default lock settings\n    constructor() {\n        esLBRLockSettings.push(esLBRLockSetting(30 days, 20 * 1e18));\n        esLBRLockSettings.push(esLBRLockSetting(90 days, 30 * 1e18));\n        esLBRLockSettings.push(esLBRLockSetting(180 days, 50 * 1e18));\n        esLBRLockSettings.push(esLBRLockSetting(365 days, 100 * 1e18));\n    }\n\n    // Function to add a new lock setting\n    function addLockSetting(esLBRLockSetting memory setting) external onlyOwner {\n        esLBRLockSettings.push(setting);\n    }\n\n    // Function to set the user's lock status\n    function setLockStatus(uint256 id) external {\n        esLBRLockSetting memory _setting = esLBRLockSettings[id];\n        LockStatus memory userStatus = userLockStatus[msg.sender];\n        if (userStatus.unlockTime > block.timestamp) {\n            require(userStatus.duration <= _setting.duration, \"Your lock-in period has not ended, and the term can only be extended, not reduced.\");\n        }\n        userLockStatus[msg.sender] = LockStatus(block.timestamp + _setting.duration, _setting.duration, _setting.miningBoost);\n    }\n\n    // Function to get the user's unlock time\n    function getUnlockTime(address user) external view returns (uint256 unlockTime) {\n        unlockTime = userLockStatus[user].unlockTime;\n    }\n\n    /**\n     * @notice calculate the user's mining boost based on their lock status\n     * @dev Based on the user's userUpdatedAt time, finishAt time, and the current time,\n     * there are several scenarios that could occur, including no acceleration, full acceleration, and partial acceleration.\n     */\n    function getUserBoost(address user, uint256 userUpdatedAt, uint256 finishAt) external view returns (uint256) {\n        uint256 boostEndTime = userLockStatus[user].unlockTime;\n        uint256 maxBoost = userLockStatus[user].miningBoost;\n        if (userUpdatedAt >= boostEndTime || userUpdatedAt >= finishAt) {\n            return 0;\n        }\n        if (finishAt <= boostEndTime || block.timestamp <= boostEndTime) {\n            return maxBoost;\n        } else {\n            uint256 time = block.timestamp > finishAt ? finishAt : block.timestamp;\n            return ((boostEndTime - userUpdatedAt) * maxBoost) / (time - userUpdatedAt);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/stakerewardV2pool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract StakingRewardsV2 is Ownable {\n    // Immutable variables for staking and rewards tokens\n    IERC20 public immutable stakingToken;\n    IesLBR public immutable rewardsToken;\n    IesLBRBoost public esLBRBoost;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n\n    // Total staked\n    uint256 public totalSupply;\n    // User address => staked amount\n    mapping(address => uint256) public balanceOf;\n\n    ///events\n    event StakeToken(address indexed user, uint256 amount, uint256 time);\n    event WithdrawToken(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    constructor(address _stakingToken, address _rewardToken, address _boost) {\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IesLBR(_rewardToken);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    // Update user's claimable reward data and record the timestamp.\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    // Returns the last time the reward was applicable\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    // Calculates and returns the reward per token\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalSupply;\n    }\n\n    // Allows users to stake a specified amount of tokens\n    function stake(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        bool success = stakingToken.transferFrom(msg.sender, address(this), _amount);\n        require(success, \"TF\");\n        balanceOf[msg.sender] += _amount;\n        totalSupply += _amount;\n        emit StakeToken(msg.sender, _amount, block.timestamp);\n    }\n\n    // Allows users to withdraw a specified amount of staked tokens\n    function withdraw(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n        emit WithdrawToken(msg.sender, _amount, block.timestamp);\n    }\n\n    function getBoost(address _account) public view returns (uint256) {\n        return 100 * 1e18 + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    // Calculates and returns the earned rewards for a user\n    function earned(address _account) public view returns (uint256) {\n        return ((balanceOf[_account] * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    // Allows users to claim their earned rewards\n    function getReward() external updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    // Allows the owner to set the rewards duration\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    // Allows the owner to set the boost contract address\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    // Allows the owner to set the mining rewards.\n    function notifyRewardAmount(uint256 _amount) external onlyOwner updateReward(address(0)) {\n        if (block.timestamp >= finishAt) {\n            rewardRatio = _amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (_amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(_amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    },
    {
      "filename": "contracts/lybra/miner/stakerewardV2pool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract StakingRewardsV2 is Ownable {\n    // Immutable variables for staking and rewards tokens\n    IERC20 public immutable stakingToken;\n    IesLBR public immutable rewardsToken;\n    IesLBRBoost public esLBRBoost;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n\n    // Total staked\n    uint256 public totalSupply;\n    // User address => staked amount\n    mapping(address => uint256) public balanceOf;\n\n    ///events\n    event StakeToken(address indexed user, uint256 amount, uint256 time);\n    event WithdrawToken(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    constructor(address _stakingToken, address _rewardToken, address _boost) {\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IesLBR(_rewardToken);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    // Update user's claimable reward data and record the timestamp.\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    // Returns the last time the reward was applicable\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    // Calculates and returns the reward per token\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalSupply;\n    }\n\n    // Allows users to stake a specified amount of tokens\n    function stake(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        bool success = stakingToken.transferFrom(msg.sender, address(this), _amount);\n        require(success, \"TF\");\n        balanceOf[msg.sender] += _amount;\n        totalSupply += _amount;\n        emit StakeToken(msg.sender, _amount, block.timestamp);\n    }\n\n    // Allows users to withdraw a specified amount of staked tokens\n    function withdraw(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n        emit WithdrawToken(msg.sender, _amount, block.timestamp);\n    }\n\n    function getBoost(address _account) public view returns (uint256) {\n        return 100 * 1e18 + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    // Calculates and returns the earned rewards for a user\n    function earned(address _account) public view returns (uint256) {\n        return ((balanceOf[_account] * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    // Allows users to claim their earned rewards\n    function getReward() external updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    // Allows the owner to set the rewards duration\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    // Allows the owner to set the boost contract address\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    // Allows the owner to set the mining rewards.\n    function notifyRewardAmount(uint256 _amount) external onlyOwner updateReward(address(0)) {\n        if (block.timestamp >= finishAt) {\n            rewardRatio = _amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (_amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(_amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    }
  ]
}