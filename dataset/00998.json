{
  "Title": "M-4: fulfillRandomWords() could revert under certain circumstances",
  "Content": "# Issue M-4: fulfillRandomWords() could revert under certain circumstances \n\nSource: https://github.com/sherlock-audit/2023-10-looksrare-judging/issues/136 \n\n## Found by \nge6a, klaus, p-tsanev\n\nAccording the documentation of Chainlink VRF the max gas limit for the VRF coordinator is 2 500 000. This means that the max gas that fulfillRandomWords() can use is 2 500 000 and if it is exceeded the function would revert. I have constructed a proof of concept that demonstrates it is possible to have a scenario in which fulfillRandomWords reverts and thereby disrupts the protocol's work.\n\n## Vulnerability Detail\n\nCrucial part of my POC is the variable AGENTS_TO_WOUND_PER_ROUND_IN_BASIS_POINTS. I communicated with the protocol's team that they plan to set it to 20 initially but it is possible to have a different value for it in future. For the POC i used 30.\n\n```solidity\nfunction test_fulfillRandomWords_revert() public {\n        _startGameAndDrawOneRound();\n\n        _drawXRounds(48);\n        \n        uint256 counter = 0;\n        uint256[] memory wa = new uint256[](30);\n        uint256 totalCost = 0;\n\n        for (uint256 j=2; j <= 6; j++) \n        {\n            (uint256[] memory woundedAgentIds, ) = infiltration.getRoundInfo({roundId: j});\n\n            uint256[] memory costs = new uint256[](woundedAgentIds.length);\n            for (uint256 i; i < woundedAgentIds.length; i++) {\n                costs[i] = HEAL_BASE_COST;\n                wa[counter] = woundedAgentIds[i];\n                counter++;\n                if(counter > 29) break;\n            }\n\n            if(counter > 29) break;\n        }\n        \n        \n        totalCost = HEAL_BASE_COST * wa.length;\n        looks.mint(user1, totalCost);\n\n        vm.startPrank(user1);\n        _grantLooksApprovals();\n        looks.approve(TRANSFER_MANAGER, totalCost);\n\n\n        infiltration.heal(wa);\n        vm.stopPrank();\n\n        _drawXRounds(1);\n    }\n```\n\nI put this test into Infiltration.startNewRound.t.sol and used --gas-report to see that the gas used for fulfillRandomWords exceeds 2 500 000.\n\n## Impact\n\nDOS of the protocol and inability to continue the game.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-looksrare/blob/main/contracts-infiltration/contracts/Infiltration.sol#L1096-L1249\nhttps://docs.chain.link/vrf/v2/subscription/supported-networks/#ethereum-mainnet\nhttps://docs.chain.link/vrf/v2/security#fulfillrandomwords-must-not-revert\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nA couple of ideas : \n\n1) You can limit the value of AGENTS_TO_WOUND_PER_ROUND_IN_BASIS_POINTS to a small enough number so that it is 100% sure it will not reach the gas limit.\n\n2) Consider simply storing the randomness and taking more complex follow-on actions in separate contract calls as stated in the \"Security Considerations\" section of the VRF's docs. \n\n\n\n## Discussion\n\n**nevillehuang**\n\n[Accepted risks](https://github.com/sherlock-audit/2023-10-looksrare#q-please-list-any-known-issuesacceptable-risks-that-should-not-result-in-a-valid-finding), the **KEYWORDS** here are: \n- **periods of network congestion** --> this causes the hard code gas fallback to revert --> accepted risk\n- **Any reason causing randomness request to not be fufilled** --> If request for randomness is not fufilled due to ANY reason, even if highilighted in a submission, it is not a accepted finding since it is an accepted risk LooksRare are willing to take\n\n> In the case of extended periods of network congestion or any reason causing the randomness request not to be fulfilled, the contract owner is able to withdraw everything after approximately 36 hours.\n\n**gstoyanovbg**\n\nEscalate\nI disagree with the comment of @nevillehuang . Imagine a situation in which you start a game with 10,000 participants, go through many rounds, and at one point, the game stops and cannot continue. As far as I understand, the judge's claim is that the funds can be withdrawn after a certain time, which is true. However, will the gas fees be returned to all users who have healed agents or traded them on the open market in some way? And what about the time that the players have devoted to winning a game that suddenly stops due to a bug and cannot continue? Every player may have claims for significant missed benefits (and losses from gas fees). Now, imagine that this continues to happen again and again in some of the subsequent games. Will anyone even invest time and resources to play this game? My request to the judges is to review my report again because it has nothing to do with 'periods of network congestion' as stated and this issue is not listed under the \"Accepted risks\" section. \nThanks.\nP.S During the contest i discussed this with the sponsor and confirmed that this is an issue (probably doesn't matter but wanted to mention it)\n\n**sherlock-admin2**\n\n > Escalate\n> I disagree with the comment of @nevillehuang . Imagine a situation in which you start a game with 10,000 participants, go through many rounds, and at one point, the game stops and cannot continue. As far as I understand, the judge's claim is that the funds can be withdrawn after a certain time, which is true. However, will the gas fees be returned to all users who have healed agents or traded them on the open market in some way? And what about the time that the players have devoted to winning a game that suddenly stops due to a bug and cannot continue? Every player may have claims for significant missed benefits (and losses from gas fees). Now, imagine that this continues to happen again and again in some of the subsequent games. Will anyone even invest time and resources to play this game? My request to the judges is to review my report again because it has nothing to do with 'periods of network congestion' as stated and this issue is not listed under the \"Accepted risks\" section. \n> Thanks.\n> P.S During the contest i discussed this with the sponsor and confirmed that this is an issue (probably doesn't matter but wanted to mention it)\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**PlamenTSV**\n\nEscalate\nMy issue 107 is the same and I agree with the above statement, as this is not an occurance that can randomly happen once, depending on potential parameter changes it can become extremely likely to happen every time. If every game has a high chance to get permanently dosed, even if emergency withdrawal is available, the game itself becomes unplayable.\nThe accepted risks cover network congestion and the 36 period, but that period does not solve the insolvency, it just refunds some funds, not even everything that costed players and congestion is not the cause, but the badly gas optimized function. \n\n**sherlock-admin2**\n\n > Escalate\n> My issue 107 is the same and I agree with the above statement, as this is not an occurance that can randomly happen once, depending on potential parameter changes it can become extremely likely to happen every time. If every game has a high chance to get permanently dosed, even if emergency withdrawal is available, the game itself becomes unplayable.\n> The accepted risks cover network congestion and the 36 period, but that period does not solve the insolvency, it just refunds some funds, not even everything that costed players and congestion is not the cause, but the badly gas optimized function. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nThis is the only comment I will make about this submission, and I will leave the rest up to @nasri136 @Evert0x . \n\nI agree this is a valid issue, but the fact is in the accepted risk section it mentions that ANY and i repeat ANY issue not just network congestion causing randomness request to fail is an accepted risk. If the game is not completed, then admin can always call `emergencyWithdraw()`, so as long as this function is not DoSed (which is not possible unless game has ended), then I am simply following sherlocks [rules](https://docs.sherlock.xyz/audits/judging/judging#iii.-some-standards-observed):\n\n> Hierarchy of truth: Contest README > Sherlock rules for valid issues > Historical decisions. \nWhile considering the validity of an issue in case of any conflict the sources of truth are prioritized in the above order. \nFor example: In case of conflict between Sherlock rules vs Sherlock's historical decision,  Sherlock criteria for issues must be considered the source of truth. \nIn case of conflict between information in the README vs Sherlock rules, the README overrides Sherlock rules. \n\nAnd yes private/discord messages does not matter: \n\n> Discord messages or DM screenshots are not considered sources of truth while judging an issue/escalation especially if they are conflicting with the contest README.\n\n**gstoyanovbg**\n\nI understand your point. However, still believe that the 'Accepted Risks' section is not formulated well enough, and this case should definitely be excluded from its scope. I am aware of Sherlock's rules, but in my opinion, there are nuances even in them, and they cannot be 100% accurate for all situations. \nI see that report #107 by @PlamenTSV, which is same issue as this, has labels \"Sponsor Confirmed\" and \"Will fix.\" Also, @0xhiroshi has made a pull request for a fix which makes me happy because at the end of the day our goal is to have a secure, bug free protocol. However, it sounds strange to claim that a vulnerability is an \"accepted risk\" but at the same time to fix it.  Looking forward for the final decision of the judges. If you have any questions, I am ready to assist.\n\n**nevillehuang**\n\n@gstoyanovbg I totally get your point too and agree with you. If I didnâ€™t have to follow sherlock rules, I would have side with the watsons and validated this finding. But the fact that in the accepted risks section they used the word ANY is too strong of a word for me to ignore.\n\n**PlamenTSV**\n\nDon't sherlock rules serve as a guideline?\nI hope most if not every watson that has read this issue agrees it is valid. The judges agree it is valid by severity and even the sponsors themselves want to fix it and deem it a valid finding.\nI think the reason the README is like this is because the protocol team did not expect that their protocol could have a DoS of this caliber - thus why they overlook the README and confirm the issue. It would be a shame to get robbed of a valid finding with no reward, worse ratio for the platform, but for the protocol to aknowledge and fix. There should be some kind of workaround for these kinds of scenarios. I believe that would be most fair and I hope you agree. If we could get a sherlock admin to give clarity to the situation it would be appreciated, thanks to everyone in the comments. \n\n**PlamenTSV**\n\n> This is the only comment I will make about this submission, and I will leave the rest up to @nasri136 @Evert0x .\n> \n> I agree this is a valid issue, but the fact is in the accepted risk section it mentions that ANY and i repeat ANY issue not just network congestion causing randomness request to fail is an accepted risk. If the game is not completed, then admin can always call `emergencyWithdraw()`, so as long as this function is not DoSed (which is not possible unless game has ended), then I am simply following sherlocks [rules](https://docs.sherlock.xyz/audits/judging/judging#iii.-some-standards-observed):\n> \n> > Hierarchy of truth: Contest README > Sherlock rules for valid issues > Historical decisions.\n> > While considering the validity of an issue in case of any conflict the sources of truth are prioritized in the above order.\n> > For example: In case of conflict between Sherlock rules vs Sherlock's historical decision,  Sherlock criteria for issues must be considered the source of truth.\n> > In case of conflict between information in the README vs Sherlock rules, the README overrides Sherlock rules.\n> \n> And yes private/discord messages does not matter:\n> \n> > Discord messages or DM screenshots are not considered sources of truth while judging an issue/escalation especially if they are conflicting with the contest README.\n\nOne thing to add while rereading this comment, shouldn't Sponsor final confirmation >>> contest readmi, exactly because some issue's severity can go overlooked, just like in the current case\n\n**nevillehuang**\n\nAfaik, Sponsor confirmation has never been the deciding factor for a finding. It has always been sherlock rules, contest details and the code itself. To note, this rules are introduce to ensure judging consistency in the first place.\n\nI agree that this finding is valid, and it is unfair to watsons for not being rewarded. But it is also very unfair to me for potentially having my judging points penalized because the source of ambiguity is not because of me. I think all watsons know judging is not easy, and the rules revolving judging is extremely strict. Even one miss finding by me will heavily penalize me.\n\nI leave this in the hands of @Evert0x @nasri136 and will respect any final outcome.\n\n**Czar102**\n\nFirst off, the status of whether the sponsor wants to fix the issue has nothing to do with its validity. Please don't use it as an argument of judgement.\n\nSecondly, I understand @nevillehuang about the strictness of the judging rules and potential payout issues. Will see what can I do about it in this case. The mechanism shouldn't bias you towards maintaining the current judgement, so if you have concerns with that, we can try to resolve those rewarding formula issues in DMs.\n\nAbout the issue, it is true that it is unfortunately conflicting with the README. I think we should rethink the way the docs describes the hierarchy of truth.\n\nAudits exist not only to show outright mistakes in the code. Auditors' role is to show that some properties (that are important to parties using the code) are not enforced or fulfilled. They need to think in a broader sense than the sponsors did, in order to provide any more insight above the technical one. Auditors need to teach sponsors not only about issues, but also about the impacts. \"Why is this property a problem?\"\n\nSponsors can't know what wording to use not to exclude the bugs they don't care about. Because that's not their job. It's our job to understand their needs. We work for them to secure their code. We tell them what do they need.\n\nWhat sponsors probably meant by \"any reason causing the randomness request not to be fulfilled\" is most likely \"any **external** reason causing the randomness request not to be fulfilled\". They didn't think it could be their contract causing this issue. I think some Watsons correctly identified what sponsors intended to convey and should be rewarded for submitting the issue.\n\nWill alter the docs to account for this kind of situations.\n\nCould you share your feedback on the above approach? @nevillehuang @PlamenTSV @gstoyanovbg\n\n**PlamenTSV**\n\nI am glad you understand the aspect of the README file overlooking the potential issues. It is not that they do not accept issues like this, it is the fact that they did not expect their contract to be at fault for them.\nI believe us watsons did in fact identify a valid problem, adhering both to the sherlock criteria and the sponsor's needs (we understand their confirmation is not a valid judgement, but it can be an argument that they did a mistake in the README), and hopefully I am speaking for everyone when I say I am glad we reached such a fair outcome.\nI am looking forward to seeing some docs changes for edge-case scenarios like this so they can be more easily resolved in the future.\nThanks for the hard work!\n\n**nevillehuang**\n\nHi @Czar102, I will share with you how I interpreted this while judging. In addition to the conflicted READ.ME, the `emergencyWithdraw` function exists in the first place to deal with such scenarios, that is why i deemed it as an accepted risk since funds can always be rescued by trusted admins.\n\nWhile I also understand the other side of the equation, I will share with you what I think is the only possible fair outcome for both watsons auditing and judging. I also want to clarify that unfairness goes both ways, but arguably even more so for judging since judging has way stricter rules.\n\n> Hi all heres my input for the findings regarding 107 & 136. In my opinion, the only fair outcome for all parties for 107 & 136 is to validate the finding as medium severity and waive its potential impact on my judging status. After all, the finding has provided significant value to the sponsor given the fix implemented.\n> But you can see from the current judging state that there will likely be less than 10 issues, so one missed issue by me can lead to heavy penalisation of my judging points or maybe even lead me to not make the minimum 80% recall threshold.\n> I have included this in part of my growing list of suggestion for improvement to sherlock, that is we possibly need a period of 24-48 hour for sponsor to clarify/edit any doubts regarding contest details. Lead judge/head of judging can facilitate in this.\n> Of course this is just my opinion, I leave the rest up to the temporary head of judging and sherlock\n\n**gstoyanovbg**\n\n@Czar102, I agree with everything you've said, and I share your philosophy on the work of auditors. Regarding the rules for judging, in my opinion, they cannot cover all possible cases, especially those that have not arisen before. They should evolve over time, and in the event of a situation, the Sherlock team should be able to make a decision so that there are no affected judges and auditors. @nevillehuang, I still believe this is a high severity issue, but at the same time, it is not fair to be punished because you acted according to the defined rules. I hope a solution can be found.\n\n**Czar102**\n\n> the `emergencyWithdraw` function exists in the first place to deal with such scenarios\n\nNevertheless, the contract doesn't function correctly. I think that because it is possible to rescue funds, it can be a medium severity issue. Players who were supposed to win in a game don't get their funds, but the EV doesn't change. The result is never uncovered. Hence medium.\n\nBecause judges who approached this issue \"by the book\" would lose out on this outcome, this issue and duplicates will not count towards the judging contest reward calculation.\n\n@nevillehuang @nasri136 Please let me know whether, according to the above approach, #72 should be considered valid or not. It seems it presents another issue.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n \nThe issue and duplicates will not be counted towards the judging payout.\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [gstoyanovbg](https://github.com/sherlock-audit/2023-10-looksrare-judging/issues/136/#issuecomment-1804703228): accepted\n- [PlamenTSV](https://github.com/sherlock-audit/2023-10-looksrare-judging/issues/136/#issuecomment-1804713799): accepted\n\n**gstoyanovbg**\n\n@Czar102, allow me to disagree with the severity of the report. I'm not sure if I have the right to dispute it after the escalation is resolved, but here are my arguments:\n\n1) I agree that the funds can be rescued using emergencyWithdraw(). However, the funds locked in one iteration of the game are insignificant compared to the indirect losses from such an event. The success of luck-based games is directly tied to the trust of the players in the game creators. If the game is interrupted at a crucial moment (which is very likely), the affected players will certainly question the fairness of the game. Can they be sure that this is not intentionally caused for someone not to win the prize? The damage to the brand's reputation will be irreversible. In addition to the missed profits from hundreds of future iterations of the game, developers will incur losses from the funds invested in development.\n\n2) I mentioned earlier that when we talk about financial losses, we should also consider the losses for users from gas fees (may have thousands of players). We all know what the fees on the Ethereum mainnet can be, especially in moments of network congestion. For a player whose agent is wounded, it may be extremely important to heal it regardless of the fee paid. When funds are withdrawn through emergencyWithdraw() and returned to the players, they should be compensated for gas fees. These funds must be paid either by Looksrare or the players. In both cases, someone loses.\n\n3) The time lost by players to play a game that suddenly stops and cannot continue should also be taken into account. Even if the game starts again from the beginning and everything is fine, it cannot start from the same state it was interrupted. A player may have been in a position where they were likely to win a prize, but they probably won't be compensated for it. Even if they are, it will be at the protocol's expense.\n\nConsidering 1), 2), and 3), my position is that there are much larger losses for each party than just the funds locked in the contract at the time of the interruption.\n\n**Czar102**\n\n> Can they be sure that this is not intentionally caused for someone not to win the prize?\n\nIf that's the case, this could have been a high severity issue. I don't think that the report mentions such a scenario though.\n\n> The damage to the brand's reputation will be irreversible.\n\nThat's true, but that is not a high severity vulnerability. A high severity vulnerability is when there is a direct and very probable loss of funds, which is not the case here.\n\n> These funds must be paid either by Looksrare or the players. In both cases, someone loses.\n\nThe gas costs are out of scope here. The fact that the user plays the game is a \"value gotten\" for the gas. Anyway, even if, there would be no high severity impact because of gas.\n\n> A player may have been in a position where they were likely to win a prize, but they probably won't be compensated for it.\n\nWe don't know that. Maybe the protocol would distribute the rewards proportionally to the EV of the players in a given position given an optimal strategy?\n\nThis is why I chose a Medium severity for this issue.\n\n**gstoyanovbg**\n\n> If that's the case, this could have been a high severity issue. I don't think that the report mentions such a scenario though.\n\nMe and you know that this is not true, but for people which are not solidity developers / auditors it is not clear and creates reasonable doubt about the fairness of the game and its creators\n\n> That's true, but that is not a high severity vulnerability. A high severity vulnerability is when there is a direct and very probable loss of funds, which is not the case here.\n\nI agree there is no direct loss of funds but we have an issue that breaks core contract functionality, rendering the protocol/contract useless + indirect loss of funds on a large scale.\n\n> We don't know that. Maybe the protocol would distribute the rewards proportionally to the EV of the players in a given position given an optimal strategy?\n\nThat would be the right decision. However, there is no way to do it in a good enough manner because there is no way to prove which player had what financial resources for the game. This is a very important variable for the potential mathematical model. For example, two agents who have survived until round X and have been healed three times will have equal weight if the game is interrupted at that moment. However, the player behind the first may no longer have the financial ability to heal the agent, while the second may be able to heal it three more times without any problem.\n\n\n**Czar102**\n\n> Me and you know that this is not true, but for people which are not solidity developers / auditors it is not clear and creates reasonable doubt about the fairness of the game and its creators\n\nThis is exactly why we have this job. We need to tell them. And this impact doesn't seem to be the case here.\n\n> However, there is no way to do it in a good enough manner because there is no way to prove which player had what financial resources for the game.\n\nYes, but I feel that's an insufficient impact to consider a high severity impact. In the end, they might make another contract and continue the game ;)\nOfc that would be costly but the loss of funds is extremely limited here. This is why it's Medium.\n\n**0xhiroshi**\n\nhttps://github.com/LooksRare/contracts-infiltration/pull/165\n\n**SergeKireev**\n\nFix LGTM\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/122",
  "Code": [
    {
      "filename": "contracts-infiltration/contracts/Infiltration.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IInfiltration} from \"./interfaces/IInfiltration.sol\";\n\nimport {OwnableTwoSteps} from \"@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\";\nimport {IERC20} from \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\";\n\nimport {ProtocolFee} from \"@looksrare/contracts-libs/contracts/ProtocolFee.sol\";\nimport {PackableReentrancyGuard} from \"@looksrare/contracts-libs/contracts/PackableReentrancyGuard.sol\";\nimport {LowLevelERC20Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelWETH} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\";\nimport {ITransferManager} from \"@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\";\n\nimport {VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"erc721a/contracts/ERC721A.sol\";\n\nimport {UnsafeMathUint256} from \"./libraries/UnsafeMathUint256.sol\";\n\n//                                            .:^^^^^^:::::::::::::::::::::::::::::::::::::::::::::.\n//                                          :~7777!!!77?JJ??????!?YYYYYYYYJ?7~~!!!!!!!!!7???7~~~!~~^:.\n//                                        :~!!!~~77JYYYJJYJJJJJ7J5PPPPP55?!!!!!!!7!!~~~~~~!77??7?!7!!~^.\n//                                      .^~!!!7JYYYYYYJJJJJJJJJ7Y5PPPY?!!!!!!~~~~~~!7!!~~~~~~!????J??7!!^.\n//                                   .:^!!?JYYYYYYYYJJJJJJJYJJ!J55YJ?!!!!!~~~~~~~~~~~!!7!!!!!7!!!!!77?JJ?!~:.\n//                                 .:^~?YYYYYYYYYJJJJJJJJJJJJ??YYJ?!!!77!!!!!!!!!!!!!!~~!!!77!!!!!!!!!!!7?J7~:.\n//                               .^~~!~JYYYYYYYYYJJJJJJJJ???~^??7^.........:::::::^^^^!!!!!77!!!!!!!!!!~~!!7?7!^.\n//                             :^!!!!!~~JYYYYYYJJJJJJJ7!~^:::!????~....    ...:::::::::::^^~77!!!!!!!!!~~~!!!77!!^.\n//                           :~77~!7!!~!JYJJJJJJJJJ!^^^^^^^:^JJ???7!^^::::::::..::::::::::::.:~!!!!!~7?!~~~~!!!!~~!^.\n//                         :!?7!!!77!~~JJJJJJJJ?!^^^^^^^^^::J???5PPG##GPPP5555?77!::::::::.....::^!!!J5Y?!~~~~!77~~~!~:\n//                      .:7J?!~!77!~~~!JJJJJ?~^^^^^^^^^^^::~?5##&@@@@@&BGBGPPPP555YJ!^::......:::...^?55YJ?!~~!!!!~~!!!~:\n//                    .^7J?7!!!!!!~~~~JJJJ7~^^^^^^^^^^^^:^J##@@@@@@@@@@@&#GGPPP555PPP55?:...::::::.. :!?JJJJ7!~~!77!~!!~!~:.\n//                  .:!?77!!!!!!~~~~~7JJ7~^^^^^^^^^^^^::~J#@@@@@@@@@@@@@@@#BGP55PPPPPGGGJ^......:::. ^~:^7???7!!!!!!~~!!!~!~:.\n//                .:!7!~~!!!!!!!~~~~!J7~^^^^^^^^^^^^^::7PB&@@@@@@@@&&B55555YGGPPPPPPGGBBBG7......:::..:^::^!7777!!!!!~~!!!!~!~^.\n//              .:^~!?J!~!7!!!!!~~~!~~^^~^^^^^:::::::.7PGB&&&&@@@&G?~~~!!!!~~~75GBBBBBBBB#B?  ......   .... :~!7!!!!~~!!!!!7!~7?~.\n//            .:^~!?5PPJ!~!!!!!~!!^::!~!!!^:....... .^JPB&&&&&&&G?~~!!7?JJ7!~^:^!5###&#####P~       :^^:      .^!!~~!7777!!!!~7Y5J!.\n//          .:^~!JY5PPPPY!~~~~!!^.   .:^!!^.       ::YBB####&&&P~^~!~~~^^^^:::::.^P&&&&&#&&&5    .:!????7!^::.  .^!!77777777!~!J5PPY!:\n//        .:~~~?Y5555PP5Y?~~!!^.        .^:..^^^!77?!5BB######B~:^^^::::::::......^#&&&&&&&&5  .:!???????????7!!^::~7?7?77777777?Y555J~.\n//       .:^~!!7?J??????7!!!7~.       .......:^77?JJ!5BBBBBBB#B^:::::....::::::::.~&@@@@&&&&5...^^^^^^^^^^^~^^^^^^:.~7!!~~~~~!!!!!77?7~:.\n//         .:^~!~!77!!!!!~~~!!!^:..... .::~~:....:^^:?GBBBGPPP5~.....:::::::::::.:7&&&&&&&&&P:::^:^^^^^:. .:.    .^~~~~~~~~~~~~~!77!~:.\n//           .:^~!!!77!!!~~~~~~!!^.   .::!77~^:......!Y555555555!:..::::::::::..:?#&&&&&&@@&5!7???????!. :~:.. .^!!~~~~~~~~~~~!!7!~:.\n//            ..:^~!!7?!!~~~~~~~~!!~:.:^!7!^.:^: .....755PPPPPPGG57:..::::::..:7P#&&&&&&@@@P!7????JJJ!. :^::.:~!!~~~~~~~~!!!!!7!~:..\n//           .....:^~!!77!~~~~~~~!!!!!^!7!:....^^  .. :?PPGGGGGBBBBPYJ^^^^^^JYG####&&&#&@@G?7????JJJ~. :^:.:!777!!!!!!!!!!!!7!~:.....\n//         .........:^~!!77!~~~~~~!??JY?!:...  .^^  .. :?PGBBBB####&@&######&&&#######&&#P?7????JJ7~. :^:^!?77777777777!!!7!^:.........\n//        ..........:::^~!!77!!~~~~!JJ5J7!:.    .^^. ....~PBB#####&&@@@@@@@@&&########&#J77????J?7:  :^^!?77777777??7!!!7!^:::...........\n//      ..........:::::::^~~!7?7~~~~~7JY7!~~^.   .^^. .   ^7?G###&&&@@@@@@@@&&######GJY?77????J?7:  :!!!J?777777??7!!!!~^:::::::..........\n//    ..........::::::::^^^^~~?J7!~~~~~??7^757^^. .^^.       :7?PBB#&&&&&&&&&&#BBP?7^!777????J?7..~~?5?!????????7!!!!~^^^^::::::::..........\n//   ..........:::::::^^^^^^^^^!???!~~~~!?77J?:~~^^:^:  .       .::!JJJJJJJJJJ!^^^:..777??????!~^7J!JY77JJJJ??7!!!!~^^^^^^^^:::::::..........\n//  .........:::::::^^^^^^~~~~^^^!7J?!!~~~77!^:~~!~~~~:...    .  .. .::::::::::::::.^777?77??7~~7J5!!7?JJJJ?7!!!!~^^~~~~^^^^^^:::::::.........\n// .........:::::::^^^^^~~~~~~!~~^^!JJ?7!~!!!~^^^~~~~!??!^~^.... .. .:::::::::::::::77???Y5Y7~~?Y5YJJJJJJ??7~!!~~~!!~~~~~~^^^^^:::::::.........\n// ........::::::^^^^^^~~~~~!!!!!!!~~!??77!!!~~~~:^~~~!?J???7777~^~^~~~~!!~~~~~~~!7JYYP5PG57^!?Y55YYYJJJJ7!!!~~!!!!!!!~~~~~^^^^^^::::::........\n// ......:::::::^^^^^~~~~~~!!!!!7777!~~!??7777!~!~^^~!^!??J??????????555PP5555555J?55P5PP57^!?Y55P5YYYJ?!!!~~!7777!!!!!~~~~~~^^^^^:::::::......\n// .....:::::::^^^^^~~~~~!!!!!!77777??7~~!???7?777!^~!!7???77???????JY55GG555555Y??5555PY?77JY55PPP5Y?!!!~!7??777777!!!!!~~~~~^^^^^^::::::.....\n// ....::::::^^^^^^~~~~~!!!!!77777??????!^^!?YY??!!!^~!777!^!??7!!!!!7Y5PP5YYYYJ7~Y5P55?7?JJY5555PPY7!!^^!??????77777!!!!!~~~~~^^^^^^::::::....\n// ...::::::^^^^^~~~~~!!!!!!77777??77!~~~~^:~7JP5J7^~~!!!7!7??!7777?JJ5YYYYPPP5J77555PJ77?JY555PP5J?7~^^~~~~!77??77777!!!!!!~~~~~^^^^^::::::...\n// ..::::::^^^^^~~~~~!!!!!777777!!~~~~~!!!!!~^~?5PY7~~!77!!?7!!7????JJ55555555Y?7JP5YJ?7JJY55555Y?7~^~!!!!!~~~~~!!777777!!!!!~~~~~^^^^^::::::..\n// ..::::::^^^^~~~~~!!!!!77!!~~~~~~~~7?JJJ?77!^:~?Y5Y!~!7!^7J7~~!7777?YYYYYYYYJ7?55J7JJ7J55555Y?!^:^!77?JJJ?7~~~~~~~~!!77!!!!!~~~~~^^^^^:::::..\n// .::::::^^^^^~~~~!!!!!!!^^^^^^~!!7777JJY?77!!~^.^7YY?~^!!^?J7~^^!77?YYYYYYYY7~75Y7JJ?JY555Y?!^:^~!!77?YJJ7777!!~^^^^^^!!!!!!!~~~~^^^^^::::::.\n// ::::::^^^^^~~~~~!!!!7!:!!^:^~~!!!7!777?JJ?77!~.::^7JJ7^^~~~????77?Y5PP5P55Y7?5Y?J???Y55Y?!^:::~!77?JJ?777!7!!!~~^:^!!^!7!!!!~~~~~^^^^^::::::\n// :::::^^^^^~~~~~!!!!77!:J?!^^^~~~!!!!!777??777~.^^::^7YJ!^^!!77!!7JJY555555J7!!77J??JYY?!^::^^:!777??777!!!!!~~~^^^!?J^!77!!!!~~~~~^^^^^:::::\n// :::::^^^^^~~~~!!!!!777~^!???7~^~~~!!!!!777777!.^~~~^^~?J!~^~~~!7??JJ55555Y?77!!???J?~^^:^~~~^:!777777!!!!!~~~^~7???!^~777!!!!!~~~~^^^^^:::::\n// ::::^^^^^~~~~~!!!!77777~^^~!??7~^~~~~~!!!!!777!.^!!~!!^^!?7!77!~!?JJ5555YJ7~^7JJJ!~:.:!!~!!^:!777!!!!!~~~~~^~7??!~^^~77777!!!!~~~~~^^^^^::::\n// ::::^^^^^~~~~!!!!!7777??7!^^^!??7~^~~~~~~!!!!!!.^~!!7??^.^!????????YPPPPJ~^~7JJ?!^:.^??7!!~^:!!!!!!~~~~~~^~7??!^^^!7??7777!!!!!~~~~^^^^^::::\n// ::::^^^^~~~~~!!!!77777777??~^^^~7?7~^~^~~~~!~!~.:!!7!75J::::!7????7?PPP5!^~7777~::::J57!7!!^:!!~!~~~~^~^~7?7~^^^~??77777777!!!!~~~~~^^^^::::\n// :::^^^^^~~~~!!!!!~~~^:::^^~7^:^^^~7?7!^^^^~~~~~..!!!77?5J:^^::~7?J?7JPPJ:~77!^::^^:J5?77!!!..~~~~~^^^^!7?7~^^^^~7~^^:::^~~~!!!!!~~~~^^^^^:::\n// ::::^^^^~~~~!!!~^^^^~^^^^:.::::^~^:~7??!^::^^^: :~!!!77?5J:^~~::~?JJ?P5~!??~::~~^:J5?77!!!~: :^^^::^!??7~:^~^::::.:^^^^~^^^^~!!!~~~~^^^^::::\n// ::::::^^~~~~!!~^^^~~~~^^^^:.::::^~^::~7??!^::::.::!7!!!7?5J^^~!!~^~?YPP?7~^~!!~^^J5?7!!!7!::.::::^!??7~::^~^::::.:^^^^~~~~^^^~!!~~~~^^::::::\n// ^^^^~~^^^^~~!~:^^~~!~~~^^^^:.::^~~^^:::^!??!:~!~::^!!!!!7?5J^^~!77~^~??~^~77!~^^J5?7!!!!!^::~!~:!??!^:::^^~~^::.:^^^^~~~!~~^^:~!~~^^^^~~^^^^\n// ^^^~~^:^^^^^~:^^~~!!!!!!!~~~^::~^^^^^^:::!J?!^!7!^::~!!!!7?5Y!^~!!7!~^^~!7!!~^!Y5?7!!!!~::^!7!^!?J!:::^^^^^^~::^~~~!!!!!!!~~^^:~^^^^::^~~^^^\n// !!~!7^.::^^::.^~~!!!!!77?JJJJ?!~^::^^^^^^~7?~:!!77!^^~~!!!7?J5Y7~^^~!~~!~^^~7Y5J?7!!!~~^^!77!!:~?7~^^^^^^::^~!?JJJJ?77!!!!!~~^.::^^::.^7!~!!\n// 777J?:.:^^^...:^~!!!7Y??7?777???!.:^~^^^~!~~!!!!!!7?7~^^^~~!77?JJ??~~~~~~??JJ?77!~~^^^~7?7!!!!!!~~!~^^^~^:.!??7777?7??Y7!!!~^:...^^^:.:?J777\n// !!7Y?::!77~:^^:.:^~7J??!!!7^~!!77~.:~7~~~~^^?J?!^^~~!7??!~^^^~~!!7????????7!!~~^^^~!??7!~~^^!?J?^^~~~~7~:.~777~^~~7!!??J7~^:.:^^:~77!::?Y7!!\n// !!7Y?::!!~:~?7~^:::^~~7!!7!^~~~7!!~.:~!!~~~^^^~: .:^^^^~~!7!~~~^:^^^^^^^^^^:^~~~!7!~~^^^^:. :~^^^~~~!!~:.~!!7!^~!~~7!7~~^:::^~7?~:~!!::?Y7!!\n// ?77?Y7^:^:~!??J?7!^::^~!!!~~~~!!!!~^.:^7?!~~^^^^::.:^^~!!~~~~~~^^^^^^^^^^^^^^~~~~~~!!~^^:.::^^^^~~!?7^:.^~!!!!~~~~!!!~^::^!7?J??!~:^:^7Y?77?\n// ??!7YJ^.:^!7???YYJ?7~~^^~~7!!!~~~~~~^::^~7??777!~!^^^^:::^~~~!!!!!!!!!!!!!!!!!!~~~^:::^^^^!~!777??7~^::^~~~~~~!!!7~~^^~~7?JYY???7!^:.^JY7!??\n// ??77YJ~.^~!77?JJJYYYYJ7!^^^~!777!!~~~~^::^^~!77????77?7!!~~~~^::::::::::::::::^~~~~!!7?77????77!~^^::^~~~~!!777!~^^^!7JYYYYJJJ?77!~^.~JY77??\n// J??77YJ~.^!!!JJ??777??YYJJ7!~^^~!77!~~~~~~~^^^^^~~!7777??????777777777777777777??????7777!~~^^^^^~~~~~~~!77!~^^~!7JJYY??777??JJ!!!^.~JY77??J\n// YY?77JY!:^!!!YJ?7!!!~~!!??JYJJ7!~^~~!!!~!!!!7777~~~~^^^~~~~~!777777777777777777!~~~~~^^^~~~~7777!!!!~!!!~~^~!7JJYJ??!!~~!!!7?JY!!!^:!YJ77?YY\n// YYJ?77JY!:~!!?Y?7!!!~~~~~~!!7?JYJ?7~^^~~!!!!7????????777777~~~~~~~~~~~~~~~~~~~~~~777777????????7!!!!~~^^~7?JYJ?7!!~~~~~~!!!7?Y?!!~:!YJ77?JYY\n// YJYJJ?7?J?^:!!?J?!!!~~~~~~~~~~~!7JJYY?~^^~!!77!7777?????????JJJJJJJJJJJJJJJJJJJJ?????????7777!77!!~^^~?YYJJ7!~~~~~~~~~~~!!!?J?!!:^?J?7?JJYJY\ncontract Infiltration is\n    IInfiltration,\n    OwnableTwoSteps,\n    ERC721A,\n    VRFConsumerBaseV2,\n    LowLevelERC20Transfer,\n    LowLevelWETH,\n    ProtocolFee,\n    PackableReentrancyGuard\n{\n    using UnsafeMathUint256 for uint256;\n\n    /**\n     * @notice When the frontrun lock is unlocked, agents can escape or heal.\n     */\n    uint8 private constant FRONTRUN_LOCK__UNLOCKED = 1;\n\n    /**\n     * @notice When the frontrun lock is locked, agents cannot escape or heal.\n     */\n    uint8 private constant FRONTRUN_LOCK__LOCKED = 2;\n\n    /**\n     * @notice When VRF is being requested, agents cannot escape or heal. It unlocks when the randomness is fulfilled.\n     * @dev frontrunLock is initially set as locked so that agents cannot escape or heal before the game starts.\n     *      It is unlocked when the first round's randomness is fulfilled.\n     */\n    uint8 private frontrunLock = FRONTRUN_LOCK__LOCKED;\n\n    /**\n     * @notice 100% in basis points.\n     */\n    uint256 private constant ONE_HUNDRED_PERCENT_IN_BASIS_POINTS = 10_000;\n\n    /**\n     * @notice 100% in basis points squared.\n     */\n    uint256 private constant ONE_HUNDRED_PERCENT_IN_BASIS_POINTS_SQUARED = 10_000 ** 2;\n\n    /**\n     * @notice The number of secondary prize pool winners. Their entitled shares are based on their placements.\n     *         When the number of active agents is less than or equal to this number, 1 agent is instantly killed\n     *         in each round.\n     */\n    uint256 private constant NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS = 50;\n\n    uint256 private constant PROBABILITY_PRECISION = 100_000_000;\n\n    /**\n     * @notice Max agent supply.\n     */\n    uint256 public immutable MAX_SUPPLY;\n\n    /**\n     * @notice Max mint per address.\n     */\n    uint256 public immutable MAX_MINT_PER_ADDRESS;\n\n    /**\n     * @notice The price of minting 1 agent.\n     */\n    uint256 public immutable PRICE;\n\n    /**\n     * @notice The number of blocks per round.\n     */\n    uint256 public immutable BLOCKS_PER_ROUND;\n\n    /**\n     * @notice The percentage of agents to wound per round in basis points.\n     */\n    uint256 public immutable AGENTS_TO_WOUND_PER_ROUND_IN_BASIS_POINTS;\n\n    /**\n     * @notice The number of rounds for agents to be wounded before getting killed.\n     */\n    uint256 public immutable ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD;\n\n    /**\n     * @notice This value is used as the denominator in healProbability.\n     */\n    uint256 private immutable ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD_MINUS_ONE;\n\n    /**\n     * @notice This value is used as the minuend in healProbability.\n     */\n    uint256 private immutable HEAL_PROBABILITY_MINUEND;\n\n    /**\n     * @notice The base cost of healing an agent. The cost increases for each successful heal.\n     */\n    uint256 public immutable HEAL_BASE_COST;\n\n    /**\n     * @notice WETH address.\n     */\n    address private immutable WETH;\n\n    /**\n     * @notice LOOKS address.\n     */\n    address private immutable LOOKS;\n\n    /**\n     * @notice Chainlink VRF key hash.\n     */\n\n    bytes32 private immutable KEY_HASH;\n\n    /**\n     * @notice Chainlink VRF coordinator.\n     */\n    VRFCoordinatorV2Interface private immutable VRF_COORDINATOR;\n\n    /**\n     * @notice Chainlink VRF subscription ID.\n     */\n    uint64 private immutable SUBSCRIPTION_ID;\n\n    /**\n     * @notice The transfer manager contract that manages LOOKS approvals.\n     */\n    ITransferManager private immutable TRANSFER_MANAGER;\n\n    /**\n     * @notice The timestamp at which the mint period starts.\n     */\n    uint40 public mintStart;\n\n    /**\n     * @notice The timestamp at which the mint period ends.\n     */\n    uint40 public mintEnd;\n\n    /**\n     * @notice The bitmap of the placements of the secondary prize pool winners.\n     * @dev Only bit 1 to 50 are used. Bit 0 is not used.\n     */\n    uint56 private prizesClaimedBitmap;\n\n    /**\n     * @notice The base URI of the collection.\n     */\n    string private baseURI;\n\n    /**\n     * @notice Amount of agents minted per address.\n     */\n    mapping(address minter => uint256 amount) public amountMintedPerAddress;\n\n    /**\n     * @notice Chainlink randomness requests.\n     */\n    mapping(uint256 requestId => RandomnessRequest) public randomnessRequests;\n\n    /**\n     * @notice The mapping agents acts as an \"array\". In the beginning of the game, the \"length\" of the \"array\"\n     *         is the total supply. As the game progresses, the \"length\" of the \"array\" decreases\n     *         as agents are killed. The function agentsAlive() returns the \"length\" of the \"array\".\n     *\n     *         When an Agent struct has 0 value for every field with its index within the total supply,\n     *         it means that the agent is active.\n     *\n     *         Index 0 is not used as agent ID starts from 1.\n     */\n    mapping(uint256 index => Agent) private agents;\n\n    /**\n     * @notice It is used to find the index of an agent in the agents mapping given its agent ID.\n     *         If the index is 0, it means the agent's index is the same as its agent ID as no swaps\n     *         have been made.\n     */\n    mapping(uint256 agentId => uint256 index) private agentIdToIndex;\n\n    /**\n     * @notice The maximum healing or wounded agents allowed per round.\n     */\n    uint256 private constant MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND = 30;\n\n    /**\n     * @notice The maximum healing or wounded agents allowed per round + 1 for storing the array length.\n     */\n    uint256 private constant MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND_AND_LENGTH = 31;\n\n    /**\n     * @notice The first element of the array is the length of the array.\n     */\n    mapping(uint256 roundId => uint16[MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND_AND_LENGTH] agentIds)\n        private woundedAgentIdsPerRound;\n\n    /**\n     * @notice The first element of the array is the length of the array.\n     */\n    mapping(uint256 roundId => uint16[MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND_AND_LENGTH] agentIds)\n        private healingAgentIdsPerRound;\n\n    /**\n     * @notice Game information.\n     */\n    GameInfo public gameInfo;\n\n    /**\n     * @dev Agent struct status offset for bitwise operations.\n     */\n    uint256 private constant AGENT__STATUS_OFFSET = 16;\n\n    /**\n     * @dev Agent struct wounded at offset for bitwise operations.\n     */\n    uint256 private constant AGENT__WOUNDED_AT_OFFSET = 24;\n\n    /**\n     * @dev Agent struct heal count offset for bitwise operations.\n     */\n    uint256 private constant AGENT__HEAL_COUNT_OFFSET = 64;\n\n    /**\n     * @dev GameInfo struct wounded agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__WOUNDED_AGENTS_OFFSET = 16;\n\n    /**\n     * @dev GameInfo struct healing agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__HEALING_AGENTS_OFFSET = 32;\n\n    /**\n     * @dev GameInfo struct dead agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__DEAD_AGENTS_OFFSET = 48;\n\n    /**\n     * @dev GameInfo struct escaped agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__ESCAPED_AGENTS_OFFSET = 64;\n\n    /**\n     * @dev GameInfo struct current round ID offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__CURRENT_ROUND_ID_OFFSET = 80;\n\n    /**\n     * @dev GameInfo struct current round block number offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__CURRENT_ROUND_BLOCK_NUMBER_OFFSET = 120;\n\n    /**\n     * @dev RandomnessRequest struct exists offset for bitwise operations.\n     */\n    uint256 private constant RANDOMNESS_REQUESTS__EXISTS_OFFSET = 8;\n\n    /**\n     * @dev 2 bytes bitmask.\n     */\n    uint256 private constant TWO_BYTES_BITMASK = 0xffff;\n\n    /**\n     * @dev 5 bytes bitmask.\n     */\n    uint256 private constant FIVE_BYTES_BITMASK = 0xffffffffff;\n\n    /**\n     * @param constructorCalldata Constructor calldata. See IInfiltration.ConstructorCalldata for its key values.\n     */\n    constructor(\n        ConstructorCalldata memory constructorCalldata\n    )\n        OwnableTwoSteps(constructorCalldata.owner)\n        ERC721A(constructorCalldata.name, constructorCalldata.symbol)\n        VRFConsumerBaseV2(constructorCalldata.vrfCoordinator)\n    {\n        if (\n            constructorCalldata.maxSupply <= NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS ||\n            constructorCalldata.maxSupply > type(uint16).max\n        ) {\n            revert InvalidMaxSupply();\n        }\n\n        if (\n            (constructorCalldata.maxSupply * constructorCalldata.agentsToWoundPerRoundInBasisPoints) >\n            MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND * ONE_HUNDRED_PERCENT_IN_BASIS_POINTS\n        ) {\n            revert WoundedAgentIdsPerRoundExceeded();\n        }\n\n        if (constructorCalldata.roundsToBeWoundedBeforeDead < 3) {\n            revert RoundsToBeWoundedBeforeDeadTooLow();\n        }\n\n        PRICE = constructorCalldata.price;\n        MAX_SUPPLY = constructorCalldata.maxSupply;\n        MAX_MINT_PER_ADDRESS = constructorCalldata.maxMintPerAddress;\n        BLOCKS_PER_ROUND = constructorCalldata.blocksPerRound;\n        AGENTS_TO_WOUND_PER_ROUND_IN_BASIS_POINTS = constructorCalldata.agentsToWoundPerRoundInBasisPoints;\n        ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD = constructorCalldata.roundsToBeWoundedBeforeDead;\n\n        // The next 2 values are used in healProbability\n        ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD_MINUS_ONE = ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD.unsafeSubtract(1);\n        HEAL_PROBABILITY_MINUEND =\n            ((ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD * 99 - 80) * PROBABILITY_PRECISION) /\n            ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD_MINUS_ONE;\n\n        LOOKS = constructorCalldata.looks;\n        HEAL_BASE_COST = constructorCalldata.healBaseCost;\n\n        KEY_HASH = constructorCalldata.keyHash;\n        VRF_COORDINATOR = VRFCoordinatorV2Interface(constructorCalldata.vrfCoordinator);\n        SUBSCRIPTION_ID = constructorCalldata.subscriptionId;\n\n        TRANSFER_MANAGER = ITransferManager(constructorCalldata.transferManager);\n        WETH = constructorCalldata.weth;\n\n        baseURI = constructorCalldata.baseURI;\n\n        _updateProtocolFeeRecipient(constructorCalldata.protocolFeeRecipient);\n        _updateProtocolFeeBp(constructorCalldata.protocolFeeBp);\n    }\n\n    /**\n     * @dev updateProtocolFeeBp is not implemented in this contract.\n     */\n    function updateProtocolFeeBp(uint16) external pure override {\n        revert Immutable();\n    }\n\n    /**\n     * @dev updateProtocolFeeRecipient is not implemented in this contract.\n     */\n    function updateProtocolFeeRecipient(address) external pure override {\n        revert Immutable();\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function setMintPeriod(uint40 newMintStart, uint40 newMintEnd) external onlyOwner {\n        if (newMintStart >= newMintEnd) {\n            revert InvalidMintPeriod();\n        }\n\n        if (newMintStart != 0) {\n            if (block.timestamp > newMintStart) {\n                revert MintStartIsInThePast();\n            }\n\n            uint256 currentMintStart = mintStart;\n            if (currentMintStart != 0) {\n                if (block.timestamp >= currentMintStart) {\n                    revert MintAlreadyStarted();\n                }\n            }\n\n            mintStart = newMintStart;\n        }\n\n        if (block.timestamp > newMintEnd || newMintEnd < mintEnd) {\n            revert MintCanOnlyBeExtended();\n        }\n\n        mintEnd = newMintEnd;\n\n        emit MintPeriodUpdated(newMintStart == 0 ? mintStart : newMintStart, newMintEnd);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     * @notice As long as the game has not started (after mint end), the owner can still mint.\n     */\n    function premint(address to, uint256 quantity) external payable onlyOwner {\n        if (quantity * PRICE != msg.value) {\n            revert InsufficientNativeTokensSupplied();\n        }\n\n        if (totalSupply() + quantity > MAX_SUPPLY) {\n            revert ExceededTotalSupply();\n        }\n\n        if (gameInfo.currentRoundId != 0) {\n            revert GameAlreadyBegun();\n        }\n\n        _mintERC2309(to, quantity);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function mint(uint256 quantity) external payable nonReentrant {\n        if (block.timestamp < mintStart || block.timestamp > mintEnd) {\n            revert NotInMintPeriod();\n        }\n\n        if (gameInfo.currentRoundId != 0) {\n            revert GameAlreadyBegun();\n        }\n\n        uint256 amountMinted = amountMintedPerAddress[msg.sender] + quantity;\n        if (amountMinted > MAX_MINT_PER_ADDRESS) {\n            revert TooManyMinted();\n        }\n\n        if (quantity * PRICE != msg.value) {\n            revert InsufficientNativeTokensSupplied();\n        }\n\n        if (totalSupply() + quantity > MAX_SUPPLY) {\n            revert ExceededTotalSupply();\n        }\n\n        amountMintedPerAddress[msg.sender] = amountMinted;\n        _mintERC2309(msg.sender, quantity);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     * @dev If Chainlink randomness callback does not come back after 1 day, we can call\n     *      startNewRound to trigger a new randomness request.\n     */\n    function startGame() external onlyOwner {\n        uint256 numberOfAgents = totalSupply();\n        if (numberOfAgents < MAX_SUPPLY) {\n            if (block.timestamp < mintEnd) {\n                revert StillMinting();\n            }\n        }\n\n        if (gameInfo.currentRoundId != 0) {\n            revert GameAlreadyBegun();\n        }\n\n        gameInfo.currentRoundId = 1;\n        gameInfo.activeAgents = uint16(numberOfAgents);\n        uint256 balance = address(this).balance;\n        uint256 protocolFee = balance.unsafeMultiply(protocolFeeBp).unsafeDivide(ONE_HUNDRED_PERCENT_IN_BASIS_POINTS);\n        unchecked {\n            gameInfo.prizePool = balance - protocolFee;\n        }\n\n        emit RoundStarted(1);\n\n        _transferETHAndWrapIfFailWithGasLimit(WETH, protocolFeeRecipient, protocolFee, gasleft());\n        _requestForRandomness();\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function emergencyWithdraw() external onlyOwner {\n        uint256 activeAgents;\n        uint256 woundedAgents;\n        uint256 healingAgents;\n        uint256 escapedAgents;\n        uint256 deadAgents;\n        uint256 currentRoundId;\n        uint256 currentRoundBlockNumber;\n\n        assembly {\n            let gameInfoSlot0Value := sload(gameInfo.slot)\n            activeAgents := and(gameInfoSlot0Value, TWO_BYTES_BITMASK)\n            woundedAgents := and(shr(GAME_INFO__WOUNDED_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            healingAgents := and(shr(GAME_INFO__HEALING_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            escapedAgents := and(shr(GAME_INFO__ESCAPED_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            deadAgents := and(shr(GAME_INFO__DEAD_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            currentRoundId := and(shr(GAME_INFO__CURRENT_ROUND_ID_OFFSET, gameInfoSlot0Value), FIVE_BYTES_BITMASK)\n            currentRoundBlockNumber := and(\n                shr(GAME_INFO__CURRENT_ROUND_BLOCK_NUMBER_OFFSET, gameInfoSlot0Value),\n                FIVE_BYTES_BITMASK\n            )\n        }\n\n        bool conditionOne = currentRoundId != 0 &&\n            activeAgents + woundedAgents + healingAgents + escapedAgents + deadAgents != totalSupply();\n\n        // 50 blocks per round * 216 = 10,800 blocks which is roughly 36 hours\n        // Prefer not to hard code this number as BLOCKS_PER_ROUND is not always 50\n        bool conditionTwo = currentRoundId != 0 &&\n            activeAgents > 1 &&\n            block.number > currentRoundBlockNumber + BLOCKS_PER_ROUND * 216;\n\n        // Just in case startGame reverts, we can withdraw the ETH balance and redistribute to addresses that participated in the mint.\n        bool conditionThree = currentRoundId == 0 && block.timestamp > uint256(mintEnd).unsafeAdd(36 hours);\n\n        if (conditionOne || conditionTwo || conditionThree) {\n            uint256 ethBalance = address(this).balance;\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethBalance, gasleft());\n\n            uint256 looksBalance = IERC20(LOOKS).balanceOf(address(this));\n            _executeERC20DirectTransfer(LOOKS, msg.sender, looksBalance);\n\n            emit EmergencyWithdrawal(ethBalance, looksBalance);\n        }\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     * @dev If Chainlink randomness callback does not come back after 1 day, we can try by calling\n     *      startNewRound again.\n     */\n    function startNewRound() external nonReentrant {\n        uint256 currentRoundId = gameInfo.currentRoundId;\n        if (currentRoundId == 0) {\n            revert GameNotYetBegun();\n        }\n\n        if (block.number < uint256(gameInfo.currentRoundBlockNumber).unsafeAdd(BLOCKS_PER_ROUND)) {\n            revert TooEarlyToStartNewRound();\n        }\n\n        uint256 activeAgents = gameInfo.activeAgents;\n        if (activeAgents == 1) {\n            revert GameOver();\n        }\n\n        if (block.timestamp < uint256(gameInfo.randomnessLastRequestedAt).unsafeAdd(1 days)) {\n            revert TooEarlyToRetryRandomnessRequest();\n        }\n\n        if (activeAgents <= NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS) {\n            uint256 woundedAgents = gameInfo.woundedAgents;\n\n            if (woundedAgents != 0) {\n                uint256 killRoundId = currentRoundId > ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD\n                    ? currentRoundId.unsafeSubtract(ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD)\n                    : 1;\n                uint256 agentsRemaining = agentsAlive();\n                uint256 totalDeadAgentsFromKilling;\n                while (woundedAgentIdsPerRound[killRoundId][0] != 0) {\n                    uint256 deadAgentsFromKilling = _killWoundedAgents({\n                        roundId: killRoundId,\n                        currentRoundAgentsAlive: agentsRemaining\n                    });\n                    unchecked {\n                        totalDeadAgentsFromKilling += deadAgentsFromKilling;\n                        agentsRemaining -= deadAgentsFromKilling;\n                        ++killRoundId;\n                    }\n                }\n\n                // This is equivalent to\n                // unchecked {\n                //     gameInfo.deadAgents += uint16(totalDeadAgentsFromKilling);\n                // }\n                // gameInfo.woundedAgents = 0;\n                assembly {\n                    let gameInfoSlot0Value := sload(gameInfo.slot)\n                    let deadAgents := and(shr(GAME_INFO__DEAD_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n\n                    gameInfoSlot0Value := and(\n                        gameInfoSlot0Value,\n                        // This is equivalent to\n                        // not(\n                        //     or(\n                        //         shl(GAME_INFO__WOUNDED_AGENTS_OFFSET, TWO_BYTES_BITMASK),\n                        //         shl(GAME_INFO__DEAD_AGENTS_OFFSET, TWO_BYTES_BITMASK)\n                        //     )\n                        // )\n                        0xffffffffffffffffffffffffffffffffffffffffffffffff0000ffff0000ffff\n                    )\n\n                    gameInfoSlot0Value := or(\n                        gameInfoSlot0Value,\n                        shl(GAME_INFO__DEAD_AGENTS_OFFSET, add(deadAgents, totalDeadAgentsFromKilling))\n                    )\n\n                    sstore(gameInfo.slot, gameInfoSlot0Value)\n                }\n            }\n        }\n\n        _requestForRandomness();\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function claimGrandPrize() external nonReentrant {\n        _assertGameOver();\n        uint256 agentId = agents[1].agentId;\n        _assertAgentOwnership(agentId);\n\n        uint256 prizePool = gameInfo.prizePool;\n\n        if (prizePool == 0) {\n            revert NothingToClaim();\n        }\n\n        gameInfo.prizePool = 0;\n\n        _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, prizePool, gasleft());\n\n        emit PrizeClaimed(agentId, address(0), prizePool);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function claimSecondaryPrizes(uint256 agentId) external nonReentrant {\n        _assertGameOver();\n        _assertAgentOwnership(agentId);\n\n        uint256 placement = agentIndex(agentId);\n        _assertValidPlacement(placement);\n\n        uint56 _prizesClaimedBitmap = prizesClaimedBitmap;\n        if ((_prizesClaimedBitmap >> placement) & 1 != 0) {\n            revert NothingToClaim();\n        }\n\n        prizesClaimedBitmap = _prizesClaimedBitmap | uint56(1 << placement);\n\n        uint256 ethAmount = secondaryPrizePoolShareAmount(gameInfo.secondaryPrizePool, placement);\n        if (ethAmount != 0) {\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethAmount, gasleft());\n            emit PrizeClaimed(agentId, address(0), ethAmount);\n        }\n\n        uint256 secondaryLooksPrizePool = gameInfo.secondaryLooksPrizePool;\n        if (secondaryLooksPrizePool == 0) {\n            secondaryLooksPrizePool = IERC20(LOOKS).balanceOf(address(this));\n            if (secondaryLooksPrizePool == 0) {\n                return;\n            }\n            gameInfo.secondaryLooksPrizePool = secondaryLooksPrizePool;\n        }\n\n        uint256 looksAmount = secondaryPrizePoolShareAmount(secondaryLooksPrizePool, placement);\n        if (looksAmount != 0) {\n            _executeERC20DirectTransfer(LOOKS, msg.sender, looksAmount);\n            emit PrizeClaimed(agentId, LOOKS, looksAmount);\n        }\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function escape(uint256[] calldata agentIds) external nonReentrant {\n        _assertFrontrunLockIsOff();\n\n        uint256 agentIdsCount = agentIds.length;\n        _assertNotEmptyAgentIdsArrayProvided(agentIdsCount);\n\n        uint256 activeAgents = gameInfo.activeAgents;\n        uint256 activeAgentsAfterEscape = activeAgents - agentIdsCount;\n        _assertGameIsNotOverAfterEscape(activeAgentsAfterEscape);\n\n        uint256 currentRoundAgentsAlive = agentsAlive();\n\n        uint256 prizePool = gameInfo.prizePool;\n        uint256 secondaryPrizePool = gameInfo.secondaryPrizePool;\n        uint256 reward;\n        uint256[] memory rewards = new uint256[](agentIdsCount);\n\n        for (uint256 i; i < agentIdsCount; ) {\n            uint256 agentId = agentIds[i];\n            _assertAgentOwnership(agentId);\n\n            uint256 index = agentIndex(agentId);\n            _assertAgentStatus(agents[index], agentId, AgentStatus.Active);\n\n            uint256 totalEscapeValue = prizePool / currentRoundAgentsAlive;\n            uint256 rewardForPlayer = (totalEscapeValue * _escapeMultiplier(currentRoundAgentsAlive)) /\n                ONE_HUNDRED_PERCENT_IN_BASIS_POINTS;\n            rewards[i] = rewardForPlayer;\n            reward += rewardForPlayer;\n\n            uint256 rewardToSecondaryPrizePool = (totalEscapeValue.unsafeSubtract(rewardForPlayer) *\n                _escapeRewardSplitForSecondaryPrizePool(currentRoundAgentsAlive)) / ONE_HUNDRED_PERCENT_IN_BASIS_POINTS;\n\n            unchecked {\n                prizePool = prizePool - rewardForPlayer - rewardToSecondaryPrizePool;\n            }\n            secondaryPrizePool += rewardToSecondaryPrizePool;\n\n            _swap({\n                currentAgentIndex: index,\n                lastAgentIn"
    }
  ]
}