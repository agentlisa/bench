{
  "Title": "[G-01] Derive min / max collection bounds dynamically",
  "Content": "\n**54,522 gas can be saved.**\n\n| Method | Before | After | Gas Saved | Test Passes? |\n|-----------|------------|-----------|-----------|--------|\n| `NextGenCore:setCollectionData()` | 199090 | 154389 | 44701 | Yes |\n| `NextGenCore:burn()` | 84270 | 83948 | 322 | Yes |\n| `NextGenCore:setFinalSupply()` | 54949 | 49590 | 5359 | Yes |\n| `NextGenCore:mint()` | 529382 | 525242 | 4140 | Yes |\n\nToken min / max index define the valid range of tokens within a collection. There is no need to store them in state variables, as these can be derived using `collectionID` and `collectionTotalSupply` and their values can be read using the getter functions wherever required.\n\n### Recommendation\n\n**STEP 1:**  Update the getter functions:\n```diff\n    function viewTokensIndexMin(...) {\n-       return(collectionAdditionalData[_collectionID].reservedMinTokensIndex);\n+       return _collectionID * 10000000000;\n    }\n```\n\n[Source: smart-contracts/NextGenCore.sol#L383-L385](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/NextGenCore.sol#L383-L385)\n\n```diff\n    function viewTokensIndexMax(...) {\n-       return(collectionAdditionalData[_collectionID].reservedMaxTokensIndex);\n+       return _collectionID * 10000000000 + collectionAdditionalData[_collectionID].collectionTotalSupply - 1;\n\t}\n```\n\n[Source: smart-contracts/NextGenCore.sol#L389-L391](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/NextGenCore.sol#L389-L391)\n\n**STEP 2:** Remove declaration:\n\n```diff\n    struct collectionAdditonalDataStructure {\n        address collectionArtistAddress;\n        uint256 maxCollectionPurchases;\n        uint256 collectionCirculationSupply;\n        uint256 collectionTotalSupply;\n-       uint256 reservedMinTokensIndex;\n-       uint256 reservedMaxTokensIndex;\n        uint setFinalSupplyTimeAfterMint;\n        address randomizerContract;\n        IRandomizer randomizer;\n    }\n```\n\n[Source: smart-contracts/NextGenCore.sol#L44-L54](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/NextGenCore.sol#L44-L54)\n\n**STEP 3:** Remove assignment:\n\n```diff\n   function setCollectionData(...) {\n       __SNIP__\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply == 0) {\n            collectionAdditionalData[_collectionID].collectionCirculationSupply = 0;\n            collectionAdditionalData[_collectionID].collectionTotalSupply = _collectionTotalSupply;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n-           collectionAdditionalData[_collectionID].reservedMinTokensIndex = (_collectionID * 10000000000);\n-           collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + _collectionTotalSupply - 1;\n            wereDataAdded[_collectionID] = true;\n        } \n      __SNIP__\n    }\n```\n\n[Source: smart-contracts/NextGenCore.sol#L147-L166](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/NextGenCore.sol#L147-L166)\n\n**STEP 4:** Read value via getter:\n\n```diff\n    function burn(uint256 _collectionID, uint256 _tokenId) public {\n        __SNIP__\n-        require ((_tokenId >= collectionAdditionalData[_collectionID].reservedMinTokensIndex) && (_tokenId <= collectionAdditionalData[_collectionID].reservedMaxTokensIndex), \"id err\");\n+        require ((_tokenId >= this.viewTokensIndexMin(_collectionID)) && (_tokenId <=  this.viewTokensIndexMax(_collectionID)), \"id err\");\n        __SNIP__\n    }\n```\n\n[Source: smart-contracts/NextGenCore.sol#L204-L209](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/NextGenCore.sol#L204-L209)\n\n**STEP 5:** Since max value is calculated dynamically, no need to update it on supply change:\n\n```diff\n    function setFinalSupply(...) {\n     __SNIP__\n        collectionAdditionalData[_collectionID].collectionTotalSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply;\n-       collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + collectionAdditionalData[_collectionID].collectionTotalSupply - 1;\n    }\n```\n\n[Source: smart-contracts/NextGenCore.sol#L307-L311](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/NextGenCore.sol#L307-L311)\n\n**STEP 6:** Fetch via  value via getter:\n\n```diff\n    function getTokenName(...)  {\n-       uint256 tok = tokenId - collectionAdditionalData[tokenIdsToCollectionIds[tokenId]].reservedMinTokensIndex;\n+       uint256 tok = tokenId - this.viewTokensIndexMin(tokenIdsToCollectionIds[tokenId]);\n        __SNIP__\n    }\n```\n\n[Source: smart-contracts/NextGenCore.sol#L361-L364](https://github.com/code-423n4/2023-10-nextgen/blob/8b518196629faa37eae39736837b24926fd3c07c/smart-contracts/NextGenCore.sol#L361-L364)\n\n### POC\n\n![Test Result](https://i.imgur.com/3nYU2eN.png)\n\n### POC test file\n\n<details>\n\n```js\nconst {\n  loadFixture,\n  time,\n} = require(\"@nomicfoundation/hardhat-toolbox/network-helpers\");\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\nconst fixturesDeployment = require(\"../scripts/fixturesDeployment.js\");\n\nlet signers;\nlet contracts;\nconst MAX_TOTAL_SUPPLY = 10_000_000_000;\n\ndescribe(\"Verify removal of min/max params from storage\", async function () {\n  before(async function () {\n    ({ signers, contracts } = await loadFixture(fixturesDeployment));\n  });\n\n  it(\"SHOULD deploy contracts\", async function () {\n    expect(await contracts.hhAdmin.getAddress()).to.not.equal(\n      ethers.ZeroAddress\n    );\n    expect(await contracts.hhCore.getAddress()).to.not.equal(\n      ethers.ZeroAddress\n    );\n    expect(await contracts.hhDelegation.getAddress()).to.not.equal(\n      ethers.ZeroAddress\n    );\n    expect(await contracts.hhMinter.getAddress()).to.not.equal(\n      ethers.ZeroAddress\n    );\n    expect(await contracts.hhRandomizer.getAddress()).to.not.equal(\n      ethers.ZeroAddress\n    );\n    expect(await contracts.hhRandoms.getAddress()).to.not.equal(\n      ethers.ZeroAddress\n    );\n  });\n\n  it(\"SHOULD create a collection\", async function () {\n    await contracts.hhCore.createCollection(\n      \"TestCollection\",\n      \"Artist 1\",\n      \"For testing\",\n      \"www.test.com\",\n      \"CCO\",\n      \"https://ipfs.io/ipfs/hash/\",\n      \"\",\n      [\"desc\"]\n    );\n  });\n\n  it(\"SHOULD successfully set min / max params for a collection\", async function () {\n    const SUPPLY = 1000;\n\n    await contracts.hhCore.setCollectionData(\n      1,\n      signers.owner.address,\n      50,\n      SUPPLY,\n      100\n    );\n\n    expect(await contracts.hhCore.viewTokensIndexMin(1)).eq(\n      1 * MAX_TOTAL_SUPPLY\n    );\n\n    expect(await contracts.hhCore.viewTokensIndexMax(1)).eq(\n      1 * MAX_TOTAL_SUPPLY + (SUPPLY - 1)\n    );\n  });\n\n  it(\"SHOULD mint token\", async function () {\n    await contracts.hhCore.addMinterContract(contracts.hhMinter);\n    await contracts.hhCore.addRandomizer(1, contracts.hhRandomizer);\n    await contracts.hhMinter.setCollectionCosts(\n      1, // _collectionID\n      0, // _collectionMintCost\n      0, // _collectionEndMintCost\n      0, // _rate\n      0, // _timePeriod\n      1, // _salesOptions\n      \"0xD7ACd2a9FD159E69Bb102A1ca21C9a3e3A5F771B\" // delAddress\n    );\n    await contracts.hhMinter.setCollectionPhases(\n      1, // _collectionID\n      1696931278, // _allowlistStartTime\n      1696931278, // _allowlistEndTime\n      1696931278, // _publicStartTime\n      1700019791, // _publicEndTime\n      \"0x8e3c1713145650ce646f7eccd42c4541ecee8f07040fc1ac36fe071bbfebb870\" // _merkleRoot\n    );\n    await contracts.hhMinter.mint(\n      1, // _collectionID\n      2, // _numberOfTokens\n      0, // _maxAllowance\n      '{\"tdh\": \"100\"}', // _tokenData\n      signers.owner.address, // _mintTo\n      [\"0x8e3c1713145650ce646f7eccd42c4541ecee8f07040fc1ac36fe071bbfebb870\"], // _merkleRoot\n      signers.addr1.address, // _delegator\n      2 //_varg0\n    );\n  });\n\n  it(\"SHOULD burn valid token\", async function () {\n    let min = await contracts.hhCore.viewTokensIndexMin(1);\n    await expect(contracts.hhCore.burn(1, min)).not.to.be.reverted;\n    expect(await contracts.hhCore.balanceOf(signers.owner.address)).eq(1);\n  });\n\n  it(\"SHOULD successfully set final supply\", async function () {\n    await time.increaseTo(1700019900);\n    await expect(contracts.hhCore.setFinalSupply(1)).not.to.be.reverted;\n  });\n\n    it(\"SHOULD successfully get token name\", async function () {\n      let min = await contracts.hhCore.viewTokensIndexMin(1);\n      // @audit getTokenName was changed to public for the purpose of unit testing.\n      expect(await contracts.hhCore.getTokenName(min + 1n)).to.be.eq(\n        \"TestCollection #1\"\n      );\n    });\n});\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/NextGenCore.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Smart Contract\n *  @date: 19-October-2023 \n *  @version: 10.28\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./ERC721Enumerable.sol\";\nimport \"./Ownable.sol\";\nimport \"./Strings.sol\";\nimport \"./Base64.sol\";\nimport \"./IRandomizer.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IMinterContract.sol\";\nimport \"./ERC2981.sol\";\n\ncontract NextGenCore is ERC721Enumerable, Ownable, ERC2981 {\n    using Strings for uint256;\n\n    // declare variables\n    uint256 public newCollectionIndex;\n\n    // collectionInfo struct declaration\n    struct collectionInfoStructure {\n        string collectionName;\n        string collectionArtist;\n        string collectionDescription;\n        string collectionWebsite;\n        string collectionLicense;\n        string collectionBaseURI;\n        string collectionLibrary;\n        string[] collectionScript;\n    }\n\n    // mapping of collectionInfo struct\n    mapping (uint256 => collectionInfoStructure) private collectionInfo;\n\n    // collectionAdditionalData struct declaration\n    struct collectionAdditonalDataStructure {\n        address collectionArtistAddress;\n        uint256 maxCollectionPurchases;\n        uint256 collectionCirculationSupply;\n        uint256 collectionTotalSupply;\n        uint256 reservedMinTokensIndex;\n        uint256 reservedMaxTokensIndex;\n        uint setFinalSupplyTimeAfterMint;\n        address randomizerContract;\n        IRandomizer randomizer;\n    }\n\n    // mapping of collectionAdditionalData struct\n    mapping (uint256 => collectionAdditonalDataStructure) private collectionAdditionalData;\n\n    // other mappings\n\n    // checks if a collection was created\n    mapping (uint256 => bool) private isCollectionCreated; \n\n    // checks if data on a collection were added\n    mapping (uint256 => bool) private wereDataAdded;\n\n    // maps tokends ids with collectionsids\n    mapping (uint256 => uint256) private tokenIdsToCollectionIds;\n\n    // stores randomizer hash\n    mapping(uint256 => bytes32) private tokenToHash;\n\n    // minted tokens per address per collection during public sale\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedPerAddress;\n\n    // minted tokens per address per collection during allowlist\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedAllowlistAddress;\n\n    // tokens airdrop per address per collection \n    mapping (uint256 => mapping (address => uint256)) private tokensAirdropPerAddress;\n\n    // current amount of burnt tokens per collection\n    mapping (uint256 => uint256) public burnAmount;\n\n    // modify the metadata view\n    mapping (uint256 => bool) public onchainMetadata; \n\n    // artist signature per collection\n    mapping (uint256 => string) public artistsSignatures;\n\n    // tokens additional metadata\n    mapping (uint256 => string) public tokenData;\n\n    // on-chain token Image URI and attributes\n    mapping (uint256 => string[2]) private tokenImageAndAttributes;\n\n    // collectionFreeze \n    mapping (uint256 => bool) private collectionFreeze;\n\n    // artist signed\n    mapping (uint256 => bool) public artistSigned; \n\n    // external contracts declaration\n    INextGenAdmins private adminsContract;\n    address public minterContract;\n\n    // smart contract constructor\n    constructor(string memory name, string memory symbol, address _adminsContract) ERC721(name, symbol) {\n        adminsContract = INextGenAdmins(_adminsContract);\n        newCollectionIndex = newCollectionIndex + 1;\n        _setDefaultRoyalty(0x1B1289E34Fe05019511d7b436a5138F361904df0, 690);\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to create a Collection\n\n    function createCollection(string memory _collectionName, string memory _collectionArtist, string memory _collectionDescription, string memory _collectionWebsite, string memory _collectionLicense, string memory _collectionBaseURI, string memory _collectionLibrary, string[] memory _collectionScript) public FunctionAdminRequired(this.createCollection.selector) {\n        collectionInfo[newCollectionIndex].collectionName = _collectionName;\n        collectionInfo[newCollectionIndex].collectionArtist = _collectionArtist;\n        collectionInfo[newCollectionIndex].collectionDescription = _collectionDescription;\n        collectionInfo[newCollectionIndex].collectionWebsite = _collectionWebsite;\n        collectionInfo[newCollectionIndex].collectionLicense = _collectionLicense;\n        collectionInfo[newCollectionIndex].collectionBaseURI = _collectionBaseURI;\n        collectionInfo[newCollectionIndex].collectionLibrary = _collectionLibrary;\n        collectionInfo[newCollectionIndex].collectionScript = _collectionScript;\n        isCollectionCreated[newCollectionIndex] = true;\n        newCollectionIndex = newCollectionIndex + 1;\n    }\n\n    // function to add/modify the additional data of a collection\n    // once a collection is created and total supply is set it cannot be changed\n    // only _collectionArtistAddress , _maxCollectionPurchases can change after total supply is set\n\n    function setCollectionData(uint256 _collectionID, address _collectionArtistAddress, uint256 _maxCollectionPurchases, uint256 _collectionTotalSupply, uint _setFinalSupplyTimeAfterMint) public CollectionAdminRequired(_collectionID, this.setCollectionData.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false) && (_collectionTotalSupply <= 10000000000), \"err/freezed\");\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply == 0) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].collectionCirculationSupply = 0;\n            collectionAdditionalData[_collectionID].collectionTotalSupply = _collectionTotalSupply;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n            collectionAdditionalData[_collectionID].reservedMinTokensIndex = (_collectionID * 10000000000);\n            collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + _collectionTotalSupply - 1;\n            wereDataAdded[_collectionID] = true;\n        } else if (artistSigned[_collectionID] == false) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        } else {\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        }\n    }\n\n    // Add Randomizer contract on collection\n\n    function addRandomizer(uint256 _collectionID, address _randomizerContract) public FunctionAdminRequired(this.addRandomizer.selector) {\n        require(IRandomizer(_randomizerContract).isRandomizerContract() == true, \"Contract is not Randomizer\");\n        collectionAdditionalData[_collectionID].randomizerContract = _randomizerContract;\n        collectionAdditionalData[_collectionID].randomizer = IRandomizer(_randomizerContract);\n    }\n\n    // airdrop called from minterContract\n    \n    function airDropTokens(uint256 mintIndex, address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        collectionAdditionalData[_collectionID].collectionCirculationSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply >= collectionAdditionalData[_collectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, _recipient, _tokenData, _collectionID, _saltfun_o);\n            tokensAirdropPerAddress[_collectionID][_recipient] = tokensAirdropPerAddress[_collectionID][_recipient] + 1;\n        }\n    }\n\n    // mint called from minterContract\n\n    function mint(uint256 mintIndex, address _mintingAddress , address _mintTo, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint256 phase) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        collectionAdditionalData[_collectionID].collectionCirculationSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply >= collectionAdditionalData[_collectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, _mintTo, _tokenData, _collectionID, _saltfun_o);\n            if (phase == 1) {\n                tokensMintedAllowlistAddress[_collectionID][_mintingAddress] = tokensMintedAllowlistAddress[_collectionID][_mintingAddress] + 1;\n            } else {\n                tokensMintedPerAddress[_collectionID][_mintingAddress] = tokensMintedPerAddress[_collectionID][_mintingAddress] + 1;\n            }\n        }\n    }\n\n    // burn function\n\n    function burn(uint256 _collectionID, uint256 _tokenId) public {\n        require(_isApprovedOrOwner(_msgSender(), _tokenId), \"ERC721: caller is not token owner or approved\");\n        require ((_tokenId >= collectionAdditionalData[_collectionID].reservedMinTokensIndex) && (_tokenId <= collectionAdditionalData[_collectionID].reservedMaxTokensIndex), \"id err\");\n        _burn(_tokenId);\n        burnAmount[_collectionID] = burnAmount[_collectionID] + 1;\n    }\n\n    // burn to mint called from minterContract\n\n    function burnToMint(uint256 mintIndex, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o, address burner) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        require(_isApprovedOrOwner(burner, _tokenId), \"ERC721: caller is not token owner or approved\");\n        collectionAdditionalData[_mintCollectionID].collectionCirculationSupply = collectionAdditionalData[_mintCollectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_mintCollectionID].collectionTotalSupply >= collectionAdditionalData[_mintCollectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, ownerOf(_tokenId), tokenData[_tokenId], _mintCollectionID, _saltfun_o);\n            // burn token\n            _burn(_tokenId);\n            burnAmount[_burnCollectionID] = burnAmount[_burnCollectionID] + 1;\n        }\n    }\n\n    // mint processing\n\n    function _mintProcessing(uint256 _mintIndex, address _recipient, string memory _tokenData, uint256 _collectionID, uint256 _saltfun_o) internal {\n        tokenData[_mintIndex] = _tokenData;\n        collectionAdditionalData[_collectionID].randomizer.calculateTokenHash(_collectionID, _mintIndex, _saltfun_o);\n        tokenIdsToCollectionIds[_mintIndex] = _collectionID;\n        _safeMint(_recipient, _mintIndex);\n    }\n\n    // Additional setter functions\n\n    // function to update Collection Info\n\n    function updateCollectionInfo(uint256 _collectionID, string memory _newCollectionName, string memory _newCollectionArtist, string memory _newCollectionDescription, string memory _newCollectionWebsite, string memory _newCollectionLicense, string memory _newCollectionBaseURI, string memory _newCollectionLibrary, uint256 _index, string[] memory _newCollectionScript) public CollectionAdminRequired(_collectionID, this.updateCollectionInfo.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false), \"Not allowed\");\n         if (_index == 1000) {\n            collectionInfo[_collectionID].collectionName = _newCollectionName;\n            collectionInfo[_collectionID].collectionArtist = _newCollectionArtist;\n            collectionInfo[_collectionID].collectionDescription = _newCollectionDescription;\n            collectionInfo[_collectionID].collectionWebsite = _newCollectionWebsite;\n            collectionInfo[_collectionID].collectionLicense = _newCollectionLicense;\n            collectionInfo[_collectionID].collectionLibrary = _newCollectionLibrary;\n            collectionInfo[_collectionID].collectionScript = _newCollectionScript;\n        } else if (_index == 999) {\n            collectionInfo[_collectionID].collectionBaseURI = _newCollectionBaseURI;\n        } else {\n            collectionInfo[_collectionID].collectionScript[_index] = _newCollectionScript[0];\n        }\n    }\n\n    // function for artist signature\n\n    function artistSignature(uint256 _collectionID, string memory _signature) public {\n        require(msg.sender == collectionAdditionalData[_collectionID].collectionArtistAddress, \"Only artist\");\n        require(artistSigned[_collectionID] == false, \"Already Signed\");\n        artistsSignatures[_collectionID] = _signature;\n        artistSigned[_collectionID] = true;\n    }\n\n    // function change metadata view \n\n    function changeMetadataView(uint256 _collectionID, bool _status) public CollectionAdminRequired(_collectionID, this.changeMetadataView.selector) { \n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false), \"Not allowed\");\n        onchainMetadata[_collectionID] = _status;\n    }\n\n    // function to change the token data\n\n    function changeTokenData(uint256 _tokenId, string memory newData) public FunctionAdminRequired(this.changeTokenData.selector) {\n        require(collectionFreeze[tokenIdsToCollectionIds[_tokenId]] == false, \"Data frozen\");\n        _requireMinted(_tokenId);\n        tokenData[_tokenId] = newData;\n    }\n\n    // function to add a thumbnail image\n\n    function updateImagesAndAttributes(uint256[] memory _tokenId, string[] memory _images, string[] memory _attributes) public FunctionAdminRequired(this.updateImagesAndAttributes.selector) {\n        for (uint256 x; x < _tokenId.length; x++) {\n            require(collectionFreeze[tokenIdsToCollectionIds[_tokenId[x]]] == false, \"Data frozen\");\n            _requireMinted(_tokenId[x]);\n            tokenImageAndAttributes[_tokenId[x]][0] = _images[x];\n            tokenImageAndAttributes[_tokenId[x]][1] = _attributes[x];\n        }\n    }\n\n    // freeze collection\n\n    function freezeCollection(uint256 _collectionID) public FunctionAdminRequired(this.freezeCollection.selector) {\n        require(isCollectionCreated[_collectionID] == true, \"No Col\");\n        collectionFreeze[_collectionID] = true;\n    }\n\n    // set tokenHash\n\n    function setTokenHash(uint256 _collectionID, uint256 _mintIndex, bytes32 _hash) external {\n        require(msg.sender == collectionAdditionalData[_collectionID].randomizerContract);\n        require(tokenToHash[_mintIndex] == 0x0000000000000000000000000000000000000000000000000000000000000000);\n        tokenToHash[_mintIndex] = _hash;\n    }\n\n    // set final supply\n\n    function setFinalSupply(uint256 _collectionID) public FunctionAdminRequired(this.setFinalSupply.selector) {\n        require (block.timestamp > IMinterContract(minterContract).getEndTime(_collectionID) + collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint, \"Time has not passed\");\n        collectionAdditionalData[_collectionID].collectionTotalSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply;\n        collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + collectionAdditionalData[_collectionID].collectionTotalSupply - 1;\n    }\n\n    // function to add a minter contract\n\n    function addMinterContract(address _minterContract) public FunctionAdminRequired(this.addMinterContract.selector) { \n        require(IMinterContract(_minterContract).isMinterContract() == true, \"Contract is not Minter\");\n        minterContract = _minterContract;\n    }\n\n    // function to update admin contract\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    // function to update default royalties\n    \n    function setDefaultRoyalties(address _royaltyAddress, uint96 _bps) public FunctionAdminRequired(this.setDefaultRoyalties.selector) {\n        _setDefaultRoyalty(_royaltyAddress, _bps);\n    }\n\n    // Retrieve Functions\n\n    // function to override supportInterface\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, ERC2981) returns (bool) { \n        return super.supportsInterface(interfaceId); \n    }\n\n    // function to return the tokenURI\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        if (onchainMetadata[tokenIdsToCollectionIds[tokenId]] == false && tokenToHash[tokenId] != 0x0000000000000000000000000000000000000000000000000000000000000000) {\n            string memory baseURI = collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionBaseURI;\n            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n        } else if (onchainMetadata[tokenIdsToCollectionIds[tokenId]] == false && tokenToHash[tokenId] == 0x0000000000000000000000000000000000000000000000000000000000000000) {\n            string memory baseURI = collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionBaseURI;\n            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, \"pending\")) : \"\";\n        }\n        else {\n            string memory b64 = Base64.encode(abi.encodePacked(\"<html><head></head><body><script src=\\\"\",collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionLibrary,\"\\\"></script><script>\",retrieveGenerativeScript(tokenId),\"</script></body></html>\"));\n            string memory _uri = string(abi.encodePacked(\"data:application/json;utf8,{\\\"name\\\":\\\"\",getTokenName(tokenId),\"\\\",\\\"description\\\":\\\"\",collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionDescription,\"\\\",\\\"image\\\":\\\"\",tokenImageAndAttributes[tokenId][0],\"\\\",\\\"attributes\\\":[\",tokenImageAndAttributes[tokenId][1],\"],\\\"animation_url\\\":\\\"data:text/html;base64,\",b64,\"\\\"}\"));\n            return _uri;\n        }\n    }\n\n    // function get Name\n\n    function getTokenName(uint256 tokenId) private view returns(string memory)  {\n        uint256 tok = tokenId - collectionAdditionalData[tokenIdsToCollectionIds[tokenId]].reservedMinTokensIndex;\n        return string(abi.encodePacked(collectionInfo[viewColIDforTokenID(tokenId)].collectionName, \" #\" ,tok.toString()));\n    }\n\n    // retrieve the collection freeze status\n    function collectionFreezeStatus(uint256 _collectionID) public view returns(bool){\n        return collectionFreeze[_collectionID];\n    }\n\n    // function to return the collection id given a token id\n    function viewColIDforTokenID(uint256 _tokenid) public view returns (uint256) {\n        return(tokenIdsToCollectionIds[_tokenid]);\n    }\n\n    // retrieve if data were added\n    function retrievewereDataAdded(uint256 _collectionID) external view returns(bool){\n        return wereDataAdded[_collectionID];\n    }\n\n    // function to return the min index id of a collection\n\n    function viewTokensIndexMin(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].reservedMinTokensIndex);\n    }\n\n    // function to return the max index id of a collection\n\n    function viewTokensIndexMax(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].reservedMaxTokensIndex);\n    }\n\n    // function to return the circ supply of a collection\n    function viewCirSupply(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].collectionCirculationSupply);\n    }\n\n    // function to return max allowance in public sale\n    function viewMaxAllowance(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].maxCollectionPurchases);\n    }\n\n    // function to return tokens minted per address during AL\n    function retrieveTokensMintedALPerAddress(uint256 _collectionID, address _address) external view returns(uint256) {\n        return (tokensMintedAllowlistAddress[_collectionID][_address]);\n    }\n\n    // function to return tokens minted per address during Public\n    function retrieveTokensMintedPublicPerAddress(uint256 _collectionID, address _address) external view returns(uint256) {\n        return (tokensMintedPerAddress[_collectionID][_address]);\n    }\n\n    // function to retrieve the airdrop/minted tokens per address \n\n    function retrieveTokensAirdroppedPerAddress(uint256 _collectionID, address _address) public view returns(uint256) {\n        return (tokensAirdropPerAddress[_collectionID][_address]);\n    }\n\n    // function to return the artist's address\n    function retrieveArtistAddress(uint256 _collectionID) external view returns(address) {\n        return (collectionAdditionalData[_collectionID].collectionArtistAddress);\n    }\n\n    // function to retrieve a Collection's Info\n\n    function retrieveCollectionInfo(uint256 _collectionID) public view returns(string memory, string memory, string memory, string memory, string memory, string memory){\n        return (collectionInfo[_collectionID].collectionName, collectionInfo[_collectionID].collectionArtist, collectionInfo[_collectionID].collectionDescription, collectionInfo[_collectionID].collectionWebsite, collectionInfo[_collectionID].collectionLicense, collectionInfo[_collectionID].collectionBaseURI);\n    }\n\n    // function to retrieve the library and script of a collection\n\n    function retrieveCollectionLibraryAndScript(uint256 _collectionID) public view returns(string memory, string[] memory){\n        return (collectionInfo[_collectionID].collectionLibrary, collectionInfo[_collectionID].collectionScript);\n    }\n\n    // function to retrieve the Additional data of a Collection\n\n    function retrieveCollectionAdditionalData(uint256 _collectionID) public view returns(address, uint256, uint256, uint256, uint, address){\n        return (collectionAdditionalData[_collectionID].collectionArtistAddress, collectionAdditionalData[_collectionID].maxCollectionPurchases, collectionAdditionalData[_collectionID].collectionCirculationSupply, collectionAdditionalData[_collectionID].collectionTotalSupply, collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint, collectionAdditionalData[_collectionID].randomizerContract);\n    }\n\n    // function to retrieve tokenHash\n\n    function retrieveTokenHash(uint256 _tokenid) public view returns(bytes32){\n        return (tokenToHash[_tokenid]);\n    }\n\n    // function to retrieve the Generative Script of a token\n\n    function retrieveGenerativeScript(uint256 tokenId) public view returns(string memory){\n        _requireMinted(tokenId);\n        string memory scripttext;\n        for (uint256 i=0; i < collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionScript.length; i++) {\n            scripttext = string(abi.encodePacked(scripttext, collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionScript[i])); \n        }\n        return string(abi.encodePacked(\"let hash='\",Strings.toHexString(uint256(tokenToHash[tokenId]), 32),\"';let tokenId=\",tokenId.toString(),\";let tokenData=[\",tokenData[tokenId],\"];\", scripttext));\n    }\n\n    // function to retrieve the supply of a collection\n\n    function totalSupplyOfCollection(uint256 _collectionID) public view returns (uint256) {\n        return (collectionAdditionalData[_collectionID].collectionCirculationSupply - burnAmount[_collectionID]);\n    }\n\n    // function to retrieve the token image uri and the attributes stored on-chain for a token id.\n\n    function retrievetokenImageAndAttributes(uint256 _tokenId) public view returns(string memory, string memory) {\n        return (tokenImageAndAttributes[_tokenId][0],tokenImageAndAttributes[_tokenId][1]);\n    }\n\n}"
    },
    {
      "filename": "smart-contracts/NextGenCore.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Smart Contract\n *  @date: 19-October-2023 \n *  @version: 10.28\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./ERC721Enumerable.sol\";\nimport \"./Ownable.sol\";\nimport \"./Strings.sol\";\nimport \"./Base64.sol\";\nimport \"./IRandomizer.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IMinterContract.sol\";\nimport \"./ERC2981.sol\";\n\ncontract NextGenCore is ERC721Enumerable, Ownable, ERC2981 {\n    using Strings for uint256;\n\n    // declare variables\n    uint256 public newCollectionIndex;\n\n    // collectionInfo struct declaration\n    struct collectionInfoStructure {\n        string collectionName;\n        string collectionArtist;\n        string collectionDescription;\n        string collectionWebsite;\n        string collectionLicense;\n        string collectionBaseURI;\n        string collectionLibrary;\n        string[] collectionScript;\n    }\n\n    // mapping of collectionInfo struct\n    mapping (uint256 => collectionInfoStructure) private collectionInfo;\n\n    // collectionAdditionalData struct declaration\n    struct collectionAdditonalDataStructure {\n        address collectionArtistAddress;\n        uint256 maxCollectionPurchases;\n        uint256 collectionCirculationSupply;\n        uint256 collectionTotalSupply;\n        uint256 reservedMinTokensIndex;\n        uint256 reservedMaxTokensIndex;\n        uint setFinalSupplyTimeAfterMint;\n        address randomizerContract;\n        IRandomizer randomizer;\n    }\n\n    // mapping of collectionAdditionalData struct\n    mapping (uint256 => collectionAdditonalDataStructure) private collectionAdditionalData;\n\n    // other mappings\n\n    // checks if a collection was created\n    mapping (uint256 => bool) private isCollectionCreated; \n\n    // checks if data on a collection were added\n    mapping (uint256 => bool) private wereDataAdded;\n\n    // maps tokends ids with collectionsids\n    mapping (uint256 => uint256) private tokenIdsToCollectionIds;\n\n    // stores randomizer hash\n    mapping(uint256 => bytes32) private tokenToHash;\n\n    // minted tokens per address per collection during public sale\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedPerAddress;\n\n    // minted tokens per address per collection during allowlist\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedAllowlistAddress;\n\n    // tokens airdrop per address per collection \n    mapping (uint256 => mapping (address => uint256)) private tokensAirdropPerAddress;\n\n    // current amount of burnt tokens per collection\n    mapping (uint256 => uint256) public burnAmount;\n\n    // modify the metadata view\n    mapping (uint256 => bool) public onchainMetadata; \n\n    // artist signature per collection\n    mapping (uint256 => string) public artistsSignatures;\n\n    // tokens additional metadata\n    mapping (uint256 => string) public tokenData;\n\n    // on-chain token Image URI and attributes\n    mapping (uint256 => string[2]) private tokenImageAndAttributes;\n\n    // collectionFreeze \n    mapping (uint256 => bool) private collectionFreeze;\n\n    // artist signed\n    mapping (uint256 => bool) public artistSigned; \n\n    // external contracts declaration\n    INextGenAdmins private adminsContract;\n    address public minterContract;\n\n    // smart contract constructor\n    constructor(string memory name, string memory symbol, address _adminsContract) ERC721(name, symbol) {\n        adminsContract = INextGenAdmins(_adminsContract);\n        newCollectionIndex = newCollectionIndex + 1;\n        _setDefaultRoyalty(0x1B1289E34Fe05019511d7b436a5138F361904df0, 690);\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to create a Collection\n\n    function createCollection(string memory _collectionName, string memory _collectionArtist, string memory _collectionDescription, string memory _collectionWebsite, string memory _collectionLicense, string memory _collectionBaseURI, string memory _collectionLibrary, string[] memory _collectionScript) public FunctionAdminRequired(this.createCollection.selector) {\n        collectionInfo[newCollectionIndex].collectionName = _collectionName;\n        collectionInfo[newCollectionIndex].collectionArtist = _collectionArtist;\n        collectionInfo[newCollectionIndex].collectionDescription = _collectionDescription;\n        collectionInfo[newCollectionIndex].collectionWebsite = _collectionWebsite;\n        collectionInfo[newCollectionIndex].collectionLicense = _collectionLicense;\n        collectionInfo[newCollectionIndex].collectionBaseURI = _collectionBaseURI;\n        collectionInfo[newCollectionIndex].collectionLibrary = _collectionLibrary;\n        collectionInfo[newCollectionIndex].collectionScript = _collectionScript;\n        isCollectionCreated[newCollectionIndex] = true;\n        newCollectionIndex = newCollectionIndex + 1;\n    }\n\n    // function to add/modify the additional data of a collection\n    // once a collection is created and total supply is set it cannot be changed\n    // only _collectionArtistAddress , _maxCollectionPurchases can change after total supply is set\n\n    function setCollectionData(uint256 _collectionID, address _collectionArtistAddress, uint256 _maxCollectionPurchases, uint256 _collectionTotalSupply, uint _setFinalSupplyTimeAfterMint) public CollectionAdminRequired(_collectionID, this.setCollectionData.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false) && (_collectionTotalSupply <= 10000000000), \"err/freezed\");\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply == 0) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].collectionCirculationSupply = 0;\n            collectionAdditionalData[_collectionID].collectionTotalSupply = _collectionTotalSupply;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n            collectionAdditionalData[_collectionID].reservedMinTokensIndex = (_collectionID * 10000000000);\n            collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + _collectionTotalSupply - 1;\n            wereDataAdded[_collectionID] = true;\n        } else if (artistSigned[_collectionID] == false) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        } else {\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFin"
    }
  ]
}