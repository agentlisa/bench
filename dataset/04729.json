{
  "Title": "[M-01] `asdRouter.sol` is at risk of DOS due to vulnerable implementation of `NOTE` address",
  "Content": "\n### Proof of Concept\n\nBased on Canto [doc](https://docs.canto.io/evm-development/dex-and-lending-market#note), `NOTE` address may be modified and redeployed:\n\n> The `NOTE` smart contract may be modified and redeployed at a new address in the future. For this reason, DApps should use the `CToken.underlying()` view on the `cNOTE` contract to determine the address for `NOTE` instead of hardcoding it.\n\nAs stated in doc, Dapp should use `CToken.underlying()` to ensure that `NOTE` address used is always correct.\n\nThe problem is current implementation in `asdRouter.sol` will only initiate `noteAddress` at contract deployment. `noteAddress` can not be changed afterward and the effect is the same as hardcoding an address.\n\n```solidity\n//contracts/asd/asdRouter.sol\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        //@audit No method to change noteAddress after deployment.\n|>      noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n    }\n```\n\n<https://github.com/code-423n4/2024-03-canto/blob/52dd3d7083ca9bed0484180f4a5f3af84a10a9bc/contracts/asd/asdRouter.sol#L45>\n\nNote: When performing swap from `asdUSDC` to `NOTE`, `noteAddress` will be used instead of `CToken.underlying()`. This means when `NOTE` address changes, `swap` and `lzcompose` will be DOSed.\n\n```solidity\n//contracts/asd/asdRouter.sol\n    function _swapOFTForNote(address _oftAddress, uint _amount, uint _minAmountNote) internal returns (uint, bool) {\n...\n        if (_oftAddress < noteAddress) {\n            baseToken = _oftAddress;\n|>          quoteToken = noteAddress;\n        } else {\n|>          baseToken = noteAddress;\n            quoteToken = _oftAddress;\n        }\n...\n```\n\n<https://github.com/code-423n4/2024-03-canto/blob/52dd3d7083ca9bed0484180f4a5f3af84a10a9bc/contracts/asd/asdRouter.sol#L214-L218>\n\nFor comparison, `asdOFT.sol` has the [correct `NOTE` address implementation](https://github.com/code-423n4/2024-03-canto/blob/52dd3d7083ca9bed0484180f4a5f3af84a10a9bc/contracts/asd/asdOFT.sol#L53) where `cNoteToken.underlying()` is used.\n\n### Recommended Mitigation Steps\n\nChange to store `cNote` address and only use `CNote.underlying()`.\n\n**[dsudit01 (Canto) confirmed and commented](https://github.com/code-423n4/2024-03-canto-findings/issues/13#issuecomment-2040497428):**\n > PR [here](https://github.com/Plex-Engineer/ASD-V2/pull/3).\n\n**[SpicyMeatball (warden) commented](https://github.com/code-423n4/2024-03-canto-findings/issues/13#issuecomment-2041105258):**\n > @3docSec - I think QA is more appropriate: \n> - The probability is low, changing the `NOTE` address is a rare event which may never occur.\n> - The impact is medium at best, a temporary DOS which can be mitigated by redeploying the router with a new `NOTE` address. Canto can do it prior to redeploying the `NOTE` token to streamline the process.\n\n**[3docSec (judge) commented](https://github.com/code-423n4/2024-03-canto-findings/issues/13#issuecomment-2041119228):**\n > The doc is clear about this, `cNOTE` address changes are a design choice in the ecosystem, and that's a fact. That the event is rare and may never happen is subjective.\n> \n> As per the second point, the SC helped clear out that [the possibility of deploying a new version of the contract should not be reason for mitigating severity of a finding](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-using-contract-upgradability-as-a-severity-mitigation).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-canto",
  "Code": [
    {
      "filename": "contracts/asd/asdRouter.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ASDOFT} from \"./asdOFT.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {ICrocSwapDex, ICrocImpact} from \"../ambient/CrocInterfaces.sol\";\nimport {ASDUSDC} from \"./asdUSDC.sol\";\n\n/**\n * @title ASDRouter\n */\n\ncontract ASDRouter is IOAppComposer, Ownable {\n    // ambient params\n    address public crocSwapAddress;\n    address public crocImpactAddress;\n    uint public constant ambientPoolIdx = 36000;\n    // canto chain params\n    address public noteAddress;\n    uint32 public cantoLzEID;\n    // asdUSDC contract for swapping to $NOTE\n    address public asdUSDC;\n\n    struct OftComposeMessage {\n        uint32 _dstLzEid;\n        address _dstReceiver;\n        address _dstAsdAddress;\n        address _cantoAsdAddress;\n        uint256 _minAmountASD;\n        address _cantoRefundAddress;\n        uint256 _feeForSend;\n    }\n\n    event LZReceived(bytes32 indexed _guid, address _from, bytes _message, address _executor, bytes _extraData, uint _value);\n\n    event TokenRefund(bytes32 indexed _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string _reason);\n\n    event ASDSent(bytes32 indexed _guid, address _to, address _asdAddress, uint _amount, uint32 _dstEid, bool _lzSend);\n\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n    }\n\n    /**\n     * @notice Called by the LZ executor after sending OFT tokens to this contract.\n     * @param _from The address of the OFT on this chain.\n     * @param _guid The GUID of the message.\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @param _executor The address of the executor.\n     * @param _extraData Additional data supplied by the executor.\n     * @dev Cannot revert anywhere, must send the tokens to the intended receiver if something fails (token's will be lost otherwise)\n     */\n    function lzCompose(address _from, bytes32 _guid, bytes calldata _message, address _executor, bytes calldata _extraData) external payable {\n        /* log event */\n        emit LZReceived(_guid, _from, _message, _executor, _extraData, msg.value);\n\n        /* decode OFT composed message */\n        (, , uint256 amountLD, bytes32 composeFrom, bytes memory composeMsg) = _decodeOFTComposeMsg(_message);\n\n        /* decode composed message payload */\n\n        // check the composed message for proper formatting\n        if (composeMsg.length != 224) {\n            // return tokens to the address that sent them (composeFrom)\n            _refundToken(_guid, _from, OFTComposeMsgCodec.bytes32ToAddress(composeFrom), amountLD, msg.value, \"Invalid composeMsg length\");\n            return;\n        }\n        OftComposeMessage memory payload = abi.decode(composeMsg, (OftComposeMessage));\n\n        /* check if the OFT stable coin is whitelisted */\n        if (!ASDUSDC(asdUSDC).whitelistedUSDCVersions(_from)) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, _from, payload._cantoRefundAddress, amountLD, msg.value, \"not whitelisted\");\n            return;\n        }\n\n        /* deposit oft to receive asdUSDC for swapping */\n        IERC20(_from).approve(asdUSDC, amountLD);\n        uint amountUSDC = ASDUSDC(asdUSDC).deposit(_from, amountLD);\n\n        /* swap tokens for $NOTE (check minAmount for slippage) */\n        (uint amountNote, bool successfulSwap) = _swapOFTForNote(asdUSDC, amountUSDC, payload._minAmountASD);\n\n        // check if the swap was successful\n        if (!successfulSwap) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, asdUSDC, payload._cantoRefundAddress, amountUSDC, msg.value, \"swap failed\");\n            return;\n        }\n\n        /* deposit $NOTE to the correct asd vault to receive ASD tokens */\n        (bool successfulDeposit, string memory reason) = _depositNoteToASDVault(payload._cantoAsdAddress, amountNote);\n\n        // check if deposit was successful\n        if (!successfulDeposit) {\n            // return $NOTE to the refund address on canto since OFT was swapped already\n            _refundToken(_guid, noteAddress, payload._cantoRefundAddress, amountNote, msg.value, reason);\n            return;\n        }\n\n        /* transfer the ASD tokens to the destination receiver */\n        _sendASD(_guid, payload, amountNote);\n    }\n\n    /**\n     *\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @return _nonce The nonce value.\n     * @return _srcEid The source endpoint ID.\n     * @return _amountLD The amount in local decimals.\n     * @return _composeFrom The composeFrom value (msg.sender on from chain).\n     * @return _composeMsg The composed message.\n     */\n    function _decodeOFTComposeMsg(bytes calldata _message) internal pure returns (uint64 _nonce, uint32 _srcEid, uint256 _amountLD, bytes32 _composeFrom, bytes memory _composeMsg) {\n        _nonce = OFTComposeMsgCodec.nonce(_message);\n        _srcEid = OFTComposeMsgCodec.srcEid(_message);\n        _amountLD = OFTComposeMsgCodec.amountLD(_message);\n        _composeFrom = OFTComposeMsgCodec.composeFrom(_message);\n        _composeMsg = OFTComposeMsgCodec.composeMsg(_message);\n    }\n\n    /**\n     * @param _guid the GUID of the message from layer zero.\n     * @param _payload the payload of the message.\n     * @param _amount  the amount of ASD tokens to send.\n     */\n    function _sendASD(bytes32 _guid, OftComposeMessage memory _payload, uint _amount) internal {\n        /* transfer the ASD tokens to the destination receiver */\n        if (_payload._dstLzEid == cantoLzEID) {\n            // just transfer the ASD tokens to the destination receiver\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, false);\n            ASDOFT(_payload._cantoAsdAddress).transfer(_payload._dstReceiver, _amount);\n        } else {\n            // use Layer Zero oapp to send ASD tokens to the destination receiver on the destination chain\n\n            // make sure msg.value is enough to cover the fee or this transaction will revert\n            if (msg.value < _payload._feeForSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, \"insufficient msg.value for send fee\");\n                return;\n            }\n\n            // create send params for the Layer Zero oapp\n            bytes memory sendOptions = OptionsBuilder.addExecutorLzReceiveOption(OptionsBuilder.newOptions(), 200000, 0);\n            SendParam memory sendParams = SendParam({dstEid: _payload._dstLzEid, to: OFTComposeMsgCodec.addressToBytes32(_payload._dstReceiver), amountLD: _amount, minAmountLD: _amount, extraOptions: sendOptions, composeMsg: \"0x\", oftCmd: \"0x\"});\n            MessagingFee memory fee = MessagingFee({nativeFee: _payload._feeForSend, lzTokenFee: 0});\n\n            // send tokens\n            (bool successfulSend, bytes memory data) = payable(_payload._cantoAsdAddress).call{value: _payload._feeForSend}(abi.encodeWithSelector(IOFT.send.selector, sendParams, fee, _payload._cantoRefundAddress));\n\n            // check if the send was successful\n            if (!successfulSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, string(data));\n                return;\n            }\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, true);\n        }\n    }\n\n    /**\n     * @notice refunds tokens when lzCompose fails\n     * @param _guid The GUID of the message from layer zero.\n     * @param _tokenAddress address of token\n     * @param _refundAddress address to refund to on canto\n     * @param _amount amount to send\n     * @param _nativeAmount amount to send in native token\n     */\n    function _refundToken(bytes32 _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string memory _reason) internal {\n        // emit event\n        emit TokenRefund(_guid, _tokenAddress, _refundAddress, _amount, _nativeAmount, _reason);\n        // transfer tokens to refund address\n        IERC20(_tokenAddress).transfer(_refundAddress, _amount);\n        // transfer native tokens to refund address and check that this value is less than or equal to msg.value\n        if (_nativeAmount > 0 && _nativeAmount <= msg.value) {\n            payable(_refundAddress).transfer(_nativeAmount);\n        }\n    }\n\n    /**\n     * @notice deposits $NOTE to the correct asd vault to receive ASD tokens\n     * @param _asdVault The address of the ASD vault to deposit to\n     * @param _amountNote The amount of $NOTE to deposit\n     */\n    function _depositNoteToASDVault(address _asdVault, uint _amountNote) internal returns (bool, string memory) {\n        // approve asd vault to spend $NOTE\n        IERC20(noteAddress).approve(_asdVault, _amountNote);\n        // deposit $NOTE to asd vault (use call, so this doesn't revert)\n        (bool success, bytes memory errReason) = _asdVault.call(abi.encodeWithSelector(ASDOFT.mint.selector, _amountNote));\n        return (success, string(errReason));\n    }\n\n    /**\n     * @notice swaps an OFT stable coin for $NOTE\n     * @dev only callable by the owner\n     * @param _oftAddress The address of the OFT stable coin contract\n     * @param _amount The amount of OFT stable coin to swap\n     * @param _minAmountNote The minimum amount of $NOTE to receive\n     * @return amount The amount of $NOTE received or error code\n     */\n    function _swapOFTForNote(address _oftAddress, uint _amount, uint _minAmountNote) internal returns (uint, bool) {\n        // sort tokens\n        address baseToken;\n        address quoteToken;\n        if (_oftAddress < noteAddress) {\n            baseToken = _oftAddress;\n            quoteToken = noteAddress;\n        } else {\n            baseToken = noteAddress;\n            quoteToken = _oftAddress;\n        }\n        // check if pool exists\n        if (ambientPoolFor(baseToken, quoteToken, ambientPoolIdx) == 0) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n\n        // convert amount to uint128\n        uint128 amountConverted = uint128(_amount);\n        // query impact to make sure user will receive at least _minAmountNote\n        bool isNoteBase = baseToken == noteAddress;\n        (int128 baseFlow, int128 quoteFlow, ) = ICrocImpact(crocImpactAddress).calcImpact(baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0);\n\n        // check if amount note received is greater than or equal to _minAmountNote\n\n        int minAmountInt = int(_minAmountNote); // stack too deep fix\n        // flow is negative if it left the pool, so multiply by -1\n        if (isNoteBase && -baseFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        } else if (!isNoteBase && -quoteFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // convert minAmount to uint for stack too deep fix\n        uint128 uintMinAmount = uint128(_minAmountNote);\n\n        // swap is good to make, use call just in case revert occurs\n        (bool successSwap, bytes memory data) = crocSwapAddress.call(abi.encodeWithSelector(ICrocSwapDex.swap.selector, baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0, uintMinAmount, 0));\n        if (!successSwap) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // return amount of note received\n        (int128 baseUsed, int128 quoteUsed) = abi.decode(data, (int128, int128));\n        return (uint128(-1 * (isNoteBase ? baseUsed : quoteUsed)), true);\n    }\n\n    function ambientPoolFor(address _baseToken, address _quoteToken, uint256 _poolIdx) internal view returns (uint256) {\n        bytes32 poolKey = keccak256(abi.encode(_baseToken, _quoteToken, _poolIdx));\n        uint POOL_PARAM_SLOT = 65545;\n        bytes32 slot = keccak256(abi.encode(poolKey, POOL_PARAM_SLOT));\n        return ICrocSwapDex(crocSwapAddress).readSlot(uint256(slot));\n    }\n}"
    },
    {
      "filename": "contracts/asd/asdRouter.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ASDOFT} from \"./asdOFT.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {ICrocSwapDex, ICrocImpact} from \"../ambient/CrocInterfaces.sol\";\nimport {ASDUSDC} from \"./asdUSDC.sol\";\n\n/**\n * @title ASDRouter\n */\n\ncontract ASDRouter is IOAppComposer, Ownable {\n    // ambient params\n    address public crocSwapAddress;\n    address public crocImpactAddress;\n    uint public constant ambientPoolIdx = 36000;\n    // canto chain params\n    address public noteAddress;\n    uint32 public cantoLzEID;\n    // asdUSDC contract for swapping to $NOTE\n    address public asdUSDC;\n\n    struct OftComposeMessage {\n        uint32 _dstLzEid;\n        address _dstReceiver;\n        address _dstAsdAddress;\n        address _cantoAsdAddress;\n        uint256 _minAmountASD;\n        address _cantoRefundAddress;\n        uint256 _feeForSend;\n    }\n\n    event LZReceived(bytes32 indexed _guid, address _from, bytes _message, address _executor, bytes _extraData, uint _value);\n\n    event TokenRefund(bytes32 indexed _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string _reason);\n\n    event ASDSent(bytes32 indexed _guid, address _to, address _asdAddress, uint _amount, uint32 _dstEid, bool _lzSend);\n\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n    }\n\n    /**\n     * @notice Called by the LZ executor after sending OFT tokens to this contract.\n     * @param _from The address of the OFT on this chain.\n     * @param _guid The GUID of the message.\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @param _executor The address of the executor.\n     * @param _extraData Additional data supplied by the executor.\n     * @dev Cannot revert anywhere, must send the tokens to the intended receiver if something fails (token's will be lost otherwise)\n     */\n    function lzCompose(address _from, bytes32 _guid, bytes calldata _message, address _executor, bytes calldata _extraData) external payable {\n        /* log event */\n        emit LZReceived(_guid, _from, _message, _executor, _extraData, msg.value);\n\n        /* decode OFT composed message */\n        (, , uint256 amountLD, bytes32 composeFrom, bytes memory composeMsg) = _decodeOFTComposeMsg(_message);\n\n        /* decode composed message payload */\n\n        // check the composed message for proper formatting\n        if (composeMsg.length != 224) {\n            // return tokens to the address that sent them (composeFrom)\n            _refundToken(_guid, _from, OFTComposeMsgCodec.bytes32ToAddress(composeFrom), amountLD, msg.value, \"Invalid composeMsg length\");\n            return;\n        }\n        OftComposeMessage memory payload = abi.decode(composeMsg, (OftComposeMessage));\n\n        /* check if the OFT stable coin is whitelisted */\n        if (!ASDUSDC(asdUSDC).whitelistedUSDCVersions(_from)) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, _from, payload._cantoRefundAddress, amountLD, msg.value, \"not whitelisted\");\n            return;\n        }\n\n        /* deposit oft to receive asdUSDC for swapping */\n        IERC20(_from).approve(asdUSDC, amountLD);\n        uint amountUSDC = ASDUSDC(asdUSDC).deposit(_from, amountLD);\n\n        /* swap tokens for $NOTE (check minAmount for slippage) */\n        (uint amountNote, bool successfulSwap) = _swapOFTForNote(asdUSDC, amountUSDC, payload._minAmountASD);\n\n        // check if the swap was successful\n        if (!successfulSwap) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, asdUSDC, payload._cantoRefundAddress, amountUSDC, msg.value, \"swap failed\");\n            return;\n        }\n\n        /* deposit $NOTE to the correct asd vault to receive ASD tokens */\n        (bool successfulDeposit, string memory reason) = _depositNoteToASDVault(payload._cantoAsdAddress, amountNote);\n\n        // check if deposit was successful\n        if (!successfulDeposit) {\n            // return $NOTE to the refund address on canto since OFT was swapped already\n            _refundToken(_guid, noteAddress, payload._cantoRefundAddress, amountNote, msg.value, reason);\n            return;\n        }\n\n        /* transfer the ASD tokens to the destination receiver */\n        _sendASD(_guid, payload, amountNote);\n    }\n\n    /**\n     *\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @return _nonce The nonce value.\n     * @return _srcEid The source endpoint ID.\n     * @return _amountLD The amount in local decimals.\n     * @return _composeFrom The composeFrom value (msg.sender on from chain).\n     * @return _composeMsg The composed message.\n     */\n    function _decodeOFTComposeMsg(bytes calldata _message) internal pure returns (uint64 _nonce, uint32 _srcEid, uint256 _amountLD, bytes32 _composeFrom, bytes memory _composeMsg) {\n        _nonce = OFTComposeMsgCodec.nonce(_message);\n        _srcEid = OFTComposeMsgCodec.srcEid(_message);\n        _amountLD = OFTComposeMsgCodec.amountLD(_message);\n        _composeFrom = OFTComposeMsgCodec.composeFrom(_message);\n        _composeMsg = OFTComposeMsgCodec.composeMsg(_message);\n    }\n\n    /**\n     * @param _guid the GUID of the message from layer zero.\n     * @param _payload the payload of the message.\n     * @param _amount  the amount of ASD tokens to send.\n     */\n    function _sendASD(bytes32 _guid, OftComposeMessage memory _payload, uint _amount) internal {\n        /* transfer the ASD tokens to the destination receiver */\n        if (_payload._dstLzEid == cantoLzEID) {\n            // just transfer the ASD tokens to the destination receiver\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, false);\n            ASDOFT(_payload._cantoAsdAddress).transfer(_payload._dstReceiver, _amount);\n        } else {\n            // use Layer Zero oapp to send ASD tokens to the destination receiver on the destination chain\n\n            // make sure msg.value is enough to cover the fee or this transaction will revert\n            if (msg.value < _payload._feeForSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, \"insufficient msg.value for send fee\");\n                return;\n            }\n\n            // create send params for the Layer Zero oapp\n            bytes memory sendOptions = OptionsBuilder.addExecutorLzReceiveOption(OptionsBuilder.newOptions(), 200000, 0);\n            SendParam memory sendParams = SendParam({dstEid: _payload._dstLzEid, to: OFTComposeMsgCodec.addressToBytes32(_payload._dstReceiver), amountLD: _amount, minAmountLD: _amount, extraOptions: sendOptions, composeMsg: \"0x\", oftCmd: \"0x\"});\n            MessagingFee memory fee = MessagingFee({nativeFee: _payload._feeForSend, lzTokenFee: 0});\n\n            // send tokens\n            (bool successfulSend, bytes memory data) = payable(_payload._cantoAsdAddress).call{value: _payload._feeForSend}(abi.encodeWithSelector(IOFT.send.selector, sendParams, fee, _payload._cantoRefundAddress));\n\n            // check if the send was successful\n            if (!successfulSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, string(data));\n                return;\n            }\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, true);\n        }\n    }\n\n    /**\n     * @notice refunds tokens when lzCompose fails\n     * @param _guid The GUID of the message from layer zero.\n     * @param _tokenAddress address of token\n     * @param _refundAddress address to refund to on canto\n     * @param _amount amount to send\n     * @param _nativeAmount amount to send in native token\n     */\n    function _refundToken(bytes32 _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string memory _reason) internal {\n        // emit event\n        emit TokenRefund(_guid, _tokenAddress, _refundAddress, _amount, _nativeAmount, _reason);\n        // transfer tokens to refund address\n        IERC20(_tokenAddress).transfer(_refundAddress, _amount);\n        // transfer native tokens to refund address and check that this value is less than or equal to msg.value\n        if (_nativeAmount > 0 && _nativeAmount <= msg.value) {\n            payable(_refundAddress).transfer(_nativeAmount);\n        }\n    }\n\n    /**\n     * @notice deposits $NOTE to the correct asd vault to receive ASD tokens\n     * @param _asdVault The address of the ASD vault to deposit to\n     * @param _amountNote The amount of $NOTE to deposit\n     */\n    function _depositNoteToASDVault(address _asdVault, uint _amountNote) internal returns (bool, string memory) {\n        // approve asd vault to spend $NOTE\n        IERC20(noteAddress).approve(_asdVault, _amountNote);\n        // deposit $NOTE to asd vault (use call, so this doesn't revert)\n        (bool success, bytes memory errReason) = _asdVault.call(abi.encodeWithSelector(ASDOFT.mint.selector, _amountNote));\n        return (success, string(errReason));\n    }\n\n    /**\n     * @notice swaps an OFT stable coin for $NOTE\n     * @dev only callable by the owner\n     * @param _oftAddress The address of the OFT stable coin contract\n     * @param _amount The amount of OFT stable coin to swap\n     * @param _minAmountNote The minimum amount of $NOTE to receive\n     * @return amount The amount of $NOTE received or error code\n     */\n    function _swapOFTForNote(address _oftAddress, uint _amount, uint _minAmountNote) internal returns (uint, bool) {\n        // sort tokens\n        address baseToken;\n        address quoteToken;\n        if (_oftAddress < noteAddress) {\n            baseToken = _oftAddress;\n            quoteToken = noteAddress;\n        } else {\n            baseToken = noteAddress;\n            quoteToken = _oftAddress;\n        }\n        // check if pool exists\n        if (ambientPoolFor(baseToken, quoteToken, ambientPoolIdx) == 0) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n\n        // convert amount to uint128\n        uint128 amountConverted = uint128(_amount);\n        // query impact to make sure user will receive at least _minAmountNote\n        bool isNoteBase = baseToken == noteAddress;\n        (int128 baseFlow, int128 quoteFlow, ) = ICrocImpact(crocImpactAddress).calcImpact(baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0);\n\n        // check if amount note received is greater than or equal to _minAmountNote\n\n        int minAmountInt = int(_minAmountNote); // stack too deep fix\n        // flow is negative if it left the pool, so multiply by -1\n        if (isNoteBase && -baseFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        } else if (!isNoteBase && -quoteFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // convert minAmount to uint for stack too deep fix\n        uint128 uintMinAmount = uint128(_minAmountNote);\n\n        // swap is good to make, use call just in case revert occurs\n        (bool successSwap, bytes memory data) = crocSwapAddress.call(abi.encodeWithSelector(ICrocSwapDex.swap.selector, baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0, uintMinAmount, 0));\n        if (!successSwap) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // return amount of note received\n        (int128 baseUsed, int128 quoteUsed) = abi.decode(data, (int128, int128));\n        return (uint128(-1 * (isNoteBase ? baseUsed : quoteUsed)), true);\n    }\n\n    function ambientPoolFor(address _baseToken, address _quoteToken, uint256 _poolIdx) internal view returns (uint256) {\n        bytes32 poolKey = keccak256(abi.encode(_baseToken, _quoteToken, _poolIdx));\n        uint POOL_PARAM_SLOT = 65545;\n        bytes32 slot = keccak256(abi.encode(poolKey, POOL_PARAM_SLOT));\n        return ICrocSwapDex(crocSwapAddress).readSlot(uint256(slot));\n    }\n}"
    },
    {
      "filename": "contracts/asd/asdOFT.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {Turnstile} from \"../clm/Turnstile.sol\";\nimport {CTokenInterface, CErc20Interface} from \"../clm/CTokenInterfaces.sol\";\nimport {IERC20, ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\ncontract ASDOFT is OFT {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n    address public immutable cNote; // Reference to the cNOTE token\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event CarryWithdrawal(uint256 amount);\n\n    /// @notice Initiates CSR on main- and testnet\n    /// @param _name Name of the token\n    /// @param _symbol Symbol of the token\n    /// @param _lzEndpoint Lz endpoint on chain token is deployed on\n    /// @param _cNote Address of the cNOTE token\n    /// @param _csrRecipient Address that should receive CSR rewards\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint, address _cNote, address _csrRecipient) OFT(_name, _symbol, _lzEndpoint, msg.sender) {\n        cNote = _cNote;\n        if (block.chainid == 7700 || block.chainid == 7701) {\n            // Register CSR on Canto main- and testnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(_csrRecipient);\n        }\n    }\n\n    /// @notice Mint amount of asD tokens by providing NOTE. The NOTE:asD exchange rate is always 1:1\n    /// @param _amount Amount of tokens to mint\n    /// @dev User needs to approve the asD contract for _amount of NOTE\n    function mint(uint256 _amount) external {\n        CErc20Interface cNoteToken = CErc20Interface(cNote);\n        IERC20 note = IERC20(cNoteToken.underlying());\n        SafeERC20.safeTransferFrom(note, msg.sender, address(this), _amount);\n        note.approve(cNote, _amount);\n        uint256 returnCode = cNoteToken.mint(_amount);\n        // Mint returns 0 on success: https://docs.compound.finance/v2/ctokens/#mint\n        require(returnCode == 0, \"Error when minting\");\n        _mint(msg.sender, _amount);\n    }\n\n    /// @notice Burn amount of asD tokens to get back NOTE. Like when minting, the NOTE:asD exchange rate is always 1:1\n    /// @param _amount Amount of tokens to burn\n    function burn(uint256 _amount) external {\n        CErc20Interface cNoteToken = CErc20Interface(cNote);\n        IERC20 note = IERC20(cNoteToken.underlying());\n        uint256 returnCode = cNoteToken.redeemUnderlying(_amount); // Request _amount of NOTE (the underlying of cNOTE)\n        require(returnCode == 0, \"Error when redeeming\"); // 0 on success: https://docs.compound.finance/v2/ctokens/#redeem-underlying\n        _burn(msg.sender, _amount);\n        SafeERC20.safeTransfer(note, msg.sender, _amount);\n    }\n\n    /// @notice Withdraw the interest that accrued, only callable by the owner.\n    /// @param _amount Amount of NOTE to withdraw. 0 for withdrawing the maximum possible amount\n    /// @dev The function checks that the owner does not withdraw too much NOTE, i.e. that a 1:1 NOTE:asD exchange rate can be maintained after the withdrawal\n    function withdrawCarry(uint256 _amount) external onlyOwner {\n        // The amount of cNOTE the contract has to hold (based on the current exchange rate which is always increasing) such that it is always possible to receive 1 NOTE when burning 1 asD\n        uint256 maximumWithdrawable = CTokenInterface(cNote).balanceOfUnderlying(address(this)) - totalSupply();\n        if (_amount == 0) {\n            _amount = maximumWithdrawable;\n        } else {\n            require(_amount <= maximumWithdrawable, \"Too many tokens requested\");\n        }\n        // Technically, _amount can still be 0 at this point, which would make the following two calls unnecessary.\n        // But we do not handle this case specifically, as the only consequence is that the owner wastes a bit of gas when there is nothing to withdraw\n        uint256 returnCode = CErc20Interface(cNote).redeemUnderlying(_amount);\n        require(returnCode == 0, \"Error when redeeming\"); // 0 on success: https://docs.compound.finance/v2/ctokens/#redeem\n        IERC20 note = IERC20(CErc20Interface(cNote).underlying());\n        SafeERC20.safeTransfer(note, msg.sender, _amount);\n        emit CarryWithdrawal(_amount);\n    }\n}"
    }
  ]
}