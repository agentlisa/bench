{
  "Title": "BaseBridgeReceiver can be rendered inoperable by incorrectly setting the localTimelock",
  "Content": "The intricate relationship between the `BaseBridgeReceiver` and `TimeLock` contracts requires extra caution when updating the `localTimelock` in the `BaseBridgeReceiver`, as an incorrect update could render the entire contract inoperable. The following errors must be avoided:\n\n\n* Setting the new `localTimelock` value to an address that does not implement the `Timelock` interface (this includes sending the zero address by mistake)\n* Setting the `localTimelock` variable to an address that implements the `Timelock` interface, but with an [`admin`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L11) (or [`pendingAdmin`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L12)) variable that is not set to the address of the `BaseBridgeReceiver` contract\n\n\nIf either of these two events were to happen, the `BaseBridgeReceiver` contract would be unable to successfully send any new messages to the `Timelock` contract and, as a result, would not be able to update its own `localTimelock` variable to address this issue.\n\n\nConsider checking that the new `Timelock` address implements the `ITimelock` interface in the `initialize` and `setLocalTimelock` functions. Also consider checking that the `Timelock` contract’s `admin` (or `pendingAdmin`) variable is set to the `BaseBridgeReceiver` contract’s address in both the `initialize` and `setLocalTimelock` functions before updating the `localTimelock` variable.\n\n\n***Update:** Resolved in [pull request 665](https://github.com/compound-finance/comet/pull/665) at commit [1ffc7e9](https://github.com/compound-finance/comet/pull/665/commits/1ffc7e94bb50f15393ef3ef31d0b27dc3609dec2).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vendor/Timelock.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nimport \"../ITimelock.sol\";\n\ncontract Timelock is ITimelock {\n    uint public immutable GRACE_PERIOD;\n    uint public immutable MINIMUM_DELAY;\n    uint public immutable MAXIMUM_DELAY;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_, uint gracePeriod_, uint minimumDelay_, uint maxiumumDelay_) public {\n        require(delay_ >= minimumDelay_, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= maxiumumDelay_, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        GRACE_PERIOD = gracePeriod_;\n        MINIMUM_DELAY = minimumDelay_;\n        MAXIMUM_DELAY = maxiumumDelay_;\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    fallback() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= (getBlockTimestamp() + delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= (eta + GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        return block.timestamp;\n    }\n}"
    }
  ]
}