{
  "Title": "Accidental calling of `LimitOrderManagement.collectLimitOrder()` with zero recipient may lead to tokens stealing",
  "Content": "##### Description\nIf `LimitOrderManagement.collectLimitOrder()` is called by accident for zero recipient, tokens will be transferred to the contract address:\nhttps://github.com/cryptoalgebra/Algebra/blob/bddd6487c86e0d6afef39638159dc403a91ba433/src/periphery/contracts/LimitOrderManager.sol#LL229C1-L229C1\nAfter that, anyone can claim them.\n##### Recommendation\nWe recommend reverting `LimitOrderManagement.collectLimitOrder()` if `recipient` is `address(0)`.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/periphery/contracts/LimitOrderManager.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\npragma abicoder v2;\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@cryptoalgebra/core/contracts/libraries/TickMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/FullMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\n\nimport './interfaces/ILimitOrderManager.sol';\nimport './libraries/PositionKey.sol';\nimport './libraries/PoolAddress.sol';\nimport './base/LimitOrderManagement.sol';\nimport './base/PeripheryImmutableState.sol';\nimport './base/Multicall.sol';\nimport './base/ERC721Permit.sol';\nimport './base/PeripheryValidation.sol';\nimport './base/SelfPermit.sol';\n\n/// @title NFT limitPositions\n/// @notice Wraps Algebra  limitPositions in the ERC721 non-fungible token interface\ncontract LimitOrderManager is\n    ILimitOrderManager,\n    Multicall,\n    ERC721Permit,\n    PeripheryImmutableState,\n    LimitOrderManagement,\n    PeripheryValidation,\n    SelfPermit\n{\n    struct UpdatePositionCache {\n        uint256 cumulativeDelta;\n        uint128 liquidityLast;\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n    }\n\n    /// @dev IDs of pools assigned by this contract\n    mapping(address => uint80) private _poolIds;\n\n    /// @dev Pool keys by pool ID, to save on SSTOREs for limitPosition data\n    mapping(uint80 => PoolAddress.PoolKey) private _poolIdToPoolKey;\n\n    /// @dev The token ID limitPosition data\n    mapping(uint256 => LimitPosition) private _limitPositions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint176 private _nextId = 1;\n    /// @dev The ID of the next pool that is used for the first time. Skips 0\n    uint80 private _nextPoolId = 1;\n\n    constructor(\n        address _factory,\n        address _WNativeToken,\n        address _poolDeployer\n    )\n        ERC721Permit('Algebra Limit Orders NFT-V1', 'ALGB-LIMIT', '1')\n        PeripheryImmutableState(_factory, _WNativeToken, _poolDeployer)\n    {}\n\n    function limitPositions(\n        uint256 tokenId\n    ) external view override returns (LimitPosition memory limitPosition, address token0, address token1) {\n        limitPosition = _limitPositions[tokenId];\n        require(limitPosition.poolId != 0, 'Invalid token ID');\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[limitPosition.poolId];\n        return (limitPosition, poolKey.token0, poolKey.token1);\n    }\n\n    /// @dev Caches a pool key\n    function cachePoolKey(address pool, PoolAddress.PoolKey memory poolKey) private returns (uint80 poolId) {\n        poolId = _poolIds[pool];\n        if (poolId == 0) {\n            _poolIds[pool] = (poolId = _nextPoolId++);\n            _poolIdToPoolKey[poolId] = poolKey;\n        }\n    }\n\n    function addLimitOrder(addLimitOrderParams calldata params) external payable override returns (uint256 tokenId) {\n        PoolAddress.PoolKey memory poolKey = PoolAddress.PoolKey({token0: params.token0, token1: params.token1});\n        IAlgebraPool pool = IAlgebraPool(PoolAddress.computeAddress(poolDeployer, poolKey));\n        bool depositedToken;\n\n        bytes32 positionKey = PositionKey.compute(address(this), params.tick, params.tick);\n        uint128 liquidityPrev;\n        uint128 liquidityInitPrev;\n\n        unchecked {\n            (uint256 _liquidity, , , , ) = pool.positions(positionKey);\n            liquidityPrev = uint128(_liquidity >> 128);\n            liquidityInitPrev = uint128(_liquidity);\n        }\n\n        (pool, depositedToken) = _createLimitOrder(params.token0, params.token1, params.tick, params.amount);\n        _mint(msg.sender, (tokenId = _nextId++));\n\n        // idempotent set\n        uint80 poolId = cachePoolKey(address(pool), poolKey);\n\n        (uint256 _liquidityAfter, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool\n            .positions(positionKey);\n\n        uint128 liquidity;\n        uint128 liquidityInit;\n        unchecked {\n            liquidity = uint128(_liquidityAfter >> 128);\n            liquidityInit = uint128(_liquidityAfter);\n        }\n\n        require(depositedToken == params.depositedToken, 'depositedToken changed');\n        if (liquidity != liquidityInit && liquidityPrev != 0) {\n            liquidityInit -= liquidityInitPrev;\n        } else {\n            liquidityInit = params.amount;\n        }\n        _limitPositions[tokenId] = LimitPosition({\n            nonce: 0,\n            operator: address(0),\n            poolId: poolId,\n            tick: params.tick,\n            depositedToken: depositedToken,\n            depositedAmount: params.amount,\n            liquidity: params.amount,\n            liquidityInit: liquidityInit,\n            feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128: feeGrowthInside1LastX128,\n            tokensOwed0: 0,\n            tokensOwed1: 0\n        });\n    }\n\n    modifier isAuthorizedForToken(uint256 tokenId) {\n        require(_isApprovedOrOwner(msg.sender, tokenId), 'Not approved');\n        _;\n    }\n\n    function decreaseLimitOrder(\n        uint256 tokenId,\n        uint128 liquidity\n    ) external payable override isAuthorizedForToken(tokenId) {\n        LimitPosition storage position = _limitPositions[tokenId];\n        UpdatePositionCache memory cache;\n\n        uint128 positionLiquidity = position.liquidity;\n        int24 tick = position.tick;\n\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n        IAlgebraPool pool = IAlgebraPool(PoolAddress.computeAddress(poolDeployer, poolKey));\n        // update position state\n        bytes32 positionKey = PositionKey.compute(address(this), tick, tick);\n        uint128 liquidityInitialPrev;\n        uint128 liquidityInitial;\n        uint256 _liquidity;\n        (_liquidity, cache.feeGrowthInside0LastX128, cache.feeGrowthInside1LastX128, , ) = pool.positions(positionKey);\n\n        unchecked {\n            cache.liquidityLast = uint128(_liquidity >> 128);\n            liquidityInitialPrev = uint128(_liquidity);\n        }\n\n        if (cache.liquidityLast > 0) {\n            pool.burn(tick, tick, liquidity);\n            // this is now updated to the current transaction\n            (_liquidity, cache.feeGrowthInside0LastX128, cache.feeGrowthInside1LastX128, , ) = pool.positions(\n                positionKey\n            );\n            unchecked {\n                liquidityInitial = uint128(_liquidity);\n            }\n        }\n        // update lomanager position state\n        if (position.depositedToken) {\n            cache.cumulativeDelta = cache.feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128;\n        } else {\n            cache.cumulativeDelta = cache.feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128;\n        }\n\n        if (cache.cumulativeDelta > 0) {\n            uint256 closedAmount = FullMath.mulDiv(cache.cumulativeDelta, position.liquidityInit, Constants.Q128);\n            uint256 nominator;\n            uint256 denominator;\n            // scope to prevent stack too deep error\n            {\n                uint256 sqrtPrice = TickMath.getSqrtRatioAtTick(tick);\n                uint256 priceX144 = FullMath.mulDiv(sqrtPrice, sqrtPrice, Constants.Q48);\n                (nominator, denominator) = position.depositedToken\n                    ? (Constants.Q144, priceX144)\n                    : (priceX144, Constants.Q144);\n            }\n            uint256 fullAmount = FullMath.mulDiv(positionLiquidity, nominator, denominator);\n            if (closedAmount >= fullAmount) {\n                closedAmount = fullAmount;\n                positionLiquidity = 0;\n            } else {\n                positionLiquidity = uint128(FullMath.mulDiv(fullAmount - closedAmount, denominator, nominator));\n            }\n            if (position.depositedToken) {\n                position.feeGrowthInside0LastX128 = cache.feeGrowthInside0LastX128;\n                if (closedAmount > 0) position.tokensOwed0 += uint128(closedAmount);\n            } else {\n                position.feeGrowthInside1LastX128 = cache.feeGrowthInside1LastX128;\n                if (closedAmount > 0) position.tokensOwed1 += uint128(closedAmount);\n            }\n        }\n\n        if (liquidity > 0) {\n            require(positionLiquidity >= liquidity);\n            positionLiquidity -= liquidity;\n            if (position.depositedToken) {\n                position.tokensOwed1 += liquidity;\n            } else {\n                position.tokensOwed0 += liquidity;\n            }\n        }\n        position.liquidity = positionLiquidity;\n\n        if (positionLiquidity == 0) {\n            position.liquidityInit = 0;\n        } else {\n            position.liquidityInit -= liquidityInitialPrev - liquidityInitial;\n        }\n    }\n\n    function collectLimitOrder(\n        uint256 tokenId,\n        address recipient\n    ) external payable override isAuthorizedForToken(tokenId) returns (uint256 amount0, uint256 amount1) {\n        // allow collecting to the nft position manager address with address 0\n        recipient = recipient == address(0) ? address(this) : recipient;\n\n        LimitPosition storage position = _limitPositions[tokenId];\n        int24 tick = position.tick;\n\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n\n        IAlgebraPool pool = IAlgebraPool(PoolAddress.computeAddress(poolDeployer, poolKey));\n\n        // compute the arguments to give to the pool#collect method\n        (uint128 amount0Collect, uint128 amount1Collect) = (position.tokensOwed0, position.tokensOwed1);\n\n        // the actual amounts collected are returned\n        (amount0, amount1) = pool.collect(recipient, tick, tick, amount0Collect, amount1Collect);\n\n        // sometimes there will be a few less wei than expected due to rounding down in core, but we just subtract the full amount expected\n        // instead of the actual amount so we can burn the token\n        (position.tokensOwed0, position.tokensOwed1) = (\n            position.tokensOwed0 - amount0Collect,\n            position.tokensOwed1 - amount1Collect\n        );\n    }\n\n    // save bytecode by removing implementation of unused method\n    function baseURI() public pure returns (string memory) {}\n\n    function burn(uint256 tokenId) external payable override isAuthorizedForToken(tokenId) {\n        LimitPosition storage position = _limitPositions[tokenId];\n        require(position.liquidity == 0 && position.tokensOwed0 == 0 && position.tokensOwed1 == 0, 'Not cleared');\n        delete _limitPositions[tokenId];\n        _burn(tokenId);\n    }\n\n    function _getAndIncrementNonce(uint256 tokenId) internal override returns (uint256) {\n        return uint256(_limitPositions[tokenId].nonce++);\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenId) public view override(ERC721, IERC721) returns (address) {\n        require(_exists(tokenId), 'ERC721: approved query for nonexistent token');\n\n        return _limitPositions[tokenId].operator;\n    }\n\n    /// @dev Overrides _approve to use the operator in the limitPosition, which is packed with the limitPosition permit nonce\n    function _approve(address to, uint256 tokenId) internal override(ERC721) {\n        _limitPositions[tokenId].operator = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n}"
    }
  ]
}