{
  "Title": "[H-01] Spend limit on owner can be bypassed",
  "Content": "\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/distributor/src/contract.rs#L140><br>\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/community/src/contract.rs#L69><br>\n\nIt seems that the owner is only allowed to spend amount uptil config.spend\\_limit. However it was observed that this `config.spend_limit` is never decreased even if owner has spend an amount. This makes `config.spend_limit` useless as owner can simply send 2-multiple transactions each of `config.spend_limit` which will all pass and hence bypassing the spend limit placed on owner.\n\n### Proof of Concept\n\n1.  Assume spend limit of 100 is placed on owner\n2.  Owner simply calls the spend function at either distributor or community contract with amount 100\n3.  Ideally after this transaction owner should not be allowed to perform any more spend operation\n4.  Since `config.spend_limit` remains unchanged, owner can call step 2 multiple times which will spend amount 100 several times bypassing spend limit\n\n### Recommended Mitigation Steps\n\nAfter successful spend, the `config.spend_limit` should be decreased by the amount spend.\n\n**[Albert Chon (judge) commented via duplicate issue #34](https://github.com/code-423n4/2022-02-anchor-findings/issues/34#issuecomment-1250500683):**\n > Indeed, this is a serious oversight, unless one expects the whitelisted addresses to not exceed the spend limit (which is not a good assumption to bake in). \n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/anchor-token-contracts/contracts/distributor/src/contract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse crate::state::{read_config, store_config, Config};\n\nuse cosmwasm_std::{\n    to_binary, Binary, CanonicalAddr, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response,\n    StdError, StdResult, Uint128, WasmMsg,\n};\n\nuse anchor_token::distributor::{ConfigResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\n\nuse cw20::Cw20ExecuteMsg;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    let whitelist = msg\n        .whitelist\n        .into_iter()\n        .map(|w| deps.api.addr_canonicalize(&w))\n        .collect::<StdResult<Vec<CanonicalAddr>>>()?;\n\n    store_config(\n        deps.storage,\n        &Config {\n            gov_contract: deps.api.addr_canonicalize(&msg.gov_contract)?,\n            anchor_token: deps.api.addr_canonicalize(&msg.anchor_token)?,\n            whitelist,\n            spend_limit: msg.spend_limit,\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::UpdateConfig { spend_limit } => update_config(deps, info, spend_limit),\n        ExecuteMsg::Spend { recipient, amount } => spend(deps, info, recipient, amount),\n        ExecuteMsg::AddDistributor { distributor } => add_distributor(deps, info, distributor),\n        ExecuteMsg::RemoveDistributor { distributor } => {\n            remove_distributor(deps, info, distributor)\n        }\n    }\n}\n\npub fn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    spend_limit: Option<Uint128>,\n) -> StdResult<Response> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.gov_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(spend_limit) = spend_limit {\n        config.spend_limit = spend_limit;\n    }\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![(\"action\", \"update_config\")]))\n}\n\npub fn add_distributor(\n    deps: DepsMut,\n    info: MessageInfo,\n    distributor: String,\n) -> StdResult<Response> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.gov_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let distributor_raw = deps.api.addr_canonicalize(&distributor)?;\n    if config\n        .whitelist\n        .clone()\n        .into_iter()\n        .any(|w| w == distributor_raw)\n    {\n        return Err(StdError::generic_err(\"Distributor already registered\"));\n    }\n\n    config.whitelist.push(distributor_raw);\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"add_distributor\"),\n        (\"distributor\", distributor.as_str()),\n    ]))\n}\n\npub fn remove_distributor(\n    deps: DepsMut,\n    info: MessageInfo,\n    distributor: String,\n) -> StdResult<Response> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.gov_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let distributor_raw = deps.api.addr_canonicalize(&distributor)?;\n    let whitelist_len = config.whitelist.len();\n    let whitelist: Vec<CanonicalAddr> = config\n        .whitelist\n        .into_iter()\n        .filter(|w| *w != distributor_raw)\n        .collect();\n\n    if whitelist_len == whitelist.len() {\n        return Err(StdError::generic_err(\"Distributor not found\"));\n    }\n\n    config.whitelist = whitelist;\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"remove_distributor\"),\n        (\"distributor\", distributor.as_str()),\n    ]))\n}\n\n/// Spend\n/// Owner can execute spend operation to send\n/// `amount` of MIR token to `recipient` for community purpose\npub fn spend(\n    deps: DepsMut,\n    info: MessageInfo,\n    recipient: String,\n    amount: Uint128,\n) -> StdResult<Response> {\n    let config: Config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n\n    if !config.whitelist.into_iter().any(|w| w == sender_raw) {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if config.spend_limit < amount {\n        return Err(StdError::generic_err(\"Cannot spend more than spend_limit\"));\n    }\n\n    let anchor_token = deps.api.addr_humanize(&config.anchor_token)?.to_string();\n    Ok(Response::new()\n        .add_messages(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: anchor_token,\n            funds: vec![],\n            msg: to_binary(&Cw20ExecuteMsg::Transfer {\n                recipient: recipient.clone(),\n                amount,\n            })?,\n        })])\n        .add_attributes(vec![\n            (\"action\", \"spend\"),\n            (\"recipient\", recipient.as_str()),\n            (\"amount\", amount.to_string().as_str()),\n        ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n    }\n}\n\npub fn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let state = read_config(deps.storage)?;\n    let resp = ConfigResponse {\n        gov_contract: deps.api.addr_humanize(&state.gov_contract)?.to_string(),\n        anchor_token: deps.api.addr_humanize(&state.anchor_token)?.to_string(),\n        whitelist: state\n            .whitelist\n            .into_iter()\n            .map(|w| match deps.api.addr_humanize(&w) {\n                Ok(addr) => Ok(addr.to_string()),\n                Err(e) => Err(e),\n            })\n            .collect::<StdResult<Vec<String>>>()?,\n        spend_limit: state.spend_limit,\n    };\n\n    Ok(resp)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -> StdResult<Response> {\n    Ok(Response::default())\n}"
    },
    {
      "filename": "contracts/anchor-token-contracts/contracts/community/src/contract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse crate::state::{read_config, store_config, Config};\n\nuse cosmwasm_std::{\n    to_binary, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,\n    Uint128, WasmMsg,\n};\n\nuse anchor_token::community::{ConfigResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\n\nuse cw20::Cw20ExecuteMsg;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    store_config(\n        deps.storage,\n        &Config {\n            gov_contract: deps.api.addr_canonicalize(&msg.gov_contract)?,\n            anchor_token: deps.api.addr_canonicalize(&msg.anchor_token)?,\n            spend_limit: msg.spend_limit,\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::UpdateConfig { spend_limit } => update_config(deps, info, spend_limit),\n        ExecuteMsg::Spend { recipient, amount } => spend(deps, info, recipient, amount),\n    }\n}\n\npub fn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    spend_limit: Option<Uint128>,\n) -> StdResult<Response> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.gov_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(spend_limit) = spend_limit {\n        config.spend_limit = spend_limit;\n    }\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![(\"action\", \"update_config\")]))\n}\n\n/// Spend\n/// Owner can execute spend operation to send\n/// `amount` of ANC token to `recipient` for community purpose\npub fn spend(\n    deps: DepsMut,\n    info: MessageInfo,\n    recipient: String,\n    amount: Uint128,\n) -> StdResult<Response> {\n    let config: Config = read_config(deps.storage)?;\n    if config.gov_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if config.spend_limit < amount {\n        return Err(StdError::generic_err(\"Cannot spend more than spend_limit\"));\n    }\n\n    let anchor_token = deps.api.addr_humanize(&config.anchor_token)?.to_string();\n    Ok(Response::new()\n        .add_messages(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: anchor_token,\n            funds: vec![],\n            msg: to_binary(&Cw20ExecuteMsg::Transfer {\n                recipient: recipient.clone(),\n                amount,\n            })?,\n        })])\n        .add_attributes(vec![\n            (\"action\", \"spend\"),\n            (\"recipient\", recipient.as_str()),\n            (\"amount\", &amount.to_string()),\n        ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n    }\n}\n\npub fn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let state = read_config(deps.storage)?;\n    let resp = ConfigResponse {\n        gov_contract: deps.api.addr_humanize(&state.gov_contract)?.to_string(),\n        anchor_token: deps.api.addr_humanize(&state.anchor_token)?.to_string(),\n        spend_limit: state.spend_limit,\n    };\n\n    Ok(resp)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -> StdResult<Response> {\n    Ok(Response::default())\n}"
    }
  ]
}