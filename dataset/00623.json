{
  "Title": "[FIXED] Elevated price in USD in the `getLiquidityTokenPrice` function leads to money theft from the pool in `ZunamiStratBase`",
  "Content": "##### Location\nFile | Location | Line\n--- | --- | ---\n[ZunamiStratBase.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/strategies/ZunamiStratBase.sol#L71 \"/contracts/strategies/ZunamiStratBase.sol\") | contract `ZunamiStratBase` > function `deposit` | 71\n\n##### Description\nIn the `deposit` function of the `ZunamiStratBase` contract, the cost of Curve pool LP tokens in USD is determined based on the current price received from the oracle. This value is then used in the `processSuccessfulDeposit` function for minting shares. The issue arises because a higher current price of the LP token results in a larger share of the total LP tokens for a user, while the price change does not impact the shares of previous users.\n\nIn the strategy, within the `deposit` function, liquidity is deposited into the Curve pool, which returns LP tokens. The amount of these LP tokens is set in the `depositedLiquidity` variable. Finally, the USD value of the LP tokens is returned to `zunamiPool`, calculated based on the current price provided by the oracle:\n```solidity\nfunction deposit(uint256[POOL_ASSETS] memory amounts) external returns (uint256) {\n\t// ...\n\tuint256 liquidity = depositLiquidity(amounts);\n\tdepositedLiquidity += liquidity;\n\treturn calcLiquidityValue(liquidity);\n}\n```\n\nIn `zunamiPool`, shares are minted based on the USD value of this LP tokens. However, these new shares are allocated without considering the USD value of previously minted shares in the pool according to the new price:\n\n```solidity\n\t// ...\n\tminted =\n\t\t((totalSupply() + 10 ** _decimalsOffset()) * depositedValue) /\n\t\t(totalDeposited + 1);\n}\n_mint(receiver, minted - locked);\n_strategyInfo[sid].minted += minted;\n\ntotalDeposited += depositedValue;\n```\n\nFor example:\n1) The first user deposits `10000` `zunUSD`, the strategy is receiving `10000` LP tokens from the Curve pool. These LP tokens are recorded in the strategy in the `depositedLiquidity` variable. The cost of these LP tokens in USD, as returned from the oracle, is assumed to be 1 USD per token:\n\n```\n\tgetLiquidityTokenPrice = 1 (USD)\n\tstrategy.depositedLiquidity = 10000 (LP)\n\tzunamiPool.minted = 10000 (shares)\n\tzunamiPool.totalDeposited = 10000 (USD)\n```\n2) A second user deposits `1000` `zunUSD`, the strategy is receiving `1000` LP tokens. If the price per LP token has risen to `1.2` USD, the `deposit` function returns `1200` USD. The shares in `zunamiPool` remain unchanged due to the LP token price change:\n\n```\n\tgetLiquidityTokenPrice = 1.2 (USD)\n\tstrategy.depositedLiquidity = 11000 (LP)\n\tzunamiPool.minted = 11200 (shares)\n\tzunamiPool.totalDeposited = 11200 (USD)\n```\n3) The second user withdraws their `1200` shares. The `calcRatioSafe` function determines the user's claim to be `1200/11200 = 0.107` of `strategy.depositedLiquidity`, equating to `0.107 * 11000 = 1177` LP tokens. Exchanging these tokens in the Curve pool yields `1177` `zunUSD`:\n\n```\n\tstrategy.depositedLiquidity = 9823 (LP)\n\tzunamiPool.minted = 10000 (shares)\n\tzunamiPool.totalDeposited = 10000 (USD)\n```\n\nAs a result, the second user profits `177` `zunUSD` from the `deposit` and `withdraw` functions, causing a loss for the first user.\n\n##### Recommendation\nWe recommend adjusting the allocation of new shares during a deposit in `zunamiPool` to consider the current value of shares in USD.\n\n##### Update\n\n###### Zunami's response\nFixed in commit [`9ffa8e1b6128d1ade8459a4e492cee669ed241a1`](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/9ffa8e1b6128d1ade8459a4e492cee669ed241a1/).\n\n###### Oxorio's response\nMade solution not fully fixes bug scenario in case of `ThroughController` usage:\n1) The first user deposits `10000` `DAI`, the strategy is receiving `10000` LP tokens from the Curve pool. These LP tokens are recorded in the strategy in the `depositedLiquidity` variable. The cost of these LP tokens in USD, as returned from the oracle, is assumed to be 1 USD per token:\n\n```\n\tgetLiquidityTokenPrice = 1 (USD)\n\tstrategy.depositedLiquidity = 10000 (LP)\n\tzunamiPool.minted = 10000 (shares)\n\tzunamiPool.totalDeposited = 10000 (USD)\n```\n2) A second user deposits `1000` `DAI`, the strategy is receiving `1000` LP tokens. If the price per LP token has risen to `1.2` USD, the `deposit` function returns `1200` USD. Also, the new `extraGains` logic of `zunamiPool` mints `2000` new shares to the pool address:\n\n```\n\tgetLiquidityTokenPrice = 1.2 (USD)\n\tstrategy.depositedLiquidity = 11000 (LP)\n\tzunamiPool.minted = 13200 = 10000 + 2000 (new shares for pool) + 1200 (new shares for depositer)\n\tzunamiPool.totalDeposited = 13200 (USD)\n```\n3) Let's assume that the price spike of `DAI` was short-lived and after a while, the price returned to `1` dollar. The first user withdraws their `10000` shares. The `calcRatioSafe` function determines the user's claim to be `10000/13200 = 0.758` of `strategy.depositedLiquidity`, equating to `0.758 * 11000 = 8338` LP tokens. Exchanging these tokens in the Curve pool yields `8338` `DAI`:\n\n```\n\tstrategy.depositedLiquidity = 2662 (LP)\n\tzunamiPool.minted = 3200 (shares)\n\tzunamiPool.totalDeposited = 3200 (USD)\n```\n\nAs a result, the first user loses `1662` `DAI` from the `deposit` and `withdraw` function calls.\n\n\nAlso, the new `extraGains` logic mints shares at a [1 to 1 rate](https://github.com/ZunamiProtocol/ZunamiProtocolV2/blob/9ffa8e1b6128d1ade8459a4e492cee669ed241a1/contracts/ZunamiPool.sol#L140):\n```\n    uint256 gains = currentTotalHoldings - totalDeposited;\n    extraGains += gains;\n    totalDeposited += gains;\n    extraGainsMintedBlock = block.number;\n    _mint(address(this), gains);\n```\nBut as the pool contract implements defense from inflation attack, it mints shares in a shifted rate [during deposit](https://github.com/ZunamiProtocol/ZunamiProtocolV2/blob/9ffa8e1b6128d1ade8459a4e492cee669ed241a1/contracts/ZunamiPool.sol#L236):\n```\n    minted = ((totalSupply() + 10 ** _decimalsOffset()) * depositedValue) / (totalDeposited + 1);\n    ...\n    _mint(receiver, minted);\n```\nWe recommend using the same shifted rate for minting in the `extraGains` logic.\n\n###### Zunami's second response\nFixed in commit [`79892fe12bec407d3d9706c19cd421d458263c0c`](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/79892fe12bec407d3d9706c19cd421d458263c0c/).\n\nIn the current architecture, a protocol has capital stored in strategies. Essentially, investing capital through the pool, the protocol mint own zun stablecoins in return. The capital the protocol held earns the rewards and the yield in the base scenario. Currently, the DAO explicitly withdraws the rewards and converts capital growth into `zun` stablecoins for withdrawal as well. In other words, it's the normal operation mode of the protocol where it constantly gains capital growth. However, in the event of a force majeure and if the protocol has an unsuccessful strategy where the token in which the capital is stored in an external protocol drops in price (for example, Curve LP token), the `DAO` initiate a recapitalization procedure to restore 100% backing selling stacked `zun` stablecoin and collected rewards. In the protocol, the period between losing full backing of own stablecoin with capital and its restoration is a standard procedure that cannot be fixed algorithmically because the problem lies in the external protocol, which has become imbalanced. And yes, users take on the risk that in the event of exiting the zunami pool (omni or APS), they may lose funds if capital is lost in an external project before the recapitalization happens.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ZunamiPool.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Pausable.sol';\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport './interfaces/IStrategy.sol';\nimport './interfaces/IPool.sol';\n\n/**\n *\n * @title Zunami Protocol v2\n *\n */\ncontract ZunamiPool is IPool, ERC20, Pausable, AccessControl {\n    using SafeERC20 for IERC20;\n\n    uint8 public constant POOL_ASSETS = 5;\n\n    bytes32 public constant EMERGENCY_ADMIN_ROLE = keccak256('EMERGENCY_ADMIN_ROLE');\n    bytes32 public constant CONTROLLER_ROLE = keccak256('CONTROLLER_ROLE');\n    uint256 public constant RATIO_MULTIPLIER = 1e18;\n    uint256 public constant MIN_LOCK_TIME = 1 days;\n    uint256 public constant FUNDS_DENOMINATOR = 1e18;\n    uint256 public constant MINIMUM_LIQUIDITY = 1e3;\n    address public constant MINIMUM_LIQUIDITY_LOCKER = 0x000000000000000000000000000000000000dEaD;\n\n    StrategyInfo[] private _strategyInfo;\n\n    IERC20[POOL_ASSETS] private _tokens;\n    uint256[POOL_ASSETS] private _decimalsMultipliers;\n\n    uint256 public totalDeposited;\n    uint256 public extraGains;\n    uint256 public extraGainsMintedBlock;\n    bool public launched;\n\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(EMERGENCY_ADMIN_ROLE, msg.sender);\n    }\n\n    function _checkStrategyExisted(uint256 sid) internal view {\n        if (sid >= _strategyInfo.length) revert AbsentStrategy(sid);\n    }\n\n    function _checkStrategyStarted(uint256 sid) internal view {\n        if (block.timestamp < _strategyInfo[sid].startTime) revert NotStartedStrategy(sid);\n    }\n\n    function _checkStrategyEnabled(uint256 sid) internal view {\n        if (!_strategyInfo[sid].enabled) revert DisabledStrategy(sid);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n\n    function strategyInfo(uint256 sid) external view returns (StrategyInfo memory) {\n        return _strategyInfo[sid];\n    }\n\n    function tokens() external view returns (IERC20[POOL_ASSETS] memory) {\n        return _tokens;\n    }\n\n    function token(uint256 tid) external view returns (IERC20) {\n        return _tokens[tid];\n    }\n\n    function tokenDecimalsMultipliers() external view returns (uint256[POOL_ASSETS] memory) {\n        return _decimalsMultipliers;\n    }\n\n    function _setTokens(\n        address[POOL_ASSETS] memory tokens_,\n        uint256[POOL_ASSETS] memory tokenDecimalsMultipliers_\n    ) internal {\n        bool otherZeros = false;\n        for (uint256 i = 0; i < POOL_ASSETS; i++) {\n            if (otherZeros && address(tokens_[i]) != address(0)) revert WrongTokens();\n            if (address(tokens_[i]) == address(0)) otherZeros = true;\n            if (\n                (address(tokens_[i]) != address(0) && tokenDecimalsMultipliers_[i] == 0) ||\n                (address(tokens_[i]) == address(0) && tokenDecimalsMultipliers_[i] != 0)\n            ) revert WrongDecimalMultipliers();\n            address oldToken = address(_tokens[i]);\n            _tokens[i] = IERC20(tokens_[i]);\n            _decimalsMultipliers[i] = tokenDecimalsMultipliers_[i];\n            emit UpdatedToken(i, tokens_[i], tokenDecimalsMultipliers_[i], oldToken);\n        }\n    }\n\n    function setTokens(\n        address[POOL_ASSETS] memory tokens_,\n        uint256[POOL_ASSETS] memory tokenDecimalMultipliers_\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setTokens(tokens_, tokenDecimalMultipliers_);\n    }\n\n    function pause() external onlyRole(EMERGENCY_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function claimRewards(\n        address receiver,\n        IERC20[] memory rewardTokens\n    ) external onlyRole(CONTROLLER_ROLE) {\n        _mintExtraGains();\n        _claimExtraGains(receiver);\n\n        for (uint256 i = 0; i < _strategyInfo.length; i++) {\n            StrategyInfo memory strategyInfo_ = _strategyInfo[i];\n            if (strategyInfo_.minted > 0 && strategyInfo_.enabled) {\n                strategyInfo_.strategy.claimRewards(receiver, rewardTokens);\n            }\n        }\n        emit ClaimedRewards(receiver, rewardTokens);\n    }\n\n    /// @dev mint extra gains if any and weren't minted in this block\n    function _mintExtraGains() internal {\n        // return if gains were minted in this block\n        if (extraGainsMintedBlock == block.number) return;\n\n        uint256 currentTotalHoldings = totalHoldings();\n        //check if gains are present\n        if (currentTotalHoldings <= totalDeposited) return;\n\n        uint256 gains = currentTotalHoldings - totalDeposited;\n        extraGains += gains;\n        totalDeposited += gains;\n        extraGainsMintedBlock = block.number;\n        _mint(address(this), gains);\n    }\n\n    /// @dev claim extra gains if any\n    function _claimExtraGains(address receiver) internal {\n        if (extraGains == 0) return;\n\n        uint256 _extraGains = extraGains;\n        extraGains = 0;\n        IERC20(address(this)).transfer(receiver, _extraGains);\n        emit ClaimedExtraGains(receiver, _extraGains);\n    }\n\n    function mintAndClaimExtraGains(address receiver) external onlyRole(CONTROLLER_ROLE) {\n        _mintExtraGains();\n        _claimExtraGains(receiver);\n    }\n\n    function totalHoldings() public view returns (uint256) {\n        uint256 length = _strategyInfo.length;\n        uint256 total;\n        for (uint256 sid = 0; sid < length; sid++) {\n            StrategyInfo memory strategyInfo_ = _strategyInfo[sid];\n            if (strategyInfo_.minted > 0 && strategyInfo_.enabled) {\n                total += strategyInfo_.strategy.totalHoldings();\n            }\n        }\n        return total;\n    }\n\n    function strategyCount() external view returns (uint256) {\n        return _strategyInfo.length;\n    }\n\n    function deposit(\n        uint256 sid,\n        uint256[POOL_ASSETS] memory amounts,\n        address receiver\n    ) external whenNotPaused onlyRole(CONTROLLER_ROLE) returns (uint256) {\n        _checkStrategyExisted(sid);\n        _checkStrategyStarted(sid);\n        _checkStrategyEnabled(sid);\n\n        if (receiver == address(0)) {\n            receiver = _msgSender();\n        }\n\n        _mintExtraGains();\n\n        uint256 depositedValue = doDepositStrategy(sid, amounts);\n\n        return processSuccessfulDeposit(receiver, depositedValue, amounts, sid);\n    }\n\n    function depositStrategy(\n        uint256 sid,\n        uint256[POOL_ASSETS] memory amounts\n    ) external whenNotPaused onlyRole(CONTROLLER_ROLE) returns (uint256) {\n        _checkStrategyExisted(sid);\n        _checkStrategyStarted(sid);\n\n        return doDepositStrategy(sid, amounts);\n    }\n\n    function doDepositStrategy(\n        uint256 sid,\n        uint256[POOL_ASSETS] memory amounts\n    ) internal returns (uint256 depositedValue) {\n        IStrategy strategy = _strategyInfo[sid].strategy;\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            if (amounts[i] > 0) {\n                IERC20(_tokens[i]).safeTransfer(address(strategy), amounts[i]);\n            }\n        }\n\n        _mintExtraGains();\n\n        depositedValue = strategy.deposit(amounts);\n\n        if (depositedValue == 0) revert WrongDeposit(sid, amounts);\n    }\n\n    function processSuccessfulDeposit(\n        address receiver,\n        uint256 depositedValue,\n        uint256[POOL_ASSETS] memory depositedTokens,\n        uint256 sid\n    ) internal returns (uint256 minted) {\n        uint256 locked = 0;\n        if (totalSupply() == 0) {\n            if (depositedValue <= MINIMUM_LIQUIDITY) revert WrongAmount();\n            minted = depositedValue;\n            locked = MINIMUM_LIQUIDITY;\n            _mint(MINIMUM_LIQUIDITY_LOCKER, MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            minted =\n                ((totalSupply() + 10 ** _decimalsOffset()) * depositedValue) /\n                (totalDeposited + 1);\n        }\n        _mint(receiver, minted - locked);\n        _strategyInfo[sid].minted += minted;\n\n        totalDeposited += depositedValue;\n\n        emit Deposited(receiver, depositedValue, depositedTokens, minted, sid);\n    }\n\n    function withdraw(\n        uint256 sid,\n        uint256 amount,\n        uint256[POOL_ASSETS] memory tokenAmounts,\n        address receiver\n    ) external whenNotPaused onlyRole(CONTROLLER_ROLE) {\n        _checkStrategyExisted(sid);\n        _checkStrategyStarted(sid);\n        _checkStrategyEnabled(sid);\n\n        IStrategy strategy = _strategyInfo[sid].strategy;\n        address controllerAddr = _msgSender();\n\n        if (balanceOf(controllerAddr) < amount) revert WrongAmount();\n\n        _mintExtraGains();\n\n        if (\n            !strategy.withdraw(\n                receiver == address(0) ? controllerAddr : receiver,\n                calcRatioSafe(amount, _strategyInfo[sid].minted),\n                tokenAmounts\n            )\n        ) revert WrongWithdrawParams(sid);\n\n        uint256 userDeposit = ((totalDeposited + 1) * amount) /\n            (totalSupply() + 10 ** _decimalsOffset());\n\n        processSuccessfulWithdrawal(controllerAddr, userDeposit, amount, sid);\n    }\n\n    function processSuccessfulWithdrawal(\n        address user,\n        uint256 userDeposit,\n        uint256 stableAmount,\n        uint256 sid\n    ) internal {\n        _burn(user, stableAmount);\n        _strategyInfo[sid].minted -= stableAmount;\n        totalDeposited -= userDeposit;\n        emit Withdrawn(user, stableAmount, sid);\n    }\n\n    function calcRatioSafe(\n        uint256 outAmount,\n        uint256 strategyDeposited\n    ) internal pure returns (uint256 ratio) {\n        ratio = (outAmount * RATIO_MULTIPLIER) / strategyDeposited;\n        if (ratio == 0 || ratio > RATIO_MULTIPLIER) revert WrongRatio();\n    }\n\n    /**\n     * @dev add a new strategy, deposits in the new strategy are blocked for one day for safety\n     * @param _strategyAddr - the new strategy strategy address\n     */\n    function addStrategy(address _strategyAddr) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_strategyAddr == address(0)) revert ZeroAddress();\n        for (uint256 i = 0; i < _strategyInfo.length; i++) {\n            if (_strategyAddr == address(_strategyInfo[i].strategy)) revert DuplicatedStrategy();\n        }\n\n        uint256 startTime = block.timestamp + (launched ? MIN_LOCK_TIME : 0);\n        _strategyInfo.push(\n            StrategyInfo({\n                strategy: IStrategy(_strategyAddr),\n                startTime: startTime,\n                minted: 0,\n                enabled: true\n            })\n        );\n        emit AddedStrategy(_strategyInfo.length - 1, _strategyAddr, startTime);\n    }\n\n    function launch() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        launched = true;\n    }\n\n    /**\n     * @dev dev can transfer funds from few strategy's to one strategy for better APY\n     * @param _strategies - array of strategy's, from which funds are withdrawn\n     * @param _withdrawalsPercents - A percentage of the funds that should be transferred\n     * @param _receiverStrategy - number strategy, to which funds are deposited\n     * @param _minAmounts - minimum amount of tokens that should be received from each strategy\n     */\n    function moveFundsBatch(\n        uint256[] memory _strategies,\n        uint256[] memory _withdrawalsPercents,\n        uint256 _receiverStrategy,\n        uint256[POOL_ASSETS][] memory _minAmounts\n    ) external onlyRole(EMERGENCY_ADMIN_ROLE) {\n        if (_strategies.length != _withdrawalsPercents.length) revert IncorrectArguments();\n        if (_receiverStrategy >= _strategyInfo.length) revert WrongReceiver();\n\n        _checkStrategyExisted(_receiverStrategy);\n        _checkStrategyEnabled(_receiverStrategy);\n\n        uint256 sid;\n        uint256 zunamiStables;\n        for (uint256 i = 0; i < _strategies.length; i++) {\n            sid = _strategies[i];\n            zunamiStables += _moveFunds(sid, _withdrawalsPercents[i], _minAmounts[i]);\n        }\n        _strategyInfo[_receiverStrategy].minted += zunamiStables;\n\n        uint256[POOL_ASSETS] memory tokensRemainder;\n        for (uint256 i = 0; i < POOL_ASSETS; i++) {\n            IERC20 token_ = _tokens[i];\n            if (address(token_) == address(0)) break;\n            tokensRemainder[i] = token_.balanceOf(address(this));\n            if (tokensRemainder[i] > 0) {\n                token_.safeTransfer(\n                    address(_strategyInfo[_receiverStrategy].strategy),\n                    tokensRemainder[i]\n                );\n            }\n        }\n\n        if (_strategyInfo[_receiverStrategy].strategy.deposit(tokensRemainder) == 0)\n            revert WrongDeposit(_receiverStrategy, tokensRemainder);\n    }\n\n    function _moveFunds(\n        uint256 sid,\n        uint256 withdrawPercent,\n        uint256[POOL_ASSETS] memory minAmounts\n    ) private returns (uint256 stableAmount) {\n        if (withdrawPercent == 0 || withdrawPercent > FUNDS_DENOMINATOR)\n            revert WrongWithdrawPercent();\n\n        if (withdrawPercent == FUNDS_DENOMINATOR) {\n            stableAmount = _strategyInfo[sid].minted;\n            _strategyInfo[sid].minted = 0;\n            _strategyInfo[sid].strategy.withdrawAll(minAmounts);\n        } else {\n            stableAmount = (_strategyInfo[sid].minted * withdrawPercent) / FUNDS_DENOMINATOR;\n            _strategyInfo[sid].minted -= stableAmount;\n\n            if (!_strategyInfo[sid].strategy.withdraw(address(this), withdrawPercent, minAmounts))\n                revert WrongWithdrawParams(sid);\n        }\n\n        return stableAmount;\n    }\n\n    function enableStrategy(uint256 _sid) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_sid >= _strategyInfo.length) revert IncorrectSid();\n\n        _strategyInfo[_sid].enabled = true;\n\n        emit EnabledStrategy(address(_strategyInfo[_sid].strategy));\n    }\n\n    function disableStrategy(uint256 _sid) external onlyRole(EMERGENCY_ADMIN_ROLE) {\n        if (_sid >= _strategyInfo.length) revert IncorrectSid();\n\n        _strategyInfo[_sid].enabled = false;\n\n        emit DisableStrategy(address(_strategyInfo[_sid].strategy));\n    }\n}"
    },
    {
      "filename": "contracts/ZunamiPool.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Pausable.sol';\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport './interfaces/IStrategy.sol';\nimport './interfaces/IPool.sol';\n\n/**\n *\n * @title Zunami Protocol v2\n *\n */\ncontract ZunamiPool is IPool, ERC20, Pausable, AccessControl {\n    using SafeERC20 for IERC20;\n\n    uint8 public constant POOL_ASSETS = 5;\n\n    bytes32 public constant EMERGENCY_ADMIN_ROLE = keccak256('EMERGENCY_ADMIN_ROLE');\n    bytes32 public constant CONTROLLER_ROLE = keccak256('CONTROLLER_ROLE');\n    uint256 public constant RATIO_MULTIPLIER = 1e18;\n    uint256 public constant MIN_LOCK_TIME = 1 days;\n    uint256 public constant FUNDS_DENOMINATOR = 1e18;\n    uint256 public constant MINIMUM_LIQUIDITY = 1e3;\n    address public constant MINIMUM_LIQUIDITY_LOCKER = 0x000000000000000000000000000000000000dEaD;\n\n    StrategyInfo[] private _strategyInfo;\n\n    IERC20[POOL_ASSETS] private _tokens;\n    uint256[POOL_ASSETS] private _decimalsMultipliers;\n\n    uint256 public totalDeposited;\n    uint256 public extraGains;\n    uint256 public extraGainsMintedBlock;\n    bool public launched;\n\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(EMERGENCY_ADMIN_ROLE, msg.sender);\n    }\n\n    function _checkStrategyExisted(uint256 sid) internal view {\n        if (sid >= _strategyInfo.length) revert AbsentStrategy(sid);\n    }\n\n    function _checkStrategyStarted(uint256 sid) internal view {\n        if (block.timestamp < _strategyInfo[sid].startTime) revert NotStartedStrategy(sid);\n    }\n\n    function _checkStrategyEnabled(uint256 sid) internal view {\n        if (!_strategyInfo[sid].enabled) revert DisabledStrategy(sid);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n\n    function strategyInfo(uint256 sid) external view returns (StrategyInfo memory) {\n        return _strategyInfo[sid];\n    }\n\n    function tokens() external view returns (IERC20[POOL_ASSETS] memory) {\n        return _tokens;\n    }\n\n    function token(uint256 tid) external view returns (IERC20) {\n        return _tokens[tid];\n    }\n\n    function tokenDecimalsMultipliers() external view returns (uint256[POOL_ASSETS] memory) {\n        return _decimalsMultipliers;\n    }\n\n    function _setTokens(\n        address[POOL_ASSETS] memory tokens_,\n        uint256[POOL_ASSETS] memory tokenDecimalsMultipliers_\n    ) internal {\n        bool otherZeros = false;\n        for (uint256 i = 0; i < POOL_ASSETS; i++) {\n            if (otherZeros && address(tokens_[i]) != address(0)) revert WrongTokens();\n            if (address(tokens_[i]) == address(0)) otherZeros = true;\n            if (\n                (address(tokens_[i]) != address(0) && tokenDecimalsMultipliers_[i] == 0) ||\n                (address(tokens_[i]) == address(0) && tokenDecimalsMultipliers_[i] != 0)\n            ) revert WrongDecimalMultipliers();\n            address oldToken = address(_tokens[i]);\n            _tokens[i] = IERC20(tokens_[i]);\n            _decimalsMultipliers[i] = tokenDecimalsMultipliers_[i];\n            emit UpdatedToken(i, tokens_[i], tokenDecimalsMultipliers_[i], oldToken);\n        }\n    }\n\n    function setTokens(\n        address[POOL_ASSETS] memory tokens_,\n        uint256[POOL_ASSETS] memory tokenDecimalMultipliers_\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setTokens(tokens_, tokenDecimalMultipliers_);\n    }\n\n    function pause() external onlyRole(EMERGENCY_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    function claimRewards(\n        address receiver,\n        IERC20[] memory rewardTokens\n    ) external onlyRole(CONTROLLER_ROLE) {\n        _mintExtraGains();\n        _claimExtraGains(receiver);\n\n        for (uint256 i = 0; i < _strategyInfo.length; i++) {\n            StrategyInfo memory strategyInfo_ = _strategyInfo[i];\n            if (strategyInfo_.minted > 0 && strategyInfo_.enabled) {\n                strategyInfo_.strategy.claimRewards(receiver, rewardTokens);\n            }\n        }\n        emit ClaimedRewards(receiver, rewardTokens);\n    }\n\n    /// @dev mint extra gains if any and weren't minted in this block\n    function _mintExtraGains() internal {\n        // return if gains were minted in this block\n        if (extraGainsMintedBlock == block.number) return;\n\n        uint256 currentTotalHoldings = totalHoldings();\n        //check if gains are present\n        if (currentTotalHoldings <= totalDeposited) return;\n\n        uint256 gains = currentTotalHoldings - totalDeposited;\n        extraGains += gains;\n        totalDeposited += gains;\n        extraGainsMintedBlock = block.number;\n        _mint(address(this), gains);\n    }\n\n    /// @dev claim extra gains if any\n    function _claimExtraGains(address receiver) internal {\n        if (extraGains == 0) return;\n\n        uint256 _extraGains = extraGains;\n        extraGains = 0;\n        IERC20(address(this)).transfer(receiver, _extraGains);\n        emit ClaimedExtraGains(receiver, _extraGains);\n    }\n\n    function mintAndClaimExtraGains(address receiver) external onlyRole(CONTROLLER_ROLE) {\n        _mintExtraGains();\n        _claimExtraGains(receiver);\n    }\n\n    function totalHoldings() public view returns (uint256) {\n        uint256 length = _strategyInfo.length;\n        uint256 total;\n        for (uint256 sid = 0; sid < length; sid++) {\n            StrategyInfo memory strategyInfo_ = _strategyInfo[sid];\n            if (strategyInfo_.minted > 0 && strategyInfo_.enabled) {\n                total += strategyInfo_.strategy.totalHoldings();\n            }\n        }\n        return total;\n    }\n\n    function strategyCount() external view returns (uint256) {\n        return _strategyInfo.length;\n    }\n\n    function deposit(\n        uint256 sid,\n        uint256[POOL_ASSETS] memory amounts,\n        address receiver\n    ) external whenNotPaused onlyRole(CONTROLLER_ROLE) returns (uint256) {\n        _checkStrategyExisted(sid);\n        _checkStrategyStarted(sid);\n        _checkStrategyEnabled(sid);\n\n        if (receiver == address(0)) {\n            receiver = _msgSender();\n        }\n\n        _mintExtraGains();\n\n        uint256 depositedValue = doDepositStrategy(sid, amounts);\n\n        return processSuccessfulDeposit(receiver, depositedValue, amounts, sid);\n    }\n\n    function depositStrategy(\n        uint256 sid,\n        uint256[POOL_ASSETS] memory amounts\n    ) external whenNotPaused onlyRole(CONTROLLER_ROLE) returns (uint256) {\n        _checkStrategyExisted(sid);\n        _checkStrategyStarted(sid);\n\n        return doDepositStrategy(sid, amounts);\n    }\n\n    function doDepositStrategy(\n        uint256 sid,\n        uint256[POOL_ASSETS] memory amounts\n    ) internal returns (uint256 depositedValue) {\n        IStrategy strategy = _strategyInfo[sid].strategy;\n\n        for (uint256 i = 0; i < amounts.length; i++) {\n            if (amounts[i] > 0) {\n                IERC20(_tokens[i]).safeTransfer(address(strategy), amounts[i]);\n            }\n        }\n\n        _mintExtraGains();\n\n        depositedValue = strategy.deposit(amounts);\n\n        if (depositedValue == 0) revert WrongDeposit(sid, amounts);\n    }\n\n    function processSuccessfulDeposit(\n        address receiver,\n        uint256 depositedValue,\n        uint256[POOL_ASSETS] memory depositedTokens,\n        uint256 sid\n    ) internal returns (uint256 minted) {\n        uint256 locked = 0;\n        if (totalSupply() == 0) {\n            if (depositedValue <= MINIMUM_LIQUIDITY) revert WrongAmount();\n            minted = depositedValue;\n            locked = MINIMUM_LIQUIDITY;\n            _mint(MINIMUM_LIQUIDITY_LOCKER, MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            minted =\n                ((totalSupply() + 10 ** _decimalsOffset()) * depositedValue) /\n                (totalDeposited + 1);\n        }\n        _mint(receiver, minted - locked);\n        _strategyInfo[sid].minted += minted;\n\n        totalDeposited += depositedValue;\n\n        emit Deposited(receiver, depositedValue, depositedTokens, minted, sid);\n    }\n\n    function withdraw(\n        uint256 sid,\n        uint256 amount,\n        uint256[POOL_ASSETS] memory tokenAmounts,\n        address receiver\n    ) external whenNotPaused onlyRole(CONTROLLER_ROLE) {\n        _checkStrategyExisted(sid);\n        _checkStrategyStarted(sid);\n        _checkStrategyEnabled(sid);\n\n        IStrategy strategy = _strategyInfo[sid].strategy;\n        address controllerAddr = _msgSender();\n\n        if (balanceOf(controllerAddr) < amount) revert WrongAmount();\n\n        _mintExtraGains();\n\n        if (\n            !strategy.withdraw(\n                receiver == address(0) ? controllerAddr : receiver,\n                calcRatioSafe(amount, _strategyInfo[sid].minted),\n                tokenAmounts\n            )\n        ) revert WrongWithdrawParams(sid);\n\n        uint256 userDeposit = ((totalDeposited + 1) * amount) /\n            (totalSupply() + 10 ** _decimalsOffset());\n\n        processSuccessfulWithdrawal(controllerAddr, userDeposit, amount, sid);\n    }\n\n    function processSuccessfulWithdrawal(\n        address user,\n        uint256 userDeposit,\n        uint256 stableAmount,\n        uint256 sid\n    ) internal {\n        _burn(user, stableAmount);\n        _strategyInfo[sid].minted -= stableAmount;\n        totalDeposited -= userDeposit;\n        emit Withdrawn(user, stableAmount, sid);\n    }\n\n    function calcRatioSafe(\n        uint256 outAmount,\n        uint256 strategyDeposited\n    ) internal pure returns (uint256 ratio) {\n        ratio = (outAmount * RATIO_MULTIPLIER) / strategyDeposited;\n        if (ratio == 0 || ratio > RATIO_MULTIPLIER) revert WrongRatio();\n    }\n\n    /**\n     * @dev add a new strategy, deposits in the new strategy are blocked for one day for safety\n     * @param _strategyAddr - the new strategy strategy address\n     */\n    function addStrategy(address _strategyAddr) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_strategyAddr == address(0)) revert ZeroAddress();\n        for (uint256 i = 0; i < _strategyInfo.length; i++) {\n            if (_strategyAddr == address(_strategyInfo[i].strategy)) revert DuplicatedStrategy();\n        }\n\n        uint256 startTime = block.timestamp + (launched ? MIN_LOCK_TIME : 0);\n        _strategyInfo.push(\n            StrategyInfo({\n                strategy: IStrategy(_strategyAddr),\n                startTime: startTime,\n                minted: 0,\n                enabled: true\n            })\n        );\n        emit AddedStrategy(_strategyInfo.length - 1, _strategyAddr, startTime);\n    }\n\n    function launch() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        launched = true;\n    }\n\n    /**\n     * @dev dev can transfer funds from few strategy's to one strategy for better APY\n     * @param _strategies - array of strategy's, from which funds are withdrawn\n     * @param _withdrawalsPercents - A percentage of the funds that should be transferred\n     * @param _receiverStrategy - number strategy, to which funds are deposited\n     * @param _minAmounts - minimum amount of tokens that should be received from each strategy\n     */\n    function moveFundsBatch(\n        uint256[] memory _strategies,\n        uint256[] memory _withdrawalsPercents,\n        uint256 _receiverStrategy,\n        uint256[POOL_ASSETS][] memory _minAmounts\n    ) external onlyRole(EMERGENCY_ADMIN_ROLE) {\n        if (_strategies.length != _withdrawalsPercents.length) revert IncorrectArguments();\n        if (_receiverStrategy >= _strategyInfo.length) revert WrongReceiver();\n\n        _checkStrategyExisted(_receiverStrategy);\n        _checkStrategyEnabled(_receiverStrategy);\n\n        uint256 sid;\n        uint256 zunamiStables;\n        for (uint256 i = 0; i < _strategies.length; i++) {\n            sid = _strategies[i];\n            zunamiStables += _moveFunds(sid, _withdrawalsPercents[i], _minAmounts[i]);\n        }\n        _strategyInfo[_receiverStrategy].minted += zunamiStables;\n\n        uint256[POOL_ASSETS] memory tokensRemainder;\n        for (uint256 i = 0; i < POOL_ASSETS; i++) {\n            IERC20 token_ = _tokens[i];\n            if (address(token_) == address(0)) break;\n            tokensRemainder[i] = token_.balanceOf(address(this));\n            if (tokensRemainder[i] > 0) {\n                token_.safeTransfer(\n                    address(_strategyInfo[_receiverStrategy].strategy),\n                    tokensRemainder[i]\n                );\n            }\n        }\n\n        if (_strategyInfo[_receiverStrategy].strategy.deposit(tokensRemainder) == 0)\n            revert WrongDeposit(_receiverStrategy, tokensRemainder);\n    }\n\n    function _moveFunds(\n        uint256 sid,\n        uint256 withdrawPercent,\n        uint256[POOL_ASSETS] memory minAmounts\n    ) private returns (uint256 stableAmount) {\n        if (withdrawPercent == 0 || withdrawPercent > FUNDS_DENOMINATOR)\n            revert WrongWithdrawPercent();\n\n        if (withdrawPercent == FUNDS_DENOMINATOR) {\n            stableAmount = _strategyInfo[sid].minted;\n            _strategyInfo[sid].minted = 0;\n            _strategyInfo[sid].strategy.withdrawAll(minAmounts);\n        } else {\n            stableAmount = (_strategyInfo[sid].minted * withdrawPercent) / FUNDS_DENOMINATOR;\n            _strategyInfo[sid].minted -= stableAmount;\n\n            if (!_strategyInfo[sid].strategy.withdraw(address(this), withdrawPercent, minAmounts))\n                revert WrongWithdrawParams(sid);\n        }\n\n        return stableAmount;\n    }\n\n    function enableStrategy(uint256 _sid) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_sid >= _strategyInfo.length) revert IncorrectSid();\n\n        _strategyInfo[_sid].enabled = true;\n\n        emit EnabledStrategy(address(_strategyInfo[_sid].strategy));\n    }\n\n    function disableStrategy(uint256 _sid) external onlyRole(EMERGENCY_ADMIN_ROLE) {\n        if (_sid >= _strategyInfo.length) revert IncorrectSid();\n\n        _strategyInfo[_sid].enabled = false;\n\n        emit DisableStrategy(address(_strategyInfo[_sid].strategy));\n    }\n}"
    }
  ]
}