{
  "Title": "[12] If the pending admin becomes malicious there is no specific way to stop them from accepting the admin",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L22-L42\n\n```solidity\n    /// @inheritdoc IAdmin\n    function setPendingAdmin(address _newPendingAdmin) external onlyAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = s.pendingAdmin;\n        // Change pending admin\n        s.pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function acceptAdmin() external {\n        address pendingAdmin = s.pendingAdmin;\n        require(msg.sender == pendingAdmin, \"n4\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = s.admin;\n        s.admin = pendingAdmin;\n        delete s.pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n```\n\nBoth functions are all used in the logic to update the admins.\n\nNow consider this scenario:\n\n- Current admin sets a new pending admin\n- After a few days, current admin found out that pending admin is malicious (or even maybe a wrong address, i.e current admin made a mistake to set a wrong address as pending admin)\n- Current admin now attempts to update the pending admin with a new fresh pending admin\n- Current pending admin sees the transaction and then front runs it by accepting the admin status\n\n### Impact\n\nLow, since this overall depends on the current admin setting an address that could become malicious as the pending admin (or a wrong address)\n\n### Recommended Mitigation Steps\n\nConsider implementing timelocks to the whole logic, i.e if pending admin does not accept their admin status in 1 day, it should be automatically revoked.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IAdmin} from \"../../chain-interfaces/IAdmin.sol\";\nimport {Diamond} from \"../../libraries/Diamond.sol\";\nimport {MAX_GAS_PER_TRANSACTION} from \"../../../common/Config.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../ZkSyncStateTransitionStorage.sol\";\nimport {ZkSyncStateTransitionBase} from \"./ZkSyncStateTransitionBase.sol\";\nimport {IStateTransitionManager} from \"../../IStateTransitionManager.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZkSyncStateTransitionBase} from \"../../chain-interfaces/IZkSyncStateTransitionBase.sol\";\n\n/// @title Admin Contract controls access rights for contract management.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract AdminFacet is ZkSyncStateTransitionBase, IAdmin {\n    /// @inheritdoc IZkSyncStateTransitionBase\n    string public constant override getName = \"AdminFacet\";\n\n    /// @inheritdoc IAdmin\n    function setPendingAdmin(address _newPendingAdmin) external onlyAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = s.pendingAdmin;\n        // Change pending admin\n        s.pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function acceptAdmin() external {\n        address pendingAdmin = s.pendingAdmin;\n        require(msg.sender == pendingAdmin, \"n4\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = s.admin;\n        s.admin = pendingAdmin;\n        delete s.pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function setValidator(address _validator, bool _active) external onlyStateTransitionManager {\n        s.validators[_validator] = _active;\n        emit ValidatorStatusUpdate(_validator, _active);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPorterAvailability(bool _zkPorterIsAvailable) external onlyStateTransitionManager {\n        // Change the porter availability\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        emit IsPorterAvailableStatusUpdate(_zkPorterIsAvailable);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyStateTransitionManager {\n        require(_newPriorityTxMaxGasLimit <= MAX_GAS_PER_TRANSACTION, \"n5\");\n\n        uint256 oldPriorityTxMaxGasLimit = s.priorityTxMaxGasLimit;\n        s.priorityTxMaxGasLimit = _newPriorityTxMaxGasLimit;\n        emit NewPriorityTxMaxGasLimit(oldPriorityTxMaxGasLimit, _newPriorityTxMaxGasLimit);\n    }\n\n    /// @inheritdoc IAdmin\n    function changeFeeParams(FeeParams calldata _newFeeParams) external onlyAdminOrStateTransitionManager {\n        // Double checking that the new fee params are valid, i.e.\n        // the maximal pubdata per batch is not less than the maximal pubdata per priority transaction.\n        require(_newFeeParams.maxPubdataPerBatch >= _newFeeParams.priorityTxMaxPubdata, \"n6\");\n\n        FeeParams memory oldFeeParams = s.feeParams;\n        s.feeParams = _newFeeParams;\n\n        emit NewFeeParams(oldFeeParams, _newFeeParams);\n    }\n\n    /// @inheritdoc IAdmin\n    function setTokenMultiplier(uint128 _nominator, uint128 _denominator) external onlyAdminOrStateTransitionManager {\n        uint128 oldNominator = s.baseTokenGasPriceMultiplierNominator;\n        uint128 oldDenominator = s.baseTokenGasPriceMultiplierDenominator;\n\n        s.baseTokenGasPriceMultiplierNominator = _nominator;\n        s.baseTokenGasPriceMultiplierDenominator = _denominator;\n\n        emit NewBaseTokenMultiplier(oldNominator, oldDenominator, _nominator, _denominator);\n    }\n\n    function setValidiumMode(PubdataPricingMode _validiumMode) external onlyAdmin {\n        require(s.totalBatchesCommitted == 0, \"AdminFacet: set validium only after genesis\"); // Validium mode can be set only before the first batch is committed\n        s.feeParams.pubdataPricingMode = _validiumMode;\n        emit ValidiumModeStatusUpdate(_validiumMode);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UPGRADE EXECUTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// upgrade a specific chain\n    function upgradeChainFromVersion(\n        uint256 _oldProtocolVersion,\n        Diamond.DiamondCutData calldata _diamondCut\n    ) external onlyAdminOrStateTransitionManager {\n        bytes32 cutHashInput = keccak256(abi.encode(_diamondCut));\n        require(\n            cutHashInput == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion),\n            \"StateTransition: cutHash mismatch\"\n        );\n\n        require(\n            s.protocolVersion == _oldProtocolVersion,\n            \"StateTransition: protocolVersion mismatch in STC when upgrading\"\n        );\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n        require(\n            s.protocolVersion > _oldProtocolVersion,\n            \"StateTransition: protocolVersion mismatch in STC after upgrading\"\n        );\n    }\n\n    /// @inheritdoc IAdmin\n    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external onlyStateTransitionManager {\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT FREEZING\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAdmin\n    function freezeDiamond() external onlyAdminOrStateTransitionManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        diamondStorage.isFrozen = true;\n\n        emit Freeze();\n    }\n\n    /// @inheritdoc IAdmin\n    function unfreezeDiamond() external onlyAdminOrStateTransitionManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze();\n    }\n}"
    }
  ]
}