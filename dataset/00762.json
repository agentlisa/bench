{
  "Title": "M-9: Rebalance will be delayed due to revert",
  "Content": "# Issue M-9: Rebalance will be delayed due to revert \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/44 \n\n## Found by \nxiaoming90\n## Summary\n\nThe rebalancing of unhealthy currencies will be delayed due to a revert, resulting in an excess of liquidity being lent out in the external market. This might affect the liquidity of the protocol, potentially resulting in withdrawal or liquidation having issues executed due to insufficient liquidity.\n\n## Vulnerability Detail\n\nAssume that Notional supports 5 currencies ($A, B, C, D, E$), and the Gelato bot is configured to call the `checkRebalance` function every 30 minutes.\n\nAssume that the current market condition is volatile. Thus, the inflow and outflow of assets to Notional, utilization rate, and available liquidity at AAVE change frequently. As a result, the target amount that should be externally lent out also changes frequently since the computation of this value relies on the spot market information.\n\nAt T1, when the Gelato bot calls the `checkRebalance()` view function, it returns that currencies $A$, $B$, and $C$ are unhealthy and need to be rebalanced.\n\nShortly after receiving the execution payload from the `checkRebalance()`, the bot submits the rebalancing TX to the mempool for execution at T2.\n\nWhen the rebalancing TX is executed at T3, one of the currencies (Currency $A$) becomes healthy. As a result, the require check at Line 326 will revert and the entire rebalancing transaction will be cancelled. Thus, currencies $B$ and $C$ that are still unhealthy at this point will not be rebalanced.\n\nIf this issue occurs frequently or repeatedly over a period of time, the rebalancing of unhealthy currencies will be delayed.\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/actions/TreasuryAction.sol#L326\n\n```solidity\nFile: TreasuryAction.sol\n315:     function _rebalanceCurrency(uint16 currencyId, bool useCooldownCheck) private { \n316:         RebalancingContextStorage memory context = LibStorage.getRebalancingContext()[currencyId]; \n317:         // Accrues interest up to the current block before any rebalancing is executed\n318:         IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId); \n319:         PrimeRate memory pr = PrimeRateLib.buildPrimeRateStateful(currencyId); \n320: \n321:         bool hasCooldownPassed = _hasCooldownPassed(context); \n322:         (bool isExternalLendingUnhealthy, OracleData memory oracleData, uint256 targetAmount) = \n323:             _isExternalLendingUnhealthy(currencyId, oracle, pr); \n324: \n325:         // Cooldown check is bypassed when the owner updates the rebalancing targets\n326:         if (useCooldownCheck) require(hasCooldownPassed || isExternalLendingUnhealthy); \n```\n\n## Impact\n\nThe rebalancing of unhealthy currencies will be delayed, resulting in an excess of liquidity being lent out to the external market. This might affect the liquidity of the protocol, potentially resulting in withdrawal or liquidation having issues executed due to insufficient liquidity.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/external/actions/TreasuryAction.sol#L326\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf one of the currencies becomes healthy when the rebalance TX is executed, consider skipping this currency and move on to execute the rebalance on the rest of the currencies that are still unhealthy.\n\n```diff\nfunction _rebalanceCurrency(uint16 currencyId, bool useCooldownCheck) private { \n\tRebalancingContextStorage memory context = LibStorage.getRebalancingContext()[currencyId]; \n\t// Accrues interest up to the current block before any rebalancing is executed\n\tIPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId); \n\tPrimeRate memory pr = PrimeRateLib.buildPrimeRateStateful(currencyId); \n\n\tbool hasCooldownPassed = _hasCooldownPassed(context); \n\t(bool isExternalLendingUnhealthy, OracleData memory oracleData, uint256 targetAmount) = \n\t\t_isExternalLendingUnhealthy(currencyId, oracle, pr); \n\n\t// Cooldown check is bypassed when the owner updates the rebalancing targets\n-\tif (useCooldownCheck) require(hasCooldownPassed || isExternalLendingUnhealthy);\n+\tif (useCooldownCheck && !hasCooldownPassed && !isExternalLendingUnhealthy) return;\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { valid medium findings due to the occurrence}\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "contracts-v3/contracts/external/actions/TreasuryAction.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    PrimeRate,\n    PrimeCashFactorsStorage,\n    PrimeCashFactors,\n    RebalancingTargetData,\n    RebalancingContextStorage\n} from \"../../global/Types.sol\";\nimport {StorageLayoutV2} from \"../../global/StorageLayoutV2.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {Emitter} from \"../../internal/Emitter.sol\";\nimport {BalanceHandler} from \"../../internal/balances/BalanceHandler.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {TokenHandler} from \"../../internal/balances/TokenHandler.sol\";\nimport {ExternalLending} from \"../../internal/balances/ExternalLending.sol\";\nimport {nTokenHandler} from \"../../internal/nToken/nTokenHandler.sol\";\nimport {nTokenSupply} from \"../../internal/nToken/nTokenSupply.sol\";\nimport {PrimeCashExchangeRate} from \"../../internal/pCash/PrimeCashExchangeRate.sol\";\nimport {GenericToken} from \"../../internal/balances/protocols/GenericToken.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {NotionalTreasury} from \"../../../interfaces/notional/NotionalTreasury.sol\";\nimport {IRewarder} from \"../../../interfaces/notional/IRewarder.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {IPrimeCashHoldingsOracle, DepositData, RedeemData, OracleData}\n    from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\n\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using PrimeRateLib for PrimeRate;\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    struct RebalancingData {\n        RedeemData[] redeemData;\n        DepositData[] depositData;\n    }\n\n    /// @dev Harvest methods are only callable by the authorized treasury manager contract\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Treasury manager required\");\n        _;\n    }\n\n    /*****************************************\n     * Governance Methods                    *\n     *****************************************/\n\n    /// @notice Sets the new treasury manager contract\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n\n    /// @notice Set the rebalancing bot to call the rebalance method.\n    function setRebalancingBot(address _rebalancingBot) external override onlyOwner {\n        rebalancingBot = _rebalancingBot;\n    }\n\n    /// @notice Sets the reserve buffer. This is the amount of reserve balance to keep denominated in 1e8\n    /// The reserve cannot be harvested if it's below this amount. This portion of the reserve will remain on\n    /// the contract to act as a buffer against potential insolvency.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param bufferAmount reserve buffer amount to keep in internal token precision (1e8)\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n\n    /// @notice Updates the emission rate of incentives for a given currency\n    /// @dev emit:UpdateIncentiveEmissionRate\n    /// @param currencyId the currency id that the nToken references\n    /// @param newEmissionRate Target total incentives to emit for an nToken over an entire year\n    /// denominated in WHOLE TOKENS (i.e. setting this to 1 means 1e8 tokens). The rate will not be\n    /// exact due to multiplier effects and fluctuating token supply.\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(nTokenAddress != address(0));\n        // Sanity check that emissions rate is not specified in 1e8 terms.\n        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, \"Invalid rate\");\n\n        nTokenSupply.setIncentiveEmissionRate(nTokenAddress, newEmissionRate, block.timestamp);\n        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);\n    }\n\n    /// @notice This is used in the case of insolvency. It allows the owner to re-align the reserve with its correct balance.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param newBalance new reserve balance to set, must be less than the current balance\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        // newBalance cannot be negative and is checked inside BalanceHandler.setReserveCashBalance\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n\n    /// @notice Sets the rebalancing parameters that define how often a token is rebalanced. Rebalancing targets a\n    /// specific Prime Cash utilization while ensuring that we have the ability to withdraw from an external money\n    /// market if we need to.\n    function setRebalancingTargets(\n        uint16 currencyId,\n        RebalancingTargetConfig[] calldata targets\n    ) external override onlyOwner {\n        address holding =\n            PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId).holdings()[0];\n\n        // Currently, the functionality only supports lending on a single external money market. If we want to expand beyond\n        // that then how we calculate the rebalancing amounts will have to change.\n        require(targets.length == 1);\n\n        mapping(address => RebalancingTargetData) storage rebalancingTargets = LibStorage.getRebalancingTargets()[currencyId];\n\n        RebalancingTargetConfig memory config = targets[0];\n\n        require(config.holding == holding);\n        require(config.targetUtilization < 100);\n        require(100 <= config.externalWithdrawThreshold);\n\n        rebalancingTargets[holding] = RebalancingTargetData(config.targetUtilization, config.externalWithdrawThreshold);\n\n        emit RebalancingTargetsUpdated(currencyId, targets);\n\n        // Rebalance the currency immediately after we set targets. This allows the owner to immediately exit money\n        // markets by setting all the targets to zero. The cooldown check is skipped in this case.\n        _rebalanceCurrency({currencyId: currencyId, useCooldownCheck: false});\n    }\n\n    /// @notice Sets the time between calls to the rebalance method by the rebalancing bot.\n    function setRebalancingCooldown(uint16 currencyId, uint40 cooldownTimeInSeconds) external override onlyOwner {\n        mapping(uint16 => RebalancingContextStorage) storage store = LibStorage.getRebalancingContext();\n        store[currencyId].rebalancingCooldownInSeconds = cooldownTimeInSeconds;\n        emit RebalancingCooldownUpdated(currencyId, cooldownTimeInSeconds);\n    }\n\n    /*****************************************\n     * Treasury Manager Methods              *\n     *****************************************/\n\n    /// @notice Transfers some amount of reserve assets to the treasury manager contract. Reserve assets are\n    /// the result of collecting fCash trading fees and vault fees and denominated in Prime Cash. Redeems prime cash\n    /// to underlying as it is transferred off the protocol.\n    /// @param currencies an array of currencies to transfer from Notional\n    function transferReserveToTreasury(uint16[] calldata currencies) external override onlyManagerContract \n        nonReentrant returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; ++i) {\n            // Prevents duplicate currency IDs\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n\n            // Reserve buffer amount in INTERNAL_TOKEN_PRECISION\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n\n            // Reserve requirement not defined\n            if (bufferInternal == 0) continue;\n\n            int256 reserveInternal = BalanceHandler.getPositiveCashBalance(Constants.FEE_RESERVE, currencyId);\n\n            // Do not withdraw anything if reserve is below or equal to reserve requirement\n            if (reserveInternal <= bufferInternal) continue;\n\n            // Actual reserve amount allowed to be redeemed and transferred\n            // NOTE: overflow not possible with the check above\n            int256 primeCashRedeemed = reserveInternal - bufferInternal;\n\n            // Redeems prime cash and transfer underlying to treasury manager contract\n            amountsTransferred[i] = _redeemAndTransfer(currencyId, primeCashRedeemed);\n\n            // Updates the reserve balance\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                primeCashRedeemed\n            );\n        }\n\n        // NOTE: TreasuryManager contract will emit an AssetsHarvested event\n        return amountsTransferred;\n    }\n\n    /// @notice Harvests interest income from rebalancing. Interest income is different from reserve assets because they\n    /// are not accounted for with in stored token balances and therefore are not accessible by Prime Cash holders. Any\n    /// interest will be transferred to the treasury manager.\n    function harvestAssetInterest(uint16[] calldata currencies) external override onlyManagerContract nonReentrant {\n        for (uint256 i; i < currencies.length; ++i) {\n            // Prevents duplicate currency IDs\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n            _skimInterest(currencyId, PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId));\n        }\n    }\n\n    /// @notice Redeems and transfers tokens to the treasury manager contract. This method is distinct from _skimInterest\n    /// because it redeems prime cash held by the protocol, _skimInterest transfers external lending tokens held by the\n    /// protocol.\n    function _redeemAndTransfer(uint16 currencyId, int256 primeCashRedeemAmount) private returns (uint256) {\n        PrimeRate memory primeRate = PrimeRateLib.buildPrimeRateStateful(currencyId);\n        Emitter.emitTransferPrimeCash(Constants.FEE_RESERVE, treasuryManagerContract, currencyId, primeCashRedeemAmount);\n\n        int256 actualTransferExternal = TokenHandler.withdrawPrimeCash(\n            treasuryManagerContract,\n            treasuryManagerContract,\n            currencyId,\n            primeCashRedeemAmount.neg(),\n            primeRate,\n            true // if ETH, transfers it as WETH\n        ).neg();\n\n        require(actualTransferExternal > 0);\n        return uint256(actualTransferExternal);\n    }\n\n    /// @notice Transfers any excess balance above the stored token balance to the treasury manager. This\n    /// balance is not accessible by Prime Cash holders and represents interest earned by the protocol\n    // from lending on external money markets.\n    function _skimInterest(uint16 currencyId, IPrimeCashHoldingsOracle oracle) private {\n        address[] memory assetTokens = oracle.holdings();\n\n        for (uint256 i; i < assetTokens.length; ++i) {\n            address asset = assetTokens[i];\n\n            mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n            uint256 storedBalance = store[asset];\n            uint256 currentBalance = IERC20(asset).balanceOf(address(this));\n\n            if (currentBalance > storedBalance) {\n                uint256 skimAmount = currentBalance - storedBalance;\n                GenericToken.safeTransferOut(asset, treasuryManagerContract, skimAmount);\n                emit AssetInterestHarvested(currencyId, asset, skimAmount);\n            }\n        }\n    }\n\n    /*****************************************\n     * Rebalancing Bot Methods               *\n     *****************************************/\n\n    /// @notice View method used by Gelato to check if rebalancing can be executed and get the execution payload.\n    function checkRebalance() external view override returns (bool canExec, bytes memory execPayload) {\n        mapping(uint16 => RebalancingContextStorage) storage contexts = LibStorage.getRebalancingContext();\n        uint16[] memory currencyIds = new uint16[](maxCurrencyId);\n\n        // Counter is used to calculate the payload at the end of the method\n        uint16 counter = 0;\n\n        // Currency ids are 1-indexed\n        for (uint16 currencyId = 1; currencyId <= maxCurrencyId; currencyId++) {\n            IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n            address[] memory holdings = oracle.holdings();\n            if (holdings.length == 0) continue;\n\n            RebalancingContextStorage storage context = contexts[currencyId];\n            bool cooldownPassed = _hasCooldownPassed(context);\n            (PrimeRate memory pr, /* */) = PrimeCashExchangeRate.getPrimeCashRateView(currencyId, block.timestamp);\n            (bool isExternalLendingUnhealthy, /* */, /* */) = _isExternalLendingUnhealthy(currencyId, oracle, pr);\n\n            // If external lending is unhealthy, the bot and rebalance the currency immediately and\n            // bypass the cooldown.\n            if (cooldownPassed || isExternalLendingUnhealthy) {\n                currencyIds[counter] = currencyId;\n                counter++;\n            }\n        }\n\n        if (counter != 0) {\n            uint16[] memory slicedCurrencyIds = new uint16[](counter);\n            for (uint16 i = 0; i < counter; i++) slicedCurrencyIds[i] = currencyIds[i];\n            canExec = true;\n            execPayload = abi.encodeWithSelector(NotionalTreasury.rebalance.selector, slicedCurrencyIds);\n        }\n    }\n\n    /// @notice Rebalances the given currency ids. Can only be called by the rebalancing bot. Under normal operating\n    /// conditions this can only be called once the cool down period has passed between rebalances, however, if the\n    /// external lending is unhealthy we can bypass that cool down period. The logic for when rebalance is called is\n    /// defined above in `checkRebalance`.\n    /// @param currencyIds sorted array of unique currency id\n    function rebalance(uint16[] calldata currencyIds) external override nonReentrant {\n        require(msg.sender == rebalancingBot, \"Unauthorized\");\n\n        for (uint256 i; i < currencyIds.length; ++i) {\n            // ensure currency ids are unique and sorted\n            if (i != 0) require(currencyIds[i - 1] < currencyIds[i]);\n\n            // Rebalance each of the currencies provided. The gelato bot cannot skip the cooldown check.\n            _rebalanceCurrency({currencyId: currencyIds[i], useCooldownCheck: true});\n        }\n    }\n\n    /// @notice Returns when sufficient time has passed since the last rebalancing cool down.\n    function _hasCooldownPassed(RebalancingContextStorage memory context) private view returns (bool) {\n        return uint256(context.lastRebalanceTimestampInSeconds)\n            .add(context.rebalancingCooldownInSeconds) < block.timestamp;\n    }\n\n    /// @notice Executes the rebalancing of a single currency and updates the oracle supply rate.\n    function _rebalanceCurrency(uint16 currencyId, bool useCooldownCheck) private {\n        RebalancingContextStorage memory context = LibStorage.getRebalancingContext()[currencyId];\n        // Accrues interest up to the current block before any rebalancing is executed\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        PrimeRate memory pr = PrimeRateLib.buildPrimeRateStateful(currencyId);\n\n        bool hasCooldownPassed = _hasCooldownPassed(context);\n        (bool isExternalLendingUnhealthy, OracleData memory oracleData, uint256 targetAmount) = \n            _isExternalLendingUnhealthy(currencyId, oracle, pr);\n\n        // Cooldown check is bypassed when the owner updates the rebalancing targets\n        if (useCooldownCheck) require(hasCooldownPassed || isExternalLendingUnhealthy);\n\n        // Updates the oracle supply rate as well as the last cooldown timestamp. Only update the oracle supply rate\n        // if the cooldown has passed. If not, the oracle supply rate won't change.\n        uint256 oracleSupplyRate = pr.oracleSupplyRate;\n        if (hasCooldownPassed) {\n            oracleSupplyRate = _updateOracleSupplyRate(\n                currencyId, pr, context.previousSupplyFactorAtRebalance, context.lastRebalanceTimestampInSeconds\n            );\n        }\n\n        // External effects happen after the internal state has updated\n        _executeRebalance(currencyId, oracle, pr, oracleData, targetAmount);\n\n        emit CurrencyRebalanced(currencyId, pr.supplyFactor.toUint(), oracleSupplyRate);\n    }\n\n    /// @notice Updates the oracle supply rate for Prime Cash. This oracle supply rate is used to value fCash that exists\n    /// below the 3 month fCash tenor. This is not a common situation but it is important to use a TWAP oracle here to\n    /// ensure that this fCash is not subject to market manipulation.\n    function _updateOracleSupplyRate(\n        uint16 currencyId,\n        PrimeRate memory pr,\n        uint256 previousSupplyFactorAtRebalance,\n        uint256 lastRebalanceTimestampInSeconds\n    ) private returns (uint256 oracleSupplyRate) {\n        // If previous supply factor at rebalance == 0, then it is the first rebalance and the\n        // oracle supply rate will be left as zero. The previous supply factor will\n        // be set to the new factors.supplyFactor in the code below.\n        if (previousSupplyFactorAtRebalance != 0) {\n            // The interest rate is the rate of increase of the supply factor scaled up to a\n            // year time period. Therefore the calculation is:\n            //  ((supplyFactor / prevSupplyFactorAtRebalance) - 1) * (year / timeSinceLastRebalance)\n            uint256 interestRate = pr.supplyFactor.toUint()\n                .mul(Constants.SCALAR_PRECISION)\n                .div(previousSupplyFactorAtRebalance)\n                .sub(Constants.SCALAR_PRECISION) \n                .div(uint256(Constants.RATE_PRECISION));\n\n\n            oracleSupplyRate = interestRate\n                .mul(Constants.YEAR)\n                .div(block.timestamp.sub(lastRebalanceTimestampInSeconds));\n        }\n\n        mapping(uint256 => PrimeCashFactorsStorage) storage p = LibStorage.getPrimeCashFactors();\n        p[currencyId].oracleSupplyRate = oracleSupplyRate.toUint32();\n\n        mapping(uint16 => RebalancingContextStorage) storage c = LibStorage.getRebalancingContext();\n        c[currencyId].lastRebalanceTimestampInSeconds = block.timestamp.toUint40();\n        c[currencyId].previousSupplyFactorAtRebalance = pr.supplyFactor.toUint().toUint128();\n    }\n\n    /// @notice Calculates and executes the rebalancing of a single currency.\n    function _executeRebalance(\n        uint16 currencyId,\n        IPrimeCashHoldingsOracle oracle,\n        PrimeRate memory pr,\n        OracleData memory oracleData,\n        uint256 targetAmount\n    ) private {\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\n        RebalancingData memory data = _calculateRebalance(oracle, oracleData, targetAmount);\n        PrimeCashFactors memory factors = PrimeCashExchangeRate.getPrimeCashFactors(currencyId);\n\n        uint256 totalUnderlyingValueBefore =\n            uint256(underlyingToken.convertToExternal(int256(factors.lastTotalUnderlyingValue)));\n\n        // Both of these methods will short circuit if redeemData or depositData has a length of zero\n        ExternalLending.executeMoneyMarketRedemptions(underlyingToken, data.redeemData);\n        ExternalLending.executeDeposits(underlyingToken, data.depositData);\n\n        // Ensure that total value in underlying terms is not lost as a result of rebalancing.\n        (uint256 totalUnderlyingValueAfter, /* */) = oracle.getTotalUnderlyingValueStateful();\n        require(totalUnderlyingValueBefore <= totalUnderlyingValueAfter);\n    }\n\n    /// @notice Determines if external lending is unhealthy. If this is the case, then we will need to immediately\n    /// execute a rebalance.\n    function _isExternalLendingUnhealthy(\n        uint16 currencyId,\n        IPrimeCashHoldingsOracle oracle,\n        PrimeRate memory pr\n    ) internal view returns (bool isExternalLendingUnhealthy, OracleData memory oracleData, uint256 targetAmount) {\n        oracleData = oracle.getOracleData();\n\n        RebalancingTargetData memory rebalancingTargetData =\n            LibStorage.getRebalancingTargets()[currencyId][oracleData.holding];\n        PrimeCashFactors memory factors = PrimeCashExchangeRate.getPrimeCashFactors(currencyId);\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\n\n        targetAmount = ExternalLending.getTargetExternalLendingAmount(\n            underlyingToken, factors, rebalancingTargetData, oracleData, pr\n        );\n\n        if (oracleData.currentExternalUnderlyingLend == 0) {\n            // If this is zero then there is no outstanding lending.\n            isExternalLendingUnhealthy = false;\n        } else {\n            uint256 offTargetPercentage = oracleData.currentExternalUnderlyingLend.toInt()\n                .sub(targetAmount.toInt()).abs()\n                .toUint()\n                .mul(uint256(Constants.PERCENTAGE_DECIMALS))\n                .div(targetAmount.add(oracleData.currentExternalUnderlyingLend));\n\n            // prevent rebalance if change is not greater than 1%, important for health check and avoiding triggering\n            // rebalance shortly after rebalance on minimum change\n            isExternalLendingUnhealthy = \n                (targetAmount < oracleData.currentExternalUnderlyingLend) && (offTargetPercentage > 0);\n        }\n    }\n\n    function _calculateRebalance(\n        IPrimeCashHoldingsOracle oracle,\n        OracleData memory oracleData,\n        uint256 targetAmount\n    ) private view returns (RebalancingData memory rebalancingData) {\n        address holding = oracleData.holding;\n        uint256 currentAmount = oracleData.currentExternalUnderlyingLend;\n\n        if (targetAmount < currentAmount) {\n            // If above the target amount then redeem\n            address[] memory redeemHoldings = new address[](1);\n            uint256[] memory redeemAmounts = new uint256[](1);\n\n            redeemHoldings[0] = holding;\n            redeemAmounts[0] = currentAmount - targetAmount;\n            rebalancingData.redeemData = oracle.getRedemptionCalldataForRebalancing(redeemHoldings, redeemAmounts);\n        } else if (currentAmount < targetAmount) {\n            // If below the target amount then deposit\n            address[] memory depositHoldings = new address[](1);\n            uint256[] memory depositAmounts = new uint256[](1);\n\n            depositHoldings[0] = holding;\n            depositAmounts[0] = targetAmount - currentAmount;\n            rebalancingData.depositData = oracle.getDepositCalldataForRebalancing(depositHoldings, depositAmounts);\n        }\n    }\n\n    function _saveOracleSupplyRate(uint16 currencyId, uint256 annualizedInterestRate) private {\n        mapping(uint256 => PrimeCashFactorsStorage) storage store = LibStorage.getPrimeCashFactors();\n        store[currencyId].oracleSupplyRate = annualizedInterestRate.toUint32();\n    }\n\n    function _saveRebalancingContext(uint16 currencyId, uint128 supplyFactor) private {\n        mapping(uint16 => RebalancingContextStorage) storage store = LibStorage.getRebalancingContext();\n        store[currencyId].lastRebalanceTimestampInSeconds = block.timestamp.toUint40();\n        store[currencyId].previousSupplyFactorAtRebalance = supplyFactor;\n    }\n\n    /// @notice Sets a secondary incentive rewarder for a currency. This contract will\n    /// be called whenever an nToken balance changes and allows a secondary contract to\n    /// mint incentives to the account. This will override any previous rewarder, if set.\n    /// Will have no effect if there is no nToken corresponding to the currency id.\n    /// @dev emit:UpdateSecondaryIncentiveRewarder\n    /// @param currencyId currency id of the nToken\n    /// @param rewarder rewarder contract\n    function setSecondaryIncentiveRewarder(uint16 currencyId, IRewarder rewarder) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n\n        address nTokenAddress= nTokenHandler.nTokenAddress(currencyId);\n        if (address(rewarder) != address(0)) {\n            require(currencyId == rewarder.CURRENCY_ID());\n            require(nTokenAddress == rewarder.NTOKEN_ADDRESS());\n            require(!rewarder.detached());\n        }\n\n        IRewarder currentRewarder = nTokenHandler.getSecondaryRewarder(nTokenAddress);\n        require(address(rewarder) != address(currentRewarder));\n        if (address(currentRewarder) != address(0)) {\n            currentRewarder.detach();\n        }\n        nTokenHandler.setSecondaryRewarder(currencyId, rewarder);\n        emit UpdateSecondaryIncentiveRewarder(currencyId, address(rewarder));\n    }\n}"
    },
    {
      "filename": "contracts-v3/contracts/external/actions/TreasuryAction.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    PrimeRate,\n    PrimeCashFactorsStorage,\n    PrimeCashFactors,\n    RebalancingTargetData,\n    RebalancingContextStorage\n} from \"../../global/Types.sol\";\nimport {StorageLayoutV2} from \"../../global/StorageLayoutV2.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {Emitter} from \"../../internal/Emitter.sol\";\nimport {BalanceHandler} from \"../../internal/balances/BalanceHandler.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {TokenHandler} from \"../../internal/balances/TokenHandler.sol\";\nimport {ExternalLending} from \"../../internal/balances/ExternalLending.sol\";\nimport {nTokenHandler} from \"../../internal/nToken/nTokenHandler.sol\";\nimport {nTokenSupply} from \"../../internal/nToken/nTokenSupply.sol\";\nimport {PrimeCashExchangeRate} from \"../../internal/pCash/PrimeCashExchangeRate.sol\";\nimport {GenericToken} from \"../../internal/balances/protocols/GenericToken.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {NotionalTreasury} from \"../../../interfaces/notional/NotionalTreasury.sol\";\nimport {IRewarder} from \"../../../interfaces/notional/IRewarder.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {IPrimeCashHoldingsOracle, DepositData, RedeemData, OracleData}\n    from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\n\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using PrimeRateLib for PrimeRate;\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    struct RebalancingData {\n        RedeemData[] redeemData;\n        DepositData[] depositData;\n    }\n\n    /// @dev Harvest methods are only callable by the authorized treasury manager contract\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Treasury manager required\");\n        _;\n    }\n\n    /*****************************************\n     * Governance Methods                    *\n     *****************************************/\n\n    /// @notice Sets the new treasury manager contract\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n\n    /// @notice Set the rebalancing bot to call the rebalance method.\n    function setRebalancingBot(address _rebalancingBot) external override onlyOwner {\n        rebalancingBot = _rebalancingBot;\n    }\n\n    /// @notice Sets the reserve buffer. This is the amount of reserve balance to keep denominated in 1e8\n    /// The reserve cannot be harvested if it's below this amount. This portion of the reserve will remain on\n    /// the contract to act as a buffer against potential insolvency.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param bufferAmount reserve buffer amount to keep in internal token precision (1e8)\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n\n    /// @notice Updates the emission rate of incentives for a given currency\n    /// @dev emit:UpdateIncentiveEmissionRate\n    /// @param currencyId the currency id that the nToken references\n    /// @param newEmissionRate Target total incentives to emit for an nToken over an entire year\n    /// denominated in WHOLE TOKENS (i.e. setting this to 1 means 1e8 tokens). The rate will not be\n    /// exact due to multiplier effects and fluctuating token supply.\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(nTokenAddress != address(0));\n        // Sanity check that emissions rate is not specified in 1e8 terms.\n        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, \"Invalid rate\");\n\n        nTokenSupply.setIncentiveEmissionRate(nTokenAddress, newEmissionRate, block.timestamp);\n        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);\n    }\n\n    /// @notice This is used in the case of insolvency. It allows the owner to re-align the reserve with its correct balance.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param newBalance new reserve balance to set, must be less than the current balance\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        // newBalance cannot be negative and is checked inside BalanceHandler.setReserveCashBalance\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n\n    /// @notice Sets the rebalancing parameters that define how often a token is rebalanced. Rebalancing targets a\n    /// specific Prime Cash utilization while ensuring that we have the ability to withdraw from an external money\n    /// market if we need to.\n    function setRebalancingTargets(\n        uint16 currencyId,\n        RebalancingTargetConfig[] calldata targets\n    ) external override onlyOwner {\n        address holding =\n            PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId).holdings()[0];\n\n        // Currently, the functionality only supports lending on a single external money market. If we want to expand beyond\n        // that then how we calculate the rebalancing amounts will have to change.\n        require(targets.length == 1);\n\n        mapping(address => RebalancingTargetData) storage rebalancingTargets = LibStorage.getRebalancingTargets()[currencyId];\n\n        RebalancingTargetConfig memory config = targets[0];\n\n        require(config.holding == holding);\n        require(config.targetUtilization < 100);\n        require(100 <= config.externalWithdrawThreshold);\n\n        rebalancingTargets[holding] = RebalancingTargetData(config.targetUtilization, config.externalWithdrawThreshold);\n\n        emit RebalancingTargetsUpdated(currencyId, targets);\n\n        // Rebalance the currency immediately after we set targets. This allows the owner to immediately exit money\n        // markets by setting all the targets to zero. The cooldown check is skipped in this case.\n        _rebalanceCurrency({currencyId: currencyId, useCooldownCheck: false});\n    }\n\n    /// @notice Sets the time between calls to the reba"
    }
  ]
}