{
  "Title": "[M-03] Manipulation of total share amount might cause future depositors to lose their assets",
  "Content": "\nIn the `Equity` contract, the `calculateSharesInternal()` function is used to determine the amount of shares minted whenever a user deposits Frankencoin:\n\n[Equity.sol#L266-L270](https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Equity.sol#L266-L270)\n\n```solidity\nfunction calculateSharesInternal(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n    uint256 totalShares = totalSupply();\n    uint256 newTotalShares = totalShares < 1000 * ONE_DEC18 ? 1000 * ONE_DEC18 : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n    return newTotalShares - totalShares;\n}\n```\n\nNote that the return value is the amount of shares minted to the depositor.\n\nWhenever the total amount of shares is less than `1000e18`, the depositor will receive `1000e18 - totalShares` shares, regardless of how much Frankencoin he has deposited. This functionality exists to mint `1000e18` shares to the first depositor.\n\nHowever, this is a vulnerability as the total amount of shares can decrease below `1000e18` due to the `redeem()` function, which burns shares:\n\n[Equity.sol#L275-L278](https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Equity.sol#L275-L278)\n\n```solidity\nfunction redeem(address target, uint256 shares) public returns (uint256) {\n    require(canRedeem(msg.sender));\n    uint256 proceeds = calculateProceeds(shares);\n    _burn(msg.sender, shares);\n```\n\nThe following check in `calculateProceeds()` only ensures that `totalSupply()` is never below `1e18`:\n\n[Equity.sol#L293](https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Equity.sol#L293)\n\n```solidity\nrequire(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n```\n\nAs such, if the total amount of shares decreases below `1000e18`, the next depositor will receive `1000e18 - totalShares` shares instead of an amount of shares proportional to the amount of Frankencoin deposited. This could result in a loss or unfair gain of Frankencoin for the depositor.\n\n### Impact\n\nIf the total amount of shares ever drops below `1000e18`, the next depositor will receive a disproportionate amount of shares, resulting in an unfair gain or loss of Frankencoin.\n\nMoreover, by repeatedly redeeming shares, an attacker can force the total share amount remain below `1000e18`, causing all future depositors to lose most of their deposited Frankencoin.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n*   Alice deposits 1000 Frankencoin (`amount = 1000e18`), gaining `1000e18` shares in return.\n*   After 90 days, Alice is able to redeem her shares.\n*   Alice calls `redeem()` with `shares = 1` to redeem 1 share:\n    *   The total amount of shares is now `1000e18 - 1`.\n*   Bob deposits 1000 Frankencoin (`amount = 1000e18`). In `calculateSharesInternal()`:\n    *   `totalShares < 1000 * ONE_DEC18` evalutes to true.\n    *   Bob receives `newTotalShares - totalShares = 1000e18 - (1000e18 - 1) = 1` shares.\n\nAlthough Bob deposited 1000 Frankencoin, he received only 1 share in return. As such, all his deposited Frankencoin can be redeemed by Alice using her shares. Furthermore, Alice can cause the next depositor after Bob to also receive 1 share by redeeming 1 share, causing the total amount of shares to become `1000e18 - 1` again.\n\nNote that the attack described above is possbile as long as an attacker has sufficient shares to decrease the total share amount below `1000e18`.\n\nThe following Foundry test demonstrates the scenario above:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../contracts/Frankencoin.sol\";\n\ncontract ShareManipulation_POC is Test {\n    Frankencoin zchf;\n    Equity reserve;\n    \n    address ALICE = address(0x1);\n    address BOB = address(0x2);\n\n    function setUp() public {\n        // Setup contracts\n        zchf = new Frankencoin(10 days);\n        reserve = Equity(address(zchf.reserve()));\n\n        // Give both ALICE and BOB 1000 Frankencoin\n        zchf.suggestMinter(address(this), 0, 0, \"\");\n        zchf.mint(ALICE, 1000 ether);\n        zchf.mint(BOB, 1000 ether);\n    }\n\n    function test_NextDepositorGetsOneShare() public {\n        // ALICE deposits 1000 Frankencoin, getting 1000e18 shares\n        vm.prank(ALICE);\n        zchf.transferAndCall(address(reserve), 1000 ether, \"\");\n\n        // Time passes until ALICE can redeem\n        vm.roll(block.number + 90 * 7200);\n\n        // ALICE redeems 1 share, leaving 1000e18 - 1 shares remaining\n        vm.prank(ALICE);\n        reserve.redeem(ALICE, 1);\n        \n        // BOB deposits 1000 Frankencoin, but gets only 1 share\n        vm.prank(BOB);\n        zchf.transferAndCall(address(reserve), 1000 ether, \"\");\n        assertEq(reserve.balanceOf(BOB), 1);\n\n        // All of BOB's deposited Frankencoin accrue to ALICE\n        vm.startPrank(ALICE);\n        reserve.redeem(ALICE, reserve.balanceOf(ALICE) - 1e18);\n        assertGt(zchf.balanceOf(ALICE), 1999 ether);\n    }\n}\n```\n\n### Recommendation\n\nAs the total amount of shares will never be less than `1e18`, check if `totalShares` is less than `1e18` instead of `1000e18` in `calculateSharesInternal()`:\n\n[Equity.sol#L266-L270](https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Equity.sol#L266-L270)\n\n```diff\n     function calculateSharesInternal(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n         uint256 totalShares = totalSupply();\n-         uint256 newTotalShares = totalShares < 1000 * ONE_DEC18 ? 1000 * ONE_DEC18 : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n+         uint256 newTotalShares = totalShares < ONE_DEC18 ? 1000 * ONE_DEC18 : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n         return newTotalShares - totalShares;\n     }\n```\n\nThis would give `1000e18` shares to the initial depositor and ensure that subsequent depositors will never receive a disproportionate amount of shares.\n\n**[0xA5DF (lookout) commented](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/915#issuecomment-1519790248):**\n > Similar to [`#983`](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/983), yet different.\n>\n > [`#880`](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/880) describes a similar issue except that the lowering of shares is due to restructure, duping to this one.\n\n**[luziusmeisser (Frankencoin) acknowledged and commented](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/915#issuecomment-1528895861):**\n > In theory, this is possible. In practice, I assume the number of shares to always be significantly above 1000 and this issue not to be of practical relevance.\n\n**[hansfried (judge) decreased severity to Medium](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/915#issuecomment-1551893812)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-frankencoin",
  "Code": [
    {
      "filename": "contracts/Equity.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./Frankencoin.sol\";\nimport \"./IERC677Receiver.sol\";\nimport \"./ERC20PermitLight.sol\";\nimport \"./MathUtil.sol\";\nimport \"./IReserve.sol\";\n\n/** \n * If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\n * weighted reserve pool shares gains veto power and can veto new proposals.\n */\ncontract Equity is ERC20PermitLight, MathUtil, IReserve {\n\n    /**\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\n     *\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\n     *\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\n     * |          1000 |          3000 |             3 |         1000 |\n     * |       1000000 |       3000000 |           300 |        10000 |\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\n     *\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\n     */\n    uint32 public constant VALUATION_FACTOR = 3;\n\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\n\n    /**\n     * The quorum in basis points. 100 is 1%.\n     */\n    uint32 private constant QUORUM = 300;\n\n    /**\n     * The number of digits to store the average holding time of share tokens.\n     */\n    uint8 private constant BLOCK_TIME_RESOLUTION_BITS = 24;\n\n    /**\n     * The minimum holding duration in blocks. You are not allowed to redeem your pool shares if you held them\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\n     * holding duration of your shares is only 55 days < 90 days.\n     */\n    uint256 public constant MIN_HOLDING_DURATION = 90*7200 << BLOCK_TIME_RESOLUTION_BITS; // Set to 5 for local testing\n\n    Frankencoin immutable public zchf;\n\n    /**\n     * To track the total number of votes we need to know the number of votes at the anchor time and when the\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\n     * the total vote count 192 Bits. Given the sub-block time resolution of 24 Bits, the implicit assumption is\n     * that the block number can always be stored in 40 Bits (i.e. it does not exceed a trillion). Further,\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed \n     *   192 - 60 - 40 - 24 = 68 Bits\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact, when\n     * minting, a limit of about 2**30 shares (that's 2**90 Bits when taking into account the decimals) is imposed\n     * when minting. This means that the maximum supply is about a billion shares, which is reached at a market\n     * cap of 3,000,000,000,000,000,000 CHF. This limit could in theory be reached in times of hyper inflaction. \n     */\n    uint192 private totalVotesAtAnchor;  // Total number of votes at the anchor time, see comment on the um\n    uint64 private totalVotesAnchorTime; // 40 Bit for the block number, 24 Bit sub-block time resolution\n\n    /**\n     * Keeping track on who delegated votes to whom.\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\n     */\n    mapping (address => address) public delegates;\n\n    /**\n     * A block number in the past such that: votes = balance * (time passed since anchor was set)\n     */\n    mapping (address => uint64) private voteAnchor; // 40 Bit for the block number, 24 Bit sub-block time resolution\n\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\n\n    constructor(Frankencoin zchf_) ERC20(18) {\n        zchf = zchf_;\n    }\n\n    function name() override external pure returns (string memory) {\n        return \"Frankencoin Pool Share\";\n    }\n\n    function symbol() override external pure returns (string memory) {\n        return \"FPS\";\n    }\n\n    /**\n     * Returns the price of one FPS in ZCHF with 18 decimals precision.\n     */\n    function price() public view returns (uint256){\n        return VALUATION_FACTOR * zchf.equity() * ONE_DEC18 / totalSupply();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal {\n        super._beforeTokenTransfer(from, to, amount);\n        if (amount > 0){\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\n            // their votes so everything falls nicely into place.\n            // Recipient votes should stay the same, but grow faster in the future, requiring an adjustment of the anchor.\n            uint256 roundingLoss = adjustRecipientVoteAnchor(to, amount);\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\n            adjustTotalVotes(from, amount, roundingLoss);\n        }\n    }\n\n    /**\n     * Returns whether the sender address is allowed to redeem FPS.\n     */\n    function canRedeem() external view returns (bool){\n        return canRedeem(msg.sender);\n    }\n\n    /**\n     * Returns whether the given address is allowed to redeem FPS, which is the\n     * case after their average holding duration is larger than the required minimum.\n     */\n    function canRedeem(address owner) public view returns (bool) {\n        return anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\n    }\n\n     /**\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\n     * @param from      sender\n     * @param amount    amount to be sent\n     */\n    function adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n        uint256 lostVotes = from == address(0x0) ? 0 : (anchorTime() - voteAnchor[from]) * amount;\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n        totalVotesAnchorTime = anchorTime();\n    }\n\n    /**\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\n     * votes does not change despite the higher balance.\n     * @param to        receiver address\n     * @param amount    amount to be received\n     * @return the number of votes lost due to rounding errors\n     */\n    function adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256){\n        if (to != address(0x0)) {\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 blocks\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\n            voteAnchor[to] = uint64(anchorTime() - recipientVotes / newbalance); // new example anchor is only 21 / 11 = 1 block in the past\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\n        } else {\n            // optimization for burn, vote anchor of null address does not matter\n            return 0;\n        }\n    }\n\n    /**\n     * Block number with some additional Bits for higher resolution.\n     */\n    function anchorTime() internal view returns (uint64){\n        return uint64(block.number << BLOCK_TIME_RESOLUTION_BITS);\n    }\n\n    /**\n     * The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) public view returns (uint256) {\n        return balanceOf(holder) * (anchorTime() - voteAnchor[holder]);\n    }\n\n    /**\n     * Total number of votes in the system.\n     */\n    function totalVotes() public view returns (uint256) {\n        return totalVotesAtAnchor + totalSupply() * (anchorTime() - totalVotesAnchorTime);\n    }\n\n    function votes(address sender, address[] calldata helpers) public view returns (uint256) {\n        uint256 _votes = votes(sender);\n        for (uint i=0; i<helpers.length; i++){\n            address current = helpers[i];\n            require(current != sender);\n            require(canVoteFor(sender, current));\n            for (uint j=i+1; j<helpers.length; j++){\n                require(current != helpers[j]); // ensure helper unique\n            }\n            _votes += votes(current);\n        }\n        return _votes;\n    }\n\n    /**\n     * Checks whether the sender address is qualified given a list of helpers that delegated their votes\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\n     * helpes are necessary and to identify them by scanning the blockchain for Delegation events. \n     */\n    function checkQualified(address sender, address[] calldata helpers) public override view {\n        uint256 _votes = votes(sender, helpers);\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\n    }\n\n    error NotQualified();\n\n    /**\n     * Increases the voting power of the delegate by your number of votes without taking away any voting power\n     * from the sender.\n     */\n    function delegateVoteTo(address delegate) external {\n        delegates[msg.sender] = delegate;\n        emit Delegation(msg.sender, delegate);\n    }\n\n    function canVoteFor(address delegate, address owner) internal view returns (bool) {\n        if (owner == delegate){\n            return true;\n        } else if (owner == address(0x0)){\n            return false;\n        } else {\n            return canVoteFor(delegate, delegates[owner]);\n        }\n    }\n\n    /**\n     * In order to mint new FPS tokens, one needs to send ZCHF to this contract using the transferAndCall function\n     * in the ZCHF contract.\n     *\n     * If equity is close to zero or negative, you need to send enough ZCHF to bring equity back to 1000 ZCHF.\n     */\n    function onTokenTransfer(address from, uint256 amount, bytes calldata) external returns (bool) {\n        require(msg.sender == address(zchf), \"caller must be zchf\");\n        uint256 equity = zchf.equity();\n        require(equity >= MINIMUM_EQUITY, \"insuf equity\"); // ensures that the initial deposit is at least 1000 ZCHF\n\n        // Assign 1000 FPS for the initial deposit, calculate the amount otherwise\n        uint256 shares = equity <= amount ? 1000 * ONE_DEC18 : calculateSharesInternal(equity - amount, amount);\n        _mint(from, shares);\n        emit Trade(msg.sender, int(shares), amount, price());\n\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\n        // the 128 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\n        require(totalSupply() < 2**128, \"total supply exceeded\");\n        return true;\n    }\n\n    /**\n     * @notice Calculate shares received when depositing ZCHF\n     * @param investment ZCHF invested\n     * @return amount of shares received for the ZCHF invested\n     */\n    function calculateShares(uint256 investment) public view returns (uint256) {\n        return calculateSharesInternal(zchf.equity(), investment);\n    }\n\n    function calculateSharesInternal(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 newTotalShares = totalShares < 1000 * ONE_DEC18 ? 1000 * ONE_DEC18 : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    /**\n     * Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\n     */\n    function redeem(address target, uint256 shares) public returns (uint256) {\n        require(canRedeem(msg.sender));\n        uint256 proceeds = calculateProceeds(shares);\n        _burn(msg.sender, shares);\n        zchf.transfer(target, proceeds);\n        emit Trade(msg.sender, -int(shares), proceeds, price());\n        return proceeds;\n    }\n\n    /**\n     * @notice Calculate ZCHF received when depositing shares\n     * @param shares number of shares we want to exchange for ZCHF,\n     *               in dec18 format\n     * @return amount of ZCHF received for the shares\n     */\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 capital = zchf.equity();\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n        uint256 newTotalShares = totalShares - shares;\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(newTotalShares, totalShares)));\n        return capital - newCapital;\n    }\n\n    /**\n     * If there is less than 1000 ZCHF in equity left (maybe even negative), the system is at risk\n     * and we should allow qualified FPS holders to restructure the system.\n     *\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\n     * Frankencoin system except for a group of small FPS holders who still believes in it and is willing to provide\n     * 2'000'000 ZCHF to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\n     * would be wrong to force them to share the other million with the passive FPS holders. Instead, they will get\n     * the possibility to bootstrap the system again owning 100% of all FPS shares.\n     */\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) public {\n        require(zchf.equity() < MINIMUM_EQUITY);\n        checkQualified(msg.sender, helpers);\n        for (uint256 i = 0; i<addressesToWipe.length; i++){\n            address current = addressesToWipe[0];\n            _burn(current, balanceOf(current));\n        }\n    }\n\n}"
    },
    {
      "filename": "contracts/Equity.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./Frankencoin.sol\";\nimport \"./IERC677Receiver.sol\";\nimport \"./ERC20PermitLight.sol\";\nimport \"./MathUtil.sol\";\nimport \"./IReserve.sol\";\n\n/** \n * If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\n * weighted reserve pool shares gains veto power and can veto new proposals.\n */\ncontract Equity is ERC20PermitLight, MathUtil, IReserve {\n\n    /**\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\n     *\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\n     *\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\n     * |          1000 |          3000 |             3 |         1000 |\n     * |       1000000 |       3000000 |           300 |        10000 |\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\n     *\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\n     */\n    uint32 public constant VALUATION_FACTOR = 3;\n\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\n\n    /**\n     * The quorum in basis points. 100 is 1%.\n     */\n    uint32 private constant QUORUM = 300;\n\n    /**\n     * The number of digits to store the average holding time of share tokens.\n     */\n    uint8 private constant BLOCK_TIME_RESOLUTION_BITS = 24;\n\n    /**\n     * The minimum holding duration in blocks. You are not allowed to redeem your pool shares if you held them\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\n     * holding duration of your shares is only 55 days < 90 days.\n     */\n    uint256 public constant MIN_HOLDING_DURATION = 90*7200 << BLOCK_TIME_RESOLUTION_BITS; // Set to 5 for local testing\n\n    Frankencoin immutable public zchf;\n\n    /**\n     * To track the total number of votes we need to know the number of votes at the anchor time and when the\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\n     * the total vote count 192 Bits. Given the sub-block time resolution of 24 Bits, the implicit assumption is\n     * that the block number can always be stored in 40 Bits (i.e. it does not exceed a trillion). Further,\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed \n     *   192 - 60 - 40 - 24 = 68 Bits\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact, when\n     * minting, a limit of about 2**30 shares (that's 2**90 Bits when taking into account the decimals) is imposed\n     * when minting. This means that the maximum supply is about a billion shares, which is reached at a market\n     * cap of 3,000,000,000,000,000,000 CHF. This limit could in theory be reached in times of hyper inflaction. \n     */\n    uint192 private totalVotesAtAnchor;  // Total number of votes at the anchor time, see comment on the um\n    uint64 private totalVotesAnchorTime; // 40 Bit for the block number, 24 Bit sub-block time resolution\n\n    /**\n     * Keeping track on who delegated votes to whom.\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\n     */\n    mapping (address => address) public delegates;\n\n    /**\n     * A block number in the past such that: votes = balance * (time passed since anchor was set)\n     */\n    mapping (address => uint64) private voteAnchor; // 40 Bit for the block number, 24 Bit sub-block time resolution\n\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\n\n    constructor(Frankencoin zchf_) ERC20(18) {\n        zchf = zchf_;\n    }\n\n    function name() override external pure returns (string memory) {\n        return \"Frankencoin Pool Share\";\n    }\n\n    function symbol() override external pure returns (string memory) {\n        return \"FPS\";\n    }\n\n    /**\n     * Returns the price of one FPS in ZCHF with 18 decimals precision.\n     */\n    function price() public view returns (uint256){\n        return VALUATION_FACTOR * zchf.equity() * ONE_DEC18 / totalSupply();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal {\n        super._beforeTokenTransfer(from, to, amount);\n        if (amount > 0){\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\n            // their votes so everything falls nicely into place.\n            // Recipient votes should stay the same, but grow faster in the future, requiring an adjustment of the anchor.\n            uint256 roundingLoss = adjustRecipientVoteAnchor(to, amount);\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\n            adjustTotalVotes(from, amount, roundingLoss);\n        }\n    }\n\n    /**\n     * Returns whether the sender address is allowed to redeem FPS.\n     */\n    function canRedeem() external view returns (bool){\n        return canRedeem(msg.sender);\n    }\n\n    /**\n     * Returns whether the given address is allowed to redeem FPS, which is the\n     * case after their average holding duration is larger than the required minimum.\n     */\n    function canRedeem(address owner) public view returns (bool) {\n        return anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\n    }\n\n     /**\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\n     * @param from      sender\n     * @param amount    amount to be sent\n     */\n    function adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n        uint256 lostVotes = from == address(0x0) ? 0 : (anchorTime() - voteAnchor[from]) * amount;\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n        totalVotesAnchorTime = anchorTime();\n    }\n\n    /**\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\n     * votes does not change despite the higher balance.\n     * @param to        receiver address\n     * @param amount    amount to be received\n     * @return the number of votes lost due to rounding errors\n     */\n    function adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256){\n        if (to != address(0x0)) {\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 blocks\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\n            voteAnchor[to] = uint64(anchorTime() - recipientVotes / newbalance); // new example anchor is only 21 / 11 = 1 block in the past\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\n        } else {\n            // optimization for burn, vote anchor of null address does not matter\n            return 0;\n        }\n    }\n\n    /**\n     * Block number with some additional Bits for higher resolution.\n     */\n    function anchorTime() internal view returns (uint64){\n        return uint64(block.number << BLOCK_TIME_RESOLUTION_BITS);\n    }\n\n    /**\n     * The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) public view returns (uint256) {\n        return balanceOf(holder) * (anchorTime() - voteAnchor[holder]);\n    }\n\n    /**\n     * Total number of votes in the system.\n     */\n    function totalVotes() public view returns (uint256) {\n        return totalVotesAtAnchor + totalSupply() * (anchorTime() - totalVotesAnchorTime);\n    }\n\n    function votes(address sender, address[] calldata helpers) public view returns (uint256) {\n        uint256 _votes = votes(sender);\n        for (uint i=0; i<helpers.length; i++){\n            address current = helpers[i];\n            require(current != sender);\n            require(canVoteFor(sender, current));\n            for (uint j=i+1; j<helpers.length; j++){\n                require(current != helpers[j]); // ensure helper unique\n            }\n            _votes += votes(current);\n        }\n        return _votes;\n    }\n\n    /**\n     * Checks whether the sender address is qualified given a list of helpers that delegated their votes\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\n     * helpes are necessary and to identify them by scanning the blockchain for Delegation events. \n     */\n    function checkQualified(address sender, address[] calldata helpers) public override view {\n        uint256 _votes = votes(sender, helpers);\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\n    }\n\n    error NotQualified();\n\n    /**\n     * Increases the voting power of the delegate by your number of votes without taking away any voting power\n     * from the sender.\n     */\n    function delegateVoteTo(address delegate) external {\n        delegates[msg.sender] = delegate;\n        emit Delegation(msg.sender, delegate);\n    }\n\n    function canVoteFor(address delegate, address owner) internal view returns (bool) {\n        if (owner == delegate){\n            return true;\n        } else if (owner == address(0x0)){\n            return false;\n        } else {\n            return canVoteFor(delegate, delegates[owner]);\n        }\n    }\n\n    /**\n     * In order to mint new FPS tokens, one needs to send ZCHF to this contract using the transferAndCall function\n     * in the ZCHF contract.\n     *\n     * If equity is close to zero or negative, you need to send enough ZCHF to bring equity back to 1000 ZCHF.\n     */\n    function onTokenTransfer(address from, uint256 amount, bytes calldata) external returns (bool) {\n        require(msg.sender == address(zchf), \"caller must be zchf\");\n        uint256 equity = zchf.equity();\n        require(equity >= MINIMUM_EQUITY, \"insuf equity\"); // ensures that the initial deposit is at least 1000 ZCHF\n\n        // Assign 1000 FPS for the initial deposit, calculate the amount otherwise\n        uint256 shares = equity <= amount ? 1000 * ONE_DEC18 : calculateSharesInternal(equity - amount, amount);\n        _mint(from, shares);\n        emit Trade(msg.sender, int(shares), amount, price());\n\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\n        // the 128 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\n        require(totalSupply() < 2**128, \"total supply exceeded\");\n        return true;\n    }\n\n    /**\n     * @notice Calculate shares received when depositing ZCHF\n     * @param investment ZCHF invested\n     * @return amount of shares received for the ZCHF invested\n     */\n    function calculateShares(uint256 investment) public view returns (uint256) {\n        return calculateSharesInternal(zchf.equity(), investment);\n    }\n\n    function calculateSharesInternal(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 newTotalShares = totalShares < 1000 * ONE_DEC18 ? 1000 * ONE_DEC18 : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    /**\n     * Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\n     */\n    function redeem(address target, uint256 shares) public returns (uint256) {\n        require(canRedeem(msg.sender));\n        uint256 proceeds = calculateProceeds(shares);\n        _burn(msg.sender, shares);\n        zchf.transfer(target, proceeds);\n        emit Trade(msg.sender, -int(shares), proceeds, price());\n        return proceeds;\n    }\n\n    /**\n     * @notice Calculate ZCHF received when depositing shares\n     * @param shares number of shares we want to exchange for ZCHF,\n     *               in dec18 format\n     * @return amount of ZCHF received for the shares\n     */\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 capital = zchf.equity();\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n        uint256 newTotalShares = totalShares - shares;\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(newTotalShares, totalShares)));\n        return capital - newCapital;\n    }\n\n    /**\n     * If there is less than 1000 ZCHF in equity left (maybe even negative), the system is at risk\n     * and we should allow qualified FPS holders to restructure the system.\n     *\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\n     * Frankencoin system except for a group of small FPS holders who still believes in it and is willing to provide\n     * 2'000'000 ZCHF to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\n     * would be wrong to force them to share the other million with the passive FPS holders. Instead, they will get\n     * the possibility to bootstrap the system again owning 100% of all FPS shares.\n     */\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) public {\n        require(zchf.equity() < MINIMUM_EQUITY);\n        checkQualified(msg.sender, helpers);\n        for (uint256 i = 0; i<addressesToWipe.length; i++){\n            address current = addressesToWipe[0];\n            _burn(current, balanceOf(current));\n        }\n    }\n\n}"
    },
    {
      "filename": "contracts/Equity.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./Frankencoin.sol\";\nimport \"./IERC677Receiver.sol\";\nimport \"./ERC20PermitLight.sol\";\nimport \"./MathUtil.sol\";\nimport \"./IReserve.sol\";\n\n/** \n * If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\n * weighted reserve pool shares gains veto power and can veto new proposals.\n */\ncontract Equity is ERC20PermitLight, MathUtil, IReserve {\n\n    /**\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\n     *\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\n     *\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\n     * |          1000 |          3000 |             3 |         1000 |\n     * |       1000000 |       3000000 |           300 |        10000 |\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\n     *\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\n     */\n    uint32 public constant VALUATION_FACTOR = 3;\n\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\n\n    /**\n     * The quorum in basis points. 100 is 1%.\n     */\n    uint32 private constant QUORUM = 300;\n\n    /**\n     * The number of digits to store the average holding time of share tokens.\n     */\n    uint8 private constant BLOCK_TIME_RESOLUTION_BITS = 24;\n\n    /**\n     * The minimum holding duration in blocks. You are not allowed to redeem your pool shares if you held them\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\n     * holding duration of your shares is only 55 day"
    }
  ]
}