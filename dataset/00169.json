{
  "Title": "H-2: Original collection referrer will be overwritten when a new collection/work is created",
  "Content": "# Issue H-2: Original collection referrer will be overwritten when a new collection/work is created \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/265 \n\n## Found by \n14si2o\\_Flint, Varun\\_05, mt030d, xiaoming90\n## Summary\n\nOriginal collection referrers will be overwritten when a new collection/work is created. This results in the original collection referrers being unable to collect the fee they are entitled to, leading to a loss of assets for them.\n\n## Vulnerability Detail\n\n> [!NOTE]\n>\n> The following information is taken from the sponsor's response in the Contest's Discord Channel.\n>\n> There are two types of referrers in this ecosystem. The first is a collection referrer, who refers the creation of a new Edition, and gets a cut of all mint fees for that Edition. The second is a mint referrer, who refers a mint and gets a cut of the mint fee for that mint.\n>\n> The following describes the difference between collection referrer and mint referrer.\n>\n> - User 1 creates a referral link to create a collection\n> - User 2 uses that link to publish a collection\n> - User 3 mints that collection. For this mint, user1 is treated as the collection referrer\n> - User 4 creates a referral link to mint that collection\n> - User 5 mints that collection. For this mint, user1 is treated as the collection referrer and user4 is treated as the mint referrer\n>\n\nAssume that Alice creates a referral link to create a collection. Bob uses that link to publish a new collection/work called $Collection_A$ that is based on an Edition called $Edition_A$. The collection referrer of $Collection_A$ will Alice. \n\nBob will call the following `TitlesCore.publish` function with the `edition` parameter set to $Edition_A$​ and the `referrer_` parameter will be automatically set to Alice by the front end.\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/TitlesCore.sol#L103\n\n```solidity\nFile: TitlesCore.sol\n098:     /// @notice Publishes a new Work in the given {Edition} using the given payload.\n099:     /// @param edition_ The {Edition} to publish the Work in.\n100:     /// @param payload_ The compressed payload for publishing the Work. See {WorkPayload}.\n101:     /// @param referrer_ The address of the referrer.\n102:     /// @return tokenId The token ID of the new Work.\n103:     function publish(Edition edition_, bytes calldata payload_, address referrer_)\n..SNIP..\n140:         // Create the fee route for the new Work\n141:         // wake-disable-next-line reentrancy\n142:         Target memory feeReceiver = feeManager.createRoute(\n143:             edition_, tokenId, _attributionTargets(work_.attributions), referrer_\n..SNIP..\n```\n\nWithin the `TitlesCore.publish`, the following `feeManager.createRoute` function will be executed internally. The `feeManager.createRoute` function will store Alice's wallet address within the `referrers[edition_]` mapping. Thus, the state of the `referrers` mapping will be as follows:\n\n```solidity\nreferrers[Edition_A] = Alice\n```\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L125\n\n```solidity\nFile: FeeManager.sol\n125:     function createRoute(\n126:         IEdition edition_,\n127:         uint256 tokenId_,\n128:         Target[] calldata attributions_,\n129:         address referrer_\n130:     ) external onlyOwnerOrRoles(ADMIN_ROLE) returns (Target memory receiver) {\n..SNIP..\n158:         _feeReceivers[getRouteId(edition_, tokenId_)] = receiver;\n159:         referrers[edition_] = referrer_;\n160:     }\n```\n\nWhen someone mints a new token for $Collection_A$​, Alice, who is the collection referrer, will get a share of the minting fee per Line 421 below.\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L421\n\n```solidity\nFile: FeeManager.sol\n412:     function _splitProtocolFee(\n413:         IEdition edition_,\n414:         address asset_,\n415:         uint256 amount_,\n416:         address payer_,\n417:         address referrer_\n418:     ) internal returns (uint256 referrerShare) {\n419:         // The creation and mint referrers earn 25% and 50% of the protocol's share respectively, if applicable\n420:         uint256 mintReferrerShare = getMintReferrerShare(amount_, referrer_);\n421:         uint256 collectionReferrerShare = getCollectionReferrerShare(amount_, referrers[edition_]);\n422:         referrerShare = mintReferrerShare + collectionReferrerShare;\n```\n\nLet's assume Charles also creates a referral link to create a collection. David uses that link to publish a new collection/work called $Collection_B$ that is based on the same Edition called $Edition_A$. The collection referral of $Collection_B$ will be Charles.\n\nWhen the `FeeManager.createRoute` function is executed during the publishing of the new work/collection, Charles's wallet address will be stored within the `referrers[edition_]` mapping. Thus, the state of the `referrers` mapping will be as follows:\n\n```solidity\nreferrers[Edition_A] = Charles\n```\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L125\n\n```solidity\nFile: FeeManager.sol\n125:     function createRoute(\n126:         IEdition edition_,\n127:         uint256 tokenId_,\n128:         Target[] calldata attributions_,\n129:         address referrer_\n130:     ) external onlyOwnerOrRoles(ADMIN_ROLE) returns (Target memory receiver) {\n..SNIP..\n158:         _feeReceivers[getRouteId(edition_, tokenId_)] = receiver;\n159:         referrers[edition_] = referrer_;\n160:     }\n```\n\nIt is important to note that the `referrers[Edition_A]` have been updated from Alice to Charles here. At this point onwards, if someone mints tokens for $Collection_A$, the collection referral fee will be routed to Charles instead of Alice. Alice is the referral for $Collection_A$, yet she does not receive the referral fee, resulting in a loss of assets for Alice.\n\n## Impact\n\nLoss of assets as shown in the above scenario. The original collection referrers are unable to collect the fee they are entitled to, leading to a loss of assets for them.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/TitlesCore.sol#L103\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L125\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L421\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider the following changes to ensure that the collection referral fee is routed to the correct collection referrer for each collection/work. \n\nWith the following changes, Alice will continue to receive the collection referral fee for $Collection_A$ and Bob will receive the collection referral fee for $Collection_B$ even if there are multiple collections/works for a specific Edition.\n\n```diff\nfunction createRoute(\n    IEdition edition_,\n    uint256 tokenId_,\n    Target[] calldata attributions_,\n    address referrer_\n) external onlyOwnerOrRoles(ADMIN_ROLE) returns (Target memory receiver) {\n..SNIP..\n    _feeReceivers[getRouteId(edition_, tokenId_)] = receiver;\n-    referrers[edition_] = referrer_;\n+    referrers[getRouteId(edition_, tokenId_)] = referrer_;\n}\n```\n\n```diff\nfunction _splitProtocolFee(\n    IEdition edition_,\n+\t\tuint256 tokenId,    \n    address asset_,\n    uint256 amount_,\n    address payer_,\n    address referrer_\n) internal returns (uint256 referrerShare) {\n    // The creation and mint referrers earn 25% and 50% of the protocol's share respectively, if applicable\n    uint256 mintReferrerShare = getMintReferrerShare(amount_, referrer_);\n-    uint256 collectionReferrerShare = getCollectionReferrerShare(amount_, referrers[edition_]);\n+    uint256 collectionReferrerShare = getCollectionReferrerShare(amount_, referrers[getRouteId(edition_, tokenId)]);\n    referrerShare = mintReferrerShare + collectionReferrerShare;\n```\n\n\n\n## Discussion\n\n**pqseags**\n\nValid, but duplicate of #59 \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "wallflower-contract-v2/src/TitlesCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {LibClone} from \"lib/solady/src/utils/LibClone.sol\";\nimport {LibZip} from \"lib/solady/src/utils/LibZip.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Receiver} from \"lib/solady/src/accounts/Receiver.sol\";\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\nimport {UUPSUpgradeable} from \"lib/solady/src/utils/UUPSUpgradeable.sol\";\n\nimport {EnumerableMap} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol\";\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {Edition} from \"src/editions/Edition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\n\nimport {\n    ADMIN_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    EditionCreated,\n    FeeStrategyUpdated,\n    Metadata,\n    Node,\n    Strategy,\n    Target\n} from \"src/shared/Common.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\n\n/// @title Titles Core\n/// @notice Core contract for the Titles Protocol\ncontract TitlesCore is OwnableRoles, Initializable, UUPSUpgradeable, Receiver {\n    using LibClone for address;\n    using LibZip for bytes;\n    using SafeTransferLib for address;\n\n    address public editionImplementation = address(new Edition());\n    FeeManager public feeManager;\n    TitlesGraph public graph;\n\n    /// @notice Initializes the protocol.\n    /// @param feeReceiver_ The address to receive fees.\n    /// @param splitFactory_ The address of the split factory.\n    function initialize(address feeReceiver_, address splitFactory_) external initializer {\n        _initializeOwner(msg.sender);\n\n        feeManager = new FeeManager(msg.sender, feeReceiver_, splitFactory_);\n        graph = new TitlesGraph(address(this), msg.sender);\n    }\n\n    /// @notice The payload for creating a Work within an {Edition}.\n    struct WorkPayload {\n        Target creator;\n        Node[] attributions;\n        uint256 maxSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n        Metadata metadata;\n    }\n\n    /// @notice The payload for creating an {Edition}.\n    struct EditionPayload {\n        WorkPayload work;\n        Metadata metadata;\n    }\n\n    /// @notice Creates an {Edition} with the given payload.\n    /// @param payload_ The compressed payload for creating the {Edition}. See {EditionPayload}.\n    /// @param referrer_ The address of the referrer.\n    /// @return edition The new {Edition}.\n    function createEdition(bytes calldata payload_, address referrer_)\n        external\n        payable\n        returns (Edition edition)\n    {\n        EditionPayload memory payload = abi.decode(payload_.cdDecompress(), (EditionPayload));\n\n        edition = Edition(editionImplementation.clone());\n\n        // wake-disable-next-line reentrancy\n        edition.initialize(\n            feeManager, graph, payload.work.creator.target, address(this), payload.metadata\n        );\n\n        // wake-disable-next-line unchecked-return-value\n        _publish(edition, payload.work, referrer_);\n\n        emit EditionCreated(\n            address(edition),\n            payload.work.creator.target,\n            payload.work.maxSupply,\n            payload.work.strategy,\n            abi.encode(payload.metadata)\n        );\n    }\n\n    /// @notice Publishes a new Work in the given {Edition} using the given payload.\n    /// @param edition_ The {Edition} to publish the Work in.\n    /// @param payload_ The compressed payload for publishing the Work. See {WorkPayload}.\n    /// @param referrer_ The address of the referrer.\n    /// @return tokenId The token ID of the new Work.\n    function publish(Edition edition_, bytes calldata payload_, address referrer_)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        if (!edition_.hasAnyRole(msg.sender, EDITION_PUBLISHER_ROLE)) {\n            revert Unauthorized();\n        }\n        WorkPayload memory payload = abi.decode(payload_.cdDecompress(), (WorkPayload));\n        return _publish(edition_, payload, referrer_);\n    }\n\n    /// @notice Publishes a new Work in the given {Edition} using the given payload.\n    /// @param edition_ The {Edition} to publish the Work in.\n    /// @param work_ The payload for publishing the Work. See {EditionPayload}.\n    /// @param referrer_ The address of the referrer.\n    /// @return tokenId The token ID of the new Work.\n    function _publish(Edition edition_, WorkPayload memory work_, address referrer_)\n        internal\n        returns (uint256 tokenId)\n    {\n        // Publish the new Work in the Edition\n        // wake-disable-next-line reentrancy\n        tokenId = edition_.publish(\n            work_.creator.target,\n            work_.maxSupply,\n            work_.opensAt,\n            work_.closesAt,\n            work_.attributions,\n            work_.strategy,\n            work_.metadata\n        );\n\n        // Collect the creation fee\n        // wake-disable-next-line reentrancy\n        feeManager.collectCreationFee{value: msg.value}(edition_, tokenId, msg.sender);\n\n        // Create the fee route for the new Work\n        // wake-disable-next-line reentrancy\n        Target memory feeReceiver = feeManager.createRoute(\n            edition_, tokenId, _attributionTargets(work_.attributions), referrer_\n        );\n\n        // Set the royalty target for the new Work\n        // wake-disable-next-line reentrancy\n        edition_.setRoyaltyTarget(tokenId, feeReceiver.target);\n    }\n\n    /// @notice Sets the implementation address to be cloned for each new {Edition}.\n    /// @param implementation_ The new implementation address.\n    /// @dev Only the owner can call this function.\n    function setEditionImplementation(address implementation_)\n        external\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        editionImplementation = implementation_;\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    /// @dev This function is overridden to restrict access to the owner/admin. No other logic required.\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {}\n\n    /// @notice Returns the targets of the given attributions.\n    function _attributionTargets(Node[] memory attributions_)\n        internal\n        pure\n        returns (Target[] memory targets)\n    {\n        targets = new Target[](attributions_.length);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            targets[i] = attributions_[i].creator;\n        }\n    }\n}"
    },
    {
      "filename": "wallflower-contract-v2/src/fees/FeeManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {LibZip} from \"solady/utils/LibZip.sol\";\nimport {OwnableRoles} from \"solady/auth/OwnableRoles.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {SplitFactoryV2} from \"splits-v2/splitters/SplitFactoryV2.sol\";\nimport {SplitV2Lib} from \"splits-v2/libraries/SplitV2.sol\";\n\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport \"src/shared/Common.sol\";\n\n/// @title Titles Fee Manager\n/// @notice Manages fees for the Titles Protocol\n/// @dev The FeeManager contract is responsible for collecting fees associated with protocol actions.\ncontract FeeManager is OwnableRoles {\n    using SafeTransferLib for address;\n    using LibZip for bytes;\n\n    /// @notice The payload for creating a {Strategy}.\n    /// @param edition The address of the {Edition} to be associated with the {Strategy}.\n    /// @param tokenId The ID of the token to be associated with the {Strategy}.\n    /// @param strategy The {Strategy} to be created.\n    struct StrategyPayload {\n        address edition;\n        uint256 tokenId;\n        Strategy strategy;\n    }\n\n    /////////////////////\n    // Events & Errors //\n    /////////////////////\n\n    /// @notice Emitted when a fee is collected.\n    /// @param edition The address of the edition for which the fee was collected.\n    /// @param work The ID of the work for which the fee was collected.\n    /// @param asset The address of the asset which was collected.\n    /// @param fee The amount of the fee collected.\n    /// @param referrerShare The portion of the collected fee which was paid to the referrer.\n    event FeeCollected(\n        address indexed edition, uint256 work, address asset, uint256 fee, uint256 referrerShare\n    );\n\n    /// @notice Emitted when the protocol fees are changed.\n    /// @param protocolFeeBps The new protocol fee in basis points.\n    /// @param protocolFlatFee The new protocol flat fee.\n    /// @param mintReferrerRevshareBps The new partner revenue share in basis points.\n    event ProtocolFeesChanged(\n        uint16 protocolFeeBps, uint128 protocolFlatFee, uint16 mintReferrerRevshareBps\n    );\n\n    /// @notice Thrown when an invalid fee configuration is supplied.\n    error InvalidFee();\n\n    /// @notice Thrown when a fee cannot be routed.\n    error NotRoutable();\n\n    ///////////////////\n    // Fee Constants //\n    ///////////////////\n\n    /// @dev The maximum basis points (BPS) value. Equivalent to 100%.\n    uint16 public constant MAX_BPS = 10_000;\n\n    /// @dev The maximum protocol fee in basis points (BPS). Equivalent to 33.33%.\n    uint16 public constant MAX_PROTOCOL_FEE_BPS = 3333;\n\n    /// @dev The maximum protocol fee in wei. Applies to both flat and percentage fees.\n    uint64 public constant MAX_PROTOCOL_FEE = 0.1 ether;\n\n    /// @dev The maximum royalty fee in basis points (BPS). Equivalent to 95%.\n    uint16 public constant MAX_ROYALTY_BPS = 9500;\n\n    /// @dev The minimum royalty fee in basis points (BPS). Equivalent to 2.5%.\n    uint16 public constant MIN_ROYALTY_BPS = 250;\n\n    ///////////////////////\n    // Fee Configuration //\n    ///////////////////////\n\n    /// @notice The protocol creation fee. This fee is collected when a new {Edition} is created.\n    uint128 public protocolCreationFee = 0.0001 ether;\n\n    /// @notice The flat fee for the protocol. This fee is collected on all mint transactions.\n    uint128 public protocolFlatFee = 0.0006 ether;\n\n    /// @notice The protocol fee share in basis points (BPS). Only applies to protocol fees collected for unpriced mints.\n    uint32 public protocolFeeshareBps = 3333;\n\n    /// @notice The share of protocol fees to be distributed to the direct referrer of the mint, in basis points (BPS).\n    uint16 public mintReferrerRevshareBps = 5000;\n\n    /// @notice The share of protocol fees to be distributed to the referrer of the collection, in basis points (BPS).\n    uint16 public collectionReferrerRevshareBps = 2500;\n\n    /// @notice The address of the protocol fee receiver.\n    address public protocolFeeReceiver;\n\n    /// @notice The {SplitFactoryV2} contract used to create fee splits.\n    SplitFactoryV2 public splitFactory;\n\n    /// @notice The mapping of referrers for each {Edition}'s creation.\n    mapping(IEdition edition => address referrer) public referrers;\n\n    /// @notice The mapping of fee receivers by ID.\n    mapping(bytes32 id => Target receiver) private _feeReceivers;\n\n    /// @notice Initializes the {FeeManager} contract.\n    /// @param protocolFeeReceiver_ The address of the protocol fee receiver.\n    /// @param splitFactory_ The address of the {SplitFactoryV2} contract.\n    constructor(address admin_, address protocolFeeReceiver_, address splitFactory_) {\n        _initializeOwner(msg.sender);\n        _grantRoles(admin_, ADMIN_ROLE);\n        protocolFeeReceiver = protocolFeeReceiver_;\n        splitFactory = SplitFactoryV2(splitFactory_);\n    }\n\n    /// @notice Creates a new fee route for the given {Edition} and attributions.\n    /// @param edition_ The {Edition} for which to create the route.\n    /// @param tokenId_ The token ID associated with the route.\n    /// @param attributions_ The attributions to be associated with the route.\n    /// @param referrer_ The address of the referrer to receive a share of the fee.\n    function createRoute(\n        IEdition edition_,\n        uint256 tokenId_,\n        Target[] calldata attributions_,\n        address referrer_\n    ) external onlyOwnerOrRoles(ADMIN_ROLE) returns (Target memory receiver) {\n        Target memory creator = edition_.node(tokenId_).creator;\n\n        if (attributions_.length == 0) {\n            // No attributions, pay the creator directly\n            receiver = creator;\n        } else {\n            // Distribute the fee among the creator and attributions\n            (address[] memory targets, uint256[] memory revshares) = _buildSharesAndTargets(\n                creator, attributions_, edition_.feeStrategy(tokenId_).revshareBps\n            );\n\n            // Create the split. The protocol retains \"ownership\" to enable future use cases.\n            receiver = Target({\n                target: splitFactory.createSplit(\n                    SplitV2Lib.Split({\n                        recipients: targets,\n                        allocations: revshares,\n                        totalAllocation: 1e6,\n                        distributionIncentive: 0\n                    }),\n                    address(this),\n                    creator.target\n                    ),\n                chainId: creator.chainId\n            });\n        }\n\n        _feeReceivers[getRouteId(edition_, tokenId_)] = receiver;\n        referrers[edition_] = referrer_;\n    }\n\n    /// @notice Collects the creation fee for a given {Edition}.\n    /// @param edition_ The {Edition} for which to collect the creation fee.\n    /// @param tokenId_ The token ID associated with the fee.\n    /// @param feePayer_ The address of the account paying the fee.\n    function collectCreationFee(IEdition edition_, uint256 tokenId_, address feePayer_)\n        external\n        payable\n    {\n        Fee memory fee = getCreationFee();\n        if (fee.amount == 0) return;\n\n        _route(fee, Target({target: protocolFeeReceiver, chainId: block.chainid}), feePayer_);\n        emit FeeCollected(address(edition_), tokenId_, ETH_ADDRESS, fee.amount, 0);\n    }\n\n    /// @notice Collects the mint fee for a given {Edition}.\n    /// @param edition_ The {Edition} for which to collect the mint fee.\n    /// @param tokenId_ The token ID associated with the fee.\n    /// @param amount_ The amount of the fee to collect.\n    /// @param payer_ The address of the account paying the fee.\n    /// @param referrer_ The address of the referrer to receive a share of the fee.\n    function collectMintFee(\n        IEdition edition_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address payer_,\n        address referrer_\n    ) external payable {\n        _collectMintFee(\n            edition_, tokenId_, amount_, payer_, referrer_, getMintFee(edition_, tokenId_, amount_)\n        );\n    }\n\n    /// @notice Collects the mint fee for a given {Edition} and token ID, routing it as appropriate.\n    /// @param edition The {Edition} for which the fee is being collected.\n    /// @param tokenId_ The token ID associated with the fee.\n    /// @param amount_ The amount of the fee to collect.\n    /// @param payer_ The address of the account paying the fee.\n    /// @param referrer_ The address of the referrer to receive a share of the fee.\n    /// @param strategy_ The {Strategy} to use for computing the fee split.\n    function collectMintFee(\n        IEdition edition,\n        uint256 tokenId_,\n        uint256 amount_,\n        address payer_,\n        address referrer_,\n        Strategy calldata strategy_\n    ) external payable {\n        _collectMintFee(\n            edition, tokenId_, amount_, payer_, referrer_, getMintFee(strategy_, amount_)\n        );\n    }\n\n    /// @notice Gets the fee receiver for a given {Edition}.\n    /// @param edition_ The {Edition} for which to get the fee receiver.\n    /// @return feeReceiver The {Target} to receive the fee.\n    function feeReceiver(IEdition edition_, uint256 tokenId_) public view returns (Target memory) {\n        return _feeReceivers[getRouteId(edition_, tokenId_)];\n    }\n\n    /// @notice Calculates the fee for creating a new {Edition}.\n    /// @return fee The {Fee} for creating a new {Edition}.\n    /// @dev The creation fee is a flat fee collected by the protocol when a new {Edition} is created.\n    function getCreationFee() public view returns (Fee memory fee) {\n        return Fee({asset: ETH_ADDRESS, amount: protocolCreationFee});\n    }\n\n    /// @notice Calculates the mint fee for a given {Edition} based on its {Strategy}.\n    /// @param edition_ The {Edition} for which to calculate the mint fee.\n    /// @return fee The {Fee} for minting the {Edition}.\n    /// @dev The mint fee is calculated as the sum of:\n    ///      - The mint fee specified by the creator in the {Strategy}.\n    ///      - The protocol's base transaction fee (see {protocolFlatFee}).\n    function getMintFee(IEdition edition_, uint256 tokenId_, uint256 quantity_)\n        public\n        view\n        returns (Fee memory fee)\n    {\n        return getMintFee(edition_.feeStrategy(tokenId_), quantity_);\n    }\n\n    /// @notice Calculates the mint fee for a given {Strategy} based on the quantity of tokens being minted.\n    /// @param strategy_ The {Strategy} for which to calculate the mint fee.\n    /// @param quantity_ The quantity of tokens being minted.\n    /// @return fee The {Fee} for minting the tokens.\n    /// @dev The mint fee is calculated as the sum of:\n    ///      - The {Strategy.mintFee}.\n    ///      - The {protocolFlatFee}.\n    function getMintFee(Strategy memory strategy_, uint256 quantity_)\n        public\n        view\n        returns (Fee memory fee)\n    {\n        // Return the total fee (creator's mint fee + protocol flat fee)\n        return Fee({asset: ETH_ADDRESS, amount: quantity_ * (strategy_.mintFee + protocolFlatFee)});\n    }\n\n    /// @notice Calculates the referrer share for a given amount.\n    /// @param protocolFee_ The amount from which to calculate the referrer share.\n    /// @return referrerShare The mint referrer's share.\n    function getMintReferrerShare(uint256 protocolFee_, address referrer_)\n        public\n        view\n        returns (uint256)\n    {\n        if (referrer_ == address(0)) return 0;\n        return protocolFee_ * mintReferrerRevshareBps / MAX_BPS;\n    }\n\n    /// @notice Calculates the collection referrer share for a given amount.\n    /// @param protocolFee_ The amount from which to calculate the collection referrer share.\n    /// @return referrerShare The collection referrer's share.\n    function getCollectionReferrerShare(uint256 protocolFee_, address referrer_)\n        public\n        view\n        returns (uint256)\n    {\n        if (referrer_ == address(0)) return 0;\n        return protocolFee_ * collectionReferrerRevshareBps / MAX_BPS;\n    }\n\n    /// @notice Gets the route ID for a given {Edition} and token ID.\n    /// @param edition_ The {Edition} for which to get the route ID.\n    /// @param tokenId_ The token ID for which to get the route ID.\n    /// @return id The route ID.\n    function getRouteId(IEdition edition_, uint256 tokenId_) public pure returns (bytes32 id) {\n        return keccak256(abi.encodePacked(edition_, tokenId_));\n    }\n\n    /// @notice Updates the protocol fees which are collected for various actions.\n    /// @param protocolCreationFee_ The new protocol creation fee. This fee is collected when a new {Edition} is created. Cannot exceed {MAX_PROTOCOL_FEE}.\n    /// @param protocolFlatFee_ The new protocol flat fee. This fee is collected on all mint transactions. Cannot exceed {MAX_PROTOCOL_FEE}.\n    /// @param protocolFeeShareBps_ The new protocol fee share in basis points. Cannot exceed {MAX_PROTOCOL_FEE_BPS}.\n    /// @param mintReferrerRevshareBps_ The new mint referrer revenue share in basis points. This plus the collection referrer share cannot exceed {MAX_ROYALTY_BPS}.\n    /// @param collectionReferrerRevshareBps_ The new collection referrer revenue share in basis points. This plus the mint referrer share cannot exceed {MAX_ROYALTY_BPS}.\n    /// @dev This function can only be called by the owner or an admin.\n    function setProtocolFees(\n        uint64 protocolCreationFee_,\n        uint64 protocolFlatFee_,\n        uint16 protocolFeeShareBps_,\n        uint16 mintReferrerRevshareBps_,\n        uint16 collectionReferrerRevshareBps_\n    ) external onlyOwnerOrRoles(ADMIN_ROLE) {\n        if (\n            protocolCreationFee_ > MAX_PROTOCOL_FEE || protocolFlatFee_ > MAX_PROTOCOL_FEE\n                || protocolFeeShareBps_ > MAX_PROTOCOL_FEE_BPS\n                || (mintReferrerRevshareBps_ + collectionReferrerRevshareBps_) > MAX_BPS\n        ) {\n            revert InvalidFee();\n        }\n        protocolCreationFee = protocolCreationFee_;\n        protocolFlatFee = protocolFlatFee_;\n        protocolFeeshareBps = protocolFeeShareBps_;\n        mintReferrerRevshareBps = mintReferrerRevshareBps_;\n        collectionReferrerRevshareBps = collectionReferrerRevshareBps_;\n    }\n\n    /// @notice Returns a validated {Strategy} based on the given data.\n    /// @param strategy_ The {Strategy} to validate.\n    /// @return strategy The validated {Strategy}.\n    function validateStrategy(Strategy calldata strategy_)\n        external\n        pure\n        returns (Strategy memory strategy)\n    {\n        // Clamp the revshare to the range of [MIN_ROYALTY_BPS...MAX_ROYALTY_BPS]\n        uint16 revshareBps = strategy_.revshareBps > MAX_ROYALTY_BPS\n            ? MAX_ROYALTY_BPS\n            : strategy_.revshareBps < MIN_ROYALTY_BPS ? MIN_ROYALTY_BPS : strategy_.revshareBps;\n\n        // Clamp the royalty to the range of [0...MAX_ROYALTY_BPS]\n        uint16 royaltyBps =\n            strategy_.royaltyBps > MAX_ROYALTY_BPS ? MAX_ROYALTY_BPS : strategy_.royaltyBps;\n\n        strategy = Strategy({\n            asset: strategy_.asset == address(0) ? ETH_ADDRESS : strategy_.asset,\n            mintFee: strategy_.mintFee,\n            revshareBps: revshareBps,\n            royaltyBps: royaltyBps\n        });\n    }\n\n    /// @notice Allows the contract to receive ETH.\n    receive() external payable {}\n\n    /// @notice An escape hatch to transfer any trapped assets from the contract to the given address.\n    /// @param asset_ The address of the asset to withdraw.\n    /// @param amount_ The amount of the asset to withdraw.\n    /// @param to_ The address to send the asset to.\n    /// @dev This is meant to be used in cases where the contract is holding assets that it should not be. This function can only be called by an admin.\n    function withdraw(address asset_, uint256 amount_, address to_)\n        external\n        onlyRolesOrOwner(ADMIN_ROLE)\n    {\n        _transfer(asset_, amount_, address(this), to_);\n    }\n\n    /// @notice Collects the given {Fee} for a given {Edition} and token ID, routing it as appropriate.\n    /// @param edition_ The {Edition} for which the fee is being collected.\n    /// @param tokenId_ The token ID associated with the fee.\n    /// @param amount_ The amount of tokens being minted.\n    /// @param payer_ The address of the account paying the fee.\n    /// @param referrer_ The address of the referrer to receive a share of the fee.\n    /// @param fee_ The {Fee} to collect.\n    function _collectMintFee(\n        IEdition edition_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address payer_,\n        address referrer_,\n        Fee memory fee_\n    ) internal {\n        if (fee_.amount == 0) return;\n\n        // For free mints:\n        // - Protocol Share = 1/3 of flat fee\n        // - Edition Share = 2/3 of flat fee\n        //\n        // For priced mints:\n        // - Protocol Share = 100% of flat fee, shared as follows:\n        // - Edition Share = 100% of creator-specified mint cost, 0% of flat fee\n        //\n        // In both cases, the protocol and edition shares may be split as follows:\n        // - Protocol Share\n        //   - If a referred mint, mint referrer gets 50% of the protocol share\n        //   - If a referred collection, collection referrer gets 25% of the protcol share\n        //   - Protocol fee receiver gets the remainder of the protocol share\n        // - Edition Share\n        //   - Attributions equally split 25% of the edition share, if applicable\n        //   - Creator gets the remainder of the edition share\n\n        uint256 protocolFee = protocolFlatFee * amount_;\n        uint256 protocolShare;\n        if (fee_.amount == protocolFee) {\n            protocolShare = protocolFee * protocolFeeshareBps / MAX_BPS;\n        } else {\n            protocolShare = protocolFee;\n        }\n\n        _route(\n            Fee({asset: fee_.asset, amount: fee_.amount - protocolShare}),\n            _feeReceivers[getRouteId(edition_, tokenId_)],\n            payer_\n        );\n\n        uint256 referrerShare =\n            _splitProtocolFee(edition_, fee_.asset, protocolShare, payer_, referrer_);\n        emit FeeCollected(address(edition_), tokenId_, fee_.asset, fee_.amount, referrerShare);\n    }\n\n    function _splitProtocolFee(\n        IEdition edition_,\n        address asset_,\n        uint256 amount_,\n        address payer_,\n        address referrer_\n    ) internal returns (uint256 referrerShare) {\n        // The creation and mint referrers earn 25% and 50% of the protocol's share respectively, if applicable\n        uint256 mintReferrerShare = getMintReferrerShare(amount_, referrer_);\n        uint256 collectionReferrerShare = getCollectionReferrerShare(amount_, referrers[edition_]);\n        referrerShare = mintReferrerShare + collectionReferrerShare;\n\n        _route(\n            Fee({asset: asset_, amount: amount_ - referrerShare}),\n            Target({target: protocolFeeReceiver, chainId: block.chainid}),\n            payer_\n        );\n\n        _route(\n            Fee({asset: asset_, amount: mintReferrerShare}),\n            Target({target: referrer_, chainId: block.chainid}),\n            payer_\n        );\n\n        _route(\n            Fee({asset: asset_, amount: collectionReferrerShare}),\n            Target({target: referrer_, chainId: block.chainid}),\n            payer_\n        );\n    }\n\n    /// @notice Routes the given {Fee} to the appropriate receiver.\n    /// @param fee_ The {Fee} to route.\n    /// @param feeReceiver_ The {Target} to receive the fee.\n    /// @param feePayer_ The address of the account paying the fee.\n    /// @dev If the fee amount is zero, this function will return early. If the receiver is not on the same chain as the payer, this function will revert.\n    function _route(Fee memory fee_, Target memory feeReceiver_, address feePayer_) internal {\n        // Cross-chain fee routing is not supported yet\n        if (block.chainid != feeReceiver_.chainId) revert NotRoutable();\n        if (fee_.amount == 0) return;\n\n        _transfer(fee_.asset, fee_.amount, feePayer_, feeReceiver_.target);\n    }\n\n    /// @notice Transfers the given amount of the given asset from the sender to the receiver.\n    /// @param asset_ The address of the asset to transfer.\n    /// @param amount_ The amount of the asset to transfer.\n    /// @param from_ The address of the account sending the asset.\n    /// @param to_ The address of the account receiving the asset.\n    function _transfer(address asset_, uint256 amount_, address from_, address to_) internal {\n        if (asset_ == ETH_ADDRESS) {\n            to_.safeTransferETH(amount_);\n        } else {\n            asset_.safeTransferFrom(from_, to_, amount_);\n        }\n    }\n\n    /// @notice Builds the targets and shares arrays for a given creator and attributions.\n    /// @param creator The creator of the work.\n    /// @param attributions The attributions for the work.\n    /// @param revshareBps The revshare in basis points.\n    /// @return targets The array of targets.\n    /// @return shares The array of shares.\n    /// @dev Note that cross-chain payouts are not currently supported. Rather than reverting, this function assumes that the creator and attributions are on the same network.\n    function _buildSharesAndTargets(\n        Target memory creator,\n        Target[] memory attributions,\n        uint32 revshareBps\n    ) internal pure returns (address[] memory targets, uint256[] memory shares) {\n        uint32 attributionShares = uint32(attributions.length);\n        uint32 attributionRevShare = revshareBps * 100 / attributionShares;\n        uint32 creatorShare = 1e6 - (attributionRevShare * attributionShares);\n\n        // Build the targets and shares arrays using this layout:\n        // - targets: [creator, ...attributions]\n        // - shares: [creatorShare, ...attributionShares]\n        targets = new address[](attributionShares + 1);\n        shares = new uint256[](attributionShares + 1);\n\n        targets[0] = creator.target;\n        shares[0] = creatorShare;\n\n        for (uint8 i = 0; i < attributionShares; i++) {\n            targets[i + 1] = attributions[i].target;\n            shares[i + 1] = attributionRevShare;\n        }\n    }\n}"
    },
    {
      "filename": "wallflower-contract-v2/src/fees/FeeManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {LibZip} from \"solady/utils/LibZip.sol\";\nimport {OwnableRoles} from \"solady/auth/OwnableRoles.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {SplitFactoryV2} from \"splits-v2/splitters/SplitFactoryV2.sol\";\nimport {SplitV2Lib} from \"splits-v2/libraries/SplitV2.sol\";\n\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport \"src/shared/Common.sol\";\n\n/// @title Titles Fee Manager\n/// @notice Manages fees for the Titles Protocol\n/// @dev The FeeManager contract is responsible for collecting fees associated with protocol actions.\ncontract FeeManager is OwnableRoles {\n    using SafeTransferLib for address;\n    using LibZip for bytes;\n\n    /// @notice The payload for creating a {Strategy}.\n    /// @param edition The address of the {Edition} to be associated with the {Strategy}.\n    /// @param tokenId The ID of the token to be associated with the {Strategy}.\n    /// @param strategy The {Strategy} to be created.\n    struct StrategyPayload {\n        address edition;\n        uint256 tokenId;\n        Strategy strategy;\n    }\n\n    /////////////////////\n    // Events & Errors //\n    /////////////////////\n\n    /// @notice Emitted when a fee is collected.\n    /// @param edition The address of the edition for which the fee was collected.\n    /// @param work The ID of the work for which the fee was collected.\n    /// @param asset The address of the asset which was collected.\n    /// @param fee The amount of the fee collected.\n    /// @param referrerShare The portion of the collected fee which was paid to the referrer.\n    event FeeCollected(\n        address indexed edition, uint256 work, address asset, uint256 fee, uint256 referrerShare\n    );\n\n    /// @notice Emitted when the protocol fees are changed.\n    /// @param protocolFeeBps The new protocol fee in basis points.\n    /// @param protocolFlatFee The new protocol flat fee.\n    /// @param mintReferrerRevshareBps The new partner revenue share in basis points.\n    event ProtocolFeesChanged(\n        uint16 protocolFeeBps, uint128 protocolFlatFee, uint16 mintReferrerRevshareBps\n    );\n\n    /// @notice Thrown when an invalid fee configuration is supplied.\n    error InvalidFee();\n\n    /// @notice Thrown when a fee cannot be routed.\n    error NotRoutable();\n\n    ///////////////////\n    // Fee Constants //\n    ///////////////////\n\n    /// @dev The maximum basis points (BPS) value. Equivalent to 100%.\n    uint16 public constant MAX_BPS = 10_000;\n\n    /// @dev The maximum protocol fee in basis points (BPS). Equivalent to 33.33%.\n    uint16 public constant MAX_PROTOCOL_FEE_BPS = 3333;\n\n    /// @dev The maximum protocol fee in wei. Applies to both flat and percentage fees.\n    uint64 public constant MAX_PROTOCOL_FEE = 0.1 ether;\n\n    /// @dev The maximum royalty fee in basis points (BPS). Equivalent to 95%.\n    uint16 public constant MAX_ROYALTY_BPS = 9500;\n\n    /// @dev The minimum royalty fee in basis points (BPS). Equivalent to 2.5%.\n    uint16 public constant MIN_ROYALTY_BPS = 250;\n\n    ///////////////////////\n    // Fee Configuration //\n    ///////////////////////\n\n    /// @notice The protocol creation fee. This fee is collected when a new {Edition} is created.\n    uint128 public protocolCreationFee = 0.0001 ether;\n\n    /// @notice The flat fee for the protocol. This fee is collected on all mint transactions.\n    uint128 public protocolFlatFee = 0.0006 ether;\n\n    /// @notice The protocol fee share in basis points (BPS). Only applies to protocol fees collected for unpriced mints.\n    uint32 public protocolFeeshareBps = 3333;\n\n    /// @notice The share of protocol fees to be distributed to the direct re"
    }
  ]
}