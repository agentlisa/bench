{
  "Title": "[R-01] It's confusing that two different methods of determining owner are used",
  "Content": "\n[`ExecutorRegistry::registerExecutor`](https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/registries/ExecutorRegistry.sol#L40) and [`deRegisterExecutor`](https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/registries/ExecutorRegistry.sol#L55) uses two different methods of determining if `msg.sender` is the owner of the `subAccount`:\n\n```solidity\nFile: contracts/src/core/registries/ExecutorRegistry.sol\n\n40:        if (!_walletRegistry.isOwner(msg.sender, _subAccount)) revert NotOwnerWallet();\n\n55:        if (_walletRegistry.subAccountToWallet(_subAccount) != msg.sender) revert NotOwnerWallet();\n```\n\n[`WalletRegistry::isOwner`](https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/registries/WalletRegistry.sol#L73-L75) simply does the same check, `subAccountToWallet[_subAccount] == _wallet`.\n\nUsing two different methods is confusing.\n\n### Recommendation\n\nConsider using the same method in both calls.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/src/core/registries/ExecutorRegistry.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {AddressProviderService} from \"../AddressProviderService.sol\";\nimport {WalletRegistry} from \"./WalletRegistry.sol\";\nimport {EnumerableSet} from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * @title ExecutorRegistry\n * @author Brahma.fi\n * @notice Registry for executors for sub accounts\n */\ncontract ExecutorRegistry is AddressProviderService {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    error NotOwnerWallet();\n    error AlreadyExists();\n    error DoesNotExist();\n\n    event RegisterExecutor(address indexed _subAccount, address indexed _owner, address indexed _executor);\n    event DeRegisterExecutor(address indexed _subAccount, address indexed _owner, address indexed _executor);\n\n    /// @notice subAccount addresses mapped to executor addresses\n    mapping(address subAccount => EnumerableSet.AddressSet) private subAccountToExecutors;\n\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /**\n     * @notice Registers an executor for subaccount\n     * @dev Adds new executor if it doesn't already exists else reverts with AlreadyExists()\n     * @dev Can be only called by owner of subAccount\n     * @param _subAccount subAcc address to add executor to\n     * @param _executor executor to add\n     */\n    function registerExecutor(address _subAccount, address _executor) external {\n        WalletRegistry _walletRegistry = WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH));\n        if (!_walletRegistry.isOwner(msg.sender, _subAccount)) revert NotOwnerWallet();\n\n        if (!subAccountToExecutors[_subAccount].add(_executor)) revert AlreadyExists();\n        emit RegisterExecutor(_subAccount, msg.sender, _executor);\n    }\n\n    /**\n     * @notice De-registers an executor for subaccount\n     * @dev removes an executor if it exists else reverts with DoesNotExist()\n     * @dev Can be only called by owner of subAccount\n     * @param _subAccount subAcc address remove executor from\n     * @param _executor executor to remove\n     */\n    function deRegisterExecutor(address _subAccount, address _executor) external {\n        WalletRegistry _walletRegistry = WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH));\n        if (_walletRegistry.subAccountToWallet(_subAccount) != msg.sender) revert NotOwnerWallet();\n\n        if (!subAccountToExecutors[_subAccount].remove(_executor)) revert DoesNotExist();\n        emit DeRegisterExecutor(_subAccount, msg.sender, _executor);\n    }\n\n    /**\n     * @notice checks if _executor is registered for _subAccount\n     * @param _subAccount address of subAccount\n     * @param _executor address of executor\n     * @return isExecutorValid\n     */\n    function isExecutor(address _subAccount, address _executor) external view returns (bool) {\n        return subAccountToExecutors[_subAccount].contains(_executor);\n    }\n\n    /**\n     * @return all the executors for a subAccount\n     * @param _subAccount address of subAccount\n     */\n    function getExecutorsForSubAccount(address _subAccount) external view returns (address[] memory) {\n        return subAccountToExecutors[_subAccount].values();\n    }\n}"
    },
    {
      "filename": "contracts/src/core/registries/WalletRegistry.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {AddressProviderService} from \"../AddressProviderService.sol\";\n\n/**\n * @title WalletRegistry\n * @author Brahma.fi\n * @notice Registry for wallet and sub account addresses\n */\ncontract WalletRegistry is AddressProviderService {\n    error AlreadyRegistered();\n    error InvalidSender();\n    error IsSubAccount();\n\n    event RegisterWallet(address indexed wallet);\n    event RegisterSubAccount(address indexed wallet, address indexed subAccount);\n\n    /// @notice subAccount addresses mapped to owner wallet\n    mapping(address subAccount => address wallet) public subAccountToWallet;\n    /// @notice wallet addresses mapped to list of subAccounts\n    mapping(address wallet => address[] subAccountList) public walletToSubAccountList;\n    /// @notice address of wallet mapped to boolean indicating if it's a wallet\n    mapping(address => bool) public isWallet;\n\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /**\n     * @notice Registers a wallet\n     * @dev Can only be called by safe deployer or the wallet itself\n     */\n    function registerWallet() external {\n        if (isWallet[msg.sender]) revert AlreadyRegistered();\n        if (subAccountToWallet[msg.sender] != address(0)) revert IsSubAccount();\n        isWallet[msg.sender] = true;\n        emit RegisterWallet(msg.sender);\n    }\n\n    /**\n     * @notice Registers a sub account for a Safe\n     * @param _wallet Console account address, owner of sub account\n     * @param _subAccount Sub account address to register\n     * @dev Can only be called by safe deployer\n     */\n\n    function registerSubAccount(address _wallet, address _subAccount) external {\n        if (msg.sender != AddressProviderService._getAuthorizedAddress(_SAFE_DEPLOYER_HASH)) revert InvalidSender();\n        if (subAccountToWallet[_subAccount] != address(0)) revert AlreadyRegistered();\n        subAccountToWallet[_subAccount] = _wallet;\n        walletToSubAccountList[_wallet].push(_subAccount);\n        emit RegisterSubAccount(_wallet, _subAccount);\n    }\n\n    /**\n     * @notice sub account list getter\n     * @dev returns sub account list associated with _wallet\n     * @param _wallet safe address\n     * @return list of subAccounts for wallet\n     */\n    function getSubAccountsForWallet(address _wallet) external view returns (address[] memory) {\n        return walletToSubAccountList[_wallet];\n    }\n\n    /**\n     * @notice checks if _wallet owns _subAccount\n     * @param _wallet address of wallet\n     * @param _subAccount address of subAccount\n     * @return isWalletOwnerOfSubAccount\n     */\n    function isOwner(address _wallet, address _subAccount) external view returns (bool) {\n        return subAccountToWallet[_subAccount] == _wallet;\n    }\n}"
    }
  ]
}