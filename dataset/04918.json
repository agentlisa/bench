{
  "Title": "[L-14] One-off error when evaluating deposits to process with the ring buffer size",
  "Content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibDepositing.sol#L141)\n\nWhen calculating the deposits to process, we do not want to overwrite existing slots. This is why the last check/condition is implemented.\n\nThe issue with the condition is that it is one-off by the max size the ring bugger allows. Since + 1 is already added, make the check < into <= to work to it's full capacity. \n```solidity\nFile: LibDepositing.sol\n148:         unchecked {\n149:              \n150:             return\n151:                 _amount >= _config.ethDepositMinAmount &&\n152:                 _amount <= _config.ethDepositMaxAmount &&\n153:                 _state.slotA.numEthDeposits -\n154:                     _state.slotA.nextEthDepositToProcess <\n155:                 _config.ethDepositRingBufferSize - 1;   \n156:         }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L1/libs/LibDepositing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"../TaikoData.sol\";\n\n/// @title LibDepositing\n/// @notice A library for handling Ether deposits in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibDepositing {\n    using LibAddress for address;\n    using LibAddress for address payable;\n    using LibMath for uint256;\n\n    /// @notice Emitted when Ether is deposited.\n    /// @dev Any events defined here must also be defined in TaikoEvents.sol.\n    event EthDeposited(TaikoData.EthDeposit deposit);\n\n    /// @dev Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_INVALID_ETH_DEPOSIT();\n\n    /// @dev Deposits Ether to Layer 2.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _recipient The recipient address.\n    function depositEtherToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        address _recipient\n    )\n        internal\n    {\n        if (!canDepositEthToL2(_state, _config, msg.value)) {\n            revert L1_INVALID_ETH_DEPOSIT();\n        }\n\n        _resolver.resolve(\"bridge\", false).sendEther(msg.value);\n\n        // Append the deposit to the queue.\n        address recipient_ = _recipient == address(0) ? msg.sender : _recipient;\n        uint256 slot = _state.slotA.numEthDeposits % _config.ethDepositRingBufferSize;\n\n        // range of msg.value is checked by next line.\n        _state.ethDeposits[slot] = _encodeEthDeposit(recipient_, msg.value);\n\n        emit EthDeposited(\n            TaikoData.EthDeposit({\n                recipient: recipient_,\n                amount: uint96(msg.value),\n                id: _state.slotA.numEthDeposits\n            })\n        );\n\n        // Unchecked is safe:\n        // - uint64 can store up to ~1.8 * 1e19, which can represent 584K years\n        // if we are depositing at every second\n        unchecked {\n            _state.slotA.numEthDeposits++;\n        }\n    }\n\n    /// @dev Processes the ETH deposits in a batched manner.\n    function processDeposits(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        address _feeRecipient\n    )\n        internal\n        returns (TaikoData.EthDeposit[] memory deposits_)\n    {\n        // Calculate the number of pending deposits.\n        uint256 numPending = _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess;\n\n        if (numPending < _config.ethDepositMinCountPerBlock) {\n            deposits_ = new TaikoData.EthDeposit[](0);\n        } else {\n            deposits_ =\n                new TaikoData.EthDeposit[](numPending.min(_config.ethDepositMaxCountPerBlock));\n            uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));\n            uint64 j = _state.slotA.nextEthDepositToProcess;\n            uint96 totalFee;\n            for (uint256 i; i < deposits_.length;) {\n                uint256 data = _state.ethDeposits[j % _config.ethDepositRingBufferSize];\n                deposits_[i] = TaikoData.EthDeposit({\n                    recipient: address(uint160(data >> 96)),\n                    amount: uint96(data),\n                    id: j\n                });\n                uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;\n\n                // Unchecked is safe:\n                // - _fee cannot be bigger than deposits_[i].amount\n                // - all values are in the same range (uint96) except loop\n                // counter, which obviously cannot be bigger than uint95\n                // otherwise the function would be gassing out.\n                unchecked {\n                    deposits_[i].amount -= _fee;\n                    totalFee += _fee;\n                    ++i;\n                    ++j;\n                }\n            }\n            _state.slotA.nextEthDepositToProcess = j;\n            // This is the fee deposit\n            _state.ethDeposits[_state.slotA.numEthDeposits % _config.ethDepositRingBufferSize] =\n                _encodeEthDeposit(_feeRecipient, totalFee);\n\n            // Unchecked is safe:\n            // - uint64 can store up to ~1.8 * 1e19, which can represent 584K\n            // years if we are depositing at every second\n            unchecked {\n                _state.slotA.numEthDeposits++;\n            }\n        }\n    }\n\n    /// @dev Checks if Ether deposit is allowed for Layer 2.\n    function canDepositEthToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // Unchecked is safe:\n        // - both numEthDeposits and _state.slotA.nextEthDepositToProcess are\n        // indexes. One is tracking all deposits (numEthDeposits: unprocessed)\n        // and the next to be processed, so nextEthDepositToProcess cannot be\n        // bigger than numEthDeposits\n        // - ethDepositRingBufferSize cannot be 0 by default (validity checked\n        // in LibVerifying)\n        unchecked {\n            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount\n                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess\n                    < _config.ethDepositRingBufferSize - 1;\n        }\n    }\n\n    /// @dev Encodes the given deposit into a uint256.\n    /// @param _addr The address of the deposit recipient.\n    /// @param _amount The amount of the deposit.\n    /// @return The encoded deposit.\n    function _encodeEthDeposit(address _addr, uint256 _amount) private pure returns (uint256) {\n        if (_amount > type(uint96).max) revert L1_INVALID_ETH_DEPOSIT();\n        return (uint256(uint160(_addr)) << 96) | _amount;\n    }\n}"
    }
  ]
}