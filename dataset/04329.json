{
  "Title": "[L02] Misleading comments",
  "Content": "Some of the code comments could be clearer.  \n\n– In [line 85 of FixedPoint.sol](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/FixedPoint.sol#L85): `fixed point 18 number` should be `fixed point 18 mantissa` to be consistent with the convention used in the code base.  \n\n– In [line 106](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ExchangeRateTracker.sol#L106) and [line 119](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ExchangeRateTracker.sol#L119) of `ExchangeRateTracker.sol`: the phrase `in the past` should be `at the specified timestamp`.  \n\n– In [line 80](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L80) and [line 91](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L91) of `Pod.sol`: `burned` should be `redeemed`  \n\n– In [line 113 of Pod.sol](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L113): `debited` should be `credited`\n\n\n**Update:** *Fixed in [PR#6](https://github.com/pooltogether/pods/pull/6/). The comments were updated appropriately.*\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/FixedPoint.sol",
      "content": "/**\nCopyright 2020 PoolTogether Inc.\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\n/**\n * @author Brendan Asselstine\n * @notice Provides basic fixed point math calculations.\n *\n * This library calculates integer fractions by scaling values by 1e18 then performing standard integer math.\n */\nlibrary FixedPoint {\n  using SafeMath for uint256;\n\n  // The scale to use for fixed point numbers.  Same as Ether for simplicity.\n  uint256 public constant SCALE = 1e18;\n\n  /**\n   * A struct representing a fixed point 18 number (ie Ether).\n   */\n  struct Fixed18 {\n    uint256 mantissa;\n  }\n\n  /**\n   * Calculates a Fixed18 mantissa given the numerator and denominator\n   *\n   * The mantissa = (numerator * 1e18) / denominator\n   *\n   * @param numerator The mantissa numerator\n   * @param denominator The mantissa denominator\n   * @return The mantissa of the fraction\n   */\n  function calculateMantissa(uint256 numerator, uint256 denominator) public pure returns (uint256) {\n    uint256 mantissa = numerator.mul(SCALE);\n    mantissa = mantissa.div(denominator);\n    return mantissa;\n  }\n\n  /**\n   * Multiplies a Fixed18 number by an integer.\n   *\n   * @param f The Fixed18 number\n   * @param b The whole integer to multiply\n   * @return An integer that is the result of multiplying the params.\n   */\n  function multiplyUint(Fixed18 storage f, uint256 b) public view returns (uint256) {\n    uint256 result = f.mantissa.mul(b);\n    result = result.div(SCALE);\n    return result;\n  }\n\n  /**\n   * Divides an integer by a Fixed18 number.\n   *\n   * @param dividend The integer to divide\n   * @param divisor The Fixed18 number to act as the divisor\n   * @return An integer that is the result of dividing an integer by a Fixed18 number\n   */\n  function divideUintByFixed(uint256 dividend, Fixed18 storage divisor) public view returns (uint256) {\n    return divideUintByMantissa(dividend, divisor.mantissa);\n  }\n\n  /**\n   * Divides an integer by a fixed point 18 mantissa\n   *\n   * @param dividend The integer to divide\n   * @param mantissa The fixed point 18 number to serve as the divisor\n   * @return An integer that is the result of dividing an integer by a fixed point 18 mantissa\n   */\n  function divideUintByMantissa(uint256 dividend, uint256 mantissa) public pure returns (uint256) {\n    uint256 result = SCALE.mul(dividend);\n    result = result.div(mantissa);\n    return result;\n  }\n}"
    },
    {
      "filename": "contracts/ExchangeRateTracker.sol",
      "content": "/**\nCopyright 2020 PoolTogether Inc.\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"./FixedPoint.sol\";\n\n/**\n * @author Brendan Asselstine\n * @notice Tracks exchange rate history for a token and it's backing collateral.\n *\n * Users can query the historic exchange rate using a timestamp in O(log(n)) time.\n */\nlibrary ExchangeRateTracker {\n\n  /**\n   * The struct for a single exchange rate in time\n   */\n  struct ExchangeRate {\n    uint256 timestamp;\n    FixedPoint.Fixed18 exchangeRate;\n  }\n\n  /**\n   * The struct that contains the complete history of rates.  This library should be attached to this struct.\n   */\n  struct State {\n    ExchangeRate[] exchangeRates;\n  }\n\n  /**\n   * Initializes the data structure.\n   *\n   * @param self The State struct\n   * @param baseExchangeRateMantissa The starting exchange rate for the token\n   */\n  function initialize(State storage self, uint256 baseExchangeRateMantissa) internal {\n    require(baseExchangeRateMantissa > 0, \"ExchangeRateTracker/non-zero\");\n    self.exchangeRates.length = 0;\n    self.exchangeRates.push(ExchangeRate(0, FixedPoint.Fixed18(baseExchangeRateMantissa)));\n  }\n\n  /**\n   * Add a new exchange rate to the history.\n   *\n   * The exchange rate is added by declaring the token supply, amount of collateral and timestamp.\n   * The timestamp must be strictly greater than or equal to the last timestamp to ensure correct ordering.\n   *\n   * @param self The State struct\n   * @param tokens The new token supply\n   * @param collateral The amount of backing collateral\n   * @param timestamp The time at which the change occurred\n   * @return The new exchange rate mantissa\n   */\n  function collateralizationChanged(\n    State storage self,\n    uint256 tokens,\n    uint256 collateral,\n    uint256 timestamp\n  ) internal returns (uint256) {\n    wasInitialized(self);\n    require(self.exchangeRates[self.exchangeRates.length - 1].timestamp <= timestamp, \"ExchangeRateTracker/too-early\");\n    FixedPoint.Fixed18 memory rate = FixedPoint.Fixed18(FixedPoint.calculateMantissa(tokens, collateral));\n    self.exchangeRates.push(ExchangeRate(timestamp, rate));\n    return rate.mantissa;\n  }\n\n  /**\n   * Calculates the current collateral value of the given token amount.\n   *\n   * @param self The State struct\n   * @param tokens The token amount\n   * @return The collateral value of the tokens\n   */\n  function tokenToCollateralValue(State storage self, uint256 tokens) internal view returns (uint256) {\n    return FixedPoint.divideUintByFixed(tokens, currentExchangeRate(self));\n  }\n\n  /**\n   * Calculates the current token value of the given collateral amount\n   *\n   * @param self The State struct\n   * @param collateral The collateral amount\n   * @return The token value of the collateral\n   */\n  function collateralToTokenValue(State storage self, uint256 collateral) internal view returns (uint256) {\n    return FixedPoint.multiplyUint(currentExchangeRate(self), collateral);\n  }\n\n  /**\n   * Calculates the collateral value of the given token amount in the past.\n   *\n   * @param self The State struct\n   * @param tokens The token amount\n   * @param timestamp The timestamp of the rate to use for conversion\n   * @return The collateral value of the given tokens at the given timestamp\n   */\n  function tokenToCollateralValueAt(State storage self, uint256 tokens, uint256 timestamp) internal view returns (uint256) {\n    uint256 exchangeRateIndex = search(self, timestamp);\n    return FixedPoint.divideUintByFixed(tokens, self.exchangeRates[exchangeRateIndex].exchangeRate);\n  }\n\n  /**\n   * Calculates the token value of the given collateral amount in the past.\n   *\n   * @param self The State struct\n   * @param collateral The collateral amount\n   * @param timestamp The timestamp of the rate to use for conversion\n   * @return The token value of the given collateral at the given timestamp\n   */\n  function collateralToTokenValueAt(State storage self, uint256 collateral, uint256 timestamp) internal view returns (uint256) {\n    uint256 exchangeRateIndex = search(self, timestamp);\n    return FixedPoint.multiplyUint(self.exchangeRates[exchangeRateIndex].exchangeRate, collateral);\n  }\n\n  /**\n   * Returns the current exchange rate mantissa as a fixed point 18 number (ie Ether).\n   *\n   * For example, an exchange rate of 0.5 would be represented as 500000000000000000\n   *\n   * @param self The State struct\n   * @return The current exchange rate mantissa\n   */\n  function currentExchangeRateMantissa(State storage self) internal view returns (uint256) {\n     wasInitialized(self);\n    return self.exchangeRates[self.exchangeRates.length - 1].exchangeRate.mantissa;\n  }\n\n  /**\n   * Returns the current exchange rate as a FixedPoint.Fixed18 struct\n   *\n   * @param self The State struct\n   * @return The current exchange rate as a FixedPoint.Fixed18 struct\n   */\n  function currentExchangeRate(State storage self) internal view returns (FixedPoint.Fixed18 storage) {\n    wasInitialized(self);\n    return self.exchangeRates[self.exchangeRates.length - 1].exchangeRate;\n  }\n\n  /**\n   * Searches for the historic exchange rate at the given timestamp.\n   *\n   * The algorithm will return the index of the *last* exchange rate whose timestamp is less than or equal to the given timestamp.\n   *\n   * @param self The State struct\n   * @param timestamp The timestamp to search for\n   * @return The index of the exchange rate that was in effect at the given timestamp\n   */\n  function search(State storage self, uint256 timestamp) internal view returns (uint256) {\n    wasInitialized(self);\n\n    uint256 lowerBound = 0;\n    uint256 upperBound = self.exchangeRates.length;\n\n    while (lowerBound < upperBound - 1) {\n        uint256 midPoint = lowerBound + (upperBound - lowerBound) / 2;\n\n        if (timestamp < self.exchangeRates[midPoint].timestamp) {\n          upperBound = midPoint;\n        } else {\n          lowerBound = midPoint;\n        }\n    }\n\n    return upperBound - 1;\n  }\n\n  function wasInitialized(State storage self) internal view {\n    require(self.exchangeRates.length > 0, \"ExchangeRateTracker/not-init\");\n  }\n}"
    },
    {
      "filename": "contracts/Pod.sol",
      "content": "/**\nCopyright 2020 PoolTogether Inc.\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC777/ERC777.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@kleros/kleros/contracts/data-structures/SortitionSumTreeFactory.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/UniformRandomNumber.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/MCDAwarePool.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/IRewardListener.sol\";\n\nimport \"./ScheduledBalance.sol\";\nimport \"./ExchangeRateTracker.sol\";\n\n/**\n * @title PoolTogether Pod\n * @author Brendan Asselstine\n * @notice Allows users to own shares in pooled tickets for a PoolTogether Pool\n *\n * Designed to be bound to the PoolTogether Pool that support RewardListeners.\n *\n * A RewardListener is a contract that is registered to be the reward listener for an address using the ERC 1820 registry.\n *\n * When the Pool picks a winner, the Pool will look for a registered RewardListener.  If one exists, it calls `rewarded`\n * on the listener with a stipend of 200000 gas.\n *\n * In this way the Pod is able to track historic exchange rates.\n */\ncontract Pod is ERC777, ReentrancyGuard, IERC777Recipient, IRewardListener {\n  using ScheduledBalance for ScheduledBalance.State;\n  using ExchangeRateTracker for ExchangeRateTracker.State;\n\n  /// @notice The initial exchange rate for shares.  Starts high as the shares perpetually deflate.\n  uint256 internal constant BASE_EXCHANGE_RATE_MANTISSA = 1e24;\n\n  /// @notice keccak256(\"PoolTogetherRewardListener\")\n  bytes32 constant internal REWARD_LISTENER_INTERFACE_HASH =\n      0x68f03b0b1a978ee238a70b362091d993343460bc1a2830ab3f708936d9f564a4;\n\n  /// @notice keccak256(\"ERC777TokensRecipient\")\n  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\n      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n  /// @notice A reference to interact with the ERC1820 registry\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  /**\n   * @notice Event emitted when a user withdraws their pending deposit\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param collateral The amount of collateral being withdrawn\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event PendingDepositWithdrawn(address indexed operator, address indexed from, uint256 collateral, bytes data, bytes operatorData);\n\n  /**\n   * @notice Event emitted when a user or operator redeems tokens into the backing collateral\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param amount The amount of Pod shares burned\n   * @param collateral The amount of collateral that was returned\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event Redeemed(address indexed operator, address indexed from, uint256 amount, uint256 collateral, bytes data, bytes operatorData);\n\n  /**\n   * @notice Event emitted when a user or operator redeems tokens into Pool tickets\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param amount The amount of Pod shares burned\n   * @param collateral The amount of Pool tickets redeemed.\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event RedeemedToPool(address indexed operator, address indexed from, uint256 amount, uint256 collateral, bytes data, bytes operatorData);\n\n  /**\n   * @notice Event emitted when the collateralization of the Pod shares changes.\n   * @param timestamp The timestamp at which the collateralization changed\n   * @param tokens The new token supply\n   * @param collateral The new collateral amount\n   * @param mantissa The new exchange rate mantissa\n   */\n  event CollateralizationChanged(uint256 indexed timestamp, uint256 tokens, uint256 collateral, uint256 mantissa);\n\n  /**\n   * @notice Event emitted when a user or operator deposits collateral for Pod shares\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that will be credited with Pod shares\n   * @param collateral The amount of collateral deposited\n   * @param drawId The open draw id in which the account deposited\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event Deposited(address indexed operator, address indexed from, uint256 collateral, uint256 drawId, bytes data, bytes operatorData);\n\n  /// @notice Tracks the consolidated and unconsolidated supply of tokens\n  ScheduledBalance.State internal scheduledSupply;\n\n  /// @notice Tracks the consolidated and unconsolidated balances of tokens per user\n  mapping(address => ScheduledBalance.State) internal scheduledBalances;\n\n  /// @notice Tracks the historic exchange rate\n  ExchangeRateTracker.State internal exchangeRateTracker;\n\n  /// @notice The PoolTogether Pool that this Pod is bound to\n  MCDAwarePool public pool;\n\n  /**\n   * @notice Initializes the Pod.\n   * @param _pool The Pool to bind this Pod to.\n   */\n  function initialize(\n    MCDAwarePool _pool\n  ) public initializer {\n    require(address(_pool) != address(0), \"Pod/pool-def\");\n    exchangeRateTracker.initialize(BASE_EXCHANGE_RATE_MANTISSA);\n    pool = _pool;\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), REWARD_LISTENER_INTERFACE_HASH, address(this));\n  }\n\n  /**\n   * @notice Deposits on behalf of a user by an operator.  The deposit will become Pod shares upon the next Pool reward.\n   * @param user The user on whose behalf to deposit\n   * @param amount The amount of collateral to deposit\n   * @param data Included user data\n   * @param operatorData Included operator data\n   */\n  function operatorDeposit(address user, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n    _deposit(msg.sender, user, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Deposits into the Pod. The deposit will become Pod shares upon the next Pool reward.\n   * @param amount The amount of collateral to deposit\n   * @param data Included user data\n   */\n  function deposit(uint256 amount, bytes calldata data) external {\n    _deposit(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n   * @notice Deposits on behalf of a user by an operator.  The operator may also be the user. The deposit will become Pod shares upon the next Pool reward.\n   * @param operator The operator who kicked of the deposit\n   * @param from The user on whose half to deposit\n   * @param amount The amount of collateral to deposit\n   * @param data Included user data\n   * @param operatorData Included operator data\n   */\n  function _deposit(\n    address operator,\n    address from,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) internal nonReentrant {\n    consolidateBalanceOf(from);\n    pool.token().transferFrom(operator, address(this), amount);\n    pool.token().approve(address(pool), amount);\n    pool.depositPool(amount);\n    uint256 openDrawId = pool.currentOpenDrawId();\n    scheduledSupply.deposit(amount, openDrawId);\n    scheduledBalances[from].deposit(amount, openDrawId);\n    emit Deposited(operator, from, amount, openDrawId, data, operatorData);\n  }\n\n  /**\n   * @notice IERC777Recipient callback to handle direct Pool token transfers. When users transfer their Pool tickets to this contract they will be instantly converted into Pod shares.\n   * @param from The user whose tickets are being transferred\n   * @param amount The number of tickets being transferred\n   */\n  function tokensReceived(\n    address,\n    address from,\n    address, // to address can't be anything but us because we don't implement ERC1820ImplementerInterface\n    uint256 amount,\n    bytes calldata,\n    bytes calldata\n  ) external {\n    // if this is a transfer of pool tickets\n    if (msg.sender == address(pool.poolToken())) {\n      // convert to shares\n      consolidateBalanceOf(from);\n      uint256 tokens = exchangeRateTracker.collateralToTokenValue(amount);\n      _mint(address(this), from, tokens, \"\", \"\");\n    } else {\n      // The only other allowed token is itself and the asset\n      require(msg.sender == address(this) || msg.sender == address(pool.token()), \"Pod/unknown-token\");\n    }\n  }\n\n  /**\n   * @notice Returns the collateral value of the given users tokens. If the user does not have any tokens, this will be zero.  Pending deposits are not included.\n   * @param user The user whose balance should be checked\n   * @return The collateral value of the tokens held by the user.\n   */\n  function balanceOfUnderlying(address user) public view returns (uint256) {\n    return exchangeRateTracker.tokenToCollateralValue(balanceOf(user));\n  }\n\n  /**\n   * @notice Returns the number of tokens held by the given user.  Does not include pending deposits.\n   * @param tokenHolder The user whose balance should be checked\n   * @return The users total balance of tokens.\n   */\n  function balanceOf(address tokenHolder) public view returns (uint256) {\n    (uint256 balance, uint256 drawId) = scheduledBalances[tokenHolder].consolidatedBalanceInfo(pool.currentOpenDrawId());\n    return super.balanceOf(tokenHolder).add(\n      exchangeRateTracker.collateralToTokenValueAt(\n        balance,\n        drawId\n      )\n    );\n  }\n\n  /**\n   * @notice Returns the amount of collateral a user has deposited that is pending conversion to tokens.\n   * @param user The user whose pending collateral balance should be returned.\n   * @return The amount of collateral the user has deposited that has not converted to tokens.\n   */\n  function pendingDeposit(address user) public view returns (uint256) {\n    return scheduledBalances[user].unconsolidatedBalance(pool.currentOpenDrawId());\n  }\n\n  /**\n   * @notice Allows an operator to withdraw a user's pending deposit on their behalf\n   * @param from The user on whose behalf to withdraw\n   * @param amount The amount to withdraw\n   * @param data Data included by the user\n   * @param operatorData Data included by the operator\n   */\n  function operatorWithdrawPendingDeposit(\n    address from,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external {\n    require(isOperatorFor(msg.sender, from), \"Pod/not-op\");\n    _withdrawPendingDeposit(msg.sender, from, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Allows a user to withdraw their pending deposit\n   * @param amount The amount the user wishes to withdraw\n   * @param data Data included by the user\n   */\n  function withdrawPendingDeposit(\n    uint256 amount,\n    bytes calldata data\n  ) external {\n    _withdrawPendingDeposit(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n   * @notice Withdraw from a user's pending deposit\n   * @param operator The operator conducting the withdrawal\n   * @param from The user whose deposit will be withdrawn\n   * @param amount The amount to withdraw\n   * @param data Data included by the user\n   * @param operatorData Data included by the operator\n   */\n  function _withdrawPendingDeposit(\n    address operator,\n    address from,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) internal {\n    uint256 openDrawId = pool.currentOpenDrawId();\n    scheduledBalances[from].withdrawUnconsolidated(amount, openDrawId);\n    pool.withdrawOpenDeposit(amount);\n    pool.token().transfer(from, amount);\n\n    emit PendingDepositWithdrawn(operator, from, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Returns the total supply of tokens.  Does not included any pending deposits.\n   * @return The total supply of tokens.\n   */\n  function totalSupply() public view returns (uint256) {\n    (uint256 balance, uint256 drawId) = scheduledSupply.consolidatedBalanceInfo(pool.currentOpenDrawId());\n    return super.totalSupply().add(\n      exchangeRateTracker.collateralToTokenValueAt(\n        balance,\n        drawId\n      )\n    );\n  }\n\n  /**\n    * @dev See {IERC777-operatorBurn}.\n    *\n    * This contract does not support burning.  Redeem must be called.\n    */\n  function operatorBurn(address, uint256, bytes memory, bytes memory) public {\n    revert(\"Pod/no-op\");\n  }\n\n  /**\n    * @dev See {IERC777-burn}.\n    *\n    * This contract does not support burning.  Redeem must be called.\n    */\n  function burn(uint256, bytes memory) public {\n    revert(\"Pod/no-op\");\n  }\n\n  /**\n   * @dev PoolTogetherRewardListener callback that is triggered by the Pool when this Pod wins.\n   * @param winnings The amount of collateral won in the prize\n   * @param drawId The prize id that was won\n   */\n  function rewarded(address, uint256 winnings, uint256 drawId) external nonReentrant {\n    require(msg.sender == address(pool), \"Pod/only-pool\");\n    uint256 tokens = totalSupply();\n    uint256 collateral = exchangeRateTracker.tokenToCollateralValue(tokens).add(winnings);\n    uint256 mantissa = exchangeRateTracker.collateralizationChanged(tokens, collateral, drawId.add(1));\n    emit CollateralizationChanged(drawId, tokens, collateral, mantissa);\n  }\n\n  /**\n   * @notice Returns the mantissa of the current exchange rate.\n   * @return The current exchange rate mantissa.\n   */\n  function currentExchangeRateMantissa() external view returns (uint256) {\n    return exchangeRateTracker.currentExchangeRateMantissa();\n  }\n\n  /**\n   * @notice Allows an operator to redeem tokens for collateral on behalf of a user.\n   * @param account The user who is redeeming tokens\n   * @param amount The amount of tokens to convert to collateral\n   * @param data User data included with the tx\n   * @param operatorData Operator data included with the tx\n   */\n  function operatorRedeem(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n    require(isOperatorFor(msg.sender, account), \"Pod/not-op\");\n    _redeem(msg.sender, account, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Allows a user to redeem tokens for collateral.\n   * @param amount The amount of tokens to convert to collateral\n   * @param data User data included with the tx\n   */\n  function redeem(uint256 amount, bytes calldata data) external {\n    _redeem(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n    * @notice Redeems tokens for the underlying asset.\n    * @param operator address operator requesting the operation\n    * @param from address token holder address\n    * @param amount uint256 amount of tokens to redeem\n    * @param data bytes extra information provided by the token holder\n    * @param operatorData bytes extra information provided by the operator (if any)\n    */\n  function _redeem(\n      address operator,\n      address from,\n      uint256 amount,\n      bytes memory data,\n      bytes memory operatorData\n  )\n      internal nonReentrant\n  {\n      consolidateBalanceOf(from);\n      uint256 collateral = exchangeRateTracker.tokenToCollateralValue(amount);\n      pool.withdrawCommittedDeposit(collateral);\n      pool.token().transfer(from, collateral);\n      emit Redeemed(operator, from, amount, collateral, data, operatorData);\n      _burn(operator, from, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Allows an operator to redeem tokens for Pool tickets on behalf of a user.\n   * @param account The user who is redeeming tokens\n   * @param amount The amount of tokens to convert to Pool tickets\n   * @param data User data included with the tx\n   * @param operatorData Operator data included with the tx\n   */\n  function operatorRedeemToPool(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n    require(isOperatorFor(msg.sender, account), \"Pod/not-op\");\n    _redeemToPool(msg.sender, account, amount, data, operatorData);\n  }\n\n  /**\n   * @notice Allows a user to redeem tokens for Pool tickets\n   * @param amount The amount of tokens to convert to Pool tickets\n   * @param data User data included with the tx\n   */\n  function redeemToPool(uint256 amount, bytes calldata data) external {\n    _redeemToPool(msg.sender, msg.sender, amount, data, \"\");\n  }\n\n  /**\n   * @notice Allows an operator to redeem tokens for Pool tickets on behalf of a user.\n   * @param operator The operator who is running the tx\n   * @param from The user who is redeeming tokens\n   * @param amount The amount of tokens to convert to Pool tickets\n   * @param data User data included with the tx\n   * @param operatorData Operator data included with the tx\n   */\n  function _redeemToPool(\n    address operator,\n    address from,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) internal nonReentrant {\n    consolidateBalanceOf(from);\n    uint256 collateral = exchangeRateTracker.tokenToCollateralValue(amount);\n    pool.poolToken().transfer(from, collateral);\n    emit RedeemedToPool(operator, from, amount, collateral, data, operatorData);\n    _burn(operator, from, amount, data, operatorData);\n  }\n\n  /**\n   * @dev Mints tokens to the Pod using any consolidated supply, then zeroes out the supply.\n   */\n  function consolidateSupply() internal {\n    uint256 openDrawId = pool.currentOpenDrawId();\n    (uint256 balance, uint256 drawId) = scheduledSupply.consolidatedBalanceInfo(openDrawId);\n    uint256 tokens = exchangeRateTracker.collateralToTokenValueAt(balance, drawId);\n    if (tokens > 0) {\n      scheduledSupply.clearConsolidated(openDrawId);\n      _mint(address(this), address(this), tokens, \"\", \"\");\n    }\n  }\n\n  /**\n   * @dev First calls `consolidateSupply()`, then transfers tokens from the Pod to the user based\n   * on the users consolidated supply.  Finally, it zeroes out the users consolidated supply.\n   * @param user The user whose balance should be consolidated.\n   */\n  function consolidateBalanceOf(address user) internal {\n    consolidateSupply();\n    uint256 openDrawId = pool.currentOpenDrawId();\n    (uint256 balance, uint256 drawId) = scheduledBalances[user].consolidatedBalanceInfo(openDrawId);\n    uint256 tokens = exchangeRateTracker.collateralToTokenValueAt(balance, drawId);\n    if (tokens > 0) {\n      scheduledBalances[user].clearConsolidated(openDrawId);\n      _send(address(this), address(this), user, tokens, \"\", \"\", true);\n    }\n  }\n}"
    },
    {
      "filename": "contracts/Pod.sol",
      "content": "/**\nCopyright 2020 PoolTogether Inc.\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC777/ERC777.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@kleros/kleros/contracts/data-structures/SortitionSumTreeFactory.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/UniformRandomNumber.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/MCDAwarePool.sol\";\nimport \"@pooltogether/pooltogether-contracts/contracts/IRewardListener.sol\";\n\nimport \"./ScheduledBalance.sol\";\nimport \"./ExchangeRateTracker.sol\";\n\n/**\n * @title PoolTogether Pod\n * @author Brendan Asselstine\n * @notice Allows users to own shares in pooled tickets for a PoolTogether Pool\n *\n * Designed to be bound to the PoolTogether Pool that support RewardListeners.\n *\n * A RewardListener is a contract that is registered to be the reward listener for an address using the ERC 1820 registry.\n *\n * When the Pool picks a winner, the Pool will look for a registered RewardListener.  If one exists, it calls `rewarded`\n * on the listener with a stipend of 200000 gas.\n *\n * In this way the Pod is able to track historic exchange rates.\n */\ncontract Pod is ERC777, ReentrancyGuard, IERC777Recipient, IRewardListener {\n  using ScheduledBalance for ScheduledBalance.State;\n  using ExchangeRateTracker for ExchangeRateTracker.State;\n\n  /// @notice The initial exchange rate for shares.  Starts high as the shares perpetually deflate.\n  uint256 internal constant BASE_EXCHANGE_RATE_MANTISSA = 1e24;\n\n  /// @notice keccak256(\"PoolTogetherRewardListener\")\n  bytes32 constant internal REWARD_LISTENER_INTERFACE_HASH =\n      0x68f03b0b1a978ee238a70b362091d993343460bc1a2830ab3f708936d9f564a4;\n\n  /// @notice keccak256(\"ERC777TokensRecipient\")\n  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\n      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n  /// @notice A reference to interact with the ERC1820 registry\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  /**\n   * @notice Event emitted when a user withdraws their pending deposit\n   * @param operator The operator who kicked off the transaction\n   * @param from The account that is being debited\n   * @param collateral The amount of collateral being withdrawn\n   * @param data Data the debited account included in the tx\n   * @param operatorData Data the operator included in the tx\n   */\n  event PendingDepositWithdrawn(address indexed operator, address indexed from, uint256 collateral, bytes dat"
    }
  ]
}