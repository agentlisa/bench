{
  "Title": "[G-01] Structs can be packed into fewer storage slots",
  "Content": "\n### Saves `6000 GAS`, `3 SLOT`\n\nEach slot saved can avoid an extra Gsset (20000 gas) for the first setting of the struct.\n\nSubsequent reads as well as writes have smaller gas savings.\n\n### `expiry` can be uint96 instead of `uint256` :  Saves `2000 GAS`, `1 SLOT`\n\nhttps://github.com/code-423n4/2023-09-delegate/blob/a6dbac8068760ee4fc5bababb57e3fe79e5eeb2e/src/libraries/DelegateTokenLib.sol#L20-L29\n\nA `uint96` can store values from `0 to 2^96 - 1`, which is a very large range. However, it's important to note that Ethereum's `block.timestamp` is a `Unix timestamp`, which represents time in seconds.\n\nA `uint96` would overflow after approximately `2,508,149,904,626,209 years` when storing time in seconds.  This is an extremely long time frame, and it's highly unlikely that Ethereum or any blockchain system will remain unchanged for such an extended period.\n\n```diff\nFILE: 2023-09-delegate/src/libraries/DelegateTokenLib.sol\n\n20: struct DelegateInfo {\n21:        address principalHolder;\n22:        IDelegateRegistry.DelegationType tokenType;\n23:        address delegateHolder;\n24:        uint256 amount;\n25:        address tokenContract;\n+ 28:        uint96 expiry;\n26:        uint256 tokenId;\n27:        bytes32 rights;\n- 28:        uint256 expiry;\n29:    }\n```\n\n### `signerSalt`, `expiryLength` can be `uint128` instead of `uint256` : Saves `4000 GAS`, `2 SLOT`\n\nhttps://github.com/code-423n4/2023-09-delegate/blob/a6dbac8068760ee4fc5bababb57e3fe79e5eeb2e/src/libraries/CreateOffererLib.sol#L89-L105\n\nIn many blockchain protocols, the usage of `salt` often involves values within the range of `uint32`, as they provide a sufficient numeric space for generating unique salts. Therefore, adopting a uint32 data type for the signerSalt field is a reasonable choice, as it aligns with common practices and conserves storage resources.\n\nFor the `expiryLength` field, which is intended to store the `duration` or `length` of an `expiration period`, using `uint128` is more than adequate. This choice allows for a vast range of possible expiration lengths, accommodating a wide spectrum of use cases without incurring unnecessary storage overhead\n\n```diff\nFILE: 2023-09-delegate/src/libraries/CreateOffererLib.sol\n\n89: struct Context {\n90:        bytes32 rights;\n+ 91:        uint128 signerSalt;\n+ 92:        uint128 expiryLength;\n- 91:        uint256 signerSalt;\n- 92:        uint256 expiryLength;\n93:        CreateOffererEnums.ExpiryType expiryType;\n94:        CreateOffererEnums.TargetToken targetToken;\n95:    }\n\n\n98: struct Order {\n99:        bytes32 rights;\n- 100:        uint256 expiryLength;\n- 101:        uint256 signerSalt;\n+ 100:        uint128 expiryLength;\n+ 101:        uint128 signerSalt;\n102:        address tokenContract;\n103:        CreateOffererEnums.ExpiryType expiryType;\n104:        CreateOffererEnums.TargetToken targetToken;\n105:    }\n\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-09-delegate",
  "Code": [
    {
      "filename": "src/libraries/DelegateTokenLib.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\nimport {IDelegateRegistry} from \"delegate-registry/src/IDelegateRegistry.sol\";\nimport {IDelegateFlashloan} from \"src/interfaces/IDelegateFlashloan.sol\";\nimport {IERC721Receiver} from \"openzeppelin/token/ERC721/IERC721Receiver.sol\";\n\nlibrary DelegateTokenStructs {\n    struct Uint256 {\n        uint256 flag;\n    }\n\n    struct DelegateTokenParameters {\n        address delegateRegistry;\n        address principalToken;\n        address marketMetadata;\n    }\n\n    /// @notice Struct for creating delegate tokens and returning their information\n    struct DelegateInfo {\n        address principalHolder;\n        IDelegateRegistry.DelegationType tokenType;\n        address delegateHolder;\n        uint256 amount;\n        address tokenContract;\n        uint256 tokenId;\n        bytes32 rights;\n        uint256 expiry;\n    }\n\n    struct FlashInfo {\n        address receiver; // The address to receive the loaned assets\n        address delegateHolder; // The holder of the delegation\n        IDelegateRegistry.DelegationType tokenType; // The type of contract, e.g. ERC20\n        address tokenContract; // The contract of the underlying being loaned\n        uint256 tokenId; // The tokenId of the underlying being loaned, if applicable\n        uint256 amount; // The amount being lent, if applicable\n        bytes data; // Arbitrary data structure, intended to contain user-defined parameters\n    }\n}\n\nlibrary DelegateTokenErrors {\n    error DelegateRegistryZero();\n    error PrincipalTokenZero();\n    error DelegateTokenHolderZero();\n    error MarketMetadataZero();\n    error ToIsZero();\n\n    error NotERC721Receiver();\n    error InvalidERC721TransferOperator();\n    error ERC1155PullNotRequested(address operator);\n    error BatchERC1155TransferUnsupported();\n\n    error InsufficientAllowanceOrInvalidToken();\n    error CallerNotOwnerOrInvalidToken();\n\n    error NotOperator(address caller, address account);\n    error NotApproved(address caller, uint256 delegateTokenId);\n\n    error FromNotDelegateTokenHolder();\n\n    error HashMismatch();\n\n    error NotMinted(uint256 delegateTokenId);\n    error AlreadyExisted(uint256 delegateTokenId);\n    error WithdrawNotAvailable(uint256 delegateTokenId, uint256 expiry, uint256 timestamp);\n\n    error ExpiryInPast();\n    error ExpiryTooLarge();\n    error ExpiryTooSmall();\n\n    error WrongAmountForType(IDelegateRegistry.DelegationType tokenType, uint256 wrongAmount);\n    error WrongTokenIdForType(IDelegateRegistry.DelegationType tokenType, uint256 wrongTokenId);\n    error InvalidTokenType(IDelegateRegistry.DelegationType tokenType);\n\n    error ERC721FlashUnavailable();\n    error ERC20FlashAmountUnavailable();\n    error ERC1155FlashAmountUnavailable();\n\n    error BurnNotAuthorized();\n    error MintNotAuthorized();\n    error CallerNotPrincipalToken();\n    error BurnAuthorized();\n    error MintAuthorized();\n\n    error ERC1155Pulled();\n    error ERC1155NotPulled();\n}\n\nlibrary DelegateTokenHelpers {\n    function revertOnCallingInvalidFlashloan(DelegateTokenStructs.FlashInfo calldata info) internal {\n        if (IDelegateFlashloan(info.receiver).onFlashloan{value: msg.value}(msg.sender, info) == IDelegateFlashloan.onFlashloan.selector) return;\n        revert IDelegateFlashloan.InvalidFlashloan();\n    }\n\n    function revertOnInvalidERC721ReceiverCallback(address from, address to, uint256 delegateTokenId, bytes calldata data) internal {\n        if (to.code.length == 0 || IERC721Receiver(to).onERC721Received(msg.sender, from, delegateTokenId, data) == IERC721Receiver.onERC721Received.selector) return;\n        revert DelegateTokenErrors.NotERC721Receiver();\n    }\n\n    function revertOnInvalidERC721ReceiverCallback(address from, address to, uint256 delegateTokenId) internal {\n        if (to.code.length == 0 || IERC721Receiver(to).onERC721Received(msg.sender, from, delegateTokenId, \"\") == IERC721Receiver.onERC721Received.selector) return;\n        revert DelegateTokenErrors.NotERC721Receiver();\n    }\n\n    /// @dev won't revert if expiry is too large (i.e. > type(uint96).max)\n    function revertOldExpiry(uint256 expiry) internal view {\n        //slither-disable-next-line timestamp\n        if (expiry > block.timestamp) return;\n        revert DelegateTokenErrors.ExpiryInPast();\n    }\n\n    function delegateIdNoRevert(address caller, uint256 salt) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encode(caller, salt)));\n    }\n}"
    },
    {
      "filename": "src/libraries/CreateOffererLib.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\nimport {SpentItem, ReceivedItem} from \"seaport/contracts/interfaces/ContractOffererInterface.sol\";\nimport {ItemType} from \"seaport/contracts/lib/ConsiderationEnums.sol\";\nimport {IDelegateToken, Structs as IDelegateTokenStructs} from \"src/interfaces/IDelegateToken.sol\";\nimport {RegistryHashes} from \"delegate-registry/src/libraries/RegistryHashes.sol\";\nimport {IDelegateRegistry, DelegateTokenHelpers} from \"src/libraries/DelegateTokenLib.sol\";\n\nlibrary CreateOffererErrors {\n    error DelegateTokenIsZero();\n    error PrincipalTokenIsZero();\n    error InvalidTokenType(IDelegateRegistry.DelegationType invalidType);\n    error NoBatchWrapping();\n    error InvalidExpiryType(CreateOffererEnums.ExpiryType invalidType);\n    error SeaportIsZero();\n    error Locked();\n    error WrongStage(CreateOffererEnums.Stage expected, CreateOffererEnums.Stage actual);\n    error CallerNotSeaport(address caller);\n    error DelegateTokenIdInvariant(uint256 requested, uint256 actual);\n    error CreateOrderHashInvariant(uint256 requested, uint256 actual);\n    error MinimumReceivedInvalid(SpentItem minimumReceived);\n    error MaximumSpentInvalid(SpentItem maximumSpent);\n    error FromNotCreateOfferer(address from);\n    error ERC20ApproveFailed(address tokenAddress);\n    error ERC20AllowanceInvariant(address tokenAddress);\n    error InvalidContractNonce(uint256 actual, uint256 seaportExpected);\n    error DelegateInfoInvariant();\n    error InvalidContextLength();\n    error TargetTokenInvalid(CreateOffererEnums.TargetToken invalidTargetToken);\n}\n\nlibrary CreateOffererEnums {\n    /// @notice Used to determine how expiryLength is interpreted in orders\n    enum ExpiryType {\n        none,\n        absolute,\n        relative\n    }\n\n    /// @notice Used to determine which token the targetTokenReceiver gets in orders\n    enum TargetToken {\n        none,\n        principal,\n        delegate\n    }\n\n    /// @notice Used to keep track of the stage during seaport calls on CreateOfferer\n    enum Stage {\n        none,\n        generate,\n        transfer,\n        ratify\n    }\n\n    /// @notice Used to keep track of whether a stage has been entered\n    enum Lock {\n        none,\n        locked,\n        unlocked\n    }\n}\n\nlibrary CreateOffererStructs {\n    /// @notice Used to track the stage and lock status\n    struct Stage {\n        CreateOffererEnums.Stage flag;\n        CreateOffererEnums.Lock lock;\n    }\n\n    /// @notice Used to keep track of the seaport contract nonce of CreateOfferer\n    struct Nonce {\n        uint256 value;\n    }\n\n    struct Receivers {\n        address targetTokenReceiver;\n        address fulfiller;\n    }\n\n    /// @notice Used in the constructor of CreateOfferer\n    struct Parameters {\n        address seaport;\n        address principalToken;\n        address delegateToken;\n    }\n\n    /// @notice Should be abi encoded (unpacked) in context data field for seaport CreateOfferer orders\n    struct Context {\n        bytes32 rights;\n        uint256 signerSalt;\n        uint256 expiryLength;\n        CreateOffererEnums.ExpiryType expiryType;\n        CreateOffererEnums.TargetToken targetToken;\n    }\n\n    /// @notice Contains data common to all order types\n    struct Order {\n        bytes32 rights;\n        uint256 expiryLength;\n        uint256 signerSalt;\n        address tokenContract;\n        CreateOffererEnums.ExpiryType expiryType;\n        CreateOffererEnums.TargetToken targetToken;\n    }\n\n    /// @notice Should be used when creating an ERC721 order\n    struct ERC721Order {\n        uint256 tokenId;\n        Order info;\n    }\n\n    /// @notice Should be used when creating an ERC20 order\n    struct ERC20Order {\n        uint256 amount;\n        Order info;\n    }\n\n    /// @notice Should be used when creating an ERC1155 order\n    struct ERC1155Order {\n        uint256 amount;\n        uint256 tokenId;\n        Order info;\n    }\n\n    /// @notice Transient storage used during a seaport call on CreateOfferer\n    struct TransientState {\n        ERC721Order erc721Order;\n        ERC20Order erc20Order;\n        ERC1155Order erc1155Order;\n        Receivers receivers;\n    }\n}\n\n/// @notice Contains the modifiers used by CreateOfferer\nabstract contract CreateOffererModifiers {\n    address public immutable seaport;\n    /// @notice Used by checkStage to track stage sequence and stage locks\n    CreateOffererStructs.Stage private stage;\n\n    /**\n     * @param setSeaport The address of the seaport version being used\n     * @param firstStage The first stage of the seaport flow, which is generateOrder\n     */\n    constructor(address setSeaport, CreateOffererEnums.Stage firstStage) {\n        if (setSeaport == address(0)) revert CreateOffererErrors.SeaportIsZero();\n        seaport = setSeaport;\n        stage = CreateOffererStructs.Stage({flag: firstStage, lock: CreateOffererEnums.Lock.unlocked});\n    }\n\n    /**\n     * @notice Prevents reentrancy into marked functions and allows stages to be called in sequence\n     * @param currentStage The stage being marked by the modifier\n     * @param nextStage The stage to be entered after ths stage being marked by the modifier\n     */\n    modifier checkStage(CreateOffererEnums.Stage currentStage, CreateOffererEnums.Stage nextStage) {\n        CreateOffererStructs.Stage memory cacheStage = stage;\n        if (cacheStage.lock != CreateOffererEnums.Lock.unlocked) revert CreateOffererErrors.Locked();\n        if (cacheStage.flag != currentStage) revert CreateOffererErrors.WrongStage(currentStage, cacheStage.flag);\n        stage.lock = CreateOffererEnums.Lock.locked;\n        _;\n        stage = CreateOffererStructs.Stage({flag: nextStage, lock: CreateOffererEnums.Lock.unlocked});\n    }\n\n    /**\n     * @notice Restricts a caller to seaport\n     * @param caller Should be msg.sender or intended caller for a preview function\n     */\n    modifier onlySeaport(address caller) {\n        if (caller != seaport) revert CreateOffererErrors.CallerNotSeaport(caller);\n        _;\n    }\n}\n\n/// @notice Contains helper function used by CreateOfferer\nlibrary CreateOffererHelpers {\n    /**\n     * @notice Validates and updates a Nonce struct\n     * @param nonce The storage pointer to the Nonce struct to be validated and updated\n     * @param contractNonce Used to valid against the expected nonce in storage\n     * @dev Should revert if contractNonce is not the same as the storage nonce\n     * @dev Should increment storage nonce if validation succeeds\n     */\n    function processNonce(CreateOffererStructs.Nonce storage nonce, uint256 contractNonce) internal {\n        if (nonce.value != contractNonce) revert CreateOffererErrors.InvalidContractNonce(nonce.value, contractNonce);\n        unchecked {\n            ++nonce.value;\n        } // Infeasible this will overflow if starting point is zero\n    }\n\n    /**\n     * @notice Updates a TransientState struct in storage with order data\n     * @param transientState The storage pointer to the TransientState struct to be updated\n     * @param minimumReceived Used to decode the token id of the CreateOfferer \"ghost\" token offer\n     * @param maximumSpent Contains the information of the underlying token to be used in create\n     * @param decodedContext Is the Context struct decoded and provides additional data need for the Order structs\n     * @dev Only one of the transient order data types will be updated\n     */\n    function updateTransientState(\n        CreateOffererStructs.TransientState storage transientState,\n        address fulfiller,\n        SpentItem calldata minimumReceived,\n        SpentItem calldata maximumSpent,\n        CreateOffererStructs.Context memory decodedContext\n    ) internal {\n        IDelegateRegistry.DelegationType tokenType = RegistryHashes.decodeType(bytes32(minimumReceived.identifier));\n        if (tokenType == IDelegateRegistry.DelegationType.ERC721) {\n            transientState.erc721Order = CreateOffererStructs.ERC721Order({\n                tokenId: maximumSpent.identifier,\n                info: CreateOffererStructs.Order({\n                    rights: decodedContext.rights,\n                    expiryLength: decodedContext.expiryLength,\n                    signerSalt: decodedContext.signerSalt,\n                    tokenContract: maximumSpent.token,\n                    expiryType: decodedContext.expiryType,\n                    targetToken: decodedContext.targetToken\n                })\n            });\n        } else if (tokenType == IDelegateRegistry.DelegationType.ERC20) {\n            transientState.erc20Order = CreateOffererStructs.ERC20Order({\n                amount: maximumSpent.amount,\n                info: CreateOffererStructs.Order({\n                    rights: decodedContext.rights,\n                    expiryLength: decodedContext.expiryLength,\n                    signerSalt: decodedContext.signerSalt,\n                    tokenContract: maximumSpent.token,\n                    expiryType: decodedContext.expiryType,\n                    targetToken: decodedContext.targetToken\n                })\n            });\n        } else if (tokenType == IDelegateRegistry.DelegationType.ERC1155) {\n            transientState.erc1155Order = CreateOffererStructs.ERC1155Order({\n                amount: maximumSpent.amount,\n                tokenId: maximumSpent.identifier,\n                info: CreateOffererStructs.Order({\n                    rights: decodedContext.rights,\n                    expiryLength: decodedContext.expiryLength,\n                    signerSalt: decodedContext.signerSalt,\n                    tokenContract: maximumSpent.token,\n                    expiryType: decodedContext.expiryType,\n                    targetToken: decodedContext.targetToken\n                })\n            });\n        } else {\n            revert CreateOffererErrors.InvalidTokenType(tokenType);\n        }\n        transientState.receivers.fulfiller = fulfiller;\n    }\n\n    /**\n     * @notice Creates a delegateToken pair and verifies the expected delegateTokenId\n     * @param delegateToken Should be the address of the DelegateToken contract\n     * @param createOrderHash Is the CreateOfferer order hash that will be used to verify the delegateTokenId is as expected\n     * @param delegateInfo A DelegateToken struct used in calls to the create function\n     * @dev Must revert if delegateId returned from create call is not the same as expected with createOrderHash\n     */\n    function createAndValidateDelegateTokenId(address delegateToken, uint256 createOrderHash, IDelegateTokenStructs.DelegateInfo memory delegateInfo) internal {\n        uint256 actualDelegateId = IDelegateToken(delegateToken).create(delegateInfo, createOrderHash);\n        uint256 requestedDelegateId = DelegateTokenHelpers.delegateIdNoRevert(address(this), createOrderHash);\n        if (actualDelegateId != requestedDelegateId) {\n            revert CreateOffererErrors.DelegateTokenIdInvariant(requestedDelegateId, actualDelegateId);\n        }\n    }\n\n    /**\n     * @notice Calculates the CreateOfferer hash, agnostic to the type\n     * @param delegateToken Should be the address of the DelegateToken contract\n     * @param targetTokenReceiver The receiver of the targetToken in orderInfo\n     * @param conduit The address of the conduit that should conduct the create on transferFrom on seaport calling CreateOfferer\n     * @param orderInfo Should be abi encoded (unpacked) with the relevant token type Order struct\n     * @param delegationType Delegation type that should correspond to the token type encoded into orderInfo\n     * @dev Should revert if a delegateToken has already been created with the parameters above\n     */\n    function calculateOrderHashAndId(address delegateToken, address targetTokenReceiver, address conduit, bytes memory orderInfo, IDelegateRegistry.DelegationType delegationType)\n        internal\n        view\n        returns (uint256 createOrderHash, uint256 delegateTokenId)\n    {\n        createOrderHash = CreateOffererHelpers.calculateOrderHash(targetTokenReceiver, conduit, orderInfo, delegationType);\n        delegateTokenId = IDelegateToken(delegateToken).getDelegateId(address(this), createOrderHash); // This should revert if already existed\n    }\n\n    /**\n     * @notice Verifies the properties of a delegateToken against the first element of a seaport ContractOfferer ratify order calldata\n     * @param delegateToken Should be the address of the DelegateToken contract\n     * @param identifier The offer identifier\n     * @param consideration The consideration specified in the ratify order call data (used as input data of the underlying used to create the delegate token)\n     * @param context Should contain an unpacked encoding of the Context struct which provides additional order data for comparison\n     * @dev Should revert if the delegateToken with tokenId in the offer does not match with the expected result\n     * @dev Should revert if context is the wrong length\n     */\n    function verifyCreate(address delegateToken, uint256 identifier, CreateOffererStructs.Receivers storage receivers, ReceivedItem calldata consideration, bytes calldata context)\n        internal\n        view\n    {\n        IDelegateRegistry.DelegationType tokenType = RegistryHashes.decodeType(bytes32(identifier));\n        if (context.length != 160) revert CreateOffererErrors.InvalidContextLength();\n        CreateOffererStructs.Context memory decodedContext = abi.decode(context, (CreateOffererStructs.Context));\n        //slither-disable-start timestamp\n        if (\n            keccak256(\n                abi.encode(\n                    IDelegateTokenStructs.DelegateInfo({\n                        tokenType: tokenType,\n                        principalHolder: decodedContext.targetToken == CreateOffererEnums.TargetToken.principal ? receivers.targetTokenReceiver : receivers.fulfiller,\n                        delegateHolder: decodedContext.targetToken == CreateOffererEnums.TargetToken.delegate ? receivers.targetTokenReceiver : receivers.fulfiller,\n                        expiry: CreateOffererHelpers.calculateExpiry(decodedContext.expiryType, decodedContext.expiryLength),\n                        rights: decodedContext.rights,\n                        tokenContract: consideration.token,\n                        tokenId: (tokenType != IDelegateRegistry.DelegationType.ERC20) ? consideration.identifier : 0,\n                        amount: (tokenType != IDelegateRegistry.DelegationType.ERC721) ? consideration.amount : 0\n                    })\n                )\n            ) != keccak256(abi.encode(IDelegateToken(delegateToken).getDelegateInfo(DelegateTokenHelpers.delegateIdNoRevert(address(this), identifier))))\n        ) revert CreateOffererErrors.DelegateInfoInvariant();\n        //slither-disable-end timestamp\n    }\n\n    /**\n     * @notice Calculates an effective expiry for an order at the time of execution\n     * @param expiryType Defines the type of expiry, should be relative or absolute\n     * @param expiryLength Length of the expiry given its reference point\n     * @dev Must revert if the expiryType is invalid\n     * @dev The reference for relative expiry types is block.timestamp\n     */\n    function calculateExpiry(CreateOffererEnums.ExpiryType expiryType, uint256 expiryLength) internal view returns (uint256) {\n        if (expiryType == CreateOffererEnums.ExpiryType.relative) {\n            return block.timestamp + expiryLength;\n        } else if (expiryType == CreateOffererEnums.ExpiryType.absolute) {\n            return expiryLength;\n        } else {\n            revert CreateOffererErrors.InvalidExpiryType(expiryType);\n        }\n    }\n\n    /**\n     * @notice Processes SpentItems calldata in a seaport call to CreateOfferer\n     * @param minimumReceived The corresponding calldata in generateOrder and previewOrder\n     * @param maximumSpent The corresponding calldata in generateOrder and previewOrder\n     * @return offer Which is the \"ghost\" token provided by CreateOfferer\n     * @return consideration Which is the same as minimumReceived with the address of the contract appended as the receiver\n     * @dev Must revert if calldata arrays are not length 1\n     * @dev Must revert if minimumReceived does not reflect the properties of the CreateOfferer \"ghost\" token\n     * @dev Must revert if maximumSpent does not use a token type supported by CreateOfferer and DelegateToken\n     */\n    function processSpentItems(SpentItem[] calldata minimumReceived, SpentItem[] calldata maximumSpent)\n        internal\n        view\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration)\n    {\n        if (!(minimumReceived.length == 1 && maximumSpent.length == 1)) revert CreateOffererErrors.NoBatchWrapping();\n        if (minimumReceived[0].itemType != ItemType.ERC721 || minimumReceived[0].token != address(this) || minimumReceived[0].amount != 1) {\n            revert CreateOffererErrors.MinimumReceivedInvalid(minimumReceived[0]);\n        }\n        if (maximumSpent[0].itemType != ItemType.ERC721 && maximumSpent[0].itemType != ItemType.ERC20 && maximumSpent[0].itemType != ItemType.ERC1155) {\n            revert CreateOffererErrors.MaximumSpentInvalid(maximumSpent[0]);\n        }\n        offer = new SpentItem[](1);\n        offer[0] = SpentItem({itemType: minimumReceived[0].itemType, token: minimumReceived[0].token, identifier: minimumReceived[0].identifier, amount: minimumReceived[0].amount});\n        consideration = new ReceivedItem[](1);\n        consideration[0] = ReceivedItem({\n            itemType: maximumSpent[0].itemType,\n            token: maximumSpent[0].token,\n            identifier: maximumSpent[0].identifier,\n            amount: maximumSpent[0].amount,\n            recipient: payable(address(this))\n        });\n    }\n\n    /**\n     * @notice Validates an expected CreateOfferer order hash against actual order data used and the current caller\n     * @param targetTokenReceiver Should be the receiver of the targetToken in the encodedOrder\n     * @param createOrderHash Is the order hash to be validated against\n     * @param encodedOrder Should be the unpacked encoding of the order data used\n     * @param tokenType Should correspond to the order type of encodedOrder\n     * @dev Must revert if the hash does not match up against the order data used\n     */\n    function validateCreateOrderHash(address targetTokenReceiver, uint256 createOrderHash, bytes memory encodedOrder, IDelegateRegistry.DelegationType tokenType) internal view {\n        uint256 actualCreateOrderHash = CreateOffererHelpers.calculateOrderHash(targetTokenReceiver, msg.sender, encodedOrder, tokenType);\n        if (actualCreateOrderHash != createOrderHash) {\n            revert CreateOffererErrors.CreateOrderHashInvariant(createOrderHash, actualCreateOrderHash);\n        }\n    }\n\n    /**\n     * @notice The order hash system used by CreateOfferer\n     * @param targetTokenReceiver Should be the intended receiver of the targetToken in createOrderInfo\n     * @param conduit Should be the intended conduit to be used in the corresponding seaport order\n     * @param createOrderInfo should be the unpacked encoding for a given token type order info\n     * @param tokenType Should match with the token type used in the encoded createOrderInfo\n     * @dev tokenType is encoded in the last byte of the hash after it has been shifted left by a byte\n     */\n    function calculateOrderHash(address targetTokenReceiver, address conduit, bytes memory createOrderInfo, IDelegateRegistry.DelegationType tokenType)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 hashWithoutType = uint256(keccak256(abi.encode(targetTokenReceiver, conduit, createOrderInfo)));\n        return (hashWithoutType << 8) | uint256(tokenType);\n    }\n}"
    }
  ]
}