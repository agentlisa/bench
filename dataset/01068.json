{
  "Title": "M-2: Uniswap Formula Drastically Underestimates Volatilty",
  "Content": "# Issue M-2: Uniswap Formula Drastically Underestimates Volatilty \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/38 \n\n## Found by \nBandit\n\nThe implied volatility calculated fees over a time period divided by current liquidity will almost always be lower than a reasonable derivation of volaitility. This is because there is no incentive or way for rational market participants to \"correct\" a pool where there is too much liquidity relative to volatility and fees.\n\n## Vulnerability Detail\n\nNote: This report will use annualised IV expressed in % will be use, even though the code representation uses different scaling.\n\nAloe estimates implied volatility based on the article cited below (taken from in-line code comments)\n\n```solidity\n\n//@notice Estimates implied volatility using this math - https://lambert-guillaume.medium.com/on-chain-volatility-and-uniswap-v3-d031b98143d1).\n```\n\nLambert's article describes a method of valuing Uniswap liquidity positions based on volatility. It is correct to say that the expected value of holding an LP position can be determined by the formula referenced in the article.  A liquidity position can be valued with the same as \"selling a straddle\" which is a short-volatility strategy which involves selling both a put and a call. Lambert does this by representing fee collection as an options premium and impermanat loss as the cost paid by the seller when the underlying hits the strike price. If the implied volatility of a uniswap position is above the fair IV, then it is profitable to be a liquidity provider, if it is lower, than it is not.\n\nKEY POINT: However, this does not mean that re-arranging the formula to derive IV gives a correct estimation of IV.\n\nThe assumptions of the efficient market hypothesis holds true only when there is a mechanism and incentive for rational actors to arbitrage the value of positions to fair value. There is a direct mechanism to push down the IV of Uniswap liquidity positions - if the IV is too high then providing liquidity is +EV, so rational actors would deposit liquidity, and thus the IV as calculated by Aloe's formula will decrease.\n\nHowever, when the `IV` derived from Uniswap fees and liquidity is too low, there is no mechanism for rational actors to profit off correcting this. If you are not already a liquidity provider, there is no way to provide \"negative liquidity\" or \"short a liquidity position\".\n\nIn fact the linked article by Lambert Guillaume contains data which demonstrates this exact fact - the table which shows the derived IV at time of writing having far lower results than the historical volatilities and the the IV derived from markets that allow both long and short trading (like options exchanges such as Deribit).  \n\nHere is a quote from that exact article, which points out that the Uniswap derived IV is sometimes 2.5x lower. Also check out the table directly in the article for reference:\n\n```solidity\n\"The realized volatility of most assets hover between 75% and 200% annualized in ETH terms. If we compare this to the IV extracted from the Uniswap v3 pools, we get:\n\nNote that the volatilities are somewhat lower, perhaps a factor of ~2.5, for most assets.\"\n```\n\n\nThe IV's in options markets or protocols that have long-short mechanisms such as Opyn's Squeeth have a correction mechanism for `IV's` which are too low, because you can both buy and sell options, and are therefore \"correct\" according to Efficient Market Hypothesis. The Uniswap pool is a \"long-only\" market, where liquidity can be added, but not shorted, which leads to systematically lower `IV` than is realistic. The EMH model, both in soft and hard form, only holds when there is a mechnaism for a rational minority to profit off correcting a market imbalance. If many irrational or utilitarian users deposits too much liquidity into a Uniswap v3 pool relative to the fee capture and IV, theres no way to profit off correcting this imbalance.\n\nThere are 3 ways to validate the claim that the Uniswap formula drastically underestimates the IV:\n\n1. On chain data which shows that the liquidty and fee derivation from Uniswap gives far lower results than other\n2. The table provided in Lambert Guillaume's article, which shows a Uniswap pool derived IVs which are far lower than the historical volatilities of the asset.\n3. Studies showing that liquidity providers suffer far more impermanent loss than fees.\n\n## Impact\n\n- The lower IV increases LTV, which means far higher LTV for risky assets. `5 sigma` probability bad-debt events, as calculated by the protocol which is basically an impossibility, becomes possible/likely as the relationship between `IV` or `Pr(event)` is super-linear\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/libraries/Volatility.sol#L33-L81\n\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/VolatilityOracle.sol#L45-L94\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n2 possible options (excuse the pun):\n\n- Use historical price differences in the Uniswap pool (similar to a TWAP, but Time Weighted Average Price Difference) and use that to infer volatilty alongside the current implementations which is based on fees and liquidity. Both are inaccurate, but use the `maximum` of the two values. The 2 IV calculations can be used to \"sanity check\" the other, to correct one which drastically underestimates the risk\n\n- Same as above, use the `maximum`  of the fee/liquidity derived `IV` but use a market that has long/short possibilities such as Opyn's Squeeth to sanity check the IV.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> low, because the risk of liquidation has a huge margin of error built-in, so that 2.5 IV underestimation is not really a problems and is covered by the safety margin of the values used. Besides, all the other solutions are not very universal and do not guarantee much better IV estimation anyway.\n\n**MohammedRizwan** commented:\n>  seems intended design\n\n\n\n**haydenshively**\n\nThis is **medium severity** because governance can increase `nSigma` from the default of 5 up to a maximum of 8. This 60% increase should be enough to compensate for systematic error arising from the not-quite-efficient market (and [Panoptic](https://panoptic.xyz/) should be available soon, making it more efficient).\n\nThat said, the whitehat is correct that the `VolatilityOracle` underestimates IV, and **we will do our best to improve it**. Unfortunately their first suggestion requires too much gas (at least for mainnet) and Opyn data would only work for a handful of markets. One idea is to allow IV to increase faster than it decreases -- in other words, use a different `IV_CHANGE_PER_UPDATE` constraint depending on whether IV is increasing or decreasing. You can see the impact of such a change in the plot below (compare \"OG\" vs \"New\"). It reduces avg error from -29% to -14%. Variations on this idea could get even better.\n\n_T3 Index data [here](https://t3index.com/indexes/bit-vol/); `VolatilityOracle` simulated for a few weeks at the beginning of this year using mainnet USDC/WETH 0.05% pair_\n\n<img width=\"592\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-10-aloe-judging/assets/17186559/25f35ef9-c3d0-47f8-b7b7-fc21b96583d7\">\n\n**haydenshively**\n\nFixed in https://github.com/aloelabs/aloe-ii/pull/219\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "aloe-ii/core/src/libraries/Volatility.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {FixedPointMathLib as SoladyMath} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {square, mulDiv96, mulDiv128, mulDiv224} from \"./MulDiv.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {TickMath} from \"./TickMath.sol\";\n\n/// @title Volatility\n/// @notice Provides functions that use Uniswap v3 to compute price volatility\n/// @author Aloe Labs, Inc.\nlibrary Volatility {\n    struct PoolMetadata {\n        // the overall fee minus the protocol fee for token0, times 1e6\n        uint24 gamma0;\n        // the overall fee minus the protocol fee for token1, times 1e6\n        uint24 gamma1;\n        // the pool tick spacing\n        int24 tickSpacing;\n    }\n\n    struct FeeGrowthGlobals {\n        // the fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n        uint256 feeGrowthGlobal0X128;\n        // the fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n        uint256 feeGrowthGlobal1X128;\n        // the block timestamp at which feeGrowthGlobal0X128 and feeGrowthGlobal1X128 were last updated\n        uint32 timestamp;\n    }\n\n    /**\n     * @notice Estimates implied volatility using\n     * [this math](https://lambert-guillaume.medium.com/on-chain-volatility-and-uniswap-v3-d031b98143d1).\n     * @dev The return value can fit in uint128 if necessary\n     * @param metadata The pool's metadata (may be cached)\n     * @param data A summary of the pool's state from `pool.slot0` `pool.observe` and `pool.liquidity`\n     * @param a The pool's cumulative feeGrowthGlobals some time in the past\n     * @param b The pool's cumulative feeGrowthGlobals as of the current block\n     * @param scale The timescale (in seconds) in which IV should be reported, e.g. hourly, daily, annualized\n     * @return An estimate of the implied volatility scaled by 1e12\n     */\n    function estimate(\n        PoolMetadata memory metadata,\n        Oracle.PoolData memory data,\n        FeeGrowthGlobals memory a,\n        FeeGrowthGlobals memory b,\n        uint32 scale\n    ) internal pure returns (uint256) {\n        uint256 tickTvl = computeTickTvl(metadata.tickSpacing, data.currentTick, data.sqrtPriceX96, data.tickLiquidity);\n\n        // Return early to avoid division by 0\n        if (data.secondsPerLiquidityX128 == 0 || b.timestamp - a.timestamp == 0 || tickTvl == 0) return 0;\n\n        uint256 revenue0Gamma1 = computeRevenueGamma(\n            a.feeGrowthGlobal0X128,\n            b.feeGrowthGlobal0X128,\n            data.secondsPerLiquidityX128,\n            data.oracleLookback,\n            metadata.gamma1\n        );\n        uint256 revenue1Gamma0 = computeRevenueGamma(\n            a.feeGrowthGlobal1X128,\n            b.feeGrowthGlobal1X128,\n            data.secondsPerLiquidityX128,\n            data.oracleLookback,\n            metadata.gamma0\n        );\n        // This is an approximation. Ideally the fees earned during each swap would be multiplied by the price\n        // *at that swap*. But for prices simulated with GBM and swap sizes either normally or uniformly distributed,\n        // the error you get from using geometric mean price is <1% even with high drift and volatility.\n        uint256 volumeGamma0Gamma1 = revenue1Gamma0 + amount0ToAmount1(revenue0Gamma1, data.sqrtMeanPriceX96);\n        // Clamp to prevent overflow later on\n        if (volumeGamma0Gamma1 > (1 << 128)) volumeGamma0Gamma1 = (1 << 128);\n\n        unchecked {\n            // Scale volume to the target time frame, divide by `tickTvl`, and sqrt for final result\n            return SoladyMath.sqrt((4e24 * volumeGamma0Gamma1 * scale) / (b.timestamp - a.timestamp) / tickTvl);\n        }\n    }\n\n    /**\n     * @notice Computes an `amount1` that (at `tick`) is equivalent in worth to the provided `amount0`\n     * @param amount0 The amount of token0 to convert\n     * @param sqrtPriceX96 The sqrt(price) at which the conversion should hold true\n     * @return amount1 An equivalent amount of token1\n     */\n    function amount0ToAmount1(uint256 amount0, uint160 sqrtPriceX96) internal pure returns (uint256 amount1) {\n        uint256 priceX128 = square(sqrtPriceX96);\n        amount1 = mulDiv128(amount0, priceX128);\n    }\n\n    /**\n     * @notice Computes pool revenue using feeGrowthGlobal accumulators, then scales it down by a factor of gamma\n     * @param feeGrowthGlobalAX128 The value of feeGrowthGlobal (either 0 or 1) at time A\n     * @param feeGrowthGlobalBX128 The value of feeGrowthGlobal (either 0 or 1, but matching) at time B (B > A)\n     * @param secondsPerLiquidityX128 The difference in the secondsPerLiquidity accumulator from `secondsAgo` seconds ago until now\n     * @param secondsAgo The oracle lookback period that was used to find `secondsPerLiquidityX128`\n     * @param gamma The fee factor to scale by\n     * @return Revenue over the period from `block.timestamp - secondsAgo` to `block.timestamp`, scaled down by a factor of gamma\n     */\n    function computeRevenueGamma(\n        uint256 feeGrowthGlobalAX128,\n        uint256 feeGrowthGlobalBX128,\n        uint160 secondsPerLiquidityX128,\n        uint32 secondsAgo,\n        uint24 gamma\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 delta;\n\n            if (feeGrowthGlobalBX128 >= feeGrowthGlobalAX128) {\n                // feeGrowthGlobal has increased from time A to time B\n                delta = feeGrowthGlobalBX128 - feeGrowthGlobalAX128;\n            } else {\n                // feeGrowthGlobal has overflowed between time A and time B\n                delta = type(uint256).max - feeGrowthGlobalAX128 + feeGrowthGlobalBX128;\n            }\n\n            return Math.mulDiv(delta, secondsAgo * uint256(gamma), secondsPerLiquidityX128 * uint256(1e6));\n        }\n    }\n\n    /**\n     * @notice Computes the value of liquidity available at the current tick, denominated in token1\n     * @param tickSpacing The pool tick spacing (from pool.tickSpacing())\n     * @param tick The current tick (from pool.slot0())\n     * @param sqrtPriceX96 The current price (from pool.slot0())\n     * @param liquidity The liquidity depth at currentTick (from pool.liquidity())\n     */\n    function computeTickTvl(\n        int24 tickSpacing,\n        int24 tick,\n        uint160 sqrtPriceX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 tickTvl) {\n        unchecked {\n            tick = TickMath.floor(tick, tickSpacing);\n\n            tickTvl = _getValueOfLiquidity(\n                sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(tick),\n                TickMath.getSqrtRatioAtTick(tick + tickSpacing),\n                liquidity\n            );\n        }\n    }\n\n    /**\n     * @notice Computes the value of the liquidity in terms of token1\n     * @dev The return value can fit in uint193 if necessary\n     * @param sqrtRatioX96 A sqrt price representing the current pool prices\n     * @param sqrtRatioAX96 A sqrt price representing the lower tick boundary\n     * @param sqrtRatioBX96 A sqrt price representing the upper tick boundary\n     * @param liquidity The liquidity being valued\n     * @return value The total value of `liquidity`, in terms of token1\n     */\n    function _getValueOfLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) private pure returns (uint256 value) {\n        assert(sqrtRatioAX96 <= sqrtRatioX96 && sqrtRatioX96 <= sqrtRatioBX96);\n\n        unchecked {\n            uint256 numerator = Math.mulDiv(uint256(liquidity) << 128, sqrtRatioX96, sqrtRatioBX96);\n\n            value =\n                mulDiv224(numerator, sqrtRatioBX96 - sqrtRatioX96) +\n                mulDiv96(liquidity, sqrtRatioX96 - sqrtRatioAX96);\n        }\n    }\n}"
    },
    {
      "filename": "aloe-ii/core/src/VolatilityOracle.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {\n    IV_SCALE,\n    IV_COLD_START,\n    IV_CHANGE_PER_UPDATE,\n    UNISWAP_AVG_WINDOW,\n    FEE_GROWTH_AVG_WINDOW,\n    FEE_GROWTH_ARRAY_LENGTH,\n    FEE_GROWTH_SAMPLE_PERIOD\n} from \"./libraries/constants/Constants.sol\";\nimport {Oracle} from \"./libraries/Oracle.sol\";\nimport {Volatility} from \"./libraries/Volatility.sol\";\n\n/// @title VolatilityOracle\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract VolatilityOracle {\n    event Update(IUniswapV3Pool indexed pool, uint160 sqrtMeanPriceX96, uint256 iv);\n\n    struct LastWrite {\n        uint8 index;\n        uint32 time;\n        uint216 iv;\n    }\n\n    mapping(IUniswapV3Pool => Volatility.PoolMetadata) public cachedMetadata;\n\n    mapping(IUniswapV3Pool => Volatility.FeeGrowthGlobals[FEE_GROWTH_ARRAY_LENGTH]) public feeGrowthGlobals;\n\n    mapping(IUniswapV3Pool => LastWrite) public lastWrites;\n\n    function prepare(IUniswapV3Pool pool) external {\n        cachedMetadata[pool] = _getPoolMetadata(pool);\n\n        if (lastWrites[pool].time == 0) {\n            feeGrowthGlobals[pool][0] = _getFeeGrowthGlobalsNow(pool);\n            lastWrites[pool] = LastWrite({index: 0, time: uint32(block.timestamp), iv: IV_COLD_START});\n        }\n    }\n\n    function update(IUniswapV3Pool pool, uint40 seed) external returns (uint56, uint160, uint256) {\n        unchecked {\n            // Read `lastWrite` info from storage\n            LastWrite memory lastWrite = lastWrites[pool];\n            require(lastWrite.time > 0);\n\n            // We need to call `Oracle.consult` even if we're going to return early, so go ahead and do it\n            (Oracle.PoolData memory data, uint56 metric) = Oracle.consult(pool, seed);\n\n            // If fewer than `FEE_GROWTH_SAMPLE_PERIOD` seconds have elapsed, return early.\n            // We still fetch the latest TWAP, but we do not sample feeGrowthGlobals or update IV.\n            if (block.timestamp - lastWrite.time < FEE_GROWTH_SAMPLE_PERIOD) {\n                return (metric, data.sqrtMeanPriceX96, lastWrite.iv);\n            }\n\n            // Populate remaining `PoolData` fields\n            data.oracleLookback = UNISWAP_AVG_WINDOW;\n            data.tickLiquidity = pool.liquidity();\n\n            // Populate `FeeGrowthGlobals`\n            Volatility.FeeGrowthGlobals[FEE_GROWTH_ARRAY_LENGTH] storage arr = feeGrowthGlobals[pool];\n            Volatility.FeeGrowthGlobals memory a = _getFeeGrowthGlobalsOld(arr, lastWrite.index);\n            Volatility.FeeGrowthGlobals memory b = _getFeeGrowthGlobalsNow(pool);\n\n            // Default to using the existing IV\n            uint256 iv = lastWrite.iv;\n            // Only update IV if the feeGrowthGlobals samples are approximately `FEE_GROWTH_AVG_WINDOW` hours apart\n            if (\n                _isInInterval({\n                    min: FEE_GROWTH_AVG_WINDOW - FEE_GROWTH_SAMPLE_PERIOD / 2,\n                    x: b.timestamp - a.timestamp,\n                    max: FEE_GROWTH_AVG_WINDOW + FEE_GROWTH_SAMPLE_PERIOD / 2\n                })\n            ) {\n                // Estimate, then clamp so it lies within [previous - maxChange, previous + maxChange]\n                iv = Volatility.estimate(cachedMetadata[pool], data, a, b, IV_SCALE);\n\n                if (iv > lastWrite.iv + IV_CHANGE_PER_UPDATE) iv = lastWrite.iv + IV_CHANGE_PER_UPDATE;\n                else if (iv + IV_CHANGE_PER_UPDATE < lastWrite.iv) iv = lastWrite.iv - IV_CHANGE_PER_UPDATE;\n            }\n\n            // Store the new feeGrowthGlobals sample and update `lastWrites`\n            uint8 next = uint8((lastWrite.index + 1) % FEE_GROWTH_ARRAY_LENGTH);\n            arr[next] = b;\n            lastWrites[pool] = LastWrite(next, uint32(block.timestamp), uint216(iv));\n\n            emit Update(pool, data.sqrtMeanPriceX96, iv);\n            return (metric, data.sqrtMeanPriceX96, iv);\n        }\n    }\n\n    function consult(IUniswapV3Pool pool, uint40 seed) external view returns (uint56, uint160, uint256) {\n        (Oracle.PoolData memory data, uint56 metric) = Oracle.consult(pool, seed);\n        return (metric, data.sqrtMeanPriceX96, lastWrites[pool].iv);\n    }\n\n    function _getPoolMetadata(IUniswapV3Pool pool) private view returns (Volatility.PoolMetadata memory metadata) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , uint8 feeProtocol, ) = pool.slot0();\n        // We want observations from `UNISWAP_AVG_WINDOW` and `UNISWAP_AVG_WINDOW * 2` seconds ago. Since observation\n        // frequency varies with `pool` usage, we apply an extra 3x safety factor. If `pool` usage increases,\n        // oracle cardinality may need to be increased as well. This should be monitored off-chain.\n        require(\n            Oracle.getMaxSecondsAgo(pool, observationIndex, observationCardinality) > UNISWAP_AVG_WINDOW * 6,\n            \"Aloe: cardinality\"\n        );\n\n        uint24 fee = pool.fee();\n        metadata.gamma0 = fee;\n        metadata.gamma1 = fee;\n        unchecked {\n            if (feeProtocol % 16 != 0) metadata.gamma0 -= fee / (feeProtocol % 16);\n            if (feeProtocol >> 4 != 0) metadata.gamma1 -= fee / (feeProtocol >> 4);\n        }\n\n        metadata.tickSpacing = pool.tickSpacing();\n    }\n\n    function _getFeeGrowthGlobalsNow(IUniswapV3Pool pool) private view returns (Volatility.FeeGrowthGlobals memory) {\n        return\n            Volatility.FeeGrowthGlobals(\n                pool.feeGrowthGlobal0X128(),\n                pool.feeGrowthGlobal1X128(),\n                uint32(block.timestamp)\n            );\n    }\n\n    function _getFeeGrowthGlobalsOld(\n        Volatility.FeeGrowthGlobals[FEE_GROWTH_ARRAY_LENGTH] storage arr,\n        uint256 index\n    ) private view returns (Volatility.FeeGrowthGlobals memory) {\n        uint256 target = block.timestamp - FEE_GROWTH_AVG_WINDOW;\n\n        // See if the newest sample is nearest to `target`\n        Volatility.FeeGrowthGlobals memory sample = arr[index];\n        if (sample.timestamp <= target) return sample;\n\n        // See if the oldest sample is nearest to `target`\n        uint256 next = (index + 1) % FEE_GROWTH_ARRAY_LENGTH;\n        sample = arr[next];\n        if (sample.timestamp >= target) return sample;\n\n        // Now that we've checked the edges, we know the best sample lies somewhere within the array.\n        return _binarySearch(arr, next, target);\n    }\n\n    function _binarySearch(\n        Volatility.FeeGrowthGlobals[FEE_GROWTH_ARRAY_LENGTH] storage arr,\n        uint256 l,\n        uint256 target\n    ) private view returns (Volatility.FeeGrowthGlobals memory) {\n        Volatility.FeeGrowthGlobals memory beforeOrAt;\n        Volatility.FeeGrowthGlobals memory atOrAfter;\n\n        unchecked {\n            uint256 r = l + (FEE_GROWTH_ARRAY_LENGTH - 1);\n            uint256 i;\n            while (true) {\n                i = (l + r) / 2;\n\n                beforeOrAt = arr[i % FEE_GROWTH_ARRAY_LENGTH];\n                atOrAfter = arr[(i + 1) % FEE_GROWTH_ARRAY_LENGTH];\n\n                if (_isInInterval(beforeOrAt.timestamp, target, atOrAfter.timestamp)) break;\n\n                if (target < beforeOrAt.timestamp) r = i - 1;\n                else l = i + 1;\n            }\n\n            uint256 errorA = target - beforeOrAt.timestamp;\n            uint256 errorB = atOrAfter.timestamp - target;\n\n            return errorB < errorA ? atOrAfter : beforeOrAt;\n        }\n    }\n\n    function _isInInterval(uint256 min, uint256 x, uint256 max) private pure returns (bool) {\n        return min <= x && x <= max;\n    }\n}"
    }
  ]
}