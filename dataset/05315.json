{
  "Title": "[G-04] Cache state variables outside of loop to avoid reading storage on every iteration",
  "Content": "Reading from storage should always try to be avoided within loops. In the following instances, we are able to cache state variables outside of the loop to save a Gwarmaccess (100 gas) per loop iteration.\n\n### Please note these instances were not included in the bot reports.\n\n### 5 Instances\n1. ### Cache `fee` outside the loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L242\n\nIn the `_settlePayment()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `fee` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<Details>\n\n```solidity\nfile: src/modules/PaymentEscrow.sol\n\n215:    function _settlePayment(\n216:        Item[] calldata items,\n217:        OrderType orderType,\n218:        address lender,\n219:        address renter,\n220:        uint256 start,\n221:        uint256 end\n222:    ) internal {\n223:        // Calculate the time values.\n224:        uint256 elapsedTime = block.timestamp - start;\n225:        uint256 totalTime = end - start;\n226:\n227:        // Determine whether the rental order has ended.\n228:        bool isRentalOver = elapsedTime >= totalTime;\n229:\n230:        // Loop through each item in the order.\n231:        for (uint256 i = 0; i < items.length; ++i) {\n232:            // Get the item.\n233:            Item memory item = items[i];\n234:\n235:            // Check that the item is a payment.\n236:            if (item.isERC20()) {\n237:                // Set a placeholder payment amount which can be reduced in the\n238:                // presence of a fee.\n239:                uint256 paymentAmount = item.amount;\n240:\n241:                // Take a fee on the payment amount if the fee is on.\n242:                if (fee != 0) { //@audit cache fee outside the loop\n243:                    // Calculate the new fee.\n244:                    uint256 paymentFee = _calculateFee(paymentAmount);\n245:\n246:                    // Adjust the payment amount by the fee.\n247:                    paymentAmount -= paymentFee;\n248:                }\n.\n.\n.\n283:    }\n```\n```diff\ndiff --git a/src/modules/PaymentEscrow.sol b/src/modules/PaymentEscrow.sol\nindex 34c4f4c..066d593 100644\n--- a/src/modules/PaymentEscrow.sol\n+++ b/src/modules/PaymentEscrow.sol\n@@ -226,7 +226,7 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n\n         // Determine whether the rental order has ended.\n         bool isRentalOver = elapsedTime >= totalTime;\n-\n+        uint256 _fee = fee;\n         // Loop through each item in the order.\n         for (uint256 i = 0; i < items.length; ++i) {\n             // Get the item.\n@@ -239,7 +239,7 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n                 uint256 paymentAmount = item.amount;\n\n                 // Take a fee on the payment amount if the fee is on.\n-                if (fee != 0) {\n+                if (_fee != 0) {\n                     // Calculate the new fee.\n                     uint256 paymentFee = _calculateFee(paymentAmount);\n```\n```\nEstimated gas saved: 97 gas units per iteration\n```\n\n</details>\n\n2. ### Cache `STORE` outside the loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L480\n\nIn the `_addHooks()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `STORE` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<Details>\n\n```solidity\nfile: src/policies/Create.sol\n\n464:    function _addHooks(\n465:        Hook[] memory hooks,\n466:        SpentItem[] memory offerItems,\n467:        address rentalWallet\n468:    ) internal {\n469:        // Define hook target, offer item index, and an offer item.\n470:        address target;\n471:        uint256 itemIndex;\n472:        SpentItem memory offer;\n473:\n474:        // Loop through each hook in the payload.\n475:        for (uint256 i = 0; i < hooks.length; ++i) {\n476:            // Get the hook's target address.\n477:            target = hooks[i].target;\n478:\n479:            // Check that the hook is reNFT-approved to execute on rental start.\n480:            if (!STORE.hookOnStart(target)) {   //@audit cache STORE outside the loop\n481:                revert Errors.Shared_DisabledHook(target);\n482:            }\n483:\n484:            // Get the offer item index for this hook.\n485:            itemIndex = hooks[i].itemIndex;\n.\n.\n.\n520:    }\n```\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..a8de17a 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -470,14 +470,14 @@ contract Create is Policy, Signer, Zone, Accumulator {\n         address target;\n         uint256 itemIndex;\n         SpentItem memory offer;\n-\n+        Storage _store = STORE;\n         // Loop through each hook in the payload.\n         for (uint256 i = 0; i < hooks.length; ++i) {\n             // Get the hook's target address.\n             target = hooks[i].target;\n\n             // Check that the hook is reNFT-approved to execute on rental start.\n-            if (!STORE.hookOnStart(target)) {\n+            if (!_store.hookOnStart(target)) {\n                 revert Errors.Shared_DisabledHook(target);\n             }\n```\n```\nEstimated gas saved: 97 gas units per iteration\n```\n\n</details>\n\n3. ### Cache `ESCRW` outside of loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L601\n\nIn the `_rentFromZone()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `ESCRW` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<details>\n\n```solidity\nfile: src/policies/Create.sol\n\n530:    function _rentFromZone(\n531:        RentPayload memory payload,\n532:        SeaportPayload memory seaportPayload\n533:    ) internal {\n534:        // Check: make sure order metadata is valid with the given seaport order zone hash.\n535:        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n536:\n537:        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n538:        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n.\n.\n.\n597:            // Interaction: Increase the deposit value on the payment escrow so\n598:            // it knows how many tokens were sent to it.\n599:            for (uint256 i = 0; i < items.length; ++i) {\n600:                if (items[i].isERC20()) {\n601:                    ESCRW.increaseDeposit(items[i].token, items[i].amount); //@audit cache ESCRW outside loop\n602:                }\n603:            }\n604:\n605:            // Interaction: Process the hooks associated with this rental.\n606:            if (payload.metadata.hooks.length > 0) {\n607:                _addHooks(\n608:                    payload.metadata.hooks,\n609:                    seaportPayload.offer,\n610:                    payload.fulfillment.recipient\n611:                );\n612:            }\n613:\n614:            // Emit rental order started.\n615:            _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n616:        }\n617:    }\n```\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..1a8ecb6 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -593,12 +593,12 @@ contract Create is Policy, Signer, Zone, Accumulator {\n\n             // Interaction: Update storage only if the order is a Base Order or Pay order.\n             STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n-\n+            PaymentEscrow _escrw = ESCRW;\n             // Interaction: Increase the deposit value on the payment escrow so\n             // it knows how many tokens were sent to it.\n             for (uint256 i = 0; i < items.length; ++i) {\n                 if (items[i].isERC20()) {\n-                    ESCRW.increaseDeposit(items[i].token, items[i].amount);\n+                    _escrw.increaseDeposit(items[i].token, items[i].amount);\n                 }\n             }\n```\n```\nEstimated gas saved: 97 gas units per iteration\n```\n\n</details>\n\n4. ### Cache `ESCRW` outside of loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L700\n\nIn the `_executionInvariantChecks()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `ESCRW` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<details>\n\n```solidity\nfile: src/policies/Create.sol\n\n691:    function _executionInvariantChecks(\n692:        ReceivedItem[] memory executions,\n693:        address expectedRentalSafe\n694:    ) internal view {\n695:        for (uint256 i = 0; i < executions.length; ++i) {\n696:            ReceivedItem memory execution = executions[i];\n697:\n698:            // ERC20 invariant where the recipient must be the payment escrow.\n699:            if (execution.isERC20()) {\n700:                _checkExpectedRecipient(execution, address(ESCRW));\n701:            }\n702:            // ERC721 and ERC1155 invariants where the recipient must\n703:            // be the expected rental safe.\n704:            else if (execution.isRental()) {\n705:                _checkExpectedRecipient(execution, expectedRentalSafe);\n706:            }\n707:            // Revert if unsupported item type.\n708:            else {\n709:                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n710:                    execution.itemType\n711:                );\n712:            }\n713:        }\n714:    }\n```\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..93d1ec6 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -692,12 +692,13 @@ contract Create is Policy, Signer, Zone, Accumulator {\n         ReceivedItem[] memory executions,\n         address expectedRentalSafe\n     ) internal view {\n+        PaymentEscrow _escrw = ESCRW;\n         for (uint256 i = 0; i < executions.length; ++i) {\n             ReceivedItem memory execution = executions[i];\n\n             // ERC20 invariant where the recipient must be the payment escrow.\n             if (execution.isERC20()) {\n-                _checkExpectedRecipient(execution, address(ESCRW));\n+                _checkExpectedRecipient(execution, address(_escrw));\n             }\n             // ERC721 and ERC1155 invariants where the recipient must\n             // be the expected rental safe.\n```\n```\nEstimated gas saved: 97 gas saved per iteration\n```\n\n</details>\n\n5. ### Cache `STORE` outside of loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L210\n\nIn the `_removeHooks()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `STORE` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<details>\n\n```solidity\nfile: src/policies/Stop.sol\n\n194:    function _removeHooks(\n195:        Hook[] calldata hooks,\n196:        Item[] calldata rentalItems,\n197:        address rentalWallet\n198:    ) internal {\n199:        // Define hook target, item index, and item.\n200:        address target;\n201:        uint256 itemIndex;\n202:        Item memory item;\n203:\n204:        // Loop through each hook in the payload.\n205:        for (uint256 i = 0; i < hooks.length; ++i) {\n206:            // Get the hook address.\n207:            target = hooks[i].target;\n208:\n209:            // Check that the hook is reNFT-approved to execute on rental stop.\n210:            if (!STORE.hookOnStop(target)) {\n211:                revert Errors.Shared_DisabledHook(target);\n212:            }\n.\n.\n.\n250:    }\n```\n```diff\ndiff --git a/src/policies/Stop.sol b/src/policies/Stop.sol\nindex ab240ba..c348c1c 100644\n--- a/src/policies/Stop.sol\n+++ b/src/policies/Stop.sol\n@@ -200,14 +200,14 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n         address target;\n         uint256 itemIndex;\n         Item memory item;\n-\n+        Storage _store = STORE;\n         // Loop through each hook in the payload.\n         for (uint256 i = 0; i < hooks.length; ++i) {\n             // Get the hook address.\n             target = hooks[i].target;\n\n             // Check that the hook is reNFT-approved to execute on rental stop.\n-            if (!STORE.hookOnStop(target)) {\n+            if (!_store.hookOnStop(target)) {\n                 revert Errors.Shared_DisabledHook(target);\n             }\n```\n```\nEstimated gas saved: 97 gas saved per iteration\n```\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/modules/PaymentEscrow.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\n\nimport {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\nimport {Proxiable} from \"@src/proxy/Proxiable.sol\";\nimport {\n    RentalOrder,\n    Item,\n    ItemType,\n    SettleTo,\n    OrderType\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n\n/**\n * @title PaymentEscrowBase\n * @notice Storage exists in its own base contract to avoid storage slot mismatch during upgrades.\n */\ncontract PaymentEscrowBase {\n    // Keeps a record of the current token balances in the escrow.\n    mapping(address token => uint256 amount) public balanceOf;\n\n    // Fee percentage taken from payments.\n    uint256 public fee;\n}\n\n/**\n * @title PaymentEscrow\n * @notice Module dedicated to escrowing rental payments while rentals are active. When\n *         rentals are stopped, this module will determine payouts to all parties and a\n *         fee will be reserved to be withdrawn later by a protocol admin.\n */\ncontract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n    using RentalUtils for Item;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Module Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Instantiate this contract as a module. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /**\n     * @notice Instantiates this contract as a module via a proxy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    function MODULE_PROXY_INSTANTIATION(\n        Kernel kernel_\n    ) external onlyByProxy onlyUninitialized {\n        kernel = kernel_;\n        initialized = true;\n    }\n\n    /**\n     * @notice Specifies which version of a module is being implemented.\n     */\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /**\n     * @notice Defines the keycode for this module.\n     */\n    function KEYCODE() public pure override returns (Keycode) {\n        return Keycode.wrap(\"ESCRW\");\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Calculates the fee based on the fee numerator set by an admin.\n     *\n     * @param amount Amount for which to calculate the fee.\n     */\n    function _calculateFee(uint256 amount) internal view returns (uint256) {\n        // Uses 10,000 as a denominator for the fee.\n        return (amount * fee) / 10000;\n    }\n\n    /**\n     * @dev Safe transfer for ERC20 tokens that do not consistently renturn true/false.\n     *\n     * @param token Asset address which is being sent.\n     * @param to    Destination address for the transfer.\n     * @param value Amount of the asset being transferred.\n     */\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        // Call transfer() on the token.\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n\n        // Because both reverting and returning false are allowed by the ERC20 standard\n        // to indicate a failed transfer, we must handle both cases.\n        //\n        // If success is false, the ERC20 contract reverted.\n        //\n        // If success is true, we must check if return data was provided. If no return\n        // data is provided, then no revert occurred. But, if return data is provided,\n        // then it must be decoded into a bool which will indicate the success of the\n        // transfer.\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n        }\n    }\n\n    /**\n     * @dev Calculates the pro-rata split based on the amount of time that has elapsed in\n     *      a rental order. If there are not enough funds to split perfectly, rounding is\n     *      done to make the split as fair as possible.\n     *\n     * @param amount      Amount of tokens for which to calculate the split.\n     * @param elapsedTime Elapsed time since the rental started.\n     * @param totalTime   Total time window of the rental from start to end.\n     *\n     * @return renterAmount Payment amount to send to the renter.\n     * @return lenderAmount Payment amoutn to send to the lender.\n     */\n    function _calculatePaymentProRata(\n        uint256 amount,\n        uint256 elapsedTime,\n        uint256 totalTime\n    ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n        // Calculate the numerator and adjust by a multiple of 1000.\n        uint256 numerator = (amount * elapsedTime) * 1000;\n\n        // Calculate the result, but bump by 500 to add a rounding adjustment. Then,\n        // reduce by a multiple of 1000.\n        renterAmount = ((numerator / totalTime) + 500) / 1000;\n\n        // Calculate lender amount from renter amount so no tokens are left behind.\n        lenderAmount = amount - renterAmount;\n    }\n\n    /**\n     * @dev Settles a payment via a pro-rata split. After payments are calculated, they\n     *      are transferred to their respective recipients.\n     *\n     * @param token       Token address for which to settle a payment.\n     * @param amount      Amount of the token to settle.\n     * @param lender      Lender account.\n     * @param renter      Renter accoutn.\n     * @param elapsedTime Elapsed time since the rental started.\n     * @param totalTime   Total time window of the rental from start to end.\n     */\n    function _settlePaymentProRata(\n        address token,\n        uint256 amount,\n        address lender,\n        address renter,\n        uint256 elapsedTime,\n        uint256 totalTime\n    ) internal {\n        // Calculate the pro-rata payment for renter and lender.\n        (uint256 renterAmount, uint256 lenderAmount) = _calculatePaymentProRata(\n            amount,\n            elapsedTime,\n            totalTime\n        );\n\n        // Send the lender portion of the payment.\n        _safeTransfer(token, lender, lenderAmount);\n\n        // Send the renter portion of the payment.\n        _safeTransfer(token, renter, renterAmount);\n    }\n\n    /**\n     * @dev Settles a payment by sending the full amount to one address.\n     *\n     * @param token    Token address for which to settle a payment.\n     * @param amount   Amount of the token to settle.\n     * @param settleTo Specifies whether to settle to the lender or the renter.\n     * @param lender   Lender account.\n     * @param renter   Renter account.\n     */\n    function _settlePaymentInFull(\n        address token,\n        uint256 amount,\n        SettleTo settleTo,\n        address lender,\n        address renter\n    ) internal {\n        // Determine the address that this payment will settle to.\n        address settleToAddress = settleTo == SettleTo.LENDER ? lender : renter;\n\n        // Send the payment.\n        _safeTransfer(token, settleToAddress, amount);\n    }\n\n    /**\n     * @dev Settles alls payments contained in the given item. Uses a pro-rata or in full\n     *      scheme depending on the order type and when the order was stopped.\n     *\n     * @param items     Items present in the order.\n     * @param orderType Type of the order.\n     * @param lender    Lender account.\n     * @param renter    Renter account.\n     * @param start     Timestamp that the rental began.\n     * @param end       Timestamp that the rental expires at.\n     */\n    function _settlePayment(\n        Item[] calldata items,\n        OrderType orderType,\n        address lender,\n        address renter,\n        uint256 start,\n        uint256 end\n    ) internal {\n        // Calculate the time values.\n        uint256 elapsedTime = block.timestamp - start;\n        uint256 totalTime = end - start;\n\n        // Determine whether the rental order has ended.\n        bool isRentalOver = elapsedTime >= totalTime;\n\n        // Loop through each item in the order.\n        for (uint256 i = 0; i < items.length; ++i) {\n            // Get the item.\n            Item memory item = items[i];\n\n            // Check that the item is a payment.\n            if (item.isERC20()) {\n                // Set a placeholder payment amount which can be reduced in the\n                // presence of a fee.\n                uint256 paymentAmount = item.amount;\n\n                // Take a fee on the payment amount if the fee is on.\n                if (fee != 0) {\n                    // Calculate the new fee.\n                    uint256 paymentFee = _calculateFee(paymentAmount);\n\n                    // Adjust the payment amount by the fee.\n                    paymentAmount -= paymentFee;\n                }\n\n                // Effect: Decrease the token balance. Use the payment amount pre-fee\n                // so that fees can be taken.\n                _decreaseDeposit(item.token, item.amount);\n\n                // If its a PAY order but the rental hasn't ended yet.\n                if (orderType.isPayOrder() && !isRentalOver) {\n                    // Interaction: a PAY order which hasnt ended yet. Payout is pro-rata.\n                    _settlePaymentProRata(\n                        item.token,\n                        paymentAmount,\n                        lender,\n                        renter,\n                        elapsedTime,\n                        totalTime\n                    );\n                }\n                // If its a PAY order and the rental is over, or, if its a BASE order.\n                else if (\n                    (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n                ) {\n                    // Interaction: a pay order or base order which has ended. Payout is in full.\n                    _settlePaymentInFull(\n                        item.token,\n                        paymentAmount,\n                        item.settleTo,\n                        lender,\n                        renter\n                    );\n                } else {\n                    revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Decreases the tracked token balance of a particular token on the payment\n     *      escrow contract.\n     *\n     * @param token  Token address.\n     * @param amount Amount to decrease the balance by.\n     */\n    function _decreaseDeposit(address token, uint256 amount) internal {\n        // Directly decrease the synced balance.\n        balanceOf[token] -= amount;\n    }\n\n    /**\n     * @dev Increases the tracked token balance of a particular token on the payment\n     *      escrow contract.\n     *\n     * @param token  Token address.\n     * @param amount Amount to increase the balance by.\n     */\n    function _increaseDeposit(address token, uint256 amount) internal {\n        // Directly increase the synced balance.\n        balanceOf[token] += amount;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Settles the payment for a rental order by transferring all items marked as\n     *         payments to their destination accounts. During the settlement process, if\n     *         active, a fee is taken on the payment.\n     *\n     * @param order Rental order for which to settle a payment.\n     */\n    function settlePayment(RentalOrder calldata order) external onlyByProxy permissioned {\n        // Settle all payments for the order.\n        _settlePayment(\n            order.items,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @notice Settles the payments for multiple orders by looping through each one.\n     *\n     * @param orders Rental ordesr for which to settle payments.\n     */\n    function settlePaymentBatch(\n        RentalOrder[] calldata orders\n    ) external onlyByProxy permissioned {\n        // Loop through each order.\n        for (uint256 i = 0; i < orders.length; ++i) {\n            // Settle all payments for the order.\n            _settlePayment(\n                orders[i].items,\n                orders[i].orderType,\n                orders[i].lender,\n                orders[i].renter,\n                orders[i].startTimestamp,\n                orders[i].endTimestamp\n            );\n        }\n    }\n\n    /**\n     * @notice When fungible tokens are transferred to the payment escrow contract,\n     *         their balances should be increased.\n     *\n     * @param token  Token address for the asset.\n     * @param amount Amount of the token transferred to the escrow\n     */\n    function increaseDeposit(\n        address token,\n        uint256 amount\n    ) external onlyByProxy permissioned {\n        // Cannot accept a payment of zero.\n        if (amount == 0) {\n            revert Errors.PaymentEscrow_ZeroPayment();\n        }\n\n        // Increase the deposit\n        _increaseDeposit(token, amount);\n    }\n\n    /**\n     * @notice Sets the numerator for the fee. The denominator will always be set at\n     *         10,000.\n     *\n     * @param feeNumerator Numerator of the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyByProxy permissioned {\n        // Cannot accept a fee numerator greater than 10000.\n        if (feeNumerator > 10000) {\n            revert Errors.PaymentEscrow_InvalidFeeNumerator();\n        }\n\n        // Set the fee.\n        fee = feeNumerator;\n    }\n\n    /**\n     * @notice Used to collect protocol fees. In addition, if funds are accidentally sent\n     *         to the payment escrow contract, this function can be used to skim them off.\n     *\n     * @param token Address of the token to skim.\n     * @param to    Address to send the collected tokens.\n     */\n    function skim(address token, address to) external onlyByProxy permissioned {\n        // Fetch the currently synced balance of the escrow.\n        uint256 syncedBalance = balanceOf[token];\n\n        // Fetch the true token balance of the escrow.\n        uint256 trueBalance = IERC20(token).balanceOf(address(this));\n\n        // Calculate the amount to skim.\n        uint256 skimmedBalance = trueBalance - syncedBalance;\n\n        // Send the difference to the specified address.\n        _safeTransfer(token, to, skimmedBalance);\n\n        // Emit event with fees taken.\n        emit Events.FeeTaken(token, skimmedBalance);\n    }\n\n    /**\n     * @notice Upgrades the contract to a different implementation. This implementation\n     *         contract must be compatible with ERC-1822 or else the upgrade will fail.\n     *\n     * @param newImplementation Address of the implementation contract to upgrade to.\n     */\n    function upgrade(address newImplementation) external onlyByProxy permissioned {\n        // _upgrade is implemented in the Proxiable contract.\n        _upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the contract which prevents upgrading the implementation contract.\n     *         There is no way to unfreeze once a contract has been frozen.\n     */\n    function freeze() external onlyByProxy permissioned {\n        // _freeze is implemented in the Proxiable contract.\n        _freeze();\n    }\n}"
    },
    {
      "filename": "src/policies/Create.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ZoneParameters} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\";\nimport {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {ZoneInterface} from \"@src/interfaces/IZone.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Zone} from \"@src/packages/Zone.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {\n    RentalOrder,\n    RentPayload,\n    SeaportPayload,\n    Hook,\n    OrderFulfillment,\n    OrderMetadata,\n    OrderType,\n    Item,\n    ItemType,\n    SettleTo,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\n\n/**\n * @title Create\n * @notice Acts as an interface for all behavior related to creating a rental.\n */\ncontract Create is Policy, Signer, Zone, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for SpentItem;\n    using RentalUtils for ReceivedItem;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentals.selector);\n        requests[1] = Permissions(toKeycode(\"ESCRW\"), ESCRW.increaseDeposit.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                              View Functions                                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Retrieves the domain separator.\n     *\n     * @return The domain separator for the protocol.\n     */\n    function domainSeparator() external view returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    /**\n     * @notice Derives the rental order EIP-712 compliant hash from a `RentalOrder`.\n     *\n     * @param order Rental order converted to a hash.\n     */\n    function getRentalOrderHash(\n        RentalOrder memory order\n    ) external view returns (bytes32) {\n        return _deriveRentalOrderHash(order);\n    }\n\n    /**\n     * @notice Derives the rent payload EIP-712 compliant hash from a `RentPayload`.\n     *\n     * @param payload Rent payload converted to a hash.\n     */\n    function getRentPayloadHash(\n        RentPayload memory payload\n    ) external view returns (bytes32) {\n        return _deriveRentPayloadHash(payload);\n    }\n\n    /**\n     * @notice Derives the order metadata EIP-712 compliant hash from an `OrderMetadata`.\n     *\n     * @param metadata Order metadata converted to a hash.\n     */\n    function getOrderMetadataHash(\n        OrderMetadata memory metadata\n    ) external view returns (bytes32) {\n        return _deriveOrderMetadataHash(metadata);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has started.\n     *\n     * @param order     Rental order to emit.\n     * @param orderHash Order hash of the seaport order.\n     * @param extraData Any extra data to be emitted which was supplied by the offerer.\n     */\n    function _emitRentalOrderStarted(\n        RentalOrder memory order,\n        bytes32 orderHash,\n        bytes memory extraData\n    ) internal {\n        // Emit the event.\n        emit Events.RentalOrderStarted(\n            orderHash,\n            extraData,\n            order.seaportOrderHash,\n            order.items,\n            order.hooks,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.rentalWallet,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a BASE order. All offer items must\n     *      adhere to the BASE order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processBaseOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal pure {\n        // Must be at least one offer item.\n        if (offers.length == 0) {\n            revert Errors.CreatePolicy_OfferCountZero();\n        }\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n\n        // Process each offer item.\n        for (uint256 i; i < offers.length; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                itemType = ItemType.ERC721;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                itemType = ItemType.ERC1155;\n            }\n            // ERC20s are not supported as offer items in a BASE order.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // An ERC721 or ERC1155 offer item is considered a rented asset which will be\n            // returned to the lender upon expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: SettleTo.LENDER,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a PAY order. All offer items must\n     *      adhere to the PAY order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processPayOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal pure {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n        SettleTo settleTo;\n\n        // Process each offer item.\n        for (uint256 i; i < offers.length; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                // The ERC721 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC721;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                // The ERC1155 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC1155;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Process an ERC20 offer item.\n            else if (offer.isERC20()) {\n                // An ERC20 offer item is considered a payment to the renter upon\n                // expiration of the rental order.\n                itemType = ItemType.ERC20;\n                settleTo = SettleTo.RENTER;\n\n                // Increment payments.\n                totalPayments++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // Create the item.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: settleTo,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n\n        // PAY order offer must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a BASE order. All\n     *      consideration items must adhere to the BASE order format, else\n     *      execution will revert.\n     *\n     * @param rentalItems    Running array of items that comprise the rental order.\n     * @param considerations Array of consideration items to include in the the order.\n     * @param startIndex     Index to begin adding the offer items to the\n     *                       `rentalItems` array.\n     */\n    function _processBaseOrderConsideration(\n        Item[] memory rentalItems,\n        ReceivedItem[] memory considerations,\n        uint256 startIndex\n    ) internal pure {\n        // Must be at least one consideration item.\n        if (considerations.length == 0) {\n            revert Errors.CreatePolicy_ConsiderationCountZero();\n        }\n\n        // Process each consideration item.\n        for (uint256 i; i < considerations.length; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Only process an ERC20 item.\n            if (!consideration.isERC20()) {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n\n            // An ERC20 consideration item is considered a payment to the lender upon\n            // expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: ItemType.ERC20,\n                settleTo: SettleTo.LENDER,\n                token: consideration.token,\n                amount: consideration.amount,\n                identifier: consideration.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a PAYEE order. All\n     *      consideration items must adhere to the PAYEE order format, else\n     *      execution will revert.\n     *\n     * @param considerations Array of consideration items to include in the the order.\n     */\n    function _processPayeeOrderConsideration(\n        ReceivedItem[] memory considerations\n    ) internal pure {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Process each consideration item.\n        for (uint256 i; i < considerations.length; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Process an ERC20 item.\n            if (consideration.isERC20()) {\n                totalPayments++;\n            }\n            // Process an ERC721 or ERC1155 consideration item.\n            else if (consideration.isRental()) {\n                totalRentals++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n        }\n\n        // PAYEE order consideration must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Converts an offer array and a consideration array into a single array of\n     *      `Item` which comprise a rental order. The offers and considerations must\n     *      adhere to a specific set of rules depending on the type of order being\n     *      constructed.\n     *\n     * @param offers         Array of Seaport offer items.\n     * @param considerations Array of seaport consideration items.\n     * @param orderType      Order type of the rental.\n     */\n    function _convertToItems(\n        SpentItem[] memory offers,\n        ReceivedItem[] memory considerations,\n        OrderType orderType\n    ) internal pure returns (Item[] memory items) {\n        // Initialize an array of items.\n        items = new Item[](offers.length + considerations.length);\n\n        // Process items for a base order.\n        if (orderType.isBaseOrder()) {\n            // Process offer items.\n            _processBaseOrderOffer(items, offers, 0);\n\n            // Process consideration items.\n            _processBaseOrderConsideration(items, considerations, offers.length);\n        }\n        // Process items for a pay order.\n        else if (orderType.isPayOrder()) {\n            // Process offer items.\n            _processPayOrderOffer(items, offers, 0);\n\n            // Assert that no consideration items are provided.\n            if (considerations.length > 0) {\n                revert Errors.CreatePolicy_ConsiderationCountNonZero(\n                    considerations.length\n                );\n            }\n        }\n        // Process items for a payee order.\n        else if (orderType.isPayeeOrder()) {\n            // Assert that no offer items are provided.\n            if (offers.length > 0) {\n                revert Errors.CreatePolicy_OfferCountNonZero(offers.length);\n            }\n\n            // Process consideration items.\n            _processPayeeOrderConsideration(considerations);\n        }\n        // Revert if order type is not supported.\n        else {\n            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n        }\n    }\n\n    /**\n     * @dev When a rental order is created, process each hook one by one but only if\n     *      the hook's status is set to execute on a rental start.\n     *\n     * @param hooks        Arr"
    }
  ]
}