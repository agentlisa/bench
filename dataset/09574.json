{
  "Title": "[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy",
  "Content": "_Submitted by 0xDjango_\n\n[NFTLoanFacilitator.sol#L214-L221](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L214-L221)<br>\n[NFTLoanFacilitator.sol#L230-L250](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L230-L250)\n\nIf borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.\n\n### Proof of Concept\n\nThis exploit requires that the `loanAssetContractAddress` token transfers control to the receiver.\n\n#### Steps of exploit:\n\n*   Borrower creates loan with `createLoan()`.\n*   The same Borrower calls `lend()`, funding their own loan. The Borrower receives the lend ticket, and funds are transferred to themself.\n*   A new lender attempts to buy out the loan. The original loan amount + accruedInterest are sent to the original lender (same person as borrower).\n*   Due to lack of checks-effects-interactions pattern, the borrower is able to immediately call `repayAndCloseLoan()` before the lend ticket is transferred to the new lender.\n\nThe following code illustrates that the new lender sends funds to the original lender prior to receiving the lend ticket in return.\n```solidity\n} else {\n    ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n        msg.sender,\n        currentLoanOwner,\n        accumulatedInterest + previousLoanAmount\n    );\n}\nILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n```\n\n```solidity\nThe original lender/borrower calls the following `repayAndCloseLoan()` function so that they receive their collateral NFT from the protocol.\n\nfunction repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n    Loan storage loan = loanInfo[loanId];\n\n\n    uint256 interest = _interestOwed(\n        loan.loanAmount,\n        loan.lastAccumulatedTimestamp,\n        loan.perAnumInterestRate,\n        loan.accumulatedInterest\n    );\n    address lender = IERC721(lendTicketContract).ownerOf(loanId);\n    loan.closed = true;\n    ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n    IERC721(loan.collateralContractAddress).safeTransferFrom(\n        address(this),\n        IERC721(borrowTicketContract).ownerOf(loanId),\n        loan.collateralTokenId\n    );\n\n\n    emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n    emit Close(loanId);\n}\n```\n\nFinally, the new lender receives the lend ticket that has no utility at this point. The borrower now possesses the NFT, original loan amount, and accrued interest.\n\n### Recommended Mitigation Steps\n\nMove the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely.\n\nIf desired, also require that the lender cannot be the same account as the borrower of a loan.\n\n**[wilsoncusack (Backed Protocol) confirmed and commented](https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1091968833):**\n > Borrower would need to convince lender to use an ERC20 with this malicious callback, but yes is legit.\n>\n > malicious ERC20<br>\n> -> transfers value to borrow ticket holder<br>\n> -> calls repay and close loan (would need funds available to do so, but still nets up)\n\n**[wilsoncusack (Backed Protocol) commented](https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1092334816):**\n > Possibility of an ERC777 loan asset warrants this as high, I think. Even though the warden didn't suggest that vector.\n\n**[wilsoncusack (Backed Protocol) commented](https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1092724315):**\n > Scratch that, I think ERC777 not possible because our contract isn't setup to receive them.\n\n**[wilsoncusack (Backed Protocol) commented](https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1092733859):**\n > er erc777 does work because reception ack is not needed in the normal case.\n\n**[wilsoncusack (Backed Protocol) resolved](https://github.com/code-423n4/2022-04-backed-findings/issues/85#event-6430345280)**\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-04-backed-findings/issues/85#issuecomment-1100148955):**\n > Sponsor confirmed.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-04-backed-protocol-contest",
  "Code": [
    {
      "filename": "contracts/NFTLoanFacilitator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeTransferLib, ERC20} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';\nimport {IERC721Mintable} from './interfaces/IERC721Mintable.sol';\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\n\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n\n    // ==== constants ====\n\n    /** \n     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     \n     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%\n     */\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n\n    /// See {INFTLoanFacilitator-SCALAR}.\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n\n    \n    // ==== state variables ====\n\n    /// See {INFTLoanFacilitator-originationFeeRate}.\n    /// @dev starts at 1%\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n\n    /// See {INFTLoanFacilitator-requiredImprovementRate}.\n    /// @dev starts at 10%\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n\n    /// See {INFTLoanFacilitator-lendTicketContract}.\n    address public override lendTicketContract;\n\n    /// See {INFTLoanFacilitator-borrowTicketContract}.\n    address public override borrowTicketContract;\n\n    /// See {INFTLoanFacilitator-loanInfo}.\n    mapping(uint256 => Loan) public loanInfo;\n\n    /// @dev tracks loan count\n    uint256 private _nonce = 1;\n\n    \n    // ==== modifiers ====\n\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n        _; \n    }\n\n\n    // ==== constructor ====\n\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n\n    \n    // ==== state changing external functions ====\n\n    /// See {INFTLoanFacilitator-createLoan}.\n    function createLoan(\n        uint256 collateralTokenId,\n        address collateralContractAddress,\n        uint16 maxPerAnumInterest,\n        uint128 minLoanAmount,\n        address loanAssetContractAddress,\n        uint32 minDurationSeconds,\n        address mintBorrowTicketTo\n    )\n        external\n        override\n        returns (uint256 id) \n    {\n        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');\n        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');\n        require(collateralContractAddress != lendTicketContract,\n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        require(collateralContractAddress != borrowTicketContract, \n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        \n        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);\n\n        unchecked {\n            id = _nonce++;\n        }\n\n        Loan storage loan = loanInfo[id];\n        loan.loanAssetContractAddress = loanAssetContractAddress;\n        loan.loanAmount = minLoanAmount;\n        loan.collateralTokenId = collateralTokenId;\n        loan.collateralContractAddress = collateralContractAddress;\n        loan.perAnumInterestRate = maxPerAnumInterest;\n        loan.durationSeconds = minDurationSeconds;\n        \n        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);\n        emit CreateLoan(\n            id,\n            msg.sender,\n            collateralTokenId,\n            collateralContractAddress,\n            maxPerAnumInterest,\n            loanAssetContractAddress,\n            minLoanAmount,\n            minDurationSeconds\n        );\n    }\n\n    /// See {INFTLoanFacilitator-closeLoan}.\n    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,\n        \"NFTLoanFacilitator: borrow ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");\n        \n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-lend}.\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            address loanAssetContractAddress = loan.loanAssetContractAddress;\n            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");\n\n            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');\n            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');\n            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');\n        \n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n\n            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;\n            ERC20(loanAssetContractAddress).safeTransfer(\n                IERC721(borrowTicketContract).ownerOf(loanId),\n                amount - facilitatorTake\n            );\n            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            // will underflow if amount < previousAmount\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n\n                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n\n    /// See {INFTLoanFacilitator-repayAndCloseLoan}.\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-seizeCollateral}.\n    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, \n        \"NFTLoanFacilitator: lend ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,\n        \"NFTLoanFacilitator: payment is not late\");\n\n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            sendCollateralTo,\n            loan.collateralTokenId\n        );\n\n        emit SeizeCollateral(loanId);\n        emit Close(loanId);\n    }\n\n    \n    // === owner state changing ===\n\n    /**\n     * @notice Sets lendTicketContract to _contract\n     * @dev cannot be set if lendTicketContract is already set\n     */\n    function setLendTicketContract(address _contract) external onlyOwner {\n        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        lendTicketContract = _contract;\n    }\n\n    /**\n     * @notice Sets borrowTicketContract to _contract\n     * @dev cannot be set if borrowTicketContract is already set\n     */\n    function setBorrowTicketContract(address _contract) external onlyOwner {\n        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        borrowTicketContract = _contract;\n    }\n\n    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`\n    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {\n        ERC20(asset).safeTransfer(to, amount);\n\n        emit WithdrawOriginationFees(asset, amount, to);\n    }\n\n    /**\n     * @notice Updates originationFeeRate the faciliator keeps of each loan amount\n     * @dev Cannot be set higher than 5%\n     */\n    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {\n        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");\n        \n        originationFeeRate = _originationFeeRate;\n\n        emit UpdateOriginationFeeRate(_originationFeeRate);\n    }\n\n    /**\n     * @notice updates the percent improvement required of at least one loan term when buying out lender \n     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount\n     * must be 10% higher or interest rate must be 10% lower. \n     * @dev Cannot be 0.\n     */\n    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {\n        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');\n\n        requiredImprovementRate = _improvementRate;\n\n        emit UpdateRequiredImprovementRate(_improvementRate);\n    }\n\n    \n    // ==== external view ====\n\n    /// See {INFTLoanFacilitator-loanInfoStruct}.\n    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {\n        return loanInfo[loanId];\n    }\n\n    /// See {INFTLoanFacilitator-totalOwed}.\n    function totalOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return loanInfo[loanId].loanAmount + _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-interestOwed}.\n    function interestOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-loanEndSeconds}.\n    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        return loan.durationSeconds + loan.lastAccumulatedTimestamp;\n    }\n\n    \n    // === private ===\n\n    /// @dev Returns the total interest owed on loan\n    function _interestOwed(\n        uint256 loanAmount,\n        uint256 lastAccumulatedTimestamp,\n        uint256 perAnumInterestRate,\n        uint256 accumulatedInterest\n    ) \n        internal \n        view \n        returns (uint256) \n    {\n        return loanAmount\n            * (block.timestamp - lastAccumulatedTimestamp)\n            * (perAnumInterestRate * 1e18 / 365 days)\n            / 1e21 // SCALAR * 1e18\n            + accumulatedInterest;\n    }\n}"
    },
    {
      "filename": "contracts/NFTLoanFacilitator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeTransferLib, ERC20} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';\nimport {IERC721Mintable} from './interfaces/IERC721Mintable.sol';\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\n\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n\n    // ==== constants ====\n\n    /** \n     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     \n     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%\n     */\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n\n    /// See {INFTLoanFacilitator-SCALAR}.\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n\n    \n    // ==== state variables ====\n\n    /// See {INFTLoanFacilitator-originationFeeRate}.\n    /// @dev starts at 1%\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n\n    /// See {INFTLoanFacilitator-requiredImprovementRate}.\n    /// @dev starts at 10%\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n\n    /// See {INFTLoanFacilitator-lendTicketContract}.\n    address public override lendTicketContract;\n\n    /// See {INFTLoanFacilitator-borrowTicketContract}.\n    address public override borrowTicketContract;\n\n    /// See {INFTLoanFacilitator-loanInfo}.\n    mapping(uint256 => Loan) public loanInfo;\n\n    /// @dev tracks loan count\n    uint256 private _nonce = 1;\n\n    \n    // ==== modifiers ====\n\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n        _; \n    }\n\n\n    // ==== constructor ====\n\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n\n    \n    // ==== state changing external functions ====\n\n    /// See {INFTLoanFacilitator-createLoan}.\n    function createLoan(\n        uint256 collateralTokenId,\n        address collateralContractAddress,\n        uint16 maxPerAnumInterest,\n        uint128 minLoanAmount,\n        address loanAssetContractAddress,\n        uint32 minDurationSeconds,\n        address mintBorrowTicketTo\n    )\n        external\n        override\n        returns (uint256 id) \n    {\n        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');\n        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');\n        require(collateralContractAddress != lendTicketContract,\n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        require(collateralContractAddress != borrowTicketContract, \n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        \n        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);\n\n        unchecked {\n            id = _nonce++;\n        }\n\n        Loan storage loan = loanInfo[id];\n        loan.loanAssetContractAddress = loanAssetContractAddress;\n        loan.loanAmount = minLoanAmount;\n        loan.collateralTokenId = collateralTokenId;\n        loan.collateralContractAddress = collateralContractAddress;\n        loan.perAnumInterestRate = maxPerAnumInterest;\n        loan.durationSeconds = minDurationSeconds;\n        \n        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);\n        emit CreateLoan(\n            id,\n            msg.sender,\n            collateralTokenId,\n            collateralContractAddress,\n            maxPerAnumInterest,\n            loanAssetContractAddress,\n            minLoanAmount,\n            minDurationSeconds\n        );\n    }\n\n    /// See {INFTLoanFacilitator-closeLoan}.\n    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,\n        \"NFTLoanFacilitator: borrow ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");\n        \n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-lend}.\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            address loanAssetContractAddress = loan.loanAssetContractAddress;\n            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");\n\n            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');\n            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');\n            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');\n        \n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n\n            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;\n            ERC20(loanAssetContractAddress).safeTransfer(\n                IERC721(borrowTicketContract).ownerOf(loanId),\n                amount - facilitatorTake\n            );\n            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            // will underflow if amount < previousAmount\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n\n                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n\n    /// See {INFTLoanFacilitator-repayAndCloseLoan}.\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-seizeCollateral}.\n    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, \n        \"NFTLoanFacilitator: lend ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,\n        \"NFTLoanFacilitator: payment is not late\");\n\n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            sendCollateralTo,\n            loan.collateralTokenId\n        );\n\n        emit SeizeCollateral(loanId);\n        emit Close(loanId);\n    }\n\n    \n    // === owner state changing ===\n\n    /**\n     * @notice Sets lendTicketContract to _contract\n     * @dev cannot be set if lendTicketContract is already set\n     */\n    function setLendTicketContract(address _contract) external onlyOwner {\n        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        lendTicketContract = _contract;\n    }\n\n    /**\n     * @notice Sets borrowTicketContract to _contract\n     * @dev cannot be set if borrowTicketContract is already set\n     */\n    function setBorrowTicketContract(address _contract) external onlyOwner {\n        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        borrowTicketContract = _contract;\n    }\n\n    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`\n    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {\n        ERC20(asset).safeTransfer(to, amount);\n\n        emit WithdrawOriginationFees(asset, amount, to);\n    }\n\n    /**\n     * @notice Updates originationFeeRate the faciliator keeps of each loan amount\n     * @dev Cannot be set higher than 5%\n     */\n    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {\n        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");\n        \n        originationFeeRate = _originationFeeRate;\n\n        emit UpdateOriginationFeeRate(_originationFeeRate);\n    }\n\n    /**\n     * @notice updates the percent improvement required of at least one loan term when buying out lender \n     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount\n     * must be 10% higher or interest rate must be 10% lower. \n     * @dev Cannot be 0.\n     */\n    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {\n        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');\n\n        requiredImprovementRate = _improvementRate;\n\n        emit UpdateRequiredImprovementRate(_improvementRate);\n    }\n\n    \n    // ==== external view ====\n\n    /// See {INFTLoanFacilitator-loanInfoStruct}.\n    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {\n        return loanInfo[loanId];\n    }\n\n    /// See {INFTLoanFacilitator-totalOwed}.\n    function totalOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return loanInfo[loanId].loanAmount + _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-interestOwed}.\n    function interestOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-loanEndSeconds}.\n    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        return loan.durationSeconds + loan.lastAccumulatedTimestamp;\n    }\n\n    \n    // === private ===\n\n    /// @dev Returns the total interest owed on loan\n    function _interestOwed(\n        uint256 loanAmount,\n        uint256 lastAccumulatedTimestamp,\n        uint256 perAnumInterestRate,\n        uint256 accumulatedInterest\n    ) \n        internal \n        view \n        returns (uint256) \n    {\n        return loanAmount\n            * (block.timestamp - lastAccumulatedTimestamp)\n            * (perAnumInterestRate * 1e18 / 365 days)\n            / 1e21 // SCALAR * 1e18\n            + accumulatedInterest;\n    }\n}"
    }
  ]
}