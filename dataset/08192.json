{
  "Title": "[H-02] Delegators can Avoid Lock Commitments if they can Reliably get Themselves Blocked when Needed",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L526-L625\n\n\n# Vulnerability details\n\n## Impact\nUsers can enjoy the voting power of long lock times whilst not committing their tokens. This could cause the entire system to break down as the incentives don't work any more.\n\n## Exploit Method\nThis exploit only works if a user is able to use the system and reliably get themselves blocked. Blocking policies are not in scope, so I am assuming there would be a list of bannable offences, and thus this condition could be fulfilled.\nConsider a user with two accounts, called Rider and Horse.\nRider has 100,000 tokens.\nHorse has 1 token.\nRider is a smart contract (required for an account to be bannable).\nRider locks for 1 week.\nHorse locks for 52 weeks.\nRider delegates to Horse.\nHorse can continue to extend its lock period and enjoy the maximised voting power.\nWhenever the user wants their tokens back, they simply need to get the Rider account blocked.\nWhen Rider is blocked, `Blocklist.block(RiderAddress)` is called, which in turn calls `ve.forceUndelegate(RiderAddress)`.\nRider is now an undelegated account with an expired lock. It can call `ve.withdraw()` to get its tokens back.\nThe user can repeat this process with a fresh account taking the role of Rider.\n\n## Recommended Mitigation Steps\n`forceUndelegate()` could be made to set `locked_.end = fromLocked.end`. This would mean that blocked users are still locked into the system for the period they delegated for. However, this does have the downside of tokens being locked in the system without the full rights of the system which other users enjoy.\nAlternatively, this might be addressable through not blocking users that seem to be doing this, but of course that might have other undersirable consequences.\n\n## Proof of Concept\n```diff\ndiff --git a/test/votingEscrowTest.ts b/test/votingEscrowBlockMeTest.ts\nindex 7d3163d..ed27155 100644\n--- a/test/votingEscrowTest.ts\n+++ b/test/votingEscrowBlockMeTest.ts\n@@ -25,7 +25,7 @@ describe(\"VotingEscrow Tests\", function () {\n   let fdtMock: MockERC20;\n   let contract: MockSmartWallet;\n   let contract2: MockSmartWallet; // ADD TEST FOR 0 BALANCES\n-  let contract3: MockSmartWallet;\n+  let rider: MockSmartWallet;\n   let admin: SignerWithAddress;\n   let treasury: SignerWithAddress;\n   const maxPenalty = utils.parseEther(\"1\");\n@@ -36,6 +36,7 @@ describe(\"VotingEscrow Tests\", function () {\n   let charlie: SignerWithAddress;\n   let david: SignerWithAddress;\n   let eve: SignerWithAddress;\n+  let horse: SignerWithAddress;\n   const initialFDTuserBal = utils.parseEther(\"1000\");\n   const lockAmount = utils.parseEther(\"100\");\n   let tx;\n@@ -57,7 +58,7 @@ describe(\"VotingEscrow Tests\", function () {\n     await createSnapshot(provider);\n \n     signers = await ethers.getSigners();\n-    [admin, alice, bob, charlie, david, eve, treasury] = signers;\n+    [admin, alice, bob, charlie, david, eve, treasury, horse] = signers;\n \n     // Deploy FDT contract\n     const fdtMockDeployer = await ethers.getContractFactory(\"MockERC20\", admin);\n@@ -69,6 +70,7 @@ describe(\"VotingEscrow Tests\", function () {\n     await fdtMock.mint(charlie.address, initialFDTuserBal);\n     await fdtMock.mint(david.address, initialFDTuserBal);\n     await fdtMock.mint(eve.address, initialFDTuserBal);\n+    await fdtMock.mint(horse.address, initialFDTuserBal);\n \n     // Deploy VE contract\n     const veDeployer = await ethers.getContractFactory(\"VotingEscrow\", admin);\n@@ -96,6 +98,7 @@ describe(\"VotingEscrow Tests\", function () {\n     await fdtMock.setAllowance(charlie.address, ve.address, MAX);\n     await fdtMock.setAllowance(david.address, ve.address, MAX);\n     await fdtMock.setAllowance(eve.address, ve.address, MAX);\n+    await fdtMock.setAllowance(horse.address, ve.address, MAX);\n \n     // Deploy malicious contracts\n     const contractDeployer = await ethers.getContractFactory(\n@@ -108,8 +111,8 @@ describe(\"VotingEscrow Tests\", function () {\n     contract2 = await contractDeployer.deploy(fdtMock.address);\n     await fdtMock.mint(contract2.address, initialFDTuserBal);\n \n-    contract3 = await contractDeployer.deploy(fdtMock.address);\n-    await fdtMock.mint(contract3.address, initialFDTuserBal);\n+    rider = await contractDeployer.deploy(fdtMock.address);\n+    await fdtMock.mint(rider.address, initialFDTuserBal);\n   });\n   after(async () => {\n     await restoreSnapshot(provider);\n@@ -139,722 +142,54 @@ describe(\"VotingEscrow Tests\", function () {\n     });\n   });\n \n-  describe(\"Blocklist checker\", async () => {\n-    it(\"Blocklist EOA fails\", async () => {\n+  describe(\"C4 POCs\", async () => {\n+    it(\"Rider locks many tokens for a week.\", async () => {\n       await createSnapshot(provider);\n+      const smallLockTime = 1 * WEEK + (await getTimestamp());\n \n-      expect(await blocklist.isBlocked(alice.address)).to.equal(false);\n-      expect(await blocklist.isBlocked(bob.address)).to.equal(false);\n-\n-      tx = blocklist.block(alice.address);\n-      await expect(tx).to.be.revertedWith(\"Only contracts\");\n-    });\n-\n-    it(\"Blocklist contract succeeds\", async () => {\n-      const lockTime = 4 * WEEK + (await getTimestamp());\n-\n-      expect(await blocklist.isBlocked(contract.address)).to.equal(false);\n-      await contract.createLock(ve.address, lockAmount, lockTime);\n-\n-      await blocklist.block(contract2.address);\n-      expect(await blocklist.isBlocked(contract2.address)).to.equal(true);\n-    });\n-\n-    it(\"Only owner can blocklist\", async () => {\n-      tx = blocklist.connect(bob).block(contract.address);\n-      await expect(tx).to.be.revertedWith(\"Only manager\");\n-\n-      await restoreSnapshot(provider);\n-    });\n-  });\n-\n-  describe(\"EOA flow\", async () => {\n-    it(\"Alice and Bob lock FDT in ve\", async () => {\n-      await createSnapshot(provider);\n-      const lockTime = 4 * WEEK + (await getTimestamp());\n-\n-      await ve.connect(alice).createLock(lockAmount, lockTime);\n-\n-      await ve.connect(bob).createLock(lockAmount, lockTime);\n-    });\n-\n-    it(\"Alice and Bob attempt to withdraw before lock end, fail\", async () => {\n-      tx = ve.connect(alice).withdraw();\n-      await expect(tx).to.be.revertedWith(\"Lock not expired\");\n-\n-      tx = ve.connect(bob).withdraw();\n-      await expect(tx).to.be.revertedWith(\"Lock not expired\");\n-    });\n-\n-    it(\"Alice attempts to quit lock, succeeds with penalty\", async () => {\n-      // Increase time to 2 weeks to lock end\n-      await increaseTimeTo((await ve.lockEnd(alice.address)).sub(WEEK * 2));\n-      await ve.connect(alice).quitLock();\n-\n-      // Penalty is ~ 3.84% (2/52*100)\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(alice.address),\n-        initialFDTuserBal.sub(lockAmount.mul(2).div(MAXTIME)),\n-        \"0.4\"\n-      );\n-    });\n-\n-    it(\"Check accumulated penalty and collect\", async () => {\n-      const lockAmount = utils.parseEther(\"100\");\n-      expect(await ve.penaltyAccumulated()).gt(0);\n-\n-      const penaltyAccumulated = await ve.penaltyAccumulated();\n-\n-      await ve.collectPenalty();\n-\n-      expect(await ve.penaltyAccumulated()).to.equal(0);\n-\n-      expect(await fdtMock.balanceOf(treasury.address)).to.equal(\n-        penaltyAccumulated\n-      );\n-    });\n-\n-    it(\"Bob increase his unlock time\", async () => {\n-      const lockTime = 10 * WEEK + (await getTimestamp());\n-      await ve.connect(bob).increaseUnlockTime(lockTime);\n-    });\n-\n-    it(\"Alice locks again after locked expired, succeed\", async () => {\n-      await increaseTime(5 * WEEK);\n-      const lockTime = 4 * WEEK + (await getTimestamp());\n-      await ve.connect(alice).createLock(lockAmount, lockTime);\n-    });\n-\n-    it(\"Admin unlocks ve contracts\", async () => {\n-      tx = ve.connect(alice).withdraw();\n-      await expect(tx).to.be.revertedWith(\"Lock not expired\");\n-\n-      await ve.unlock();\n-\n-      expect(await ve.maxPenalty()).to.equal(0);\n-    });\n-\n-    it(\"Alice and Bob attempt to quit lock, succeeds without penalty\", async () => {\n-      await ve.connect(alice).quitLock();\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(alice.address),\n-        initialFDTuserBal.sub(lockAmount.mul(2).div(MAXTIME)),\n-        \"0.4\"\n-      );\n-\n-      await ve.connect(bob).quitLock();\n-      expect(await fdtMock.balanceOf(bob.address)).to.equal(initialFDTuserBal); // because bob did not quit lock previously but deposited twice\n-\n-      expect(await ve.penaltyAccumulated()).to.equal(0);\n-\n-      await restoreSnapshot(provider);\n-    });\n-  });\n-\n-  describe(\"Malicious contracts flow\", async () => {\n-    it(\"2 contracts lock FDT in ve\", async () => {\n-      await createSnapshot(provider);\n-\n-      const lockTime = 4 * WEEK + (await getTimestamp());\n-\n-      // contract 1\n-      await contract.createLock(ve.address, lockAmount, lockTime);\n-      expect(await ve.balanceOf(contract.address)).not.eq(0);\n-      expect(await ve.balanceOfAt(contract.address, await getBlock())).not.eq(\n-        0\n-      );\n-\n-      // contract 2\n-      await contract2.createLock(ve.address, lockAmount, lockTime);\n-      expect(await ve.balanceOf(contract2.address)).not.eq(0);\n-      expect(await ve.balanceOfAt(contract2.address, await getBlock())).not.eq(\n-        0\n-      );\n-    });\n-\n-    it(\"Blocklisted contract CANNOT increase amount of tokens\", async () => {\n-      // = await Deployer.deploy(ve.address);\n-      await blocklist.block(contract.address);\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-\n-      await expect(\n-        contract.increaseAmount(ve.address, lockAmount)\n-      ).to.be.revertedWith(\"Blocked contract\");\n-\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-    });\n-\n-    it(\"Blocklisted contract CANNOT increase locked time\", async () => {\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-\n-      await expect(\n-        contract.increaseUnlockTime(\n-          ve.address,\n-          (await getTimestamp()) + 10 * WEEK\n-        )\n-      ).to.be.revertedWith(\"Blocked contract\");\n-\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-    });\n-\n-    it(\"Blocklisted contract can quit lock\", async () => {\n-      await increaseTime(ONE_WEEK);\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-\n-      await contract.quitLock(ve.address);\n-\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(contract.address),\n-        initialFDTuserBal.sub(lockAmount.mul(2 * WEEK).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-      // expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-      //   initialFDTuserBal.sub(lockAmount.div(2))\n-      // );\n-    });\n-\n-    it(\"Admin unlocks ve contracts\", async () => {\n-      await ve.unlock();\n-\n-      expect(await ve.maxPenalty()).to.equal(0);\n-    });\n-\n-    it(\"Allowed contract can quit lock without penalty\", async () => {\n-      // not blocklisted contract\n-      await contract2.quitLock(ve.address);\n-      expect(await fdtMock.balanceOf(contract2.address)).to.equal(\n-        initialFDTuserBal\n-      );\n-\n-      await restoreSnapshot(provider);\n-    });\n-  });\n-\n-  describe(\"Blocked contracts undelegation\", async () => {\n-    it(\"2contracts lock FDT in ve\", async () => {\n-      await createSnapshot(provider);\n-\n-      const lockTime = 4 * WEEK + (await getTimestamp());\n-      const lockTime2 = 2 * WEEK + (await getTimestamp());\n-      // contract 1\n-      await contract.createLock(ve.address, lockAmount, lockTime);\n-      expect(await ve.balanceOf(contract.address)).not.eq(0);\n-      expect(await ve.balanceOfAt(contract.address, await getBlock())).not.eq(\n-        0\n-      );\n-\n-      // contract 2\n-      await contract2.createLock(ve.address, lockAmount, lockTime);\n-      expect(await ve.balanceOf(contract2.address)).not.eq(0);\n-      expect(await ve.balanceOfAt(contract2.address, await getBlock())).not.eq(\n-        0\n-      );\n-      // contract 3\n-      await contract3.createLock(ve.address, lockAmount, lockTime);\n-      expect(await ve.balanceOf(contract3.address)).not.eq(0);\n-      expect(await ve.balanceOfAt(contract3.address, await getBlock())).not.eq(\n-        0\n-      );\n-    });\n-\n-    it(\"Admin blocklists malicious contracts\", async () => {\n-      // contract 2 delegates first\n-      await contract2.delegate(ve.address, contract.address);\n-      await blocklist.block(contract2.address);\n+      await rider.createLock(ve.address, initialFDTuserBal, smallLockTime);\n     });\n+    it(\"Horse locks a billionth of a token for max time.\", async () => {\n+      const bigLockTime = 52 * WEEK + (await getTimestamp());\n \n-    it(\"Blocked contract gets UNDELEGATED\", async () => {\n-      await contract.delegate(ve.address, contract3.address);\n-      expect((await ve.locked(contract.address)).delegatee).to.equal(\n-        contract3.address\n-      );\n-      await blocklist.block(contract.address);\n-      expect((await ve.locked(contract.address)).delegatee).to.equal(\n-        contract.address\n-      );\n-    });\n-\n-    it(\"CANNOT delegate to a blocked Contract\", async () => {\n-      // contract 3  cannot delegate to contract\n-      await expect(\n-        contract3.delegate(ve.address, contract.address)\n-      ).to.be.revertedWith(\"Blocked contract\");\n-      await blocklist.block(contract2.address);\n-    });\n-\n-    it(\"Blocked contract CANNOT delegate to another user\", async () => {\n-      //contract 3 is not blocked\n-      expect(await blocklist.isBlocked(contract3.address)).to.equal(false);\n-      // contract 1 is blocked\n-      await expect(\n-        contract.delegate(ve.address, contract3.address)\n-      ).to.be.revertedWith(\"Blocked contract\");\n-    });\n-\n-    it(\"Blocked contract is already undelegated\", async () => {\n-      expect((await ve.locked(contract.address)).delegatee).to.equal(\n-        contract.address\n-      );\n-      // contract 1 is blocked\n-      await expect(\n-        contract.delegate(ve.address, contract.address)\n-      ).to.be.revertedWith(\"Blocked contract\");\n-    });\n-\n-    it(\"Blocklisted contract CANNOT increase amount of tokens\", async () => {\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-\n-      await expect(\n-        contract.increaseAmount(ve.address, lockAmount)\n-      ).to.be.revertedWith(\"Blocked contract\");\n-\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n+      await ve.connect(horse).createLock(1_000_000_000, bigLockTime);\n     });\n-\n-    it(\"Blocklisted contract CANNOT increase locked time\", async () => {\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-\n-      await expect(\n-        contract.increaseUnlockTime(\n-          ve.address,\n-          (await getTimestamp()) + 10 * WEEK\n-        )\n-      ).to.be.revertedWith(\"Blocked contract\");\n-\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-    });\n-\n-    it(\"Blocklisted contract can quit lock\", async () => {\n-      await increaseTime(ONE_WEEK);\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-\n-      await contract.quitLock(ve.address);\n-\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(contract.address),\n-        initialFDTuserBal.sub(lockAmount.mul(2 * WEEK).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-    });\n-    it(\"Blocked contracts can withdraw\", async () => {\n-      await increaseTime(ONE_WEEK.mul(10));\n-      // blocked contract can still\n-      await contract2.withdraw(ve.address);\n-\n-      await restoreSnapshot(provider);\n-    });\n-  });\n-\n-  describe(\"Delegation flow\", async () => {\n-    it(\"Alice creates a lock\", async () => {\n-      await createSnapshot(provider);\n-\n-      const lockTime = 4 * WEEK + (await getTimestamp());\n-\n-      await ve.connect(alice).createLock(lockAmount, lockTime);\n-\n-      const block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.above(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-    });\n-\n-    it(\"Bob creates a lock, Alice delegates to Bob\", async () => {\n-      const lockTime = 5 * WEEK + (await getTimestamp());\n-\n-      // pre lock balances\n-      let block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.above(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-\n-      // bob creates lock\n-      await ve.connect(bob).createLock(lockAmount, lockTime);\n-\n-      block = await getBlock();\n-      const preBalance = await ve.balanceOfAt(bob.address, block);\n-      expect(preBalance).to.above(0);\n-\n-      // alice delegates\n-      await ve.connect(alice).delegate(bob.address);\n-\n-      // post lock balances\n-      block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.above(preBalance);\n-    });\n-\n-    it(\"Bob extends his lock beyond Alice's lock, succeeds\", async () => {\n-      const lockTime = 6 * WEEK + (await getTimestamp());\n-\n+    it(\"Rider delegates to Horse, increasing its voting power\", async () => {\n       // pre delegation balances\n       let block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0);\n-      const preBalance = await ve.balanceOfAt(bob.address, block);\n+      const preBalance = await ve.balanceOfAt(horse.address, block);\n       expect(preBalance).to.above(0);\n \n-      // Bob extends lock\n-      await ve.connect(bob).increaseUnlockTime(lockTime);\n-      block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.above(preBalance);\n-    });\n-\n-    it(\"Contract creates a lock, Bob delegates to contract\", async () => {\n-      const lockTime = 7 * WEEK + (await getTimestamp());\n-\n-      // create lock\n-      await contract.createLock(ve.address, lockAmount, lockTime);\n-      let block = await getBlock();\n-      expect(await ve.balanceOfAt(contract.address, block)).to.above(0);\n-\n-      // delegate to contract\n-      await ve.connect(bob).delegate(contract.address);\n-      block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.above(0);\n-      expect(await ve.balanceOfAt(contract.address, block)).to.above(0);\n-    });\n-\n-    it(\"Alice re-delegates to contract\", async () => {\n-      let block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.above(0);\n-\n-      // re-delegation to contract\n-      await ve.connect(alice).delegate(contract.address);\n-      block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(contract.address, block)).to.above(0);\n-    });\n-\n-    it(\"Alice's lock ends before Contract's, Alice cannot delegate back to herself\", async () => {\n-      tx = ve.connect(alice).delegate(alice.address);\n-      await expect(tx).to.be.revertedWith(\"Only delegate to longer lock\");\n-\n-      const block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(contract.address, block)).to.above(0);\n-    });\n-\n-    it(\"Alice extends her lock\", async () => {\n-      const lockTime = 8 * WEEK + (await getTimestamp());\n-      await ve.connect(alice).increaseUnlockTime(lockTime);\n-\n-      const block = await getBlock();\n-      // expect(await ve.lockEnd(alice.address)).to.equal(\n-      //   Math.trunc(lockTime / WEEK) * WEEK\n-      // );\n-    });\n-\n-    it(\"Alice's lock ends after Contract's, Alice can delegate back to herself\", async () => {\n-      // pre undelegation\n-      let block = await getBlock();\n-      const balance_before_contract = await ve.balanceOfAt(\n-        contract.address,\n-        block\n-      );\n-      expect(balance_before_contract).to.above(0);\n-\n-      // undelegate\n-      await ve.connect(alice).delegate(alice.address);\n-\n-      // post undelegation\n-      block = await getBlock();\n-      expect(await ve.balanceOfAt(alice.address, block)).to.above(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(contract.address, block)).to.above(0);\n-    });\n-\n-    it(\"Alice's lock is not delegated, Alice can quit\", async () => {\n-      // pre quit\n-      let block = await getBlock();\n-      expect(await fdtMock.balanceOf(alice.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-      expect(await ve.balanceOfAt(alice.address, block)).to.above(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(contract.address, block)).to.above(0);\n-\n-      // alice quits\n-      await ve.connect(alice).quitLock();\n-\n-      // post quit\n-      block = await getBlock();\n-\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(alice.address),\n-        initialFDTuserBal.sub(lockAmount.mul(7 * WEEK).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-      expect(await ve.balanceOfAt(alice.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(contract.address, block)).to.above(0);\n-    });\n-\n-    it(\"Bob's lock is delegated, Bob cannot quit\", async () => {\n-      // pre quit\n-      let block = await getBlock();\n-      expect(await fdtMock.balanceOf(bob.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-\n-      // Bob attempts to quit\n-      tx = ve.connect(bob).quitLock();\n-      await expect(tx).to.be.revertedWith(\"Lock delegated\");\n+      // rider delegates\n+      await rider.delegate(ve.address, horse.address);\n \n-      // post quit\n-      block = await getBlock();\n-      expect(await fdtMock.balanceOf(bob.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-    });\n-\n-    it(\"Bob extends lock and undelegates\", async () => {\n-      // pre undelegation\n-      let block = await getBlock();\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-      const preBalance = await ve.balanceOfAt(contract.address, block);\n-      expect(preBalance).to.above(0);\n-\n-      // Bob extends and undelegates\n-      await ve\n-        .connect(bob)\n-        .increaseUnlockTime(7 * WEEK + (await getTimestamp()));\n-      await ve.connect(bob).delegate(bob.address);\n-\n-      // post undelegation\n-      block = await getBlock();\n-      expect(await ve.balanceOfAt(bob.address, block)).to.above(0);\n-      const postBalance = await ve.balanceOfAt(contract.address, block);\n-      expect(postBalance).to.above(0);\n-      expect(postBalance).to.below(preBalance);\n-    });\n-\n-    it(\"Bob's lock is not delegated, Bob can quit\", async () => {\n-      // pre quit\n-      let block = await getBlock();\n-      expect(await fdtMock.balanceOf(bob.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-      expect(await ve.balanceOfAt(bob.address, block)).to.above(0);\n-\n-      // alice quits\n-      await ve.connect(bob).quitLock();\n-\n-      // post quit\n+      // post lock balances\n       block = await getBlock();\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(bob.address),\n-        initialFDTuserBal.sub(lockAmount.mul(6 * WEEK).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n+      expect(await ve.balanceOfAt(rider.address, block)).to.equal(0);\n+      expect(await ve.balanceOfAt(horse.address, block)).to.above(preBalance);\n     });\n+    it(\"After some time, Rider gets itself blocked.\", async () => {\n+      await increaseTime(15 * WEEK);\n \n-    it(\"Contract extends lock beyond Bob's lock, \", async () => {\n-      const lockTimeContract = 30 * WEEK + (await getTimestamp());\n-      await contract.increaseUnlockTime(ve.address, lockTimeContract);\n-\n-      await increaseTime(8 * WEEK);\n-      // pre delegation\n-      const block = await getBlock();\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(bob.address),\n-        initialFDTuserBal.sub(lockAmount.mul(7 * WEEK).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n+      expect(await blocklist.isBlocked(rider.address)).to.equal(false);\n+      await blocklist.block(rider.address);\n+      expect(await blocklist.isBlocked(rider.address)).to.equal(true);\n     });\n-\n-    it(\"Bob attempts to lock again, succeeds, Bob can delegate to contract\", async () => {\n-      const lockTime = 10 * WEEK + (await getTimestamp());\n-      // bob creates a new lock\n-      await ve.connect(bob).createLock(lockAmount, lockTime);\n-\n+    it(\"Rider can now withdraw\", async () => {\n       let block = await getBlock();\n-      const preBalance = await ve.balanceOfAt(contract.address, block);\n+      const preBalance = await ve.balanceOfAt(horse.address, block);\n       expect(preBalance).to.above(0);\n \n-      await ve.connect(bob).delegate(contract.address);\n+      expect(await fdtMock.balanceOf(rider.address)).to.equal(0);\n \n-      // post delegation\n-      block = await getBlock();\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(bob.address),\n-        initialFDTuserBal\n-          .sub(lockAmount.mul(7 * WEEK).div(MAXTIME))\n-          .sub(lockAmount),\n-        \"0.5\"\n-      );\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-      const postBalance = await ve.balanceOfAt(contract.address, block);\n-      expect(postBalance).to.above(preBalance);\n-      // const block = await getBlock();\n-      // expect(await ve.lockEnd(contract.address)).to.equal(\n-      //   Math.trunc(lockTime / WEEK) * WEEK\n-      // );\n-    });\n+      await rider.withdraw(ve.address);\n \n-    it(\"Contract's lock is not delegated, contract can quit and but lose delegated balance\", async () => {\n-      // pre quit\n-      let block = await getBlock();\n-      expect(await fdtMock.balanceOf(contract.address)).to.equal(\n-        initialFDTuserBal.sub(lockAmount)\n-      );\n-      const preBalance = await ve.balanceOfAt(contract.address, block);\n-      expect(preBalance).to.above(0);\n-\n-      // contract quits\n-      await contract.quitLock(ve.address);\n-\n-      // post quit\n       block = await getBlock();\n+      expect(await ve.balanceOfAt(rider.address, block)).to.equal(0);\n \n-      // Contract locked for 30 weeks, then we advanced 8 weeks\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(contract.address),\n-        initialFDTuserBal.sub(lockAmount.mul(21 * WEEK).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-      const postBalance = await ve.balanceOfAt(contract.address, block);\n-      expect(postBalance).to.equal(0);\n-      expect(postBalance).to.below(preBalance);\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-    });\n-\n-    it(\"Bob's lock ends before Contract's, Bob cannot delegate back to himself\", async () => {\n-      tx = ve.connect(bob).delegate(bob.address);\n-      await expect(tx).to.be.revertedWith(\"Only delegate to longer lock\");\n-\n-      const block = await getBlock();\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-      // Contract has no voting power\n-      expect(await ve.balanceOfAt(contract.address, block)).to.equal(0);\n-    });\n-\n-    it(\"Bob extends his lock\", async () => {\n-      const lockTime = 50 * WEEK + (await getTimestamp());\n-      await ve.connect(bob).increaseUnlockTime(lockTime);\n-\n-      const block = await getBlock();\n-      // expect(await ve.lockEnd(bob.address)).to.equal(\n-      //   Math.trunc(lockTime / WEEK) * WEEK\n-      // );\n-    });\n-\n-    it(\"Bob's lock ends after Contract's, Bob can delegate back to himself\", async () => {\n-      // pre undelegation\n-      let block = await getBlock();\n-      expect(await ve.balanceOfAt(bob.address, block)).to.equal(0);\n-      expect(await ve.balanceOfAt(contract.address, block)).to.equal(0);\n-\n-      // undelegate\n-      await ve.connect(bob).delegate(bob.address);\n-\n-      // post undelegation\n-      block = await getBlock();\n-      expect(await ve.balanceOfAt(bob.address, block)).to.above(0);\n-      expect(await ve.balanceOfAt(contract.address, block)).to.equal(0);\n-\n-      await restoreSnapshot(provider);\n-    });\n-  });\n-\n-  describe(\"Quitlock flow\", async () => {\n-    it(\"Alice, Bob, Charlie, David and Eve lock FDT in ve\", async () => {\n-      await createSnapshot(provider);\n-      // MAXTIME => 1 year\n-      const lockTime1 = MAXTIME + (await getTimestamp());\n-      const lockTime2 = MAXTIME / 2 + (await getTimestamp());\n-\n-      // 1 year lock\n-      await ve.connect(alice).createLock(lockAmount, lockTime1);\n-      await ve.connect(bob).createLock(lockAmount, lockTime1);\n-      await ve.connect(charlie).createLock(lockAmount, lockTime1);\n-\n-      // 6 month lock\n-      await ve.connect(david).createLock(lockAmount, lockTime2);\n-      await ve.connect(eve).createLock(lockAmount, lockTime2);\n-    });\n-\n-    it(\"Alice and David quitlocks after ~3 months\", async () => {\n-      await increaseTime(ONE_WEEK.mul(13));\n-      await ve.connect(alice).quitLock();\n-      // Alice would have ~39 weeks left\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(alice.address),\n-        initialFDTuserBal.sub(lockAmount.mul(ONE_WEEK.mul(39)).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-      // David would have ~13 weeks left\n-      await ve.connect(david).quitLock();\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(david.address),\n-        initialFDTuserBal.sub(lockAmount.mul(ONE_WEEK.mul(13)).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-    });\n-\n-    it(\"Bob and Eve quitlocks after ~ 4 months\", async () => {\n-      await increaseTime(ONE_WEEK.mul(4));\n-      await ve.connect(bob).quitLock();\n-      // Bob would have ~35 weeks left\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(bob.address),\n-        initialFDTuserBal.sub(lockAmount.mul(ONE_WEEK.mul(35)).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-      // David would have ~9 weeks left\n-      await ve.connect(eve).quitLock();\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(eve.address),\n-        initialFDTuserBal.sub(lockAmount.mul(ONE_WEEK.mul(9)).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-    });\n-\n-    it(\"Charlie quitlocks after ~ 9 months\", async () => {\n-      await increaseTime(ONE_WEEK.mul(21));\n-      await ve.connect(charlie).quitLock();\n-      // Charlie would have ~14 weeks left\n-      assertBNClosePercent(\n-        await fdtMock.balanceOf(charlie.address),\n-        initialFDTuserBal.sub(lockAmount.mul(ONE_WEEK.mul(14)).div(MAXTIME)),\n-        \"0.5\"\n-      );\n-    });\n+      //Rider's tokens are back in the wallet\n+      expect(await fdtMock.balanceOf(rider.address)).to.equal(initialFDTuserBal);\n \n-    it(\"Alice locks again, then penalty is taken away,she withdraws without penalty\", async () => {\n-      const aliceBalBefore = await fdtMock.balanceOf(alice.address);\n-      await ve\n-        .connect(alice)\n-        .createLock(lockAmount, (await getTimestamp()) + MAXTIME);\n-      await ve.unlock();\n-      await ve.connect(alice).quitLock();\n-      expect(await fdtMock.balanceOf(alice.address)).to.equal(aliceBalBefore);\n     });\n   });\n });\n```\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-08-fiat-dao-vefdt-contest",
  "Code": [
    {
      "filename": "contracts/VotingEscrow.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.3;\n\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { IVotingEscrow } from \"./interfaces/IVotingEscrow.sol\";\nimport { IBlocklist } from \"./interfaces/IBlocklist.sol\";\n\n/// @title  VotingEscrow\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///           (see https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n///         mStable (AGPL) - forking Curve's Vyper contract and porting to Solidity\n///           (see https://github.com/mstable/mStable-contracts/blob/master/contracts/governance/IncentivisedVotingLockup.sol)\n///         FIAT DAO (AGPL) - this version\n/// @notice Plain Curve VotingEscrow mechanics with following adjustments:\n///            1) Delegation of lock and voting power\n///            2) Quit an existing lock and pay a penalty\n///            3) Whitelisting of SmartWallets outside the VotingEscrow\n///            4) Reduced pointHistory array size and, as a result, lifetime of the contract\n///            5) Removed public deposit_for and Aragon compatibility (no use case)\ncontract VotingEscrow is IVotingEscrow, ReentrancyGuard {\n    // Shared Events\n    event Deposit(\n        address indexed provider,\n        uint256 value,\n        uint256 locktime,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event Withdraw(\n        address indexed provider,\n        uint256 value,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event TransferOwnership(address owner);\n    event UpdateBlocklist(address blocklist);\n    event UpdatePenaltyRecipient(address recipient);\n    event CollectPenalty(uint256 amount, address recipient);\n    event Unlock();\n\n    // Shared global state\n    IERC20 public token;\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MAXTIME = 365 days;\n    uint256 public constant MULTIPLIER = 10**18;\n    address public owner;\n    address public penaltyRecipient; // receives collected penalty payments\n    uint256 public maxPenalty = 10**18; // penalty for quitters with MAXTIME remaining lock\n    uint256 public penaltyAccumulated; // accumulated and unwithdrawn penalty payments\n    address public blocklist;\n\n    // Lock state\n    uint256 public globalEpoch;\n    Point[1000000000000000000] public pointHistory; // 1e9 * userPointHistory-length, so sufficient for 1e9 users\n    mapping(address => Point[1000000000]) public userPointHistory;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => int128) public slopeChanges;\n    mapping(address => LockedBalance) public locked;\n\n    // Voting token\n    string public name;\n    string public symbol;\n    uint256 public decimals = 18;\n\n    // Structs\n    struct Point {\n        int128 bias;\n        int128 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n        int128 delegated;\n        address delegatee;\n    }\n\n    // Miscellaneous\n    enum LockAction {\n        CREATE,\n        INCREASE_AMOUNT,\n        INCREASE_AMOUNT_AND_DELEGATION,\n        INCREASE_TIME,\n        WITHDRAW,\n        QUIT,\n        DELEGATE,\n        UNDELEGATE\n    }\n\n    /// @notice Initializes state\n    /// @param _owner The owner is able to update `owner`, `penaltyRecipient` and `penaltyRate`\n    /// @param _penaltyRecipient The recipient of penalty paid by lock quitters\n    /// @param _token The token locked in order to obtain voting power\n    /// @param _name The name of the voting token\n    /// @param _symbol The symbol of the voting token\n    constructor(\n        address _owner,\n        address _penaltyRecipient,\n        address _token,\n        string memory _name,\n        string memory _symbol\n    ) {\n        token = IERC20(_token);\n        pointHistory[0] = Point({\n            bias: int128(0),\n            slope: int128(0),\n            ts: block.timestamp,\n            blk: block.number\n        });\n\n        decimals = IERC20(_token).decimals();\n        require(decimals <= 18, \"Exceeds max decimals\");\n\n        name = _name;\n        symbol = _symbol;\n        owner = _owner;\n        penaltyRecipient = _penaltyRecipient;\n    }\n\n    modifier checkBlocklist() {\n        require(\n            !IBlocklist(blocklist).isBlocked(msg.sender),\n            \"Blocked contract\"\n        );\n        _;\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       Owner Functions       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Transfers ownership to a new owner\n    /// @param _addr The new owner\n    /// @dev Owner should always be a timelock contract\n    function transferOwnership(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        owner = _addr;\n        emit TransferOwnership(_addr);\n    }\n\n    /// @notice Updates the blocklist contract\n    function updateBlocklist(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        blocklist = _addr;\n        emit UpdateBlocklist(_addr);\n    }\n\n    /// @notice Updates the recipient of the accumulated penalty paid by quitters\n    function updatePenaltyRecipient(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        penaltyRecipient = _addr;\n        emit UpdatePenaltyRecipient(_addr);\n    }\n\n    /// @notice Removes quitlock penalty by setting it to zero\n    /// @dev This is an irreversible action\n    function unlock() external {\n        require(msg.sender == owner, \"Only owner\");\n        maxPenalty = 0;\n        emit Unlock();\n    }\n\n    /// @notice Forces an undelegation of virtual balance for a blocked locker\n    /// @dev Can only be called by the Blocklist contract (as part of a block)\n    /// @dev This is an irreversible action\n    function forceUndelegate(address _addr) external override {\n        require(msg.sender == blocklist, \"Only Blocklist\");\n        LockedBalance memory locked_ = locked[_addr];\n        address delegatee = locked_.delegatee;\n        int128 value = locked_.amount;\n\n        if (delegatee != _addr && value > 0) {\n            LockedBalance memory fromLocked;\n            locked_.delegatee = _addr;\n            fromLocked = locked[delegatee];\n            _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n            _delegate(_addr, locked_, value, LockAction.DELEGATE);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       LOCK MANAGEMENT       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Returns a user's lock expiration\n    /// @param _addr The address of the user\n    /// @return Expiration of the user's lock\n    function lockEnd(address _addr) external view returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    /// @notice Returns the last available user point for a user\n    /// @param _addr User address\n    /// @return bias i.e. y\n    /// @return slope i.e. linear gradient\n    /// @return ts i.e. time point was logged\n    function getLastUserPoint(address _addr)\n        external\n        view\n        returns (\n            int128 bias,\n            int128 slope,\n            uint256 ts\n        )\n    {\n        uint256 uepoch = userPointEpoch[_addr];\n        if (uepoch == 0) {\n            return (0, 0, 0);\n        }\n        Point memory point = userPointHistory[_addr][uepoch];\n        return (point.bias, point.slope, point.ts);\n    }\n\n    /// @notice Records a checkpoint of both individual and global slope\n    /// @param _addr User address, or address(0) for only global\n    /// @param _oldLocked Old amount that user had locked, or null for global\n    /// @param _newLocked new amount that user has locked, or null for global\n    function _checkpoint(\n        address _addr,\n        LockedBalance memory _oldLocked,\n        LockedBalance memory _newLocked\n    ) internal {\n        Point memory userOldPoint;\n        Point memory userNewPoint;\n        int128 oldSlopeDelta = 0;\n        int128 newSlopeDelta = 0;\n        uint256 epoch = globalEpoch;\n\n        if (_addr != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.delegated > 0) {\n                userOldPoint.slope =\n                    _oldLocked.delegated /\n                    int128(int256(MAXTIME));\n                userOldPoint.bias =\n                    userOldPoint.slope *\n                    int128(int256(_oldLocked.end - block.timestamp));\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.delegated > 0) {\n                userNewPoint.slope =\n                    _newLocked.delegated /\n                    int128(int256(MAXTIME));\n                userNewPoint.bias =\n                    userNewPoint.slope *\n                    int128(int256(_newLocked.end - block.timestamp));\n            }\n\n            // Moved from bottom final if statement to resolve stack too deep err\n            // start {\n            // Now handle user history\n            uint256 uEpoch = userPointEpoch[_addr];\n            if (uEpoch == 0) {\n                userPointHistory[_addr][uEpoch + 1] = userOldPoint;\n            }\n\n            userPointEpoch[_addr] = uEpoch + 1;\n            userNewPoint.ts = block.timestamp;\n            userNewPoint.blk = block.number;\n            userPointHistory[_addr][uEpoch + 1] = userNewPoint;\n\n            // } end\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldSlopeDelta = slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newSlopeDelta = oldSlopeDelta;\n                } else {\n                    newSlopeDelta = slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        Point memory lastPoint =\n            Point({\n                bias: 0,\n                slope: 0,\n                ts: block.timestamp,\n                blk: block.number\n            });\n        if (epoch > 0) {\n            lastPoint = pointHistory[epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint =\n            Point({ bias: 0, slope: 0, ts: lastPoint.ts, blk: lastPoint.blk });\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope =\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\n                (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 iterativeTime = _floorToWeek(lastCheckpoint);\n        for (uint256 i = 0; i < 255; i++) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            if (iterativeTime > block.timestamp) {\n                iterativeTime = block.timestamp;\n            } else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n            int128 biasDelta =\n                lastPoint.slope *\n                    int128(int256((iterativeTime - lastCheckpoint)));\n            lastPoint.bias = lastPoint.bias - biasDelta;\n            lastPoint.slope = lastPoint.slope + dSlope;\n            // This can happen\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            // This cannot happen - just in case\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            lastCheckpoint = iterativeTime;\n            lastPoint.ts = iterativeTime;\n            lastPoint.blk =\n                initialLastPoint.blk +\n                (blockSlope * (iterativeTime - initialLastPoint.ts)) /\n                MULTIPLIER;\n\n            // when epoch is incremented, we either push here or after slopes updated below\n            epoch = epoch + 1;\n            if (iterativeTime == block.timestamp) {\n                lastPoint.blk = block.number;\n                break;\n            } else {\n                pointHistory[epoch] = lastPoint;\n            }\n        }\n\n        globalEpoch = epoch;\n        // Now pointHistory is filled until t=now\n\n        if (_addr != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope =\n                lastPoint.slope +\n                userNewPoint.slope -\n                userOldPoint.slope;\n            lastPoint.bias =\n                lastPoint.bias +\n                userNewPoint.bias -\n                userOldPoint.bias;\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n        }\n\n        // Record the changed point into history\n        pointHistory[epoch] = lastPoint;\n\n        if (_addr != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // oldSlopeDelta was <something> - userOldPoint.slope, so we cancel that\n                oldSlopeDelta = oldSlopeDelta + userOldPoint.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    oldSlopeDelta = oldSlopeDelta - userNewPoint.slope; // It was a new deposit, not extension\n                }\n                slopeChanges[_oldLocked.end] = oldSlopeDelta;\n            }\n            if (_newLocked.end > block.timestamp) {\n                if (_newLocked.end > _oldLocked.end) {\n                    newSlopeDelta = newSlopeDelta - userNewPoint.slope; // old slope disappeared at this point\n                    slopeChanges[_newLocked.end] = newSlopeDelta;\n                }\n                // else: we recorded it already in oldSlopeDelta\n            }\n        }\n    }\n\n    /// @notice Public function to trigger global checkpoint\n    function checkpoint() external {\n        LockedBalance memory empty;\n        _checkpoint(address(0), empty, empty);\n    }\n\n    // See IVotingEscrow for documentation\n    function createLock(uint256 _value, uint256 _unlockTime)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(locked_.amount == 0, \"Lock exists\");\n        require(unlock_time >= locked_.end, \"Only increase lock end\"); // from using quitLock, user should increaseAmount instead\n        require(unlock_time > block.timestamp, \"Only future lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update lock and voting power (checkpoint)\n        locked_.amount += int128(int256(_value));\n        locked_.end = unlock_time;\n        locked_.delegated += int128(int256(_value));\n        locked_.delegatee = msg.sender;\n        locked[msg.sender] = locked_;\n        _checkpoint(msg.sender, LockedBalance(0, 0, 0, address(0)), locked_);\n        // Deposit locked tokens\n        require(\n            token.transferFrom(msg.sender, address(this), _value),\n            \"Transfer failed\"\n        );\n        emit Deposit(\n            msg.sender,\n            _value,\n            unlock_time,\n            LockAction.CREATE,\n            block.timestamp\n        );\n    }\n\n    // See IVotingEscrow for documentation\n    // @dev A lock is active until both lock.amount==0 and lock.end<=block.timestamp\n    function increaseAmount(uint256 _value)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        // Update lock\n        address delegatee = locked_.delegatee;\n        uint256 unlockTime = locked_.end;\n        LockAction action = LockAction.INCREASE_AMOUNT;\n        LockedBalance memory newLocked;\n        if (delegatee == msg.sender) {\n            // Undelegated lock\n            action = LockAction.INCREASE_AMOUNT_AND_DELEGATION;\n            newLocked = _copyLock(locked_);\n            newLocked.amount += int128(int256(_value));\n            newLocked.delegated += int128(int256(_value));\n            locked[msg.sender] = newLocked;\n        } else {\n            // Delegated lock, update sender's lock first\n            locked_.amount += int128(int256(_value));\n            locked[msg.sender] = locked_;\n            // Then, update delegatee's lock and voting power (checkpoint)\n            locked_ = locked[delegatee];\n            require(locked_.amount > 0, \"Delegatee has no lock\");\n            require(locked_.end > block.timestamp, \"Delegatee lock expired\");\n            newLocked = _copyLock(locked_);\n            newLocked.delegated += int128(int256(_value));\n            locked[delegatee] = newLocked;\n            emit Deposit(\n                delegatee,\n                _value,\n                newLocked.end,\n                LockAction.DELEGATE,\n                block.timestamp\n            );\n        }\n        // Checkpoint only for delegatee\n        _checkpoint(delegatee, locked_, newLocked);\n        // Deposit locked tokens\n        require(\n            token.transferFrom(msg.sender, address(this), _value),\n            \"Transfer failed\"\n        );\n        emit Deposit(msg.sender, _value, unlockTime, action, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function increaseUnlockTime(uint256 _unlockTime)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(unlock_time > locked_.end, \"Only increase lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update lock\n        uint256 oldUnlockTime = locked_.end;\n        locked_.end = unlock_time;\n        locked[msg.sender] = locked_;\n        if (locked_.delegatee == msg.sender) {\n            // Undelegated lock\n            require(oldUnlockTime > block.timestamp, \"Lock expired\");\n            LockedBalance memory oldLocked = _copyLock(locked_);\n            oldLocked.end = unlock_time;\n            _checkpoint(msg.sender, oldLocked, locked_);\n        }\n        emit Deposit(\n            msg.sender,\n            0,\n            unlock_time,\n            LockAction.INCREASE_TIME,\n            block.timestamp\n        );\n    }\n\n    // See IVotingEscrow for documentation\n    function withdraw() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end <= block.timestamp, \"Lock not expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update lock\n        uint256 value = uint256(uint128(locked_.amount));\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.end = 0;\n        newLocked.delegated -= int128(int256(value));\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // Send back deposited tokens\n        require(token.transfer(msg.sender, value), \"Transfer failed\");\n        emit Withdraw(msg.sender, value, LockAction.WITHDRAW, block.timestamp);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         DELEGATION         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function delegate(address _addr)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(!IBlocklist(blocklist).isBlocked(_addr), \"Blocked contract\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.delegatee != _addr, \"Already delegated\");\n        // Update locks\n        int128 value = locked_.amount;\n        address delegatee = locked_.delegatee;\n        LockedBalance memory fromLocked;\n        LockedBalance memory toLocked;\n        locked_.delegatee = _addr;\n        if (delegatee == msg.sender) {\n            // Delegate\n            fromLocked = locked_;\n            toLocked = locked[_addr];\n        } else if (_addr == msg.sender) {\n            // Undelegate\n            fromLocked = locked[delegatee];\n            toLocked = locked_;\n        } else {\n            // Re-delegate\n            fromLocked = locked[delegatee];\n            toLocked = locked[_addr];\n            // Update owner lock if not involved in delegation\n            locked[msg.sender] = locked_;\n        }\n        require(toLocked.amount > 0, \"Delegatee has no lock\");\n        require(toLocked.end > block.timestamp, \"Delegatee lock expired\");\n        require(toLocked.end >= fromLocked.end, \"Only delegate to longer lock\");\n        _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n        _delegate(_addr, toLocked, value, LockAction.DELEGATE);\n    }\n\n    // Delegates from/to lock and voting power\n    function _delegate(\n        address addr,\n        LockedBalance memory _locked,\n        int128 value,\n        LockAction action\n    ) internal {\n        LockedBalance memory newLocked = _copyLock(_locked);\n        if (action == LockAction.DELEGATE) {\n            newLocked.delegated += value;\n            emit Deposit(\n                addr,\n                uint256(int256(value)),\n                newLocked.end,\n                action,\n                block.timestamp\n            );\n        } else {\n            newLocked.delegated -= value;\n            emit Withdraw(\n                addr,\n                uint256(int256(value)),\n                action,\n                block.timestamp\n            );\n        }\n        locked[addr] = newLocked;\n        if (newLocked.amount > 0) {\n            // Only if lock (from lock) hasn't been withdrawn/quitted\n            _checkpoint(addr, _locked, newLocked);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         QUIT LOCK          ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function quitLock() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update lock\n        uint256 value = uint256(uint128(locked_.amount));\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.delegated -= int128(int256(value));\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.end = 0;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // apply penalty\n        uint256 penaltyRate = _calculatePenaltyRate(locked_.end);\n        uint256 penaltyAmount = (value * penaltyRate) / 10**18; // quitlock_penalty is in 18 decimals precision\n        penaltyAccumulated += penaltyAmount;\n        uint256 remainingAmount = value - penaltyAmount;\n        // Send back remaining tokens\n        require(token.transfer(msg.sender, remainingAmount), \"Transfer failed\");\n        emit Withdraw(msg.sender, value, LockAction.QUIT, block.timestamp);\n    }\n\n    // Calculate penalty rate (decreasing linearly)\n    function _calculatePenaltyRate(uint256 end)\n        internal\n        view\n        returns (uint256)\n    {\n        // We know that end > block.timestamp because expired locks cannot be quitted\n        return ((end - block.timestamp) * maxPenalty) / MAXTIME;\n    }\n\n    /// @notice Collect accumulated penalty from quitters\n    /// @dev Everyone can collect but penalty is sent to `penaltyRecipient`\n    function collectPenalty() external {\n        uint256 amount = penaltyAccumulated;\n        penaltyAccumulated = 0;\n        require(token.transfer(penaltyRecipient, amount), \"Transfer failed\");\n        emit CollectPenalty(amount, penaltyRecipient);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///            GETTERS         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // Creates a copy of a lock\n    function _copyLock(LockedBalance memory _locked)\n        internal\n        pure\n        returns (LockedBalance memory)\n    {\n        return\n            LockedBalance({\n                amount: _locked.amount,\n                end: _locked.end,\n                delegatee: _locked.delegatee,\n                delegated: _locked.delegated\n            });\n    }\n\n    // @dev Floors a timestamp to the nearest weekly increment\n    // @param _t Timestamp to floor\n    function _floorToWeek(uint256 _t) internal pure returns (uint256) {\n        return (_t / WEEK) * WEEK;\n    }\n\n    // @dev Uses binarysearch to find the most recent point history preceeding block\n    // @param _block Find the most recent point history before this block\n    // @param _maxEpoch Do not search pointHistories past this index\n    function _findBlockEpoch(uint256 _block, uint256 _maxEpoch)\n        internal\n        view\n        returns (uint256)\n    {\n        // Binary search\n        uint256 min = 0;\n        uint256 max = _maxEpoch;\n        // Will be always enough for 128-bit numbers\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n            uint256 mid = (min + max + 1) / 2;\n            if (pointHistory[mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // @dev Uses binarysearch to find the most recent user point history preceeding block\n    // @param _addr User for which to search\n    // @param _block Find the most recent point history before this block\n    function _findUserBlockEpoch(address _addr, uint256 _block)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 min = 0;\n        uint256 max = userPointEpoch[_addr];\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) {\n                break;\n            }\n            uint256 mid = (min + max + 1) / 2;\n            if (userPointHistory[_addr][mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // See IVotingEscrow for documentation\n    function balanceOf(address _owner) public view override returns (uint256) {\n        uint256 epoch = userPointEpoch[_owner];\n        if (epoch == 0) {\n            return 0;\n        }\n        Point memory lastPoint = userPointHistory[_owner][epoch];\n        lastPoint.bias =\n            lastPoint.bias -\n            (lastPoint.slope * int128(int256(block.timestamp - lastPoint.ts)));\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function balanceOfAt(address _owner, uint256 _blockNumber)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        // Get most recent user Point to block\n        uint256 userEpoch = _findUserBlockEpoch(_owner, _blockNumber);\n        if (userEpoch == 0) {\n            return 0;\n        }\n        Point memory upoint = userPointHistory[_owner][userEpoch];\n\n        // Get most recent global Point to block\n        uint256 maxEpoch = globalEpoch;\n        uint256 epoch = _findBlockEpoch(_blockNumber, maxEpoch);\n        Point memory point0 = pointHistory[epoch];\n\n        // Calculate delta (block & time) between user Point and target block\n        // Allowing us to calculate the average seconds per block between\n        // the two points\n        uint256 dBlock = 0;\n        uint256 dTime = 0;\n        if (epoch < maxEpoch) {\n            Point memory point1 = pointHistory[epoch + 1];\n            dBlock = point1.blk - point0.blk;\n            dTime = point1.ts - point0.ts;\n        } else {\n            dBlock = block.number - point0.blk;\n            dTime = block.timestamp - point0.ts;\n        }\n        // (Deterministically) Estimate the time at which block _blockNumber was mined\n        uint256 blockTime = point0.ts;\n        if (dBlock != 0) {\n            blockTime =\n                blockTime +\n                ((dTime * (_blockNumber - point0.blk)) / dBlock);\n        }\n        // Current Bias = most recent bias - (slope * time since update)\n        upoint.bias =\n            upoint.bias -\n            (upoint.slope * int128(int256(blockTime - upoint.ts)));\n        if (upoint.bias >= 0) {\n            return uint256(uint128(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Calculate total supply of voting power at a given time _t\n    /// @param _point Most recent point before time _t\n    /// @param _t Time at which to calculate supply\n    /// @return totalSupply at given point in time\n    function _supplyAt(Point memory _point, uint256 _t)\n        internal\n        view\n        returns (uint256)\n    {\n        Point memory lastPoint = _point;\n        // Floor the timestamp to weekly interval\n        uint256 iterativeTime = _floorToWeek(lastPoint.ts);\n        // Iterate through all weeks between _point & _t to account for slope changes\n        for (uint256 i = 0; i < 255; i++) {\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            // If week end is after timestamp, then truncate & leave dSlope to 0\n            if (iterativeTime > _t) {\n                iterativeTime = _t;\n            }\n            // else get most recent slope change\n            else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n\n            lastPoint.bias =\n                lastPoint.bias -\n                (lastPoint.slope *\n                    int128(int256(iterativeTime - lastPoint.ts)));\n            if (iterativeTime == _t) {\n                break;\n            }\n            lastPoint.slope = lastPoint.slope + dSlope;\n            lastPoint.ts = iterativeTime;\n        }\n\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupply() public view override returns (uint256) {\n        uint256 epoch_ = globalEpoch;\n        Point memory lastPoint = pointHistory[epoch_];\n        return _supplyAt(lastPoint, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupplyAt(uint256 _blockNumber)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        uint256 epoch = globalEpoch;\n        uint256 targetEpoch = _findBlockEpoch(_blockNumber, epoch);\n\n        Point memory point = pointHistory[targetEpoch];\n\n        // If point.blk > _blockNumber that means we got the initial epoch & contract did not yet exist\n        if (point.blk > _blockNumber) {\n            return 0;\n        }"
    }
  ]
}