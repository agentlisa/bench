{
  "Title": "[M-02] TribeRedeemer will start redeeming incorrectly if someone transfer redeem tokens directly to it",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-tribe/blob/main/contracts/shutdown/redeem/TribeRedeemer.sol#L58\nhttps://github.com/code-423n4/2022-09-tribe/blob/main/contracts/shutdown/redeem/TribeRedeemer.sol#L70\n\n\n# Vulnerability details\n\n## Impact\n`TribeRedeemer` contract has one goal. It should take `_redeemedToken`(token that contract will accept from users), `_tokensReceived` - list of exchange tokens(this are created exactly to be changed for redeemedToken) and `_redeemBase` amount of tokens that should be redeemed(this actually should be `IERC20(_redeemedToken).totalSupply())`. After that it will start redeeming `_redeemedToken` in exchange to `_tokensReceived` tokens.\n\nSuppose we have redeemed token `tokenA` with total supply of `10000` and `redeemBase == 10000` . And in  `_tokensReceived` list we have only 1 token `tokenB` with total supply of `10000`(all tokens are controlled by `TribeRedeemer`). According to logic of `TribeRedeemer` if user wants to redeem X tokens then he will receive `(x * tokenB.balanceOf(address(this))) / redeemBase` that in our case will be just amount X. So user send X `tokenA` and receive back X `tokenB`. Now because `redeemBase == 10000` and contract balance of `tokenB` is `10000` the exchange ratio is `1:1`.\n\nHowever if someone will transfer some amount of `tokenA` to `TribeRedeemer` contract directly using `ERC20.transfer` for example `500` tokens then it not call `redeem` function and `redeemBase` value will not be decreased with amount sent. That means that right now the exchange ratio should not be `1:1` as `TribeRedeemer` contract received more `500` tokens and didn't pay user for them(it should redeem that amount then with the next users, they share should be increased). So the next users will receive less amount then they should(`TribeRedeemer` should spend all `tokenB` amount in exchange of all `tokenA` tokens). \n\n## Proof of Concept\nHere is where `amounOut` is calculated.\nhttps://github.com/code-423n4/2022-09-tribe/blob/main/contracts/shutdown/redeem/TribeRedeemer.sol#L58\n\nThis is where the `redeemBase` is decreased with redeem amount, but is not called because of direct transfer.\nhttps://github.com/code-423n4/2022-09-tribe/blob/main/contracts/shutdown/redeem/TribeRedeemer.sol#L70\n\n## Recommended Mitigation Steps\nDo not use `redeemBase` for calculation amount of tokens that are left for redeeming. Use `IERC20(_redeemedToken).totalSupply()) - IERC20(_redeemedToken).balanceOf(address(this))`.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-fei-and-tribe-redemption-contest",
  "Code": [
    {
      "filename": "contracts/shutdown/redeem/TribeRedeemer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title contract used to redeem a list of tokens, by permanently\n/// taking another token out of circulation.\n/// @author Fei Protocol\ncontract TribeRedeemer is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice event to track redemptions\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    /// @notice token to redeem\n    address public immutable redeemedToken;\n\n    /// @notice tokens to receive when redeeming\n    address[] private tokensReceived;\n\n    /// @notice base used to compute the redemption amounts.\n    /// For instance, if the base is 100, and a user provides 100 `redeemedToken`,\n    /// they will receive all the balances of each `tokensReceived` held on this contract.\n    uint256 public redeemBase;\n\n    constructor(\n        address _redeemedToken,\n        address[] memory _tokensReceived,\n        uint256 _redeemBase\n    ) {\n        redeemedToken = _redeemedToken;\n        tokensReceived = _tokensReceived;\n        redeemBase = _redeemBase;\n    }\n\n    /// @notice Public function to get `tokensReceived`\n    function tokensReceivedOnRedeem() public view returns (address[] memory) {\n        return tokensReceived;\n    }\n\n    /// @notice Return the balances of `tokensReceived` that would be\n    /// transferred if redeeming `amountIn` of `redeemedToken`.\n    function previewRedeem(uint256 amountIn)\n        public\n        view\n        returns (address[] memory tokens, uint256[] memory amountsOut)\n    {\n        tokens = tokensReceivedOnRedeem();\n        amountsOut = new uint256[](tokens.length);\n\n        uint256 base = redeemBase;\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;\n            amountsOut[i] = redeemedAmount;\n        }\n    }\n\n    /// @notice Redeem `redeemedToken` for a pro-rata basket of `tokensReceived`\n    function redeem(address to, uint256 amountIn) external nonReentrant {\n        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);\n\n        uint256 base = redeemBase;\n        redeemBase = base - amountIn; // decrement the base for future redemptions\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);\n        }\n\n        emit Redeemed(msg.sender, to, amountIn, base);\n    }\n}"
    },
    {
      "filename": "contracts/shutdown/redeem/TribeRedeemer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title contract used to redeem a list of tokens, by permanently\n/// taking another token out of circulation.\n/// @author Fei Protocol\ncontract TribeRedeemer is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice event to track redemptions\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    /// @notice token to redeem\n    address public immutable redeemedToken;\n\n    /// @notice tokens to receive when redeeming\n    address[] private tokensReceived;\n\n    /// @notice base used to compute the redemption amounts.\n    /// For instance, if the base is 100, and a user provides 100 `redeemedToken`,\n    /// they will receive all the balances of each `tokensReceived` held on this contract.\n    uint256 public redeemBase;\n\n    constructor(\n        address _redeemedToken,\n        address[] memory _tokensReceived,\n        uint256 _redeemBase\n    ) {\n        redeemedToken = _redeemedToken;\n        tokensReceived = _tokensReceived;\n        redeemBase = _redeemBase;\n    }\n\n    /// @notice Public function to get `tokensReceived`\n    function tokensReceivedOnRedeem() public view returns (address[] memory) {\n        return tokensReceived;\n    }\n\n    /// @notice Return the balances of `tokensReceived` that would be\n    /// transferred if redeeming `amountIn` of `redeemedToken`.\n    function previewRedeem(uint256 amountIn)\n        public\n        view\n        returns (address[] memory tokens, uint256[] memory amountsOut)\n    {\n        tokens = tokensReceivedOnRedeem();\n        amountsOut = new uint256[](tokens.length);\n\n        uint256 base = redeemBase;\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;\n            amountsOut[i] = redeemedAmount;\n        }\n    }\n\n    /// @notice Redeem `redeemedToken` for a pro-rata basket of `tokensReceived`\n    function redeem(address to, uint256 amountIn) external nonReentrant {\n        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);\n\n        uint256 base = redeemBase;\n        redeemBase = base - amountIn; // decrement the base for future redemptions\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);\n        }\n\n        emit Redeemed(msg.sender, to, amountIn, base);\n    }\n}"
    }
  ]
}