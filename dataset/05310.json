{
  "Title": "[L-05] - Canâ€™t update the status of a self destructed hook",
  "Content": "\nThe protocol doesn't allow updating the status of hooks with no code.\nThe issue is that if a hook is self destructed for any reason the admin can't update its status any more.\n\n[code](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L318-L319)\n```solidity\n        if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n```\n\nAs mitigation - if the hook doesn't have any code allow only disabling it (setting the status to zero).\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/modules/Storage.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\nimport {Proxiable} from \"@src/proxy/Proxiable.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {RentalId, RentalAssetUpdate} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title StorageBase\n * @notice Storage exists in its own base contract to avoid storage slot mismatch during upgrades.\n */\ncontract StorageBase {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                                Rental Storage                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Points an order hash to whether it is active.\n    mapping(bytes32 orderHash => bool isActive) public orders;\n\n    // Points an item ID to its number of actively rented tokens. This is used to\n    // determine if an item is actively rented within the protocol. For ERC721, this\n    // value will always be 1 when actively rented. Any inactive rentals will have a\n    // value of 0.\n    mapping(RentalId itemId => uint256 amount) public rentedAssets;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Deployed Safe Storage                            //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Records all safes that have been deployed by the protocol.\n    mapping(address safe => uint256 nonce) public deployedSafes;\n\n    // Records the total amount of deployed safes.\n    uint256 public totalSafes;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                                 Hook Storage                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // When interacting with the guard, any contracts that have hooks enabled\n    // should have the guard logic routed through them.\n    mapping(address to => address hook) internal _contractToHook;\n\n    // Mapping of a bitmap which denotes the hook functions that are enabled.\n    mapping(address hook => uint8 enabled) public hookStatus;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Whitelist Storage                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Allows the safe to delegate call to an approved address. For example, delegate\n    // call to a contract that would swap out an old gnosis safe module for a new one.\n    mapping(address delegate => bool isWhitelisted) public whitelistedDelegates;\n\n    // Allows for the safe registration of extensions that can be enabled on a safe.\n    mapping(address extension => bool isWhitelisted) public whitelistedExtensions;\n}\n\n/**\n * @title Storage\n * @notice Module dedicated to maintaining all the storage for the protocol. Includes\n *         storage for active rentals, deployed rental safes, hooks, and whitelists.\n */\ncontract Storage is Proxiable, Module, StorageBase {\n    using RentalUtils for address;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Module Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Instantiate this contract as a module. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /**\n     * @notice Instantiates this contract as a module via a proxy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    function MODULE_PROXY_INSTANTIATION(\n        Kernel kernel_\n    ) external onlyByProxy onlyUninitialized {\n        kernel = kernel_;\n        initialized = true;\n    }\n\n    /**\n     * @notice Specifies which version of a module is being implemented.\n     */\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /**\n     * @notice Defines the keycode for this module.\n     */\n    function KEYCODE() public pure override returns (Keycode) {\n        return Keycode.wrap(\"STORE\");\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                              View Functions                                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Determines if an asset is actively being rented by a wallet.\n     *\n     * @param recipient  Address of the wallet which rents the asset.\n     * @param token      Address of the token.\n     * @param identifier ID of the token.\n     */\n    function isRentedOut(\n        address recipient,\n        address token,\n        uint256 identifier\n    ) external view returns (bool) {\n        // calculate the rental ID\n        RentalId rentalId = RentalUtils.getItemPointer(recipient, token, identifier);\n\n        // Determine if there is a positive amount\n        return rentedAssets[rentalId] != 0;\n    }\n\n    /**\n     * @notice Fetches the hook address that is pointing at the the target.\n     *\n     * @param to Address which has a hook pointing to it.\n     */\n    function contractToHook(address to) external view returns (address) {\n        // Fetch the hook that the address currently points to.\n        address hook = _contractToHook[to];\n\n        // This hook may have been disabled without setting a new hook to take its place.\n        // So if the hook is disabled, then return the 0 address.\n        return hookStatus[hook] != 0 ? hook : address(0);\n    }\n\n    /**\n     * @notice Determines whether the `onTransaction()` function is enabled for the hook.\n     *\n     * @param hook Address of the hook contract.\n     */\n    function hookOnTransaction(address hook) external view returns (bool) {\n        // 1 is 0x00000001. Determines if the masked bit is enabled.\n        return (uint8(1) & hookStatus[hook]) != 0;\n    }\n\n    /**\n     * @notice Determines whether the `onStart()` function is enabled for the hook.\n     *\n     * @param hook Address of the hook contract.\n     */\n    function hookOnStart(address hook) external view returns (bool) {\n        // 2 is 0x00000010. Determines if the masked bit is enabled.\n        return uint8(2) & hookStatus[hook] != 0;\n    }\n\n    /**\n     * @notice Determines whether the `onStop()` function is enabled for the hook.\n     *\n     * @param hook Address of the hook contract.\n     */\n    function hookOnStop(address hook) external view returns (bool) {\n        // 4 is 0x00000100. Determines if the masked bit is enabled.\n        return uint8(4) & hookStatus[hook] != 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Adds an order hash to storage. Once an order hash is added to storage,\n     *         the assets contained within are considered actively rented. Additionally,\n     *         rental asset IDs are added to storage which creates a blocklist on those\n     *         assets. When the blocklist is active, the protocol guard becomes active on\n     *         them and prevents transfer or approval of the assets by the owner of the\n     *         safe.\n     *\n     * @param orderHash          Hash of the rental order which is added to storage.\n     * @param rentalAssetUpdates Asset update structs which are added to storage.\n     */\n    function addRentals(\n        bytes32 orderHash,\n        RentalAssetUpdate[] memory rentalAssetUpdates\n    ) external onlyByProxy permissioned {\n        // Add the order to storage.\n        orders[orderHash] = true;\n\n        // Add the rented items to storage.\n        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n            // Update the order hash for that item.\n            rentedAssets[asset.rentalId] += asset.amount;\n        }\n    }\n\n    /**\n     * @notice Removes an order hash from storage. Once an order hash is removed from\n     *         storage, it can no longer be stopped since the protocol will have no\n     *         record of the order. Addtionally, rental asset IDs are removed from\n     *         storage. Once these hashes are removed, they are no longer blocklisted\n     *         from being transferred out of the rental wallet by the owner.\n     *\n     * @param orderHash          Hash of the rental order which will be removed from\n     *                           storage.\n     * @param rentalAssetUpdates Asset update structs which will be removed from storage.\n     */\n    function removeRentals(\n        bytes32 orderHash,\n        RentalAssetUpdate[] calldata rentalAssetUpdates\n    ) external onlyByProxy permissioned {\n        // The order must exist to be deleted.\n        if (!orders[orderHash]) {\n            revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n        } else {\n            // Delete the order from storage.\n            delete orders[orderHash];\n        }\n\n        // Process each rental asset.\n        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n            // Reduce the amount of tokens for the particular rental ID.\n            rentedAssets[asset.rentalId] -= asset.amount;\n        }\n    }\n\n    /**\n     * @notice Behaves the same as `removeRentals()`, except that orders are processed in\n     *          a loop.\n     *\n     * @param orderHashes        All order hashes which will be removed from storage.\n     * @param rentalAssetUpdates Asset update structs which will be removed from storage.\n     */\n    function removeRentalsBatch(\n        bytes32[] calldata orderHashes,\n        RentalAssetUpdate[] calldata rentalAssetUpdates\n    ) external onlyByProxy permissioned {\n        // Delete the orders from storage.\n        for (uint256 i = 0; i < orderHashes.length; ++i) {\n            // The order must exist to be deleted.\n            if (!orders[orderHashes[i]]) {\n                revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n            } else {\n                // Delete the order from storage.\n                delete orders[orderHashes[i]];\n            }\n        }\n\n        // Process each rental asset.\n        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n            // Reduce the amount of tokens for the particular rental ID.\n            rentedAssets[asset.rentalId] -= asset.amount;\n        }\n    }\n\n    /**\n     * @notice Adds the addresss of a rental safe to storage so that protocol-deployed\n     *         rental safes can be distinguished from those deployed elsewhere.\n     *\n     * @param safe Address of the rental safe to add to storage.\n     */\n    function addRentalSafe(address safe) external onlyByProxy permissioned {\n        // Get the new safe count.\n        uint256 newSafeCount = totalSafes + 1;\n\n        // Register the safe as deployed.\n        deployedSafes[safe] = newSafeCount;\n\n        // Increment nonce.\n        totalSafes = newSafeCount;\n    }\n\n    /**\n     * @notice Connects a hook to a destination address. Once an active path is made,\n     *         any transactions originating from a rental safe to the target address\n     *         will use a hook as middleware. The hook chosen is determined by the path\n     *         set.\n     *\n     * @param to   Target address which will use a hook as middleware.\n     * @param hook Address of the hook which will act as a middleware.\n     */\n    function updateHookPath(address to, address hook) external onlyByProxy permissioned {\n        // Require that the `to` address is a contract.\n        if (to.code.length == 0) revert Errors.StorageModule_NotContract(to);\n\n        // Require that the `hook` address is a contract.\n        if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n\n        // Point the `to` address to the `hook` address.\n        _contractToHook[to] = hook;\n    }\n\n    /**\n     * @notice Updates a hook with a bitmap that indicates its active functionality.\n     *         A valid bitmap is any decimal value that is less than or equal\n     *         to 7 (0x111).\n     *\n     * @param hook   Address of the hook contract.\n     * @param bitmap Decimal value that defines the active functionality on the hook.\n     */\n    function updateHookStatus(\n        address hook,\n        uint8 bitmap\n    ) external onlyByProxy permissioned {\n        // Require that the `hook` address is a contract.\n        if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n\n        // 7 is 0x00000111. This ensures that only a valid bitmap can be set.\n        if (bitmap > uint8(7))\n            revert Errors.StorageModule_InvalidHookStatusBitmap(bitmap);\n\n        // Update the status of the hook.\n        hookStatus[hook] = bitmap;\n    }\n\n    /**\n     * @notice Toggles whether an address can be delegate called.\n     *\n     * @param delegate  Address which can be delegate called.\n     * @param isEnabled Boolean indicating whether the address is enabled.\n     */\n    function toggleWhitelistDelegate(\n        address delegate,\n        bool isEnabled\n    ) external onlyByProxy permissioned {\n        whitelistedDelegates[delegate] = isEnabled;\n    }\n\n    /**\n     * @notice Toggles whether an extension is whitelisted.\n     *\n     * @param extension Gnosis safe module which can be added to a rental safe.\n     * @param isEnabled Boolean indicatingwhether the module is enabled.\n     */\n    function toggleWhitelistExtension(\n        address extension,\n        bool isEnabled\n    ) external onlyByProxy permissioned {\n        whitelistedExtensions[extension] = isEnabled;\n    }\n\n    /**\n     * @notice Upgrades the contract to a different implementation. This implementation\n     *         contract must be compatible with ERC-1822 or else the upgrade will fail.\n     *\n     * @param newImplementation Address of the implementation contract to upgrade to.\n     */\n    function upgrade(address newImplementation) external onlyByProxy permissioned {\n        // _upgrade is implemented in the Proxiable contract.\n        _upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the contract which prevents upgrading the implementation contract.\n     *         There is no way to unfreeze once a contract has been frozen.\n     */\n    function freeze() external onlyByProxy permissioned {\n        // _freeze is implemented in the Proxiable contract.\n        _freeze();\n    }\n}"
    }
  ]
}