{
  "Title": "Rate Limiters Can Lead to a Denial-of-Service Attack",
  "Content": "The protocol uses [rate limiters](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/lib/RateLimiter.sol) to limit its exposure in case of financial loss. These limit the amount of ETH that can be [bridged from L2](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l2/L2MessageService.sol#L109), as well as the amount of ETH that can be [claimed on L1](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l1/L1MessageService.sol#L132).\n\n\nHowever, such protocol-wide rate limits can be used to DOS the protocol. For example, a well-funded attacker could deposit and withdraw the rate limit in ETH on each [rate limit period](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/lib/RateLimiter.sol#L16). If this were to occur, users' ETH would be stuck on L2 as the rate limit would block withdrawals. Users would also be prevented from adding a [postman fee](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l2/L2MessageService.sol#L109), forcing them to be their own postman to get their transactions included on L1.\n\n\nConsider removing the rate limiter or introducing more sophisticated limits. If it is kept, consider composing an action plan and incorporating monitoring for potential cases of abuse. Any change, such as more sophisticated rate limits, would have to be end-to-end tested.\n\n\n***Update:** Acknowledged, will resolve. The Linea team stated:*\n\n\n\n> *This will be a future enhancement. Current withdrawal limits are placed on the bridge to minimize the impact of any potential malicious actors and will be removed at a later date.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/messageService/lib/RateLimiter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { IRateLimiter } from \"../../interfaces/IRateLimiter.sol\";\n\n/**\n * @title Rate Limiter by period and amount using the block timestamp.\n * @author ConsenSys Software Inc.\n * @notice You can use this control numeric limits over a period using timestamp.\n **/\ncontract RateLimiter is Initializable, IRateLimiter, AccessControlUpgradeable {\n  bytes32 public constant RATE_LIMIT_SETTER_ROLE = keccak256(\"RATE_LIMIT_SETTER_ROLE\");\n\n  uint256 public periodInSeconds; // how much time before limit resets.\n  uint256 public limitInWei; // max ether to withdraw per period.\n\n  // @dev Public for ease of consumption.\n  // @notice The time at which the current period ends at.\n  uint256 public currentPeriodEnd;\n\n  // @dev Public for ease of consumption.\n  // @notice Amounts already withdrawn this period.\n  uint256 public currentPeriodAmountInWei;\n\n  uint256[10] private _gap;\n\n  /**\n   * @notice Initialises the limits and period for the rate limiter.\n   * @param _periodInSeconds The length of the period in seconds.\n   * @param _limitInWei The limit allowed in the period in Wei.\n   **/\n  function __RateLimiter_init(uint256 _periodInSeconds, uint256 _limitInWei) internal onlyInitializing {\n    if (_periodInSeconds == 0) {\n      revert PeriodIsZero();\n    }\n\n    if (_limitInWei == 0) {\n      revert LimitIsZero();\n    }\n\n    periodInSeconds = _periodInSeconds;\n    limitInWei = _limitInWei;\n    currentPeriodEnd = block.timestamp + _periodInSeconds;\n  }\n\n  /**\n   * @notice Increments the amount used in the period.\n   * @dev The amount determining logic is external to this (e.g. fees are included when calling here).\n   * @dev Reverts if the limit is breached.\n   * @param _usedAmount The amount used to be added.\n   **/\n  function _addUsedAmount(uint256 _usedAmount) internal {\n    uint256 currentPeriodAmountTemp;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      currentPeriodAmountTemp = _usedAmount;\n    } else {\n      currentPeriodAmountTemp = currentPeriodAmountInWei + _usedAmount;\n    }\n\n    if (currentPeriodAmountTemp > limitInWei) {\n      revert RateLimitExceeded();\n    }\n\n    currentPeriodAmountInWei = currentPeriodAmountTemp;\n  }\n\n  /**\n   * @notice Resets the rate limit amount.\n   * @dev If the used amount is higher, it is set to the limit to avoid confusion/issues.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the LimitAmountChanged event.\n   * @dev usedLimitAmountToSet will use the default value of zero if period has expired\n   * @param _amount The amount to reset the limit to.\n   **/\n  function resetRateLimitAmount(uint256 _amount) external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    uint256 usedLimitAmountToSet;\n    bool amountUsedLoweredToLimit;\n    bool usedAmountResetToZero;\n\n    if (currentPeriodEnd < block.timestamp) {\n      currentPeriodEnd = block.timestamp + periodInSeconds;\n      usedAmountResetToZero = true;\n    } else {\n      if (_amount < currentPeriodAmountInWei) {\n        usedLimitAmountToSet = _amount;\n        amountUsedLoweredToLimit = true;\n      }\n    }\n\n    limitInWei = _amount;\n\n    if (usedAmountResetToZero || amountUsedLoweredToLimit) {\n      currentPeriodAmountInWei = usedLimitAmountToSet;\n    }\n\n    emit LimitAmountChanged(_msgSender(), _amount, amountUsedLoweredToLimit, usedAmountResetToZero);\n  }\n\n  /**\n   * @notice Resets the amount used to zero.\n   * @dev Only the RATE_LIMIT_SETTER_ROLE is allowed to execute this function.\n   * @dev Emits the AmountUsedInPeriodReset event.\n   **/\n  function resetAmountUsedInPeriod() external onlyRole(RATE_LIMIT_SETTER_ROLE) {\n    currentPeriodAmountInWei = 0;\n\n    emit AmountUsedInPeriodReset(_msgSender());\n  }\n}"
    }
  ]
}