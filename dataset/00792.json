{
  "Title": "CCIP router address cannot be updated",
  "Content": "# CCIP router address cannot be updated\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/WrappedTokenBridge.sol\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/WrappedTokenBridge.sol</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/base/SDLPoolCCIPController.sol\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/base/SDLPoolCCIPController.sol</a>\n\n\n## Summary\n\nCCIP Router addresses cannot be updated in `SDLPoolCCIPController.sol, SDLPoolCCIPControllerPrimary.sol, SDLPoolCCIPControllerSecondary.sol, WrappedTokenBridge.sol` . \n\n## Vulnerability Details\n\nOn contracts that inherit from `CCIPReceiver`, router addresses need to be updateable. Chainlink may update the router addresses as they did before. This issue introduces a single point of failure that is outside of the protocol's control.\n\n[An example contract](https://github.com/smartcontractkit/ccip-tic-tac-toe/blob/main/contracts/TTTDemo.sol#L81-L83) that uses CCIP. [Taken from Chainlink docs](https://docs.chain.link/ccip/examples#ccip-tic-tac-toe).\n\n[Chainlink documents noticing users about router address updating on testnet.](https://docs.chain.link/ccip/release-notes#v120-release-on-testnet---2023-12-08)\n\n> CCIP v1.0.0 has been deprecated on testnet. You must use the new router addresses mentioned in the [CCIP v1.2.0 configuration page](https://docs.chain.link/ccip/supported-networks/v1_2_0/testnet) **before January 31st, 2024**\n> \n\nOn Testnets, router contracts in v1.0.0 and v1.2.0 are different. It means that router contract addresses can change from version to version. So CCIPReceivers should accommodate this. Mainnet is on v1.0.0 which means its router addresses can change with an update.\n\n## Impact\n\nImpact: High\nLikelihood: Low\n\nRouter address deprecation will cause the protocol to stop working.\n\n## Tools Used\n\nManual review.\n\n## Recommendations\n\nImplement a function to update the `_router` address. Example shown below:\n\n```jsx\nfunction updateRouter(address routerAddr) external onlyOwner {\n        _router = routerAddr;\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/TTTDemo.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {IRouterClient} from \"cross-not-official/contracts/interfaces/IRouterClient.sol\";\nimport {OwnerIsCreator} from \"cross-not-official/contracts/OwnerIsCreator.sol\";\nimport {Client} from \"cross-not-official/contracts/libraries/Client.sol\";\nimport {CCIPReceiver} from \"cross-not-official/contracts/applications/CCIPReceiver.sol\";\nimport {IERC20} from \"cross-not-official/vendor/openzeppelin-solidity/v4.8.0/token/ERC20/IERC20.sol\";\n\n/**\n * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.\n * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.\n * DO NOT USE THIS CODE IN PRODUCTION.\n */\n\n/// @title - A simple messenger contract for sending/receiving string messages across chains.\n/// Pay using native tokens (e.g, ETH in Ethereum)\ncontract TTTDemo is CCIPReceiver, OwnerIsCreator {\n    // Custom errors to provide more descriptive revert messages.\n    error NoMessageReceived(); // Used when trying to access a message but no messages have been received.\n    error IndexOutOfBound(uint256 providedIndex, uint256 maxIndex); // Used when the provided index is out of bounds.\n    error MessageIdNotExist(bytes32 messageId); // Used when the provided message ID does not exist.\n    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.\n    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.\n\n    struct GameSession {\n        bytes32 sessionId;\n        address player_1; // player who starts the game\n        address player_2; // the other player in the game\n        address winner; // winner of game\n        address turn; // check who takes action in next step\n        uint8[9] player1Status; // current status for player 1\n        uint8[9] player2Status; // current status for player 2\n    }\n    mapping(bytes32 => GameSession) public gameSessions;\n    bytes32[] public sessionIds;\n\n    uint8[9] initialCombination = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    function getPlayer1Status(bytes32 _sessionId) external view returns (uint8[9] memory){\n        return gameSessions[_sessionId].player1Status;\n    }\n    function getPlayer2Status(bytes32 _sessionId) external view returns (uint8[9] memory){\n        return gameSessions[_sessionId].player2Status;\n    }\n\n    // Event emitted when a message is sent to another chain.\n    event MessageSent(\n        bytes32 indexed messageId, // The unique ID of the message.\n        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.\n        address receiver, // The address of the receiver on the destination chain.\n        GameSession message, // The message being sent.\n        uint256 fees // The fees paid for sending the message.\n    );\n\n    // Event emitted when a message is received from another chain.\n    event MessageReceived(\n        bytes32 indexed messageId, // The unique ID of the message.\n        uint64 indexed sourceChainSelector, // The chain selector of the source chain.\n        address sender, // The address of the sender from the source chain.\n        GameSession message // The message that was received.\n    );\n\n    // Struct to hold details of a message.\n    struct Message {\n        uint64 sourceChainSelector; // The chain selector of the source chain.\n        address sender; // The address of the sender.\n        GameSession message; // The content of the message.\n    }\n\n    // Storage variables.\n    bytes32[] public receivedMessages; // Array to keep track of the IDs of received messages.\n    mapping(bytes32 => Message) public messageDetail; // Mapping from message ID to Message struct, storing details of each received message.\n    address public _router;\n\n    /// @notice Constructor initializes the contract with the router address.\n    /// @param router The address of the router contract.\n    constructor(address router) CCIPReceiver(router) {\n    }\n\n    function updateRouter(address routerAddr) external {\n        _router = routerAddr;\n    }\n\n    function start(uint64 destinationChainSelector, address receiver) external {\n        bytes32 uniqueId = keccak256(abi.encodePacked(block.timestamp, msg.sender));\n        sessionIds.push(uniqueId);\n        gameSessions[uniqueId]= GameSession(\n            uniqueId,\n            msg.sender,\n            address(0),\n            address(0),\n            msg.sender,\n            initialCombination,\n            initialCombination\n            );\n\n        sendMessage(destinationChainSelector, receiver, gameSessions[uniqueId]);\n    }\n\n    function checkWin(uint8[9] memory playerStatus) public pure returns(bool _return){\n        if(horizontalCheck(playerStatus) || verticalCheck(playerStatus) || diagonalCheck(playerStatus)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Sends data to receiver on the destination chain.\n    /// @dev Assumes your contract has sufficient native asset (e.g, ETH on Ethereum, MATIC on Polygon...).\n    /// @param destinationChainSelector The identifier (aka selector) for the destination blockchain.\n    /// @param receiver The address of the recipient on the destination blockchain.\n    /// @param message The string message to be sent.\n    /// @return messageId The ID of the message that was sent.\n    function sendMessage(\n        uint64 destinationChainSelector,\n        address receiver,\n        GameSession memory message\n    ) public returns (bytes32 messageId) {\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\n            data: abi.encode(message), // ABI-encoded string message\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\n            extraArgs: Client._argsToBytes(\n                Client.EVMExtraArgsV1({gasLimit: 400_000, strict: false}) // Additional arguments, setting gas limit and non-strict sequency mode\n            ),\n            feeToken: address(0) // Setting feeToken to zero address, indicating native asset will be used for fees\n        });\n\n        // Initialize a router client instance to interact with cross-chain router\n        IRouterClient router = IRouterClient(_router);\n\n        // Get the fee required to send the message\n        uint256 fees = router.getFee(destinationChainSelector, evm2AnyMessage);\n\n        // Send the message through the router and store the returned message ID\n        messageId = router.ccipSend{value: fees}(\n            destinationChainSelector,\n            evm2AnyMessage\n        );\n\n        // Emit an event with message details\n        emit MessageSent(\n            messageId,\n            destinationChainSelector,\n            receiver,\n            message,\n            fees\n        );\n\n        // Return the message ID\n        return messageId;\n    }\n\n        // check if the position is taken then move\n    function move(\n        uint256 x, \n        uint256 y, \n        uint256 player, \n        bytes32 sessionId, \n        uint64 destinationChainSelector,\n        address receiver) \n        public  \n    {\n        GameSession memory gs = gameSessions[sessionId];\n        // make sure the game session setup and not over.\n        require(gs.player_1 != address(0), \"the session is not setup, please start game first!\");\n        require(gs.winner == address(0), \"the game is over\");\n        \n        // make sure the player is in the game session\n        require(player == 1 || player == 2, \"you must be player1 or player2\"); //this is used to when player has the same address\n        \n        if(player == 1) {\n            // make sure it is player1's turn to move\n            require(gs.player_1 == msg.sender && gs.turn == msg.sender, \"it is not your turn\");\n            \n            // 1. if the position is not taken by the oppenent, then take the position\n            if(gs.player1Status[x * 3 + y] == 0 && gs.player2Status[x * 3 + y] == 0) {\n               gameSessions[sessionId].player1Status[x * 3 + y] = 1;\n               \n               // 2. check if player1 wins or make the turn to the opponent, send the message\n               if(checkWin(gameSessions[sessionId].player1Status)) {\n                   gameSessions[sessionId].winner = gameSessions[sessionId].player_1;\n               } else {\n                   gameSessions[sessionId].turn = gameSessions[sessionId].player_2;\n               }\n               sendMessage(destinationChainSelector, receiver, gameSessions[sessionId]);\n            } else {\n                revert(\"the position is occupied\");\n            }\n        } else if(player == 2) {\n            // make sure it is player2's turn to move, this is the first step for player2\n            require((gs.player_2 == msg.sender && gs.turn == msg.sender) || gs.player_2 == address(0), \"it is not your turn\");\n\n            if(gs.player_2 == address(0)) {\n                gameSessions[sessionId].player_2 = msg.sender;\n            }\n\n            // 1. if the position is not taken by the oppenent, then take the position\n            if(gs.player1Status[x * 3 + y] == 0 && gs.player2Status[x * 3 + y] == 0) {\n               gameSessions[sessionId].player2Status[x * 3 + y] = 1; \n\n               // 2. check if player1 wins or make the turn to the oppenent, send the message\n               if(checkWin(gameSessions[sessionId].player2Status)) {\n                   gameSessions[sessionId].winner = gameSessions[sessionId].player_2;\n               } else {\n                   gameSessions[sessionId].turn = gameSessions[sessionId].player_1;\n               }\n               sendMessage(destinationChainSelector, receiver, gameSessions[sessionId]);\n            } else {\n                revert(\"the position is occupied\");\n            }\n        }\n    } \n\n    \n\n    /// handle a received message\n    function _ccipReceive(\n        Client.Any2EVMMessage memory any2EvmMessage\n    ) internal override {\n        bytes32 messageId = any2EvmMessage.messageId; // fetch the messageId\n        uint64 sourceChainSelector = any2EvmMessage.sourceChainSelector; // fetch the source chain identifier (aka selector)\n        address sender = abi.decode(any2EvmMessage.sender, (address)); // abi-decoding of the sender address\n        GameSession memory message = abi.decode(any2EvmMessage.data, (GameSession)); // abi-decoding of the sent string message\n        receivedMessages.push(messageId);\n        Message memory detail = Message(sourceChainSelector, sender, message);\n        messageDetail[messageId] = detail;\n        gameSessions[message.sessionId] = message;\n        sessionIds.push(message.sessionId);\n\n        emit MessageReceived(messageId, sourceChainSelector, sender, message);\n    }\n\n    /// @notice Get the total number of received messages.\n    /// @return number The total number of received messages.\n    function getNumberOfReceivedMessages()\n        external\n        view\n        returns (uint256 number)\n    {\n        return receivedMessages.length;\n    }\n\n    /// @notice Fetches the details of the last received message.\n    /// @dev Reverts if no messages have been received yet.\n    /// @return messageId The ID of the last received message.\n    /// @return sourceChainSelector The source chain identifier (aka selector) of the last received message.\n    /// @return sender The address of the sender of the last received message.\n    /// @return message The last received message.\n    function getLastReceivedMessageDetails()\n        external\n        view\n        returns (\n            bytes32 messageId,\n            uint64 sourceChainSelector,\n            address sender,\n            GameSession memory message\n        )\n    {\n        // Revert if no messages have been received\n        if (receivedMessages.length == 0) revert NoMessageReceived();\n\n        // Fetch the last received message ID\n        messageId = receivedMessages[receivedMessages.length - 1];\n\n        // Fetch the details of the last received message\n        Message memory detail = messageDetail[messageId];\n\n        return (\n            messageId,\n            detail.sourceChainSelector,\n            detail.sender,\n            detail.message\n        );\n    }\n\n\n    function horizontalCheck(uint8[9] memory playerStatus) private pure returns(bool horizontalValidation){\n        if(playerStatus[0] == 1 && playerStatus[1] == 1 && playerStatus[2] == 1) {\n            return true;\n        }\n\n        if(playerStatus[3] == 1 && playerStatus[4] == 1 && playerStatus[5] == 1) {\n            return true;\n        }\n\n        if(playerStatus[6] == 1 && playerStatus[7] == 1 && playerStatus[8] == 1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function verticalCheck(uint8[9] memory playerStatus) private pure returns(bool verticalValidation){\n        if(playerStatus[0] == 1 && playerStatus[3] == 1 && playerStatus[6] == 1) {\n            return true;\n        }\n\n        if(playerStatus[1] == 1 && playerStatus[4] == 1 && playerStatus[7] == 1) {\n            return true;\n        }\n\n        if(playerStatus[2] == 1 && playerStatus[5] == 1 && playerStatus[8] == 1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function diagonalCheck(uint8[9] memory playerStatus) private pure returns(bool diagonalValidation){\n        if(playerStatus[0] == 1 && playerStatus[4] == 1 && playerStatus[8] == 1) {\n            return true;\n        }\n\n        if(playerStatus[2] == 1 && playerStatus[4] == 1 && playerStatus[6] == 1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Fallback function to allow the contract to receive Ether.\n    /// @dev This function has no function body, making it a default function for receiving Ether.\n    /// It is automatically called when Ether is sent to the contract without any data.\n    receive() external payable {}\n\n    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.\n    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.\n    /// It should only be callable by the owner of the contract.\n    /// @param beneficiary The address to which the Ether should be sent.\n    function withdraw(address beneficiary) public onlyOwner {\n        // Retrieve the balance of this contract\n        uint256 amount = address(this).balance;\n\n        // Revert if there is nothing to withdraw\n        if (amount == 0) revert NothingToWithdraw();\n\n        // Attempt to send the funds, capturing the success status and discarding any return data\n        (bool sent, ) = beneficiary.call{value: amount}(\"\");\n\n        // Revert if the send failed, with information about the attempted transfer\n        if (!sent) revert FailedToWithdrawEth(msg.sender, beneficiary, amount);\n    }\n}"
    }
  ]
}