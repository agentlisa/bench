{
  "Title": "[18] Setters do not have `equality/zero` checkers",
  "Content": "\n### Proof of Concept\n\nThere are multiple instances where protocol does not validate input data, to list a few, take a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L248-L260\n\n```solidity\n    /// @dev Changes the minimum timelock duration for future operations.\n    /// @param _newDelay The new minimum delay time (in seconds) for future operations.\n    function updateDelay(uint256 _newDelay) external onlySelf {\n        emit ChangeMinDelay(minDelay, _newDelay);\n        minDelay = _newDelay;\n    }\n\n    /// @dev Updates the address of the security council.\n    /// @param _newSecurityCouncil The address of the new security council.\n    function updateSecurityCouncil(address _newSecurityCouncil) external onlySelf {\n        emit ChangeSecurityCouncil(securityCouncil, _newSecurityCouncil);\n        securityCouncil = _newSecurityCouncil;\n    }\n```\n\nEvidently, these functions are used for updating governance values, but no checks exist on making sure that the values being passed are not the same as the stored value for these variables.\n\n- Another instance can be seen here: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/ContractDeployer.sol#L62-L70\n\n```solidity\n    /// @notice Update the used version of the account.\n    /// @param _version The new version of the AA protocol to use.\n    /// @dev Note that it allows changes from account to non-account and vice versa.\n    function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n        accountInfo[msg.sender].supportedAAVersion = _version;\n\n        emit AccountVersionUpdated(msg.sender, _version);\n    }\n\n```\n\nAs we can see, there's no verification that`_version` is different from `accountInfo[msg.sender].supportedAAVersion` or not being `0`\n\n\n### Impact\n\nNo input validation in this case leading to an unnecessary execution of code if the value is the same, or even if it's zero.\n\n### Recommended Mitigation Steps\n\nImplement equality checkers in setter functions.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/governance/Governance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IGovernance} from \"./IGovernance.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Contract design is inspired by OpenZeppelin TimelockController and in-house Diamond Proxy upgrade mechanism.\n/// @notice This contract manages operations (calls with preconditions) for governance tasks.\n/// The contract allows for operations to be scheduled, executed, and canceled with\n/// appropriate permissions and delays. It is used for managing and coordinating upgrades\n/// and changes in all zkSync hyperchain governed contracts.\n///\n/// Operations can be proposed as either fully transparent upgrades with on-chain data,\n/// or \"shadow\" upgrades where upgrade data is not published on-chain before execution. Proposed operations\n/// are subject to a delay before they can be executed, but they can be executed instantly\n/// with the security councilâ€™s permission.\ncontract Governance is IGovernance, Ownable2Step {\n    /// @notice A constant representing the timestamp for completed operations.\n    uint256 internal constant EXECUTED_PROPOSAL_TIMESTAMP = uint256(1);\n\n    /// @notice The address of the security council.\n    /// @dev It is supposed to be multisig contract.\n    address public securityCouncil;\n\n    /// @notice A mapping to store timestamps when each operation will be ready for execution.\n    /// @dev - 0 means the operation is not created.\n    /// @dev - 1 (EXECUTED_PROPOSAL_TIMESTAMP) means the operation is already executed.\n    /// @dev - any other value means timestamp in seconds when the operation will be ready for execution.\n    mapping(bytes32 operationId => uint256 executionTimestamp) public timestamps;\n\n    /// @notice The minimum delay in seconds for operations to be ready for execution.\n    uint256 public minDelay;\n\n    /// @notice Initializes the contract with the admin address, security council address, and minimum delay.\n    /// @param _admin The address to be assigned as the admin of the contract.\n    /// @param _securityCouncil The address to be assigned as the security council of the contract.\n    /// @param _minDelay The initial minimum delay (in seconds) to be set for operations.\n    constructor(address _admin, address _securityCouncil, uint256 _minDelay) {\n        require(_admin != address(0), \"Admin should be non zero address\");\n\n        _transferOwnership(_admin);\n\n        securityCouncil = _securityCouncil;\n        emit ChangeSecurityCouncil(address(0), _securityCouncil);\n\n        minDelay = _minDelay;\n        emit ChangeMinDelay(0, _minDelay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks that the message sender is contract itself.\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Only governance contract itself is allowed to call this function\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active security council.\n    modifier onlySecurityCouncil() {\n        require(msg.sender == securityCouncil, \"Only security council is allowed to call this function\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active owner or an active security council.\n    modifier onlyOwnerOrSecurityCouncil() {\n        require(\n            msg.sender == owner() || msg.sender == securityCouncil,\n            \"Only the owner and security council are allowed to call this function\"\n        );\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            OPERATION GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Returns whether an id corresponds to a registered operation. This\n    /// includes Waiting, Ready, and Done operations.\n    function isOperation(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) != OperationState.Unset;\n    }\n\n    /// @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n    function isOperationPending(bytes32 _id) public view returns (bool) {\n        OperationState state = getOperationState(_id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n    function isOperationReady(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is done or not.\n    function isOperationDone(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Done;\n    }\n\n    /// @dev Returns operation state.\n    function getOperationState(bytes32 _id) public view returns (OperationState) {\n        uint256 timestamp = timestamps[_id];\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == EXECUTED_PROPOSAL_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SCHEDULING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Propose a fully transparent upgrade, providing upgrade data on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function scheduleTransparent(Operation calldata _operation, uint256 _delay) external onlyOwner {\n        bytes32 id = hashOperation(_operation);\n        _schedule(id, _delay);\n        emit TransparentOperationScheduled(id, _delay, _operation);\n    }\n\n    /// @notice Propose \"shadow\" upgrade, upgrade data is not publishing on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade may be executed by the owner.\n    function scheduleShadow(bytes32 _id, uint256 _delay) external onlyOwner {\n        _schedule(_id, _delay);\n        emit ShadowOperationScheduled(_id, _delay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CANCELING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Cancel the scheduled operation.\n    /// @dev Only owner can call this function.\n    /// @param _id Proposal id value (see `hashOperation`)\n    function cancel(bytes32 _id) external onlyOwner {\n        require(isOperationPending(_id), \"Operation must be pending\");\n        delete timestamps[_id];\n        emit OperationCancelled(_id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXECUTING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Executes the scheduled operation after the delay passed.\n    /// @dev Both the owner and security council may execute delayed operations.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    function execute(Operation calldata _operation) external payable onlyOwnerOrSecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is ready to proceed.\n        require(isOperationReady(id), \"Operation must be ready before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still ready after execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationReady(id), \"Operation must be ready after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @notice Executes the scheduled operation with the security council instantly.\n    /// @dev Only the security council may execute an operation instantly.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    function executeInstant(Operation calldata _operation) external payable onlySecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is in a pending state before proceeding.\n        require(isOperationPending(id), \"Operation must be pending before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still pending before execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationPending(id), \"Operation must be pending after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @dev Returns the identifier of an operation.\n    /// @param _operation The operation object to compute the identifier for.\n    function hashOperation(Operation calldata _operation) public pure returns (bytes32) {\n        return keccak256(abi.encode(_operation));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Schedule an operation that is to become valid after a given delay.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function _schedule(bytes32 _id, uint256 _delay) internal {\n        require(!isOperation(_id), \"Operation with this proposal id already exists\");\n        require(_delay >= minDelay, \"Proposed delay is less than minimum delay\");\n\n        timestamps[_id] = block.timestamp + _delay;\n    }\n\n    /// @dev Execute an operation's calls.\n    /// @param _calls The array of calls to be executed.\n    function _execute(Call[] calldata _calls) internal {\n        for (uint256 i = 0; i < _calls.length; ++i) {\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\n            if (!success) {\n                // Propagate an error if the call fails.\n                assembly {\n                    revert(add(returnData, 0x20), mload(returnData))\n                }\n            }\n        }\n    }\n\n    /// @notice Verifies if the predecessor operation is completed.\n    /// @param _predecessorId The hash of the operation that should be completed.\n    /// @dev Doesn't check the operation to be complete if the input is zero.\n    function _checkPredecessorDone(bytes32 _predecessorId) internal view {\n        require(_predecessorId == bytes32(0) || isOperationDone(_predecessorId), \"Predecessor operation not completed\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SELF UPGRADES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Changes the minimum timelock duration for future operations.\n    /// @param _newDelay The new minimum delay time (in seconds) for future operations.\n    function updateDelay(uint256 _newDelay) external onlySelf {\n        emit ChangeMinDelay(minDelay, _newDelay);\n        minDelay = _newDelay;\n    }\n\n    /// @dev Updates the address of the security council.\n    /// @param _newSecurityCouncil The address of the new security council.\n    function updateSecurityCouncil(address _newSecurityCouncil) external onlySelf {\n        emit ChangeSecurityCouncil(securityCouncil, _newSecurityCouncil);\n        securityCouncil = _newSecurityCouncil;\n    }\n\n    /// @dev Contract might receive/hold ETH as part of the maintenance process.\n    receive() external payable {}\n}"
    },
    {
      "filename": "code/system-contracts/contracts/ContractDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ImmutableData} from \"./interfaces/IImmutableSimulator.sol\";\nimport {IContractDeployer} from \"./interfaces/IContractDeployer.sol\";\nimport {CREATE2_PREFIX, CREATE_PREFIX, NONCE_HOLDER_SYSTEM_CONTRACT, ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT, FORCE_DEPLOYER, MAX_SYSTEM_CONTRACT_ADDRESS, KNOWN_CODE_STORAGE_CONTRACT, BASE_TOKEN_SYSTEM_CONTRACT, IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT, COMPLEX_UPGRADER_CONTRACT, KECCAK256_SYSTEM_CONTRACT} from \"./Constants.sol\";\n\nimport {Utils} from \"./libraries/Utils.sol\";\nimport {EfficientCall} from \"./libraries/EfficientCall.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice System smart contract that is responsible for deploying other smart contracts on zkSync.\n * @dev The contract is responsible for generating the address of the deployed smart contract,\n * incrementing the deployment nonce and making sure that the constructor is never called twice in a contract.\n * Note, contracts with bytecode that have already been published to L1 once\n * do not need to be published anymore.\n */\ncontract ContractDeployer is IContractDeployer, ISystemContract {\n    /// @notice Information about an account contract.\n    /// @dev For EOA and simple contracts (i.e. not accounts) this value is 0.\n    mapping(address => AccountInfo) internal accountInfo;\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Callable only by self\");\n        _;\n    }\n\n    /// @notice Returns information about a certain account.\n    function getAccountInfo(address _address) external view returns (AccountInfo memory info) {\n        return accountInfo[_address];\n    }\n\n    /// @notice Returns the account abstraction version if `_address` is a deployed contract.\n    /// Returns the latest supported account abstraction version if `_address` is an EOA.\n    function extendedAccountVersion(address _address) public view returns (AccountAbstractionVersion) {\n        AccountInfo memory info = accountInfo[_address];\n        if (info.supportedAAVersion != AccountAbstractionVersion.None) {\n            return info.supportedAAVersion;\n        }\n\n        // It is an EOA, it is still an account.\n        if (\n            _address > address(MAX_SYSTEM_CONTRACT_ADDRESS) &&\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getRawCodeHash(_address) == 0\n        ) {\n            return AccountAbstractionVersion.Version1;\n        }\n\n        return AccountAbstractionVersion.None;\n    }\n\n    /// @notice Stores the new account information\n    function _storeAccountInfo(address _address, AccountInfo memory _newInfo) internal {\n        accountInfo[_address] = _newInfo;\n    }\n\n    /// @notice Update the used version of the account.\n    /// @param _version The new version of the AA protocol to use.\n    /// @dev Note that it allows changes from account to non-account and vice versa.\n    function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n        accountInfo[msg.sender].supportedAAVersion = _version;\n\n        emit AccountVersionUpdated(msg.sender, _version);\n    }\n\n    /// @notice Updates the nonce ordering of the account. Currently,\n    /// it only allows changes from sequential to arbitrary ordering.\n    /// @param _nonceOrdering The new nonce ordering to use.\n    function updateNonceOrdering(AccountNonceOrdering _nonceOrdering) external onlySystemCall {\n        AccountInfo memory currentInfo = accountInfo[msg.sender];\n\n        require(\n            _nonceOrdering == AccountNonceOrdering.Arbitrary &&\n                currentInfo.nonceOrdering == AccountNonceOrdering.Sequential,\n            \"It is only possible to change from sequential to arbitrary ordering\"\n        );\n\n        currentInfo.nonceOrdering = _nonceOrdering;\n        _storeAccountInfo(msg.sender, currentInfo);\n\n        emit AccountNonceOrderingUpdated(msg.sender, _nonceOrdering);\n    }\n\n    /// @notice Calculates the address of a deployed contract via create2\n    /// @param _sender The account that deploys the contract.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _salt The create2 salt.\n    /// @param _input The constructor data.\n    /// @return newAddress The derived address of the account.\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) public view override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE2, since\n        // the prefix begins with 0x20....\n        bytes32 constructorInputHash = EfficientCall.keccak(_input);\n\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, constructorInputHash)\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Calculates the address of a deployed contract via create\n    /// @param _sender The account that deploys the contract.\n    /// @param _senderNonce The deploy nonce of the sender's account.\n    function getNewAddressCreate(\n        address _sender,\n        uint256 _senderNonce\n    ) public pure override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE, since\n        // the prefix begins with 0x63....\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    function create2(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return create2Account(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev This method also accepts nonce as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return createAccount(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create2Account(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate2(msg.sender, _bytecodeHash, _salt, _input);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev This method also accepts salt as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    function createAccount(\n        bytes32, // salt\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        uint256 senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate(msg.sender, senderNonce);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice A struct that describes a forced deployment on an address\n    struct ForceDeployment {\n        // The bytecode hash to put on an address\n        bytes32 bytecodeHash;\n        // The address on which to deploy the bytecodehash to\n        address newAddress;\n        // Whether to run the constructor on the force deployment\n        bool callConstructor;\n        // The value with which to initialize a contract\n        uint256 value;\n        // The constructor calldata\n        bytes input;\n    }\n\n    /// @notice The method that can be used to forcefully deploy a contract.\n    /// @param _deployment Information about the forced deployment.\n    /// @param _sender The `msg.sender` inside the constructor call.\n    function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n        _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n\n        // Since the `forceDeployOnAddress` function is called only during upgrades, the Governance is trusted to correctly select\n        // the addresses to deploy the new bytecodes to and to assess whether overriding the AccountInfo for the \"force-deployed\"\n        // contract is acceptable.\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = AccountAbstractionVersion.None;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_deployment.newAddress, newAccountInfo);\n\n        _constructContract(\n            _sender,\n            _deployment.newAddress,\n            _deployment.bytecodeHash,\n            _deployment.input,\n            false,\n            _deployment.callConstructor\n        );\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    /// @dev We do not require `onlySystemCall` here, since the method is accessible only\n    /// by `FORCE_DEPLOYER`.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments) external payable {\n        require(\n            msg.sender == FORCE_DEPLOYER || msg.sender == address(COMPLEX_UPGRADER_CONTRACT),\n            \"Can only be called by FORCE_DEPLOYER or COMPLEX_UPGRADER_CONTRACT\"\n        );\n\n        uint256 deploymentsLength = _deployments.length;\n        // We need to ensure that the `value` provided by the call is enough to provide `value`\n        // for all of the deployments\n        uint256 sumOfValues = 0;\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            sumOfValues += _deployments[i].value;\n        }\n        require(msg.value == sumOfValues, \"`value` provided is not equal to the combined `value`s of deployments\");\n\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            this.forceDeployOnAddress{value: _deployments[i].value}(_deployments[i], msg.sender);\n        }\n    }\n\n    function _nonSystemDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        require(_bytecodeHash != bytes32(0x0), \"BytecodeHash cannot be zero\");\n        require(uint160(_newAddress) > MAX_SYSTEM_CONTRACT_ADDRESS, \"Can not deploy contracts in kernel space\");\n\n        // We do not allow deploying twice on the same address.\n        require(\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getCodeHash(uint256(uint160(_newAddress))) == 0x0,\n            \"Code hash is non-zero\"\n        );\n        // Do not allow deploying contracts to default accounts that have already executed transactions.\n        require(NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(_newAddress) == 0x00, \"Account is occupied\");\n\n        _performDeployOnAddress(_bytecodeHash, _newAddress, _aaVersion, _input);\n    }\n\n    /// @notice Deploy a certain bytecode on the address.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _newAddress The address of the contract to be deployed.\n    /// @param _aaVersion The version of the account abstraction protocol to use.\n    /// @param _input The constructor calldata.\n    function _performDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        _ensureBytecodeIsKnown(_bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = _aaVersion;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_newAddress, newAccountInfo);\n\n        _constructContract(msg.sender, _newAddress, _bytecodeHash, _input, false, true);\n    }\n\n    /// @notice Check that bytecode hash is marked as known on the `KnownCodeStorage` system contracts\n    function _ensureBytecodeIsKnown(bytes32 _bytecodeHash) internal view {\n        uint256 knownCodeMarker = KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash);\n        require(knownCodeMarker > 0, \"The code hash is not known\");\n    }\n\n    /// @notice Ensures that the _newAddress and assigns a new contract hash to it\n    /// @param _newAddress The address of the deployed contract\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    function _storeConstructingByteCodeHashOnAddress(address _newAddress, bytes32 _bytecodeHash) internal {\n        // Set the \"isConstructor\" flag to the bytecode hash\n        bytes32 constructingBytecodeHash = Utils.constructingBytecodeHash(_bytecodeHash);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructingCodeHash(_newAddress, constructingBytecodeHash);\n    }\n\n    /// @notice Transfers the `msg.value` ETH to the deployed account & invokes its constructor.\n    /// This function must revert in case the deployment fails.\n    /// @param _sender The msg.sender to be used in the constructor\n    /// @param _newAddress The address of the deployed contract\n    /// @param _input The constructor calldata\n    /// @param _isSystem Whether the call should be a system call (could be possibly required in the future).\n    function _constructContract(\n        address _sender,\n        address _newAddress,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        bool _isSystem,\n        bool _callConstructor\n    ) internal {\n        uint256 value = msg.value;\n        if (_callConstructor) {\n            // 1. Transfer the balance to the new address on the constructor call.\n            if (value > 0) {\n                BASE_TOKEN_SYSTEM_CONTRACT.transferFromTo(address(this), _newAddress, value);\n            }\n            // 2. Set the constructed code hash on the account\n            _storeConstructingByteCodeHashOnAddress(_newAddress, _bytecodeHash);\n\n            // 3. Call the constructor on behalf of the account\n            if (value > 0) {\n                // Safe to cast value, because `msg.value` <= `uint128.max` due to `MessageValueSimulator` invariant\n                SystemContractHelper.setValueForNextFarCall(uint128(value));\n            }\n            bytes memory returnData = EfficientCall.mimicCall(gasleft(), _newAddress, _input, _sender, true, _isSystem);\n            // 4. Mark bytecode hash as constructed\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.markAccountCodeHashAsConstructed(_newAddress);\n            // 5. Set the contract immutables\n            ImmutableData[] memory immutables = abi.decode(returnData, (ImmutableData[]));\n            IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT.setImmutables(_newAddress, immutables);\n        } else {\n            require(value == 0, \"The value must be zero if we do not call the constructor\");\n            // If we do not call the constructor, we need to set the constructed code hash.\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructedCodeHash(_newAddress, _bytecodeHash);\n        }\n\n        emit ContractDeployed(_sender, _bytecodeHash, _newAddress);\n    }\n}"
    }
  ]
}