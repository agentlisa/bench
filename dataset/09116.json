{
  "Title": "[N-13] Consider two-phase ownership transfer",
  "Content": "Consider adding a two-phase transfer, where the current owner nominates the next owner, and the next owner has to call `accept*()` to become the new owner. This prevents passing the ownership to an account that is unable to use it.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: smart-contracts/YieldManager.sol   #1\n\n26:  contract YieldManager is VersionedInitializable, Ownable {\n```\nhttps://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L26\n\n**[sforman2000 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/69#issuecomment-1129470623):**\n > Particularly high quality.\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/69#issuecomment-1134999270):**\n > L1: Fixed<br>\n> L2: Fixed<br>\n> L3: Fixed<br>\n> L4: Invalid. ETH constant may be used in several child contract.<br>\n> L5: Admin can monitor it.<br>\n> L6: Invalid. LidoVault can be received ETH from CurveSwap<br>\n> L7: No need to change<br>\n> L8: Fixed<br>\n> L9: Fixed<br>\n> N1: Fixed<br>\n> N2: Fixed<br>\n> N3: Invalid<br>\n> N4: Fixed<br>\n> N5: Fixed<br>\n> N6: Fixed<br>\n> N7: Fixed<br>\n> N8: Fixed<br>\n> N9: No need to change<br>\n> N10: Invalid<br>\n> N11: Invalid<br>\n> N12: Fixed<br>\n> N13: No need to change<br>\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/69#issuecomment-1147044556):**\n > L5 should be addressed IMO. there is an inconsistency between addresses being used. The LIDO vault should be using the ETH constant instead of the null address for ETH, or vice versa. For someone who uses etherscan, he'll see the `ETH` constant define and assumes that he should be using that to specify ETH, then wonder why his tx will potentially revert in Metamask. \n\n> **Low issues:** L1, L2, L3, L4, L5, L7, centralisation risk<br>\n> **NC issues:** L8, L9, N1, N2, N3 (more of sponsor acknowledged), N4, N5, N6, N7 (reasoning is diff from N6), N8, N9, N12, N13<br>\n> **Invalid:** L6, N10 (some fields are not worth the extra gas to index), N11 (no justification)<br>\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-sturdy",
  "Code": [
    {
      "filename": "smart-contracts/YieldManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {ISwapRouter} from '../../interfaces/ISwapRouter.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {TransferHelper} from '../libraries/helpers/TransferHelper.sol';\nimport {UniswapAdapter} from '../libraries/swap/UniswapAdapter.sol';\nimport {CurveswapAdapter} from '../libraries/swap/CurveswapAdapter.sol';\n\n/**\n * @title YieldManager\n * @notice yield distributor by swapping from assets to stable coin\n * @author Sturdy\n **/\n\ncontract YieldManager is VersionedInitializable, Ownable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  // the list of the available reserves, structured as a mapping for gas savings reasons\n  mapping(uint256 => address) internal _assetsList;\n  uint256 internal _assetsCount;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  address public _exchangeToken;\n\n  // tokenIn -> tokenOut -> Curve Pool Address\n  mapping(address => mapping(address => address)) internal _curvePools;\n\n  uint256 public constant UNISWAP_FEE = 10000; // 1%\n  uint256 public constant SLIPPAGE = 500; // 5%\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function setExchangeToken(address _token) external onlyAdmin {\n    require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _exchangeToken = _token;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  function registerAsset(address _asset) external onlyAdmin {\n    _assetsList[_assetsCount] = _asset;\n    _assetsCount = _assetsCount + 1;\n  }\n\n  function getAssetCount() external view returns (uint256) {\n    return _assetsCount;\n  }\n\n  function getAssetInfo(uint256 _index) external view returns (address) {\n    return _assetsList[_index];\n  }\n\n  /**\n   * @dev Function to set Curve Pool address for the swap\n   * @param _tokenIn The address of token being exchanged\n   * @param _tokenOut The address of token being received\n   * @param _pool The address of the Curve pool to use for the swap\n   */\n  function setCurvePool(\n    address _tokenIn,\n    address _tokenOut,\n    address _pool\n  ) external onlyAdmin {\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _curvePools[_tokenIn][_tokenOut] = _pool;\n  }\n\n  /**\n   * @dev Function to get Curve Pool address for the swap\n   * @param _tokenIn The address of token being sent\n   * @param _tokenOut The address of token being received\n   */\n  function getCurvePool(address _tokenIn, address _tokenOut) external view returns (address) {\n    return _curvePools[_tokenIn][_tokenOut];\n  }\n\n  /**\n   * @dev Distribute the yield of assets to suppliers.\n   *      1. convert asset to exchange token(for now it's USDC) via Uniswap\n   *      2. convert exchange token to other stables via Curve\n   *      3. deposit to pool for suppliers\n   * @param _offset assets array's start offset.\n   * @param _count assets array's count when perform distribution.\n   **/\n  function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n    // 1. convert from asset to exchange token via uniswap\n    for (uint256 i = 0; i < _count; i++) {\n      address asset = _assetsList[_offset + i];\n      require(asset != address(0), Errors.UL_INVALID_INDEX);\n      uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));\n      _convertAssetToExchangeToken(asset, _amount);\n    }\n    uint256 exchangedAmount = IERC20Detailed(_exchangeToken).balanceOf(address(this));\n\n    // 2. convert from exchange token to other stable assets via curve swap\n    AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);\n    for (uint256 i = 0; i < assetYields.length; i++) {\n      if (assetYields[i].amount > 0) {\n        uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);\n        // 3. deposit Yield to pool for suppliers\n        _depositYield(assetYields[i].asset, _amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraYieldAmount = _totalYieldAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute yieldAmount based on percent of asset volume\n        assetYields[i].amount = _totalYieldAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraYieldAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  /**\n   * @dev Convert asset to exchange token via Uniswap\n   * @param asset The address of asset being exchanged\n   * @param amount The amount of asset being exchanged\n   */\n  function _convertAssetToExchangeToken(address asset, uint256 amount) internal {\n    UniswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      asset,\n      _exchangeToken,\n      amount,\n      UNISWAP_FEE,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to convert from exchange token to stable coin via Curve\n   * @param _tokenOut The address of stable coin\n   * @param _amount The amount of exchange token being sent\n   * @return receivedAmount The amount of stable coin converted\n   */\n  function _convertToStableCoin(address _tokenOut, uint256 _amount)\n    internal\n    returns (uint256 receivedAmount)\n  {\n    if (_tokenOut == _exchangeToken) {\n      return _amount;\n    }\n    address _pool = _curvePools[_exchangeToken][_tokenOut];\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    receivedAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _pool,\n      _exchangeToken,\n      _tokenOut,\n      _amount,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to deposit yield to pool for suppliers\n   * @param _asset The address of yield asset\n   * @param _amount The mount of asset\n   */\n  function _depositYield(address _asset, uint256 _amount) internal {\n    address _lendingPool = _addressesProvider.getLendingPool();\n    IERC20(_asset).approve(_lendingPool, _amount);\n    ILendingPool(_lendingPool).depositYield(_asset, _amount);\n  }\n}"
    }
  ]
}