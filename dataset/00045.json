{
  "Title": "M-2: Depositing `stETH` to puffer finance will revert due to wrong implementation of `PufETHAdapter._stake` call",
  "Content": "# Issue M-2: Depositing `stETH` to puffer finance will revert due to wrong implementation of `PufETHAdapter._stake` call \n\nSource: https://github.com/sherlock-audit/2024-05-napier-update-judging/issues/21 \n\n## Found by \nBauer, Drynooo, Ironsidesec, KupiaSec, PNS, blackhole, blutorque, karsar, merlin, no, yamato, zzykxx\n## Summary\nReason: `PufETHAdapter._stake` will always revert due to wrong external call implementation.\nImpact: Can't deposit to Puffer.\nLikelihood: always.\n\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/puffer/PufETHAdapter.sol#L82\n\n```solidity\nFile: 2024-05-napier-update\\napier-uups-adapters\\src\\adapters\\puffer\\PufETHAdapter.sol\n\n66:     function _stake(uint256 stakeAmount) internal override returns (uint256) {\n...\n74: \n75:         IWETH9(Constants.WETH).withdraw(stakeAmount);\n76:         uint256 _stETHAmt = STETH.balanceOf(address(this));\n77:         STETH.submit{value: stakeAmount}(address(this));\n78:         _stETHAmt = STETH.balanceOf(address(this)) - _stETHAmt;\n79:         if (_stETHAmt == 0) revert InvariantViolation();\n80: \n81:         // Stake stETH to PufferDepositor\n82:    >>>  uint256 _pufETHAmt = PUFFER_DEPOSITOR.depositStETH(Permit(block.timestamp, _stETHAmt, 0, 0, 0));\n84: \n...\n88:     }\n\n```\n\n**Issue flow**:\n1. When depositing by calling  `PUFFER_DEPOSITOR.depositStETH(Permit)`, `PufETHAdapter` passes only one parameter `Permit` look at line 82 above.\n2. But the current `PUFFER_DEPOSITOR.depositStETH` has 2 parameters (Permit, address recipient). Check https://etherscan.io/address/0x4aA799C5dfc01ee7d790e3bf1a7C2257CE1DcefF#writeProxyContract#F1.\n3. This is due to the proxy upgrade of `PUFFER_DEPOSITOR` from implementation v1 to implementation v2. \n\nTo check upgares of `PUFFER_DEPOSITOR`, scroll on https://etherscan.io/address/0x4aA799C5dfc01ee7d790e3bf1a7C2257CE1DcefF#writeProxyContract \n\n![image](https://github.com/sherlock-audit/2024-05-napier-update-ironsidesec/assets/162350329/7473f701-d666-40d9-935e-bae897ddcc9e)\n\nPrevious implementation where it had only one param https://etherscan.io/address/0x7276925e42f9c4054afa2fad80fa79520c453d6a#code#F1#L182\n\n![image](https://github.com/sherlock-audit/2024-05-napier-update-ironsidesec/assets/162350329/3cf4acc6-417e-4ddc-9214-45afef53ac65)\n\nLatest implementation has 2 params https://etherscan.io/address/0x8c9517a9e99c74cd072a118d3dc6b4f3217f8b9b#code#F1#L67\n\n![image](https://github.com/sherlock-audit/2024-05-napier-update-ironsidesec/assets/162350329/0ff0e234-6832-4d96-af78-3b63a3520fdf)\n\n\n## Impact\nDepositing stETH to puffer finance is not possible with current  `PufETHAdapter`\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/puffer/PufETHAdapter.sol#L82\n\nhttps://etherscan.io/address/0x8c9517a9e99c74cd072a118d3dc6b4f3217f8b9b#code#F1#L41\n\nhttps://etherscan.io/address/0x4aA799C5dfc01ee7d790e3bf1a7C2257CE1DcefF#writeProxyContract\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/puffer/PufETHAdapter.sol#L82\n\n```diff\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n...\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _stETHAmt = STETH.balanceOf(address(this));\n        STETH.submit{value: stakeAmount}(address(this));\n        _stETHAmt = STETH.balanceOf(address(this)) - _stETHAmt;\n        if (_stETHAmt == 0) revert InvariantViolation();\n\n        // Stake stETH to PufferDepositor\n-       uint256 _pufETHAmt = PUFFER_DEPOSITOR.depositStETH(Permit(block.timestamp, _stETHAmt, 0, 0, 0));\n+       uint256 _pufETHAmt = PUFFER_DEPOSITOR.depositStETH(Permit(block.timestamp, _stETHAmt, 0, 0, 0), address(this));\n\n        if (_pufETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/napierfi/napier-uups-adapters/pull/10\n\n\n**zzykxx**\n\nThis has been fixed by changing the functionality of the `_stake()` function, now it deposits `WETH` instead of `stETH`.\n\n**sherlock-admin2**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/369",
  "Code": [
    {
      "filename": "napier-uups-adapters/src/adapters/puffer/PufETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {IPufferVault} from \"./interfaces/IPufferVault.sol\";\nimport {IPufferDepositor, Permit} from \"./interfaces/IPufferDepositor.sol\";\nimport {IStETH} from \"@napier/v1-tranche/adapters/lido/interfaces/IStETH.sol\";\n\n// libs\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice PufETHAdapter - ePufETH (Napier pufETH Adapter)\n/// @notice Puffer is a decentralized native liquid restaking protocol (nLRP) built on Eigenlayer\n/// It makes native restaking on Eigenlayer more accessible, allowing anyone to run an Ethereum Proof of Stake\n/// (PoS) validator while supercharging their rewards.\ncontract PufETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice stETH\n    IStETH constant STETH = IStETH(Constants.STETH);\n\n    /// @notice pufETH\n    IPufferVault constant PUFETH = IPufferVault(Constants.PUFETH);\n\n    /// @notice Puffer Depositor\n    IPufferDepositor constant PUFFER_DEPOSITOR = IPufferDepositor(Constants.PUF_DEPOSITOR);\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier pufETH Adapter\", \"ePufETH\");\n\n        PUFETH.approve(address(PUFFER_DEPOSITOR), type(uint256).max);\n        STETH.approve(address(PUFFER_DEPOSITOR), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from Puffer\n    /// @dev Puffer doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Puffer allows stETH or wstETH via PufferDepositor.\n    /// @dev Lido has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        uint256 stakeLimit = STETH.getCurrentStakeLimit();\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _stETHAmt = STETH.balanceOf(address(this));\n        STETH.submit{value: stakeAmount}(address(this));\n        _stETHAmt = STETH.balanceOf(address(this)) - _stETHAmt;\n        if (_stETHAmt == 0) revert InvariantViolation();\n\n        // Stake stETH to PufferDepositor\n        uint256 _pufETHAmt = PUFFER_DEPOSITOR.depositStETH(Permit(block.timestamp, _stETHAmt, 0, 0, 0));\n\n        if (_pufETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 share = PUFETH.balanceOf(address(this));\n        return $.totalQueueEth + $.bufferEth + PUFETH.convertToAssets(share);\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/puffer/PufETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {IPufferVault} from \"./interfaces/IPufferVault.sol\";\nimport {IPufferDepositor, Permit} from \"./interfaces/IPufferDepositor.sol\";\nimport {IStETH} from \"@napier/v1-tranche/adapters/lido/interfaces/IStETH.sol\";\n\n// libs\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice PufETHAdapter - ePufETH (Napier pufETH Adapter)\n/// @notice Puffer is a decentralized native liquid restaking protocol (nLRP) built on Eigenlayer\n/// It makes native restaking on Eigenlayer more accessible, allowing anyone to run an Ethereum Proof of Stake\n/// (PoS) validator while supercharging their rewards.\ncontract PufETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice stETH\n    IStETH constant STETH = IStETH(Constants.STETH);\n\n    /// @notice pufETH\n    IPufferVault constant PUFETH = IPufferVault(Constants.PUFETH);\n\n    /// @notice Puffer Depositor\n    IPufferDepositor constant PUFFER_DEPOSITOR = IPufferDepositor(Constants.PUF_DEPOSITOR);\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier pufETH Adapter\", \"ePufETH\");\n\n        PUFETH.approve(address(PUFFER_DEPOSITOR), type(uint256).max);\n        STETH.approve(address(PUFFER_DEPOSITOR), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from Puffer\n    /// @dev Puffer doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Puffer allows stETH or wstETH via PufferDepositor.\n    /// @dev Lido has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        uint256 stakeLimit = STETH.getCurrentStakeLimit();\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _stETHAmt = STETH.balanceOf(address(this));\n        STETH.submit{value: stakeAmount}(address(this));\n        _stETHAmt = STETH.balanceOf(address(this)) - _stETHAmt;\n        if (_stETHAmt == 0) revert InvariantViolation();\n\n        // Stake stETH to PufferDepositor\n        uint256 _pufETHAmt = PUFFER_DEPOSITOR.depositStETH(Permit(block.timestamp, _stETHAmt, 0, 0, 0));\n\n        if (_pufETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 share = PUFETH.balanceOf(address(this));\n        return $.totalQueueEth + $.bufferEth + PUFETH.convertToAssets(share);\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/puffer/PufETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {IPufferVault} from \"./interfaces/IPufferVault.sol\";\nimport {IPufferDepositor, Permit} from \"./interfaces/IPufferDepositor.sol\";\nimport {IStETH} from \"@napier/v1-tranche/adapters/lido/interfaces/IStETH.sol\";\n\n// libs\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice PufETHAdapter - ePufETH (Napier pufETH Adapter)\n/// @notice Puffer is a decentralized native liquid restaking protocol (nLRP) built on Eigenlayer\n/// It makes native restaking on Eigenlayer more accessible, allowing anyone to run an Ethereum Proof of Stake\n/// (PoS) validator while supercharging their rewards.\ncontract PufETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice stETH\n    IStETH constant STETH = IStETH(Constants.STETH);\n\n    /// @notice pufETH\n    IPufferVault constant PUFETH = IPufferVault(Constants.PUFETH);\n\n    /// @notice Puffer Depositor\n    IPufferDepositor constant PUFFER_DEPOSITOR = IPufferDepositor(Constants.PUF_DEPOSITOR);\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier pufETH Adapter\", \"ePufETH\");\n\n        PUFETH.approve(address(PUFFER_DEPOSITOR), type(uint256).max);\n        STETH.approve(address(PUFFER_DEPOSITOR), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from Puffer\n    /// @dev Puffer doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Puffer allows stETH or wstETH via PufferDepositor.\n    /// @dev Lido has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        uint256 stakeLimit = STETH.getCurrentStakeLimit();\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _stETHAmt = STETH.balanceOf(address(this));\n        STETH.submit{value: stakeAmount}(address(this));\n        _stETHAmt = STETH.balanceOf(address(this)) - _stETHAmt;\n        if (_stETHAmt == 0) revert InvariantViolation();\n\n        // Stake stETH to PufferDepositor\n        uint256 _pufETHAmt = PUFFER_DEPOSITOR.depositStETH(Permit(block.timestamp, _stETHAmt, 0, 0, 0));\n\n        if (_pufETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 share = PUFETH.balanceOf(address(this));\n        return $.totalQueueEth + $.bufferEth + PUFETH.convertToAssets(share);\n    }\n}"
    }
  ]
}