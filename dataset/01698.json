{
  "Title": "M-4: The deposit - withdraw - trade transaction lack of expiration timestamp check (DeadLine check)",
  "Content": "# Issue M-4: The deposit - withdraw - trade transaction lack of expiration timestamp check (DeadLine check) \n\nSource: https://github.com/sherlock-audit/2023-06-real-wagmi-judging/issues/163 \n\n## Found by \nAvci, Phantasmagoria, kutugu, sashik\\_eth, shealtielanz\n## Summary\nThe deposit - withdraw - trade transaction lack of expiration timestamp check (DeadLine check)\n## Vulnerability Detail\nthe protocol missing the DEADLINE check at all in logic. \n\nthis is actually how uniswap implemented the **Deadline**, this protocol also need deadline check like this logic \n\nhttps://github.com/Uniswap/v2-periphery/blob/0335e8f7e1bd1e8d8329fd300aea2ef2f36dd19f/contracts/UniswapV2Router02.sol#L61\n```solidity\n\n// **** ADD LIQUIDITY ****\nfunction _addLiquidity(\n\taddress tokenA,\n\taddress tokenB,\n\tuint amountADesired,\n\tuint amountBDesired,\n\tuint amountAMin,\n\tuint amountBMin\n) internal virtual returns (uint amountA, uint amountB) {\n\t// create the pair if it doesn't exist yet\n\tif (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n\t\tIUniswapV2Factory(factory).createPair(tokenA, tokenB);\n\t}\n\t(uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\tif (reserveA == 0 && reserveB == 0) {\n\t\t(amountA, amountB) = (amountADesired, amountBDesired);\n\t} else {\n\t\tuint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n\t\tif (amountBOptimal <= amountBDesired) {\n\t\t\trequire(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n\t\t\t(amountA, amountB) = (amountADesired, amountBOptimal);\n\t\t} else {\n\t\t\tuint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n\t\t\tassert(amountAOptimal <= amountADesired);\n\t\t\trequire(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n\t\t\t(amountA, amountB) = (amountAOptimal, amountBDesired);\n\t\t}\n\t}\n}\n\nfunction addLiquidity(\n\taddress tokenA,\n\taddress tokenB,\n\tuint amountADesired,\n\tuint amountBDesired,\n\tuint amountAMin,\n\tuint amountBMin,\n\taddress to,\n\tuint deadline\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n\t(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\tTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n\tTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n\tliquidity = IUniswapV2Pair(pair).mint(to);\n}\n```\nthe point is the deadline check\n```solidity\nmodifier ensure(uint deadline) {\n\trequire(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n\t_;\n}\n```\n\nThe deadline check ensure that the transaction can be executed on time and the expired transaction revert.\n## Impact\n\nThe transaction can be pending in mempool for a long and the trading activity is very time senstive. Without deadline check, the trade transaction can be executed in a long time after the user submit the transaction, at that time, the trade can be done in a sub-optimal price, which harms user's position.\n\nThe deadline check ensure that the transaction can be executed on time and the expired transaction revert.\n## Code Snippet\n```solidity\n function _deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 _totalSupply,\n        Slot0Data[] memory slots\n    ) private {\n        uint128 liquidity;\n        uint256 fee0;\n        uint256 fee1;\n        uint256 posNum = multiPosition.length;\n        PositionInfo memory position;\n        for (uint256 i = 0; i < posNum; ) {\n            position = multiPosition[i];\n\n            liquidity = _calcLiquidityAmountToDeposit(\n                slots[i].currentSqrtRatioX96,\n                position,\n                amount0Desired,\n                amount1Desired\n            );\n            if (liquidity > 0) {\n                (, , , uint128 tokensOwed0Before, uint128 tokensOwed1Before) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                IUniswapV3Pool(position.poolAddress).mint(\n                    address(this), //recipient\n                    position.lowerTick,\n                    position.upperTick,\n                    liquidity,\n                    abi.encode(position.poolFeeAmt)\n                );\n\n                (, , , uint128 tokensOwed0After, uint128 tokensOwed1After) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                fee0 += tokensOwed0After - tokensOwed0Before;\n                fee1 += tokensOwed1After - tokensOwed1Before;\n\n                IUniswapV3Pool(position.poolAddress).collect(\n                    address(this),\n                    position.lowerTick,\n                    position.upperTick,\n                    type(uint128).max,\n                    type(uint128).max\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n```\nhttps://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L360\nhttps://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L433\nhttps://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Multipool.sol#L557\nhttps://github.com/sherlock-audit/2023-06-real-wagmi/blob/main/concentrator/contracts/Dispatcher.sol#L180\n\n## Tool used\n\nManual Review\n\n## Recommendation\n- consider adding deadline check like in the functions like withdraw and deposit and all operations \nthe point is the deadline check\n```solidity\nmodifier ensure(uint deadline) {\n\trequire(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n\t_;\n}\n```\n\n\n\n## Discussion\n\n**ctf-sec**\n\nSeems like the sponsor mark https://github.com/sherlock-audit/2023-06-real-wagmi-judging/issues/102 as medium and dispute #163\n\n#116 is a duplicate of #102 as well,\n\nI understand the sponsor is mainly concerning with rebalance action.\n\nRecommend still leave this issue as a medium\n\n**0xffff11**\n\nAgree to keep a med here\n\n**fann95**\n\nOur team does not consider such a check necessary and allows for a delay in deposit and withdrawals subject to the conditions of slippage protection.The deadline check will be included in swapData if needed\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/88",
  "Code": [
    {
      "filename": "contracts/UniswapV2Router02.sol",
      "content": "pragma solidity =0.6.6;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\n\nimport './interfaces/IUniswapV2Router02.sol';\nimport './libraries/UniswapV2Library.sol';\nimport './libraries/SafeMath.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IWETH.sol';\n\ncontract UniswapV2Router02 is IUniswapV2Router02 {\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IUniswapV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    }\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    {\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    {\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }\n}"
    },
    {
      "filename": "concentrator/contracts/Multipool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { Babylonian } from \"./vendor0.8/uniswap/Babylonian.sol\";\nimport { FullMath, LiquidityAmounts } from \"./vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport { TickMath } from \"./vendor0.8/uniswap/TickMath.sol\";\nimport { PositionKey } from \"@uniswap/v3-periphery/contracts/libraries/PositionKey.sol\";\nimport { ErrLib } from \"./libraries/ErrLib.sol\";\nimport { IMultiStrategy } from \"./interfaces/IMultiStrategy.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract Multipool is Ownable, ERC20 {\n    error InvalidManaging();\n    error InvalidFee(uint24 fee);\n\n    enum MANAGING {\n        MAXTOTALSUPPLY,\n        PROTOCOLFEEWEIGHT,\n        OPERATOR,\n        TWAPDURATION,\n        MAXTWAPDEVIATION\n    }\n\n    struct Slot0Data {\n        int24 tick;\n        uint160 currentSqrtRatioX96;\n    }\n\n    struct PositionInfo {\n        int24 lowerTick;\n        int24 upperTick;\n        uint24 poolFeeAmt;\n        uint256 weight;\n        address poolAddress;\n        bytes32 positionKey;\n    }\n\n    struct RebalanceParams {\n        // The direction of the swap, true for token0 to token1, false for token1 to token0\n        bool zeroForOne;\n        // Aggregator's router address\n        address swapTarget;\n        // The amount of the swap\n        uint amountIn;\n        // Aggregator's data that stores pathes and amounts swap through\n        bytes swapData;\n    }\n\n    struct UnderlyingPool {\n        int24 tickSpacing;\n        address poolAddress;\n    }\n\n    struct FeeGrowth {\n        uint256 accPerShare0;\n        uint256 accPerShare1;\n        uint256 gmiAccPerShare0;\n        uint256 gmiAccPerShare1;\n    }\n\n    IUniswapV3Factory public immutable underlyingV3Factory;\n    uint24[] public fees;\n    bool private entered;\n    address private constant burnAddress = 0x000000000000000000000000000000000000dEaD;\n    IMultiStrategy public immutable strategy;\n    uint256 public constant MAX_WEIGHT_UINT256 = 10000;\n    uint256 public constant MINIMUM_LIQUIDITY = 1000;\n    uint256 public constant MINIMUM_AMOUNT = 1000_000;\n    address public immutable multiFactory;\n    address public immutable token0;\n    address public immutable token1;\n\n    address operator;\n\n    uint256 public protocolFeeWeightMax = 2000; //20 %\n    uint256 public protocolFeeWeight = 2000;\n\n    uint256 public maxTotalSupply = 1e20;\n\n    uint256 public maxTwapDeviation = 100; // 1%\n\n    uint32 public twapDuration = 150;\n    /**\n     * @dev The accumulated fee per share of liquidity multiplied by FixedPoint128.Q128.\n     * Tthe amount of pending fees per share should be added to the userRewardDebt variable.\n     */\n    FeeGrowth public feesGrowthInsideLastX128;\n\n    //      fee =>poolAddress\n    mapping(uint24 => UnderlyingPool) public underlyingTrustedPools;\n\n    mapping(address => bool) public approvedTargets;\n\n    PositionInfo[] public multiPosition;\n\n    event Deposit(address user, uint256 amount0, uint256 amount1, uint256 liquidity);\n    event Withdraw(address user, uint256 amount0, uint256 amount1, uint256 liquidity);\n    event Rebalance(\n        uint256 reserve0Before,\n        uint256 reserve1Before,\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 swappedOut\n    );\n    event SwapTargetApproved(address indexed target, bool approved);\n    event ParamChanged(MANAGING managing, uint param);\n    event TrustedPoolAdded(uint24 fee, address poolAddress);\n\n    constructor(\n        address _token0,\n        address _token1,\n        address manager,\n        address _underlyingV3Factory,\n        IMultiStrategy _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint24[] memory _fees\n    ) ERC20(_name, _symbol) {\n        IUniswapV3Factory factory = IUniswapV3Factory(_underlyingV3Factory);\n\n        for (uint256 i = 0; i < _fees.length; ) {\n            _addUnderlyingPool(_fees[i], _token0, _token1, factory);\n            unchecked {\n                ++i;\n            }\n        }\n        underlyingV3Factory = factory;\n\n        multiFactory = msg.sender;\n\n        strategy = _strategy;\n        token0 = _token0;\n        token1 = _token1;\n\n        _transferOwnership(manager);\n        operator = manager;\n    }\n\n    modifier nonReentrant() {\n        require(!entered, \"RC\");\n        entered = true;\n        _;\n        entered = false;\n    }\n\n    function addUnderlyingPool(uint24 fee) external onlyOwner {\n        _addUnderlyingPool(fee, token0, token1, underlyingV3Factory);\n    }\n\n    function _addUnderlyingPool(\n        uint24 _fee,\n        address _token0,\n        address _token1,\n        IUniswapV3Factory _factory\n    ) private {\n        address poolAddress = _factory.getPool(_token0, _token1, _fee);\n\n        if (poolAddress == address(0)) {\n            revert InvalidFee(_fee);\n        }\n        underlyingTrustedPools[_fee] = UnderlyingPool({\n            tickSpacing: IUniswapV3Pool(poolAddress).tickSpacing(),\n            poolAddress: poolAddress\n        });\n        fees.push(_fee);\n        emit TrustedPoolAdded(_fee, poolAddress);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        ErrLib.requirement(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            ErrLib.ErrorCode.ERC20_TRANSFER_DID_NOT_SUCCEED\n        );\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)\n        );\n        ErrLib.requirement(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            ErrLib.ErrorCode.ERC20_TRANSFER_FROM_DID_NOT_SUCCEED\n        );\n    }\n\n    function _safeApprove(address token, address spender, uint256 amount) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, spender, amount)\n        );\n        ErrLib.requirement(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            ErrLib.ErrorCode.ERC20_APPROVE_DID_NOT_SUCCEED\n        );\n    }\n\n    /**\n     * @dev Takes a snapshot of current state and returns various information related to multi pool.\n     * @return reserve0 Amount of token0 in the reserve\n     * @return reserve1 Amount of token1 in the reserve\n     * @return feesGrow A structure containing fee growth information\n     * @return _totalSupply Total number of LP tokens minted\n     */\n    function snapshot()\n        external\n        returns (\n            uint256 reserve0,\n            uint256 reserve1,\n            FeeGrowth memory feesGrow,\n            uint256 _totalSupply\n        )\n    {\n        _totalSupply = totalSupply();\n        _earn(_totalSupply);\n        Slot0Data[] memory slots = getSlots();\n        (reserve0, reserve1, , ) = _getReserves(slots);\n        feesGrow = feesGrowthInsideLastX128;\n    }\n\n    /**\n     * @notice This function collects fees from the liquidity pool and updates the fee growth inside both Vaults per share\n     *         based on the amount of fees collected. It then returns the updated fee growth values.\n     * @dev When called, this function updates the fee growth inside each Vault according to the realised fees in the current block,\n     *      adding them to the `feesGrowthInsideLastX128` struct member variable of the contract.\n     */\n    function earn() external {\n        uint256 _totalSupply = totalSupply();\n        _earn(_totalSupply);\n    }\n\n    function _earn(uint256 _totalSupply) private {\n        if (_totalSupply > 0) {\n            _withdraw(0, _totalSupply);\n        }\n    }\n\n    function _checkTicks(int24 tickLower, int24 tickUpper, int24 _tickSpacing) private pure {\n        ErrLib.requirement(tickLower < tickUpper, ErrLib.ErrorCode.LOWER_SHOULD_BE_LESS_UPPER);\n        ErrLib.requirement(tickLower >= TickMath.MIN_TICK, ErrLib.ErrorCode.LOWER_TOO_SMALL);\n        ErrLib.requirement(tickUpper <= TickMath.MAX_TICK, ErrLib.ErrorCode.UPPER_TOO_BIG);\n        ErrLib.requirement(tickLower % _tickSpacing == 0, ErrLib.ErrorCode.TICKLOWER_IS_NOT_SPACED);\n        ErrLib.requirement(tickUpper % _tickSpacing == 0, ErrLib.ErrorCode.TICKUPPER_IS_NOT_SPACED);\n    }\n\n    function _getTicksForPosition(\n        int24 tick,\n        int24 positionRange,\n        int24 tickSpacingOffset,\n        int24 tickSpacing\n    ) private pure returns (int24 lowerTick, int24 upperTick) {\n        int24 floorTick = (tick / tickSpacing) * tickSpacing;\n        if (tickSpacingOffset == 0) {\n            lowerTick = floorTick - (positionRange - tickSpacing) / 2;\n            upperTick = floorTick + (positionRange + tickSpacing) / 2;\n        } else if (tickSpacingOffset > 0) {\n            lowerTick = floorTick + tickSpacing * tickSpacingOffset;\n            upperTick = lowerTick + positionRange;\n        } else {\n            upperTick = floorTick + tickSpacing * tickSpacingOffset;\n            lowerTick = upperTick - positionRange;\n        }\n    }\n\n    function _initializeStrategy() private returns (Slot0Data[] memory) {\n        uint256 positionsNum = strategy.strategySize();\n        ErrLib.requirement(positionsNum > 0, ErrLib.ErrorCode.STRATEGY_DOES_NOT_EXIST);\n        delete multiPosition;\n        PositionInfo memory position;\n        int24 upperTick;\n        int24 lowerTick;\n        Slot0Data[] memory slots = new Slot0Data[](positionsNum);\n\n        for (uint256 i = 0; i < positionsNum; ) {\n            IMultiStrategy.Strategy memory sPosition = strategy.getStrategyAt(i);\n            UnderlyingPool memory uPool = underlyingTrustedPools[sPosition.poolFeeAmt];\n            position.poolFeeAmt = sPosition.poolFeeAmt;\n            position.weight = sPosition.weight;\n            position.poolAddress = uPool.poolAddress;\n            (slots[i].currentSqrtRatioX96, slots[i].tick, , , , , ) = IUniswapV3Pool(\n                uPool.poolAddress\n            ).slot0();\n            (lowerTick, upperTick) = _getTicksForPosition(\n                slots[i].tick,\n                sPosition.positionRange,\n                sPosition.tickSpacingOffset,\n                uPool.tickSpacing\n            );\n            _checkTicks(lowerTick, upperTick, uPool.tickSpacing);\n            position.upperTick = upperTick;\n            position.lowerTick = lowerTick;\n            position.positionKey = PositionKey.compute(\n                address(this),\n                position.lowerTick,\n                position.upperTick\n            );\n\n            multiPosition.push(position);\n            unchecked {\n                ++i;\n            }\n        }\n        return slots;\n    }\n\n    function _calcLiquidityAmountToDeposit(\n        uint160 currentSqrtRatioX96,\n        PositionInfo memory position,\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    ) private pure returns (uint128 liquidity) {\n        liquidity = LiquidityAmounts.getLiquidityForAmounts(\n            currentSqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(position.lowerTick),\n            TickMath.getSqrtRatioAtTick(position.upperTick),\n            (amount0Desired * position.weight) / MAX_WEIGHT_UINT256,\n            (amount1Desired * position.weight) / MAX_WEIGHT_UINT256\n        );\n    }\n\n    function _upFeesGrowth(uint256 fee0, uint256 fee1, uint256 _totalSupply) private {\n        feesGrowthInsideLastX128.gmiAccPerShare0 += FullMath.mulDiv(\n            fee0,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n\n        feesGrowthInsideLastX128.gmiAccPerShare1 += FullMath.mulDiv(\n            fee1,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n        uint256 feeGrowthWeight = MAX_WEIGHT_UINT256 - protocolFeeWeight;\n        uint256 fee0WPF = (fee0 * feeGrowthWeight) / MAX_WEIGHT_UINT256;\n        uint256 fee1WPF = (fee1 * feeGrowthWeight) / MAX_WEIGHT_UINT256;\n\n        feesGrowthInsideLastX128.accPerShare0 += FullMath.mulDiv(\n            fee0WPF,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n\n        feesGrowthInsideLastX128.accPerShare1 += FullMath.mulDiv(\n            fee1WPF,\n            FixedPoint128.Q128,\n            _totalSupply\n        );\n\n        _pay(token0, address(this), owner(), fee0 - fee0WPF);\n        _pay(token1, address(this), owner(), fee1 - fee1WPF);\n    }\n\n    function _deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 _totalSupply,\n        Slot0Data[] memory slots\n    ) private {\n        uint128 liquidity;\n        uint256 fee0;\n        uint256 fee1;\n        uint256 posNum = multiPosition.length;\n        PositionInfo memory position;\n        for (uint256 i = 0; i < posNum; ) {\n            position = multiPosition[i];\n\n            liquidity = _calcLiquidityAmountToDeposit(\n                slots[i].currentSqrtRatioX96,\n                position,\n                amount0Desired,\n                amount1Desired\n            );\n            if (liquidity > 0) {\n                (, , , uint128 tokensOwed0Before, uint128 tokensOwed1Before) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                IUniswapV3Pool(position.poolAddress).mint(\n                    address(this), //recipient\n                    position.lowerTick,\n                    position.upperTick,\n                    liquidity,\n                    abi.encode(position.poolFeeAmt)\n                );\n\n                (, , , uint128 tokensOwed0After, uint128 tokensOwed1After) = IUniswapV3Pool(\n                    position.poolAddress\n                ).positions(position.positionKey);\n\n                fee0 += tokensOwed0After - tokensOwed0Before;\n                fee1 += tokensOwed1After - tokensOwed1Before;\n\n                IUniswapV3Pool(posit"
    }
  ]
}