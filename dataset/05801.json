{
  "Title": "[H-02] Zero amount withdrawals of SafEth or Votium will brick the withdraw process",
  "Content": "\nWithdrawals of amount zero from both SafEth and VotiumStrategy have issues downstream that will cause the transaction to revert, potentially bricking withdrawals from being executed.\n\n### Impact\n\nWithdrawals in AfEth undergo a process to account for any potential delay when withdrawing locked tokens in the VotiumStrategy. When a withdrawal is requested, the implementation calculates the owed amounts for each token and queues the withdrawal. SafEth tokens will be reserved in the contract, and VotiumStrategy will also queue the withdrawal of CVX tokens.\n\nWhen the time arrives, the user can call `withdraw()` to execute the withdrawal. This function will unstake from SafEth and withdraw from VotiumStrategy.\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L252-L253>\n\n```solidity\n252:         ISafEth(SAF_ETH_ADDRESS).unstake(withdrawInfo.safEthWithdrawAmount, 0);\n253:         AbstractStrategy(vEthAddress).withdraw(withdrawInfo.vEthWithdrawId);\n```\n\nLet's first consider the SafEth case. The current `unstake()` implementation in SafEth will revert if the unstaked amount is zero:\n\n<https://etherscan.io/address/0x591c4abf20f61a8b0ee06a5a2d2d2337241fe970#code#F1#L124>\n\n```solidity\n119:     function unstake(\n120:         uint256 _safEthAmount,\n121:         uint256 _minOut\n122:     ) external nonReentrant {\n123:         if (pauseUnstaking) revert UnstakingPausedError();\n124:         if (_safEthAmount == 0) revert AmountTooLow();\n125:         if (_safEthAmount > balanceOf(msg.sender)) revert InsufficientBalance();\n```\n\nAs we can see in line 124, if `_safEthAmount` is zero the function will revert, and the transaction to `withdraw()` will revert too due to the bubbled error. This means that any withdrawal that ends up with a zero amount for SafEth will be bricked.\n\nThe VotiumStrategy case has a similar issue. The implementation of `withdraw()` will call `sellCvx()` to swap the owed amount of CVX for ETH. This is executed using a Curve pool, as we can see in the following snippet of code:\n\n```solidity\n250:     function sellCvx(\n251:         uint256 _cvxAmountIn\n252:     ) internal returns (uint256 ethAmountOut) {\n253:         address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n254:         // cvx -> eth\n255:         uint256 ethBalanceBefore = address(this).balance;\n256:         IERC20(CVX_ADDRESS).approve(CVX_ETH_CRV_POOL_ADDRESS, _cvxAmountIn);\n257: \n258:         ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying(\n259:             1,\n260:             0,\n261:             _cvxAmountIn,\n262:             0 // this is handled at the afEth level\n263:         );\n264:         ethAmountOut = address(this).balance - ethBalanceBefore;\n265:     }\n```\n\nIf we drill down in the Curve implementation, we can see that it validates that the input amount is greater than zero:\n\n<https://etherscan.io/address/0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4#code#L714>\n\n```vyper\n709: def _exchange(sender: address, mvalue: uint256, i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool) -> uint256:\n710:     assert not self.is_killed  # dev: the pool is killed\n711:     assert i != j  # dev: coin index out of range\n712:     assert i < N_COINS  # dev: coin index out of range\n713:     assert j < N_COINS  # dev: coin index out of range\n714:     assert dx > 0  # dev: do not exchange 0 coins\n```\n\nAgain, this means that any withdrawal that ends up with a zero amount of vAfEth tokens (or the associated amount of CVX tokens) will be bricked when trying to execute the swap.\n\nThis can happen for different reasons. For example the current `ratio` may be `0` or `1e18`, meaning the split goes entirely to SafEth or to VotiumStrategy. Another reason could be rounding, for small quantities the proportion may round down values to zero.\n\nThe critical issue is that both withdrawals are executed simultaneously. A zero amount shouldn't matter, but both happen at the time, and one may affect the other. If the SafEth amount is zero, it will brick the withdrawal for a potentially non-zero vAfEth amount. Similarly, if the vAfEth amount is zero, it will brick the withdrawal for a potentially non-zero SafEth amount\n\n### Proof of Concept\n\nTo simplify the case, let's say the current ratio is zero, meaning all goes to VotiumStrategy.\n\n1.  A user calls `requestWithdraw()`. Since currently the SafEth ratio is zero, the contract doesn't hold a position in SafEth. This means that `safEthWithdrawAmount = 0`, and the position is entirely in vAfEth (`votiumWithdrawAmount > 0`).\n2.  Time passes and the user can finally withdraw.\n3.  The user calls `withdraw()`. The implementation will try to call `SafEth::unstake(0)`, which will cause an error, reverting the whole transaction.\n4.  The user will never be able to call `withdraw()`. Even if the ratios are changed, the calculated amount will be already stored in the `withdrawIdInfo` mapping. The withdrawal will be bricked, causing the loss of the vAfEth tokens.\n\n### Recommendation\n\nFor SafEth, avoid calling `SafEth::unstake()` if the calculated amount is zero:\n\n```diff\n+ if (withdrawInfo.safEthWithdrawAmount > 0) {\n    ISafEth(SAF_ETH_ADDRESS).unstake(withdrawInfo.safEthWithdrawAmount, 0);\n+ }\n```\n\nFor VotiumStrategy, prevent requesting the withdrawal if `votiumWithdrawAmount` is zero, while also keeping track of this to also avoid executing the withdrawal when `AfEth::withdraw()` is called.\n\nIt is also recommended to add a guard in `VotiumStrategy::withdraw()` to avoid calling `sellCvx()` when `cvxWithdrawAmount = 0`.\n\n```diff\n-  uint256 ethReceived = sellCvx(cvxWithdrawAmount);\n+  uint256 ethReceived = cvxWithdrawAmount > 0 ? sellCvx(cvxWithdrawAmount) : 0;\n```\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1741290306)**\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1746294920):**\n > It's unclear under what circumstances, `withdrawRatio` will be zero. As it appears, `votiumWithdrawAmount` is calculated as `(withdrawRatio * votiumBalance) / 1e18` and similarly, `safEthWithdrawAmount` is calculated as `(withdrawRatio * safEthBalance) / 1e18`. So it seems the withdraw ratio is applied in the same manner to both of these amounts?\n>\n > The main case where this causes issues is when `votiumBalance` is non-zero and `safEthBalance` is zero or vice-versa. I'm curious as to when this might happen @elmutt ?\n\n**[elmutt (Asymmetry) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1746906671):**\n> withdrawRatio represents the ratio of the amount being withdrawn to the total supply. So if a user owns 1% of afEth and withdraws their entire balance they will be set to receive 1% of each of the underlying assets (safEth & votiumStrategy) based on their current prices.\n> \n> It should never be zero unless user is withdrawing the the last afEth from the system but we plan to solve this with an initial seed deposit\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1747441726):**\n > Okay good to know, I think I understand what you mean now. Issue appears valid and I think high severity is justified because the last staker would be unable to execute their withdrawal. \n>\n > However, can you explain why `withdrawRatio` would be zero upon the last withdrawal? It is calculated as `(_amount * 1e18) / (totalSupply() - afEthBalance)` where the denominator is equal to the `_amount`. Hence, this is equal to `1e18`. So it attempts to withdraw all votium and safEth tokens from the contract.\n> \n> A better thing to understand would be, when would either of this token balances be non-zero? And your mitigation is to seed the contract with some tokens initially so the token balance is always positive?\n\n**[elmutt (Asymmetry) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1748055065):**\n > I think we actually have a bug here. We shouldnt be subtracting afEthBalance. \n> \n> Previously we subtracted it because the afEth contract held the users afEth before finally burning it on withdraw(). Now we just burn it on requestWithdraw() so we shouldn't be subtracting anymore.\n> \n> Does that make sense?\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1748226123):**\n > Agreed, that makes sense. No need to track `afEthBalance` anymore. There might be other areas where this is being done incorrectly too.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > Don't withdraw zero from SafEth or Votium.\n\n**Status**: Mitigation confirmed. Full details in reports from [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/5) and [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/28).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-09-asymmetry",
  "Code": [
    {
      "filename": "contracts/AfEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"contracts/strategies/votium/VotiumStrategy.sol\";\nimport \"contracts/external_interfaces/IVotiumStrategy.sol\";\nimport \"contracts/strategies/AbstractStrategy.sol\";\n\n// AfEth is the strategy manager for safEth and votium strategies\ncontract AfEth is Initializable, OwnableUpgradeable, ERC20Upgradeable {\n    uint256 public ratio;\n    uint256 public protocolFee;\n    address public feeAddress;\n    address public constant SAF_ETH_ADDRESS =\n        0x6732Efaf6f39926346BeF8b821a04B6361C4F3e5;\n    address public vEthAddress; // Votium Strategy Address\n    uint256 public latestWithdrawId;\n\n    struct WithdrawInfo {\n        address owner;\n        uint256 amount;\n        uint256 safEthWithdrawAmount;\n        uint256 vEthWithdrawId;\n        uint256 withdrawTime;\n    }\n\n    mapping(uint256 => WithdrawInfo) public withdrawIdInfo;\n    bool public pauseDeposit;\n    bool public pauseWithdraw;\n\n    error StrategyAlreadyAdded();\n    error StrategyNotFound();\n    error InsufficientBalance();\n    error InvalidStrategy();\n    error InvalidFee();\n    error CanNotWithdraw();\n    error NotOwner();\n    error FailedToSend();\n    error FailedToDeposit();\n    error Paused();\n    error BelowMinOut();\n\n    event WithdrawRequest(\n        address indexed account,\n        uint256 amount,\n        uint256 withdrawId,\n        uint256 withdrawTime\n    );\n\n    address private constant CVX_ADDRESS =\n        0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address private constant VLCVX_ADDRESS =\n        0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    uint256 public pendingSafEthWithdraws;\n\n    modifier onlyWithdrawIdOwner(uint256 withdrawId) {\n        if (withdrawIdInfo[withdrawId].owner != msg.sender) revert NotOwner();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n    */\n    function initialize() external initializer {\n        _transferOwnership(msg.sender);\n        ratio = 5e17;\n    }\n\n    /**\n     * @notice - Sets the strategy addresses for safEth and votium\n     * @param _vEthAddress - vEth strategy address\n     */\n    function setStrategyAddress(address _vEthAddress) external onlyOwner {\n        vEthAddress = _vEthAddress;\n    }\n\n    /**\n        @notice - Sets the target ratio of safEth to votium. \n        @notice target ratio is maintained by directing rewards into either safEth or votium strategy\n        @param _newRatio - New ratio of safEth to votium\n    */\n    function setRatio(uint256 _newRatio) public onlyOwner {\n        ratio = _newRatio;\n    }\n\n    /**\n        @notice - Sets the protocol fee address which takes a percentage of the rewards.\n        @param _newFeeAddress - New protocol fee address to collect rewards\n    */\n    function setFeeAddress(address _newFeeAddress) public onlyOwner {\n        feeAddress = _newFeeAddress;\n    }\n\n    /**\n        @notice - Sets the protocol fee which takes a percentage of the rewards.\n        @param _newFee - New protocol fee\n    */\n    function setProtocolFee(uint256 _newFee) public onlyOwner {\n        if (_newFee > 1e18) revert InvalidFee();\n        protocolFee = _newFee;\n    }\n\n    /**\n        @notice - Enables/Disables depositing\n        @param _pauseDeposit - Bool to set pauseDeposit\n\n    */\n    function setPauseDeposit(bool _pauseDeposit) external onlyOwner {\n        pauseDeposit = _pauseDeposit;\n    }\n\n    /**\n        @notice - Enables/Disables withdrawing & requesting to withdraw\n        @param _pauseWithdraw - Bool to set pauseWithdraw\n    */\n    function setPauseWithdraw(bool _pauseWithdraw) external onlyOwner {\n        pauseWithdraw = _pauseWithdraw;\n    }\n\n    /**\n        @notice - Get's the price of afEth\n        @dev - Checks each strategy and calculates the total value in ETH divided by supply of afETH tokens\n        @return - Price of afEth\n    */\n    function price() public view returns (uint256) {\n        if (totalSupply() == 0) return 1e18;\n        AbstractStrategy vEthStrategy = AbstractStrategy(vEthAddress);\n        uint256 safEthValueInEth = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 vEthValueInEth = (vEthStrategy.price() *\n            vEthStrategy.balanceOf(address(this))) / 1e18;\n        return ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply();\n    }\n\n    /**\n        @notice - Deposits into each strategy\n        @dev - This is the entry into the protocol\n        @param _minout - Minimum amount of afEth to mint\n    */\n    function deposit(uint256 _minout) external payable virtual {\n        if (pauseDeposit) revert Paused();\n        uint256 amount = msg.value;\n        uint256 priceBeforeDeposit = price();\n        uint256 totalValue;\n\n        AbstractStrategy vStrategy = AbstractStrategy(vEthAddress);\n\n        uint256 sValue = (amount * ratio) / 1e18;\n        uint256 sMinted = sValue > 0\n            ? ISafEth(SAF_ETH_ADDRESS).stake{value: sValue}(0)\n            : 0;\n        uint256 vValue = (amount * (1e18 - ratio)) / 1e18;\n        uint256 vMinted = vValue > 0 ? vStrategy.deposit{value: vValue}() : 0;\n        totalValue +=\n            (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n            (vMinted * vStrategy.price());\n        if (totalValue == 0) revert FailedToDeposit();\n        uint256 amountToMint = totalValue / priceBeforeDeposit;\n        if (amountToMint < _minout) revert BelowMinOut();\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice - Request to close position\n        @param _amount - Amount of afEth to withdraw\n    */\n    function requestWithdraw(uint256 _amount) external virtual {\n        uint256 withdrawTimeBefore = withdrawTime(_amount);\n        if (pauseWithdraw) revert Paused();\n        latestWithdrawId++;\n\n        // ratio of afEth being withdrawn to totalSupply\n        // we are transfering the afEth to the contract when we requestWithdraw\n        // we shouldn't include that in the withdrawRatio\n        uint256 afEthBalance = balanceOf(address(this));\n        uint256 withdrawRatio = (_amount * 1e18) /\n            (totalSupply() - afEthBalance);\n\n        _transfer(msg.sender, address(this), _amount);\n\n        uint256 votiumBalance = IERC20(vEthAddress).balanceOf(address(this));\n        uint256 votiumWithdrawAmount = (withdrawRatio * votiumBalance) / 1e18;\n        uint256 vEthWithdrawId = AbstractStrategy(vEthAddress).requestWithdraw(\n            votiumWithdrawAmount\n        );\n\n        uint256 safEthBalance = safEthBalanceMinusPending();\n\n        uint256 safEthWithdrawAmount = (withdrawRatio * safEthBalance) / 1e18;\n\n        pendingSafEthWithdraws += safEthWithdrawAmount;\n\n        withdrawIdInfo[latestWithdrawId]\n            .safEthWithdrawAmount = safEthWithdrawAmount;\n        withdrawIdInfo[latestWithdrawId].vEthWithdrawId = vEthWithdrawId;\n\n        withdrawIdInfo[latestWithdrawId].owner = msg.sender;\n        withdrawIdInfo[latestWithdrawId].amount = _amount;\n        withdrawIdInfo[latestWithdrawId].withdrawTime = withdrawTimeBefore;\n\n        emit WithdrawRequest(\n            msg.sender,\n            _amount,\n            latestWithdrawId,\n            withdrawTimeBefore\n        );\n    }\n\n    /**\n        @notice - Checks if withdraw can be executed from withdrawId\n        @param _withdrawId - Id of the withdraw request for SafEth\n        @return - Bool if withdraw can be executed\n    */\n    function canWithdraw(uint256 _withdrawId) public view returns (bool) {\n        return\n            AbstractStrategy(vEthAddress).canWithdraw(\n                withdrawIdInfo[_withdrawId].vEthWithdrawId\n            );\n    }\n\n    /**\n        @notice - Get's the withdraw time for an amount of AfEth\n        @param _amount - Amount of afETH to withdraw\n        @return - Highest withdraw time of the strategies\n    */\n    function withdrawTime(uint256 _amount) public view returns (uint256) {\n        return AbstractStrategy(vEthAddress).withdrawTime(_amount);\n    }\n\n    /**\n        @notice - Withdraw from each strategy\n        @param _withdrawId - Id of the withdraw request\n        @param _minout - Minimum amount of ETH to receive\n    */\n    function withdraw(\n        uint256 _withdrawId,\n        uint256 _minout\n    ) external virtual onlyWithdrawIdOwner(_withdrawId) {\n        if (pauseWithdraw) revert Paused();\n        uint256 ethBalanceBefore = address(this).balance;\n        WithdrawInfo memory withdrawInfo = withdrawIdInfo[_withdrawId];\n        if (!canWithdraw(_withdrawId)) revert CanNotWithdraw();\n\n        ISafEth(SAF_ETH_ADDRESS).unstake(withdrawInfo.safEthWithdrawAmount, 0);\n        AbstractStrategy(vEthAddress).withdraw(withdrawInfo.vEthWithdrawId);\n\n        _burn(address(this), withdrawIdInfo[_withdrawId].amount);\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n\n        pendingSafEthWithdraws -= withdrawInfo.safEthWithdrawAmount;\n\n        if (ethReceived < _minout) revert BelowMinOut();\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice - sells _amount of eth from votium contract\n     * @dev - puts it into safEthStrategy or votiumStrategy, whichever is underweight.\\\n     * @param _amount - amount of eth to sell\n     */\n    function depositRewards(uint256 _amount) public payable {\n        IVotiumStrategy votiumStrategy = IVotiumStrategy(vEthAddress);\n        uint256 feeAmount = (_amount * protocolFee) / 1e18;\n        if (feeAmount > 0) {\n            // solhint-disable-next-line\n            (bool sent, ) = feeAddress.call{value: feeAmount}(\"\");\n            if (!sent) revert FailedToSend();\n        }\n        uint256 amount = _amount - feeAmount;\n        uint256 safEthTvl = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 votiumTvl = ((votiumStrategy.cvxPerVotium() *\n            votiumStrategy.ethPerCvx(true)) *\n            IERC20(vEthAddress).balanceOf(address(this))) / 1e36;\n        uint256 totalTvl = (safEthTvl + votiumTvl);\n        uint256 safEthRatio = (safEthTvl * 1e18) / totalTvl;\n        if (safEthRatio < ratio) {\n            ISafEth(SAF_ETH_ADDRESS).stake{value: amount}(0);\n        } else {\n            votiumStrategy.depositRewards{value: amount}(amount);\n        }\n    }\n\n    function safEthBalanceMinusPending() public view returns (uint256) {\n        return\n            IERC20(SAF_ETH_ADDRESS).balanceOf(address(this)) -\n            pendingSafEthWithdraws;\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}