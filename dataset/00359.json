{
  "Title": "LibEthUsdOracle returning wrong price on `minAnswer`, impacting fertilizer minting",
  "Content": "# LibEthUsdOracle returning wrong price on `minAnswer`, impacting fertilizer minting\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Oracle/LibEthUsdOracle.sol#L63-L101\">https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Oracle/LibEthUsdOracle.sol#L63-L101</a>\n\n\n## Summary\nThe Chainlink aggregator utilized in the `LibEthUsdOracle` contract lacks a mechanism to detect and handle scenarios where the price of an asset falls outside of a predetermined price band. This limitation can result in the oracle returning the `minPrice` instead of the actual price of the asset during extreme market events, such as a significant drop in value. Consequently, users may continue to interact with the system, such as minting fertilizer tokens, using inaccurate price data. <a href=\"https://rekt.news/venus-blizz-rekt/\" target=\"_blank\"> similar case happened with Venus on BSC when LUNA imploded </a>\n\nMore Refs for similar issues like this:\n- https://medium.com/cyfrin/chainlink-oracle-defi-attacks-93b6cb6541bf ( check Oracle Returns Incorrect Price During Flash Crashes )\n- https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18\n- https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/25\n\n## Impact\n\nThe Chainlink aggregator can lead to potential exploitation of price discrepancies during extreme market conditions. For instance, if the price of an asset experiences a sudden crash, the oracle may continue to provide the `minPrice`, allowing users to conduct transactions at incorrect prices. This could result in financial losses for users and undermine the integrity of the system.\n\nIn our scenario, the `mintFertilizer` function within the FertilizerFacet contract, although it falls out of our immediate scope, relies on the `LibEthUsdOracle.getEthUsdPrice()` function (within our scope) to fetch the ETH/USD price from the Chainlink oracle. This price is crucial for calculating the amount of Fertilizer tokens that can be acquired with the provided `wethAmountIn` of WETH. However, if this function returns the `minPrice` during extreme market events, it would not reflect the actual price of the asset. Consequently, users could continue to mint fertilizer tokens using this **inaccurate price data**, leading to transactions occurring at incorrect prices.\n\n## Recommendation\nIt is recommended to enhance the Chainlink oracle (`LibEthUsdOracle`) by implementing a mechanism to check the returned answer against predefined `minPrice` and `maxPrice` bounds. If the answer falls outside of these bounds, the oracle should revert the transaction, indicating that the price data is not reliable due to market conditions.\n\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clsxlpte900074r5et7x6kh96",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Oracle/LibEthUsdOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibChainlinkOracle} from \"./LibChainlinkOracle.sol\";\nimport {LibUniswapOracle} from \"./LibUniswapOracle.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibAppStorage, AppStorage} from \"contracts/libraries/LibAppStorage.sol\";\nimport {C} from \"contracts/C.sol\";\n/**\n * @title Eth Usd Oracle Library\n * @notice Contains functionalty to fetch a manipulation resistant ETH/USD price.\n * @dev\n * The Oracle uses a greedy approach to return the average price between the\n * current price returned ETH/USD Chainlink Oracle and either the ETH/USDC\n * Uniswap V3 0.05% fee pool and the ETH/USDT Uniswap V3 0.05% fee pool depending\n * on which is closer. \n * \n * If the prices in the ETH/USDC Uniswap V3 0.05% fee pool and USD/USDT Uniswap V3 0.05% fee pool are\n * greater than `MAX_DIFFERENCE` apart, then the oracle uses the Chainlink price to maximize liveness.\n * \n * The approach is greedy as if the ETH/USDC Uniswap price is sufficiently close\n * to the Chainlink Oracle price (See {MAX_GREEDY_DIFFERENCE}), then the Oracle\n * will not check the ETH/USDT Uniswap Price to save gas.\n * \n * The oracle will fail if the Chainlink Oracle is broken or frozen (See: {LibChainlinkOracle}).\n **/\nlibrary LibEthUsdOracle {\n\n    using SafeMath for uint256;\n\n    // The maximum percent different such that it is acceptable to use the greedy approach.\n    uint256 constant MAX_GREEDY_DIFFERENCE = 0.003e18; // 0.3%\n\n    // The maximum percent difference such that the oracle assumes no manipulation is occuring.\n    uint256 constant MAX_DIFFERENCE = 0.01e18; // 1%\n    uint256 constant ONE = 1e18;\n\n    // The lookback used for Uniswap Oracles when querying the instantaneous USD price.\n    uint32 constant INSTANT_LOOKBACK = 900;\n\n    /**\n     * @dev Returns the instantaneous ETH/USD price\n     * Return value has 6 decimal precision.\n     * Returns 0 if the Eth Usd Oracle cannot fetch a manipulation resistant price.\n     **/\n    function getEthUsdPrice() internal view returns (uint256) {\n        return getEthUsdPrice(0);\n    }\n\n    /**\n     * @dev Returns the ETH/USD price with the option of using a TWA lookback.\n     * Use `lookback = 0` for the instantaneous price. `lookback > 0` for a TWAP.\n     * Return value has 6 decimal precision.\n     * Returns 0 if the Eth Usd Oracle cannot fetch a manipulation resistant price.\n     * A lookback of 900 seconds is used in Uniswap V3 pools for instantaneous price queries.\n     * If using a non-zero lookback, it is recommended to use a substantially large\n     * `lookback` (> 900 seconds) to protect against manipulation.\n    **/\n    function getEthUsdPrice(uint256 lookback) internal view returns (uint256) {\n        uint256 chainlinkPrice = lookback > 0 ?\n            LibChainlinkOracle.getEthUsdTwap(lookback) :\n            LibChainlinkOracle.getEthUsdPrice();\n\n        // Check if the chainlink price is broken or frozen.\n        if (chainlinkPrice == 0) return 0;\n\n        // Use a lookback of 900 seconds for an instantaneous price query for manipulation resistance.\n        if (lookback == 0) lookback = INSTANT_LOOKBACK;\n        if (lookback > type(uint32).max) return 0;\n\n        uint256 usdcPrice = LibUniswapOracle.getEthUsdcPrice(uint32(lookback));\n        uint256 usdcChainlinkPercentDiff = getPercentDifference(usdcPrice, chainlinkPrice);\n\n        // Check if the USDC price and the Chainlink Price are sufficiently close enough\n        // to warrant using the greedy approach.\n        if (usdcChainlinkPercentDiff < MAX_GREEDY_DIFFERENCE) {\n            return chainlinkPrice.add(usdcPrice).div(2);\n        }\n\n        uint256 usdtPrice = LibUniswapOracle.getEthUsdtPrice(uint32(lookback));\n        uint256 usdtChainlinkPercentDiff = getPercentDifference(usdtPrice, chainlinkPrice);\n\n        // Check whether the USDT or USDC price is closer to the Chainlink price.\n        if (usdtChainlinkPercentDiff < usdcChainlinkPercentDiff) {\n            // Check whether the USDT price is too far from the Chainlink price.\n            if (usdtChainlinkPercentDiff < MAX_DIFFERENCE) {\n                return chainlinkPrice.add(usdtPrice).div(2);\n            }\n            return chainlinkPrice;\n        } else {\n            // Check whether the USDC price is too far from the Chainlink price.\n            if (usdcChainlinkPercentDiff < MAX_DIFFERENCE) {\n                return chainlinkPrice.add(usdcPrice).div(2);\n            }\n            return chainlinkPrice;\n        }\n    }\n\n    /**\n     * Gets the percent difference between two values with 18 decimal precision.\n     * @dev If x == 0 (Such as in the case of Uniswap Oracle failure), then the percent difference is calculated as 100%.\n     */\n    function getPercentDifference(uint x, uint y) internal pure returns (uint256 percentDifference) {\n        percentDifference = x.mul(ONE).div(y);\n        percentDifference = x > y ?\n            percentDifference - ONE :\n            ONE - percentDifference; // SafeMath unnecessary due to conditional check\n    }\n}"
    }
  ]
}