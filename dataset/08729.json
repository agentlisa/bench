{
  "Title": "[N-09] Missing selector check on operator",
  "Content": "\nhttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/scripts/OperatorScripts.sol#L28<br>\nhttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L20\n\nThe addOperator function is not checking that selector of added operator is not bytes4(0)<br>\nSame fix is required for requireAndGetOperator function at OperatorResolver.sol#L20\n\n### Recommendation\nAdd below check\n\n```\nrequire(operator.selector != bytes4(0), \"AO-SCRIPT: INVALID_SELECTOR\");\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-nested",
  "Code": [
    {
      "filename": "contracts/governance/scripts/OperatorScripts.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../../interfaces/INestedFactory.sol\";\nimport \"../../interfaces/IOperatorResolver.sol\";\nimport \"../../abstracts/MixinOperatorResolver.sol\";\nimport \"../../interfaces/external/ITransparentUpgradeableProxy.sol\";\n\ncontract OperatorScripts {\n    struct tupleOperator {\n        bytes32 name;\n        bytes4 selector;\n    }\n\n    address public immutable nestedFactory;\n    address public immutable resolver;\n\n    constructor(address _nestedFactory, address _resolver) {\n        require(_nestedFactory != address(0), \"AO-SCRIPT: INVALID_FACTORY_ADDR\");\n        require(_resolver != address(0), \"AO-SCRIPT: INVALID_RESOLVER_ADDR\");\n        nestedFactory = _nestedFactory;\n        resolver = _resolver;\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to add an operator.\n    /// @param operator The operator to add\n    /// @param name The operator bytes32 name\n    function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external {\n        require(operator.implementation != address(0), \"AO-SCRIPT: INVALID_IMPL_ADDRESS\");\n\n        // Init arrays with length 1 (only one operator to import)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = operator;\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.addOperator.selector, name)\n        );\n    }\n\n    /// @notice Deploy and add operators\n    /// @dev One address and multiple selectors/names\n    /// @param bytecode Operator implementation bytecode\n    /// @param operators Array of tuples => bytes32/bytes4 (name and selector)\n    function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\n        uint256 operatorLength = operators.length;\n        require(operatorLength != 0, \"DAO-SCRIPT: INVALID_OPERATOR_LEN\");\n        require(bytecode.length != 0, \"DAO-SCRIPT: BYTECODE_ZERO\");\n\n        address deployedAddress;\n        assembly {\n            deployedAddress := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n        require(deployedAddress != address(0), \"DAO-SCRIPT: FAILED_DEPLOY\");\n\n        // Init arrays\n        bytes32[] memory names = new bytes32[](operatorLength);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](operatorLength);\n\n        for (uint256 i; i < operatorLength; i++) {\n            names[i] = operators[i].name;\n            operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector);\n        }\n\n        // Only the NestedFactory as destination\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        // Start importing operators\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n\n        // Add all the operators to the factory\n        for (uint256 i; i < operatorLength; i++) {\n            ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n                ITransparentUpgradeableProxy(nestedFactory).implementation(),\n                abi.encodeWithSelector(INestedFactory.addOperator.selector, operators[i].name)\n            );\n        }\n    }\n\n    /// @notice Call NestedFactory and OperatorResolver to remove an operator.\n    /// @param name The operator bytes32 name\n    function removeOperator(bytes32 name) external {\n        ITransparentUpgradeableProxy(nestedFactory).upgradeToAndCall(\n            ITransparentUpgradeableProxy(nestedFactory).implementation(),\n            abi.encodeWithSelector(INestedFactory.removeOperator.selector, name)\n        );\n\n        // Init arrays with length 1 (only one operator to remove)\n        bytes32[] memory names = new bytes32[](1);\n        IOperatorResolver.Operator[] memory operatorsToImport = new IOperatorResolver.Operator[](1);\n        MixinOperatorResolver[] memory destinations = new MixinOperatorResolver[](1);\n\n        names[0] = name;\n        operatorsToImport[0] = IOperatorResolver.Operator({ implementation: address(0), selector: bytes4(0) });\n        destinations[0] = MixinOperatorResolver(nestedFactory);\n\n        IOperatorResolver(resolver).importOperators(names, operatorsToImport, destinations);\n    }\n}"
    },
    {
      "filename": "contracts/OperatorResolver.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => Operator) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetOperator(bytes32 name, string calldata reason)\n        external\n        view\n        override\n        returns (Operator memory)\n    {\n        Operator memory _foundOperator = operators[name];\n        require(_foundOperator.implementation != address(0), reason);\n        return _foundOperator;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256 namesLength = names.length;\n        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        for (uint256 i = 0; i < namesLength; i++) {\n            if (\n                operators[names[i]].implementation != destinations[i].implementation ||\n                operators[names[i]].selector != destinations[i].selector\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(\n        bytes32[] calldata names,\n        Operator[] calldata operatorsToImport,\n        MixinOperatorResolver[] calldata destinations\n    ) external override onlyOwner {\n        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        bytes32 name;\n        Operator calldata destination;\n        for (uint256 i = 0; i < names.length; i++) {\n            name = names[i];\n            destination = operatorsToImport[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n\n        // rebuild caches atomically\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\n        rebuildCaches(destinations);\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}"
    }
  ]
}