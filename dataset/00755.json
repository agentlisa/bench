{
  "Title": "ERC-20 Transfer Should Occur Before Updating Internal State",
  "Content": "The [`join` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/join/GemJoin.sol#L51) of the `GemJoin` contract allows a user to deposit the `GEM` ERC-20 token into the contract and increases their `gem` balance in the `IonPool` contract. The function currently [updates the internal `totalGem` balance, and mints `gem` to the `user` account in the `IonPool` contract](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/join/GemJoin.sol#L54-L56) prior to transferring the `GEM` token from `msg.sender` to the contract. If the `GEM` token contains a `_beforeTokenTransfer` hook or some other callback, there could potentially be an opening for reentrancy allowing a user to manipulate their `gem` balance and steal funds from the protocol.\n\n\nThough this problem does not exist for the currently planned collateral types, consider moving the token transfer before updating any internal accounting to better implement defensive coding practices and prevent exploits in the future when more collaterals are added, or current collaterals are upgraded.\n\n\n***Update:** Acknowledged, not resolved. Ion Protocol team stated:*\n\n\n\n> *The protocol should not be supporting hook tokens. Will not fix.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/join/GemJoin.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IonPool } from \"../IonPool.sol\";\n\ncontract GemJoin is Ownable2Step, Pausable {\n    error Int256Overflow();\n    error WrongIlkAddress(uint8 ilkIndex, IERC20 gem);\n\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable GEM;\n    IonPool public immutable POOL;\n    uint8 public immutable ILK_INDEX;\n\n    uint256 public totalGem;\n\n    constructor(IonPool _pool, IERC20 _gem, uint8 _ilkIndex, address owner) Ownable(owner) {\n        GEM = _gem;\n        POOL = _pool;\n        ILK_INDEX = _ilkIndex;\n\n        // Sanity check\n        if (_pool.getIlkAddress(_ilkIndex) != address(_gem)) revert WrongIlkAddress(_ilkIndex, _gem);\n    }\n\n    /**\n     * @dev Pauses the contract.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses the contract.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Gem will be sourced from `msg.sender` and credited to `user`.\n     * @param user to credit the gem to\n     * @param amount of gem to add\n     */\n    function join(address user, uint256 amount) external whenNotPaused {\n        if (int256(amount) < 0) revert Int256Overflow();\n\n        totalGem += amount;\n\n        POOL.mintAndBurnGem(ILK_INDEX, user, int256(amount));\n        GEM.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /**\n     * @dev Gem will be debited from `msg.sender` and sent to `user`.\n     */\n    function exit(address user, uint256 amount) external whenNotPaused {\n        if (int256(amount) < 0) revert Int256Overflow();\n\n        totalGem -= amount;\n\n        POOL.mintAndBurnGem(ILK_INDEX, msg.sender, -int256(amount));\n        GEM.safeTransfer(user, amount);\n    }\n}"
    }
  ]
}