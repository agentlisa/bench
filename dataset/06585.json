{
  "Title": "[H-01] Incorrect `blocksPerYear` constant in `WhitepaperInterestRateModel`",
  "Content": "\n<https://github.com/code-423n4/2023-05-venus/blob/8be784ed9752b80e6f1b8b781e2e6251748d0d7e/contracts/WhitePaperInterestRateModel.sol#L17>\n\nThe interest rate per block is **5x** greater than it's intended to be for markets that use the Whitepaper interest rate model.\n\n### Proof of Concept\n\nThe `WhitePaperInterestRateModel` contract is forked from Compound Finance, which was designed to be deployed on Ethereum Mainnet. The `blocksPerYear` constant inside the contract is used to calculate the interest rate of the market on a per-block basis and is set to **2102400**, which assumes that there are 365 days a year and that the block-time is **15 seconds**.\n\nHowever, Venus Protocol is deployed on the BNB chain, which has a block-time of only **3 seconds**. This results in the interest rate per block on the BNB chain to be **5x** greater than intended.\n\nBoth `baseRatePerBlock` and `multiplierPerBlock` are affected and are **5x** the value they should be. This also implies that the pool's interest rate is also 5 times more sensitive to utilization rate changes than intended. It is impossible for the market to arbitrage and adjust the interest rate back to the intended rate as seen in the PoC graph below. It's likely that arbitrageurs will deposit as much collateral as possible to take advantage of the high supply rate, leading to a utilization ratio close to 0.\n\nThe following Python script plots the `WhitePaperInterestRateModel` curves for a 15 second and a 3 second block time.\n\n```python\nimport matplotlib.pyplot as plt\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/WhitePaperInterestRateModel.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's WhitePaperInterestRateModel Contract\n * @author Compound\n * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper\n */\ncontract WhitePaperInterestRateModel is InterestRateModel {\n    uint256 private constant BASE = 1e18;\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint256 public constant blocksPerYear = 2102400;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint256 public immutable multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint256 public immutable baseRatePerBlock;\n\n    event NewInterestParams(uint256 baseRatePerBlock, uint256 multiplierPerBlock);\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     */\n    constructor(uint256 baseRatePerYear, uint256 multiplierPerYear) {\n        baseRatePerBlock = baseRatePerYear / blocksPerYear;\n        multiplierPerBlock = multiplierPerYear / blocksPerYear;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public view override returns (uint256) {\n        uint256 ur = utilizationRate(cash, borrows, reserves);\n        return ((ur * multiplierPerBlock) / BASE) + baseRatePerBlock;\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view override returns (uint256) {\n        uint256 oneMinusReserveFactor = BASE - reserveFactorMantissa;\n        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n        uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / BASE;\n        return (utilizationRate(cash, borrows, reserves) * rateToPool) / BASE;\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, BASE]\n     */\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return (borrows * BASE) / (cash + borrows - reserves);\n    }\n}"
    }
  ]
}