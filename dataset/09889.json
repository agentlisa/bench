{
  "Title": "[M-15] [WP-H7] InsuranceFund#syncDeps() may cause usersâ€™ fund loss",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L116-L119\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L116-L119\n\n```solidity\nfunction syncDeps(IRegistry _registry) public onlyGovernance {\n    vusd = IERC20(_registry.vusd());\n    marginAccount = _registry.marginAccount();\n}\n```\n\nThe `Governance` address can call `InsuranceFund.sol#syncDeps()` to change the contract address of `vusd` anytime.\n\nHowever, since the tx to set a new address for `vusd` can get in between users' txs to deposit and withdraw, in some edge cases, it can result in users' loss of funds.\n\n### PoC\n\n1. Alice deposited `1,000,000 VUSD` to `InsuranceFund`;\n2. Gov called `syncDeps()` and set `vusd` to the address of `VUSDv2`;\n3. Alice called `withdraw()` with all the `shares` and get back `0 VUSDv2`.\n\nAs a result, Alice suffered a fund loss of `1,000,000 VUSD`.\n\n### Recommendation\n\n1. Consider making `vusd` unchangeable;\n2. If a possible migration of `vusd` must be considered, consider changing the `syncDeps()` to:\n\n```solidity\nfunction syncDeps(IRegistry _registry) public onlyGovernance {\n    uint _balance = balance();\n    vusd = IERC20(_registry.vusd());\n    require(balance() >= _balance);\n    marginAccount = _registry.marginAccount();\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/InsuranceFund.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry } from \"./Interfaces.sol\";\n\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    uint public pendingObligation;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(msg.sender == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    function initialize(address _governance) external {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\"); // has initializer modifier\n        _setGovernace(_governance);\n    }\n\n    function deposit(uint _amount) external {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = balance();\n        uint _totalSupply = totalSupply();\n        if (_totalSupply == 0 && _pool > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance, _pool);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(msg.sender, address(this), _amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = _amount;\n        } else {\n            shares = _amount * _totalSupply / _pool;\n        }\n        _mint(msg.sender, shares);\n        emit FundsAdded(msg.sender, _amount, block.timestamp);\n    }\n\n    function withdraw(uint _shares) external {\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        uint amount = balance() * _shares / totalSupply();\n        _burn(msg.sender, _shares);\n        vusd.safeTransfer(msg.sender, amount);\n        emit FundsWithdrawn(msg.sender, amount, block.timestamp);\n    }\n\n    function seizeBadDebt(uint amount) external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    /**\n    * @notice Just a vanity function\n    */\n    function pricePerShare() external view returns (uint) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balance();\n        _balance -= Math.min(_balance, pendingObligation);\n        if (_totalSupply == 0 || _balance == 0) {\n            return PRECISION;\n        }\n        return _balance * PRECISION / _totalSupply;\n    }\n\n    function balance() public view returns (uint) {\n        return vusd.balanceOf(address(this));\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    /* ****************** */\n    /*   onlyGovernance   */\n    /* ****************** */\n\n    function syncDeps(IRegistry _registry) public onlyGovernance {\n        vusd = IERC20(_registry.vusd());\n        marginAccount = _registry.marginAccount();\n    }\n}"
    }
  ]
}