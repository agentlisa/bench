{
  "Title": "Missing and Incomplete Documentation",
  "Content": "Throughout the codebase, there are multiple code instances that do not have docstrings.\n\n\n* The [`upgradeChainFromVersion`](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/chain-deps/facets/Admin.sol#L100-L120) and [`setValidiumMode`](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/chain-deps/facets/Admin.sol#L89-L93) functions in `Admin.sol`\n* The [`registerAlreadyDeployedStateTransition`](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/StateTransitionManager.sol#L230-L236) and [`createNewChain`](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/StateTransitionManager.sol#L239) (`_diamondCut` parameter especially) functions in `StateTransitionManager.sol`\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec). Furthermore, the comment [*\"new fields\"*](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/chain-deps/ZkSyncStateTransitionStorage.sol#L138) in `ZkSyncStateTransitionStorage.sol` could be more meaningful (e.g., by specifying a version).\n\n\n***Update:** Resolved in [pull request #298](https://github.com/matter-labs/era-contracts/pull/298).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "l1-contracts/contracts/state-transition/chain-deps/facets/Admin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IAdmin} from \"../../chain-interfaces/IAdmin.sol\";\nimport {Diamond} from \"../../libraries/Diamond.sol\";\nimport {MAX_GAS_PER_TRANSACTION} from \"../../../common/Config.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../ZkSyncStateTransitionStorage.sol\";\nimport {ZkSyncStateTransitionBase} from \"./ZkSyncStateTransitionBase.sol\";\nimport {IStateTransitionManager} from \"../../IStateTransitionManager.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZkSyncStateTransitionBase} from \"../../chain-interfaces/IZkSyncStateTransitionBase.sol\";\n\n/// @title Admin Contract controls access rights for contract management.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract AdminFacet is ZkSyncStateTransitionBase, IAdmin {\n    /// @inheritdoc IZkSyncStateTransitionBase\n    string public constant override getName = \"AdminFacet\";\n\n    /// @inheritdoc IAdmin\n    function setPendingAdmin(address _newPendingAdmin) external onlyAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = s.pendingAdmin;\n        // Change pending admin\n        s.pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function acceptAdmin() external {\n        address pendingAdmin = s.pendingAdmin;\n        require(msg.sender == pendingAdmin, \"n4\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = s.admin;\n        s.admin = pendingAdmin;\n        delete s.pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function setValidator(address _validator, bool _active) external onlyStateTransitionManager {\n        s.validators[_validator] = _active;\n        emit ValidatorStatusUpdate(_validator, _active);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPorterAvailability(bool _zkPorterIsAvailable) external onlyStateTransitionManager {\n        // Change the porter availability\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        emit IsPorterAvailableStatusUpdate(_zkPorterIsAvailable);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyStateTransitionManager {\n        require(_newPriorityTxMaxGasLimit <= MAX_GAS_PER_TRANSACTION, \"n5\");\n\n        uint256 oldPriorityTxMaxGasLimit = s.priorityTxMaxGasLimit;\n        s.priorityTxMaxGasLimit = _newPriorityTxMaxGasLimit;\n        emit NewPriorityTxMaxGasLimit(oldPriorityTxMaxGasLimit, _newPriorityTxMaxGasLimit);\n    }\n\n    /// @inheritdoc IAdmin\n    function changeFeeParams(FeeParams calldata _newFeeParams) external onlyAdminOrStateTransitionManager {\n        // Double checking that the new fee params are valid, i.e.\n        // the maximal pubdata per batch is not less than the maximal pubdata per priority transaction.\n        require(_newFeeParams.maxPubdataPerBatch >= _newFeeParams.priorityTxMaxPubdata, \"n6\");\n\n        FeeParams memory oldFeeParams = s.feeParams;\n        s.feeParams = _newFeeParams;\n\n        emit NewFeeParams(oldFeeParams, _newFeeParams);\n    }\n\n    /// @inheritdoc IAdmin\n    function setTokenMultiplier(uint128 _nominator, uint128 _denominator) external onlyAdminOrStateTransitionManager {\n        uint128 oldNominator = s.baseTokenGasPriceMultiplierNominator;\n        uint128 oldDenominator = s.baseTokenGasPriceMultiplierDenominator;\n\n        s.baseTokenGasPriceMultiplierNominator = _nominator;\n        s.baseTokenGasPriceMultiplierDenominator = _denominator;\n\n        emit NewBaseTokenMultiplier(oldNominator, oldDenominator, _nominator, _denominator);\n    }\n\n    function setValidiumMode(PubdataPricingMode _validiumMode) external onlyAdmin {\n        require(s.totalBatchesCommitted == 0, \"AdminFacet: set validium only after genesis\"); // Validium mode can be set only before the first batch is committed\n        s.feeParams.pubdataPricingMode = _validiumMode;\n        emit ValidiumModeStatusUpdate(_validiumMode);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UPGRADE EXECUTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// upgrade a specific chain\n    function upgradeChainFromVersion(\n        uint256 _oldProtocolVersion,\n        Diamond.DiamondCutData calldata _diamondCut\n    ) external onlyAdminOrStateTransitionManager {\n        bytes32 cutHashInput = keccak256(abi.encode(_diamondCut));\n        require(\n            cutHashInput == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion),\n            \"StateTransition: cutHash mismatch\"\n        );\n\n        require(\n            s.protocolVersion == _oldProtocolVersion,\n            \"StateTransition: protocolVersion mismatch in STC when upgrading\"\n        );\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n        require(\n            s.protocolVersion > _oldProtocolVersion,\n            \"StateTransition: protocolVersion mismatch in STC after upgrading\"\n        );\n    }\n\n    /// @inheritdoc IAdmin\n    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external onlyStateTransitionManager {\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT FREEZING\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAdmin\n    function freezeDiamond() external onlyAdminOrStateTransitionManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        diamondStorage.isFrozen = true;\n\n        emit Freeze();\n    }\n\n    /// @inheritdoc IAdmin\n    function unfreezeDiamond() external onlyAdminOrStateTransitionManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze();\n    }\n}"
    },
    {
      "filename": "l1-contracts/contracts/state-transition/StateTransitionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Diamond} from \"./libraries/Diamond.sol\";\nimport {DiamondProxy} from \"./chain-deps/DiamondProxy.sol\";\nimport {IAdmin} from \"./chain-interfaces/IAdmin.sol\";\nimport {IDefaultUpgrade} from \"../upgrades/IDefaultUpgrade.sol\";\nimport {IDiamondInit} from \"./chain-interfaces/IDiamondInit.sol\";\nimport {IExecutor} from \"./chain-interfaces/IExecutor.sol\";\nimport {IStateTransitionManager, StateTransitionManagerInitializeData} from \"./IStateTransitionManager.sol\";\nimport {ISystemContext} from \"./l2-deps/ISystemContext.sol\";\nimport {IZkSyncStateTransition} from \"./chain-interfaces/IZkSyncStateTransition.sol\";\nimport {L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR, L2_FORCE_DEPLOYER_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {ProposedUpgrade} from \"../upgrades/BaseZkSyncUpgrade.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L2_TO_L1_LOG_SERIALIZE_SIZE, DEFAULT_L2_LOGS_TREE_ROOT_HASH, EMPTY_STRING_KECCAK, SYSTEM_UPGRADE_L2_TX_TYPE, ERA_DIAMOND_PROXY, ERA_CHAIN_ID} from \"../common/Config.sol\";\nimport {VerifierParams} from \"./chain-interfaces/IVerifier.sol\";\n\n/// @title StateTransition contract\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract StateTransitionManager is IStateTransitionManager, ReentrancyGuard, Ownable2Step {\n    /// @notice Address of the bridgehub\n    address public immutable bridgehub;\n\n    /// @notice chainId => chainContract\n    mapping(uint256 => address) public stateTransition;\n\n    /// @dev Batch hash zero, calculated at initialization\n    bytes32 public storedBatchZero;\n\n    /// @dev Stored cutData for diamond cut\n    bytes32 public initialCutHash;\n\n    /// @dev genesisUpgrade contract address, used to setChainId\n    address public genesisUpgrade;\n\n    /// @dev current protocolVersion\n    uint256 public protocolVersion;\n\n    /// @dev validatorTimelock contract address, used to setChainId\n    address public validatorTimelock;\n\n    /// @dev Stored cutData for upgrade diamond cut. protocolVersion => cutHash\n    mapping(uint256 => bytes32) public upgradeCutHash;\n\n    /// @dev used to manage non critical updates\n    address public admin;\n\n    /// @dev used to accept the admin role\n    address private pendingAdmin;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(address _bridgehub) reentrancyGuardInitializer {\n        bridgehub = _bridgehub;\n    }\n\n    /// @notice only the bridgehub can call\n    modifier onlyBridgehub() {\n        require(msg.sender == bridgehub, \"StateTransition: only bridgehub\");\n        _;\n    }\n\n    /// @notice the admin can call, for non-critical updates\n    modifier onlyOwnerOrAdmin() {\n        require(msg.sender == admin || msg.sender == owner(), \"Bridgehub: not owner or admin\");\n        _;\n    }\n\n    function getChainAdmin(uint256 _chainId) external view override returns (address) {\n        return IZkSyncStateTransition(stateTransition[_chainId]).getAdmin();\n    }\n\n    /// @dev initialize\n    function initialize(\n        StateTransitionManagerInitializeData calldata _initializeData\n    ) external reentrancyGuardInitializer {\n        require(_initializeData.governor != address(0), \"StateTransition: governor zero\");\n        _transferOwnership(_initializeData.governor);\n\n        genesisUpgrade = _initializeData.genesisUpgrade;\n        protocolVersion = _initializeData.protocolVersion;\n        validatorTimelock = _initializeData.validatorTimelock;\n\n        // We need to initialize the state hash because it is used in the commitment of the next batch\n        IExecutor.StoredBatchInfo memory batchZero = IExecutor.StoredBatchInfo(\n            0,\n            _initializeData.genesisBatchHash,\n            _initializeData.genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _initializeData.genesisBatchCommitment\n        );\n        storedBatchZero = keccak256(abi.encode(batchZero));\n\n        initialCutHash = keccak256(abi.encode(_initializeData.diamondCut));\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        require(msg.sender == currentPendingAdmin, \"n42\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @dev set validatorTimelock. Cannot do it an initialization, as validatorTimelock is deployed after STM\n    function setValidatorTimelock(address _validatorTimelock) external onlyOwnerOrAdmin {\n        validatorTimelock = _validatorTimelock;\n    }\n\n    /// @dev set initial cutHash\n    function setInitialCutHash(Diamond.DiamondCutData calldata _diamondCut) external onlyOwner {\n        initialCutHash = keccak256(abi.encode(_diamondCut));\n    }\n\n    /// @dev set New Version with upgrade from old version\n    function setNewVersionUpgrade(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion,\n        uint256 _newProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n        protocolVersion = _newProtocolVersion;\n    }\n\n    /// @dev set upgrade for some protocolVersion\n    function setUpgradeDiamondCut(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n    }\n\n    /// @dev freezes the specified chain\n    function freezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev freezes the specified chain\n    function unfreezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev reverts batches on the specified chain\n    function revertBatches(uint256 _chainId, uint256 _newLastBatch) external onlyOwnerOrAdmin {\n        IZkSyncStateTransition(stateTransition[_chainId]).revertBatches(_newLastBatch);\n    }\n\n    /// registration\n\n    /// @dev we have to set the chainId at genesis, as blockhashzero is the same for all chains with the same chainId\n    function _setChainIdUpgrade(uint256 _chainId, address _chainContract) internal {\n        bytes memory systemContextCalldata = abi.encodeCall(ISystemContext.setChainId, (_chainId));\n        uint256[] memory uintEmptyArray;\n        bytes[] memory bytesEmptyArray;\n\n        L2CanonicalTransaction memory l2ProtocolUpgradeTx = L2CanonicalTransaction({\n            txType: SYSTEM_UPGRADE_L2_TX_TYPE,\n            from: uint256(uint160(L2_FORCE_DEPLOYER_ADDR)),\n            to: uint256(uint160(L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR)),\n            gasLimit: $(PRIORITY_TX_MAX_GAS_LIMIT),\n            gasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            maxFeePerGas: uint256(0),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: protocolVersion,\n            value: 0,\n            reserved: [uint256(0), 0, 0, 0],\n            data: systemContextCalldata,\n            signature: new bytes(0),\n            factoryDeps: uintEmptyArray,\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n\n        ProposedUpgrade memory proposedUpgrade = ProposedUpgrade({\n            l2ProtocolUpgradeTx: l2ProtocolUpgradeTx,\n            factoryDeps: bytesEmptyArray,\n            bootloaderHash: bytes32(0),\n            defaultAccountHash: bytes32(0),\n            verifier: address(0),\n            verifierParams: VerifierParams({\n                recursionNodeLevelVkHash: bytes32(0),\n                recursionLeafLevelVkHash: bytes32(0),\n                recursionCircuitsSetVksHash: bytes32(0)\n            }),\n            l1ContractsUpgradeCalldata: new bytes(0),\n            postUpgradeCalldata: new bytes(0),\n            upgradeTimestamp: 0,\n            newProtocolVersion: protocolVersion\n        });\n\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: genesisUpgrade,\n            initCalldata: abi.encodeCall(IDefaultUpgrade.upgrade, (proposedUpgrade))\n        });\n\n        IAdmin(_chainContract).executeUpgrade(cutData);\n        emit SetChainIdUpgrade(_chainContract, l2ProtocolUpgradeTx, protocolVersion);\n    }\n\n    function registerAlreadyDeployedStateTransition(\n        uint256 _chainId,\n        address _stateTransitionContract\n    ) external onlyOwner {\n        stateTransition[_chainId] = _stateTransitionContract;\n        emit StateTransitionNewChain(_chainId, _stateTransitionContract);\n    }\n\n    /// @notice called by Bridgehub when a chain registers\n    function createNewChain(\n        uint256 _chainId,\n        address _baseToken,\n        address _sharedBridge,\n        address _admin,\n        bytes calldata _diamondCut\n    ) external onlyBridgehub {\n        if (stateTransition[_chainId] != address(0)) {\n            // StateTransition chain already registered\n            return;\n        }\n\n        // check not registered\n        Diamond.DiamondCutData memory diamondCut = abi.decode(_diamondCut, (Diamond.DiamondCutData));\n\n        // check input\n        bytes32 cutHashInput = keccak256(_diamondCut);\n        require(cutHashInput == initialCutHash, \"StateTransition: initial cutHash mismatch\");\n\n        // construct init data\n        bytes memory initData;\n        /// all together 4+9*32=292 bytes\n        initData = bytes.concat(\n            IDiamondInit.initialize.selector,\n            bytes32(_chainId),\n            bytes32(uint256(uint160(bridgehub))),\n            bytes32(uint256(uint160(address(this)))),\n            bytes32(uint256(protocolVersion)),\n            bytes32(uint256(uint160(_admin))),\n            bytes32(uint256(uint160(validatorTimelock))),\n            bytes32(uint256(uint160(_baseToken))),\n            bytes32(uint256(uint160(_sharedBridge))),\n            bytes32(storedBatchZero),\n            diamondCut.initCalldata\n        );\n\n        diamondCut.initCalldata = initData;\n        // deploy stateTransitionContract\n        DiamondProxy stateTransitionContract = new DiamondProxy{salt: bytes32(0)}(block.chainid, diamondCut);\n\n        // save data\n        address stateTransitionAddress = address(stateTransitionContract);\n\n        stateTransition[_chainId] = stateTransitionAddress;\n\n        // set chainId in VM\n        _setChainIdUpgrade(_chainId, stateTransitionAddress);\n\n        emit StateTransitionNewChain(_chainId, stateTransitionAddress);\n    }\n}"
    },
    {
      "filename": "l1-contracts/contracts/state-transition/chain-deps/ZkSyncStateTransitionStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IVerifier, VerifierParams} from \"../chain-interfaces/IVerifier.sol\";\nimport {PriorityQueue} from \"../../state-transition/libraries/PriorityQueue.sol\";\n\n/// @notice Indicates whether an upgrade is initiated and if yes what type\n/// @param None Upgrade is NOT initiated\n/// @param Transparent Fully transparent upgrade is initiated, upgrade data is publicly known\n/// @param Shadow Shadow upgrade is initiated, upgrade data is hidden\nenum UpgradeState {\n    None,\n    Transparent,\n    Shadow\n}\n\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy\n/// upgrades and diamond cuts\n/// @param proposedUpgradeHash The hash of the current upgrade proposal, zero if there is no active proposal\n/// @param state Indicates whether an upgrade is initiated and if yes what type\n/// @param securityCouncil Address which has the permission to approve instant upgrades (expected to be a Gnosis\n/// multisig)\n/// @param approvedBySecurityCouncil Indicates whether the security council has approved the upgrade\n/// @param proposedUpgradeTimestamp The timestamp when the upgrade was proposed, zero if there are no active proposals\n/// @param currentProposalId The serial number of proposed upgrades, increments when proposing a new one\nstruct UpgradeStorage {\n    bytes32 proposedUpgradeHash;\n    UpgradeState state;\n    address securityCouncil;\n    bool approvedBySecurityCouncil;\n    uint40 proposedUpgradeTimestamp;\n    uint40 currentProposalId;\n}\n\n/// @notice The struct that describes whether users will be charged for pubdata for L1->L2 transactions.\n/// @param Rollup The users are charged for pubdata & it is priced based on the gas price on Ethereum.\n/// @param Validium The pubdata is considered free with regard to the L1 gas price.\nenum PubdataPricingMode {\n    Rollup,\n    Validium\n}\n\n/// @notice The fee params for L1->L2 transactions for the network.\n/// @param pubdataPricingMode How the users will charged for pubdata in L1->L2 transactions.\n/// @param batchOverheadL1Gas The amount of L1 gas required to process the batch (except for the calldata).\n/// @param maxPubdataPerBatch The maximal number of pubdata that can be emitted per batch.\n/// @param priorityTxMaxPubdata The maximal amount of pubdata a priority transaction is allowed to publish.\n/// It can be slightly less than maxPubdataPerBatch in order to have some margin for the bootloader execution.\n/// @param minimalL2GasPrice The minimal L2 gas price to be used by L1->L2 transactions. It should represent\n/// the price that a single unit of compute costs.\nstruct FeeParams {\n    PubdataPricingMode pubdataPricingMode;\n    uint32 batchOverheadL1Gas;\n    uint32 maxPubdataPerBatch;\n    uint32 maxL2GasPerBatch;\n    uint32 priorityTxMaxPubdata;\n    uint64 minimalL2GasPrice;\n}\n\n/// @dev storing all storage variables for hyperchain diamond facets\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\n/// but NOT to modify already existing variables or change their order.\n/// NOTE: variables prefixed with '__DEPRECATED_' are deprecated and shouldn't be used.\n/// Their presence is maintained for compatibility and to prevent storage collision.\nstruct ZkSyncStateTransitionStorage {\n    /// @dev Storage of variables needed for deprecated diamond cut facet\n    uint256[7] __DEPRECATED_diamondCutStorage;\n    /// @notice Address which will exercise critical changes to the Diamond Proxy (upgrades, freezing & unfreezing). Replaced by STM\n    address __DEPRECATED_governor;\n    /// @notice Address that the governor proposed as one that will replace it\n    address __DEPRECATED_pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address validatorAddress => bool isValidator) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for batches\n    IVerifier verifier;\n    /// @notice Total number of executed batches i.e. batches[totalBatchesExecuted] points at the latest executed batch\n    /// (batch 0 is genesis)\n    uint256 totalBatchesExecuted;\n    /// @notice Total number of proved batches i.e. batches[totalBatchesProved] points at the latest proved batch\n    uint256 totalBatchesVerified;\n    /// @notice Total number of committed batches i.e. batches[totalBatchesCommitted] points at the latest committed\n    /// batch\n    uint256 totalBatchesCommitted;\n    /// @dev Stored hashed StoredBatch for batch number\n    mapping(uint256 batchNumber => bytes32 batchHash) storedBatchHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 batchNumber => bytes32 l2LogsRootHash) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    address __DEPRECATED_allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n    bool zkPorterIsAvailable;\n    /// @dev The maximum number of the L2 gas that a user can request for L1 -> L2 transactions\n    /// @dev This is the maximum number of L2 gas that is available for the \"body\" of the transaction, i.e.\n    /// without overhead for proving the batch.\n    uint256 priorityTxMaxGasLimit;\n    /// @dev Storage of variables needed for upgrade facet\n    UpgradeStorage __DEPRECATED_upgrades;\n    /// @dev A mapping L2 batch number => message number => flag.\n    /// @dev The L2 -> L1 log is sent for every withdrawal, so this mapping is serving as\n    /// a flag to indicate that the message was already processed.\n    /// @dev Used to indicate that eth withdrawal was already processed\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized)) isEthWithdrawalFinalized;\n    /// @dev The most recent withdrawal time and amount reset\n    uint256 __DEPRECATED_lastWithdrawalLimitReset;\n    /// @dev The accumulated withdrawn amount during the withdrawal limit window\n    uint256 __DEPRECATED_withdrawnAmountInWindow;\n    /// @dev A mapping user address => the total deposited amount by the user\n    mapping(address => uint256) __DEPRECATED_totalDepositedAmountPerUser;\n    /// @dev Stores the protocol version. Note, that the protocol version may not only encompass changes to the\n    /// smart contracts, but also to the node behavior.\n    uint256 protocolVersion;\n    /// @dev Hash of the system contract upgrade transaction. If 0, then no upgrade transaction needs to be done.\n    bytes32 l2SystemContractsUpgradeTxHash;\n    /// @dev Batch number where the upgrade transaction has happened. If 0, then no upgrade transaction has happened\n    /// yet.\n    uint256 l2SystemContractsUpgradeBatchNumber;\n    /// @dev Address which will exercise non-critical changes to the Diamond Proxy (changing validator set & unfreezing)\n    address admin;\n    /// @notice Address that the admin proposed as one that will replace admin role\n    address pendingAdmin;\n    /// @dev Fee params used to derive gasPrice for the L1->L2 transactions. For L2 transactions,\n    /// the bootloader gives enough freedom to the operator.\n    FeeParams feeParams;\n    /// @dev Address of the blob versioned hash getter smart contract used for EIP-4844 versioned hashes.\n    address blobVersionedHashRetriever;\n    /// new fields\n    /// @dev The chainId of the chain\n    uint256 chainId;\n    /// @dev The address of the bridgehub\n    address bridgehub;\n    /// @dev The address of the StateTransitionManager\n    address stateTransitionManager;\n    /// @dev The address of the baseToken contract. Eth is address(1)\n    address baseToken;\n    /// @dev The address of the baseTokenbridge. Eth also uses the shared bridge\n    address baseTokenBridge;\n    /// @notice gasPriceMultiplier for each baseToken, so that each L1->L2 transaction pays for its transaction on the destination\n    /// we multiply by the nominator, and divide by the denominator\n    uint128 baseTokenGasPriceMultiplierNominator;\n    uint128 baseTokenGasPriceMultiplierDenominator;\n}"
    }
  ]
}