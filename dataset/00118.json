{
  "Title": "Potential DoS of `SeasonFacet::gm` due to division by zero in `LibGauge::updateGaugePoints`",
  "Content": "There currently exists an edge case in [`LibGauge::updateGaugePoints`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibGauge.sol#L84) where it is possible to unintentionally DoS `SeasonFacet::gm` due to a potential division by zero. If there is only one newly whitelisted LP token in the Beanstalk protocol which therefore has no deposited BDV, execution will revert, thus preventing Beanstalk from advancing to the next Season. While it is unlikely that Beanstalk will encounter this issue so long as the existing whitelisted LP tokens remain, there is a small possibility that this could be an issue in the event of some future liquidity migration and so it should be handled accordingly.\n\n```diff\n...\n// if there is only one pool, there is no need to update the gauge points.\nif (whitelistedLpTokens.length == 1) {\n    // Assumes that only Wells use USD price oracles.\n    if (LibWell.isWell(whitelistedLpTokens[0]) && s.usdTokenPrice[whitelistedLpTokens[0]] == 0) {\n        return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);\n    }\n    uint256 gaugePoints = s.ss[whitelistedLpTokens[0]].gaugePoints;\n+   if (s.siloBalances[whitelistedLpTokens[0]].depositedBdv != 0) {\n        lpGpData[0].gpPerBdv = gaugePoints.mul(BDV_PRECISION).div(\n            s.siloBalances[whitelistedLpTokens[0]].depositedBdv\n        );\n+   }\n    return (\n        lpGpData[0].gpPerBdv,\n        lpGpData,\n        gaugePoints,\n        s.siloBalances[whitelistedLpTokens[0]].depositedBdv\n    );\n}\n...\n```",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibGauge.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibAppStorage, AppStorage, Storage} from \"./LibAppStorage.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\nimport {LibWhitelist} from \"contracts/libraries/Silo/LibWhitelist.sol\";\nimport {LibSafeMath32} from \"contracts/libraries/LibSafeMath32.sol\";\nimport {C} from \"../C.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\n\n/**\n * @title LibGauge\n * @author Brean, Brendan\n * @notice LibGauge handles functionality related to the seed gauge system.\n */\nlibrary LibGauge {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using LibSafeMath32 for uint32;\n\n    uint256 internal constant BDV_PRECISION = 1e6;\n    uint256 internal constant GP_PRECISION = 1e18;\n\n    // max and min are the ranges that the beanToMaxLpGpPerBdvRatioScaled can output.\n    uint256 internal constant MAX_BEAN_MAX_LP_GP_PER_BDV_RATIO = 100e18;\n    uint256 internal constant MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO = 50e18;\n    uint256 internal constant BEAN_MAX_LP_GP_RATIO_RANGE =\n        MAX_BEAN_MAX_LP_GP_PER_BDV_RATIO - MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO;\n\n    // the maximum value of beanToMaxLpGpPerBdvRatio.\n    uint256 internal constant ONE_HUNDRED_PERCENT = 100e18;\n\n    // 24 * 30 * 6\n    uint256 internal constant TARGET_SEASONS_TO_CATCHUP = 4320;\n    uint256 internal constant STALK_BDV_PRECISION = 1e4;\n\n    /**\n     * @notice Emitted when the AverageGrownStalkPerBdvPerSeason Updates.\n     */\n    event UpdateStalkPerBdvPerSeason(uint256 newStalkPerBdvPerSeason);\n\n    struct LpGaugePointData {\n        address lpToken;\n        uint256 gpPerBdv;\n    }\n    /**\n     * @notice Emitted when the gaugePoints for an LP silo token changes.\n     * @param season The current Season\n     * @param token The LP silo token whose gaugePoints was updated.\n     * @param gaugePoints The new gaugePoints for the LP silo token.\n     */\n    event GaugePointChange(uint256 indexed season, address indexed token, uint256 gaugePoints);\n\n    /**\n     * @notice Updates the seed gauge system.\n     * @dev updates the GaugePoints for LP assets (if applicable)\n     * and the distribution of grown Stalk to silo assets.\n     *\n     * If any of the LP price oracle failed, \n     * then the gauge system should be skipped, as a valid \n     * usd liquidity value cannot be computed.\n     */\n    function stepGauge() external {\n        (\n            uint256 maxLpGpPerBdv,\n            LpGaugePointData[] memory lpGpData,\n            uint256 totalGaugePoints,\n            uint256 totalLpBdv\n        ) = updateGaugePoints();\n        if (totalLpBdv == type(uint256).max) return;\n        updateGrownStalkEarnedPerSeason(maxLpGpPerBdv, lpGpData, totalGaugePoints, totalLpBdv);\n    }\n\n    /**\n     * @notice evaluate the gauge points of each LP asset.\n     * @dev `totalLpBdv` is returned as type(uint256).max when an Oracle failure occurs.\n     */\n    function updateGaugePoints()\n        internal\n        returns (\n            uint256 maxLpGpPerBdv,\n            LpGaugePointData[] memory lpGpData,\n            uint256 totalGaugePoints,\n            uint256 totalLpBdv\n        )\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address[] memory whitelistedLpTokens = LibWhitelistedTokens.getWhitelistedLpTokens();\n        lpGpData = new LpGaugePointData[](whitelistedLpTokens.length);\n\n        // if there is only one pool, there is no need to update the gauge points.\n        if (whitelistedLpTokens.length == 1) {\n            // Assumes that only Wells use USD price oracles.\n            if (LibWell.isWell(whitelistedLpTokens[0]) && s.usdTokenPrice[whitelistedLpTokens[0]] == 0) {\n                return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);\n            }\n            uint256 gaugePoints = s.ss[whitelistedLpTokens[0]].gaugePoints;\n            lpGpData[0].gpPerBdv = gaugePoints.mul(BDV_PRECISION).div(\n                s.siloBalances[whitelistedLpTokens[0]].depositedBdv\n            );\n            return (\n                lpGpData[0].gpPerBdv,\n                lpGpData,\n                gaugePoints,\n                s.siloBalances[whitelistedLpTokens[0]].depositedBdv\n            );\n        }\n\n        // summate total deposited BDV across all whitelisted LP tokens.\n        for (uint256 i; i < whitelistedLpTokens.length; ++i) {\n            // Assumes that only Wells use USD price oracles.\n            if (LibWell.isWell(whitelistedLpTokens[i]) && s.usdTokenPrice[whitelistedLpTokens[i]] == 0) {\n                return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);\n            }\n            totalLpBdv = totalLpBdv.add(s.siloBalances[whitelistedLpTokens[i]].depositedBdv);\n        }\n\n        // if nothing has been deposited, skip gauge point update.\n        if (totalLpBdv == 0) return (maxLpGpPerBdv, lpGpData, totalGaugePoints, totalLpBdv);\n\n        // calculate and update the gauge points for each LP.\n        for (uint256 i; i < whitelistedLpTokens.length; ++i) {\n            Storage.SiloSettings storage ss = s.ss[whitelistedLpTokens[i]];\n\n            uint256 depositedBdv = s.siloBalances[whitelistedLpTokens[i]].depositedBdv;\n\n            // 1e6 = 1%\n            uint256 percentDepositedBdv = depositedBdv.mul(100e6).div(totalLpBdv);\n\n            // gets the gauge points of token from GaugePointFacet.\n            uint256 newGaugePoints = calcGaugePoints(\n                ss.gpSelector,\n                ss.gaugePoints,\n                ss.optimalPercentDepositedBdv,\n                percentDepositedBdv\n            );\n\n            // increment totalGaugePoints and calculate the gaugePoints per BDV:\n            totalGaugePoints = totalGaugePoints.add(newGaugePoints);\n            LpGaugePointData memory _lpGpData;\n            _lpGpData.lpToken = whitelistedLpTokens[i];\n\n            // gauge points has 18 decimal precision (GP_PRECISION = 1%)\n            // deposited BDV has 6 decimal precision (1e6 = 1 unit of BDV)\n            uint256 gpPerBdv = newGaugePoints.mul(BDV_PRECISION).div(depositedBdv);\n\n            // gpPerBdv has 6 decimal precision.\n            if (gpPerBdv > maxLpGpPerBdv) maxLpGpPerBdv = gpPerBdv;\n            _lpGpData.gpPerBdv = gpPerBdv;\n            lpGpData[i] = _lpGpData;\n\n            ss.gaugePoints = newGaugePoints.toUint128();\n            emit GaugePointChange(s.season.current, whitelistedLpTokens[i], ss.gaugePoints);\n        }\n    }\n\n    /**\n     * @notice calculates the new gauge points for the given token.\n     * @dev function calls the selector of the token's gauge point function.\n     * See {GaugePointFacet.defaultGaugePointFunction()}\n     */\n    function calcGaugePoints(\n        bytes4 gpSelector,\n        uint256 gaugePoints,\n        uint256 optimalPercentDepositedBdv,\n        uint256 percentDepositedBdv\n    ) internal view returns (uint256 newGaugePoints) {\n        bytes memory callData = abi.encodeWithSelector(\n            gpSelector,\n            gaugePoints,\n            optimalPercentDepositedBdv,\n            percentDepositedBdv\n        );\n        (bool success, bytes memory data) = address(this).staticcall(callData);\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n        assembly {\n            newGaugePoints := mload(add(data, add(0x20, 0)))\n        }\n    }\n\n    /**\n     * @notice Updates the average grown stalk per BDV per Season for whitelisted Beanstalk assets.\n     * @dev Called at the end of each Season.\n     */\n    function updateGrownStalkEarnedPerSeason(\n        uint256 maxLpGpPerBdv,\n        LpGaugePointData[] memory lpGpData,\n        uint256 totalGaugePoints,\n        uint256 totalLpBdv\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 beanDepositedBdv = s.siloBalances[C.BEAN].depositedBdv;\n        uint256 totalBdv = totalLpBdv.add(beanDepositedBdv);\n\n        // if nothing has been deposited, skip grown stalk update.\n        if (totalBdv == 0) return;\n\n        // calculate the ratio between the bean and the max LP gauge points per BDV.\n        // 6 decimal precision\n        uint256 beanToMaxLpGpPerBdvRatio = getBeanToMaxLpGpPerBdvRatioScaled(\n            s.seedGauge.beanToMaxLpGpPerBdvRatio\n        );\n        // get the GaugePoints and GPperBDV for bean\n        // beanGpPerBdv has 6 decimal precision, beanToMaxLpGpPerBdvRatio has 18.\n        uint256 beanGpPerBdv = maxLpGpPerBdv.mul(beanToMaxLpGpPerBdvRatio).div(100e18);\n\n        totalGaugePoints = totalGaugePoints.add(\n            beanGpPerBdv.mul(beanDepositedBdv).div(BDV_PRECISION)\n        );\n\n        // check if one week elapsed since the last seedGauge update.\n        // if so, update the average grown stalk per BDV per Season.\n        // safemath not needed\n        if (s.season.current - s.seedGauge.lastSeedGaugeUpdate >= 168) {\n            updateStalkPerBdvPerSeason();\n        }\n        // calculate grown stalk issued this season and GrownStalk Per GaugePoint.\n        uint256 newGrownStalk = uint256(s.seedGauge.averageGrownStalkPerBdvPerSeason)\n            .mul(totalBdv)\n            .div(BDV_PRECISION);\n\n        // gauge points has 18 decimal precision.\n        uint256 newGrownStalkPerGp = newGrownStalk.mul(GP_PRECISION).div(totalGaugePoints);\n\n        // update stalkPerBdvPerSeason for bean.\n        issueGrownStalkPerBdv(C.BEAN, newGrownStalkPerGp, beanGpPerBdv);\n\n        // update stalkPerBdvPerSeason for LP\n        // if there is only one pool, then no need to read gauge points.\n        if (lpGpData.length == 1) {\n            issueGrownStalkPerBdv(lpGpData[0].lpToken, newGrownStalkPerGp, lpGpData[0].gpPerBdv);\n        } else {\n            for (uint256 i; i < lpGpData.length; i++) {\n                issueGrownStalkPerBdv(\n                    lpGpData[i].lpToken,\n                    newGrownStalkPerGp,\n                    lpGpData[i].gpPerBdv\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice issues the grown stalk per BDV for the given token.\n     * @param token the token to issue the grown stalk for.\n     * @param grownStalkPerGp the number of GrownStalk Per Gauge Point.\n     * @param gpPerBdv the amount of GaugePoints per BDV the token has.\n     */\n    function issueGrownStalkPerBdv(\n        address token,\n        uint256 grownStalkPerGp,\n        uint256 gpPerBdv\n    ) internal {\n        LibWhitelist.updateStalkPerBdvPerSeasonForToken(\n            token,\n            grownStalkPerGp.mul(gpPerBdv).div(GP_PRECISION).toUint32()\n        );\n    }\n\n    /**\n     * @notice updates the updateStalkPerBdvPerSeason in the seed gauge.\n     * @dev anyone can call this function to update. Currently, the function\n     * updates the targetGrownStalkPerBdvPerSeason such that it will take 6 months\n     * for the average new depositer to catch up to the average grown stalk per BDV.\n     *\n     * The expectation is that actors will call this function on their own as it benefits them.\n     * Newer depositers will call it if the value increases to catch up to the average faster,\n     * Older depositers will call it if the value decreases to slow down their rate of dilution.\n     */\n    function updateStalkPerBdvPerSeason() public {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // will overflow if the average grown stalk per BDV exceeds 1.4e36,\n        // which is highly improbable assuming consistent new deposits.\n        // thus, safeCast was determined is to be unnecessary.\n        s.seedGauge.averageGrownStalkPerBdvPerSeason = uint128(\n            getAverageGrownStalkPerBdv().mul(BDV_PRECISION).div(TARGET_SEASONS_TO_CATCHUP)\n        );\n        s.seedGauge.lastSeedGaugeUpdate = s.season.current;\n        emit UpdateStalkPerBdvPerSeason(s.seedGauge.averageGrownStalkPerBdvPerSeason);\n    }\n\n    /**\n     * @notice returns the total BDV in beanstalk.\n     * @dev the total BDV may differ from the instaneous BDV,\n     * as BDV is asyncronous.\n     */\n    function getTotalBdv() internal view returns (uint256 totalBdv) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address[] memory whitelistedSiloTokens = LibWhitelistedTokens.getWhitelistedTokens();\n        for (uint256 i; i < whitelistedSiloTokens.length; ++i) {\n            totalBdv = totalBdv.add(s.siloBalances[whitelistedSiloTokens[i]].depositedBdv);\n        }\n    }\n\n    /**\n     * @notice returns the average grown stalk per BDV .\n     */\n    function getAverageGrownStalkPerBdv() internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalBdv = getTotalBdv();\n        if (totalBdv == 0) return 0;\n        return s.s.stalk.div(totalBdv).sub(STALK_BDV_PRECISION);\n    }\n\n    /**\n     * @notice returns the ratio between the bean and\n     * the max LP gauge points per BDV.\n     * @dev s.seedGauge.beanToMaxLpGpPerBdvRatio is a number between 0 and 100e18,\n     * where f(100e18) = MIN_BEAN_MAX_LPGP_RATIO and f(0) = MAX_BEAN_MAX_LPGP_RATIO.\n     */\n    function getBeanToMaxLpGpPerBdvRatioScaled(\n        uint256 beanToMaxLpGpPerBdvRatio\n    ) internal pure returns (uint256) {\n        return\n            beanToMaxLpGpPerBdvRatio.mul(BEAN_MAX_LP_GP_RATIO_RANGE).div(ONE_HUNDRED_PERCENT).add(\n                MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO\n            );\n    }\n}"
    }
  ]
}