{
  "Title": "Transfer of poisoned tokens to any address",
  "Content": "##### Description\nThe permissionless nature of the protocol allows a malicious user to transfer any token to any address from the whitelisted address: https://github.com/euler-xyz/reward-streams/blob/95783173eff4668bb177eeefd9e8a9dc1a44669c/src/BaseRewardStreams.sol#L523.\n\n##### Recommendation\nWe recommend requiring an explicit approval from the recipient to receive any token.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/BaseRewardStreams.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.8.24;\n\nimport {ReentrancyGuard} from \"openzeppelin-contracts/utils/ReentrancyGuard.sol\";\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {EVCUtil} from \"evc/utils/EVCUtil.sol\";\nimport {Set, SetStorage} from \"evc/Set.sol\";\nimport {IRewardStreams} from \"./interfaces/IRewardStreams.sol\";\n\n/// @title BaseRewardStreams\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Base class that allows anyone to register a reward distribution stream for a given token.\nabstract contract BaseRewardStreams is IRewardStreams, EVCUtil, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Set for SetStorage;\n\n    /// @notice The duration of a reward epoch.\n    /// @dev Must be longer than 7 days.\n    uint256 public immutable EPOCH_DURATION;\n\n    /// @notice The maximum number of epochs in the future that newly registered reward streams can begin.\n    uint256 public constant MAX_EPOCHS_AHEAD = 5;\n\n    /// @notice The maximum number of epochs that a reward stream can live for.\n    uint256 public constant MAX_DISTRIBUTION_LENGTH = 25;\n\n    /// @notice The maximumum number of reward tokens enabled per account and rewarded token.\n    uint256 public constant MAX_REWARDS_ENABLED = 5;\n\n    /// @notice The minimum duration of an epoch.\n    uint256 internal constant MIN_EPOCH_DURATION = 7 days;\n\n    /// @notice The maximum duration of an epoch.\n    uint256 internal constant MAX_EPOCH_DURATION = 10 * 7 days;\n\n    /// @notice The number of epoch distribution amounts packed in a storage slot.\n    uint256 internal constant EPOCHS_PER_SLOT = 2;\n\n    /// @notice A scaling factor for precise amount calculation.\n    /// @dev Increases precision when dividing an account's distributed amount by the total eligible amount.\n    /// Allows a sufficiently large total registered amount per rewarded and reward token pair without overflowing.\n    /// Value carefully selected to avoid overflow in the user claimable amount.\n    uint256 internal constant SCALER = 2e19;\n\n    /// @notice Struct to store distribution data per rewarded and reward tokens.\n    struct DistributionStorage {\n        /// @notice The last timestamp when the distribution was updated.\n        uint48 lastUpdated;\n        /// @notice The most recent accumulator value.\n        uint208 accumulator;\n        /// @notice Total rewarded token that are eligible for rewards.\n        uint256 totalEligible;\n        /// @notice Total reward token that have been transferred into this contract for rewards.\n        uint128 totalRegistered;\n        /// @notice Total reward token that have been transferred out from this contract for rewards.\n        uint128 totalClaimed;\n        /// @notice Distribution amounts per epoch.\n        mapping(uint256 storageIndex => uint128[EPOCHS_PER_SLOT]) amounts;\n    }\n\n    /// @notice Struct to store earned data.\n    struct EarnStorage {\n        /// @notice Claimable amount, not total earned.\n        uint96 claimable;\n        /// @notice Snapshot of the accumulator at the time of the last data update.\n        uint160 accumulator;\n    }\n\n    /// @notice Struct to store account data per account and rewarded token.\n    struct AccountStorage {\n        /// @notice The account's rewarded token balance.\n        uint256 balance;\n        /// @notice The account's set of enabled reward tokens.\n        SetStorage enabledRewards;\n        /// @notice The account's earnings per reward token.\n        mapping(address reward => EarnStorage) earned;\n    }\n\n    /// @notice Stored distribution data per rewarded token and reward token.\n    mapping(address rewarded => mapping(address reward => DistributionStorage)) internal distributions;\n\n    /// @notice Stored account data per address and rewarded token.\n    mapping(address account => mapping(address rewarded => AccountStorage)) internal accounts;\n\n    /// @notice Event emitted when a reward stream is registered.\n    event RewardRegistered(\n        address indexed caller, address indexed rewarded, address indexed reward, uint256 startEpoch, uint128[] amounts\n    );\n\n    /// @notice Event emitted when a user enables a reward token.\n    event RewardEnabled(address indexed account, address indexed rewarded, address indexed reward);\n\n    /// @notice Event emitted when a user disables a reward token.\n    event RewardDisabled(address indexed account, address indexed rewarded, address indexed reward);\n\n    /// @notice Event emitted when a reward token is claimed.\n    event RewardClaimed(address indexed account, address indexed rewarded, address indexed reward, uint256 amount);\n\n    /// @notice Epoch-related error. Thrown when epoch duration or start epoch is invalid.\n    error InvalidEpoch();\n\n    /// @notice Amount-related error. Thrown when the reward amount is invalid or invalid amount of tokens was\n    /// transferred.\n    error InvalidAmount();\n\n    /// @notice Distribution-related error. Thrown when the reward distribution length is invalid.\n    error InvalidDistribution();\n\n    /// @notice Accumulator-related error. Thrown when the registered reward amount may cause an accumulator overflow.\n    error AccumulatorOverflow();\n\n    /// @notice Rewards-related error. Thrown when user tries to enable too many rewards.\n    error TooManyRewardsEnabled();\n\n    /// @notice Recipient-related error. Thrown when the recipient is invalid.\n    error InvalidRecipient();\n\n    /// @notice Constructor for the BaseRewardStreams contract.\n    /// @param _evc The Ethereum Vault Connector contract.\n    /// @param _epochDuration The duration of an epoch.\n    constructor(address _evc, uint48 _epochDuration) EVCUtil(_evc) {\n        if (_epochDuration < MIN_EPOCH_DURATION || _epochDuration > MAX_EPOCH_DURATION) {\n            revert InvalidEpoch();\n        }\n\n        EPOCH_DURATION = _epochDuration;\n    }\n\n    /// @notice Registers a new reward stream.\n    /// @param rewarded The rewarded token.\n    /// @param reward The reward token.\n    /// @param startEpoch The epoch to start the reward stream from.\n    /// @param rewardAmounts The reward token amounts for each epoch of the reward stream.\n    function registerReward(\n        address rewarded,\n        address reward,\n        uint48 startEpoch,\n        uint128[] calldata rewardAmounts\n    ) external virtual override nonReentrant {\n        uint48 epoch = currentEpoch();\n\n        // If start epoch is 0, set it to the next epoch.\n        if (startEpoch == 0) {\n            startEpoch = epoch + 1;\n        }\n\n        // Start should be at most MAX_EPOCHS_AHEAD epochs in the future.\n        if (!(startEpoch > epoch && startEpoch <= epoch + MAX_EPOCHS_AHEAD)) {\n            revert InvalidEpoch();\n        }\n\n        // Distribution stream should be at most MAX_DISTRIBUTION_LENGTH epochs long.\n        if (rewardAmounts.length > MAX_DISTRIBUTION_LENGTH) {\n            revert InvalidDistribution();\n        }\n\n        // Calculate the total amount to be distributed in this distribution stream.\n        uint256 totalAmount;\n        for (uint256 i = 0; i < rewardAmounts.length; ++i) {\n            totalAmount += rewardAmounts[i];\n        }\n\n        if (totalAmount == 0) {\n            revert InvalidAmount();\n        }\n\n        // Initialize or update the distribution and reward data.\n        DistributionStorage storage distributionStorage = distributions[rewarded][reward];\n        if (distributionStorage.lastUpdated == 0) {\n            distributionStorage.lastUpdated = uint48(block.timestamp);\n        } else {\n            updateReward(rewarded, reward);\n        }\n\n        // Sanity check for overflow (assumes total eligible supply of 1 which is the worst case scenario).\n        uint256 totalRegistered = uint256(distributionStorage.totalRegistered) + totalAmount;\n\n        if (SCALER * totalRegistered > type(uint160).max) {\n            revert AccumulatorOverflow();\n        }\n\n        // Update the total registered amount.\n        // Downcasting is safe because the `type(uint160).max / SCALER < type(uint128).max`.\n        distributionStorage.totalRegistered = uint128(totalRegistered);\n\n        // Store the amounts to be distributed.\n        increaseRewardAmounts(rewarded, reward, startEpoch, rewardAmounts);\n\n        // Transfer the total amount to be distributed to the contract.\n        address msgSender = _msgSender();\n        pullToken(IERC20(reward), msgSender, totalAmount);\n\n        emit RewardRegistered(msgSender, rewarded, reward, startEpoch, rewardAmounts);\n    }\n\n    /// @notice Updates the reward token data.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    function updateReward(address rewarded, address reward) public virtual override {\n        address msgSender = _msgSender();\n\n        // If the account disables the rewards we pass an account balance of zero to not accrue any.\n        AccountStorage storage accountStorage = accounts[msgSender][rewarded];\n        uint256 currentAccountBalance = accountStorage.enabledRewards.contains(reward) ? accountStorage.balance : 0;\n\n        updateRewardInternal(\n            distributions[rewarded][reward],\n            accountStorage.earned[reward],\n            rewarded,\n            reward,\n            currentAccountBalance,\n            false\n        );\n    }\n\n    /// @notice Claims earned reward.\n    /// @dev Rewards are only transferred to the recipient if the recipient is non-zero.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @param recipient The address to receive the claimed reward tokens.\n    /// @param forfeitRecentReward Whether to forfeit the recent rewards and not update the accumulator.\n    function claimReward(\n        address rewarded,\n        address reward,\n        address recipient,\n        bool forfeitRecentReward\n    ) external virtual override nonReentrant {\n        address msgSender = _msgSender();\n\n        // If the account disables the rewards we pass an account balance of zero to not accrue any.\n        AccountStorage storage accountStorage = accounts[msgSender][rewarded];\n        uint256 currentAccountBalance = accountStorage.enabledRewards.contains(reward) ? accountStorage.balance : 0;\n\n        updateRewardInternal(\n            distributions[rewarded][reward],\n            accountStorage.earned[reward],\n            rewarded,\n            reward,\n            currentAccountBalance,\n            forfeitRecentReward\n        );\n\n        claim(msgSender, rewarded, reward, recipient);\n    }\n\n    /// @notice Claims spillover rewards.\n    /// @dev Rewards are only transferred to the recipient if the recipient is non-zero.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @param recipient The address to receive the claimed reward tokens.\n    function claimSpilloverReward(\n        address rewarded,\n        address reward,\n        address recipient\n    ) external virtual override nonReentrant {\n        claim(address(0), rewarded, reward, recipient);\n    }\n\n    /// @notice Enable reward token.\n    /// @dev There can be at most MAX_REWARDS_ENABLED rewards enabled for the reward token and the account.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    function enableReward(address rewarded, address reward) external virtual override {\n        address msgSender = _msgSender();\n        AccountStorage storage accountStorage = accounts[msgSender][rewarded];\n        SetStorage storage accountEnabledRewards = accountStorage.enabledRewards;\n\n        if (accountEnabledRewards.insert(reward)) {\n            if (accountEnabledRewards.numElements > MAX_REWARDS_ENABLED) {\n                revert TooManyRewardsEnabled();\n            }\n\n            DistributionStorage storage distributionStorage = distributions[rewarded][reward];\n            uint256 currentAccountBalance = accountStorage.balance;\n\n            // We pass zero as `currentAccountBalance` to not distribute rewards for the period before the account\n            // enabled them.\n            updateRewardInternal(distributionStorage, accountStorage.earned[reward], rewarded, reward, 0, false);\n\n            distributionStorage.totalEligible += currentAccountBalance;\n\n            emit RewardEnabled(msgSender, rewarded, reward);\n        }\n    }\n\n    /// @notice Disable reward token.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @param forfeitRecentReward Whether to forfeit the recent rewards and not update the accumulator.\n    function disableReward(address rewarded, address reward, bool forfeitRecentReward) external virtual override {\n        address msgSender = _msgSender();\n        AccountStorage storage accountStorage = accounts[msgSender][rewarded];\n\n        if (accountStorage.enabledRewards.remove(reward)) {\n            DistributionStorage storage distributionStorage = distributions[rewarded][reward];\n            uint256 currentAccountBalance = accountStorage.balance;\n\n            updateRewardInternal(\n                distributionStorage,\n                accountStorage.earned[reward],\n                rewarded,\n                reward,\n                currentAccountBalance,\n                forfeitRecentReward\n            );\n\n            distributionStorage.totalEligible -= currentAccountBalance;\n\n            emit RewardDisabled(msgSender, rewarded, reward);\n        }\n    }\n\n    /// @notice Returns the earned reward token amount for a specific account and rewarded token.\n    /// @param account The address of the account.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @param forfeitRecentReward Whether to forfeit the recent rewards and not update the accumulator.\n    /// @return The earned reward token amount for the account and rewarded token.\n    function earnedReward(\n        address account,\n        address rewarded,\n        address reward,\n        bool forfeitRecentReward\n    ) external view virtual override returns (uint256) {\n        // If the account disables the rewards we pass an account balance of zero to not accrue any.\n        AccountStorage storage accountStorage = accounts[account][rewarded];\n        uint256 currentAccountBalance = accountStorage.enabledRewards.contains(reward) ? accountStorage.balance : 0;\n\n        (,, uint96 claimable, uint96 deltaAccountZero) = calculateRewards(\n            distributions[rewarded][reward], accountStorage.earned[reward], currentAccountBalance, forfeitRecentReward\n        );\n\n        // If we have spillover rewards, we add them to `address(0)`.\n        if (account == address(0) && deltaAccountZero != 0) {\n            return claimable + deltaAccountZero;\n        }\n\n        return claimable;\n    }\n\n    /// @notice Returns enabled reward tokens for a specific account.\n    /// @param account The address of the account.\n    /// @param rewarded The address of the rewarded token.\n    /// @return An array of addresses representing the enabled reward tokens.\n    function enabledRewards(\n        address account,\n        address rewarded\n    ) external view virtual override returns (address[] memory) {\n        return accounts[account][rewarded].enabledRewards.get();\n    }\n\n    /// @notice Returns the rewarded token balance of a specific account.\n    /// @param account The address of the account.\n    /// @param rewarded The address of the rewarded token.\n    /// @return The rewarded token balance of the account.\n    function balanceOf(address account, address rewarded) external view virtual override returns (uint256) {\n        return accounts[account][rewarded].balance;\n    }\n\n    /// @notice Returns the reward token amount for a specific rewarded token and current epoch.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @return The reward token amount for the rewarded token and current epoch.\n    function rewardAmount(address rewarded, address reward) external view virtual override returns (uint256) {\n        return rewardAmount(rewarded, reward, currentEpoch());\n    }\n\n    /// @notice Returns the total supply of the rewarded token enabled and eligible to receive the reward token.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @return The total supply of the rewarded token enabled and eligible to receive the reward token.\n    function totalRewardedEligible(address rewarded, address reward) external view virtual override returns (uint256) {\n        return distributions[rewarded][reward].totalEligible;\n    }\n\n    /// @notice Returns the total reward token amount registered to be distributed for a specific rewarded token.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @return The total reward token amount distributed for the rewarded token.\n    function totalRewardRegistered(address rewarded, address reward) external view returns (uint256) {\n        return distributions[rewarded][reward].totalRegistered;\n    }\n\n    /// @notice Returns the total reward token amount claimed for a specific rewarded token.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @return The total reward token amount claimed for the rewarded token.\n    function totalRewardClaimed(address rewarded, address reward) external view returns (uint256) {\n        return distributions[rewarded][reward].totalClaimed;\n    }\n\n    /// @notice Returns the reward token amount for a specific rewarded token and epoch.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @param epoch The epoch to get the reward token amount for.\n    /// @return The reward token amount for the rewarded token and epoch.\n    function rewardAmount(\n        address rewarded,\n        address reward,\n        uint48 epoch\n    ) public view virtual override returns (uint256) {\n        return rewardAmount(distributions[rewarded][reward], epoch);\n    }\n\n    /// @notice Returns the current epoch based on the block timestamp.\n    /// @return The current epoch.\n    function currentEpoch() public view override returns (uint48) {\n        return getEpoch(uint48(block.timestamp));\n    }\n\n    /// @notice Returns the epoch for a given timestamp.\n    /// @param timestamp The timestamp to get the epoch for.\n    /// @return The epoch for the given timestamp.\n    function getEpoch(uint48 timestamp) public view override returns (uint48) {\n        return uint48(timestamp / EPOCH_DURATION);\n    }\n\n    /// @notice Returns the start timestamp for a given epoch.\n    /// @param epoch The epoch to get the start timestamp for.\n    /// @return The start timestamp for the given epoch.\n    function getEpochStartTimestamp(uint48 epoch) public view override returns (uint48) {\n        return uint48(epoch * EPOCH_DURATION);\n    }\n\n    /// @notice Returns the end timestamp for a given epoch.\n    /// @dev The end timestamp is just after its epoch, and is the same as the start timestamp from the next epoch.\n    /// @param epoch The epoch to get the end timestamp for.\n    /// @return The end timestamp for the given epoch.\n    function getEpochEndTimestamp(uint48 epoch) public view override returns (uint48) {\n        return uint48(getEpochStartTimestamp(epoch) + EPOCH_DURATION);\n    }\n\n    /// @notice Transfers a specified amount of a token from a given address to this contract.\n    /// @dev This function uses `SafeERC20.safeTransferFrom` function to move tokens.\n    /// It checks the balance before and after the transfer to ensure the correct amount has been transferred.\n    /// If the transferred amount does not match the expected amount, it reverts.\n    /// @param token The ERC20 token to transfer.\n    /// @param from The address to transfer the tokens from.\n    /// @param amount The amount of tokens to transfer.\n    function pullToken(IERC20 token, address from, uint256 amount) internal {\n        uint256 preBalance = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n\n        if (token.balanceOf(address(this)) - preBalance != amount) {\n            revert InvalidAmount();\n        }\n    }\n\n    /// @notice Transfers a specified amount of a token to a given address.\n    /// @dev This function uses `IERC20.safeTransfer` to move tokens.\n    /// @dev This function reverts if the recipient is zero address or is a known non-owner EVC account.\n    /// @param token The ERC20 token to transfer.\n    /// @param to The address to transfer the tokens to.\n    /// @param amount The amount of tokens to transfer.\n    function pushToken(IERC20 token, address to, uint256 amount) internal {\n        address owner = evc.getAccountOwner(to);\n\n        if (to == address(0) || (owner != address(0) && owner != to)) {\n            revert InvalidRecipient();\n        }\n\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /// @notice Returns the reward token amount for an epoch, given a pre-computed distribution storage pointer.\n    /// @param distributionStorage Pre-computed distribution storage pointer.\n    /// @param epoch The epoch to get the reward token amount for.\n    /// @return The reward token amount.\n    function rewardAmount(\n        DistributionStorage storage distributionStorage,\n        uint48 epoch\n    ) internal view returns (uint256) {\n        return distributionStorage.amounts[epoch / EPOCHS_PER_SLOT][epoch % EPOCHS_PER_SLOT];\n    }\n\n    /// @notice Increases the reward token amounts for a specific rewarded token.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @param startEpoch The starting epoch to increase the reward token amount for.\n    /// @param amounts The token amounts to increase by.\n    function increaseRewardAmounts(\n        address rewarded,\n        address reward,\n        uint48 startEpoch,\n        uint128[] memory amounts\n    ) internal virtual {\n        mapping(uint256 => uint128[EPOCHS_PER_SLOT]) storage storageAmounts = distributions[rewarded][reward].amounts;\n\n        for (uint48 i = 0; i < amounts.length; ++i) {\n            // Overflow safe because `totalRegistered <= type(uint160).max / SCALER < type(uint128).max`.\n            unchecked {\n                uint48 epoch = startEpoch + i;\n                storageAmounts[epoch / EPOCHS_PER_SLOT][epoch % EPOCHS_PER_SLOT] += amounts[i];\n            }\n        }\n    }\n\n    /// @notice Claims the earned reward for a specific account, rewarded token, and reward token, and transfers it to\n    /// the recipient.\n    /// @dev This function reverts if the recipient is zero address or is a known non-owner EVC account.\n    /// @dev If there is no reward to claim, this function does nothing.\n    /// @param account The address of the account claiming the reward.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @param recipient The address to which the claimed reward will be transferred.\n    function claim(address account, address rewarded, address reward, address recipient) internal virtual {\n        EarnStorage storage accountEarned = accounts[account][rewarded].earned[reward];\n        uint128 amount = accountEarned.claimable;\n\n        // If there is a reward token to claim, transfer it to the recipient and emit an event.\n        if (amount != 0) {\n            DistributionStorage storage distributionStorage = distributions[rewarded][reward];\n            uint128 totalRegistered = distributionStorage.totalRegistered;\n            uint128 totalClaimed = distributionStorage.totalClaimed;\n            uint128 newTotalClaimed = totalClaimed + amount;\n\n            assert(totalRegistered >= newTotalClaimed);\n\n            distributionStorage.totalClaimed = newTotalClaimed;\n            accountEarned.claimable = 0;\n\n            pushToken(IERC20(reward), recipient, amount);\n            emit RewardClaimed(account, rewarded, reward, amount);\n        }\n    }\n\n    /// @notice Updates the data for a specific account, rewarded token and reward token.\n    /// @dev If required, this function artificially accumulates rewards for the address(0) to avoid loss of rewards\n    /// that wouldn't be claimable by anyone else.\n    /// @dev This function does not update total eligible amount or account balances.\n    /// @param distributionStorage Pointer to the storage of the distribution.\n    /// @param accountEarnStorage Pointer to the storage of the account's earned amount and accumulator.\n    /// @param rewarded The address of the rewarded token.\n    /// @param reward The address of the reward token.\n    /// @param currentAccountBalance The current rewarded token balance of the account.\n    /// @param forfeitRecentReward Whether to forfeit the recent rewards and not update the accumulator.\n    function updateRewardInternal(\n        DistributionStorage storage distributionStorage,\n        EarnStorage storage accountEarnStorage,\n        address rewarded,\n        address reward,\n        uint256 currentAccountBalance,\n        bool forfeitRecentReward\n    ) internal virtual {\n        (uint48 lastUpdated, uint208 accumulator, uint96 claimable, uint96 deltaAccountZero) =\n            calculateRewards(distributionStorage, accountEarnStorage, currentAccountBalance, forfeitRecentReward);\n\n        // Update the distribution data.\n        distributionStorage.lastUpdated = lastUpdated;\n        distributionStorage.accumulator = accumulator;\n\n        // Update the account's earned amount. Snapshot new accumulator value for the account.\n        // Downcasting is safe because the `totalRegistered <= type(uint160).max / SCALER`.\n        accountEarnStorage.claimable = claimable;\n        accountEarnStorage.accumulator = uint160(accumulator);\n\n        // If there were excess rewards, allocate them to address(0).\n        // Overflow safe because `totalRegistered <= type(uint160).max / SCALER < type(uint96).max`.\n        if (deltaAccountZero != 0) {\n            unchecked {\n                accounts[address(0)][rewarded].earned[reward].claimable += deltaAccountZero;\n            }\n        }\n    }\n\n    /// @notice Computes updated data for a specific account, rewarded token, and reward token.\n    /// @param distributionStorage Pointer to the storage of the distribution.\n    /// @param accountEarnStorage Pointer to the storage of the account's earned amount and accumulator.\n    /// @param currentAccountBalance The current rewarded token balance of the account.\n    /// @param forfeitRecentReward Whether to forfeit the recent rewards and not update the accumulator.\n    /// @return lastUpdated The next value for the last update timestamp.\n    /// @return accumulator The next value for the distribution accumulator.\n    /// @return claimable The next value for the account's claimable amount.\n    /// @return deltaAccountZero Amount to be credited to `address(0)` in case rewards were to be lost.\n    function calculateRewards(\n        DistributionStorage storage distributionStorage,\n        EarnStorage storage accountEarnStorage,\n        uint256 currentAccountBalance,\n        bool forfeitRecentReward\n    )\n        internal\n        view\n        virtual\n        returns (uint48 lastUpdated, uint208 accumulator, uint96 claimable, uint96 deltaAccountZero)\n    {\n        // If the distribution is not initialized, return.\n        lastUpdated = distributionStorage.lastUpdated;\n        accumulator = distributionStorage.accumulator;\n        claimable = accountEarnStorage.claimable;\n\n        if (lastUpdated == 0) {\n            return (lastUpdated, accumulator, claimable, 0);\n        }\n\n        if (!forfeitRecentReward) {\n            // Get the start and end epochs based on the last updated timestamp of the distribution.\n            uint48 epochStart = getEpoch(lastUpdated);\n            uint48 epochEnd = currentEpoch() + 1;\n            uint256 delta;\n\n            // Calculate the amount of tokens since the last update that should be distributed.\n            for (uint48 epoch = epochStart; epoch < epochEnd; ++epoch) {\n                // Overflow safe because `totalRegistered * SCALER <= type(uint160).max < type(uint256).max`.\n                unchecked {\n                    uint256 amount = rewardAmount(distributionStorage, epoch);\n                    delta += SCALER * timeElapsedInEpoch(epoch, lastUpdated) * amount / EPOCH_DURATION;\n                }\n            }\n\n            // Increase the accumulator scaled by the total eligible amount earning reward. In case nobody earns\n            // rewards, allocate them to address(0). Otherwise, some portion of the rewards might get lost.\n            uint256 currentTotalEligible = distributionStorage.totalEligible;\n            if (currentTotalEligible == 0) {\n                // Downcasting is safe because the `totalRegistered <= type(uint160).max / SCALER < type(uint96).max`.\n                deltaAccountZero = uint96(delta / SCALER);\n            } else {\n                // Overflow safe because `totalRegistered <= type(uint160).max / SCALER`.\n                unchecked {\n                    accumulator += uint160(delta / currentTotalEligible);\n                }\n            }\n\n            // Snapshot the timestamp.\n            lastUpdated = uint48(block.timestamp);\n        }\n\n        // Update the account's earned amount.\n        // Downcasting is safe because the `totalRegistered <= type(uint160).max / SCALER < type(uint96).max`.\n        claimable += uint96(uint256(accumulator - accountEarnStorage.accumulator) * currentAccountBalance / SCALER);\n    }\n\n    /// @notice Calculates the time elapsed within a given epoch.\n    /// @dev This function compares the current block timestamp with the start and end timestamps of the epoch.\n    /// @dev If the epoch is ongoing, it calculates the time elapsed since the last update or the start of the epoch,\n    /// whichever is smaller.\n    /// @dev If the epoch has ended and there was an update since its start, it calculates the time elapsed since the\n    /// last update to the end of the epoch.\n    /// @dev If the epoch has ended and there wasn't an update since its start, it returns the epoch duration.\n    /// @dev If the epoch hasn't started, then there can't be a later update yet, and we return zero.\n    /// @param epoch The epoch for which to calculate the time elapsed.\n    /// @param lastUpdated The timestamp of the last update.\n    /// @return The time elapsed in the given epoch.\n    function timeElapsedInEpoch(uint48 epoch, uint48 lastUpdated) internal view returns (uint256) {\n        // Get the start and end timestamps for the given epoch.\n        uint256 startTimestamp = getEpochStartTimestamp(epoch);\n        uint256 endTimestamp = getEpochEndTimestamp(epoch);\n\n        // Calculate the time elapsed in the given epoch.\n        if (block.timestamp >= endTimestamp) {\n            // The epoch has ended.\n            // If the last update was in or after the given epoch, return the time elapsed between the last update to\n            // the end of the given epoch. If the last update was before the start of the given epoch, return the epoch\n            // duration.\n            return lastUpdated > startTimestamp ? endTimestamp - lastUpdated : EPOCH_DURATION;\n        } else if (block.timestamp >= startTimestamp && block.timestamp < endTimestamp) {\n            // The epoch is ongoing.\n            // If the last update was in or after the given epoch, return the time elapsed since the last update.\n            // Otherwise return the time elapsed from the start of the given epoch.\n            return lastUpdated > startTimestamp ? block.timestamp - lastUpdated : block.timestamp - startTimestamp;\n        } else {\n            // The epoch hasn't started yet.\n            return 0;\n        }\n    }\n}"
    }
  ]
}