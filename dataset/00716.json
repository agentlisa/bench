{
  "Title": "M-2: High risk checks can be bypassed with extra `calldata` padding",
  "Content": "# Issue M-2: High risk checks can be bypassed with extra `calldata` padding \n\nSource: https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance-judging/issues/100 \n\n## Found by \nIllIllI, Kow, cawfree, fibonacci, haxatron, r0ck3tz\n## Summary\n\nAdding extra unused bytes to proposal calldata can trick the `_isHighRiskProposal()` function\n\n\n## Vulnerability Detail\n\nThe length checks on the transaction calldata of what falls into the 'high risk' proposal category is too strict, and incorrectly fails with extra padding. In solidity, any extra bytes of `calldata`, beyond what is required to satisfy the function arguments, are ignored, and have no effect on the operation of the function being called.\n\n\n## Impact\n\nA proposal that should have been flagged as high risk, is not, and therefore can be passed with the easier, lower, quorum. This violates a critical [invariant](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/tree/main/bophades/audit/2024-01_governance#proposal-quorum-threshold).\n\n\n## Code Snippet\n\nChecks for calls to the kernel's `executeAction()` function, expect exactly the right number of bytes to satisfy the function arguments, and no more:\n```solidity\n// File: src/external/governance/GovernorBravoDelegate.sol : GovernorBravoDelegate._isHighRiskProposal()   #1\n\n631                    // Check if the action is making a core change to system via the kernel\n632                    if (selector == Kernel.executeAction.selector) {\n633                        uint8 action;\n634                        address actionTarget;\n635    \n636 @>                     if (bytes(signature).length == 0 && data.length == 0x44) {\n637                            assembly {\n638                                action := mload(add(data, 0x24)) // accounting for length and selector in first 4 bytes\n639                                actionTarget := mload(add(data, 0x44))\n640                            }\n641 @>                     } else if (data.length == 0x40) {\n642                            (action, actionTarget) = abi.decode(data, (uint8, address));\n643                        } else {\n644                            continue;\n645:                       }\n```\nhttps://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L631-L645\n\nthis results in an easier quorum threshold:\n```solidity\n// File: src/external/governance/GovernorBravoDelegate.sol : GovernorBravoDelegate.propose()   #2\n\n168                // Identify the quorum level to use\n169 @>             if (_isHighRiskProposal(targets, signatures, calldatas)) {\n170                    quorumVotes = getHighRiskQuorumVotes();\n171                } else {\n172 @>                 quorumVotes = getQuorumVotes();\n173:               }\n```\nhttps://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L168-L173\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nChange length checks to be `>=`, rather than strict equality, since the function signature already specifies the number of arguments\n\n\n## PoC\n\nThe following test shows that extending the calldata by an empty byte still triggers a valid call to `executeAction()`, but is categorized as lower severity:\n```diff\ndiff --git a/bophades/src/test/external/GovernorBravoDelegate.t.sol b/bophades/src/test/external/GovernorBravoDelegate.t.sol\nindex 778163c..bdb6ae2 100644\n--- a/bophades/src/test/external/GovernorBravoDelegate.t.sol\n+++ b/bophades/src/test/external/GovernorBravoDelegate.t.sol\n@@ -386,6 +386,10 @@ contract GovernorBravoDelegateTest is Test {\n         assertEq(quorum, 200_000e18);\n     }\n \n+    function executeAction(Actions action_, address target_) external {\n+        console2.log(\"executed with extra calldata\");\n+    }\n+\n     function testCorrectness_proposeCapturesCorrectQuorum_highRisk() public {\n         // Activate TRSRY\n         vm.prank(address(timelock));\n@@ -404,9 +408,12 @@ contract GovernorBravoDelegateTest is Test {\n         calldatas[0] = abi.encodeWithSelector(\n             kernel.executeAction.selector,\n             Actions.ActivatePolicy,\n-            address(custodian)\n+            address(custodian),\n+            \"\"\n         );\n \n+        address(this).call(calldatas[0]);\n+\n         vm.prank(alice);\n         bytes memory data = address(governorBravoDelegator).functionCall(\n             abi.encodeWithSignature(\n```\n\nOutput:\n```text\n% forge test --match-test testCorrectness_proposeCapturesCorrectQuorum_highRisk -vv\n...\n[FAIL. Reason: assertion failed] testCorrectness_proposeCapturesCorrectQuorum_highRisk() (gas: 568208)\nLogs:\n  executed with extra calldata\n  Error: a == b not satisfied [uint]\n    Expected: 300000000000000000000000\n      Actual: 200000000000000000000000\n\nTest result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 14.92ms\n...\n```\n\n\n\n## Discussion\n\n**0xLienid**\n\nValid, will fix by reverting if the calldata doesn't match the right size since we know what the size must be for an `executeAction` call\n\n**0xLienid**\n\nFix: https://github.com/OlympusDAO/bophades/pull/299\n\n**IllIllI000**\n\nThe [PR](https://github.com/OlympusDAO/bophades/pull/299) introduces a new revert error, and reverts if the length is longer than expected, rather than allowing the code to continue if the calldata is longer than expected. Since the selector ensures that the right number of arguments is passed, there is no error in restricting possible future uses of extra calldata. The PR also adds a test.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/155",
  "Code": [
    {
      "filename": "bophades/src/external/governance/GovernorBravoDelegate.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.15;\n\nimport {IgOHM} from \"src/interfaces/IgOHM.sol\";\nimport {ITimelock} from \"./interfaces/ITimelock.sol\";\nimport {IGovernorBravoEventsAndErrors} from \"./interfaces/IGovernorBravoEvents.sol\";\n\nimport {GovernorBravoDelegateStorageV2} from \"./abstracts/GovernorBravoStorage.sol\";\n\nimport \"src/Kernel.sol\";\n\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV2, IGovernorBravoEventsAndErrors {\n    // --- CONSTANTS ---------------------------------------------------------------\n\n    /// @notice The name of this contract\n    string public constant name = \"Olympus Governor Bravo\";\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_PCT = 1_000; // 1% (out of 100_000)\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_PCT = 90_000; // 90% (out of 100_000)\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 21600; // About 3 days (12s block time)\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 100800; // About 2 weeks (12s block time)\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 21600; // About 3 days (12s block time)\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 50400; // About 1 week (12s block time)\n\n    /// @notice The percentage of total supply in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\n    ///         a percentage of total supply, rather than a fixed number of tokens.\n    uint256 public constant quorumPct = 20_000; // 20% (out of 100_000)\n\n    /// @notice The percentage of total supply in support of a proposal related to a high risk module in the Default system required\n    ///         in order for a quorum to be reached and for a vote to succeed\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\n    ///         a percentage of total supply, rather than a fixed number of tokens.\n    uint256 public constant highRiskQuorum = 30_000; // 30% (out of 100_000)\n\n    /// @notice The percentage of votes that must be in favor of a proposal for it to succeed\n    uint256 public constant approvalThresholdPct = 55_000; // 55% (out of 100_000)\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The central hub of the Default Framework system that manages modules and policies\n    /// @dev    Used in this adaptation of Governor Bravo to identify high risk proposals\n    address public kernel;\n\n    /// @notice Modules in the Default system that are considered high risk\n    /// @dev    In Default Framework, Keycodes are used to uniquely identify modules. They are a\n    ///         wrapper over the bytes5 data type, and allow us to easily check if a proposal is\n    ///         touching any specific modules\n    mapping(Keycode => bool) public isKeycodeHighRisk;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    // --- INITIALIZE --------------------------------------------------------------\n\n    /**\n     * @notice Used to initialize the contract during delegator constructor\n     * @param timelock_ The address of the Timelock\n     * @param gohm_ The address of the gOHM token\n     * @param kernel_ The address of the kernel\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThreshold_ The initial proposal threshold (percentage of total supply. out of 1000)\n     */\n    function initialize(\n        address timelock_,\n        address gohm_,\n        address kernel_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThreshold_\n    ) public virtual {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (address(timelock) != address(0)) revert GovernorBravo_AlreadyInitialized();\n        if (timelock_ == address(0) || gohm_ == address(0) || kernel_ == address(0))\n            revert GovernorBravo_AddressZero();\n        if (votingPeriod_ < MIN_VOTING_PERIOD || votingPeriod_ > MAX_VOTING_PERIOD)\n            revert GovernorBravo_InvalidPeriod();\n        if (votingDelay_ < MIN_VOTING_DELAY || votingDelay_ > MAX_VOTING_DELAY)\n            revert GovernorBravo_InvalidDelay();\n        if (\n            proposalThreshold_ < MIN_PROPOSAL_THRESHOLD_PCT ||\n            proposalThreshold_ > MAX_PROPOSAL_THRESHOLD_PCT\n        ) revert GovernorBravo_InvalidThreshold();\n\n        // Set up contract dependencies\n        timelock = ITimelock(timelock_);\n        gohm = IgOHM(gohm_);\n        kernel = kernel_;\n\n        // Configure voting parameters\n        vetoGuardian = msg.sender;\n        votingDelay = votingDelay_;\n        votingPeriod = votingPeriod_;\n        proposalThreshold = proposalThreshold_;\n        isKeycodeHighRisk[toKeycode(bytes5(\"TRSRY\"))] = true;\n        isKeycodeHighRisk[toKeycode(bytes5(\"MINTR\"))] = true;\n    }\n\n    // --- GOVERNANCE LOGIC --------------------------------------------------------\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Allow addresses above proposal threshold and whitelisted addresses to propose\n        if (\n            gohm.getPriorVotes(msg.sender, block.number - 1) <= getProposalThresholdVotes() &&\n            !isWhitelisted(msg.sender)\n        ) revert GovernorBravo_Proposal_ThresholdNotMet();\n        if (\n            targets.length != values.length ||\n            targets.length != signatures.length ||\n            targets.length != calldatas.length\n        ) revert GovernorBravo_Proposal_LengthMismatch();\n        if (targets.length == 0) revert GovernorBravo_Proposal_NoActions();\n        if (targets.length > proposalMaxOperations) revert GovernorBravo_Proposal_TooManyActions();\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            if (proposersLatestProposalState == ProposalState.Active)\n                revert GovernorBravo_Proposal_AlreadyActive();\n            if (proposersLatestProposalState == ProposalState.Pending)\n                revert GovernorBravo_Proposal_AlreadyPending();\n        }\n\n        uint256 startBlock = block.number + votingDelay;\n        uint256 endBlock = startBlock + votingPeriod;\n\n        proposalCount++;\n        uint256 newProposalID = proposalCount;\n\n        {\n            // Given Olympus's dynamic supply, we need to capture quorum and proposal thresholds in terms\n            // of the total supply at the time of proposal creation.\n            uint256 quorumVotes;\n            uint256 proposalThresholdVotes = getProposalThresholdVotes();\n\n            // Identify the quorum level to use\n            if (_isHighRiskProposal(targets, signatures, calldatas)) {\n                quorumVotes = getHighRiskQuorumVotes();\n            } else {\n                quorumVotes = getQuorumVotes();\n            }\n\n            Proposal storage newProposal = proposals[newProposalID];\n            // This should never happen but add a check in case.\n            if (newProposal.id != 0) revert GovernorBravo_Proposal_IdCollision();\n\n            newProposal.id = newProposalID;\n            newProposal.proposer = msg.sender;\n            newProposal.proposalThreshold = proposalThresholdVotes;\n            newProposal.quorumVotes = quorumVotes;\n            newProposal.targets = targets;\n            newProposal.values = values;\n            newProposal.signatures = signatures;\n            newProposal.calldatas = calldatas;\n            newProposal.startBlock = startBlock;\n            newProposal.endBlock = endBlock;\n\n            latestProposalIds[newProposal.proposer] = newProposal.id;\n        }\n\n        emit ProposalCreated(\n            newProposalID,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n        return newProposalID;\n    }\n\n    /**\n     * @notice Queues a successful proposal\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        if (state(proposalId) != ProposalState.Succeeded)\n            revert GovernorBravo_Queue_FailedProposal();\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n\n        // Check that proposer has not fallen below proposal threshold since proposal creation\n        // If proposer is whitelisted, they can queue regardless of threshold\n        if (\n            !isWhitelisted(proposal.proposer) &&\n            gohm.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold\n        ) revert GovernorBravo_Queue_BelowThreshold();\n\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function _queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        if (timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))))\n            revert GovernorBravo_Queue_AlreadyQueued();\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external payable {\n        if (state(proposalId) != ProposalState.Queued) revert GovernorBravo_Execute_NotQueued();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Check that proposer has not fallen below proposal threshold since proposal creation\n        // If proposer is whitelisted, they can execute regardless of threshold\n        if (\n            !isWhitelisted(proposal.proposer) &&\n            gohm.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold\n        ) revert GovernorBravo_Execute_BelowThreshold();\n\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        if (state(proposalId) == ProposalState.Executed)\n            revert GovernorBravo_Cancel_AlreadyExecuted();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Proposer can cancel\n        if (msg.sender != proposal.proposer) {\n            // Whitelisted proposers can't be canceled for falling below proposal threshold\n            if (isWhitelisted(proposal.proposer)) {\n                if (\n                    (gohm.getPriorVotes(proposal.proposer, block.number - 1) >=\n                        proposal.proposalThreshold) || msg.sender != whitelistGuardian\n                ) revert GovernorBravo_Cancel_WhitelistedProposer();\n            } else {\n                if (\n                    gohm.getPriorVotes(proposal.proposer, block.number - 1) >=\n                    proposal.proposalThreshold\n                ) revert GovernorBravo_Cancel_AboveThreshold();\n            }\n        }\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the veto guardian\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        if (msg.sender != vetoGuardian) revert GovernorBravo_OnlyVetoGuardian();\n        if (state(proposalId) == ProposalState.Executed)\n            revert GovernorBravo_Veto_AlreadyExecuted();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i; i < proposal.targets.length; ) {\n            // If the proposal has been queued, cancel on the timelock\n            if (\n                timelock.queuedTransactions(\n                    keccak256(\n                        abi.encode(\n                            proposal.targets[i],\n                            proposal.values[i],\n                            proposal.signatures[i],\n                            proposal.calldatas[i],\n                            proposal.eta\n                        )\n                    )\n                )\n            ) {\n                timelock.cancelTransaction(\n                    proposal.targets[i],\n                    proposal.values[i],\n                    proposal.signatures[i],\n                    proposal.calldatas[i],\n                    proposal.eta\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(\n            msg.sender,\n            proposalId,\n            support,\n            castVoteInternal(msg.sender, proposalId, support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(\n            msg.sender,\n            proposalId,\n            support,\n            castVoteInternal(msg.sender, proposalId, support),\n            reason\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        if (signatory == address(0)) revert GovernorBravo_InvalidSignature();\n        emit VoteCast(\n            signatory,\n            proposalId,\n            support,\n            castVoteInternal(signatory, proposalId, support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint256) {\n        if (state(proposalId) != ProposalState.Active) revert GovernorBravo_Vote_Closed();\n        if (support > 2) revert GovernorBravo_Vote_InvalidType();\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        if (receipt.hasVoted) revert GovernorBravo_Vote_AlreadyCast();\n\n        // Get the user's votes at the start of the proposal and at the time of voting. Take the minimum.\n        uint256 originalVotes = gohm.getPriorVotes(voter, proposal.startBlock);\n        uint256 currentVotes = gohm.getPriorVotes(voter, block.number);\n        uint256 votes = currentVotes > originalVotes ? originalVotes : currentVotes;\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    // --- ADMIN FUNCTIONS ---------------------------------------------------------\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (newVotingDelay < MIN_VOTING_DELAY || newVotingDelay > MAX_VOTING_DELAY)\n            revert GovernorBravo_InvalidDelay();\n\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (newVotingPeriod < MIN_VOTING_PERIOD || newVotingPeriod > MAX_VOTING_PERIOD)\n            revert GovernorBravo_InvalidPeriod();\n\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold\n     * @dev newProposalThreshold must be greater than the hardcoded min\n     * @param newProposalThreshold new proposal threshold\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (\n            newProposalThreshold < MIN_PROPOSAL_THRESHOLD_PCT ||\n            newProposalThreshold > MAX_PROPOSAL_THRESHOLD_PCT\n        ) revert GovernorBravo_InvalidThreshold();\n\n        uint256 oldProposalThreshold = proposalThreshold;\n        proposalThreshold = newProposalThreshold;\n\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelist expiration as a timestamp for an account. Whitelist status allows accounts to propose without meeting threshold\n     * @param account Account address to set whitelist expiration for\n     * @param expiration Expiration for account whitelist status as timestamp (if now < expiration, whitelisted)\n     */\n    function _setWhitelistAccountExpiration(address account, uint256 expiration) external {\n        if (msg.sender != admin && msg.sender != whitelistGuardian)\n            revert GovernorBravo_OnlyAdmin();\n        whitelistAccountExpirations[account] = expiration;\n\n        emit WhitelistAccountExpirationSet(account, expiration);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelistGuardian. WhitelistGuardian can cancel proposals from whitelisted addresses\n     * @param account Account to set whitelistGuardian to (0x0 to remove whitelistGuardian)\n     */\n    function _setWhitelistGuardian(address account) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        address oldGuardian = whitelistGuardian;\n        whitelistGuardian = account;\n\n        emit WhitelistGuardianSet(oldGuardian, whitelistGuardian);\n    }\n\n    /**\n     * @notice Admin function for setting the vetoGuardian. vetoGuardian can veto any proposal\n     * @param account Account to set vetoGuardian to (0x0 to remove vetoGuardian)\n     */\n    function _setVetoGuardian(address account) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        address oldGuardian = vetoGuardian;\n        vetoGuardian = account;\n\n        emit VetoGuardianSet(oldGuardian, vetoGuardian);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin â‰  address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0))\n            revert GovernorBravo_OnlyPendingAdmin();\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    /**\n     * @notice Sets whether a module is considered high risk\n     * @dev Admin function to set whether a module in the Default Framework is considered high risk\n     * @param module_ The module to set the risk of\n     * @param isHighRisk_ If the module is high risk\n     */\n    function _setModuleRiskLevel(bytes5 module_, bool isHighRisk_) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        isKeycodeHighRisk[toKeycode(module_)] = isHighRisk_;\n    }\n\n    // --- HELPER FUNCTIONS: INTERNAL ----------------------------------------------\n\n    /**\n     * @dev Checks if a proposal is high risk by identifying actions where the Default Framework kernel\n     *      is the target, if so, checking if it's installing or deactivating a policy, and if so,\n     *      checking if the policy is touching a high risk module.\n     */\n    function _isHighRiskProposal(\n        address[] memory targets,\n        string[] memory signatures,\n        bytes[] memory calldatas\n    ) internal returns (bool) {\n        // If proposal interacts with the kernel, and is touching a policy that interacts with\n        // a flagged module, then it is high risk.\n        uint256 numActions = targets.length;\n\n        for (uint256 i = 0; i < numActions; i++) {\n            address target = targets[i];\n            string memory signature = signatures[i];\n            bytes memory data = calldatas[i];\n\n            if (target == kernel) {\n                // Get function selector\n                bytes4 selector = bytes(signature).length == 0\n                    ? bytes4(data)\n                    : bytes4(keccak256(bytes(signature)));\n\n                // Check if the action is making a core change to system via the kernel\n                if (selector == Kernel.executeAction.selector) {\n                    uint8 action;\n                    address actionTarget;\n\n                    if (bytes(signature).length == 0 && data.length == 0x44) {\n                        assembly {\n                            action := mload(add(data, 0x24)) // accounting for length and selector in first 4 bytes\n                            actionTarget := mload(add(data, 0x44))\n                        }\n                    } else if (data.length == 0x40) {\n                        (action, actionTarget) = abi.decode(data, (uint8, address));\n                    } else {\n                        continue;\n                    }\n\n                    // If the action is upgrading a module (1)\n                    if (action == 1) {\n                        // Check if the module has a high risk keycode\n                        if (isKeycodeHighRisk[Module(actionTarget).KEYCODE()]) return true;\n                    }\n                    // If the action is installing (2) or deactivating (3) a policy, pull the list of dependencies\n                    else if (action == 2 || action == 3) {\n                        // Call `configureDependencies` on the policy\n                        Keycode[] memory dependencies = Policy(actionTarget)\n                            .configureDependencies();\n\n                        // Iterate over dependencies and looks for high risk keycodes\n                        uint256 numDeps = dependencies.length;\n                        for (uint256 j; j < numDeps; j++) {\n                            Keycode dep = dependencies[j];\n                            if (isKeycodeHighRisk[dep]) return true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // --- GETTER FUNCTIONS: SYSTEM ------------------------------------------------\n\n    /**\n     * @notice View function that gets the chain ID of the current network\n     * @return The chain ID\n     */\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    /**\n     * @notice View function that gets the proposal threshold in number of gOHM based on current supply\n     * @return The proposal threshold in number of gOHM\n     */\n    function getProposalThresholdVotes() public view returns (uint256) {\n        return (gohm.totalSupply() * proposalThreshold) / 100_000;\n    }\n\n    /**\n     * @notice View function that gets the quorum in number of gOHM based on current supply\n     * @return The quorum in number of gOHM\n     */\n    function getQuorumVotes() public view returns (uint256) {\n        return (gohm.totalSupply() * quorumPct) / 100_000;\n    }\n\n    /**\n     * @notice View function that gets the high risk quorum in number of gOHM based on current supply\n     * @return The high risk quorum in number of gOHM\n     */\n    function getHighRiskQuorumVotes() public view returns (uint256) {\n        return (gohm.totalSupply() * highRiskQuorum) / 100_000;\n    }\n\n    /**\n     * @notice View function which returns if an account is whitelisted\n     * @param account Account to check white list status of\n     * @return If the account is whitelisted\n     */\n    function isWhitelisted(address account) public view returns (bool) {\n        return (whitelistAccountExpirations[account] > block.timestamp);\n    }\n\n    // --- GETTER FUNCTIONS: PROPOSAL ----------------------------------------------\n\n    /**\n     * @notice Gets the quorum required for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The quorum required for the given proposal\n     */\n    function getProposalQuorum(uint256 proposalId) external view returns (uint256) {\n        return proposals[proposalId].quorumVotes;\n    }\n\n    /**\n     * @notice Gets the proposer votes threshold required for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The proposer votes threshold required for the given proposal\n     */\n    function getProposalThreshold(uint256 proposalId) external view returns (uint256) {\n        return proposals[proposalId].proposalThreshold;\n    }\n\n    /**\n     * @notice Gets the eta value for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The eta value for the given proposal\n     */\n    function getProposalEta(uint256 proposalId) external view returns (uint256) {\n        return proposals[proposalId].eta;\n    }\n\n    /**\n     * @notice Gets the against, for, and abstain votes for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The against, for, and abstain votes for the given proposal\n     */\n    function getProposalVotes(\n        uint256 proposalId\n    ) external view returns (uint256, uint256, uint256) {\n        Proposal storage p = proposals[proposalId];\n        return (p.againstVotes, p.forVotes, p.abstainVotes);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets of the proposal actions\n     * @return values of the proposal actions\n     * @return signatures of the proposal actions\n     * @return calldatas of the proposal actions\n     */\n    function getActions(\n        uint256 proposalId\n    )\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the voting outcome of the proposal\n     * @param proposalId the id of proposal\n     * @return The voting outcome\n     */\n    function getVoteOutcome(uint256 proposalId) public view returns (bool) {\n        Proposal storage proposal = proposals[proposalId];\n\n        if (proposal.forVotes == 0 && proposal.againstVotes == 0) {\n            return false;\n        } else if (\n            (proposal.forVotes * 100_000) / (proposal.forVotes + proposal.againstVotes) <\n            approvalThresholdPct ||\n            proposal.forVotes < proposal.quorumVotes\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        if (proposalCount"
    }
  ]
}