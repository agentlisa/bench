{
  "Title": "There is no processing of the value returned by the function",
  "Content": "##### Description\nAt the line\nhttps://github.com/lidofinance/lido-dao/blob/ee1991b3bbea2a24b042b0a4433be04301992656/contracts/0.8.9/SelfOwnedStETHBurner.sol#L228\nthe `transfer()` function returns a boolean variable. But this variable is not processed in any way.\nSimilarly for the line:\nhttps://github.com/lidofinance/lido-dao/blob/ee1991b3bbea2a24b042b0a4433be04301992656/contracts/0.8.9/SelfOwnedStETHBurner.sol#L203.\n##### Recommendation\nIt is necessary to add processing of the values returned by the function.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/0.8.9/SelfOwnedStETHBurner.sol",
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-v4.4/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-v4.4/token/ERC721/IERC721.sol\";\nimport \"./interfaces/IBeaconReportReceiver.sol\";\n\n/**\n  * @title Interface defining a Lido liquid staking pool\n  * @dev see also [Lido liquid staking pool core contract](https://docs.lido.fi/contracts/lido)\n  */\ninterface ILido {\n    /**\n      * @notice Destroys given amount of shares from account's holdings\n      * @param _account address of the shares holder\n      * @param _sharesAmount shares amount to burn\n      * @dev incurs stETH token rebase by decreasing the total amount of shares.\n      */\n    function burnShares(address _account, uint256 _sharesAmount) external returns (uint256 newTotalShares);\n\n    /**\n      * @notice Gets authorized oracle address\n      * @return address of oracle contract.\n      */\n    function getOracle() external view returns (address);\n\n    /**\n      * @notice Get stETH amount by the provided shares amount\n      * @param _sharesAmount shares amount\n      * @dev dual to `getSharesByPooledEth`.\n      */\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n\n    /**\n      * @notice Get shares amount by the provided stETH amount\n      * @param _pooledEthAmount stETH amount\n      * @dev dual to `getPooledEthByShares`.\n      */\n    function getSharesByPooledEth(uint256 _pooledEthAmount) external view returns (uint256);\n\n    /**\n      * @notice Get shares amount of the provided account\n      * @param _account provided account address.\n      */\n    function sharesOf(address _account) external view returns (uint256);\n}\n\n/**\n  * @title Interface for the Lido Beacon Chain Oracle\n  */\ninterface IOracle {\n    /**\n     * @notice Gets currently set beacon report receiver\n     * @return address of a beacon receiver\n     */\n    function getBeaconReportReceiver() external view returns (address);\n}\n\n/**\n  * @title A dedicated contract for enacting stETH burning requests\n  * @notice See the Lido improvement proposal #6 (LIP-6) spec.\n  * @author Eugene Mamin <TheDZhon@gmail.com>\n  *\n  * @dev Burning stETH means 'decrease total underlying shares amount to perform stETH token rebase'\n  */\ncontract SelfOwnedStETHBurner is IBeaconReportReceiver {\n    uint256 private coverSharesBurnRequested;\n    uint256 private nonCoverSharesBurnRequested;\n\n    uint256 private totalCoverSharesBurnt;\n    uint256 private totalNonCoverSharesBurnt;\n\n    address public immutable LIDO;\n    address public immutable TREASURY;\n    address public immutable VOTING;\n\n    /**\n      * Emitted when a new stETH burning request is added by the `requestedBy` address.\n      */\n    event StETHBurnRequested(\n        bool indexed isCover,\n        address indexed requestedBy,\n        uint256 amount,\n        uint256 sharesAmount\n    );\n\n    /**\n      * Emitted when the stETH `amount` (corresponding to `sharesAmount` shares) burnt for the `isCover` reason.\n      */\n    event StETHBurnt(\n        bool indexed isCover,\n        uint256 amount,\n        uint256 sharesAmount\n    );\n\n    /**\n      * Emitted when the excessive stETH `amount` (corresponding to `sharesAmount` shares) recovered (e.g. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ExcessStETHRecovered(\n        address indexed requestedBy,\n        uint256 amount,\n        uint256 sharesAmount\n    );\n\n    /**\n      * Emitted when the ERC20 `token` recovered (e.g. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ERC20Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 amount\n    );\n\n    /**\n      * Emitted when the ERC721-compatible `token` (NFT) recovered (e.g. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ERC721Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 tokenId\n    );\n\n    /**\n      * Ctor\n      *\n      * @param _treasury the Lido treasury address (see StETH/ERC20/ERC721-recovery interfaces)\n      * @param _lido the Lido token (stETH) address\n      * @param _voting the Lido Aragon Voting address\n      * @param _totalCoverSharesBurnt Shares burnt counter init value (cover case)\n      * @param _totalNonCoverSharesBurnt Shares burnt counter init value (non-cover case)\n      */\n    constructor(\n        address _treasury,\n        address _lido,\n        address _voting,\n        uint256 _totalCoverSharesBurnt,\n        uint256 _totalNonCoverSharesBurnt\n    ) {\n        require(_treasury != address(0), \"TREASURY_ZERO_ADDRESS\");\n        require(_lido != address(0), \"LIDO_ZERO_ADDRESS\");\n        require(_voting != address(0), \"VOTING_ZERO_ADDRESS\");\n\n        TREASURY = _treasury;\n        LIDO = _lido;\n        VOTING = _voting;\n\n        totalCoverSharesBurnt = _totalCoverSharesBurnt;\n        totalNonCoverSharesBurnt = _totalNonCoverSharesBurnt;\n    }\n\n    /**\n      * @notice BE CAREFUL, the provided stETH will be burnt permanently.\n      * @dev only `voting` allowed to call this function.\n      *\n      * Transfers `_stETH2Burn` stETH tokens from the message sender and irreversibly locks these\n      * on the burner contract address. Internally converts `_stETH2Burn` amount into underlying\n      * shares amount (`_stETH2BurnAsShares`) and marks the converted amount for burning\n      * by increasing the `coverSharesBurnRequested` counter.\n      *\n      * @param _stETH2Burn stETH tokens to burn\n      *\n      */\n    function requestBurnMyStETHForCover(uint256 _stETH2Burn) external {\n        _requestBurnMyStETH(_stETH2Burn, true);\n    }\n\n    /**\n      * @notice BE CAREFUL, the provided stETH will be burnt permanently.\n      * @dev only `voting` allowed to call this function.\n      *\n      * Transfers `_stETH2Burn` stETH tokens from the message sender and irreversibly locks these\n      * on the burner contract address. Internally converts `_stETH2Burn` amount into underlying\n      * shares amount (`_stETH2BurnAsShares`) and marks the converted amount for burning\n      * by increasing the `nonCoverSharesBurnRequested` counter.\n      *\n      * @param _stETH2Burn stETH tokens to burn\n      *\n      */\n    function requestBurnMyStETH(uint256 _stETH2Burn) external {\n        _requestBurnMyStETH(_stETH2Burn, false);\n    }\n\n    /**\n      * Transfers the excess stETH amount (e.g. belonging to the burner contract address\n      * but not marked for burning) to the Lido treasury address set upon the\n      * contract construction.\n      */\n    function recoverExcessStETH() external {\n        uint256 excessStETH = getExcessStETH();\n\n        if (excessStETH > 0) {\n            uint256 excessSharesAmount = ILido(LIDO).getSharesByPooledEth(excessStETH);\n\n            emit ExcessStETHRecovered(msg.sender, excessStETH, excessSharesAmount);\n\n            IERC20(LIDO).transfer(TREASURY, excessStETH);\n        }\n    }\n\n    /**\n      * Intentionally deny incoming ether\n      */\n    receive() external payable {\n        revert(\"INCOMING_ETH_IS_FORBIDDEN\");\n    }\n\n    /**\n      * Transfers a given `_amount` of an ERC20-token (defined by the `_token` contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC20-compatible token\n      * @param _amount token amount\n      */\n    function recoverERC20(address _token, uint256 _amount) external {\n        require(_amount > 0, \"ZERO_RECOVERY_AMOUNT\");\n        require(_token != address(0), \"ZERO_ERC20_ADDRESS\");\n        require(_token != LIDO, \"STETH_RECOVER_WRONG_FUNC\");\n\n        emit ERC20Recovered(msg.sender, _token, _amount);\n\n        IERC20(_token).transfer(TREASURY, _amount);\n    }\n\n    /**\n      * Transfers a given token_id of an ERC721-compatible NFT (defined by the token contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC721-compatible token\n      * @param _tokenId minted token id\n      */\n    function recoverERC721(address _token, uint256 _tokenId) external {\n        require(_token != address(0), \"ZERO_ERC721_ADDRESS\");\n\n        emit ERC721Recovered(msg.sender, _token, _tokenId);\n\n        IERC721(_token).transferFrom(address(this), TREASURY, _tokenId);\n    }\n\n    /**\n     * Enacts cover/non-cover burning requests and logs cover/non-cover shares amount just burnt.\n     * Increments `totalCoverSharesBurnt` and `totalNonCoverSharesBurnt` counters.\n     * Resets `coverSharesBurnRequested` and `nonCoverSharesBurnRequested` counters to zero.\n     * Does nothing if there are no pending burning requests.\n     */\n    function processLidoOracleReport(uint256, uint256, uint256) external override {\n        uint256 memCoverSharesBurnRequested = coverSharesBurnRequested;\n        uint256 memNonCoverSharesBurnRequested = nonCoverSharesBurnRequested;\n\n        uint256 burnAmount = memCoverSharesBurnRequested + memNonCoverSharesBurnRequested;\n\n        if (burnAmount == 0) {\n            return;\n        }\n\n        address oracle = ILido(LIDO).getOracle();\n\n        /**\n          * Allow invocation only from `LidoOracle` or previously set composite beacon report receiver.\n          * The second condition provides a way to use multiple callbacks packed into a single composite container.\n          */\n        require(\n            msg.sender == oracle\n            || (msg.sender == IOracle(oracle).getBeaconReportReceiver()),\n            \"APP_AUTH_FAILED\"\n        );\n\n        if (memCoverSharesBurnRequested > 0) {\n            totalCoverSharesBurnt += memCoverSharesBurnRequested;\n            uint256 coverStETHBurnAmountRequested = ILido(LIDO).getPooledEthByShares(memCoverSharesBurnRequested);\n            emit StETHBurnt(true /* isCover */, coverStETHBurnAmountRequested, memCoverSharesBurnRequested);\n            coverSharesBurnRequested = 0;\n        }\n        if (memNonCoverSharesBurnRequested > 0) {\n            totalNonCoverSharesBurnt += memNonCoverSharesBurnRequested;\n            uint256 nonCoverStETHBurnAmountRequested = ILido(LIDO).getPooledEthByShares(memNonCoverSharesBurnRequested);\n            emit StETHBurnt(false /* isCover */, nonCoverStETHBurnAmountRequested, memNonCoverSharesBurnRequested);\n            nonCoverSharesBurnRequested = 0;\n        }\n\n        ILido(LIDO).burnShares(address(this), burnAmount);\n    }\n\n    /**\n      * Returns the total cover shares ever burnt.\n      */\n    function getCoverSharesBurnt() external view returns (uint256) {\n        return totalCoverSharesBurnt;\n    }\n\n    /**\n      * Returns the total non-cover shares ever burnt.\n      */\n    function getNonCoverSharesBurnt() external view returns (uint256) {\n        return totalNonCoverSharesBurnt;\n    }\n\n    /**\n      * Returns the stETH amount belonging to the burner contract address but not marked for burning.\n      */\n    function getExcessStETH() public view returns (uint256)  {\n        uint256 sharesBurnRequested = (coverSharesBurnRequested + nonCoverSharesBurnRequested);\n        uint256 totalShares = ILido(LIDO).sharesOf(address(this));\n\n        // sanity check, don't revert\n        if (totalShares <= sharesBurnRequested) {\n            return 0;\n        }\n\n        return ILido(LIDO).getPooledEthByShares(totalShares - sharesBurnRequested);\n    }\n\n    function _requestBurnMyStETH(uint256 _stETH2Burn, bool _isCover) private {\n        require(_stETH2Burn > 0, \"ZERO_BURN_AMOUNT\");\n        require(msg.sender == VOTING, \"MSG_SENDER_MUST_BE_VOTING\");\n        require(IERC20(LIDO).transferFrom(msg.sender, address(this), _stETH2Burn));\n\n        uint256 sharesAmount = ILido(LIDO).getSharesByPooledEth(_stETH2Burn);\n\n        emit StETHBurnRequested(_isCover, msg.sender, _stETH2Burn, sharesAmount);\n\n        if (_isCover) {\n            coverSharesBurnRequested += sharesAmount;\n        } else {\n            nonCoverSharesBurnRequested += sharesAmount;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/0.8.9/SelfOwnedStETHBurner.sol",
      "content": "// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-v4.4/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-v4.4/token/ERC721/IERC721.sol\";\nimport \"./interfaces/IBeaconReportReceiver.sol\";\n\n/**\n  * @title Interface defining a Lido liquid staking pool\n  * @dev see also [Lido liquid staking pool core contract](https://docs.lido.fi/contracts/lido)\n  */\ninterface ILido {\n    /**\n      * @notice Destroys given amount of shares from account's holdings\n      * @param _account address of the shares holder\n      * @param _sharesAmount shares amount to burn\n      * @dev incurs stETH token rebase by decreasing the total amount of shares.\n      */\n    function burnShares(address _account, uint256 _sharesAmount) external returns (uint256 newTotalShares);\n\n    /**\n      * @notice Gets authorized oracle address\n      * @return address of oracle contract.\n      */\n    function getOracle() external view returns (address);\n\n    /**\n      * @notice Get stETH amount by the provided shares amount\n      * @param _sharesAmount shares amount\n      * @dev dual to `getSharesByPooledEth`.\n      */\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n\n    /**\n      * @notice Get shares amount by the provided stETH amount\n      * @param _pooledEthAmount stETH amount\n      * @dev dual to `getPooledEthByShares`.\n      */\n    function getSharesByPooledEth(uint256 _pooledEthAmount) external view returns (uint256);\n\n    /**\n      * @notice Get shares amount of the provided account\n      * @param _account provided account address.\n      */\n    function sharesOf(address _account) external view returns (uint256);\n}\n\n/**\n  * @title Interface for the Lido Beacon Chain Oracle\n  */\ninterface IOracle {\n    /**\n     * @notice Gets currently set beacon report receiver\n     * @return address of a beacon receiver\n     */\n    function getBeaconReportReceiver() external view returns (address);\n}\n\n/**\n  * @title A dedicated contract for enacting stETH burning requests\n  * @notice See the Lido improvement proposal #6 (LIP-6) spec.\n  * @author Eugene Mamin <TheDZhon@gmail.com>\n  *\n  * @dev Burning stETH means 'decrease total underlying shares amount to perform stETH token rebase'\n  */\ncontract SelfOwnedStETHBurner is IBeaconReportReceiver {\n    uint256 private coverSharesBurnRequested;\n    uint256 private nonCoverSharesBurnRequested;\n\n    uint256 private totalCoverSharesBurnt;\n    uint256 private totalNonCoverSharesBurnt;\n\n    address public immutable LIDO;\n    address public immutable TREASURY;\n    address public immutable VOTING;\n\n    /**\n      * Emitted when a new stETH burning request is added by the `requestedBy` address.\n      */\n    event StETHBurnRequested(\n        bool indexed isCover,\n        address indexed requestedBy,\n        uint256 amount,\n        uint256 sharesAmount\n    );\n\n    /**\n      * Emitted when the stETH `amount` (corresponding to `sharesAmount` shares) burnt for the `isCover` reason.\n      */\n    event StETHBurnt(\n        bool indexed isCover,\n        uint256 amount,\n        uint256 sharesAmount\n    );\n\n    /**\n      * Emitted when the excessive stETH `amount` (corresponding to `sharesAmount` shares) recovered (e.g. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ExcessStETHRecovered(\n        address indexed requestedBy,\n        uint256 amount,\n        uint256 sharesAmount\n    );\n\n    /**\n      * Emitted when the ERC20 `token` recovered (e.g. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ERC20Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 amount\n    );\n\n    /**\n      * Emitted when the ERC721-compatible `token` (NFT) recovered (e.g. transferred)\n      * to the Lido treasure address by `requestedBy` sender.\n      */\n    event ERC721Recovered(\n        address indexed requestedBy,\n        address indexed token,\n        uint256 tokenId\n    );\n\n    /**\n      * Ctor\n      *\n      * @param _treasury the Lido treasury address (see StETH/ERC20/ERC721-recovery interfaces)\n      * @param _lido the Lido token (stETH) address\n      * @param _voting the Lido Aragon Voting address\n      * @param _totalCoverSharesBurnt Shares burnt counter init value (cover case)\n      * @param _totalNonCoverSharesBurnt Shares burnt counter init value (non-cover case)\n      */\n    constructor(\n        address _treasury,\n        address _lido,\n        address _voting,\n        uint256 _totalCoverSharesBurnt,\n        uint256 _totalNonCoverSharesBurnt\n    ) {\n        require(_treasury != address(0), \"TREASURY_ZERO_ADDRESS\");\n        require(_lido != address(0), \"LIDO_ZERO_ADDRESS\");\n        require(_voting != address(0), \"VOTING_ZERO_ADDRESS\");\n\n        TREASURY = _treasury;\n        LIDO = _lido;\n        VOTING = _voting;\n\n        totalCoverSharesBurnt = _totalCoverSharesBurnt;\n        totalNonCoverSharesBurnt = _totalNonCoverSharesBurnt;\n    }\n\n    /**\n      * @notice BE CAREFUL, the provided stETH will be burnt permanently.\n      * @dev only `voting` allowed to call this function.\n      *\n      * Transfers `_stETH2Burn` stETH tokens from the message sender and irreversibly locks these\n      * on the burner contract address. Internally converts `_stETH2Burn` amount into underlying\n      * shares amount (`_stETH2BurnAsShares`) and marks the converted amount for burning\n      * by increasing the `coverSharesBurnRequested` counter.\n      *\n      * @param _stETH2Burn stETH tokens to burn\n      *\n      */\n    function requestBurnMyStETHForCover(uint256 _stETH2Burn) external {\n        _requestBurnMyStETH(_stETH2Burn, true);\n    }\n\n    /**\n      * @notice BE CAREFUL, the provided stETH will be burnt permanently.\n      * @dev only `voting` allowed to call this function.\n      *\n      * Transfers `_stETH2Burn` stETH tokens from the message sender and irreversibly locks these\n      * on the burner contract address. Internally converts `_stETH2Burn` amount into underlying\n      * shares amount (`_stETH2BurnAsShares`) and marks the converted amount for burning\n      * by increasing the `nonCoverSharesBurnRequested` counter.\n      *\n      * @param _stETH2Burn stETH tokens to burn\n      *\n      */\n    function requestBurnMyStETH(uint256 _stETH2Burn) external {\n        _requestBurnMyStETH(_stETH2Burn, false);\n    }\n\n    /**\n      * Transfers the excess stETH amount (e.g. belonging to the burner contract address\n      * but not marked for burning) to the Lido treasury address set upon the\n      * contract construction.\n      */\n    function recoverExcessStETH() external {\n        uint256 excessStETH = getExcessStETH();\n\n        if (excessStETH > 0) {\n            uint256 excessSharesAmount = ILido(LIDO).getSharesByPooledEth(excessStETH);\n\n            emit ExcessStETHRecovered(msg.sender, excessStETH, excessSharesAmount);\n\n            IERC20(LIDO).transfer(TREASURY, excessStETH);\n        }\n    }\n\n    /**\n      * Intentionally deny incoming ether\n      */\n    receive() external payable {\n        revert(\"INCOMING_ETH_IS_FORBIDDEN\");\n    }\n\n    /**\n      * Transfers a given `_amount` of an ERC20-token (defined by the `_token` contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC20-compatible token\n      * @param _amount token amount\n      */\n    function recoverERC20(address _token, uint256 _amount) external {\n        require(_amount > 0, \"ZERO_RECOVERY_AMOUNT\");\n        require(_token != address(0), \"ZERO_ERC20_ADDRESS\");\n        require(_token != LIDO, \"STETH_RECOVER_WRONG_FUNC\");\n\n        emit ERC20Recovered(msg.sender, _token, _amount);\n\n        IERC20(_token).transfer(TREASURY, _amount);\n    }\n\n    /**\n      * Transfers a given token_id of an ERC721-compatible NFT (defined by the token contract address)\n      * currently belonging to the burner contract address to the Lido treasury address.\n      *\n      * @param _token an ERC721-compatible token\n      * @param _tokenId minted token id\n      */\n    function recoverERC721(address _token, uint256 _tokenId) external {\n        require(_token != address(0), \"ZERO_ERC721_ADDRESS\");\n\n        emit ERC721Recovered(msg.sender, _token, _tokenId);\n\n        IERC721(_token).transferFrom(address(this), TREASURY, _tokenId);\n    }\n\n    /**\n     * Enacts cover/non-cover burning requests and logs cover/non-cover shares amount just burnt.\n     * Increments `totalCoverSharesBurnt` and `totalNonCoverSharesBurnt` counters.\n     * Resets `coverSharesBurnRequested` and `nonCoverSharesBurnRequested` counters to zero.\n     * Does nothing if there are no pending burning requests.\n     */\n    function processLidoOracleReport(uint256, uint256, uint256) external override {\n        uint256 memCoverSharesBurnRequested = coverSharesBurnRequested;\n        uint256 memNonCoverSharesBurnRequested = nonCoverSharesBurnRequested;\n\n        uint256 burnAmount = memCoverSharesBurnRequested + memNonCoverSharesBurnRequested;\n\n        if (burnAmount == 0) {\n            return;\n        }\n\n        address oracle = ILido(LIDO).getOracle();\n\n        /**\n          * Allow invocation only from `LidoOracle` or previously set composite beacon report receiver.\n          * The second condition provides a way to use multiple callbacks packed into a single composite container.\n          */\n        require(\n            msg.sender == oracle\n            || (msg.sender == IOracle(oracle).getBeaconReportReceiver()),\n            \"APP_AUTH_FAILED\"\n        );\n\n        if (memCoverSharesBurnRequested > 0) {\n            totalCoverSharesBurnt += memCoverSharesBurnRequested;\n            uint256 coverStETHBurnAmountRequested = ILido(LIDO).getPooledEthByShares(memCoverSharesBurnRequested);\n            emit StETHBurnt(true /* isCover */, coverStETHBurnAmountRequested, memCoverSharesBurnRequested);\n            coverSharesBurnRequested = 0;\n        }\n        if (memNonCoverSharesBurnRequested > 0) {\n            totalNonCoverSharesBurnt += memNonCoverSharesBurnRequested;\n            uint256 nonCoverStETHBurnAmountRequested = ILido(LIDO).getPooledEthByShares(memNonCoverSharesBurnRequested);\n            emit StETHBurnt(false /* isCover */, nonCoverStETHBurnAmountRequested, memNonCoverSharesBurnRequested);\n            nonCoverSharesBurnRequested = 0;\n        }\n\n        ILido(LIDO).burnShares(address(this), burnAmount);\n    }\n\n    /**\n      * Returns the total cover shares ever burnt.\n      */\n    function getCoverSharesBurnt() external view returns (uint256) {\n        return totalCoverSharesBurnt;\n    }\n\n    /**\n      * Returns the total non-cover shares ever burnt.\n      */\n    function getNonCoverSharesBurnt() external view returns (uint256) {\n        return totalNonCoverSharesBurnt;\n    }\n\n    /**\n      * Returns the stETH amount belonging to the burner contract address but not marked for burning.\n      */\n    function getExcessStETH() public view returns (uint256)  {\n        uint256 sharesBurnRequested = (coverSharesBurnRequested + nonCoverSharesBurnRequested);\n        uint256 totalShares = ILido(LIDO).sharesOf(address(this));\n\n        // sanity check, don't revert\n        if (totalShares <= sharesBurnRequested) {\n            return 0;\n        }\n\n        return ILido(LIDO).getPooledEthByShares(totalShares - sharesBurnRequested);\n    }\n\n    function _requestBurnMyStETH(uint256 _stETH2Burn, bool _isCover) private {\n        require(_stETH2Burn > 0, \"ZERO_BURN_AMOUNT\");\n        require(msg.sender == VOTING, \"MSG_SENDER_MUST_BE_VOTING\");\n        require(IERC20(LIDO).transferFrom(msg.sender, address(this), _stETH2Burn));\n\n        uint256 sharesAmount = ILido(LIDO).getSharesByPooledEth(_stETH2Burn);\n\n        emit StETHBurnRequested(_isCover, msg.sender, _stETH2Burn, sharesAmount);\n\n        if (_isCover) {\n            coverSharesBurnRequested += sharesAmount;\n        } else {\n            nonCoverSharesBurnRequested += sharesAmount;\n        }\n    }\n}"
    }
  ]
}