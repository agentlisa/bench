{
  "Title": "[L-01] reserveFactor in LendingPool should be capped at 1e18",
  "Content": "[`setReserveFactor()_e18`](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/lending_pool/LendingPool.sol#L239-L241) does not check the reserveFactor, which if bigger than `1e18`, will make [`accrueInterest()`](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/lending_pool/LendingPool.sol#L155) always underflow, DoSing the lending pool functions that depend on the [`accrue()`](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/lending_pool/LendingPool.sol#L55) modifier. It should ideally be capped at a lower value, but this is more of a centralization risk.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-initcapital",
  "Code": [
    {
      "filename": "contracts/lending_pool/LendingPool.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IIRM} from '../interfaces/lending_pool/IIRM.sol';\n\nimport {ERC20Upgradeable} from '@openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\nimport {IERC20Metadata} from '@openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {MathUpgradeable} from '@openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol';\n\ncontract LendingPool is ERC20Upgradeable, ILendingPool, UnderACM {\n    using SafeERC20 for IERC20;\n    using MathUpgradeable for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    uint private constant VIRTUAL_SHARES = 1e8;\n    uint private constant VIRTUAL_ASSETS = 1;\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n    bytes32 private constant GOVERNOR = keccak256('governor');\n\n    // immutables\n    address public immutable core;\n\n    // storages\n    address public underlyingToken; // underlying tokens\n    uint public cash; // total cash\n    uint public totalDebt; // total debt\n    uint public totalDebtShares; // total debt shares\n    address public irm; // interest rate model\n    uint public lastAccruedTime; // last accrued timestamp\n    uint public reserveFactor_e18; // reserve factor\n    address public treasury; // treasury address\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR, msg.sender);\n        _;\n    }\n\n    modifier onlyCore() {\n        _require(msg.sender == core, Errors.NOT_INIT_CORE);\n        _;\n    }\n\n    modifier accrue() {\n        accrueInterest();\n        _;\n    }\n\n    // constructor\n    constructor(address _core, address _acm) UnderACM(_acm) {\n        _disableInitializers();\n        core = _core;\n    }\n\n    // initializer\n    /// @dev initialize contract and setup underlying token, name, symbol\n    ///     interest rate model, reserver factor and treasury\n    /// @param _underlyingToken underlying token address\n    /// @param _name lending pool's name\n    /// @param _symbol lending pool's symbol\n    /// @param _irm interest rate model address\n    /// @param _reserveFactor_e18 reserve factor in 1e18 (1e18 = 100%)\n    /// @param _treasury treasury address\n    function initialize(\n        address _underlyingToken,\n        string calldata _name,\n        string calldata _symbol,\n        address _irm,\n        uint _reserveFactor_e18,\n        address _treasury\n    ) external initializer {\n        underlyingToken = _underlyingToken;\n        __ERC20_init(_name, _symbol);\n        irm = _irm;\n        treasury = _treasury;\n        lastAccruedTime = block.timestamp;\n        reserveFactor_e18 = _reserveFactor_e18;\n        // approve core to enable flashloan\n        IERC20(_underlyingToken).safeApprove(core, type(uint).max);\n    }\n\n    // functions\n    /// @inheritdoc ERC20Upgradeable\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(underlyingToken).decimals();\n    }\n\n    /// @inheritdoc ILendingPool\n    function mint(address _receiver) external onlyCore accrue returns (uint shares) {\n        uint _cash = cash;\n        uint newCash = IERC20(underlyingToken).balanceOf(address(this));\n        uint amt = newCash - _cash;\n        shares = _toShares(amt, _cash + totalDebt, totalSupply());\n        _require(shares != 0, Errors.ZERO_VALUE);\n        _mint(_receiver, shares);\n        cash = newCash;\n    }\n\n    /// @inheritdoc ILendingPool\n    function burn(address _receiver) external onlyCore accrue returns (uint amt) {\n        uint sharesToBurn = balanceOf(address(this));\n        uint _cash = cash;\n        _require(sharesToBurn != 0, Errors.ZERO_VALUE);\n        amt = _toAmt(sharesToBurn, _cash + totalDebt, totalSupply());\n        _require(amt <= _cash, Errors.NOT_ENOUGH_CASH);\n        unchecked {\n            cash = _cash - amt;\n        }\n        _burn(address(this), sharesToBurn);\n        IERC20(underlyingToken).safeTransfer(_receiver, amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function borrow(address _receiver, uint _amt) external onlyCore accrue returns (uint shares) {\n        _require(_amt <= cash, Errors.NOT_ENOUGH_CASH);\n        uint _totalDebt = totalDebt;\n        shares = _totalDebt > 0 ? _amt.mulDiv(totalDebtShares, _totalDebt, MathUpgradeable.Rounding.Up) : _amt;\n        totalDebtShares += shares;\n        totalDebt = _totalDebt + _amt;\n        cash -= _amt;\n        IERC20(underlyingToken).safeTransfer(_receiver, _amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function repay(uint _shares) external onlyCore accrue returns (uint amt) {\n        uint _totalDebtShares = totalDebtShares;\n        uint _totalDebt = totalDebt;\n        amt = _shares.mulDiv(_totalDebt, _totalDebtShares, MathUpgradeable.Rounding.Up);\n        uint newCash = IERC20(underlyingToken).balanceOf(address(this));\n        _require(amt <= newCash - cash, Errors.INVALID_AMOUNT_TO_REPAY);\n        totalDebtShares = _totalDebtShares - _shares;\n        totalDebt = _totalDebt > amt ? _totalDebt - amt : 0;\n        cash = newCash;\n    }\n\n    /// @inheritdoc ILendingPool\n    function syncCash() external accrue onlyCore returns (uint newCash) {\n        newCash = IERC20(underlyingToken).balanceOf(address(this));\n        _require(newCash >= cash, Errors.INVALID_AMOUNT_TO_REPAY); // flash not repay\n        cash = newCash;\n    }\n\n    /// @inheritdoc ILendingPool\n    function accrueInterest() public {\n        uint _lastAccruedTime = lastAccruedTime;\n        if (block.timestamp != _lastAccruedTime) {\n            uint _totalDebt = totalDebt;\n            uint _cash = cash;\n            uint borrowRate_e18 = IIRM(irm).getBorrowRate_e18(_cash, _totalDebt);\n            uint accruedInterest = (borrowRate_e18 * (block.timestamp - _lastAccruedTime) * _totalDebt) / ONE_E18;\n            uint reserve = (accruedInterest * reserveFactor_e18) / ONE_E18;\n            if (reserve > 0) {\n                _mint(treasury, _toShares(reserve, _cash + _totalDebt + accruedInterest - reserve, totalSupply()));\n            }\n            totalDebt = _totalDebt + accruedInterest;\n            lastAccruedTime = block.timestamp;\n        }\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtAmtToShareStored(uint _amt) public view returns (uint shares) {\n        shares = totalDebt > 0 ? _amt.mulDiv(totalDebtShares, totalDebt, MathUpgradeable.Rounding.Up) : _amt;\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtAmtToShareCurrent(uint _amt) external accrue returns (uint shares) {\n        shares = debtAmtToShareStored(_amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtShareToAmtStored(uint _shares) public view returns (uint amt) {\n        amt = totalDebtShares > 0 ? _shares.mulDiv(totalDebt, totalDebtShares, MathUpgradeable.Rounding.Up) : 0;\n    }\n\n    /// @inheritdoc ILendingPool\n    function debtShareToAmtCurrent(uint _shares) external accrue returns (uint amt) {\n        amt = debtShareToAmtStored(_shares);\n    }\n\n    /// @inheritdoc ILendingPool\n    function toShares(uint _amt) public view returns (uint shares) {\n        shares = _toShares(_amt, totalAssets(), totalSupply());\n    }\n\n    /// @inheritdoc ILendingPool\n    function toAmt(uint _shares) public view returns (uint amt) {\n        amt = _toAmt(_shares, totalAssets(), totalSupply());\n    }\n\n    /// @inheritdoc ILendingPool\n    function toSharesCurrent(uint _amt) external accrue returns (uint shares) {\n        shares = toShares(_amt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function toAmtCurrent(uint _shares) external accrue returns (uint amt) {\n        amt = toAmt(_shares);\n    }\n\n    /// @inheritdoc ILendingPool\n    function getSupplyRate_e18() external view returns (uint supplyRate_e18) {\n        uint _totalDebt = totalDebt;\n        uint _cash = cash;\n        uint borrowRate_e18 = IIRM(irm).getBorrowRate_e18(_cash, _totalDebt);\n        // supply rate = borrow rate * (1 - reserve factor) * totalDebt / (cash + totalDebt)\n        supplyRate_e18 = _cash + _totalDebt > 0\n            ? (borrowRate_e18 * (ONE_E18 - reserveFactor_e18) * _totalDebt) / ((_cash + _totalDebt) * ONE_E18)\n            : 0;\n    }\n\n    /// @inheritdoc ILendingPool\n    function getBorrowRate_e18() external view returns (uint borrowRate_e18) {\n        borrowRate_e18 = IIRM(irm).getBorrowRate_e18(cash, totalDebt);\n    }\n\n    /// @inheritdoc ILendingPool\n    function totalAssets() public view returns (uint) {\n        return cash + totalDebt;\n    }\n\n    /// @inheritdoc ILendingPool\n    function setIrm(address _irm) external accrue onlyGuardian {\n        irm = _irm;\n        emit SetIrm(_irm);\n    }\n\n    /// @inheritdoc ILendingPool\n    function setReserveFactor_e18(uint _reserveFactor_e18) external accrue onlyGuardian {\n        reserveFactor_e18 = _reserveFactor_e18;\n        emit SetReserveFactor_e18(_reserveFactor_e18);\n    }\n\n    /// @inheritdoc ILendingPool\n    function setTreasury(address _treasury) external onlyGovernor {\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n    /// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\n    /// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\n    /// @param _amt The amount of assets to convert to shares.\n    /// @param _totalAssets The total amount of assets in the pool.\n    /// @param _totalShares The total amount of shares in the pool.\n    /// @return shares the amount of shares\n    function _toShares(uint _amt, uint _totalAssets, uint _totalShares) internal pure returns (uint shares) {\n        return _amt.mulDiv(_totalShares + VIRTUAL_SHARES, _totalAssets + VIRTUAL_ASSETS);\n    }\n\n    /// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\n    /// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\n    /// @param _shares The amount of shares to convert to assets.\n    /// @param _totalAssets The total amount of assets in the pool.\n    /// @param _totalShares The total amount of shares in the pool.\n    /// @return amt the token amount\n    function _toAmt(uint _shares, uint _totalAssets, uint _totalShares) internal pure returns (uint amt) {\n        return _shares.mulDiv(_totalAssets + VIRTUAL_ASSETS, _totalShares + VIRTUAL_SHARES);\n    }\n}"
    }
  ]
}