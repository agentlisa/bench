{
  "Title": "M-14: Solmate safetransfer and safetransferfrom does not check the code size of the token address, which may lead to funding loss",
  "Content": "# Issue M-14: Solmate safetransfer and safetransferfrom does not check the code size of the token address, which may lead to funding loss \r\n\r\nSource: https://github.com/sherlock-audit/2022-11-bond-judging/issues/8 \r\n\r\n## Found by \r\nBnke0x0, 8olidity\r\n\r\n## Summary\r\n\r\n## Vulnerability Detail\r\n\r\n## Impact\r\nthe safetransfer and safetransferfrom don't check the existence of code at the token address. This is a known issue while using solmate's libraries. Hence this may lead to miscalculation of funds and may lead to loss of funds, because if safetransfer() and safetransferfrom() are called on a token address that doesn't have a contract in it, it will always return success, bypassing the return value check. Due to this protocol will think that funds have been transferred successfully, and records will be accordingly calculated, but in reality, funds were never transferred. So this will lead to miscalculation and possibly loss of funds\r\n\r\n## Code Snippet\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L143\r\n\r\n        'token_.safeTransfer(to_, amount_);'\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L152\r\n\r\n\r\n           'token_.safeTransferFrom(msg.sender, address(this), amount_);'\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L108\r\n\r\n\r\n         'token.safeTransfer(to_, send);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L187\r\n\r\n\r\n          'quoteToken.safeTransferFrom(msg.sender, address(this), amount_);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L195\r\n\r\n\r\n            'quoteToken.safeTransfer(callbackAddr, amountLessFee);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L210\r\n\r\n\r\n            'payoutToken.safeTransferFrom(owner, address(this), payout_);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L214\r\n\r\n\r\n                'quoteToken.safeTransfer(owner, amountLessFee);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L89\r\n\r\n\r\n          'underlying_.safeTransfer(recipient_, payout_);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L114\r\n\r\n\r\n           'underlying_.safeTransferFrom(msg.sender, address(this), amount_);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L152\r\n\r\n\r\n        'underlying.safeTransfer(msg.sender, amount_);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L90\r\n\r\n\r\n          'payoutToken_.safeTransfer(recipient_, payout_);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L114\r\n\r\n\r\n                'underlying_.safeTransferFrom(msg.sender, address(this), amount_);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L151\r\n\r\n\r\n                'meta.underlying.safeTransfer(msg.sender, amount_);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondSampleCallback.sol#L42\r\n\r\n\r\n          'payoutToken_.safeTransfer(msg.sender, outputAmount_);'\r\n\r\n## Tool used\r\n\r\nManual Review\r\n\r\n## Recommendation\r\nUse openzeppelin's safeERC20 or implement a code existence check\r\n\r\n## Discussion\r\n\r\n**Evert0x**\r\n\r\nMessage from sponsor\r\n\r\n----\r\n\r\nAgree. We implemented a code size check in the TransferHelper.sol library to fix this.\r\n\r\n\r\n\r\n**xiaoming9090**\r\n\r\nFixed in https://github.com/Bond-Protocol/bonds/commit/a247783a240cb7fe6fb25fa19ab9385c025f8e4f",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/20",
  "Code": [
    {
      "filename": "src/bases/BondBaseCallback.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {TransferHelper} from \"../lib/TransferHelper.sol\";\n\nimport {IBondCallback} from \"../interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"../interfaces/IBondAggregator.sol\";\n\n/// @title Bond Callback\n/// @notice Bond Callback Base Contract\n/// @dev Bond Protocol is a system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Callback contract is an optional feature of the Bond system.\n///      Callbacks allow issuers (market creators) to apply custom logic on receipt and\n///      payout of tokens. The Callback must be created prior to market creation and\n///      the address passed in as an argument. The Callback depends on the Aggregator\n///      contract for the Auctioneer that the market is created to get market data.\n///\n/// @dev Without a Callback contract, payout tokens are transferred directly from\n///      the market owner on each bond purchase (market owners must approve the\n///      Teller serving that market for the amount of Payout Tokens equivalent to the\n///      capacity of a market when created.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\nabstract contract BondBaseCallback is IBondCallback, Ownable, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    /* ========== ERRORS ========== */\n\n    error Callback_MarketNotSupported(uint256 id);\n    error Callback_TokensNotReceived();\n    error Callback_TellerMismatch();\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(address => mapping(uint256 => bool)) public approvedMarkets;\n    mapping(uint256 => uint256[2]) internal _amountsPerMarket;\n    mapping(ERC20 => uint256) internal priorBalances;\n    IBondAggregator internal _aggregator;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IBondAggregator aggregator_) {\n        _aggregator = aggregator_;\n    }\n\n    /* ========== WHITELISTING ========== */\n\n    /// @inheritdoc IBondCallback\n    function whitelist(address teller_, uint256 id_) external override onlyOwner {\n        // Check that the market id is a valid, live market on the aggregator\n        try _aggregator.isLive(id_) returns (bool live) {\n            if (!live) revert Callback_MarketNotSupported(id_);\n        } catch {\n            revert Callback_MarketNotSupported(id_);\n        }\n\n        // Check that the provided teller is the teller for the market ID on the stored aggregator\n        // We could pull the teller from the aggregator, but requiring the teller to be passed in\n        // is more explicit about which contract is being whitelisted\n        if (teller_ != address(_aggregator.getTeller(id_))) revert Callback_TellerMismatch();\n\n        approvedMarkets[teller_][id_] = true;\n    }\n\n    /* ========== CALLBACK ========== */\n\n    /// @inheritdoc IBondCallback\n    function callback(\n        uint256 id_,\n        uint256 inputAmount_,\n        uint256 outputAmount_\n    ) external override nonReentrant {\n        /// Confirm that the teller and market id are whitelisted\n        if (!approvedMarkets[msg.sender][id_]) revert Callback_MarketNotSupported(id_);\n\n        // Get tokens for market\n        (, , ERC20 payoutToken, ERC20 quoteToken, , ) = _aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        // Check that quoteTokens were transferred prior to the call\n        if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n            revert Callback_TokensNotReceived();\n\n        // Call internal _callback function to handle implementation-specific logic\n        /// @dev must implement _callback in contracts that inherit this base\n        _callback(id_, quoteToken, inputAmount_, payoutToken, outputAmount_);\n\n        // Store amounts in/out\n        /// @dev updated after internal call so previous balances are available to check against\n        priorBalances[quoteToken] = quoteToken.balanceOf(address(this));\n        priorBalances[payoutToken] = payoutToken.balanceOf(address(this));\n        _amountsPerMarket[id_][0] += inputAmount_;\n        _amountsPerMarket[id_][1] += outputAmount_;\n    }\n\n    /// @notice              Implementation-specific callback logic\n    /// @dev                 Must be implemented by inheriting contract. Called from callback.\n    /// @param id_           ID of the market\n    /// @param quoteToken_   Address of the market quote token\n    /// @param inputAmount_  Amount of quote tokens expected to have been sent to the callback\n    /// @param payoutToken_    Address of the market payout token\n    /// @param outputAmount_ Amount of payout tokens to be paid out\n    function _callback(\n        uint256 id_,\n        ERC20 quoteToken_,\n        uint256 inputAmount_,\n        ERC20 payoutToken_,\n        uint256 outputAmount_\n    ) internal virtual;\n\n    /// @inheritdoc IBondCallback\n    function amountsForMarket(uint256 id_)\n        external\n        view\n        override\n        returns (uint256 in_, uint256 out_)\n    {\n        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n        return (marketAmounts[0], marketAmounts[1]);\n    }\n\n    /// @notice         Withdraw tokens from the callback and update balances\n    /// @notice         Only callback owner\n    /// @param to_      Address of the recipient\n    /// @param token_   Address of the token to withdraw\n    /// @param amount_  Amount of tokens to withdraw\n    function withdraw(\n        address to_,\n        ERC20 token_,\n        uint256 amount_\n    ) external onlyOwner {\n        token_.safeTransfer(to_, amount_);\n        priorBalances[token_] = token_.balanceOf(address(this));\n    }\n\n    /// @notice         Deposit tokens to the callback and update balances\n    /// @notice         Only callback owner\n    /// @param token_   Address of the token to deposit\n    /// @param amount_  Amount of tokens to deposit\n    function deposit(ERC20 token_, uint256 amount_) external onlyOwner {\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n        priorBalances[token_] = token_.balanceOf(address(this));\n    }\n}"
    },
    {
      "filename": "src/bases/BondBaseCallback.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {TransferHelper} from \"../lib/TransferHelper.sol\";\n\nimport {IBondCallback} from \"../interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"../interfaces/IBondAggregator.sol\";\n\n/// @title Bond Callback\n/// @notice Bond Callback Base Contract\n/// @dev Bond Protocol is a system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Callback contract is an optional feature of the Bond system.\n///      Callbacks allow issuers (market creators) to apply custom logic on receipt and\n///      payout of tokens. The Callback must be created prior to market creation and\n///      the address passed in as an argument. The Callback depends on the Aggregator\n///      contract for the Auctioneer that the market is created to get market data.\n///\n/// @dev Without a Callback contract, payout tokens are transferred directly from\n///      the market owner on each bond purchase (market owners must approve the\n///      Teller serving that market for the amount of Payout Tokens equivalent to the\n///      capacity of a market when created.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\nabstract contract BondBaseCallback is IBondCallback, Ownable, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    /* ========== ERRORS ========== */\n\n    error Callback_MarketNotSupported(uint256 id);\n    error Callback_TokensNotReceived();\n    error Callback_TellerMismatch();\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping(address => mapping(uint256 => bool)) public approvedMarkets;\n    mapping(uint256 => uint256[2]) internal _amountsPerMarket;\n    mapping(ERC20 => uint256) internal priorBalances;\n    IBondAggregator internal _aggregator;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IBondAggregator aggregator_) {\n        _aggregator = aggregator_;\n    }\n\n    /* ========== WHITELISTING ========== */\n\n    /// @inheritdoc IBondCallback\n    function whitelist(address teller_, uint256 id_) external override onlyOwner {\n        // Check that the market id is a valid, live market on the aggregator\n        try _aggregator.isLive(id_) returns (bool live) {\n            if (!live) revert Callback_MarketNotSupported(id_);\n        } catch {\n            revert Callback_MarketNotSupported(id_);\n        }\n\n        // Check that the provided teller is the teller for the market ID on the stored aggregator\n        // We could pull the teller from the aggregator, but requiring the teller to be passed in\n        // is more explicit about which contract is being whitelisted\n        if (teller_ != address(_aggregator.getTeller(id_))) revert Callback_TellerMismatch();\n\n        approvedMarkets[teller_][id_] = true;\n    }\n\n    /* ========== CALLBACK ========== */\n\n    /// @inheritdoc IBondCallback\n    function callback(\n        uint256 id_,\n        uint256 inputAmount_,\n        uint256 outputAmount_\n    ) external override nonReentrant {\n        /// Confirm that the teller and market id are whitelisted\n        if (!approvedMarkets[msg.sender][id_]) revert Callback_MarketNotSupported(id_);\n\n        // Get tokens for market\n        (, , ERC20 payoutToken, ERC20 quoteToken, , ) = _aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        // Check that quoteTokens were transferred prior to the call\n        if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n            revert Callback_TokensNotReceived();\n\n        // Call internal _callback function to handle implementation-specific logic\n        /// @dev must implement _callback in contracts that inherit this base\n        _callback(id_, quoteToken, inputAmount_, payoutToken, outputAmount_);\n\n        // Store amounts in/out\n        /// @dev updated after internal call so previous balances are available to check against\n        priorBalances[quoteToken] = quoteToken.balanceOf(address(this));\n        priorBalances[payoutToken] = payoutToken.balanceOf(address(this));\n        _amountsPerMarket[id_][0] += inputAmount_;\n        _amountsPerMarket[id_][1] += outputAmount_;\n    }\n\n    /// @notice              Implementation-specific callback logic\n    /// @dev                 Must be implemented by inheriting contract. Called from callback.\n    /// @param id_           ID of the market\n    /// @param quoteToken_   Address of the market quote token\n    /// @param inputAmount_  Amount of quote tokens expected to have been sent to the callback\n    /// @param payoutToken_    Address of the market payout token\n    /// @param outputAmount_ Amount of payout tokens to be paid out\n    function _callback(\n        uint256 id_,\n        ERC20 quoteToken_,\n        uint256 inputAmount_,\n        ERC20 payoutToken_,\n        uint256 outputAmount_\n    ) internal virtual;\n\n    /// @inheritdoc IBondCallback\n    function amountsForMarket(uint256 id_)\n        external\n        view\n        override\n        returns (uint256 in_, uint256 out_)\n    {\n        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n        return (marketAmounts[0], marketAmounts[1]);\n    }\n\n    /// @notice         Withdraw tokens from the callback and update balances\n    /// @notice         Only callback owner\n    /// @param to_      Address of the recipient\n    /// @param token_   Address of the token to withdraw\n    /// @param amount_  Amount of tokens to withdraw\n    function withdraw(\n        address to_,\n        ERC20 token_,\n        uint256 amount_\n    ) external onlyOwner {\n        token_.safeTransfer(to_, amount_);\n        priorBalances[token_] = token_.balanceOf(address(this));\n    }\n\n    /// @notice         Deposit tokens to the callback and update balances\n    /// @notice         Only callback owner\n    /// @param token_   Address of the token to deposit\n    /// @param amount_  Amount of tokens to deposit\n    function deposit(ERC20 token_, uint256 amount_) external onlyOwner {\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n        priorBalances[token_] = token_.balanceOf(address(this));\n    }\n}"
    },
    {
      "filename": "src/bases/BondBaseTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\n\nimport {IBondTeller} from \"../interfaces/IBondTeller.sol\";\nimport {IBondCallback} from \"../interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"../interfaces/IBondAggregator.sol\";\nimport {IBondAuctioneer} from \"../interfaces/IBondAuctioneer.sol\";\n\nimport {TransferHelper} from \"../lib/TransferHelper.sol\";\nimport {FullMath} from \"../lib/FullMath.sol\";\n\n/// @title Bond Teller\n/// @notice Bond Teller Base Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Teller contract handles all interactions with end users and manages tokens\n///      issued to represent bond positions. Users purchase bonds by depositing Quote Tokens\n///      and receive a Bond Token (token type is implementation-specific) that represents\n///      their payout and the designated expiry. Once a bond vests, Investors can redeem their\n///      Bond Tokens for the underlying Payout Token. A Teller requires one or more Auctioneer\n///      contracts to be deployed to provide markets for users to purchase bonds from.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\nabstract contract BondBaseTeller is IBondTeller, Auth, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS ========== */\n\n    error Teller_InvalidCallback();\n    error Teller_TokenNotMatured(uint48 maturesOn);\n    error Teller_NotAuthorized();\n    error Teller_TokenDoesNotExist(ERC20 underlying, uint48 expiry);\n    error Teller_UnsupportedToken();\n    error Teller_InvalidParams();\n\n    /* ========== EVENTS ========== */\n    event Bonded(uint256 indexed id, address indexed referrer, uint256 amount, uint256 payout);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Fee paid to a front end operator in basis points (3 decimals). Set by the referrer, must be less than or equal to 5% (5e3).\n    /// @dev There are some situations where the fees may round down to zero if quantity of baseToken\n    ///      is < 1e5 wei (can happen with big price differences on small decimal tokens). This is purely\n    ///      a theoretical edge case, as the bond amount would not be practical.\n    mapping(address => uint48) public referrerFees;\n\n    /// @notice Fee paid to protocol in basis points (3 decimal places).\n    uint48 public protocolFee;\n\n    /// @notice 'Create' function fee discount in basis points (3 decimal places). Amount standard fee is reduced by for partners who just want to use the 'create' function to issue bond tokens.\n    uint48 public createFeeDiscount;\n\n    uint48 public constant FEE_DECIMALS = 1e5; // one percent equals 1000.\n\n    /// @notice Fees earned by an address, by token\n    mapping(address => mapping(ERC20 => uint256)) public rewards;\n\n    // Address the protocol receives fees at\n    address internal immutable _protocol;\n\n    // BondAggregator contract with utility functions\n    IBondAggregator internal immutable _aggregator;\n\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) Auth(guardian_, authority_) {\n        _protocol = protocol_;\n        _aggregator = aggregator_;\n\n        protocolFee = 0;\n    }\n\n    /// @inheritdoc IBondTeller\n    function setReferrerFee(uint48 fee_) external override nonReentrant {\n        if (fee_ > 5e3) revert Teller_InvalidParams();\n        referrerFees[msg.sender] = fee_;\n    }\n\n    /// @inheritdoc IBondTeller\n    function setProtocolFee(uint48 fee_) external override requiresAuth {\n        if (fee_ > 5e3) revert Teller_InvalidParams();\n        protocolFee = fee_;\n    }\n\n    /// @inheritdoc IBondTeller\n    function claimFees(ERC20[] memory tokens_, address to_) external override nonReentrant {\n        uint256 len = tokens_.length;\n        for (uint256 i; i < len; ++i) {\n            ERC20 token = tokens_[i];\n            uint256 send = rewards[msg.sender][token];\n\n            if (send != 0) {\n                rewards[msg.sender][token] = 0;\n                token.safeTransfer(to_, send);\n            }\n        }\n    }\n\n    /// @inheritdoc IBondTeller\n    function getFee(address referrer_) external view returns (uint48) {\n        return protocolFee + referrerFees[referrer_];\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n\n    /// @inheritdoc IBondTeller\n    function purchase(\n        address recipient_,\n        address referrer_,\n        uint256 id_,\n        uint256 amount_,\n        uint256 minAmountOut_\n    ) external virtual nonReentrant returns (uint256, uint48) {\n        ERC20 payoutToken;\n        ERC20 quoteToken;\n        uint48 vesting;\n        uint256 payout;\n\n        // Calculate fees for purchase\n        // 1. Calculate referrer fee\n        // 2. Calculate protocol fee as the total expected fee amount minus the referrer fee\n        //    to avoid issues with rounding from separate fee calculations\n        uint256 toReferrer = amount_.mulDiv(referrerFees[referrer_], FEE_DECIMALS);\n        uint256 toProtocol = amount_.mulDiv(protocolFee + referrerFees[referrer_], FEE_DECIMALS) -\n            toReferrer;\n\n        {\n            IBondAuctioneer auctioneer = _aggregator.getAuctioneer(id_);\n            address owner;\n            (owner, , payoutToken, quoteToken, vesting, ) = auctioneer.getMarketInfoForPurchase(\n                id_\n            );\n\n            // Auctioneer handles bond pricing, capacity, and duration\n            uint256 amountLessFee = amount_ - toReferrer - toProtocol;\n            payout = auctioneer.purchaseBond(id_, amountLessFee, minAmountOut_);\n        }\n\n        // Allocate fees to protocol and referrer\n        rewards[referrer_][quoteToken] += toReferrer;\n        rewards[_protocol][quoteToken] += toProtocol;\n\n        // Transfer quote tokens from sender and ensure enough payout tokens are available\n        _handleTransfers(id_, amount_, payout, toReferrer + toProtocol);\n\n        // Handle payout to user (either transfer tokens if instant swap or issue bond token)\n        uint48 expiry = _handlePayout(recipient_, payout, payoutToken, vesting);\n\n        emit Bonded(id_, referrer_, amount_, payout);\n\n        return (payout, expiry);\n    }\n\n    /// @notice     Handles transfer of funds from user and market owner/callback\n    function _handleTransfers(\n        uint256 id_,\n        uint256 amount_,\n        uint256 payout_,\n        uint256 feePaid_\n    ) internal {\n        // Get info from auctioneer\n        (address owner, address callbackAddr, ERC20 payoutToken, ERC20 quoteToken, , ) = _aggregator\n            .getAuctioneer(id_)\n            .getMarketInfoForPurchase(id_);\n\n        // Calculate amount net of fees\n        uint256 amountLessFee = amount_ - feePaid_;\n\n        // Have to transfer to teller first since fee is in quote token\n        // Check balance before and after to ensure full amount received, revert if not\n        // Handles edge cases like fee-on-transfer tokens (which are not supported)\n        uint256 quoteBalance = quoteToken.balanceOf(address(this));\n        quoteToken.safeTransferFrom(msg.sender, address(this), amount_);\n        if (quoteToken.balanceOf(address(this)) < quoteBalance + amount_)\n            revert Teller_UnsupportedToken();\n\n        // If callback address supplied, transfer tokens from teller to callback, then execute callback function,\n        // and ensure proper amount of tokens transferred in.\n        if (callbackAddr != address(0)) {\n            // Send quote token to callback (transferred in first to allow use during callback)\n            quoteToken.safeTransfer(callbackAddr, amountLessFee);\n\n            // Call the callback function to receive payout tokens for payout\n            uint256 payoutBalance = payoutToken.balanceOf(address(this));\n            IBondCallback(callbackAddr).callback(id_, amountLessFee, payout_);\n\n            // Check to ensure that the callback sent the requested amount of payout tokens back to the teller\n            if (payoutToken.balanceOf(address(this)) < (payoutBalance + payout_))\n                revert Teller_InvalidCallback();\n        } else {\n            // If no callback is provided, transfer tokens from market owner to this contract\n            // for payout.\n            // Check balance before and after to ensure full amount received, revert if not\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\n            uint256 payoutBalance = payoutToken.balanceOf(address(this));\n            payoutToken.safeTransferFrom(owner, address(this), payout_);\n            if (payoutToken.balanceOf(address(this)) < (payoutBalance + payout_))\n                revert Teller_UnsupportedToken();\n\n            quoteToken.safeTransfer(owner, amountLessFee);\n        }\n    }\n\n    /// @notice             Handle payout to recipient\n    /// @dev                Implementation-agnostic. Must be implemented in contracts that\n    ///                     extend this base since it is called by purchase.\n    /// @param recipient_   Address to receive payout\n    /// @param payout_      Amount of payoutToken to be paid\n    /// @param underlying_   Token to be paid out\n    /// @param vesting_     Time parameter for when the payout is available, could be a\n    ///                     timestamp or duration depending on the implementation\n    /// @return expiry      Timestamp when the payout will vest\n    function _handlePayout(\n        address recipient_,\n        uint256 payout_,\n        ERC20 underlying_,\n        uint48 vesting_\n    ) internal virtual returns (uint48 expiry);\n\n    /// @notice             Derive name and symbol of token for market\n    /// @param underlying_   Underlying token to be paid out when the Bond Token vests\n    /// @param expiry_      Timestamp that the Bond Token vests at\n    /// @return name        Bond token name, format is \"Token YYYY-MM-DD\"\n    /// @return symbol      Bond token symbol, format is \"TKN-YYYYMMDD\"\n    function _getNameAndSymbol(ERC20 underlying_, uint256 expiry_)\n        internal\n        view\n        returns (string memory name, string memory symbol)\n    {\n        // Convert a number of days into a human-readable date, courtesy of BokkyPooBah.\n        // Source: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\n\n        uint256 year;\n        uint256 month;\n        uint256 day;\n        {\n            int256 __days = int256(expiry_ / 1 days);\n\n            int256 num1 = __days + 68569 + 2440588; // 2440588 = OFFSET19700101\n            int256 num2 = (4 * num1) / 146097;\n            num1 = num1 - (146097 * num2 + 3) / 4;\n            int256 _year = (4000 * (num1 + 1)) / 1461001;\n            num1 = num1 - (1461 * _year) / 4 + 31;\n            int256 _month = (80 * num1) / 2447;\n            int256 _day = num1 - (2447 * _month) / 80;\n            num1 = _month / 11;\n            _month = _month + 2 - 12 * num1;\n            _year = 100 * (num2 - 49) + _year + num1;\n\n            year = uint256(_year);\n            month = uint256(_month);\n            day = uint256(_day);\n        }\n\n        string memory yearStr = _uint2str(year % 10000);\n        string memory monthStr = month < 10\n            ? string(abi.encodePacked(\"0\", _uint2str(month)))\n            : _uint2str(month);\n        string memory dayStr = day < 10\n            ? string(abi.encodePacked(\"0\", _uint2str(day)))\n            : _uint2str(day);\n\n        // Construct name/symbol strings.\n        name = string(\n            abi.encodePacked(underlying_.name(), \" \", yearStr, \"-\", monthStr, \"-\", dayStr)\n        );\n        symbol = string(abi.encodePacked(underlying_.symbol(), \"-\", yearStr, monthStr, dayStr));\n    }\n\n    // Some fancy math to convert a uint into a string, courtesy of Provable Things.\n    // Updated to work with solc 0.8.0.\n    // https://github.com/provable-things/ethereum-api/blob/master/provableAPI_0.6.sol\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}"
    },
    {
      "filename": "src/bases/BondBaseTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\n\nimport {IBondTeller} from \"../interfaces/IBondTeller.sol\";\nimport {IBondCallback} from \"../interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"../interfaces/IBondAggregator.sol\";\nimport {IBondAuctioneer} from \"../interfaces/IBondAuctioneer.sol\";\n\nimport {TransferHelper} from \"../lib/TransferHelper.sol\";\nimport {FullMath} from \"../lib/FullMath.sol\";\n\n/// @title Bond Teller\n/// @notice Bond Teller Base Contract\n/// @dev Bond Protocol is a permissionless system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Teller contract handles all interactions with end users and manages tokens\n///      issued to represent bond positions. Users purchase bonds by depositing Quote Tokens\n///      and receive a Bond Token (token type is implementation-specific) that represents\n///      their payout and the designated expiry. Once a bond vests, Investors can redeem their\n///      Bond Tokens for the underlying Payout Token. A Teller requires one or more Auctioneer\n///      contracts to be deployed to provide markets for users to purchase bonds from.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\nabstract contract BondBaseTeller is IBondTeller, Auth, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS ========== */\n\n    error Teller_InvalidCallback();\n    error Teller_TokenNotMatured(uint48 maturesOn);\n    error Teller_NotAuthorized();\n    error Teller_TokenDoesNotExist(ERC20 underlying, uint48 expiry);\n    error Teller_UnsupportedToken();\n    error Teller_InvalidParams();\n\n    /* ========== EVENTS ========== */\n    event Bonded(uint256 indexed id, address indexed referrer, uint256 amount, uint256 payout);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Fee paid to a front end operator in basis points (3 decimals). Set by the referrer, must be less than or equal to 5% (5e3).\n    /// @dev There are some situations where the fees may round down to zero if quantity of baseToken\n    ///      is < 1e5 wei (can happen with big price differences on small decimal tokens). This is purely\n    ///      a theoretical edge case, as the bond amount would not be practical.\n    mapping(address => uint48) public referrerFees;\n\n    /// @notice Fee paid to protocol in basis points (3 decimal places).\n    uint48 public protocolFee;\n\n    /// @notice 'Create' function fee discount in basis points (3 decimal places). Amount standard fee is reduced by for partners who just want to use the 'create' function to issue bond tokens.\n    uint48 public createFeeDiscount;\n\n    uint48 public constant FEE_DECIMALS = 1e5; // one percent equals 1000.\n\n    /// @notice Fees earned by an address, by token\n    mapping(address => mapping(ERC20 => uint256)) public rewards;\n\n    // Address the protocol receives fees at\n    address internal immutable _protocol;\n\n    // BondAggregator contract with utility functions\n    IBondAggregator internal immutable _aggregator;\n\n    constructor(\n        address protocol_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) Auth(guardian_, authority_) {\n        _protocol = protocol_;\n        _aggregator = aggregator_;\n\n        protocolFee = 0;\n    }\n\n    /// @inheritdoc IBondTeller\n    function setReferrerFee(uint48 fee_) external override nonReentrant {\n        if (fee_ > 5e3) revert Teller_InvalidParams();\n        referrerFees[msg.sender] = fee_;\n    }\n\n    /// @inheritdoc IBondTeller\n    function setProtocolFee(uint48 fee_) external override requiresAuth {\n        if (fee_ > 5e3) revert Teller_InvalidParams();\n        protocolFee = fee_;\n    }\n\n    /// @inheritdoc IBondTeller\n    function claimFees(ERC20[] memory tokens_, address to_) external override nonReentrant {\n        uint256 len = tokens_.length;\n        for (uint256 i; i < len; ++i) {\n            ERC20 token = tokens_[i];\n            uint256 send = rewards[msg.sender][token];\n\n            if (send != 0) {\n                rewards[msg.sender][token] = 0;\n                token.safeTransfer(to_, send);\n            }\n        }\n    }\n\n    /// @inheritdoc IBondTeller\n    function getFee(address referrer_) external view returns (uint48) {\n        return protocolFee + referrerFees[referrer_];\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n\n    /// @inheritdoc IBondTeller\n    function purchase(\n        address recipient_,\n        address referrer_,\n        uint256 id_,\n        uint256 amount_,\n        uint256 minAmountOut_\n    ) external virtual nonReentrant returns (uint256, uint48) {\n        ERC20 payoutToken;\n        ERC20 quoteToken;\n        uint48 vesting;\n        uint256 payout;\n\n        // Calculate fees for purchase\n        // 1. Calculate referrer fee\n        // 2. Calculate protocol fee as the total expected fee amount minus the referrer fee\n        //    to avoid issues with rounding from separate fee calculations\n        uint256 toReferrer = amount_.mulDiv(referrerFees[referrer_], FEE_DECIMALS);\n        uint256 toProtocol = amount_.mulDiv(protocolFee + referrerFees[referrer_], FEE_DECIMALS) -\n            toReferrer;\n\n        {\n            IBondAuctioneer auctioneer = _aggregator.getAuctioneer(id_);\n            address owner;\n            (owner, , payoutToken, quoteToken, vesting,"
    }
  ]
}