{
  "Title": "[M-09] Possible scenario for Signature Replay Attack",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229\n\n\n# Vulnerability details\n\n## Impact\nThe `QuestFactory.mintReceipt` function mints `RabbitHoleReceipt` tokens based upon signatures signed by `claimSignerAddress`.\n```solidity\n    function mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n        quests[questId_].addressMinted[msg.sender] = true;\n        quests[questId_].numberMinted++;\n        emit ReceiptMinted(msg.sender, questId_);\n        rabbitholeReceiptContract.mint(msg.sender, questId_);\n    }\n```\nIn the above function only the account's address and quest id values are used to generate and validate the signature. \n\nThis causes various issues which are mentioned below:\n\n1. There is no deadline for the signatures. Once a signature is signed by `claimSignerAddress` that signature can be provided to `QuestFactory.mintReceipt` function to mint an RabbitholeReceipt token at any point in the future.\n\n2. The signature can be replayed on other EVM compatible chains on which RabbitHole protocol is deployed. The [docs](https://github.com/rabbitholegg/quest-protocol/tree/8c4c1f71221570b14a0479c216583342bd652d8d#deployments) mention other EVM chain addresses of the contracts which means the protocol will be deployed on multiple chains.\n\n3. The signature can be replayed on multiple instances of QuestFactory contract. If multiple QuestFactory contracts are deployed on a single EVM chain then signature intended for one contract can be replayed on the other ones.\n\nNote that all these scenarios are true when `questId_` parameter stays same.\n\n#### Actual Impact\nExploitation using the above mentioned scenarios will lead to unintended minting of RabbitholeReceipt token. This is a crucial token for the protocol which is also used to claim rewards from Quest contracts. Hence any unintentional minting will cause loss of funds.\n\n## Proof of Concept\nThe test cases were added in `./test/QuestFactory.spec.ts` file and ran using command `npx hardhat test ./test/QuestFactory.spec.ts`.\n```typescript\n  describe.only('QuestFactory: Signature Replay Bug', () => {\n    it('Signature can be used in different QuestFactory instance or on different chain', async () => {\n      const randomUser = (await ethers.getSigners())[10];\n      const questA = \"A\";\n\n      // Sign message and create new Quest\n      const messageHash = utils.solidityKeccak256(['address', 'string'], [randomUser.address.toLowerCase(), questA])\n      const signature = await wallet.signMessage(utils.arrayify(messageHash))\n      await deployedFactoryContract.setRewardAllowlistAddress(deployedSampleErc20Contract.address, true)\n      await deployedFactoryContract.createQuest(\n        deployedSampleErc20Contract.address, expiryDate, startDate, totalRewards, rewardAmount, 'erc20', questA\n      )\n\n      // Use the signature on First QuestFactory\n      await deployedFactoryContract.connect(randomUser).mintReceipt(questA, messageHash, signature)\n      expect(await deployedRabbitHoleReceiptContract.balanceOf(randomUser.address)).to.equal(1)\n\n      const factoryPrevious = deployedFactoryContract\n      const RHRPrevious = deployedRabbitHoleReceiptContract\n\n      // Deploy a new QuestFactory (this could be on a different chain)\n      await deployRabbitHoleReceiptContract()\n      await deployFactoryContract()\n\n      expect(factoryPrevious.address).to.not.eq(deployedFactoryContract.address)            // Verify we have new instance\n      expect(RHRPrevious.address).to.not.eq(deployedRabbitHoleReceiptContract.address)\n\n      // Create new Quest in new QuestFactory\n      await deployedFactoryContract.setRewardAllowlistAddress(deployedSampleErc20Contract.address, true)\n      await deployedFactoryContract.createQuest(\n        deployedSampleErc20Contract.address, expiryDate, startDate, totalRewards, rewardAmount, 'erc20', questA\n      )\n\n      // Use the previously used signature again on new QuestFactory\n      await deployedFactoryContract.connect(randomUser).mintReceipt(questA, messageHash, signature)\n      expect(await deployedRabbitHoleReceiptContract.balanceOf(randomUser.address)).to.equal(1)\n      expect(await RHRPrevious.balanceOf(randomUser.address)).to.equal(1)\n    })\n\n    it('Signature can be used after 1 year', async () => {\n      const randomUser = (await ethers.getSigners())[10];\n      const questA = \"A\";\n\n      // Sign message and create new Quest\n      const messageHash = utils.solidityKeccak256(['address', 'string'], [randomUser.address.toLowerCase(), questA])\n      const signature = await wallet.signMessage(utils.arrayify(messageHash))\n      await deployedFactoryContract.setRewardAllowlistAddress(deployedSampleErc20Contract.address, true)\n      await deployedFactoryContract.createQuest(\n        deployedSampleErc20Contract.address, expiryDate, startDate, totalRewards, rewardAmount, 'erc20', questA\n      )\n\n      // Move ahead 1 year\n      await ethers.provider.send(\"evm_mine\", [expiryDate + 31536000])\n\n      // Use the signature\n      await deployedFactoryContract.connect(randomUser).mintReceipt(questA, messageHash, signature)\n      expect(await deployedRabbitHoleReceiptContract.balanceOf(randomUser.address)).to.equal(1)\n    })\n  })\n```\n\n## Tools Used\nHardhat\n\n## Recommended Mitigation Steps\nConsider including deadline, chainid and QuestFactory's address in the signature message. Ideally signatures should be created according to the [EIP712](https://eips.ethereum.org/EIPS/eip-712) standard.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/QuestFactory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {Erc20Quest} from './Erc20Quest.sol';\nimport {IQuestFactory} from './interfaces/IQuestFactory.sol';\nimport {Erc1155Quest} from './Erc1155Quest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\n\n/// @title QuestFactory\n/// @author RabbitHole.gg\n/// @dev This contract is used to create quests and mint receipts\ncontract QuestFactory is Initializable, OwnableUpgradeable, AccessControlUpgradeable, IQuestFactory {\n    bytes32 public constant CREATE_QUEST_ROLE = keccak256('CREATE_QUEST_ROLE');\n    // storage vars. Insert new vars at the end to keep the storage layout the same.\n    struct Quest {\n        mapping(address => bool) addressMinted;\n        address questAddress;\n        uint totalParticipants;\n        uint numberMinted;\n    }\n\n    address public claimSignerAddress;\n    address public protocolFeeRecipient;\n    mapping(string => Quest) public quests;\n    RabbitHoleReceipt public rabbitholeReceiptContract;\n    mapping(address => bool) public rewardAllowlist;\n    uint public questFee;\n    uint public questIdCount;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function initialize(\n        address claimSignerAddress_,\n        address rabbitholeReceiptContract_,\n        address protocolFeeRecipient_\n    ) public initializer {\n        __Ownable_init();\n        __AccessControl_init();\n        grantDefaultAdminAndCreateQuestRole(msg.sender);\n        claimSignerAddress = claimSignerAddress_;\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n        setProtocolFeeRecipient(protocolFeeRecipient_);\n        setQuestFee(2_000);\n        questIdCount = 1;\n    }\n\n    /// @dev Create either an erc20 or erc1155 quest, only accounts with the CREATE_QUEST_ROLE can create quests\n    /// @param rewardTokenAddress_ The contract address of the reward token\n    /// @param endTime_ The end time of the quest\n    /// @param startTime_ The start time of the quest\n    /// @param totalParticipants_ The total amount of participants (accounts) the quest will have\n    /// @param rewardAmountOrTokenId_ The reward amount for an erc20 quest or the token id for an erc1155 quest\n    /// @param contractType_ The type of quest, either erc20 or erc1155\n    /// @param questId_ The id of the quest\n    /// @return address the quest contract address\n    function createQuest(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountOrTokenId_,\n        string memory contractType_,\n        string memory questId_\n    ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {\n        if (quests[questId_].questAddress != address(0)) revert QuestIdUsed();\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc20'))) {\n            if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();\n\n            Erc20Quest newQuest = new Erc20Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract),\n                questFee,\n                protocolFeeRecipient\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc1155'))) {\n            if (msg.sender != owner()) revert OnlyOwnerCanCreate1155Quest();\n\n            Erc1155Quest newQuest = new Erc1155Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract)\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        revert QuestTypeInvalid();\n    }\n\n    /// @dev grant the create quest role to an account\n    /// @param account_ The account to grant or revoke the create quest role to\n    /// @param canCreateQuest_ Boolean to grant or revoke the create quest role. True grants access\n    function changeCreateQuestRole(address account_, bool canCreateQuest_) public onlyOwner {\n        if (canCreateQuest_) {\n            _grantRole(CREATE_QUEST_ROLE, account_);\n        } else {\n            _revokeRole(CREATE_QUEST_ROLE, account_);\n        }\n    }\n\n    /// @dev grant the default admin role and the create quest role to the owner\n    /// @param account_ The account to grant admin and create quest roles\n    function grantDefaultAdminAndCreateQuestRole(address account_) internal {\n        _grantRole(DEFAULT_ADMIN_ROLE, account_);\n        _grantRole(CREATE_QUEST_ROLE, account_);\n    }\n\n    /// @dev set the claim signer address\n    /// @param claimSignerAddress_ The address of the claim signer\n    function setClaimSignerAddress(address claimSignerAddress_) public onlyOwner {\n        claimSignerAddress = claimSignerAddress_;\n    }\n\n    /// @dev set the protocol fee recipient\n    /// @param protocolFeeRecipient_ The address of the protocol fee recipient\n    function setProtocolFeeRecipient(address protocolFeeRecipient_) public onlyOwner {\n        if (protocolFeeRecipient_ == address(0)) revert AddressZeroNotAllowed();\n        protocolFeeRecipient = protocolFeeRecipient_;\n    }\n\n    /// @dev set the rabbithole receipt contract\n    /// @param rabbitholeReceiptContract_ The address of the rabbithole receipt contract\n    function setRabbitHoleReceiptContract(address rabbitholeReceiptContract_) public onlyOwner {\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n    }\n\n    /// @dev set or remave a contract address to be used as a reward\n    /// @param rewardAddress_ The contract address to set\n    /// @param allowed_ Whether the contract address is allowed or not\n    function setRewardAllowlistAddress(address rewardAddress_, bool allowed_) public onlyOwner {\n        rewardAllowlist[rewardAddress_] = allowed_;\n    }\n\n    /// @dev set the quest fee\n    /// @notice the quest fee should be in Basis Point units: https://www.investopedia.com/terms/b/basispoint.asp\n    /// @param questFee_ The quest fee value\n    function setQuestFee(uint256 questFee_) public onlyOwner {\n        if (questFee_ > 10_000) revert QuestFeeTooHigh();\n        questFee = questFee_;\n    }\n\n    /// @dev return the number of minted receipts for a quest\n    /// @param questId_ The id of the quest\n    function getNumberMinted(string memory questId_) external view returns (uint) {\n        return quests[questId_].numberMinted;\n    }\n\n    /// @dev return data in the quest struct for a questId\n    /// @param questId_ The id of the quest\n    function questInfo(string memory questId_) external view returns (address, uint, uint) {\n        return (\n            quests[questId_].questAddress,\n            quests[questId_].totalParticipants,\n            quests[questId_].numberMinted\n        );\n    }\n\n    /// @dev recover the signer from a hash and signature\n    /// @param hash_ The hash of the message\n    /// @param signature_ The signature of the hash\n    function recoverSigner(bytes32 hash_, bytes memory signature_) public pure returns (address) {\n        bytes32 messageDigest = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash_));\n        return ECDSAUpgradeable.recover(messageDigest, signature_);\n    }\n\n    /// @dev mint a RabbitHole Receipt. Note: this contract must be set as Minter on the receipt contract\n    /// @param questId_ The id of the quest\n    /// @param hash_ The hash of the message\n    /// @param signature_ The signature of the hash\n    function mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n        quests[questId_].addressMinted[msg.sender] = true;\n        quests[questId_].numberMinted++;\n        emit ReceiptMinted(msg.sender, questId_);\n        rabbitholeReceiptContract.mint(msg.sender, questId_);\n    }\n}"
    }
  ]
}