{
  "Title": "H-9: Inflated price due to unnecessary precision scaling",
  "Content": "# Issue H-9: Inflated price due to unnecessary precision scaling \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/600 \n\n## Found by \n0xVolodya, Aymen0909, bin2chen, enfrasico, nobody2018, saidam017, talfao, xiaoming90\n\nThe price returned by the stat calculators will be excessively inflated, which could lead to multiple implications that lead to losses to the protocol.\n\n## Vulnerability Detail\n\nThe `price` at Line 137 below is denominated in 18 decimals as the `getPriceInEth` function always returns the price in 18 decimals precision.\n\nThere is no need to scale the accumulated price by 1e18.\n\n- It will cause the average price (`existing._initAcc`) to be inflated significantly\n- The numerator will almost always be larger than the denominator (INIT_SAMPLE_COUNT = 18). There is no risk of it rounding to zero, so any scaling is unnecessary.\n\nAssume that throughout the initialization process, the `getPriceInEth(XYZ)` always returns 2 ETH (2e18). After 18 rounds (`INIT_SAMPLE_COUNT == 18`) of initialization, `existing._initAcc` will equal 36 ETH (36e18). As such, the `averagePrice` will be as follows:\n\n```solidity\naveragePrice = existing._initAcc * 1e18 / INIT_SAMPLE_COUNT;\naveragePrice = 36e18 * 1e18 / 18\naveragePrice = 36e36 / 18\naveragePrice = 2e36\n```\n\n`existing.fastFilterPrice` and `existing.slowFilterPrice` will be set to `2e36` at Lines 157 and 158 below.\n\nIn the post-init phase, the `getPriceInEth` function return 3 ETH (3e18). Thus, the following code will be executed at Line 144s and 155 below:\n\n```solidity\nexisting.slowFilterPrice = Stats.getFilteredValue(SLOW_ALPHA, existing.slowFilterPrice, price);\nexisting.fastFilterPrice = Stats.getFilteredValue(FAST_ALPHA, existing.fastFilterPrice, price);\n\nexisting.slowFilterPrice = Stats.getFilteredValue(SLOW_ALPHA, 2e36, 3e18); // SLOW_ALPHA = 645e14; // 0.0645\nexisting.fastFilterPrice = Stats.getFilteredValue(FAST_ALPHA, 2e36, 3e18); // FAST_ALPHA = 33e16; // 0.33\n```\n\nAs shown above, the existing filter prices are significantly inflated by the scale of 1e18, which results in the prices being extremely skewed.\n\nUsing the formula of fast filter, the final fast filter price computed will be as follows:\n\n```solidity\n((priorValue * (1e18 - alpha)) + (currentValue * alpha)) / 1e18\n((priorValue * (1e18 - 33e16)) + (currentValue * 33e16)) / 1e18\n((priorValue * 67e16) + (currentValue * 33e16)) / 1e18\n((2e36 * 67e16) + (3e18 * 33e16)) / 1e18\n1.34e36 (1340000000000000000 ETH)\n```\n\nThe token is supposed only to be worth around 3 ETH. However, the fast filter price wrongly determine that it is worth around 1340000000000000000 ETH\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/stats/calculators/IncentivePricingStats.sol#L125\n\n```solidity\nFile: IncentivePricingStats.sol\n125:     function updatePricingInfo(IRootPriceOracle pricer, address token) internal {\n..SNIP..\n137:         uint256 price = pricer.getPriceInEth(token);\n138: \n139:         // update the timestamp no matter what phase we're in\n140:         existing.lastSnapshot = uint40(block.timestamp);\n141: \n142:         if (existing._initComplete) {\n143:             // post-init phase, just update the filter values\n144:             existing.slowFilterPrice = Stats.getFilteredValue(SLOW_ALPHA, existing.slowFilterPrice, price);\n145:             existing.fastFilterPrice = Stats.getFilteredValue(FAST_ALPHA, existing.fastFilterPrice, price);\n146:         } else {\n147:             // still the initialization phase\n148:             existing._initCount += 1;\n149:             existing._initAcc += price;\n150: \n151:             // snapshot count is tracked internally and cannot be manipulated\n152:             // slither-disable-next-line incorrect-equality\n153:             if (existing._initCount == INIT_SAMPLE_COUNT) { // @audit-info INIT_SAMPLE_COUNT = 18;\n154:                 // if this sample hits the target number, then complete initialize and set the filters\n155:                 existing._initComplete = true;\n156:                 uint256 averagePrice = existing._initAcc * 1e18 / INIT_SAMPLE_COUNT;\n157:                 existing.fastFilterPrice = averagePrice;\n158:                 existing.slowFilterPrice = averagePrice;\n159:             }\n160:         }\n```\n\n## Impact\n\nThe price returned by the stat calculators will be excessively inflated. The purpose of the stats/calculators contracts is to store, augment, and clean data relevant to the LMPs. When the solver proposes a rebalance, the strategy uses the stats contracts to calculate a composite return (score) for the proposed destinations. Using that composite return, it determines if the swap is beneficial for the vault.\n\nIf a stat calculator provides incorrect and inflated pricing, it can cause multiple implications that lead to losses to the protocol, such as false signals allowing the unprofitable rebalance to be executed.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/stats/calculators/IncentivePricingStats.sol#L125\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove the 1e18 scaling.\n\n```diff\nif (existing._initCount == INIT_SAMPLE_COUNT) {\n    // if this sample hits the target number, then complete initialize and set the filters\n    existing._initComplete = true;\n-    uint256 averagePrice = existing._initAcc * 1e18 / INIT_SAMPLE_COUNT;\n+    uint256 averagePrice = existing._initAcc / INIT_SAMPLE_COUNT;\n    existing.fastFilterPrice = averagePrice;\n    existing.slowFilterPrice = averagePrice;\n}\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/stats/calculators/IncentivePricingStats.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { Stats } from \"src/stats/Stats.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { IRootPriceOracle } from \"src/interfaces/oracles/IRootPriceOracle.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { IIncentivesPricingStats } from \"src/interfaces/stats/IIncentivesPricingStats.sol\";\n\n/// @notice Calculates EWMA prices for incentives tokens\ncontract IncentivePricingStats is IIncentivesPricingStats, SecurityBase {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice MIN_INTERVAL is the minimum amount of time (seconds) before a new snapshot is taken\n    uint256 public constant MIN_INTERVAL = 8 * 60 * 60; // 8 hours\n\n    /// @notice INIT_SAMPLE_COUNT is the number of samples required to complete initialization, samples are averaged to\n    /// initialize the filtered values\n    uint256 public constant INIT_SAMPLE_COUNT = 18;\n\n    /// @return FAST_ALPHA the alpha for the fast updating filtered price\n    uint256 public constant FAST_ALPHA = 33e16; // 0.33\n\n    /// @return SLOW_ALPHA the alpha for the slow updating filtered price\n    uint256 public constant SLOW_ALPHA = 645e14; // 0.0645\n\n    ISystemRegistry public immutable systemRegistry;\n\n    EnumerableSet.AddressSet private registeredTokens;\n\n    // incentive token address => pricing information\n    mapping(address => TokenSnapshotInfo) private tokenSnapshotInfo;\n\n    modifier onlyStatsSnapshot() {\n        if (!_hasRole(Roles.STATS_SNAPSHOT_ROLE, msg.sender)) {\n            revert Errors.MissingRole(Roles.STATS_SNAPSHOT_ROLE, msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyUpdater() {\n        if (!_hasRole(Roles.STATS_INCENTIVE_TOKEN_UPDATER, msg.sender)) {\n            revert Errors.MissingRole(Roles.STATS_INCENTIVE_TOKEN_UPDATER, msg.sender);\n        }\n        _;\n    }\n\n    constructor(ISystemRegistry _systemRegistry) SecurityBase(address(_systemRegistry.accessController())) {\n        systemRegistry = _systemRegistry;\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function setRegisteredToken(address token) external onlyUpdater {\n        if (!registeredTokens.add(token)) revert TokenAlreadyRegistered(token);\n\n        IRootPriceOracle pricer = systemRegistry.rootPriceOracle();\n\n        // if the token isn't registered with the pricing oracle this will fail which is the desired outcome\n        updatePricingInfo(pricer, token);\n\n        // pricer handles reentrancy issues\n        // slither-disable-next-line reentrancy-events\n        emit TokenAdded(token);\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function removeRegisteredToken(address token) external onlyUpdater {\n        if (!registeredTokens.remove(token)) revert TokenNotFound(token);\n        delete tokenSnapshotInfo[token];\n        emit TokenRemoved(token);\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function getRegisteredTokens() external view returns (address[] memory tokens) {\n        return registeredTokens.values();\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function getTokenPricingInfo()\n        external\n        view\n        returns (address[] memory tokenAddresses, TokenSnapshotInfo[] memory info)\n    {\n        tokenAddresses = registeredTokens.values();\n        uint256 numTokens = registeredTokens.length();\n        info = new TokenSnapshotInfo[](numTokens);\n        for (uint256 i = 0; i < numTokens; ++i) {\n            address token = registeredTokens.at(i);\n            info[i] = tokenSnapshotInfo[token];\n        }\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function snapshot(address[] calldata tokensToSnapshot) external onlyStatsSnapshot {\n        if (tokensToSnapshot.length == 0) revert Errors.InvalidParam(\"tokensToSnapshot\");\n        IRootPriceOracle pricer = systemRegistry.rootPriceOracle();\n\n        uint256 numTokens = tokensToSnapshot.length;\n        for (uint256 i = 0; i < numTokens; ++i) {\n            address token = tokensToSnapshot[i];\n            Errors.verifyNotZero(token, \"token\");\n            if (!registeredTokens.contains(token)) {\n                revert TokenNotFound(token);\n            }\n            updatePricingInfo(pricer, token);\n        }\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function getPrice(address token, uint40 staleCheck) external view returns (uint256 fastPrice, uint256 slowPrice) {\n        if (!registeredTokens.contains(token)) revert TokenNotFound(token);\n\n        TokenSnapshotInfo memory info = tokenSnapshotInfo[token];\n\n        // slither-disable-next-line timestamp\n        if (block.timestamp - info.lastSnapshot > staleCheck) revert IncentiveTokenPriceStale(token);\n\n        return (info.fastFilterPrice, info.slowFilterPrice);\n    }\n\n    function updatePricingInfo(IRootPriceOracle pricer, address token) internal {\n        // tokenPricing info can be in 3 possible phases\n        // 1) initialize phase, just want to accumulate the price to calculate an average\n        // 2) exactly met the number of samples for init, update fast/slow filters with the average price\n        // 3) post-init, only update the filter values\n        TokenSnapshotInfo storage existing = tokenSnapshotInfo[token];\n\n        // slither-disable-next-line timestamp\n        if (existing.lastSnapshot + MIN_INTERVAL > block.timestamp) revert TokenSnapshotNotReady(token);\n\n        // pricer handles reentrancy issues\n        // slither-disable-next-line reentrancy-no-eth\n        uint256 price = pricer.getPriceInEth(token);\n\n        // update the timestamp no matter what phase we're in\n        existing.lastSnapshot = uint40(block.timestamp);\n\n        if (existing._initComplete) {\n            // post-init phase, just update the filter values\n            existing.slowFilterPrice = Stats.getFilteredValue(SLOW_ALPHA, existing.slowFilterPrice, price);\n            existing.fastFilterPrice = Stats.getFilteredValue(FAST_ALPHA, existing.fastFilterPrice, price);\n        } else {\n            // still the initialization phase\n            existing._initCount += 1;\n            existing._initAcc += price;\n\n            // snapshot count is tracked internally and cannot be manipulated\n            // slither-disable-next-line incorrect-equality\n            if (existing._initCount == INIT_SAMPLE_COUNT) {\n                // if this sample hits the target number, then complete initialize and set the filters\n                existing._initComplete = true;\n                uint256 averagePrice = existing._initAcc * 1e18 / INIT_SAMPLE_COUNT;\n                existing.fastFilterPrice = averagePrice;\n                existing.slowFilterPrice = averagePrice;\n            }\n        }\n\n        emitSnapshotTaken(token, existing);\n    }\n\n    function emitSnapshotTaken(address token, TokenSnapshotInfo memory info) internal {\n        // pricer handles reentrancy issues\n        // slither-disable-next-line reentrancy-events\n        emit TokenSnapshot(\n            token, info.lastSnapshot, info.fastFilterPrice, info.slowFilterPrice, info._initCount, info._initComplete\n        );\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/stats/calculators/IncentivePricingStats.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { Stats } from \"src/stats/Stats.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { IRootPriceOracle } from \"src/interfaces/oracles/IRootPriceOracle.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { IIncentivesPricingStats } from \"src/interfaces/stats/IIncentivesPricingStats.sol\";\n\n/// @notice Calculates EWMA prices for incentives tokens\ncontract IncentivePricingStats is IIncentivesPricingStats, SecurityBase {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice MIN_INTERVAL is the minimum amount of time (seconds) before a new snapshot is taken\n    uint256 public constant MIN_INTERVAL = 8 * 60 * 60; // 8 hours\n\n    /// @notice INIT_SAMPLE_COUNT is the number of samples required to complete initialization, samples are averaged to\n    /// initialize the filtered values\n    uint256 public constant INIT_SAMPLE_COUNT = 18;\n\n    /// @return FAST_ALPHA the alpha for the fast updating filtered price\n    uint256 public constant FAST_ALPHA = 33e16; // 0.33\n\n    /// @return SLOW_ALPHA the alpha for the slow updating filtered price\n    uint256 public constant SLOW_ALPHA = 645e14; // 0.0645\n\n    ISystemRegistry public immutable systemRegistry;\n\n    EnumerableSet.AddressSet private registeredTokens;\n\n    // incentive token address => pricing information\n    mapping(address => TokenSnapshotInfo) private tokenSnapshotInfo;\n\n    modifier onlyStatsSnapshot() {\n        if (!_hasRole(Roles.STATS_SNAPSHOT_ROLE, msg.sender)) {\n            revert Errors.MissingRole(Roles.STATS_SNAPSHOT_ROLE, msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyUpdater() {\n        if (!_hasRole(Roles.STATS_INCENTIVE_TOKEN_UPDATER, msg.sender)) {\n            revert Errors.MissingRole(Roles.STATS_INCENTIVE_TOKEN_UPDATER, msg.sender);\n        }\n        _;\n    }\n\n    constructor(ISystemRegistry _systemRegistry) SecurityBase(address(_systemRegistry.accessController())) {\n        systemRegistry = _systemRegistry;\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function setRegisteredToken(address token) external onlyUpdater {\n        if (!registeredTokens.add(token)) revert TokenAlreadyRegistered(token);\n\n        IRootPriceOracle pricer = systemRegistry.rootPriceOracle();\n\n        // if the token isn't registered with the pricing oracle this will fail which is the desired outcome\n        updatePricingInfo(pricer, token);\n\n        // pricer handles reentrancy issues\n        // slither-disable-next-line reentrancy-events\n        emit TokenAdded(token);\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function removeRegisteredToken(address token) external onlyUpdater {\n        if (!registeredTokens.remove(token)) revert TokenNotFound(token);\n        delete tokenSnapshotInfo[token];\n        emit TokenRemoved(token);\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function getRegisteredTokens() external view returns (address[] memory tokens) {\n        return registeredTokens.values();\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function getTokenPricingInfo()\n        external\n        view\n        returns (address[] memory tokenAddresses, TokenSnapshotInfo[] memory info)\n    {\n        tokenAddresses = registeredTokens.values();\n        uint256 numTokens = registeredTokens.length();\n        info = new TokenSnapshotInfo[](numTokens);\n        for (uint256 i = 0; i < numTokens; ++i) {\n            address token = registeredTokens.at(i);\n            info[i] = tokenSnapshotInfo[token];\n        }\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function snapshot(address[] calldata tokensToSnapshot) external onlyStatsSnapshot {\n        if (tokensToSnapshot.length == 0) revert Errors.InvalidParam(\"tokensToSnapshot\");\n        IRootPriceOracle pricer = systemRegistry.rootPriceOracle();\n\n        uint256 numTokens = tokensToSnapshot.length;\n        for (uint256 i = 0; i < numTokens; ++i) {\n            address token = tokensToSnapshot[i];\n            Errors.verifyNotZero(token, \"token\");\n            if (!registeredTokens.contains(token)) {\n                revert TokenNotFound(token);\n            }\n            updatePricingInfo(pricer, token);\n        }\n    }\n\n    /// @inheritdoc IIncentivesPricingStats\n    function getPrice(address token, uint40 staleCheck) external view returns (uint256 fastPrice, uint256 slowPrice) {\n        if (!registeredTokens.contains(token)) revert TokenNotFound(token);\n\n        TokenSnapshotInfo memory info = tokenSnapshotInfo[token];\n\n        // slither-disable-next-line timestamp\n        if (block.timestamp - info.lastSnapshot > staleCheck) revert IncentiveTokenPriceStale(token);\n\n        return (info.fastFilterPrice, info.slowFilterPrice);\n    }\n\n    function updatePricingInfo(IRootPriceOracle pricer, address token) internal {\n        // tokenPricing info can be in 3 possible phases\n        // 1) initialize phase, just want to accumulate the price to calculate an average\n        // 2) exactly met the number of samples for init, update fast/slow filters with the average price\n        // 3) post-init, only update the filter values\n        TokenSnapshotInfo storage existing = tokenSnapshotInfo[token];\n\n        // slither-disable-next-line timestamp\n        if (existing.lastSnapshot + MIN_INTERVAL > block.timestamp) revert TokenSnapshotNotReady(token);\n\n        // pricer handles reentrancy issues\n        // slither-disable-next-line reentrancy-no-eth\n        uint256 price = pricer.getPriceInEth(token);\n\n        // update the timestamp no matter what phase we're in\n        existing.lastSnapshot = uint40(block.timestamp);\n\n        if (existing._initComplete) {\n            // post-init phase, just update the filter values\n            existing.slowFilterPrice = Stats.getFilteredValue(SLOW_ALPHA, existing.slowFilterPrice, price);\n            existing.fastFilterPrice = Stats.getFilteredValue(FAST_ALPHA, existing.fastFilterPrice, price);\n        } else {\n            // still the initialization phase\n            existing._initCount += 1;\n            existing._initAcc += price;\n\n            // snapshot count is tracked internally and cannot be manipulated\n            // slither-disable-next-line incorrect-equality\n            if (existing._initCount == INIT_SAMPLE_COUNT) {\n                // if this sample hits the target number, then complete initialize and set the filters\n                existing._initComplete = true;\n                uint256 averagePrice = existing._initAcc * 1e18 / INIT_SAMPLE_COUNT;\n                existing.fastFilterPrice = averagePrice;\n                existing.slowFilterPrice = averagePrice;\n            }\n        }\n\n        emitSnapshotTaken(token, existing);\n    }\n\n    function emitSnapshotTaken(address token, TokenSnapshotInfo memory info) internal {\n        // pricer handles reentrancy issues\n        // slither-disable-next-line reentrancy-events\n        emit TokenSnapshot(\n            token, info.lastSnapshot, info.fastFilterPrice, info.slowFilterPrice, info._initCount, info._initComplete\n        );\n    }\n}"
    }
  ]
}