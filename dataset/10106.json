{
  "Title": "[M-11] Rebalance will fail if a market has high utilization",
  "Content": "_Submitted by cmichel_\n\nThe `AssetManager.rebalance` function iterates through the markets and withdraws **all** tokens in the `moneyMarkets[i].withdrawAll` call.\n\nNote that in peer-to-peer lending protocols like Compound/Aave the borrower takes the tokens from the supplier and it might not be possible for the supplier to withdraw all tokens if the utilisation ratio of the market is high.\n\nSee this check for example in [Compound's cToken](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L680).\n\n#### Impact\nRebalancing will fail if a single market has a liquidity crunch.\n\n#### Recommended Mitigation Steps\nWithdraw only what's available and rebalance on that instead of trying to pull all tokens from each market first.\nAdmittedly, this might be hard to compute for some protocols.\n\n**[kingjacob (Union) acknowledged](https://github.com/code-423n4/2021-10-union-findings/issues/63)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/63#issuecomment-966611620):**\n > Agree with the finding, at this time this potential vulnerability is a feature of the protocol\n>\n> I recommend in the long term, that the sponsor rewrites the `rebalance` function to account for liquidity crunches\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-union",
  "Code": [
    {
      "filename": "contracts/CToken.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\nabstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == NO_ERROR, \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == NO_ERROR, \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return 0 if the transfer succeeded, else revert\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            revert TransferComptrollerRejection(allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            revert TransferNotAllowed();\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint allowanceNew = startingAllowance - tokens;\n        uint srcTokensNew = accountTokens[src] - tokens;\n        uint dstTokensNew = accountTokens[dst] + tokens;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint).max) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) override external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) override external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) override external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) override external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\n        return (\n            NO_ERROR,\n            accountTokens[account],\n            borrowBalanceStoredInternal(account),\n            exchangeRateStoredInternal()\n        );\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() virtual internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() override external view returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() override external view returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() override external nonReentrant returns (uint) {\n        accrueInterest();\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\n        accrueInterest();\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) override public view returns (uint) {\n        return borrowBalanceStoredInternal(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (uint) {\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return 0;\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n        return principalTimesIndex / borrowSnapshot.interestIndex;\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() override public view returns (uint) {\n        return exchangeRateStoredInternal();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStoredInternal() virtual internal view returns (uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return initialExchangeRateMantissa;\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n            uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\n\n            return exchangeRate;\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() override external view returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() virtual override public returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return NO_ERROR;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n        uint totalBorrowsNew = interestAccumulated + borrowsPrior;\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mintFresh(address minter, uint mintAmount) internal {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            revert MintComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert MintFreshnessCheck();\n        }\n\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         * And write them into storage\n         */\n        totalSupply = totalSupply + mintTokens;\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, actualMintAmount, mintTokens);\n        emit Transfer(address(this), minter, mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     */\n    function redeemInternal(uint redeemTokens) internal nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(payable(msg.sender), redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     */\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(payable(msg.sender), 0, redeemAmount);\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal() });\n\n        uint redeemTokens;\n        uint redeemAmount;\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\n            redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\n        if (allowed != 0) {\n            revert RedeemComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert RedeemFreshnessCheck();\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < redeemAmount) {\n            revert RedeemTransferOutNotPossible();\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n         */\n        totalSupply = totalSupply - redeemTokens;\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(redeemer, redeemAmount);\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), redeemTokens);\n        emit Redeem(redeemer, redeemAmount, redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    function borrowInternal(uint borrowAmount) internal nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        borrowFresh(payable(msg.sender), borrowAmount);\n    }\n\n    /**\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n    function borrowFresh(address payable borrower, uint borrowAmount) internal {\n        /* Fail if borrow not allowed */\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            revert BorrowComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert BorrowFreshnessCheck();\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        if (getCashPrior() < borrowAmount) {\n            revert BorrowCashNotAvailable();\n        }\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowNew = accountBorrow + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n        uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n        uint totalBorrowsNew = totalBorrows + borrowAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n        `*/\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(borrower, borrowAmount);\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     */\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\n     * @return (uint) the actual repayment amount.\n     */\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        /* Fail if repayBorrow not allowed */\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            revert RepayBorrowComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert RepayBorrowFreshnessCheck();\n        }\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n        uint totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\n\n        return actualRepayAmount;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant {\n        accrueInterest();\n\n        uint error = cTokenCollateral.accrueInterest();\n        if (error != NO_ERROR) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            revert LiquidateAccrueCollateralInterestFailed(error);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     */\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal {\n        /* Fail if liquidate not allowed */\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            revert LiquidateComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert LiquidateFreshnessCheck();\n        }\n\n        /* Verify cTokenCollateral market's block number equals current block number */\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            revert LiquidateCollateralFreshnessCheck();\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            revert LiquidateLiquidatorIsBorrower();\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            revert LiquidateCloseAmountIsZero();\n        }\n\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == type(uint).max) {\n            revert LiquidateCloseAmountIsUintMax();\n        }\n\n        /* Fail if repayBorrow fails */\n        uint actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\n        require(amountSeizeError == NO_ERROR, \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n        /* Revert if borrower collateral token balance < seizeTok"
    }
  ]
}