{
  "Title": "[L-03] No zero address check for adding DEX contract in `addDex`, `batchAddDex`, `removeDex` and `batchRemoveDex`.",
  "Content": "\n[addDex](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Facets/DexManagerFacet.sol#L17-L22)\n\nZero address check would prevent adding harmful DEX contracts by mistake. If zero address DEXs are whitelisted, users could burn their tokens on accident.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Facets/DexManagerFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../Libraries/LibStorage.sol\";\nimport \"../Libraries/LibDiamond.sol\";\n\n/**\n * @title Optics Router Facet\n * @author Li.Finance (https://li.finance)\n * @notice Facet contract for managing approved DEXs to be used in swaps.\n */\ncontract DexManagerFacet {\n    LibStorage internal s;\n\n    /// @notice Register the address of a DEX contract to be approved for swapping.\n    /// @param _dex The address of the DEX contract to be approved.\n    function addDex(address _dex) external {\n        LibDiamond.enforceIsContractOwner();\n\n        if (s.dexWhitelist[_dex] == true) {\n            return;\n        }\n\n        s.dexWhitelist[_dex] = true;\n        s.dexs.push(_dex);\n    }\n\n    /// @notice Batch register the addresss of DEX contracts to be approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be approved.\n    function batchAddDex(address[] calldata _dexs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint256 i; i < _dexs.length; i++) {\n            if (s.dexWhitelist[_dexs[i]] == true) {\n                continue;\n            }\n            s.dexWhitelist[_dexs[i]] = true;\n            s.dexs.push(_dexs[i]);\n        }\n    }\n\n    /// @notice Unregister the address of a DEX contract approved for swapping.\n    /// @param _dex The address of the DEX contract to be unregistered.\n    function removeDex(address _dex) external {\n        LibDiamond.enforceIsContractOwner();\n\n        if (s.dexWhitelist[_dex] == false) {\n            return;\n        }\n\n        s.dexWhitelist[_dex] = false;\n        for (uint256 i; i < s.dexs.length; i++) {\n            if (s.dexs[i] == _dex) {\n                _removeDex(i);\n                return;\n            }\n        }\n    }\n\n    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be unregistered.\n    function batchRemoveDex(address[] calldata _dexs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint256 i; i < _dexs.length; i++) {\n            if (s.dexWhitelist[_dexs[i]] == false) {\n                continue;\n            }\n            s.dexWhitelist[_dexs[i]] = false;\n            for (uint256 j; j < s.dexs.length; j++) {\n                if (s.dexs[j] == _dexs[i]) {\n                    _removeDex(j);\n                    return;\n                }\n            }\n        }\n    }\n\n    function approvedDexs() external view returns (address[] memory) {\n        return s.dexs;\n    }\n\n    function _removeDex(uint256 index) private {\n        // Move the last element into the place to delete\n        s.dexs[index] = s.dexs[s.dexs.length - 1];\n        // Remove the last element\n        s.dexs.pop();\n    }\n}"
    }
  ]
}