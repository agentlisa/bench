{
  "Title": "[M-05] Only `guardian` can change `guardian`",
  "Content": "\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L27> \n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol#L81-L86>\n\n`guardian` is mentioned as an area of concern in the [docs](https://github.com/code-423n4/2023-07-moonwell#overview):\n\n> Specific areas of concern include:\n> \n>\n> *   TemporalGovernor which is the cross chain governance contract. Specific areas of concern include delays, **the pause guardian**, ...\n\n`guardian` is a roll that has the ability to pause and unpause `TemporalGovernor`. In code, it uses the `owner` from OpenZeppelin `Ownable` as `guardian`. The issue is that [`Ownable::transferOwnership`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol#L81-L86) is not overridden. Only `guardian` (`owner`) can transfer the role.\n\nThis can be a conflict of interest if there is a falling out between governance and the guardian. If the `guardian` doesn't want to abstain, governance only option would be to call [`revokeGuardian`](https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L205-L221) which sets `owner` to `address(0)`. This permanently removes the ability to pause the contract which can be undesirable.\n\n### Proof of Concept\n\nSimple test in  `TemporalGovernorExec.t.sol`:\n\n```solidity\n    function testGovernanceCannotTransferGuardian() public {\n        address[] memory targets = new address[](1);\n        targets[0] = address(governor);\n        uint256[] memory values = new uint256[](1);\n        \n        bytes[] memory payloads = new bytes[](1);\n        payloads[0] = abi.encodeWithSelector(Ownable.transferOwnership.selector,address(newAdmin));\n\n        bytes memory payload = abi.encode(address(governor), targets, values, payloads);\n        mockCore.setStorage(true, trustedChainid, governor.addressToBytes(admin), \"reeeeeee\", payload);\n\n        governor.queueProposal(\"\");\n\n        vm.warp(block.timestamp + proposalDelay);\n\n        // governance cannot transfer guardian\n        vm.expectRevert(abi.encodeWithSignature(\"Error(string)\", \"Ownable: caller is not the owner\"));\n        governor.executeProposal(\"\");\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider overriding `transferOwnership` and either limit it to only governance (`msg.sender == address(this)`) or both `guardian` and governance.\n\n**[ElliotFriedman (Moonwell) confirmed and commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/315#issuecomment-1664715890):**\n > This is an interesting finding. Only `guardian` can change `guardian`, however, `guardian` can only pause once and is limited in abilities to being able to fast track execution, and unpause. After a single malicious pause, the `guardian` would no longer be able to pause, and 30 days later, governance would reopen.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-moonwell",
  "Code": [
    {
      "filename": "src/core/Governance/TemporalGovernor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IWormhole} from \"@protocol/core/Governance/IWormhole.sol\";\n\nimport {ITemporalGovernor} from \"@protocol/core/Governance/ITemporalGovernor.sol\";\n\n/// @notice contract that governs the Base deployment of moonwell leveraging the wormhole bridge\n/// as the source of truth. Wormhole will be fed in actions from the moonbeam chain and this contract\n/// will execute them on base.\n/// There are a few assumptions that are made in this contract:\n/// 1. Wormhole is secure and will not send malicious messages or be deactivated.\n/// 2. Moonbeam is secure.\n/// 3. Governance on Moonbeam cannot be compromised.\n/// if 1. is untrue and wormhole is deactivated, then this contract will be unable to upgrade the base instance\n/// if 1. is untrue and wormhole sends malicious messages, then this contract will be paused, and the guardian\n/// will have to fast track a proposal to hand ownership to a new governor, and wormhole will have to revoke\n/// the permissions on the compromised validator set.\n/// if 2. is untrue, then this contract will be paused until moonbeam is restored\n/// if 3. is untrue, then this contract will be paused until moonbeam governance is restored, if gov control\n/// cannot be restored, then this governance will be compromised.\ncontract TemporalGovernor is ITemporalGovernor, Ownable, Pausable {\n    using SafeCast for *;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// ----------- IMMUTABLES -----------\n\n    /// @notice reference to the wormhole bridge\n    IWormhole public immutable wormholeBridge;\n\n    /// @notice returns the amount of time a proposal must wait before being processed.\n    uint256 public immutable proposalDelay;\n\n    /// @notice returns the amount of time until this contract can be unpaused permissionlessly\n    uint256 public immutable permissionlessUnpauseTime;\n\n    /// ----------- SINGLE STORAGE SLOT -----------\n\n    /// @notice last paused time\n    uint248 public lastPauseTime;\n\n    /// @notice returns whether or not the guardian can pause.\n    /// starts true and then is turned false when the guardian pauses\n    /// governance can then reactivate it.\n    bool public guardianPauseAllowed = true;\n\n    /// ----------- MAPPINGS -----------\n\n    /// @notice Map of chain id => trusted sender\n    mapping(uint16 => EnumerableSet.Bytes32Set) private trustedSenders;\n\n    /// @notice Record of processed messages to prevent replaying\n    /// and enforce time limits are respected\n    mapping(bytes32 => ProposalInfo) public queuedTransactions;\n\n    constructor(\n        address wormholeCore,\n        uint256 _proposalDelay,\n        uint256 _permissionlessUnpauseTime,\n        TrustedSender[] memory _trustedSenders\n    ) Ownable() {\n        wormholeBridge = IWormhole(wormholeCore);\n        proposalDelay = _proposalDelay;\n        permissionlessUnpauseTime = _permissionlessUnpauseTime;\n\n        // Using https://book.wormhole.com/reference/contracts.html#testnet chain ids and local contracts\n        // Mark 0xf16165f1046f1b3cdb37da25e835b986e696313a as trusted to emit from eth mainnet\n        // Establish a list of trusted emitters from eash chain\n        for (uint256 i = 0; i < _trustedSenders.length; i++) {\n            trustedSenders[_trustedSenders[i].chainId].add(\n                addressToBytes(_trustedSenders[i].addr)\n            );\n        }\n    }\n\n    /// ------------- VIEW ONLY API -------------\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        bytes32 addr\n    ) public view returns (bool) {\n        return trustedSenders[chainId].contains(addr);\n    }\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        address addr\n    ) external view returns (bool) {\n        return isTrustedSender(chainId, addressToBytes(addr));\n    }\n\n    /// @notice returns the list of trusted senders for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @return The list of trusted senders\n    function allTrustedSenders(uint16 chainId)\n        external\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory trustedSendersList = new bytes32[](\n            trustedSenders[chainId].length()\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < trustedSendersList.length; i++) {\n                trustedSendersList[i] = trustedSenders[chainId].at(i);\n            }\n        }\n\n        return trustedSendersList;\n    }\n\n    /// @notice Wormhole addresses are denominated in 32 byte chunks. Converting the address to a bytes20\n    /// then to a bytes32 *left* aligns it, so we right shift to get the proper data\n    /// @param addr The address to convert\n    /// @return The address as a bytes32\n    function addressToBytes(address addr) public pure returns (bytes32) {\n        return bytes32(bytes20(addr)) >> 96;\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Updates the list of trusted senders\n    /// @param _trustedSenders The list of trusted senders, allowing one\n    /// trusted sender per chain id\n    function setTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].add(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    true /// added to list\n                );\n            }\n        }\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Removes trusted senders from the list\n    /// @param _trustedSenders The list of trusted senders, allowing multiple\n    /// trusted sender per chain id\n    function unSetTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].remove(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    false /// removed from list\n                );\n            }\n        }\n    }\n\n    /// @notice grant the guardians the pause ability\n    function grantGuardiansPause() external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update grant guardian pause\"\n        );\n\n        guardianPauseAllowed = true;\n        lastPauseTime = 0;\n\n        emit GuardianPauseGranted(block.timestamp);\n    }\n\n    /// ------------- GUARDIAN / GOVERNOR ONLY API -------------\n\n    /// @notice callable only via a gov proposal (governance) or by the guardian\n    /// this revokes guardian's ability, no more pausing or fast tracking and\n    /// unpauses the contract if paused\n    function revokeGuardian() external {\n        address oldGuardian = owner();\n        require(\n            msg.sender == oldGuardian || msg.sender == address(this),\n            \"TemporalGovernor: cannot revoke guardian\"\n        );\n\n        _transferOwnership(address(0));\n        guardianPauseAllowed = false;\n        lastPauseTime = 0;\n\n        if (paused()) {\n            _unpause();\n        }\n\n        emit GuardianRevoked(oldGuardian);\n    }\n\n    /// ------------- PERMISSIONLESS APIs -------------\n\n    /// @notice We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    /// @dev callable only when unpaused\n    function queueProposal(bytes memory VAA) external whenNotPaused {\n        _queueProposal(VAA);\n    }\n\n    /// @notice Taken mostly from the best practices docs from wormhole.\n    /// We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    function executeProposal(bytes memory VAA) public whenNotPaused {\n        _executeProposal(VAA, false);\n    }\n\n    /// @notice unpauses the contract, and blocks the guardian from pausing again until governance reapproves them\n    function permissionlessUnpause() external whenPaused {\n        /// lastPauseTime cannot be equal to 0 at this point because\n        /// block.timstamp on a real chain will always be gt 0 and\n        /// toggle pause will set lastPauseTime to block.timestamp\n        /// which means if the contract is paused on a live network,\n        /// its lastPauseTime cannot be 0\n        require(\n            lastPauseTime + permissionlessUnpauseTime <= block.timestamp,\n            \"TemporalGovernor: not past pause window\"\n        );\n\n        lastPauseTime = 0;\n        _unpause();\n\n        assert(!guardianPauseAllowed); /// this should never revert, statement for SMT solving\n\n        emit PermissionlessUnpaused(block.timestamp);\n    }\n\n    /// @notice Allow the guardian to process a VAA when the\n    /// Temporal Governor is paused this is only for use during\n    /// periods of emergency when the governance on moonbeam is\n    /// compromised and we need to stop additional proposals from going through.\n    /// @param VAA The signed Verified Action Approval to process\n    function fastTrackProposalExecution(bytes memory VAA) external onlyOwner {\n        _executeProposal(VAA, true); /// override timestamp checks and execute\n    }\n\n    /// @notice Allow the guardian to pause the contract\n    /// removes the guardians ability to call pause again until governance reaaproves them\n    /// starts the timer for the permissionless unpause\n    /// cannot call this function if guardian is revoked\n    function togglePause() external onlyOwner {\n        if (paused()) {\n            _unpause();\n        } else {\n            require(\n                guardianPauseAllowed,\n                \"TemporalGovernor: guardian pause not allowed\"\n            );\n\n            guardianPauseAllowed = false;\n            lastPauseTime = block.timestamp.toUint248();\n            _pause();\n        }\n\n        /// statement for SMT solver\n        assert(!guardianPauseAllowed); /// this should be an unreachable state\n    }\n\n    /// ------------- HELPER FUNCTIONS -------------\n\n    /// queue a proposal\n    function _queueProposal(bytes memory VAA) private {\n        /// Checks\n\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        // Ensure VAA parsing verification succeeded.\n        require(valid, reason);\n\n        address intendedRecipient;\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n\n        (intendedRecipient, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        // Very important to check to make sure that the VAA we're processing is specifically designed\n        // to be sent to this contract\n        require(intendedRecipient == address(this), \"TemporalGovernor: Incorrect destination\");\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        /// Check that the VAA hasn't already been processed (replay protection)\n        require(\n            queuedTransactions[vm.hash].queueTime == 0,\n            \"TemporalGovernor: Message already queued\"\n        );\n\n        /// Effect\n\n        // Add the VAA to queued messages so that it can't be replayed\n        queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n\n        emit QueuedTransaction(intendedRecipient, targets, values, calldatas);\n    }\n\n    function _executeProposal(bytes memory VAA, bool overrideDelay) private {\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        require(valid, reason); /// ensure VAA parsing verification succeeded\n\n        if (!overrideDelay) {\n            require(\n                queuedTransactions[vm.hash].queueTime != 0,\n                \"TemporalGovernor: tx not queued\"\n            );\n            require(\n                queuedTransactions[vm.hash].queueTime + proposalDelay <=\n                    block.timestamp,\n                \"TemporalGovernor: timelock not finished\"\n            );\n        } else if (queuedTransactions[vm.hash].queueTime == 0) {\n            /// if queue time is 0 due to fast track execution, set it to current block timestamp\n            queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n        }\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        require(\n            !queuedTransactions[vm.hash].executed,\n            \"TemporalGovernor: tx already executed\"\n        );\n\n        queuedTransactions[vm.hash].executed = true;\n\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n        (, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        /// Interaction (s)\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        for (uint256 i = 0; i < targets.length; i++) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes memory data = calldatas[i];\n\n            // Go make our call, and if it is not successful revert with the error bubbling up\n            (bool success, bytes memory returnData) = target.call{value: value}(\n                data\n            );\n\n            /// revert on failure with error message if any\n            require(success, string(returnData));\n\n            emit ExecutedTransaction(target, value, data);\n        }\n    }\n\n    /// @notice arity check for payload\n    function _sanityCheckPayload(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas\n    ) private pure {\n        require(targets.length != 0, \"TemporalGovernor: Empty proposal\");\n        require(\n            targets.length == values.length &&\n                targets.length == calldatas.length,\n            \"TemporalGovernor: Arity mismatch for payload\"\n        );\n    }\n}"
    },
    {
      "filename": "contracts/access/Ownable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    },
    {
      "filename": "contracts/access/Ownable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    },
    {
      "filename": "src/core/Governance/TemporalGovernor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IWormhole} from \"@protocol/core/Governance/IWormhole.sol\";\n\nimport {ITemporalGovernor} from \"@protocol/core/Governance/ITemporalGovernor.sol\";\n\n/// @notice contract that governs the Base deployment of moonwell leveraging the wormhole bridge\n/// as the source of truth. Wormhole will be fed in actions from the moonbeam chain and this contract\n/// will execute them on base.\n/// There are a few assumptions that are made in this contract:\n/// 1. Wormhole is secure and will not send malicious messages or be deactivated.\n/// 2. Moonbeam is secure.\n/// 3. Governance on Moonbeam cannot be compromised.\n/// if 1. is untrue and wormhole is deactivated, then this contract will be unable to upgrade the base instance\n/// if 1. is untrue and wormhole sends malicious messages, then this contract will be paused, and the guardian\n/// will have to fast track a proposal to hand ownership to a new governor, and wormhole will have to revoke\n/// the permissions on the compromised validator set.\n/// if 2. is untrue, then this contract will be paused until moonbeam is restored\n/// if 3. is untrue, then this contract will be paused until moonbeam governance is restored, if gov control\n/// cannot be restored, then this governance will be compromised.\ncontract TemporalGovernor is ITemporalGovernor, Ownable, Pausable {\n    using SafeCast for *;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// ----------- IMMUTABLES -----------\n\n    /// @notice reference to the wormhole bridge\n    IWormhole public immutable wormholeBridge;\n\n    /// @notice returns the amount of time a proposal must wait before being processed.\n    uint256 public immutable proposalDelay;\n\n    /// @notice returns the amount of time until this contract can be unpaused permissionlessly\n    uint256 public immutable permissionlessUnpauseTime;\n\n    /// ----------- SINGLE STORAGE SLOT -----------\n\n    /// @notice last paused time\n    uint248 public lastPauseTime;\n\n    /// @notice returns whether or not the guardian can pause.\n    /// starts true and then is turned false when the guardian pauses\n    /// governance can then reactivate it.\n    bool public guardianPauseAllowed = true;\n\n    /// ----------- MAPPINGS -----------\n\n    /// @notice Map of chain id => trusted sender\n    mapping(uint16 => EnumerableSet.Bytes32Set) private trustedSenders;\n\n    /// @notice Record of processed messages to prevent replaying\n    /// and enforce time limits are respected\n    mapping(bytes32 => ProposalInfo) public queuedTransactions;\n\n    constructor(\n        address wormholeCore,\n        uint256 _proposalDelay,\n        uint256 _permissionlessUnpauseTime,\n        TrustedSender[] memory _trustedSenders\n    ) Ownable() {\n        wormholeBridge = IWormhole(wormholeCore);\n        proposalDelay = _proposalDelay;\n        permissionlessUnpauseTime = _permissionlessUnpauseTime;\n\n        // Using https://book.wormhole.com/reference/contracts.html#testnet chain ids and local contracts\n        // Mark 0xf16165f1046f1b3cdb37da25e835b986e696313a as trusted to emit from eth mainnet\n        // Establish a list of trusted emitters from eash chain\n        for (uint256 i = 0; i < _trustedSenders.length; i++) {\n            trustedSenders[_trustedSenders[i].chainId].add(\n                addressToBytes(_trustedSenders[i].addr)\n            );\n        }\n    }\n\n    /// ------------- VIEW ONLY API -------------\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        bytes32 addr\n    ) public view returns (bool) {\n        return trustedSenders[chainId].contains(addr);\n    }\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        address addr\n    ) external view returns (bool) {\n        return isTrustedSender(chainId, addressToBytes(addr));\n    }\n\n    /// @notice returns the list of trusted senders for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @return The list of trusted senders\n    function allTrustedSenders(uint16 chainId)\n        external\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory trustedSendersList = new bytes32[](\n            trustedSenders[chainId].length()\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < trustedSendersList.length; i++) {\n                trustedSendersList[i] = trustedSenders[chainId].at(i);\n            }\n        }\n\n        return trustedSendersList;\n    }\n\n    /// @notice Wormhole addresses are denominated in 32 byte chunks. Converting the address to a bytes20\n    /// then to a bytes32 *left* aligns it, so we right shift to get the proper data\n    /// @param addr The address to convert\n    /// @return The address as a bytes32\n    function addressToBytes(address addr) public pure returns (bytes32) {\n        return bytes32(bytes20(addr)) >> 96;\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Updates the list of trusted senders\n    /// @param _trustedSenders The list of trusted senders, allowing one\n    /// trusted sender per chain id\n    function setTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].add(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    true /// added to list\n                );\n            }\n        }\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Removes trusted senders from the list\n    /// @param _trustedSenders The list of trusted senders, allowing multiple\n    /// trusted sender per chain id\n    function unSetTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].remove(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    false /// removed from list\n                );\n            }\n        }\n    }\n\n    /// @notice grant the guardians the pause ability\n    function grantGuardiansPause() external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update grant guardian pause\"\n        );\n\n        guardianPauseAllowed = true;\n        lastPauseTime = 0;\n\n        emit GuardianPauseGranted(block.timestamp);\n    }\n\n    /// ------------- GUARDIAN / GOVERNOR ONLY API -------------\n\n    /// @notice callable only via a gov proposal (governance) or by the guardian\n    /// this revokes guardian's ability, no more pausing or fast tracking and\n    /// unpauses the contract if paused\n    function revokeGuardian() external {\n        address oldGuardian = owner();\n        require(\n            msg.sender == oldGuardian || msg.sender == address(this),\n            \"TemporalGovernor: cannot revoke guardian\"\n        );\n\n        _transferOwnership(address(0));\n        guardianPauseAllowed = false;\n        lastPauseTime = 0;\n\n        if (paused()) {\n            _unpause();\n        }\n\n        emit GuardianRevoked(oldGuardian);\n    }\n\n    /// ------------- PERMISSIONLESS APIs -------------\n\n    /// @notice We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    /// @dev callable only when unpaused\n    function queueProposal(bytes memory VAA) external whenNotPaused {\n        _queueProposal(VAA);\n    }\n\n    /// @notice Taken mostly from the best practices docs from wormhole.\n    /// We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    function executeProposal(bytes memory VAA) public whenNotPaused {\n        _executeProposal(VAA, false);\n    }\n\n    /// @notice unpauses the contract, and blocks the guardian from pausing again until governance reapproves them\n    function permissionlessUnpause() external whenPaused {\n        /// lastPauseTime cannot be equal to 0 at this point because\n        /// block.timstamp on a real chain will always be gt 0 and\n        /// toggle pause will set lastPauseTime to block.timestamp\n        /// which means if the contract is paused on a live network,\n        /// its lastPauseTime cannot be 0\n        require(\n            lastPauseTime + permissionlessUnpauseTime <= block.timestamp,\n            \"TemporalGovernor: not past pause window\"\n        );\n\n        lastPauseTime = 0;\n        _unpause();\n\n        assert(!guardianPauseAllowed); /// this should never revert, statement for SMT solving\n\n        emit PermissionlessUnpaused(block.timestamp);"
    }
  ]
}