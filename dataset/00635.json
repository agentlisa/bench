{
  "Title": "H-5: Incorrect price used when updating the global position data",
  "Content": "# Issue H-5: Incorrect price used when updating the global position data \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/188 \n\n## Found by \n0xLogos, 0xVolodya, juan, nobody2018, santipu\\_, xiaoming90\n## Summary\n\nIncorrect price used when updating the global position data leading to a loss of assets for LPs.\n\n## Vulnerability Detail\n\nNear the end of the liquidation process, the `updateGlobalPositionData` function at Line 159 will be executed to update the global position data. However, when executing the `updateGlobalPositionData` function, the code sets the price at Line 160 below to the position's last price (`position.lastPrice`), which is incorrect. The price should be set to the current price instead, and not the position's last price.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L160\n\n```solidity\nFile: LiquidationModule.sol\n082:     /// @notice Function to liquidate a position.\n083:     /// @dev One could directly call this method instead of `liquidate(uint256, bytes[])` if they don't want to update the Pyth price.\n084:     /// @param tokenId The token ID of the leverage position.\n085:     function liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n086:         FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n087: \n088:         (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n089: \n090:         // Settle funding fees accrued till now.\n091:         vault.settleFundingFees();\n092: \n093:         // Check if the position can indeed be liquidated.\n094:         if (!canLiquidate(tokenId)) revert FlatcoinErrors.CannotLiquidate(tokenId);\n095: \n096:         FlatcoinStructs.PositionSummary memory positionSummary = PerpMath._getPositionSummary(\n097:             position,\n098:             vault.cumulativeFundingRate(),\n099:             currentPrice\n100:         );\n..SNIP..\n159:         vault.updateGlobalPositionData({\n160:             price: position.lastPrice,\n161:             marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n162:             additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n163:         });\n```\n\nThe reason why the `updateGlobalPositionData` function expects a current price to be passed in is that within the `PerpMath._profitLossTotal` function, it will compute the price shift between the current price and the last price to obtain the PnL of all the open positions. Also, per the comment at Line 170 below, it expects the current price of the collateral to be passed in.\n\nThus, it is incorrect to pass in the individual position's last/entry price, which is usually the price of the collateral when the position was first opened or adjusted some time ago.\n\nThus, if the last/entry price of the liquidated position is higher than the current price of collateral, the PnL will be inflated, indicating more gain for the long traders. Since this is a zero-sum game, this also means that the LP loses more assets than expected due to the inflated gain of the long traders.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L173\n\n```solidity\nFile: FlatcoinVault.sol\n168:     /// @notice Function to update the global position data.\n169:     /// @dev This function is only callable by the authorized modules.\n170:     /// @param _price The current price of the underlying asset.\n171:     /// @param _marginDelta The change in the margin deposited total.\n172:     /// @param _additionalSizeDelta The change in the size opened total.\n173:     function updateGlobalPositionData(\n174:         uint256 _price,\n175:         int256 _marginDelta,\n176:         int256 _additionalSizeDelta\n177:     ) external onlyAuthorizedModule {\n178:         // Get the total profit loss and update the margin deposited total.\n179:         int256 profitLossTotal = PerpMath._profitLossTotal({globalPosition: _globalPositions, price: _price});\n180: \n181:         // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n182:         // However, since the funding fees are settled at the same time as the global position data is updated,\n183:         // we can ignore the funding fees here.\n184:         int256 newMarginDepositedTotal = int256(_globalPositions.marginDepositedTotal) + _marginDelta + profitLossTotal;\n185: \n186:         // Check that the sum of margin of all the leverage traders is not negative.\n187:         // Rounding errors shouldn't result in a negative margin deposited total given that\n188:         // we are rounding down the profit loss of the position.\n189:         // If anything, after closing the last position in the system, the `marginDepositedTotal` should can be positive.\n190:         // The margin may be negative if liquidations are not happening in a timely manner.\n191:         if (newMarginDepositedTotal < 0) {\n192:             revert FlatcoinErrors.InsufficientGlobalMargin();\n193:         }\n194: \n195:         _globalPositions = FlatcoinStructs.GlobalPositions({\n196:             marginDepositedTotal: uint256(newMarginDepositedTotal),\n197:             sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n198:             lastPrice: _price\n199:         });\n```\n\n## Impact\n\nLoss of assets for the LP as mentioned in the above section.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L160\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the current price instead of liquidated position's last price when update the global position data\n\n```diff\n(uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n..SNIP..\nvault.updateGlobalPositionData({\n-    price: position.lastPrice,\n+    price: currentPrice,    \n    marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n    additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n});\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(1)\n\n\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/264.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/LiquidationModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LiquidationModule\n/// @author dHEDGE\n/// @notice Module for liquidating leveraged positions.\ncontract LiquidationModule is\n    ILiquidationModule,\n    Initializable,\n    ModuleUpgradeable,\n    OracleModifiers,\n    ReentrancyGuardUpgradeable,\n    InvariantChecks\n{\n    /// @notice Liquidation fee basis points paid to liquidator.\n    /// @dev Note that this needs to be used together with keeper fee bounds.\n    /// @dev Should include 18 decimals i.e, 0.2% => 0.002e18 => 2e15\n    uint128 public liquidationFeeRatio;\n\n    /// @notice Liquidation price buffer in basis points to prevent negative margin on liquidation.\n    /// @dev Should include 18 decimals i.e, 0.75% => 0.0075e18 => 75e14\n    uint128 public liquidationBufferRatio;\n\n    /// @notice Upper bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeUpperBound;\n\n    /// @notice Lower bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeLowerBound;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IFlatcoinVault _vault,\n        uint128 _liquidationFeeRatio,\n        uint128 _liquidationBufferRatio,\n        uint256 _liquidationFeeLowerBound,\n        uint256 _liquidationFeeUpperBound\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY, _vault);\n\n        setLiquidationFeeRatio(_liquidationFeeRatio);\n        setLiquidationBufferRatio(_liquidationBufferRatio);\n        setLiquidationFeeBounds(_liquidationFeeLowerBound, _liquidationFeeUpperBound);\n    }\n\n    /////////////////////////////////////////////\n    //         Public Write Functions          //\n    /////////////////////////////////////////////\n\n    function liquidate(\n        uint256 tokenID,\n        bytes[] calldata priceUpdateData\n    ) external payable whenNotPaused updatePythPrice(vault, msg.sender, priceUpdateData) {\n        liquidate(tokenID);\n    }\n\n    /// @notice Function to liquidate a position.\n    /// @dev One could directly call this method instead of `liquidate(uint256, bytes[])` if they don't want to update the Pyth price.\n    /// @param tokenId The token ID of the leverage position.\n    function liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Settle funding fees accrued till now.\n        vault.settleFundingFees();\n\n        // Check if the position can indeed be liquidated.\n        if (!canLiquidate(tokenId)) revert FlatcoinErrors.CannotLiquidate(tokenId);\n\n        FlatcoinStructs.PositionSummary memory positionSummary = PerpMath._getPositionSummary(\n            position,\n            vault.cumulativeFundingRate(),\n            currentPrice\n        );\n\n        // Check that the total margin deposited by the long traders is not -ve.\n        // To get this amount, we will have to account for the PnL and funding fees accrued.\n        int256 settledMargin = positionSummary.marginAfterSettlement;\n\n        uint256 liquidatorFee;\n\n        // If the settled margin is greater than 0, send a portion (or all) of the margin to the liquidator and LPs.\n        if (settledMargin > 0) {\n            // Calculate the liquidation fees to be sent to the caller.\n            uint256 expectedLiquidationFee = PerpMath._liquidationFee(\n                position.additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n\n            uint256 remainingMargin;\n\n            // Calculate the remaining margin after accounting for liquidation fees.\n            // If the settled margin is less than the liquidation fee, then the liquidator fee is the settled margin.\n            if (uint256(settledMargin) > expectedLiquidationFee) {\n                liquidatorFee = expectedLiquidationFee;\n                remainingMargin = uint256(settledMargin) - expectedLiquidationFee;\n            } else {\n                liquidatorFee = uint256(settledMargin);\n            }\n\n            // Adjust the stable collateral total to account for user's remaining margin.\n            // If the remaining margin is greater than 0, this goes to the LPs.\n            // Note that {`remainingMargin` - `profitLoss`} is the same as {`marginDeposited` + `accruedFunding`}.\n            vault.updateStableCollateralTotal(int256(remainingMargin) - positionSummary.profitLoss);\n\n            // Send the liquidator fee to the caller of the function.\n            // If the liquidation fee is greater than the remaining margin, then send the remaining margin.\n            vault.sendCollateral(msg.sender, liquidatorFee);\n        } else {\n            // If the settled margin is -ve then the LPs have to bear the cost.\n            // Adjust the stable collateral total to account for user's profit/loss and the negative margin.\n            // Note: We are adding `settledMargin` and `profitLoss` instead of subtracting because of their sign (which will be -ve).\n            vault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\n        }\n\n        // Update the global position data.\n        // Note that we are only accounting for `globalMarginDelta`, `marginDeposited` and `userAccruedFunding`.\n        // and not the PnL of the user when altering `marginDepositedTotal`.\n        // This is because the PnL is already accounted for in the `stableCollateralTotal`.\n        // So when the PnL is +ve (the trader made profits), the trader takes the profit along with the margin deposited.\n        // When the PnL is -ve, the trader loses a portion of the margin deposited to the LPs and the rest is again taken along.\n        // In neither case, the PnL is added/subtracted to/from the `marginDepositedTotal`.\n        // Now we are subtracting `userAccruedFunding` in the below function call because:\n        //      `globalMarginDelta` = `userAccruedFunding` + Funding accrued by the rest of the long traders.\n        // And this accrued funding is being taken away from the system (if +ve) or given to LPs (if -ve).\n        // When the `userAccruedFunding` is +ve, the user takes away the funding fees earned.\n        // When it's negative, the user pays the funding fees to the LPs and their margin is reduced.\n        // So the `marginDepositedTotal` is added with `userAccruedFunding` in the below function call as the user has paid for their share\n        // of funding fees.\n        vault.updateGlobalPositionData({\n            price: position.lastPrice,\n            marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n            additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n        });\n\n        // Delete position storage\n        vault.deletePosition(tokenId);\n\n        // Cancel any limit orders associated with the position\n        ILimitOrder(vault.moduleAddress(FlatcoinModuleKeys._LIMIT_ORDER_KEY)).cancelExistingLimitOrder(tokenId);\n\n        // If the position token is locked because of an announced order, it should still be liquidatable\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n        leverageModule.unlock(tokenId);\n        leverageModule.burn(tokenId);\n\n        emit FlatcoinEvents.PositionLiquidated(tokenId, msg.sender, liquidatorFee);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Function to calculate liquidation price for a given position.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId) public view returns (uint256 liqPrice) {\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return liquidationPrice(tokenId, currentPrice);\n    }\n\n    /// @notice Function to calculate liquidation price for a given position at a given price.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @param price The price at which the liquidation price is to be calculated.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId, uint256 price) public view returns (uint256 liqPrice) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._approxLiquidationPrice({\n                position: position,\n                nextFundingEntry: nextFundingEntry,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function which determines if a leverage position can be liquidated or not.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidatable True if the position can be liquidated, false otherwise.\n    function canLiquidate(uint256 tokenId) public view returns (bool liquidatable) {\n        // Get the current price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return canLiquidate(tokenId, currentPrice);\n    }\n\n    function canLiquidate(uint256 tokenId, uint256 price) public view returns (bool liquidatable) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._canLiquidate({\n                position: position,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                nextFundingEntry: nextFundingEntry,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function to calculate the liquidation fee awarded for a liquidating a given position.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidationFee The liquidation fee in collateral units.\n    function getLiquidationFee(uint256 tokenId) public view returns (uint256 liquidationFee) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return\n            PerpMath._liquidationFee(\n                vault.getPosition(tokenId).additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(uint256 additionalSize) public view returns (uint256 liquidationMargin) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return getLiquidationMargin(additionalSize, currentPrice);\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount and price.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @param price The price at which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(\n        uint256 additionalSize,\n        uint256 price\n    ) public view returns (uint256 liquidationMargin) {\n        return\n            PerpMath._liquidationMargin(\n                additionalSize,\n                liquidationFeeRatio,\n                liquidationBufferRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                price\n            );\n    }\n\n    /////////////////////////////////////////////\n    //            Owner Functions              //\n    /////////////////////////////////////////////\n\n    function setLiquidationFeeRatio(uint128 _newLiquidationFeeRatio) public onlyOwner {\n        if (_newLiquidationFeeRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationFeeRatio\");\n\n        emit FlatcoinEvents.LiquidationFeeRatioModified(liquidationFeeRatio, _newLiquidationFeeRatio);\n\n        liquidationFeeRatio = _newLiquidationFeeRatio;\n    }\n\n    function setLiquidationBufferRatio(uint128 _newLiquidationBufferRatio) public onlyOwner {\n        if (_newLiquidationBufferRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationBufferRatio\");\n\n        emit FlatcoinEvents.LiquidationBufferRatioModified(liquidationBufferRatio, _newLiquidationBufferRatio);\n\n        liquidationBufferRatio = _newLiquidationBufferRatio;\n    }\n\n    function setLiquidationFeeBounds(\n        uint256 _newLiquidationFeeLowerBound,\n        uint256 _newLiquidationFeeUpperBound\n    ) public onlyOwner {\n        if (_newLiquidationFeeUpperBound == 0 || _newLiquidationFeeLowerBound == 0)\n            revert FlatcoinErrors.ZeroValue(\"newLiquidationFee\");\n        if (_newLiquidationFeeUpperBound < _newLiquidationFeeLowerBound)\n            revert FlatcoinErrors.InvalidBounds(_newLiquidationFeeLowerBound, _newLiquidationFeeUpperBound);\n\n        emit FlatcoinEvents.LiquidationFeeBoundsModified(\n            liquidationFeeLowerBound,\n            liquidationFeeUpperBound,\n            _newLiquidationFeeLowerBound,\n            _newLiquidationFeeUpperBound\n        );\n\n        liquidationFeeLowerBound = _newLiquidationFeeLowerBound;\n        liquidationFeeUpperBound = _newLiquidationFeeUpperBound;\n    }\n\n    /////////////////////////////////////////////\n    //           Internal Functions            //\n    /////////////////////////////////////////////\n\n    /// @dev Accounts for the funding fees based on the market state.\n    /// @return nextFundingEntry The cumulative funding rate based on the latest market state.\n    function _accountFundingFees() internal view returns (int256 nextFundingEntry) {\n        uint256 stableCollateralTotal = vault.stableCollateralTotal();\n        int256 currMarketSkew = int256(vault.getGlobalPositions().sizeOpenedTotal) - int256(stableCollateralTotal);\n\n        int256 currentFundingRate = PerpMath._currentFundingRate({\n            proportionalSkew: PerpMath._proportionalSkew({\n                skew: currMarketSkew,\n                stableCollateralTotal: stableCollateralTotal\n            }),\n            lastRecomputedFundingRate: vault.lastRecomputedFundingRate(),\n            lastRecomputedFundingTimestamp: vault.lastRecomputedFundingTimestamp(),\n            maxFundingVelocity: vault.maxFundingVelocity(),\n            maxVelocitySkew: vault.maxVelocitySkew()\n        });\n\n        int256 unrecordedFunding = PerpMath._unrecordedFunding(\n            currentFundingRate,\n            vault.lastRecomputedFundingRate(),\n            vault.lastRecomputedFundingTimestamp()\n        );\n\n        return PerpMath._nextFundingEntry(unrecordedFunding, vault.cumulativeFundingRate());\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/FlatcoinVault.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\n\n/// @title FlatcoinVault\n/// @author dHEDGE\n/// @notice Contains state to be reused by different modules of the system.\n/// @dev Holds the stable LP deposits and leverage traders' collateral amounts.\n///      Also stores other related contract address pointers.\ncontract FlatcoinVault is IFlatcoinVault, OwnableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice The collateral token address.\n    IERC20Upgradeable public collateral;\n\n    /// @notice The last market skew recomputation timestamp.\n    uint64 public lastRecomputedFundingTimestamp;\n\n    /// @notice The minimum time that needs to expire between trade announcement and execution.\n    uint64 public minExecutabilityAge;\n\n    /// @notice The maximum amount of time that can expire between trade announcement and execution.\n    uint64 public maxExecutabilityAge;\n\n    /// @notice The last recomputed funding rate.\n    int256 public lastRecomputedFundingRate;\n\n    /// @notice Sum of funding rate over the entire lifetime of the market.\n    int256 public cumulativeFundingRate;\n\n    /// @notice Total collateral deposited by users minting the flatcoin.\n    /// @dev This value is adjusted due to funding fee payments.\n    uint256 public stableCollateralTotal;\n\n    /// @notice The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @dev Funding velocity is used for calculating the current funding rate and acts as\n    ///      a limit on how much the funding rate can change between funding re-computations.\n    ///      The units are %/day (1e18 = 100% / day at max or min skew).\n    uint256 public maxFundingVelocity;\n\n    /// @notice The skew percentage at which the funding rate velocity is at its maximum.\n    /// @dev When absolute pSkew > maxVelocitySkew, then funding velocity = maxFundingVelocity.\n    ///      The units are in % (0.1e18 = 10% skew)\n    uint256 public maxVelocitySkew;\n\n    /// @notice Maximum cap on the total stable LP deposits.\n    uint256 public stableCollateralCap;\n\n    /// @notice The maximum limit of total leverage long size vs stable LP.\n    /// @dev This prevents excessive short skew of stable LPs by capping long trader total open interest.\n    ///      Care needs to be taken when increasing this value as it can lead to the stable LPs being excessively short.\n    uint256 public skewFractionMax;\n\n    /// @notice Holds mapping between module keys and module addresses.\n    ///         A module key is a keccak256 hash of the module name.\n    /// @dev Make sure that a module key is created using the following format:\n    ///      moduleKey = bytes32(<MODULE_NAME>)\n    ///      All the module keys should reside in a single file (see FlatcoinModuleKeys.sol).\n    mapping(bytes32 moduleKey => address moduleAddress) public moduleAddress;\n\n    /// @notice Holds mapping between module addresses and their authorization status.\n    mapping(address moduleAddress => bool authorized) public isAuthorizedModule;\n\n    /// @notice Holds mapping between module keys and their pause status.\n    mapping(bytes32 moduleKey => bool paused) public isModulePaused;\n\n    /// @dev Tracks global totals of leverage trade positions to be able to:\n    ///      - price stable LP value.\n    ///      - calculate the funding rate.\n    ///      - calculate the skew.\n    ///      - calculate funding fees payments.\n    FlatcoinStructs.GlobalPositions internal _globalPositions;\n\n    /// @dev Holds mapping between user addresses and their leverage positions.\n    mapping(uint256 tokenId => FlatcoinStructs.Position userPosition) internal _positions;\n\n    modifier onlyAuthorizedModule() {\n        if (isAuthorizedModule[msg.sender] == false) revert FlatcoinErrors.OnlyAuthorizedModule(msg.sender);\n        _;\n    }\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    /// @param _owner The owner of this contract.\n    /// @param _collateral The collateral token address.\n    /// @param _maxFundingVelocity The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @param _maxVelocitySkew The skew percentage at which the funding rate velocity is at its maximum.\n    /// @param _skewFractionMax The maximum limit of total leverage long size vs stable LP.\n    /// @param _stableCollateralCap The maximum cap on the total stable LP deposits.\n    /// @param _minExecutabilityAge The minimum time that needs to expire between trade announcement and execution.\n    /// @param _maxExecutabilityAge The maximum amount of time that can expire between trade announcement and execution.\n    function initialize(\n        address _owner,\n        IERC20Upgradeable _collateral,\n        uint256 _maxFundingVelocity,\n        uint256 _maxVelocitySkew,\n        uint256 _skewFractionMax,\n        uint256 _stableCollateralCap,\n        uint64 _minExecutabilityAge,\n        uint64 _maxExecutabilityAge\n    ) external initializer {\n        if (address(_collateral) == address(0)) revert FlatcoinErrors.ZeroAddress(\"collateral\");\n\n        __Ownable_init();\n        _transferOwnership(_owner);\n\n        collateral = _collateral;\n\n        setMaxFundingVelocity(_maxFundingVelocity);\n        setMaxVelocitySkew(_maxVelocitySkew);\n        setStableCollateralCap(_stableCollateralCap);\n        setSkewFractionMax(_skewFractionMax);\n        setExecutabilityAge(_minExecutabilityAge, _maxExecutabilityAge);\n    }\n\n    /////////////////////////////////////////////\n    //            Module Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Collateral can only be withdrawn by the flatcoin contracts (Delayed Orders, Stable or Leverage module).\n    function sendCollateral(address to, uint256 amount) external onlyAuthorizedModule {\n        collateral.safeTransfer(to, amount);\n    }\n\n    /// @notice Function to set the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _newPosition The new struct encoded position of the leverage trader.\n    /// @param _tokenId The token ID of the leverage trader.\n    function setPosition(\n        FlatcoinStructs.Position calldata _newPosition,\n        uint256 _tokenId\n    ) external onlyAuthorizedModule {\n        _positions[_tokenId] = _newPosition;\n    }\n\n    /// @notice Function to delete the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _tokenId The token ID of the leverage trader.\n    function deletePosition(uint256 _tokenId) external onlyAuthorizedModule {\n        delete _positions[_tokenId];\n    }\n\n    /// @notice Function to update the stable collateral total.\n    /// @dev This function is only callable by the authorized modules.\n    ///      When `_stableCollateralAdjustment` is negative, it means that the stable collateral total is decreasing.\n    /// @param _stableCollateralAdjustment The adjustment to the stable collateral total.\n    function updateStableCollateralTotal(int256 _stableCollateralAdjustment) external onlyAuthorizedModule {\n        _updateStableCollateralTotal(_stableCollateralAdjustment);\n    }\n\n    /// @notice Function to update the global position data.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _price The current price of the underlying asset.\n    /// @param _marginDelta The change in the margin deposited total.\n    /// @param _additionalSizeDelta The change in the size opened total.\n    function updateGlobalPositionData(\n        uint256 _price,\n        int256 _marginDelta,\n        int256 _additionalSizeDelta\n    ) external onlyAuthorizedModule {\n        // Get the total profit loss and update the margin deposited total.\n        int256 profitLossTotal = PerpMath._profitLossTotal({globalPosition: _globalPositions, price: _price});\n\n        // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n        // However, since the funding fees are settled at the same time as the global position data is updated,\n        // we can ignore the funding fees here.\n        int256 newMarginDepositedTotal = int256(_globalPositions.marginDepositedTotal) + _marginDelta + profitLossTotal;\n\n        // Check that the sum of margin of all the leverage traders is not negative.\n        // Rounding errors shouldn't result in a negative margin deposited total given that\n        // we are rounding down the profit loss of the position.\n        // If anything, after closing the last position in the system, the `marginDepositedTotal` should can be positive.\n        // The margin may be negative if liquidations are not happening in a timely manner.\n        if (newMarginDepositedTotal < 0) {\n            revert FlatcoinErrors.InsufficientGlobalMargin();\n        }\n\n        _globalPositions = FlatcoinStructs.GlobalPositions({\n            marginDepositedTotal: uint256(newMarginDepositedTotal),\n            sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n            lastPrice: _price\n        });\n\n        // Profit loss of leverage traders has to be accounted for by adjusting the stable collateral total.\n        // Note that technically, even the funding fees should be accounted for when computing the stable collateral total.\n        // However, since the funding fees are settled at the same time as the global position data is updated,\n        // we can ignore the funding fees here\n        _updateStableCollateralTotal(-profitLossTotal);\n    }\n\n    /////////////////////////////////////////////\n    //            Public Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Function to settle the funding fees between longs and LPs.\n    /// @dev Anyone can call this function to settle the funding fees.\n    /// @return _fundingFees The funding fees paid to longs.\n    ///         If it's negative, longs pay shorts and vice versa.\n    function settleFundingFees() public returns (int256 _fundingFees) {\n        (int256 fundingChangeSinceRecomputed, int256 unrecordedFunding) = _getUnrecordedFunding();\n\n        // Record the funding rate change and update the cumulative funding rate.\n        cumulativeFundingRate = PerpMath._nextFundingEntry(unrecordedFunding, cumulativeFundingRate);\n\n        // Update the latest funding rate and the latest funding recomputation timestamp.\n        lastRecomputedFundingRate += fundingChangeSinceRecomputed;\n        lastRecomputedFundingTimestamp = (block.timestamp).toUint64();\n\n        // Calculate the funding fees accrued to the longs.\n        // This will be used to adjust the global margin and collateral amounts.\n        _fundingFees = PerpMath._accruedFundingTotalByLongs(_globalPositions, unrecordedFunding);\n\n        // In the worst case scenario that the last position which remained open is underwater,\n        // we set the margin deposited total to 0. We don't want to have a negative margin deposited total.\n        _globalPositions.marginDepositedTotal = (int256(_globalPositions.marginDepositedTotal) > _fundingFees)\n            ? uint256(int256(_globalPositions.marginDepositedTotal) + _fundingFees)\n            : 0;\n\n        _updateStableCollateralTotal(-_fundingFees);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Function to get a summary of the vault.\n    /// @dev This can be used by modules to get the current state of the vault.\n    /// @return _vaultSummary The vault summary struct.\n    function getVaultSummary() external view returns (FlatcoinStructs.VaultSummary memory _vaultSummary) {\n        return\n            FlatcoinStructs.VaultSummary({\n                marketSkew: int256(_globalPositions.sizeOpenedTotal) - int256(stableCollateralTotal),\n                cumulativeFundingRate: cumulativeFundingRate,\n                lastRecomputedFundingRate: lastRecomputedFundingRate,\n                lastRecomputedFundingTimestamp: lastRecomputedFundingTimestamp,\n                stableCollateralTotal: stableCollateralTotal,\n                globalPositions: _globalPositions\n            });\n    }\n\n    /// @notice Function to get the current funding rate.\n    /// @dev This can be used by modules to get the current funding rate.\n    /// @return currentFundingRate_ The current funding rate.\n    function getCurrentFundingRate() external view returns (int256 currentFundingRate_) {\n        return\n            PerpMath._currentFundingRate({\n                proportionalSkew: PerpMath._proportionalSkew({\n                    skew: int256(_globalPositions.sizeOpenedTotal) - int256(stableCollateralTotal),\n                    stableCollateralTotal: stableCollateralTotal\n                }),\n                lastRecomputedFundingRate: lastRecomputedFundingRate,\n                lastRecomputedFundingTimestamp: lastRecomputedFundingTimestamp,\n                maxFundingVelocity: maxFundingVelocity,\n                maxVelocitySkew: maxVelocitySkew\n            });\n    }\n\n    /// @notice Function to get the position details of associated with a `_tokenId`.\n    /// @dev This can be used by modules to get the position details of a leverage trader.\n    /// @param _tokenId The token ID of the leverage trader.\n    /// @return _positionDetails The position struct with details.\n    function getPosition(uint256 _tokenId) external view returns (FlatcoinStructs.Position memory _positionDetails) {\n        return _positions[_tokenId];\n    }\n\n    /// @notice Function to get the global position details.\n    /// @dev This can be used by modules to get the global position details.\n    /// @return _globalPositionsDetails The global position struct with details.\n    function getGlobalPositions()\n        external\n        view\n        returns (FlatcoinStructs.GlobalPositions memory _globalPositionsDetails)\n    {\n        return _globalPositions;\n    }\n\n    /// @notice Asserts that the system will not be too skew"
    }
  ]
}