{
  "Title": "M-2: Lack of rebalance rate limiting allow operators to drain vaults",
  "Content": "# Issue M-2: Lack of rebalance rate limiting allow operators to drain vaults \n\nSource: https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/25 \n\n## Found by \ncergyk, immeas, n33k, p12473\n## Summary\nOperators of Arrakis vaults are constrained by the checks defined in `SimpleManager.sol`, these checks prevent them from causing too much of a fund loss on a single rebalance call (check univ3 pool price deviation, enforce minimum swap slippage parameters). \n\nHowever since there is no rate limiting for an operator to call rebalance on SimpleManager, an operator can simply drain the vault by applying the accepted slippage a hundred times in one transaction.\n\n## Vulnerability Detail\nThere are mostly two safety measures for preventing an operator to extract vault funds when calling rebalance:\n\n- Check pool price deviation for mints:\n    By checking that a pool price is close to a price given by a chainlink feed, operator is prevented from adding liquidity to a pool at a really unfavorable price, and backrun later to extract vault funds\n\n- Check slippage parameters for swap (`_checkMinReturn`):\n    By checking that a minimum amount of tokens is returned to the vault after the swap, it is preventing the operator to swap tokens at a too unfavorable price.\n    Min amount out enforced in ArrakisV2:\n\nhttps://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-core/contracts/ArrakisV2.sol#L341-L363\n\nAs stated by the sponsor, in a public trustless setup, these slippage parameters should be restricted to ~1%.\n\nHowever since an operator is not rate limited for the number of calls she can do on `SimpleManager.rebalance`, she can simply call it multiple times in a very short timespan, extract an arbitrarily large share of vault funds.\n\n## Impact\nVault funds can be drained by a malicious operator.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nEnforce a rate limiting policy to the number of calls which can be made to SimpleManager's rebalance, or even better enforce a rate limit on loss of funds which can occur due to rebalances (by evaluating `totalUnderlyingWithFees` before and after the execution for example).\n\n\n\n## Discussion\n\n**ctf-sec**\n\n> Operators are \"semi trusted\" only to be awake and adhere to the expected vault rebalancing strategy. Thus a malicious operator on the SimpleManager.sol should not be able to do anything worse than \"grief\" - they MAY not execute rebalances or MAY not execute the expected strategy. However the rebalances that are executed MUST NOT be exploitable by frontrun or sandwich.\n\nBased the info from the contest readme doc, upgrading the severity to high\n\n**IAm0x52**\n\nEscalate\n\nShould be medium not high. This attacks has multiple conditions to work. First of all the operator must become compromised. Second the profitability of a sandwich attack is highly dependent on the composition of the underlying pools and the slippage setting on the manager. If the vault is primarily trading in a 0.3% (0.6% combined buy and sell) fee pool then a slippage cap of 0.5% makes it impossible for this type of attack to work. Additionally depending on the depth of liquidity for nearby relevant buckets the cost to move the pool may outweigh any gains making it unprofitable. \n\n**sherlock-admin**\n\n > Escalate\n> \n> Should be medium not high. This attacks has multiple conditions to work. First of all the operator must become compromised. Second the profitability of a sandwich attack is highly dependent on the composition of the underlying pools and the slippage setting on the manager. If the vault is primarily trading in a 0.3% (0.6% combined buy and sell) fee pool then a slippage cap of 0.5% makes it impossible for this type of attack to work. Additionally depending on the depth of liquidity for nearby relevant buckets the cost to move the pool may outweigh any gains making it unprofitable. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Jeiwan**\n\nEscalate\n\nThis is not a valid issue, the behaviour of operators is expected. As per the contest details (https://audits.sherlock.xyz/contests/86):\n> Q: Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, input validation expectations, etc)?\n> Yes the SimpleManager.operators are keeper bots running the \"off chain logic\" that defines the \"market making strategy.\" While it is generally expected that these keeper bots are not malicious, are mostly available/awake, and are running off chain logic to create the rebalance payloads on the expected \"market making strategy,\" even in the absence of this where a malicious keeper bot passes arbitrary payloads to rebalance, there should be no way to extract value from these rebalances directly beyond the acceptable slippage tolerance defined in SimpleManager.\n\nAs the finding describes, operators cannot extract value from rebalance beyond the slippage tolerance. Even though if they can rebalance multiple times, they cannot get more value than is set by the slippage tolerance. This is expected behaviour and it was explicitly mentioned by the sponsor.\n\n\nI also disagree with this comment: https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/25#issuecomment-1634990625\nThe finding doesn't mention a front run or a sandwiching attack, thus the statement is not applicable. The upgrade to high severity is not justified. The demonstrated scenario in the finding is pretty much in line with the definition of operators: they are semi trusted actors that execute a strategy and cannot manipulate the price more than the specified by the slippage tolerance. The finding doesn't prove the slippage tolerance check can be avoided.\n\n**sherlock-admin**\n\n > Escalate\n> \n> This is not a valid issue, the behaviour of operators is expected. As per the contest details (https://audits.sherlock.xyz/contests/86):\n> > Q: Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, input validation expectations, etc)?\n> > Yes the SimpleManager.operators are keeper bots running the \"off chain logic\" that defines the \"market making strategy.\" While it is generally expected that these keeper bots are not malicious, are mostly available/awake, and are running off chain logic to create the rebalance payloads on the expected \"market making strategy,\" even in the absence of this where a malicious keeper bot passes arbitrary payloads to rebalance, there should be no way to extract value from these rebalances directly beyond the acceptable slippage tolerance defined in SimpleManager.\n> \n> As the finding describes, operators cannot extract value from rebalance beyond the slippage tolerance. Even though if they can rebalance multiple times, they cannot get more value than is set by the slippage tolerance. This is expected behaviour and it was explicitly mentioned by the sponsor.\n> \n> \n> I also disagree with this comment: https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/25#issuecomment-1634990625\n> The finding doesn't mention a front run or a sandwiching attack, thus the statement is not applicable. The upgrade to high severity is not justified. The demonstrated scenario in the finding is pretty much in line with the definition of operators: they are semi trusted actors that execute a strategy and cannot manipulate the price more than the specified by the slippage tolerance. The finding doesn't prove the slippage tolerance check can be avoided.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with @Jeiwan that this should be invalid since the operator never violates the slippage tolerance\n\n**syjcnss**\n\nNot agree on the two escalations.\n\nFirst. In the README of the audit it says 'A wide variety' of tokens will be supported. And there's no limit on the fee tier of supported pairs. So there will be vaults that are vulnerable to this attack. \n\nSecond. This bug is not about violating the the slippage tolerance. But is about leveraging the slippage tolerance to profit. This attack will definitely cause a massive loss to this protocol and I don't think this is the expected behaviour.\n\n**Jeiwan**\n\n> Second. This bug is not about violating the the slippage tolerance.\n\nExactly. The contest description was very clear about what attack vectors involving operators are deemed valid. The slippage tolerance is not violated, thus this is not a valid attack.\n\n> But is about leveraging the slippage tolerance to profit.\n\nThis point is also addressed in the contest details:\n> Operators are \"semi trusted\" only to be awake and adhere to the expected vault rebalancing strategy.\n> While it is generally expected that these keeper bots are not malicious\n\nOperators are trusted to not be malicious and to execute the rebalancing strategy as its programmed. The finding doesn't demonstrate how an operator could go beyond what it's trusted to do. There's no abuse of the strategy. The slippage tolerance works as expected. Operators are expected to do multiple rebalances. Price manipulations are protected by the slippage toleranceâ€“the amount of loss that's available by the tolerance setting is expected and acceptable by the protocol.\n\n**Jeiwan**\n\nI checked the duplicate reports of this issue, some of them are more detailed about how this can be exploited. However, all those exploit scenarios were addressed in the contest description:\n> where a malicious keeper bot passes arbitrary payloads to rebalance, there should be no way to extract value from these rebalances directly beyond the acceptable slippage tolerance defined in SimpleManager. \n\nSo, we have two exploiting techniques for the attack to be valid:\n1. Price manipulation. This is already addressed by the code: the slippage tolerance check protects against that, while allowing some expected loses.\n2. Payload manipulation. The finding doesn't prove that payload manipulation can break the slippage tolerance check.\n\nEven after checking the other reports, I still believe this finding is out of scope. It describes expected behavior of operators.\n\n**JeffCX**\n\nOk. After reading the escalation, for now I agree with the senior watson's escalation, can change the severity from high to medium\n\nSo\n\n> they are semi trusted actors that execute a strategy and cannot manipulate the price more than the specified by the slippage tolerance.\n\nI would interpret this as \"operator\" are not trusted.\n\nSecond, I agree within single transaction, the slippage protection is not bypassed\n\nbut suppose we set the slippage to 1%\n\nIf operator keep doing rebalance:\n\n- first rebalance, 99% of the token we received\n- second rebalance: 98.01% of the token we received\n- third rebalance: 97.02% of the token we received \n\n...\n\nbut the attack may not be profitable for attacker :)\n\nI would recommend downgrade the severity from high to medium (report still valid)\n\nunless there are more proof for this statement:\n\n> This attack will definitely cause a massive loss to this protocol and I don't think this is the expected behaviour.\n\n**syjcnss**\n\nAgree with the lead judge and senior watson's escalation. \n\n**Jeiwan**\n\nMy view still holds true. Since the slippage tolerance check is not avoided this is not a valid attack scenario. It was expected by the sponsor and the contest description was clear that operators are \"semi trusted\" and only breaking the slippage tolerance check can be considered an attack.\n\n@hrishibhat \n\n**SergeKireev**\n\nI would like to address the escalations:\n\n@Jeiwan: The contest page also says:\n```\nThus a malicious operator on the SimpleManager.sol should not be able to do anything worse than \"grief\" - they MAY not execute rebalances or MAY not execute the expected strategy. However the rebalances that are executed MUST NOT be exploitable by frontrun or sandwich.\n```\n\nHere the impact is that a malicious operator can drain a big chunk of TVL in the protocol in one single transaction.\n\n@IAm0x52 These are very interesting points:\n> Should be medium not high. This attacks has multiple conditions to work. First of all the operator must become compromised. Second the profitability of a sandwich attack is highly dependent on the composition of the underlying pools and the slippage setting on the manager. If the vault is primarily trading in a 0.3% (0.6% combined buy and sell) fee pool then a slippage cap of 0.5% makes it impossible for this type of attack to work. Additionally depending on the depth of liquidity for nearby relevant buckets the cost to move the pool may outweigh any gains making it unprofitable.\n\nI agree that the operator has to be compromised as a condition.\n\nSince the operator can use the router payload to swap on any pool, only limited by vault.maxSlippage (for which a value of 1% should be considered according to sponsor), the malicious operator can create a bogus pool with a poison token which could just be used to extract the tokens sent by Arrakis with a fee of 0.01%.\n\nWhich means 0.99% extracted on each call. Since multiple calls can be done to `rebalance` in a single transaction, the malicious operator can drain an arbitrary amount of funds before the owner can even try to react and change it\n\n**ctf-sec**\n\nemm it is not possible to inject own's opinion into another haha, yeah just recommend leave factual based comments and wait for sherlock to resolve the escalation, recommend changing severity to medium :)\n\n**SergeKireev**\n\nFound again the message posted by sponsor in the public discord where slippage and deviation would be considered to be 1% (step 4):\n![Screen Shot 2023-07-18 at 10 39 58](https://github.com/sherlock-audit/2023-06-arrakis-judging/assets/6078372/4c1e84a4-82f7-48ed-97e7-7f625ee099b6)\n\n\n**syjcnss**\n\n> but suppose we set the slippage to 1%\n> \n> If operator keep doing rebalance:\n> \n> first rebalance, 99% of the token we received\n> second rebalance: 98.01% of the token we received\n> third rebalance: 97.02% of the token we received\n> ...\n> \n\nSo, for 100 times of rebalance we will only get 0.99\\*\\*100 = 36.60% of the token left in the vault?\nFor 300, it's very close to empty. 0.99\\*\\*300 = 4.90%\n\nIf I'm right on the math above, then a compromised operator may not be needed.\n100 times of rebalance is very much likely achievable in a short period like a few months in a fluctuant market.\nA compromised operator will make a massive loss quickly.\n\n**0ximmeas**\n\nAs i stated in my dup of this, from the docs:\n> Operators are \"semi trusted\" only to be awake and adhere to the expected vault rebalancing strategy. Thus a malicious operator on the SimpleManager.sol should not be able to do anything worse than \"grief\"\n\nThis is doing something worse than grief, the sponsor just didn't think of this specific attack scenario. An operator can steal a significant amount of the vaults funds in a single transaction. Thus high.\n\n**Gevarist**\n\nIf the operator is malicious, owner has the option to replace it.\n\n**SergeKireev**\n\n> If the operator is malicious, owner has the option to replace it.\n\nWithout some kind of rate limiting, the draining can happen in one transaction, no way for the owner to mitigate it\n\n**Gevarist**\n\nHow much iteration can the malicious operator do in 1 block? Less than thirty rebalance in one block for sure. The gas cost of such attack is considerable. And operators are semi-trusted, we think this issue is a medium.\n\n**SergeKireev**\n\nIf we assume that gas consumed is approx 1 uniswapv3 swap (the operator can choose to do only the swap step during rebalance with 1% slippage), `30` is a good estimate of the max number of rebalances possible during 1 block.\n\nWhich caps the theft of funds during one block at (1-0.99**30) ~= 26% of the funds.\n\nI agree @Gevarist that this attack is a bit less practical than what described in previous discussion\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates \nConsidering this a valid medium based on the above final comments.\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/25/#issuecomment-1636896052): accepted\n- [Jeiwan](https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/25/#issuecomment-1636964048): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/86",
  "Code": [
    {
      "filename": "v2-core/contracts/ArrakisV2.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport {\n    IUniswapV3MintCallback\n} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {\n    IUniswapV3Pool\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {\n    IUniswapV3Factory,\n    ArrakisV2Storage,\n    IERC20,\n    SafeERC20,\n    EnumerableSet,\n    Range,\n    Rebalance\n} from \"./abstract/ArrakisV2Storage.sol\";\nimport {FullMath} from \"@arrakisfi/v3-lib-0.8/contracts/LiquidityAmounts.sol\";\nimport {Withdraw, UnderlyingPayload} from \"./structs/SArrakisV2.sol\";\nimport {Position} from \"./libraries/Position.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {Underlying as UnderlyingHelper} from \"./libraries/Underlying.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {hundredPercent} from \"./constants/CArrakisV2.sol\";\n\n/// @title ArrakisV2 LP vault version 2\n/// @notice Smart contract managing liquidity providing strategy for a given token pair\n/// using multiple Uniswap V3 LP positions on multiple fee tiers.\n/// @author Arrakis Finance\n/// @dev DO NOT ADD STATE VARIABLES - APPEND THEM TO ArrakisV2Storage\ncontract ArrakisV2 is IUniswapV3MintCallback, ArrakisV2Storage {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IUniswapV3Factory factory_) ArrakisV2Storage(factory_) {}\n\n    /// @notice Uniswap V3 callback fn, called back on pool.mint\n    function uniswapV3MintCallback(\n        uint256 amount0Owed_,\n        uint256 amount1Owed_,\n        bytes calldata /*_data*/\n    ) external override {\n        _uniswapV3CallBack(amount0Owed_, amount1Owed_);\n    }\n\n    /// @notice mint Arrakis V2 shares by depositing underlying\n    /// @param mintAmount_ represent the amount of Arrakis V2 shares to mint.\n    /// @param receiver_ address that will receive Arrakis V2 shares.\n    /// @return amount0 amount of token0 needed to mint mintAmount_ of shares.\n    /// @return amount1 amount of token1 needed to mint mintAmount_ of shares.\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function mint(uint256 mintAmount_, address receiver_)\n        external\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(mintAmount_ > 0, \"MA\");\n        require(\n            restrictedMint == address(0) || msg.sender == restrictedMint,\n            \"R\"\n        );\n        address me = address(this);\n        uint256 ts = totalSupply();\n        bool isTotalSupplyGtZero = ts > 0;\n        if (isTotalSupplyGtZero) {\n            (amount0, amount1) = UnderlyingHelper.totalUnderlyingForMint(\n                UnderlyingPayload({\n                    ranges: _ranges,\n                    factory: factory,\n                    token0: address(token0),\n                    token1: address(token1),\n                    self: me\n                }),\n                mintAmount_,\n                ts\n            );\n        } else {\n            uint256 denominator = 1 ether;\n            uint256 init0M = init0;\n            uint256 init1M = init1;\n\n            amount0 = FullMath.mulDivRoundingUp(\n                mintAmount_,\n                init0M,\n                denominator\n            );\n            amount1 = FullMath.mulDivRoundingUp(\n                mintAmount_,\n                init1M,\n                denominator\n            );\n\n            /// @dev check ratio against small values that skew init ratio\n            if (FullMath.mulDiv(mintAmount_, init0M, denominator) == 0) {\n                amount0 = 0;\n            }\n            if (FullMath.mulDiv(mintAmount_, init1M, denominator) == 0) {\n                amount1 = 0;\n            }\n\n            uint256 amount0Mint = init0M != 0\n                ? FullMath.mulDiv(amount0, denominator, init0M)\n                : type(uint256).max;\n            uint256 amount1Mint = init1M != 0\n                ? FullMath.mulDiv(amount1, denominator, init1M)\n                : type(uint256).max;\n\n            require(\n                (amount0Mint < amount1Mint ? amount0Mint : amount1Mint) ==\n                    mintAmount_,\n                \"A0&A1\"\n            );\n        }\n\n        _mint(receiver_, mintAmount_);\n\n        // transfer amounts owed to contract\n        if (amount0 > 0) {\n            token0.safeTransferFrom(msg.sender, me, amount0);\n        }\n        if (amount1 > 0) {\n            token1.safeTransferFrom(msg.sender, me, amount1);\n        }\n\n        if (isTotalSupplyGtZero) {\n            for (uint256 i; i < _ranges.length; i++) {\n                Range memory range = _ranges[i];\n                IUniswapV3Pool pool = IUniswapV3Pool(\n                    factory.getPool(\n                        address(token0),\n                        address(token1),\n                        range.feeTier\n                    )\n                );\n                uint128 liquidity = Position.getLiquidityByRange(\n                    pool,\n                    me,\n                    range.lowerTick,\n                    range.upperTick\n                );\n                if (liquidity == 0) continue;\n\n                liquidity = SafeCast.toUint128(\n                    FullMath.mulDiv(liquidity, mintAmount_, ts)\n                );\n\n                pool.mint(me, range.lowerTick, range.upperTick, liquidity, \"\");\n            }\n        }\n\n        emit LogMint(receiver_, mintAmount_, amount0, amount1);\n    }\n\n    /// @notice burn Arrakis V2 shares and withdraw underlying.\n    /// @param burnAmount_ amount of vault shares to burn.\n    /// @param receiver_ address to receive underlying tokens withdrawn.\n    /// @return amount0 amount of token0 sent to receiver\n    /// @return amount1 amount of token1 sent to receiver\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function burn(uint256 burnAmount_, address receiver_)\n        external\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(burnAmount_ > 0, \"BA\");\n\n        uint256 ts = totalSupply();\n        require(ts > 0, \"TS\");\n\n        _burn(msg.sender, burnAmount_);\n\n        Withdraw memory total;\n        for (uint256 i; i < _ranges.length; i++) {\n            Range memory range = _ranges[i];\n            IUniswapV3Pool pool = IUniswapV3Pool(\n                factory.getPool(address(token0), address(token1), range.feeTier)\n            );\n            uint128 liquidity = Position.getLiquidityByRange(\n                pool,\n                address(this),\n                range.lowerTick,\n                range.upperTick\n            );\n            if (liquidity == 0) continue;\n\n            liquidity = SafeCast.toUint128(\n                FullMath.mulDiv(liquidity, burnAmount_, ts)\n            );\n\n            Withdraw memory withdraw = _withdraw(\n                pool,\n                range.lowerTick,\n                range.upperTick,\n                liquidity\n            );\n\n            total.fee0 += withdraw.fee0;\n            total.fee1 += withdraw.fee1;\n\n            total.burn0 += withdraw.burn0;\n            total.burn1 += withdraw.burn1;\n        }\n\n        if (burnAmount_ == ts) delete _ranges;\n\n        _applyFees(total.fee0, total.fee1);\n\n        uint256 leftOver0 = token0.balanceOf(address(this)) -\n            managerBalance0 -\n            total.burn0;\n        uint256 leftOver1 = token1.balanceOf(address(this)) -\n            managerBalance1 -\n            total.burn1;\n\n        // the proportion of user balance.\n        amount0 = FullMath.mulDiv(leftOver0, burnAmount_, ts);\n        amount1 = FullMath.mulDiv(leftOver1, burnAmount_, ts);\n\n        amount0 += total.burn0;\n        amount1 += total.burn1;\n\n        if (amount0 > 0) {\n            token0.safeTransfer(receiver_, amount0);\n        }\n\n        if (amount1 > 0) {\n            token1.safeTransfer(receiver_, amount1);\n        }\n\n        // For monitoring how much user burn LP token for getting their token back.\n        emit LPBurned(msg.sender, total.burn0, total.burn1);\n        emit LogCollectedFees(total.fee0, total.fee1);\n        emit LogBurn(receiver_, burnAmount_, amount0, amount1);\n    }\n\n    /// @notice rebalance ArrakisV2 vault's UniswapV3 positions\n    /// @param rebalanceParams_ rebalance params, containing ranges where\n    /// we need to collect tokens and ranges where we need to mint liquidity.\n    /// Also contain swap payload to changes token0/token1 proportion.\n    /// @dev only Manager contract can call this function.\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function rebalance(Rebalance calldata rebalanceParams_)\n        external\n        onlyManager\n        nonReentrant\n    {\n        // Burns.\n        IUniswapV3Factory mFactory = factory;\n        IERC20 mToken0 = token0;\n        IERC20 mToken1 = token1;\n\n        {\n            Withdraw memory aggregator;\n            for (uint256 i; i < rebalanceParams_.burns.length; i++) {\n                IUniswapV3Pool pool = IUniswapV3Pool(\n                    mFactory.getPool(\n                        address(mToken0),\n                        address(mToken1),\n                        rebalanceParams_.burns[i].range.feeTier\n                    )\n                );\n\n                uint128 liquidity = Position.getLiquidityByRange(\n                    pool,\n                    address(this),\n                    rebalanceParams_.burns[i].range.lowerTick,\n                    rebalanceParams_.burns[i].range.upperTick\n                );\n\n                if (liquidity == 0) continue;\n\n                uint128 liquidityToWithdraw;\n\n                if (rebalanceParams_.burns[i].liquidity == type(uint128).max)\n                    liquidityToWithdraw = liquidity;\n                else liquidityToWithdraw = rebalanceParams_.burns[i].liquidity;\n\n                Withdraw memory withdraw = _withdraw(\n                    pool,\n                    rebalanceParams_.burns[i].range.lowerTick,\n                    rebalanceParams_.burns[i].range.upperTick,\n                    liquidityToWithdraw\n                );\n\n                if (liquidityToWithdraw == liquidity) {\n                    (bool exists, uint256 index) = Position.rangeExists(\n                        _ranges,\n                        rebalanceParams_.burns[i].range\n                    );\n                    require(exists, \"RRNE\");\n\n                    _ranges[index] = _ranges[_ranges.length - 1];\n                    _ranges.pop();\n                }\n\n                aggregator.burn0 += withdraw.burn0;\n                aggregator.burn1 += withdraw.burn1;\n\n                aggregator.fee0 += withdraw.fee0;\n                aggregator.fee1 += withdraw.fee1;\n            }\n\n            require(aggregator.burn0 >= rebalanceParams_.minBurn0, \"B0\");\n            require(aggregator.burn1 >= rebalanceParams_.minBurn1, \"B1\");\n\n            if (aggregator.fee0 > 0 || aggregator.fee1 > 0) {\n                _applyFees(aggregator.fee0, aggregator.fee1);\n\n                emit LogCollectedFees(aggregator.fee0, aggregator.fee1);\n            }\n        }\n\n        // Swap.\n        if (rebalanceParams_.swap.amountIn > 0) {\n            require(_routers.contains(rebalanceParams_.swap.router), \"NR\");\n\n            uint256 balance0Before = mToken0.balanceOf(address(this));\n            uint256 balance1Before = mToken1.balanceOf(address(this));\n\n            mToken0.safeApprove(address(rebalanceParams_.swap.router), 0);\n            mToken1.safeApprove(address(rebalanceParams_.swap.router), 0);\n\n            mToken0.safeApprove(\n                address(rebalanceParams_.swap.router),\n                balance0Before\n            );\n            mToken1.safeApprove(\n                address(rebalanceParams_.swap.router),\n                balance1Before\n            );\n\n            (bool success, ) = rebalanceParams_.swap.router.call(\n                rebalanceParams_.swap.payload\n            );\n            require(success, \"SC\");\n\n            uint256 balance0After = mToken0.balanceOf(address(this));\n            uint256 balance1After = mToken1.balanceOf(address(this));\n            if (rebalanceParams_.swap.zeroForOne) {\n                require(\n                    (balance1After >=\n                        balance1Before +\n                            rebalanceParams_.swap.expectedMinReturn) &&\n                        (balance0After >=\n                            balance0Before - rebalanceParams_.swap.amountIn),\n                    \"SF\"\n                );\n                balance0After = balance0Before - balance0After;\n                balance1After = balance1After - balance1Before;\n            } else {\n                require(\n                    (balance0After >=\n                        balance0Before +\n                            rebalanceParams_.swap.expectedMinReturn) &&\n                        (balance1After >=\n                            balance1Before - rebalanceParams_.swap.amountIn),\n                    \"SF\"\n                );\n                balance0After = balance0After - balance0Before;\n                balance1After = balance1Before - balance1After;\n            }\n            emit LogRebalance(rebalanceParams_, balance0After, balance1After);\n        } else {\n            emit LogRebalance(rebalanceParams_, 0, 0);\n        }\n\n        // Mints.\n        uint256 aggregator0;\n        uint256 aggregator1;\n        for (uint256 i; i < rebalanceParams_.mints.length; i++) {\n            (bool exists, ) = Position.rangeExists(\n                _ranges,\n                rebalanceParams_.mints[i].range\n            );\n            address pool = factory.getPool(\n                address(token0),\n                address(token1),\n                rebalanceParams_.mints[i].range.feeTier\n            );\n            if (!exists) {\n                // check that the pool exists on Uniswap V3.\n\n                require(pool != address(0), \"NUP\");\n                require(_pools.contains(pool), \"P\");\n                require(\n                    Pool.validateTickSpacing(\n                        pool,\n                        rebalanceParams_.mints[i].range\n                    ),\n                    \"RTS\"\n                );\n\n                _ranges.push(rebalanceParams_.mints[i].range);\n            }\n\n            (uint256 amt0, uint256 amt1) = IUniswapV3Pool(pool).mint(\n                address(this),\n                rebalanceParams_.mints[i].range.lowerTick,\n                rebalanceParams_.mints[i].range.upperTick,\n                rebalanceParams_.mints[i].liquidity,\n                \"\"\n            );\n            aggregator0 += amt0;\n            aggregator1 += amt1;\n        }\n        require(aggregator0 >= rebalanceParams_.minDeposit0, \"D0\");\n        require(aggregator1 >= rebalanceParams_.minDeposit1, \"D1\");\n\n        require(token0.balanceOf(address(this)) >= managerBalance0, \"MB0\");\n        require(token1.balanceOf(address(this)) >= managerBalance1, \"MB1\");\n    }\n\n    /// @notice will send manager fees to manager\n    /// @dev anyone can call this function\n    function withdrawManagerBalance() external nonReentrant {\n        _withdrawManagerBalance();\n    }\n\n    function _withdraw(\n        IUniswapV3Pool pool_,\n        int24 lowerTick_,\n        int24 upperTick_,\n        uint128 liquidity_\n    ) internal returns (Withdraw memory withdraw) {\n        (withdraw.burn0, withdraw.burn1) = pool_.burn(\n            lowerTick_,\n            upperTick_,\n            liquidity_\n        );\n\n        (uint256 collect0, uint256 collect1) = pool_.collect(\n            address(this),\n            lowerTick_,\n            upperTick_,\n            type(uint128).max,\n            type(uint128).max\n        );\n\n        withdraw.fee0 = collect0 - withdraw.burn0;\n        withdraw.fee1 = collect1 - withdraw.burn1;\n    }\n\n    function _applyFees(uint256 fee0_, uint256 fee1_) internal {\n        uint16 mManagerFeeBPS = managerFeeBPS;\n        managerBalance0 += (fee0_ * mManagerFeeBPS) / hundredPercent;\n        managerBalance1 += (fee1_ * mManagerFeeBPS) / hundredPercent;\n    }\n}"
    }
  ]
}