{
  "Title": "[L09] Lack of indexed parameters in events",
  "Content": "Throughout the codebase, there are events defined without any indexed parameters. Some examples are:\n\n\n* Lines [`44-52`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L44-L52) in the `Reserve` contract.\n* Lines [`121-123`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L121-L123) in the `Validators` contract.\n* Line [`43`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L43) in the `SortedOracles` contract.\n* Line [`104-106`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L104-L106) in the `Election` contract.\n* Line [`20`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/BlockchainParameters.sol#L20) in the `BlockchainParameters` contract.\n\n\nConsider [indexing event parameters](https://solidity.readthedocs.io/en/v0.5.12/contracts.html#events) when appropriate, to avoid hindering the task of off-chain services searching and filtering for specific events.\n\n\n***Update**: Fixed in pull requests [#2907](https://github.com/celo-org/celo-monorepo/pull/2907) and [#3125](https://github.com/celo-org/celo-monorepo/pull/3125).  \n\nNow the events have indexed parameters, except for the ones that just emit integer values.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/stability/Reserve.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IReserve.sol\";\nimport \"./interfaces/ISortedOracles.sol\";\nimport \"./interfaces/IStableToken.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\n\n/**\n * @title Ensures price stability of StableTokens with respect to their pegs\n */\ncontract Reserve is IReserve, Ownable, Initializable, UsingRegistry, ReentrancyGuard {\n  using SafeMath for uint256;\n  using FixidityLib for FixidityLib.Fraction;\n\n  struct TobinTaxCache {\n    uint128 numerator;\n    uint128 timestamp;\n  }\n\n  mapping(address => bool) public isToken;\n  address[] private _tokens;\n  TobinTaxCache public tobinTaxCache;\n  uint256 public tobinTaxStalenessThreshold;\n  uint256 public constant TOBIN_TAX_NUMERATOR = 5000000000000000000000; // 0.005\n  mapping(address => bool) public isSpender;\n\n  mapping(address => bool) public isOtherReserveAddress;\n  address[] public otherReserveAddresses;\n\n  bytes32[] public assetAllocationSymbols;\n  uint256[] public assetAllocationWeights;\n\n  uint256 public lastSpendingDay;\n  uint256 public spendingLimit;\n  FixidityLib.Fraction private spendingRatio;\n\n  event TobinTaxStalenessThresholdSet(uint256 value);\n  event DailySpendingRatioSet(uint256 ratio);\n  event TokenAdded(address token);\n  event TokenRemoved(address token, uint256 index);\n  event SpenderAdded(address spender);\n  event SpenderRemoved(address spender);\n  event OtherReserveAddressAdded(address otherReserveAddress);\n  event OtherReserveAddressRemoved(address otherReserveAddress, uint256 index);\n  event AssetAllocationSet(bytes32[] symbols, uint256[] weights);\n\n  modifier isStableToken(address token) {\n    require(isToken[token], \"token addr was never registered\");\n    _;\n  }\n\n  function() external payable {} // solhint-disable no-empty-blocks\n\n  /**\n   * @notice Initializes critical variables.\n   * @param registryAddress The address of the registry contract.\n   * @param _tobinTaxStalenessThreshold The initial number of seconds to cache tobin tax value for.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 _tobinTaxStalenessThreshold,\n    uint256 _spendingRatio\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setTobinTaxStalenessThreshold(_tobinTaxStalenessThreshold);\n    setDailySpendingRatio(_spendingRatio);\n  }\n\n  /**\n   * @notice Sets the number of seconds to cache the tobin tax value for.\n   * @param value The number of seconds to cache the tobin tax value for.\n   */\n  function setTobinTaxStalenessThreshold(uint256 value) public onlyOwner {\n    require(value > 0, \"value was zero\");\n    tobinTaxStalenessThreshold = value;\n    emit TobinTaxStalenessThresholdSet(value);\n  }\n\n  /**\n   * @notice Set the ratio of reserve that is spendable per day.\n   * @param ratio Spending ratio as unwrapped Fraction.\n   */\n  function setDailySpendingRatio(uint256 ratio) public onlyOwner {\n    spendingRatio = FixidityLib.wrap(ratio);\n    require(spendingRatio.lte(FixidityLib.fixed1()), \"spending ratio cannot be larger than 1\");\n    emit DailySpendingRatioSet(ratio);\n  }\n\n  /**\n   * @notice Get daily spending ratio.\n   * @return Spending ratio as unwrapped Fraction.\n   */\n  function getDailySpendingRatio() public view onlyOwner returns (uint256) {\n    return spendingRatio.unwrap();\n  }\n\n  /**\n   * @notice Sets target allocations for Celo Gold and a diversified basket of non-Celo assets.\n   * @param symbols The symbol of each asset in the Reserve portfolio.\n   * @param weights The weight for the corresponding asset as unwrapped Fixidity.Fraction.\n   */\n  function setAssetAllocations(bytes32[] calldata symbols, uint256[] calldata weights)\n    external\n    onlyOwner\n  {\n    require(symbols.length == weights.length, \"Array length mismatch\");\n    FixidityLib.Fraction memory sum = FixidityLib.wrap(0);\n    for (uint256 i = 0; i < weights.length; i++) {\n      sum = sum.add(FixidityLib.wrap(weights[i]));\n    }\n    require(sum.equals(FixidityLib.fixed1()), \"Sum of asset allocation must be 1\");\n    assetAllocationSymbols = symbols;\n    assetAllocationWeights = weights;\n    emit AssetAllocationSet(symbols, weights);\n  }\n\n  /**\n   * @notice Add a token that the reserve will stablize.\n   * @param token The address of the token being stabilized.\n   */\n  function addToken(address token) external onlyOwner nonReentrant returns (bool) {\n    require(!isToken[token], \"token addr already registered\");\n    // Require an exchange rate between the new token and Gold exists.\n    address sortedOraclesAddress = registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID);\n    ISortedOracles sortedOracles = ISortedOracles(sortedOraclesAddress);\n    uint256 tokenAmount;\n    uint256 goldAmount;\n    (tokenAmount, goldAmount) = sortedOracles.medianRate(token);\n    require(goldAmount > 0, \"median rate returned 0 gold\");\n    isToken[token] = true;\n    _tokens.push(token);\n    emit TokenAdded(token);\n    return true;\n  }\n\n  /**\n   * @notice Remove a token that the reserve will no longer stabilize.\n   * @param token The address of the token no longer being stabilized.\n   * @param index The index of the token in _tokens.\n   */\n  function removeToken(address token, uint256 index)\n    external\n    onlyOwner\n    isStableToken(token)\n    returns (bool)\n  {\n    require(\n      index < _tokens.length && _tokens[index] == token,\n      \"index into tokens list not mapped to token\"\n    );\n    isToken[token] = false;\n    address lastItem = _tokens[_tokens.length - 1];\n    _tokens[index] = lastItem;\n    _tokens.length--;\n    emit TokenRemoved(token, index);\n    return true;\n  }\n\n  /**\n   * @notice Add a reserve address whose balance shall be included in the reserve ratio.\n   * @param reserveAddress The reserve address to add.\n   */\n  function addOtherReserveAddress(address reserveAddress)\n    external\n    onlyOwner\n    nonReentrant\n    returns (bool)\n  {\n    require(!isOtherReserveAddress[reserveAddress], \"reserve addr already added\");\n    isOtherReserveAddress[reserveAddress] = true;\n    otherReserveAddresses.push(reserveAddress);\n    emit OtherReserveAddressAdded(reserveAddress);\n    return true;\n  }\n\n  /**\n   * @notice Remove reserve address whose balance shall no longer be included in the reserve ratio.\n   * @param reserveAddress The reserve address to remove.\n   * @param index The index of the reserve address in otherReserveAddresses.\n   */\n  function removeOtherReserveAddress(address reserveAddress, uint256 index)\n    external\n    onlyOwner\n    returns (bool)\n  {\n    require(isOtherReserveAddress[reserveAddress], \"reserve addr was never added\");\n    require(\n      index < otherReserveAddresses.length && otherReserveAddresses[index] == reserveAddress,\n      \"index into reserve list not mapped to address\"\n    );\n    isOtherReserveAddress[reserveAddress] = false;\n    address lastItem = otherReserveAddresses[otherReserveAddresses.length - 1];\n    otherReserveAddresses[index] = lastItem;\n    otherReserveAddresses.length--;\n    emit OtherReserveAddressRemoved(reserveAddress, index);\n    return true;\n  }\n\n  /**\n   * @notice Gives an address permission to spend Reserve funds.\n   * @param spender The address that is allowed to spend Reserve funds.\n   */\n  function addSpender(address spender) external onlyOwner {\n    isSpender[spender] = true;\n    emit SpenderAdded(spender);\n  }\n\n  /**\n   * @notice Takes away an address's permission to spend Reserve funds.\n   * @param spender The address that is to be no longer allowed to spend Reserve funds.\n   */\n  function removeSpender(address spender) external onlyOwner {\n    isSpender[spender] = false;\n    emit SpenderRemoved(spender);\n  }\n\n  /**\n   * @notice Transfer gold.\n   * @param to The address that will receive the gold.\n   * @param value The amount of gold to transfer.\n   */\n  function transferGold(address to, uint256 value) external returns (bool) {\n    require(isSpender[msg.sender], \"sender not allowed to transfer Reserve funds\");\n    uint256 currentDay = now / 1 days;\n    if (currentDay > lastSpendingDay) {\n      uint256 balance = getReserveGoldBalance();\n      lastSpendingDay = currentDay;\n      spendingLimit = spendingRatio.multiply(FixidityLib.newFixed(balance)).fromFixed();\n    }\n    require(spendingLimit >= value, \"Exceeding spending limit\");\n    spendingLimit = spendingLimit.sub(value);\n    require(getGoldToken().transfer(to, value), \"transfer of gold token failed\");\n    return true;\n  }\n\n  /**\n   * @notice Returns the tobin tax, recomputing it if it's stale.\n   * @return The tobin tax amount as a fraction.\n   */\n  function getOrComputeTobinTax() external nonReentrant returns (uint256, uint256) {\n    // solhint-disable-next-line not-rely-on-time\n    if (now.sub(tobinTaxCache.timestamp) > tobinTaxStalenessThreshold) {\n      tobinTaxCache.numerator = uint128(computeTobinTax().unwrap());\n      tobinTaxCache.timestamp = uint128(now); // solhint-disable-line not-rely-on-time\n    }\n    return (uint256(tobinTaxCache.numerator), FixidityLib.fixed1().unwrap());\n  }\n\n  function getTokens() external view returns (address[] memory) {\n    return _tokens;\n  }\n\n  function getOtherReserveAddresses() external view returns (address[] memory) {\n    return otherReserveAddresses;\n  }\n\n  function getAssetAllocationSymbols() external view returns (bytes32[] memory) {\n    return assetAllocationSymbols;\n  }\n\n  function getAssetAllocationWeights() external view returns (uint256[] memory) {\n    return assetAllocationWeights;\n  }\n\n  function getReserveGoldBalance() public view returns (uint256) {\n    uint256 reserveGoldBalance = address(this).balance;\n    for (uint256 i = 0; i < otherReserveAddresses.length; i++) {\n      reserveGoldBalance = reserveGoldBalance.add(otherReserveAddresses[i].balance);\n    }\n    return reserveGoldBalance;\n  }\n\n  /*\n   * Internal functions\n   */\n  /**\n   * @notice Computes a tobin tax based on the reserve ratio.\n   * @return The numerator of the tobin tax amount, where the denominator is 1000.\n   */\n  function computeTobinTax() private view returns (FixidityLib.Fraction memory) {\n    address sortedOraclesAddress = registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID);\n    ISortedOracles sortedOracles = ISortedOracles(sortedOraclesAddress);\n    uint256 reserveGoldBalance = getReserveGoldBalance();\n    uint256 stableTokensValueInGold = 0;\n\n    for (uint256 i = 0; i < _tokens.length; i++) {\n      uint256 stableAmount;\n      uint256 goldAmount;\n      (stableAmount, goldAmount) = sortedOracles.medianRate(_tokens[i]);\n      uint256 stableTokenSupply = IERC20Token(_tokens[i]).totalSupply();\n      uint256 aStableTokenValueInGold = stableTokenSupply.mul(goldAmount).div(stableAmount);\n      stableTokensValueInGold = stableTokensValueInGold.add(aStableTokenValueInGold);\n    }\n\n    // The protocol calls for a 0.5% transfer tax on Celo Gold when the reserve ratio < 2.\n    // The protocol aims to keep half of the reserve value in gold, thus the reserve ratio\n    // is two when the value of gold in the reserve is equal to the total supply of stable tokens.\n    if (reserveGoldBalance >= stableTokensValueInGold) {\n      return FixidityLib.wrap(0);\n    } else {\n      return FixidityLib.wrap(TOBIN_TAX_NUMERATOR);\n    }\n  }\n\n  /**\n   * @notice Mint tokens.\n   * @param to The address that will receive the minted tokens.\n   * @param token The address of the token to mint.\n   * @param value The amount of tokens to mint.\n   */\n  function mintToken(address to, address token, uint256 value)\n    private\n    isStableToken(token)\n    returns (bool)\n  {\n    IStableToken stableToken = IStableToken(token);\n    stableToken.mint(to, value);\n    return true;\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/governance/Validators.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"./interfaces/IValidators.sol\";\n\nimport \"../identity/interfaces/IRandom.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/AddressLinkedList.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title A contract for registering and electing Validator Groups and Validators.\n */\ncontract Validators is\n  IValidators,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using AddressLinkedList for LinkedList.List;\n  using SafeMath for uint256;\n  using BytesLib for bytes;\n\n  // For Validators, these requirements must be met in order to:\n  //   1. Register a validator\n  //   2. Affiliate with and be added to a group\n  //   3. Receive epoch payments (note that the group must meet the group requirements as well)\n  // Accounts may de-register their Validator `duration` seconds after they were last a member of a\n  // group, after which no restrictions on Locked Gold will apply to the account.\n  //\n  // For Validator Groups, these requirements must be met in order to:\n  //   1. Register a group\n  //   2. Add a member to a group\n  //   3. Receive epoch payments\n  // Note that for groups, the requirement value is multiplied by the number of members, and is\n  // enforced for `duration` seconds after the group last had that number of members.\n  // Accounts may de-register their Group `duration` seconds after they were last non-empty, after\n  // which no restrictions on Locked Gold will apply to the account.\n  struct LockedGoldRequirements {\n    uint256 value;\n    // In seconds.\n    uint256 duration;\n  }\n\n  struct ValidatorGroup {\n    bool exists;\n    LinkedList.List members;\n    // TODO(asa): Add a function that allows groups to update their commission.\n    FixidityLib.Fraction commission;\n    // sizeHistory[i] contains the last time the group contained i members.\n    uint256[] sizeHistory;\n    SlashingInfo slashInfo;\n  }\n\n  // Stores the epoch number at which a validator joined a particular group.\n  struct MembershipHistoryEntry {\n    uint256 epochNumber;\n    address group;\n  }\n\n  // Stores the per-epoch membership history of a validator, used to determine which group\n  // commission should be paid to at the end of an epoch.\n  // Stores a timestamp of the last time the validator was removed from a group, used to determine\n  // whether or not a group can de-register.\n  struct MembershipHistory {\n    // The key to the most recent entry in the entries mapping.\n    uint256 tail;\n    // The number of entries in this validators membership history.\n    uint256 numEntries;\n    mapping(uint256 => MembershipHistoryEntry) entries;\n    uint256 lastRemovedFromGroupTimestamp;\n  }\n\n  struct SlashingInfo {\n    FixidityLib.Fraction multiplier;\n    uint256 lastSlashed;\n  }\n\n  struct PublicKeys {\n    bytes ecdsa;\n    bytes bls;\n  }\n\n  struct Validator {\n    PublicKeys publicKeys;\n    address affiliation;\n    FixidityLib.Fraction score;\n    MembershipHistory membershipHistory;\n  }\n\n  // Parameters that govern the calculation of validator's score.\n  struct ValidatorScoreParameters {\n    uint256 exponent;\n    FixidityLib.Fraction adjustmentSpeed;\n  }\n\n  mapping(address => ValidatorGroup) private groups;\n  mapping(address => Validator) private validators;\n  address[] private registeredGroups;\n  address[] private registeredValidators;\n  LockedGoldRequirements public validatorLockedGoldRequirements;\n  LockedGoldRequirements public groupLockedGoldRequirements;\n  ValidatorScoreParameters private validatorScoreParameters;\n  uint256 public membershipHistoryLength;\n  uint256 public maxGroupSize;\n  uint256 public slashingMultiplierResetPeriod;\n\n  event MaxGroupSizeSet(uint256 size);\n  event ValidatorEpochPaymentSet(uint256 value);\n  event ValidatorScoreParametersSet(uint256 exponent, uint256 adjustmentSpeed);\n  event GroupLockedGoldRequirementsSet(uint256 value, uint256 duration);\n  event ValidatorLockedGoldRequirementsSet(uint256 value, uint256 duration);\n  event MembershipHistoryLengthSet(uint256 length);\n  event ValidatorRegistered(address indexed validator, bytes ecdsaPublicKey, bytes blsPublicKey);\n  event ValidatorDeregistered(address indexed validator);\n  event ValidatorAffiliated(address indexed validator, address indexed group);\n  event ValidatorDeaffiliated(address indexed validator, address indexed group);\n  event ValidatorEcdsaPublicKeyUpdated(address indexed validator, bytes ecdsaPublicKey);\n  event ValidatorBlsPublicKeyUpdated(address indexed validator, bytes blsPublicKey);\n  event ValidatorScoreUpdated(address indexed validator, uint256 score, uint256 epochScore);\n  event ValidatorGroupRegistered(address indexed group, uint256 commission);\n  event ValidatorGroupDeregistered(address indexed group);\n  event ValidatorGroupMemberAdded(address indexed group, address indexed validator);\n  event ValidatorGroupMemberRemoved(address indexed group, address indexed validator);\n  event ValidatorGroupMemberReordered(address indexed group, address indexed validator);\n  event ValidatorGroupCommissionUpdated(address indexed group, uint256 commission);\n  event ValidatorEpochPaymentDistributed(\n    address indexed validator,\n    uint256 validatorPayment,\n    address indexed group,\n    uint256 groupPayment\n  );\n\n  modifier onlyVm() {\n    require(msg.sender == address(0), \"Only VM can call\");\n    _;\n  }\n\n  /**\n   * @notice Initializes critical variables.\n   * @param registryAddress The address of the registry contract.\n   * @param groupRequirementValue The Locked Gold requirement amount for groups.\n   * @param groupRequirementDuration The Locked Gold requirement duration for groups.\n   * @param validatorRequirementValue The Locked Gold requirement amount for validators.\n   * @param validatorRequirementDuration The Locked Gold requirement duration for validators.\n   * @param validatorScoreExponent The exponent used in calculating validator scores.\n   * @param validatorScoreAdjustmentSpeed The speed at which validator scores are adjusted.\n   * @param _membershipHistoryLength The max number of entries for validator membership history.\n   * @param _maxGroupSize The maximum group size.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 groupRequirementValue,\n    uint256 groupRequirementDuration,\n    uint256 validatorRequirementValue,\n    uint256 validatorRequirementDuration,\n    uint256 validatorScoreExponent,\n    uint256 validatorScoreAdjustmentSpeed,\n    uint256 _membershipHistoryLength,\n    uint256 _slashingMultiplierResetPeriod,\n    uint256 _maxGroupSize\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setGroupLockedGoldRequirements(groupRequirementValue, groupRequirementDuration);\n    setValidatorLockedGoldRequirements(validatorRequirementValue, validatorRequirementDuration);\n    setValidatorScoreParameters(validatorScoreExponent, validatorScoreAdjustmentSpeed);\n    setMaxGroupSize(_maxGroupSize);\n    setMembershipHistoryLength(_membershipHistoryLength);\n    setSlashingMultiplierResetPeriod(_slashingMultiplierResetPeriod);\n  }\n\n  /**\n   * @notice Updates the maximum number of members a group can have.\n   * @param size The maximum group size.\n   * @return True upon success.\n   */\n  function setMaxGroupSize(uint256 size) public onlyOwner returns (bool) {\n    require(0 < size, \"Max group size cannot be zero\");\n    require(size != maxGroupSize, \"Max group size not changed\");\n    maxGroupSize = size;\n    emit MaxGroupSizeSet(size);\n    return true;\n  }\n\n  /**\n   * @notice Updates the number of validator group membership entries to store.\n   * @param length The number of validator group membership entries to store.\n   * @return True upon success.\n   */\n  function setMembershipHistoryLength(uint256 length) public onlyOwner returns (bool) {\n    require(0 < length, \"Membership history length cannot be zero\");\n    require(length != membershipHistoryLength, \"Membership history length not changed\");\n    membershipHistoryLength = length;\n    emit MembershipHistoryLengthSet(length);\n    return true;\n  }\n\n  /**\n   * @notice Updates the validator score parameters.\n   * @param exponent The exponent used in calculating the score.\n   * @param adjustmentSpeed The speed at which the score is adjusted.\n   * @return True upon success.\n   */\n  function setValidatorScoreParameters(uint256 exponent, uint256 adjustmentSpeed)\n    public\n    onlyOwner\n    returns (bool)\n  {\n    require(\n      adjustmentSpeed <= FixidityLib.fixed1().unwrap(),\n      \"Adjustment speed cannot be larger than 1\"\n    );\n    require(\n      exponent != validatorScoreParameters.exponent ||\n        !FixidityLib.wrap(adjustmentSpeed).equals(validatorScoreParameters.adjustmentSpeed),\n      \"Adjustment speed and exponent not changed\"\n    );\n    validatorScoreParameters = ValidatorScoreParameters(\n      exponent,\n      FixidityLib.wrap(adjustmentSpeed)\n    );\n    emit ValidatorScoreParametersSet(exponent, adjustmentSpeed);\n    return true;\n  }\n\n  /**\n   * @notice Returns the maximum number of members a group can add.\n   * @return The maximum number of members a group can add.\n   */\n  function getMaxGroupSize() external view returns (uint256) {\n    return maxGroupSize;\n  }\n\n  /**\n   * @notice Updates the Locked Gold requirements for Validator Groups.\n   * @param value The per-member amount of Locked Gold required.\n   * @param duration The time (in seconds) that these requirements persist for.\n   * @return True upon success.\n   */\n  function setGroupLockedGoldRequirements(uint256 value, uint256 duration)\n    public\n    onlyOwner\n    returns (bool)\n  {\n    LockedGoldRequirements storage requirements = groupLockedGoldRequirements;\n    require(\n      value != requirements.value || duration != requirements.duration,\n      \"Group requirements not changed\"\n    );\n    groupLockedGoldRequirements = LockedGoldRequirements(value, duration);\n    emit GroupLockedGoldRequirementsSet(value, duration);\n    return true;\n  }\n\n  /**\n   * @notice Updates the Locked Gold requirements for Validators.\n   * @param value The amount of Locked Gold required.\n   * @param duration The time (in seconds) that these requirements persist for.\n   * @return True upon success.\n   */\n  function setValidatorLockedGoldRequirements(uint256 value, uint256 duration)\n    public\n    onlyOwner\n    returns (bool)\n  {\n    LockedGoldRequirements storage requirements = validatorLockedGoldRequirements;\n    require(\n      value != requirements.value || duration != requirements.duration,\n      \"Validator requirements not changed\"\n    );\n    validatorLockedGoldRequirements = LockedGoldRequirements(value, duration);\n    emit ValidatorLockedGoldRequirementsSet(value, duration);\n    return true;\n  }\n\n  /**\n   * @notice Registers a validator unaffiliated with any validator group.\n   * @param ecdsaPublicKey The ECDSA public key that the validator is using for consensus, should\n   *   match the validator signer. 64 bytes.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @return True upon success.\n   * @dev Fails if the account is already a validator or validator group.\n   * @dev Fails if the account does not have sufficient Locked Gold.\n   */\n  function registerValidator(\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant returns (bool) {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(!isValidator(account) && !isValidatorGroup(account), \"Already registered\");\n    uint256 lockedGoldBalance = getLockedGold().getAccountTotalLockedGold(account);\n    require(lockedGoldBalance >= validatorLockedGoldRequirements.value, \"Deposit too small\");\n    Validator storage validator = validators[account];\n    address signer = getAccounts().getValidatorSigner(account);\n    _updateEcdsaPublicKey(validator, signer, ecdsaPublicKey);\n    _updateBlsPublicKey(validator, account, blsPublicKey, blsPop);\n    registeredValidators.push(account);\n    updateMembershipHistory(account, address(0));\n    emit ValidatorRegistered(account, ecdsaPublicKey, blsPublicKey);\n    return true;\n  }\n\n  /**\n   * @notice Returns the parameters that goven how a validator's score is calculated.\n   * @return The parameters that goven how a validator's score is calculated.\n   */\n  function getValidatorScoreParameters() external view returns (uint256, uint256) {\n    return (validatorScoreParameters.exponent, validatorScoreParameters.adjustmentSpeed.unwrap());\n  }\n\n  /**\n   * @notice Returns the group membership history of a validator.\n   * @param account The validator whose membership history to return.\n   * @return The group membership history of a validator.\n   */\n  function getMembershipHistory(address account)\n    external\n    view\n    returns (uint256[] memory, address[] memory, uint256, uint256)\n  {\n    MembershipHistory storage history = validators[account].membershipHistory;\n    uint256[] memory epochs = new uint256[](history.numEntries);\n    address[] memory membershipGroups = new address[](history.numEntries);\n    for (uint256 i = 0; i < history.numEntries; i = i.add(1)) {\n      uint256 index = history.tail.add(i);\n      epochs[i] = history.entries[index].epochNumber;\n      membershipGroups[i] = history.entries[index].group;\n    }\n    return (epochs, membershipGroups, history.lastRemovedFromGroupTimestamp, history.tail);\n  }\n\n  /**\n   * @notice Calculates the validator score for an epoch from the uptime value for the epoch.\n   * @param uptime The Fixidity representation of the validator's uptime, between 0 and 1.\n   * @dev epoxh_score = uptime ** exponent\n   * @return Fixidity representation of the epoch score btween 0 and 1.\n   */\n  function calculateEpochScore(uint256 uptime) public view returns (uint256) {\n    require(uptime <= FixidityLib.fixed1().unwrap(), \"Uptime cannot be larger than one\");\n    uint256 numerator;\n    uint256 denominator;\n    (numerator, denominator) = fractionMulExp(\n      FixidityLib.fixed1().unwrap(),\n      FixidityLib.fixed1().unwrap(),\n      uptime,\n      FixidityLib.fixed1().unwrap(),\n      validatorScoreParameters.exponent,\n      18\n    );\n    return FixidityLib.newFixedFraction(numerator, denominator).unwrap();\n  }\n\n  /**\n   * @notice Calculates the aggregate score of a group for an epoch from individual uptimes.\n   * @param uptimes Array of Fixidity representations of the validators' uptimes, between 0 and 1.\n   * @dev group_score = average(uptimes ** exponent)\n   * @return Fixidity representation of the group epoch score btween 0 and 1.\n   */\n  function calculateGroupEpochScore(uint256[] calldata uptimes) external view returns (uint256) {\n    require(uptimes.length > 0, \"Uptime array empty\");\n    require(uptimes.length <= maxGroupSize, \"Uptime array larger than maximum group size\");\n    FixidityLib.Fraction memory sum;\n    for (uint256 i = 0; i < uptimes.length; i = i.add(1)) {\n      sum = sum.add(FixidityLib.wrap(calculateEpochScore(uptimes[i])));\n    }\n    return sum.divide(FixidityLib.newFixed(uptimes.length)).unwrap();\n  }\n\n  /**\n   * @notice Updates a validator's score based on its uptime for the epoch.\n   * @param signer The validator signer of the validator account whose score needs updating.\n   * @param uptime The Fixidity representation of the validator's uptime, between 0 and 1.\n   * @return True upon success.\n   */\n  function updateValidatorScoreFromSigner(address signer, uint256 uptime) external onlyVm() {\n    _updateValidatorScoreFromSigner(signer, uptime);\n  }\n\n  /**\n   * @notice Updates a validator's score based on its uptime for the epoch.\n   * @param signer The validator signer of the validator whose score needs updating.\n   * @param uptime The Fixidity representation of the validator's uptime, between 0 and 1.\n   * @dev new_score = uptime ** exponent * adjustmentSpeed + old_score * (1 - adjustmentSpeed)\n   * @return True upon success.\n   */\n  function _updateValidatorScoreFromSigner(address signer, uint256 uptime) internal {\n    address account = getAccounts().signerToAccount(signer);\n    require(isValidator(account), \"Not a validator\");\n\n    FixidityLib.Fraction memory epochScore = FixidityLib.wrap(calculateEpochScore(uptime));\n    FixidityLib.Fraction memory newComponent = validatorScoreParameters.adjustmentSpeed.multiply(\n      epochScore\n    );\n\n    FixidityLib.Fraction memory currentComponent = FixidityLib.fixed1().subtract(\n      validatorScoreParameters.adjustmentSpeed\n    );\n    currentComponent = currentComponent.multiply(validators[account].score);\n    validators[account].score = FixidityLib.wrap(\n      Math.min(epochScore.unwrap(), newComponent.add(currentComponent).unwrap())\n    );\n    emit ValidatorScoreUpdated(account, validators[account].score.unwrap(), epochScore.unwrap());\n  }\n\n  /**\n   * @notice Distributes epoch payments to the account associated with `signer` and its group.\n   * @param signer The validator signer of the account to distribute the epoch payment to.\n   * @param maxPayment The maximum payment to the validator. Actual payment is based on score and\n   *   group commission.\n   * @return The total payment paid to the validator and their group.\n   */\n  function distributeEpochPaymentsFromSigner(address signer, uint256 maxPayment)\n    external\n    onlyVm()\n    returns (uint256)\n  {\n    return _distributeEpochPaymentsFromSigner(signer, maxPayment);\n  }\n\n  /**\n   * @notice Distributes epoch payments to the account associated with `signer` and its group.\n   * @param signer The validator signer of the validator to distribute the epoch payment to.\n   * @param maxPayment The maximum payment to the validator. Actual payment is based on score and\n   *   group commission.\n   * @return The total payment paid to the validator and their group.\n   */\n  function _distributeEpochPaymentsFromSigner(address signer, uint256 maxPayment)\n    internal\n    returns (uint256)\n  {\n    address account = getAccounts().signerToAccount(signer);\n    require(isValidator(account), \"Not a validator\");\n    // The group that should be paid is the group that the validator was a member of at the\n    // time it was elected.\n    address group = getMembershipInLastEpoch(account);\n    // Both the validator and the group must maintain the minimum locked gold balance in order to\n    // receive epoch payments.\n    if (meetsAccountLockedGoldRequirements(account) && meetsAccountLockedGoldRequirements(group)) {\n      FixidityLib.Fraction memory totalPayment = FixidityLib.newFixed(maxPayment).multiply(\n        validators[account].score\n      );\n      uint256 groupPayment = totalPayment.multiply(groups[group].commission).fromFixed();\n      uint256 validatorPayment = totalPayment.fromFixed().sub(groupPayment);\n      getStableToken().mint(group, groupPayment);\n      getStableToken().mint(account, validatorPayment);\n      emit ValidatorEpochPaymentDistributed(account, validatorPayment, group, groupPayment);\n      return totalPayment.fromFixed();\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * @notice De-registers a validator.\n   * @param index The index of this validator in the list of all registered validators.\n   * @return True upon success.\n   * @dev Fails if the account is not a validator.\n   * @dev Fails if the validator has been a member of a group too recently.\n   */\n  function deregisterValidator(uint256 index) external nonReentrant returns (bool) {\n    address account = getAccounts().validatorSignerToAccount(msg.sender);\n    require(isValidator(account), \"Not a validator\");\n\n    // Require that the validator has not been a member of a validator group for\n    // `validatorLockedGoldRequirements.duration` seconds.\n    Validator storage validator = validators[account];\n    if (validator.affiliation != address(0)) {\n      require(\n        !groups[validator.affiliation].members.contains(account),\n        \"Has been group member recently\"\n      );\n    }\n    uint256 requirementEndTime = validator.membershipHistory.lastRemovedFromGroupTimestamp.add(\n      validatorLockedGoldRequirements.duration\n    );\n    require(requirementEndTime < now, \"Not yet requirement end time\");\n\n    // Remove the validator.\n    deleteElement(registeredValidato"
    }
  ]
}