{
  "Title": "[M-15] AddLiquidity and decreaseLiquidity missing slippage protection",
  "Content": "\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/LiquidityPosition.sol#L195> \n\n<https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/LiquidityPosition.sol#L258>\n\nWhen user mint NFT add liquidity, user can specify two parameter, params.amount0Min and params.amount1Min\n\n            // mint the position\n            (tokenId, liquidity, amount0Minted, amount1Minted) = Base.UNI_POSITION_MANAGER.mint(\n                INonfungiblePositionManager.MintParams({\n                    token0: params.token0,\n                    token1: params.token1,\n                    fee: params.fee,\n                    tickLower: params.tickLower,\n                    tickUpper: params.tickUpper,\n                    amount0Desired: params.amount0ToMint,\n                    amount1Desired: params.amount1ToMint,\n                    amount0Min: params.amount0Min,\n                    amount1Min: params.amount1Min,\n                    recipient: address(this),\n                    deadline: block.timestamp\n                })\n            );\n\nIf the minted amount is too small, transaction revert [in this check](https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/base/LiquidityManagement.sol#L88) in Uniswap position manager when addling liquidity.\n\n```solidity\n(amount0, amount1) = pool.mint(\n\tparams.recipient,\n\tparams.tickLower,\n\tparams.tickUpper,\n\tliquidity,\n\tabi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))\n);\n\nrequire(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check');\n```\n\nHowever, when addling liquidity, the parameter [amount0Min and amount1Min is set to 0](https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/LiquidityPosition.sol#L195).\n\n```solidity\n// increase liquidity via position manager\n(liquidity, amount0Added, amount1Added) = Base.UNI_POSITION_MANAGER.increaseLiquidity(\n\tINonfungiblePositionManager.IncreaseLiquidityParams({\n\t\ttokenId: tokenId,\n\t\tamount0Desired: amount0,\n\t\tamount1Desired: amount1,\n\t\tamount0Min: 0,\n\t\tamount1Min: 0,\n\t\tdeadline: block.timestamp\n\t})\n);\n```\n\nAs Uniswap V3 docs highlight:\n\n<https://docs.uniswap.org/contracts/v3/guides/providing-liquidity/mint-a-position#calling-mint>\n\n> We set amount0Min and amount1Min to zero for the example - but this would be a vulnerability in production. A function calling mint with no slippage protection would be vulnerable to a frontrunning attack designed to execute the mint call at an inaccurate price.\n\nIf the user transaction suffers from frontrunning, a much less amount of token can be minted.\n\nSame issue happens when user decrease liquidity:\n\n```solidity\n    function decreaseLiquidity(uint256 tokenId, uint128 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n    }\n```\n\nThe amount0 and amount1Min are set to 0.\n\nWhen MEV bot frontruns the decrease liquidity, much less amount0 and amount1 are released.\n\n### Recommended Mitigation Steps\n\nRecommend do not hardcode slippage protection parameter amount0Min and amount1Min to 0 when increase liquidity or decrease liquidity.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/2#issuecomment-1866962114):**\n > This seems valid and serious. Worth adding as user-controlled parameters.\n\n**[wukong-particle (Particle) confirmed and commented](https://github.com/code-423n4/2023-12-particle-findings/issues/2#issuecomment-1868137592):**\n > Agreed. Will add slippage protection when increase/decrease liquidity. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/libraries/LiquidityPosition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {DataStruct} from \"./Structs.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {Base} from \"./Base.sol\";\n\n/// @title Liquidity Position\n/// @notice Represents a liquidity position's underlying owner and fee tokens accrued from lending\nlibrary LiquidityPosition {\n    struct Info {\n        address owner;\n        uint32 renewalCutoffTime; ///@dev loans before this time can't be renewed\n        uint128 token0Owed;\n        uint128 token1Owed;\n    }\n\n    event SupplyLiquidity(uint256 tokenId, address lp, uint128 liquidity);\n    event IncreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event DecreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event CollectLiquidity(address lp, address token0, address token1, uint256 amount0, uint256 amount1);\n\n    /*=============================================================\n                               Info Logic\n    ==============================================================*/\n\n    /**\n     * @notice Getter for a liquidity position's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return renewalCutoffTime renewal cutoff time for all previous loans\n     */\n    function getRenewalCutoffTime(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint32 renewalCutoffTime) {\n        renewalCutoffTime = self[tokenId].renewalCutoffTime;\n    }\n\n    /**\n     * @notice Getter for a liquidity position's tokens currently owed to owner\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return token0Owed The amount of token0 owed to the owner\n     * @return token1Owed The amount of token1 owed to the owner\n     */\n    function getTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint128 token0Owed, uint128 token1Owed) {\n        Info memory info = self[tokenId];\n        token0Owed = info.token0Owed;\n        token1Owed = info.token1Owed;\n    }\n\n    /*=============================================================\n                            Tokens Owed Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's owed tokens\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @param token0Owed The amount of token0 owed to the owner to be added\n     * @param token1Owed The amount of token1 owed to the owner to be added\n     */\n    function addTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 token0Owed,\n        uint128 token1Owed\n    ) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed += token0Owed;\n        info.token1Owed += token1Owed;\n    }\n\n    /**\n     * @notice Reset a liquidity positon's owed tokens to 0\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function resetTokensOwed(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed = 0;\n        info.token1Owed = 0;\n    }\n\n    /*=============================================================\n                           Renewal Time Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function updateRenewalCutoffTime(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.renewalCutoffTime = uint32(block.timestamp);\n    }\n\n    /*=============================================================\n                               Mint Logic\n    ==============================================================*/\n\n    /**\n     * @notice Supply liquidity to mint position NFT to the contract\n     * @param self The mapping containing all liquidity positions\n     * @param params mint parameters containing token pairs, fee, tick info and amount to mint\n     * @return tokenId newly minted tokenId\n     * @return liquidity amount of liquidity minted\n     * @return amount0Minted amount of token 0 minted\n     * @return amount1Minted amount of token 1 minted\n     */\n\n    function mint(\n        mapping(uint256 => Info) storage self,\n        DataStruct.MintParams calldata params\n    ) internal returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted) {\n        // transfer in the tokens\n        TransferHelper.safeTransferFrom(params.token0, msg.sender, address(this), params.amount0ToMint);\n        TransferHelper.safeTransferFrom(params.token1, msg.sender, address(this), params.amount1ToMint);\n\n        // approve position manager to spend the tokens\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, params.amount0ToMint);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, params.amount1ToMint);\n\n        // mint the position\n        (tokenId, liquidity, amount0Minted, amount1Minted) = Base.UNI_POSITION_MANAGER.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: params.token0,\n                token1: params.token1,\n                fee: params.fee,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                amount0Desired: params.amount0ToMint,\n                amount1Desired: params.amount1ToMint,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        // create the LP position\n        self[tokenId] = LiquidityPosition.Info({owner: msg.sender, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n\n        // reset the approval\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n\n        // refund if necessary\n        Base.refund(msg.sender, params.token0, params.amount0ToMint, amount0Minted);\n        Base.refund(msg.sender, params.token1, params.amount1ToMint, amount1Minted);\n\n        emit SupplyLiquidity(tokenId, msg.sender, liquidity);\n    }\n\n    /*=============================================================\n                        Increase Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Increase liquidity to a liquidity position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param token0 The address of token0\n     * @param token1 The address of token1\n     * @param tokenId The token id of the liquidity position NFT\n     * @param amount0 The amount of token0 to add to the liquidity position\n     * @param amount1 The amount of token1 to add to the liquidity position\n     * @return liquidity The amount of liquidity added\n     * @return amount0Added The amount of token0 added\n     * @return amount1Added The amount of token1 added\n     */\n    function increaseLiquidity(\n        address token0,\n        address token1,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        // approve spending for uniswap's position manager\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, amount0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, amount1);\n\n        // increase liquidity via position manager\n        (liquidity, amount0Added, amount1Added) = Base.UNI_POSITION_MANAGER.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: tokenId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        // reset approval\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n    }\n\n    /**\n     * @notice Increase liquidity of a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0 amount to add for token 0\n     * @param amount1 amount to add for token 1\n     * @return liquidity amount of liquidity added\n     * @return amount0Added amount of token 0 added\n     * @return amount1Added amount of token 1 added\n     */\n    function increaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n\n        // get token0 and token1 from the position NFT\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n\n        // transfer in liquidity to add\n        TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0);\n        TransferHelper.safeTransferFrom(token1, msg.sender, address(this), amount1);\n\n        // add liquidity\n        (liquidity, amount0Added, amount1Added) = increaseLiquidity(token0, token1, tokenId, amount0, amount1);\n\n        // refund if necessary\n        Base.refund(msg.sender, token0, amount0, amount0Added);\n        Base.refund(msg.sender, token1, amount1, amount1Added);\n\n        emit IncreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Decrease Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Decrease liquidity from an existing position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount to decrease\n     * @return amount0 amount decreased for token0\n     * @return amount1 amount decreased for token1\n     */\n    function decreaseLiquidity(uint256 tokenId, uint128 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n    }\n\n    /**\n     * @notice Decrease liquidity from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount of liquidity to add\n     * @return amount0Decreased amount of token 0 decreased\n     * @return amount1Decreased amount of token 1 decreased\n     */\n    function decreaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 liquidity\n    ) internal returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Decreased, amount1Decreased) = decreaseLiquidity(tokenId, liquidity);\n        emit DecreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Collect Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Collect fees from a position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0Max maximum amount of token0 to collect\n     * @param amount1Max maximum amount of token1 to collect\n     * @param recipient the address to collect the liquidity\n     * @return amount0 amount collected for token0\n     * @return amount1 amount collected for token1\n     */\n    function collectLiquidity(\n        uint256 tokenId,\n        uint128 amount0Max,\n        uint128 amount1Max,\n        address recipient\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: recipient,\n                amount0Max: amount0Max,\n                amount1Max: amount1Max\n            })\n        );\n    }\n\n    /**\n     * @notice Collect fees from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @return amount0Collected amount of fees collected in token 0\n     * @return amount1Collected amount of fees collected in token 1\n     */\n    function collectLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal returns (uint256 amount0Collected, uint256 amount1Collected) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Collected, amount1Collected) = LiquidityPosition.collectLiquidity(\n            tokenId,\n            type(uint128).max,\n            type(uint128).max,\n            msg.sender\n        );\n        (uint128 token0Owed, uint128 token1Owed) = getTokensOwed(self, tokenId);\n        resetTokensOwed(self, tokenId);\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n        if (token0Owed > 0) {\n            amount0Collected += token0Owed;\n            TransferHelper.safeTransfer(token0, msg.sender, token0Owed);\n        }\n        if (token1Owed > 0) {\n            amount1Collected += token1Owed;\n            TransferHelper.safeTransfer(token1, msg.sender, token1Owed);\n        }\n\n        emit CollectLiquidity(msg.sender, token0, token1, amount0Collected, amount1Collected);\n    }\n\n    /*=============================================================\n                         Reclaim Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice LP reclaims borrowed liquidity from being renewed\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     */\n    function reclaimLiquidity(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        updateRenewalCutoffTime(self, tokenId);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LiquidityPosition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {DataStruct} from \"./Structs.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {Base} from \"./Base.sol\";\n\n/// @title Liquidity Position\n/// @notice Represents a liquidity position's underlying owner and fee tokens accrued from lending\nlibrary LiquidityPosition {\n    struct Info {\n        address owner;\n        uint32 renewalCutoffTime; ///@dev loans before this time can't be renewed\n        uint128 token0Owed;\n        uint128 token1Owed;\n    }\n\n    event SupplyLiquidity(uint256 tokenId, address lp, uint128 liquidity);\n    event IncreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event DecreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event CollectLiquidity(address lp, address token0, address token1, uint256 amount0, uint256 amount1);\n\n    /*=============================================================\n                               Info Logic\n    ==============================================================*/\n\n    /**\n     * @notice Getter for a liquidity position's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return renewalCutoffTime renewal cutoff time for all previous loans\n     */\n    function getRenewalCutoffTime(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint32 renewalCutoffTime) {\n        renewalCutoffTime = self[tokenId].renewalCutoffTime;\n    }\n\n    /**\n     * @notice Getter for a liquidity position's tokens currently owed to owner\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return token0Owed The amount of token0 owed to the owner\n     * @return token1Owed The amount of token1 owed to the owner\n     */\n    function getTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint128 token0Owed, uint128 token1Owed) {\n        Info memory info = self[tokenId];\n        token0Owed = info.token0Owed;\n        token1Owed = info.token1Owed;\n    }\n\n    /*=============================================================\n                            Tokens Owed Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's owed tokens\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @param token0Owed The amount of token0 owed to the owner to be added\n     * @param token1Owed The amount of token1 owed to the owner to be added\n     */\n    function addTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 token0Owed,\n        uint128 token1Owed\n    ) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed += token0Owed;\n        info.token1Owed += token1Owed;\n    }\n\n    /**\n     * @notice Reset a liquidity positon's owed tokens to 0\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function resetTokensOwed(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed = 0;\n        info.token1Owed = 0;\n    }\n\n    /*=============================================================\n                           Renewal Time Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function updateRenewalCutoffTime(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.renewalCutoffTime = uint32(block.timestamp);\n    }\n\n    /*=============================================================\n                               Mint Logic\n    ==============================================================*/\n\n    /**\n     * @notice Supply liquidity to mint position NFT to the contract\n     * @param self The mapping containing all liquidity positions\n     * @param params mint parameters containing token pairs, fee, tick info and amount to mint\n     * @return tokenId newly minted tokenId\n     * @return liquidity amount of liquidity minted\n     * @return amount0Minted amount of token 0 minted\n     * @return amount1Minted amount of token 1 minted\n     */\n\n    function mint(\n        mapping(uint256 => Info) storage self,\n        DataStruct.MintParams calldata params\n    ) internal returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted) {\n        // transfer in the tokens\n        TransferHelper.safeTransferFrom(params.token0, msg.sender, address(this), params.amount0ToMint);\n        TransferHelper.safeTransferFrom(params.token1, msg.sender, address(this), params.amount1ToMint);\n\n        // approve position manager to spend the tokens\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, params.amount0ToMint);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, params.amount1ToMint);\n\n        // mint the position\n        (tokenId, liquidity, amount0Minted, amount1Minted) = Base.UNI_POSITION_MANAGER.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: params.token0,\n                token1: params.token1,\n                fee: params.fee,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                amount0Desired: params.amount0ToMint,\n                amount1Desired: params.amount1ToMint,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        // create the LP position\n        self[tokenId] = LiquidityPosition.Info({owner: msg.sender, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n\n        // reset the approval\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n\n        // refund if necessary\n        Base.refund(msg.sender, params.token0, params.amount0ToMint, amount0Minted);\n        Base.refund(msg.sender, params.token1, params.amount1ToMint, amount1Minted);\n\n        emit SupplyLiquidity(tokenId, msg.sender, liquidity);\n    }\n\n    /*=============================================================\n                        Increase Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Increase liquidity to a liquidity position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param token0 The address of token0\n     * @param token1 The address of token1\n     * @param tokenId The token id of the liquidity position NFT\n     * @param amount0 The amount of token0 to add to the liquidity position\n     * @param amount1 The amount of token1 to add to the liquidity position\n     * @return liquidity The amount of liquidity added\n     * @return amount0Added The amount of token0 added\n     * @return amount1Added The amount of token1 added\n     */\n    function increaseLiquidity(\n        address token0,\n        address token1,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        // approve spending for uniswap's position manager\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, amount0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, amount1);\n\n        // increase liquidity via position manager\n        (liquidity, amount0Added, amount1Added) = Base.UNI_POSITION_MANAGER.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: tokenId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        // reset approval\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n    }\n\n    /**\n     * @notice Increase liquidity of a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0 amount to add for token 0\n     * @param amount1 amount to add for token 1\n     * @return liquidity amount of liquidity added\n     * @return amount0Added amount of token 0 added\n     * @return amount1Added amount of token 1 added\n     */\n    function increaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n\n        // get token0 and token1 from the position NFT\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n\n        // transfer in liquidity to add\n        TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0);\n        TransferHelper.safeTransferFrom(token1, msg.sender, address(this), amount1);\n\n        // add liquidity\n        (liquidity, amount0Added, amount1Added) = increaseLiquidity(token0, token1, tokenId, amount0, amount1);\n\n        // refund if necessary\n        Base.refund(msg.sender, token0, amount0, amount0Added);\n        Base.refund(msg.sender, token1, amount1, amount1Added);\n\n        emit IncreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Decrease Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Decrease liquidity from an existing position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount to decrease\n     * @return amount0 amount decreased for token0\n     * @return amount1 amount decreased for token1\n     */\n    function decreaseLiquidity(uint256 tokenId, uint128 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n    }\n\n    /**\n     * @notice Decrease liquidity from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount of liquidity to add\n     * @return amount0Decreased amount of token 0 decreased\n     * @return amount1Decreased amount of token 1 decreased\n     */\n    function decreaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 liquidity\n    ) internal returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Decreased, amount1Decreased) = decreaseLiquidity(tokenId, liquidity);\n        emit DecreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Collect Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Collect fees from a position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0Max maximum amount of token0 to collect\n     * @param amount1Max maximum amount of token1 to collect\n     * @param recipient the address to collect the liquidity\n     * @return amount0 amount collected for token0\n     * @return amount1 amount collected for token1\n     */\n    function collectLiquidity(\n        uint256 tokenId,\n        uint128 amount0Max,\n        uint128 amount1Max,\n        address recipient\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: recipient,\n                amount0Max: amount0Max,\n                amount1Max: amount1Max\n            })\n        );\n    }\n\n    /**\n     * @notice Collect fees from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @return amount0Collected amount of fees collected in token 0\n     * @return amount1Collected amount of fees collected in token 1\n     */\n    function collectLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal returns (uint256 amount0Collected, uint256 amount1Collected) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Collected, amount1Collected) = LiquidityPosition.collectLiquidity(\n            tokenId,\n            type(uint128).max,\n            type(uint128).max,\n            msg.sender\n        );\n        (uint128 token0Owed, uint128 token1Owed) = getTokensOwed(self, tokenId);\n        resetTokensOwed(self, tokenId);\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n        if (token0Owed > 0) {\n            amount0Collected += token0Owed;\n            TransferHelper.safeTransfer(token0, msg.sender, token0Owed);\n        }\n        if (token1Owed > 0) {\n            amount1Collected += token1Owed;\n            TransferHelper.safeTransfer(token1, msg.sender, token1Owed);\n        }\n\n        emit CollectLiquidity(msg.sender, token0, token1, amount0Collected, amount1Collected);\n    }\n\n    /*=============================================================\n                         Reclaim Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice LP reclaims borrowed liquidity from being renewed\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     */\n    function reclaimLiquidity(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        updateRenewalCutoffTime(self, tokenId);\n    }\n}"
    },
    {
      "filename": "contracts/base/LiquidityManagement.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\n\nimport '../libraries/PoolAddress.sol';\nimport '../libraries/CallbackValidation.sol';\nimport '../libraries/LiquidityAmounts.sol';\n\nimport './PeripheryPayments.sol';\nimport './PeripheryImmutableState.sol';\n\n/// @title Liquidity management functions\n/// @notice Internal functions for safely managing liquidity in Uniswap V3\nabstract contract LiquidityManagement is IUniswapV3MintCallback, PeripheryImmutableState, PeripheryPayments {\n    struct MintCallbackData {\n        PoolAddress.PoolKey poolKey;\n        address payer;\n    }\n\n    /// @inheritdoc IUniswapV3MintCallback\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external override {\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        CallbackValidation.verifyCallback(factory, decoded.poolKey);\n\n        if (amount0Owed > 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);\n        if (amount1Owed > 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);\n    }\n\n    struct AddLiquidityParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        address recipient;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n\n    /// @notice Add liquidity to an initialized pool\n    function addLiquidity(AddLiquidityParams memory params)\n        internal\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1,\n            IUniswapV3Pool pool\n        )\n    {"
    }
  ]
}