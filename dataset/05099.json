{
  "Title": "[M-09] Liquidating chaining can be achieved by liquidating token collateral with the highest `collateralFactor`",
  "Content": "\nThe liquidation mechanism is intended as follows:\n\n- If a user has more borrowed value than weighted collateral, but it does not surpass the 89% of the unweighted collateral, he can be liquidated up to 50% of his borrowed shares.\n- When the borrowed amount surpass the 89% of the unweighted collateral, then it is considered bad debt and the position can be fully liquidated\n\nThis feature is programmed [here](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurityHelper.sol#L876-L900)\n\nHowever, since the liquidator can select which collateral he will receive, he can intentionally liquidate the highest `collateralFactor` tokens in order to make the overall position's `collateralFactor` to go down and being able to keep liquidating the other tokens. Since the intended maximum amount to liquidate when the position has no bad debt is 50%, if a user can intentionally create a sequence of liquidation that leads to a greater percentage it can be considered a high impact vulnerability.\n\n### Written Proof of Concept\n\nImagine the following situation:\n\nThe protocol supports these 4 tokens, A, B, C and D with these `collateralFactors`:\n\n| Token | Collateral factor |\n| :---- | ----------------: |\n| A     |              0.85 |\n| B     |              0.65 |\n| C     |              0.50 |\n| D     |              0.70 |\n\nThe initial prices for these tokens are as follows:\n\n| Token | Price (in ETH) |\n| :---- | -------------: |\n| A     |              1 |\n| B     |            0.2 |\n| C     |            0.5 |\n| D     |              1 |\n\nAlice deposits these 3 amounts of token A, B and C as collateral:\n\n| Token | Value |       Amount | Unweighted value | Weighted value |\n| :---- | ----: | -----------: | ---------------: | -------------: |\n| A     |     1 |           10 |               10 |            8.5 |\n| B     |   0.2 |           50 |               10 |            6.5 |\n| C     |   0.5 |           20 |               10 |              5 |\n|       |       | Total values |               30 |             20 |\n\nAlice can borrow up to `20 * 0.95 = 19` worth of ETH. For the sake of simplicity, since token D is valued 1 ETH, she can borrow up to 19 of token D. However, she decides to borrow 18.9 to have a tiny healthy zone. Unfortunately for Alice, the price of token C drops to 0.25. And the situation continues as follows:\n\n| Token | Value |       Amount | Unweighted value | Weighted value |\n| :---- | ----: | -----------: | ---------------: | -------------: |\n| A     |     1 |           10 |               10 |            8.5 |\n| B     |   0.2 |           50 |               10 |            6.5 |\n| C     |  0.25 |           20 |                5 |            2.5 |\n|       |       | Total values |               25 |           17.5 |\n\nIn this stage, Alice can be liquidated up to 50% because her borrowed amount (18.9 ETH) is greater than her weighted value (17.5 ETH). Just 50% is liquidable because the 89% of her weighted value is greater than her borrowed amount.\n\nLet's now demonstrate that if the liquidator receives the token with the highest `collateralFactor`, the position will still be liquidable and he can chain this function call in order to liquidate a huge amount of collateral.\n\nThe liquidator decides to repay 9.09 shares of token D. He intentionally selects this amount because when added to the fee (10%), the total amount will be 10 worth of ETH. Hence, liquidating this amount, the user is liquidating the whole token A collateral from Alice with the highest `collateralFactor`. The new borrowed value from Alice would be `18.9 - 9.09 = 9.81`.\n\n| Token | Value |       Amount | Unweighted value | Weighted value |\n| :---- | ----: | -----------: | ---------------: | -------------: |\n| A     |     1 |            0 |                0 |              0 |\n| B     |   0.2 |           50 |               10 |            6.5 |\n| C     |  0.25 |           20 |                5 |            2.5 |\n|       |       | Total values |               15 |              9 |\n\nWe can clearly see that the borrowed value is still greater than Alice's weighted value. Hence, she can be liquidated again! See Coded Proof of Concept to see the full chain liquidation.\n\nThe scenario completely changes if the liquidator would be forced to liquidate the collateral with the lowest `collateralFactor`. The liquidator is forced to receive token C (lowest `collateralFactor`). He decides to repay 4.54 worth of token D that when added with the fee (10%) will be 5. The whole value of collateral token C.\n\n| Token | Value |       Amount | Unweighted value | Weighted value |\n| :---- | ----: | -----------: | ---------------: | -------------: |\n| A     |     1 |           10 |               10 |            8.5 |\n| B     |   0.2 |           50 |               10 |            6.5 |\n| C     |  0.25 |            0 |                0 |              0 |\n|       |       | Total values |               20 |             15 |\n\nThe new borrowed value would be `18.9 - 4.54 = 14.36`. This new borrowed value is smaller than the weighted value. Thus, Alice is no longer liquidable and her position is healthy. See coded Proof of Concept.\n\n### Coded Proof of Concept\n\nFor the sake of testing, I adjusted the collateral factors manually when deploying the protocol locally:\n\n```\n            createPoolArray[0] = PoolManager.CreatePool(\n                {\t\n    \t\t\t\t// Token A\n                    allowBorrow: true,\n                    poolToken: address(MOCK_ERC20_1),\n                    poolMulFactor: 17500000000000000,\n                    poolCollFactor: 0.85 ether,\n                    maxDepositAmount: 10000000000000 ether\n                }\n            );\n\n            createPoolArray[1] = PoolManager.CreatePool(\n                {\n    \t\t\t\t// Token B\n                    allowBorrow: true,\n                    poolToken: address(MOCK_ERC20_2),\n                    poolMulFactor: 25000000000000000,\n                    poolCollFactor: 0.65 ether,\n                    maxDepositAmount: 10000000000000 ether\n                }\n            );\n\n            createPoolArray[2] = PoolManager.CreatePool(\n                {\n    \t\t\t\t// Token C\n                    allowBorrow: true,\n                    poolToken: address(MOCK_ERC20_3),\n                    poolMulFactor: 15000000000000000,\n                    poolCollFactor: 0.5 ether,\n                    maxDepositAmount: 10000000000000 ether\n                }\n            );\n\n            createPoolArray[3] = PoolManager.CreatePool(\n                {\n    \t\t\t\t// Token D\n                    allowBorrow: true,\n                    poolToken: address(MOCK_WETH),\n                    poolMulFactor: 17500000000000000,\n                    poolCollFactor: 0.7 ether,\n                    maxDepositAmount: 10000000000000 ether\n                }\n            );\n```\n\nAnd also created a function inside the `MockChainlink` to set the prices of the tokens:\n\n```\n    \tfunction setNewPrice(uint256 newPrice) public {\n            ethValuePerToken = newPrice;\n        }\n```\n\nWith all that said, let's see the PoC for the 2 previously explained situations:\n\nAlice can be liquidated multiple times:\n\n```\n        function testChainLiquidation() public {\n            address token1 = 0xfDf134B61F8139B8ea447eD49e7e6adf62fd4B49;\n            address token2 = 0xEa3aF45ae5a2bAc059Cd026f23E47bdD753E664a;\n            address token3 = 0x15BB461b3a994218fD0D6329E129846F366FFeB3;\n            address token4 = 0x6B9d657Df9Eab179c44Ff9120566A2d423d01Ea9;\n\n            testDeployLocal();\n            skip(1000);\n\n            // Add some tokens4 to have enough liquidity\n            address thirdParty = makeAddr(\"thirdParty\");\n            deal(address(token4), thirdParty, 1_000_000 ether);\n            vm.startPrank(thirdParty);\n            IERC20(token4).approve(address(LENDING_INSTANCE), 1_000_000 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token4, 1_000_000 ether);\n            vm.stopPrank();\n\n            // Initially the price for tokens are:\n            // 1 Token1 = 1 ETH\n            MOCK_CHAINLINK_1.setNewPrice(1 ether);\n            // 1 Token2 = 0.2 ETH\n            MOCK_CHAINLINK_2.setNewPrice(0.2 ether);\n            // 1 Token3 = 0.5 ETH\n            MOCK_CHAINLINK_3.setNewPrice(0.5 ether);\n            // 1 Token4 = 1 ETH\n            MOCK_CHAINLINK_4.setNewPrice(1 ether);\n\n            // Bob is liquidating Alice\n            address alice = makeAddr(\"alice\");\n            address bob = makeAddr(\"bob\");\n            deal(token1, alice, 10 ether);\n            deal(token2, alice, 50 ether);\n            deal(token3, alice, 20 * 10**6);\n            deal(token4, bob, 200 ether);\n\n            vm.startPrank(alice);\n            IERC20(token1).approve(address(LENDING_INSTANCE), 10 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token1, 10 ether);\n            IERC20(token2).approve(address(LENDING_INSTANCE), 50 ether);\n            LENDING_INSTANCE.depositExactAmount(6, token2, 50 ether);\n            IERC20(token3).approve(address(LENDING_INSTANCE), 20 * 10**6);\n            LENDING_INSTANCE.depositExactAmount(6, token3, 20 * 10**6);\n            LENDING_INSTANCE.borrowExactAmount(6, token4, 18.9 ether);\n            uint256 initialBorrowShares = LENDING_INSTANCE.getPositionBorrowShares(6, token4);\n            vm.stopPrank();\n\n            // Time passes and value of token3 drops significantly\n            // 1 Token3 = 0.25 ETH\n            MOCK_CHAINLINK_3.setNewPrice(0.25 ether);\n\n            vm.startPrank(bob);\n            IERC20(token4).approve(address(LENDING_INSTANCE), 200 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token4, 10 ether);\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(6, 7, token4, token1, 9.090909090909 ether);\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(6, 7, token4, token2, 2.7 ether);\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(6, 7, token4, token2, 3.5 ether);\n            vm.stopPrank();\n\n            uint256 finalBorrowShares = LENDING_INSTANCE.getPositionBorrowShares(6, token4);\n\n            uint256 percentageLiquidated = 100 - (finalBorrowShares * 100 / initialBorrowShares);\n            console.log(\"Percentage liquidated\", percentageLiquidated);\n        }\n```\n\nResult:\n\n```\n    [PASS] testChainLiquidation() (gas: 44546965)\n    Logs:\n      Percentage liquidated 81\n\n    Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 38.40ms\n\n    Ran 1 test suite in 38.40ms: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\nWith 3 liquidation calls, the liquidator could repay 81% of Alice's position when in fact, the maximum percentage that the protocol allows when there is no bas debt is 50%.\n\nAlice can only be liquidated once with the asset with lowest `collateralFactor` and then her position becomes healthy:\n\n```\n        function testLiquidationsConstrainted() public {\n            address token1 = 0xfDf134B61F8139B8ea447eD49e7e6adf62fd4B49;\n            address token2 = 0xEa3aF45ae5a2bAc059Cd026f23E47bdD753E664a;\n            address token3 = 0x15BB461b3a994218fD0D6329E129846F366FFeB3;\n            address token4 = 0x6B9d657Df9Eab179c44Ff9120566A2d423d01Ea9;\n\n            uint256 aliceNftPosition = 6;\n            uint256 bobNftPosition = 7;\n\n            testDeployLocal();\n            skip(1000);\n\n            // Add some tokens4 to have enough liquidity\n            address thirdParty = makeAddr(\"thirdParty\");\n            deal(address(token4), thirdParty, 1_000_000 ether);\n            vm.startPrank(thirdParty);\n            IERC20(token4).approve(address(LENDING_INSTANCE), 1_000_000 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token4, 1_000_000 ether);\n            vm.stopPrank();\n\n            // Initially the price for tokens are:\n            // 1 Token1 = 1 ETH\n            MOCK_CHAINLINK_1.setNewPrice(1 ether);\n            // 1 Token2 = 0.2 ETH\n            MOCK_CHAINLINK_2.setNewPrice(0.2 ether);\n            // 1 Token3 = 0.5 ETH\n            MOCK_CHAINLINK_3.setNewPrice(0.5 ether);\n            // 1 Token4 = 1 ETH\n            MOCK_CHAINLINK_4.setNewPrice(1 ether);\n\n            // Bob is liquidating Alice\n            address alice = makeAddr(\"alice\");\n            address bob = makeAddr(\"bob\");\n            deal(token1, alice, 10 ether);\n            deal(token2, alice, 50 ether);\n            deal(token3, alice, 20 * 10**6);\n            deal(token4, bob, 200 ether);\n\n            vm.startPrank(alice);\n            IERC20(token1).approve(address(LENDING_INSTANCE), 10 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token1, 10 ether);\n            IERC20(token2).approve(address(LENDING_INSTANCE), 50 ether);\n            LENDING_INSTANCE.depositExactAmount(aliceNftPosition, token2, 50 ether);\n            IERC20(token3).approve(address(LENDING_INSTANCE), 20 * 10**6);\n            LENDING_INSTANCE.depositExactAmount(aliceNftPosition, token3, 20 * 10**6);\n            LENDING_INSTANCE.borrowExactAmount(aliceNftPosition, token4, 18.9 ether);\n            uint256 initialBorrowShares = LENDING_INSTANCE.getPositionBorrowShares(aliceNftPosition, token4);\n            vm.stopPrank();\n\n            // Time passes and value of token3 drops significantly\n            // 1 Token3 = 0.25 ETH\n            MOCK_CHAINLINK_3.setNewPrice(0.25 ether);\n\n            vm.startPrank(bob);\n            IERC20(token4).approve(address(LENDING_INSTANCE), 200 ether);\n            LENDING_INSTANCE.depositExactAmountMint(token4, 10 ether);\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(aliceNftPosition, bobNftPosition, token4, token3, 4.54 ether);\n\n            // Having liquidated the token with less LVT, the position is no longer liquidable\n            // Try to liquidate with the minimum amount of shares (1)\n            vm.expectRevert();\n            LENDING_INSTANCE.liquidatePartiallyFromTokens(aliceNftPosition, bobNftPosition, token4, token3, 1);\n            vm.stopPrank();\n\n            uint256 finalBorrowShares = LENDING_INSTANCE.getPositionBorrowShares(aliceNftPosition, token4);\n\n            uint256 percentageLiquidated = 100 - (finalBorrowShares * 100 / initialBorrowShares);\n            console.log(\"Percentage liquidated\", percentageLiquidated);\n        }\n```\n\nResult:\n\n```\n    [PASS] testLiquidationsConstrainted() (gas: 44044788)\n    Logs:\n      Percentage liquidated 25\n\n    Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 40.81ms\n\n    Ran 1 test suite in 40.81ms: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\nWith just a single liquidation call, the liquidator could only repay 25% of Alice's position and at that point, her position becomes healthy and she is no longer liquidable.\n\n### Recommended Mitigation Steps\n\nThis issue can be easily solved by forcing all liquidations to be done with the lowest `collateralFactor` tokens first. As shown in the written and coded PoC, if the user would have been forced to receive the collateral token with the lowest `collateralFactor`, the health of the position would go to non-liquidable and the liquidator would not be able to continue liquidating the position.\n\nAlso, a really good safety check would be to ensure that after the liquidation is executed, the health of the position must be good in order to prevent this chain liquidation.\n\n### Assessed type\n\nError\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/202#issuecomment-2007427556):**\n > This is not an issue since the liquidation incentive usually is lower than the difference in percentage between 100 and collateral factor. So paying back in my described scenario always makes the position more healthy. High as a description is overblown! Also, such a force could lead liquidators to be forced to loose money on a specific scenario before being able to access a profitable liquidation endangering the protocol.\n\n**[Trust (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/202#issuecomment-2020860309):**\n > Cascading liquidations are a dangerous situation and I agree with the warden there are no built-in safety mechanisms around it in the liquidation routines (health is monotonically increasing or it is now healthy).\n>\n> However, the warden had to modify the collateral factors to demonstrate the issue in a PoC. It seems hard to determine whether by natural course of action, such a scenario would occur.\n>\n> According to the sponsor's remarks, the `liquidation incentive *usually* is lower than the difference in percentage between 100 and collateral factor.` This has not convinced me it could not occur by chance at some point. In case it does, it leads to higher than expected liquidation penalties. Weighing all the circumstances, I believe Medium to be appropriate.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/202#issuecomment-2082914485):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseSecurity/WiseSecurityHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./WiseSecurityDeclarations.sol\";\n\nabstract contract WiseSecurityHelper is WiseSecurityDeclarations {\n\n    /**\n     * @dev Read function returning weighted and\n     * and unweighted total collateral of a\n     * postion with {_nftId} (unweighted means\n     * collateral factor equals 1E18).\n     */\n    function overallETHCollateralsBoth(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256, uint256)\n    {\n        uint256 amount;\n        uint256 weightedTotal;\n        uint256 unweightedAmount;\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount = getFullCollateralETH(\n                _nftId,\n                tokenAddress\n            );\n\n            weightedTotal += amount\n                * WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                / PRECISION_FACTOR_E18;\n\n            unweightedAmount += amount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (\n            weightedTotal,\n            unweightedAmount\n        );\n    }\n\n    /**\n     * @dev Read function returning weighted\n     *  total collateral of a postion with {_nftId}.\n     */\n    function overallETHCollateralsWeighted(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 weightedTotal)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            weightedTotal += WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                * getFullCollateralETH(\n                    _nftId,\n                    tokenAddress\n                ) / PRECISION_FACTOR_E18;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning unweighted\n     *  total collateral of a postion with {_nftId}\n     * (unweighted means collateral factor equals 1E18).\n     */\n    function overallETHCollateralsBare(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 amount)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            amount += getFullCollateralETH(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal calculation function returning\n     * the updated weighted collateral amount of a\n     * postion with {_nftId}. Result can be\n     * extrapolated linear with length {_interval}.\n     */\n    function _overallETHCollateralsWeighted(\n        uint256 _nftId,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 weightedTotal)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionLendingTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionLendingTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            weightedTotal += WISE_LENDING.lendingPoolData(tokenAddress).collateralFactor\n                * _getCollateralOfTokenETHUpdated(\n                    _nftId,\n                    tokenAddress,\n                    _interval\n                ) / PRECISION_FACTOR_E18;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the full bare\n     * collateral amount of a {_poolToken} from a\n     * {_nftId}. Full means sum of private and\n     * public added funds.\n     */\n    function getFullCollateralETH(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256 ethCollateral)\n    {\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n\n        if (WISE_LENDING.getPositionLendingShares(_nftId, _poolToken) == 0) {\n            return ethCollateral;\n        }\n\n        ethCollateral += getETHCollateral(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Wrapper function checking if a supplied\n     * fund is uncollateralized.\n     */\n    function _isUncollateralized(\n        uint256 _nftId,\n        address _poolToken\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return WISE_LENDING.isUncollateralized(\n            _nftId,\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the full\n     * collateral amount of a {_poolToken} from a\n     * {_nftId} updated to current values.\n     * Full means sum of private and public added\n     * funds. Can be extrapolated linear within\n     * {_interval}.\n     */\n    function _getCollateralOfTokenETHUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 ethCollateral)\n    {\n        ethCollateral = _getTokensInEth(\n            _poolToken,\n            WISE_LENDING.getPureCollateralAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n\n        if (_isUncollateralized(_nftId, _poolToken) == true) {\n            return ethCollateral;\n        }\n\n        ethCollateral += getETHCollateralUpdated(\n            _nftId,\n            _poolToken,\n            _interval\n        );\n    }\n\n    /**\n     * @dev Read function returning the full\n     * (private and public) collateral amount\n     * of a {_poolToken} from a {_nftId} updated\n     * to current values. Can be extrapolated\n     * linear within {_interval}.\n     */\n    function getETHCollateralUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 lendingShares = WISE_LENDING.getPositionLendingShares(\n            _nftId,\n            _poolToken\n        );\n\n        if (lendingShares == 0) {\n            return 0;\n        }\n\n        uint256 currentTotalLendingShares = WISE_LENDING.getTotalDepositShares(\n            _poolToken\n        );\n\n        uint256 updatedPseudo = _getUpdatedPseudoPool(\n            _poolToken,\n            _interval\n        );\n\n        uint256 updatedToken = lendingShares\n            * updatedPseudo\n            / currentTotalLendingShares;\n\n        return _getTokensInEth(\n            _poolToken,\n            updatedToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the public\n     * collateral amount of a {_poolToken} from a\n     * {_nftId}.\n     */\n    function getETHCollateral(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _getTokensInEth(\n            _poolToken,\n            getPositionLendingAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    function _getTokensInEth(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return WISE_ORACLE.getTokensInETH(\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount of a postion with {_nftId}.\n     * No heartbeat or blacklisted checks are\n     * included in this function!\n     */\n    function overallETHBorrowBare(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 buffer)\n    {\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            buffer += getETHBorrow(\n                _nftId,\n                WISE_LENDING.getPositionBorrowTokenByIndex(\n                    _nftId,\n                    i\n                )\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount of a postion with {_nftId}.\n     * No blacklisted check is included\n     * in this function!\n     */\n    function overallETHBorrowHeartbeat(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 buffer)\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            buffer += getETHBorrow(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Read function returning the total\n     * borrow amount of a postion with {_nftId}.\n     */\n    function overallETHBorrow(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256 buffer)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            buffer += getETHBorrow(\n                _nftId,\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function combining hearbeat\n     * and blacklisted checks.\n     */\n    function _checkBlacklisted(\n        address _poolToken\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return wasBlacklisted[_poolToken] == true;\n    }\n\n    /**\n     * @dev Read function returning the total\n     * updated current borrow amount of a\n     * postion with {_nftId}. Can be\n     * extrapolated linear with {_intervall}.\n     */\n    function _overallETHBorrow(\n        uint256 _nftId,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256 buffer)\n    {\n        uint256 i;\n        address tokenAddress;\n\n        uint256 l = WISE_LENDING.getPositionBorrowTokenLength(\n            _nftId\n        );\n\n        while (i < l) {\n\n            tokenAddress = WISE_LENDING.getPositionBorrowTokenByIndex(\n                _nftId,\n                i\n            );\n\n            _checkPoolCondition(\n                tokenAddress\n            );\n\n            buffer += _getETHBorrowUpdated(\n                _nftId,\n                tokenAddress,\n                _interval\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function calculating\n     * the updated pseudo borrow amount of\n     * {_poolToken}. Result can be extrapolated\n     * linear with {_interval}.\n     */\n    function _getUpdatedPseudoBorrow(\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 currentPseudo = WISE_LENDING.getPseudoTotalBorrowAmount(\n            _poolToken\n        );\n\n        return _getInterest(\n            _poolToken,\n            _interval\n        ) + currentPseudo;\n    }\n\n    /**\n     * @dev Internal function calculating\n     * the updated pseudo lending amount of\n     * {_poolToken}. Result can be extrapolated\n     * linear with {_interval}.\n     */\n    function _getUpdatedPseudoPool(\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 currentPseudo = WISE_LENDING.getPseudoTotalPool(\n            _poolToken\n        );\n\n        return _getInterest(_poolToken, _interval)\n            * (PRECISION_FACTOR_E18 - WISE_LENDING.globalPoolData(_poolToken).poolFee)\n            / PRECISION_FACTOR_E18\n            + currentPseudo;\n    }\n\n    /**\n     * @dev Internal math function calculating\n     * the accumulated interest amount for\n     * {_poolToken}. Result can be extrapolated\n     * linear with {_interval}.\n     */\n    function _getInterest(\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        BorrowPoolEntry memory borrowPoolData = WISE_LENDING.borrowPoolData(\n            _poolToken\n        );\n\n        uint256 timeInterval = _interval\n            + block.timestamp\n            - WISE_LENDING.getTimeStamp(_poolToken);\n\n        uint256 rate = timeInterval\n            * borrowPoolData.borrowRate\n            * WISE_LENDING.getPseudoTotalBorrowAmount(_poolToken)\n            / PRECISION_FACTOR_E18\n            / ONE_YEAR;\n\n        return rate;\n    }\n\n    /**\n     * @dev Read function returning the full\n     * borrow amount of a {_poolToken} from a\n     * {_nftId} updated to current values.\n     * Can be extrapolated linear within\n     * {_interval}.\n     */\n    function _getETHBorrowUpdated(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _intervall\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 borrowShares = WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            _poolToken\n        );\n\n        if (borrowShares == 0) {\n            return 0;\n        }\n\n        uint256 currentTotalBorrowShares = WISE_LENDING.getTotalBorrowShares(\n            _poolToken\n        );\n\n        uint256 updatesPseudo = _getUpdatedPseudoBorrow(\n            _poolToken,\n            _intervall\n        );\n\n        uint256 updatedToken = borrowShares\n            * updatesPseudo\n            / currentTotalBorrowShares;\n\n        return _getTokensInEth(\n            _poolToken,\n            updatedToken\n        );\n    }\n\n    /**\n     * @dev Read function returning the borow\n     * amount of a {_poolToken} from a {_nftId}.\n     */\n    function getETHBorrow(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _getTokensInEth(\n            _poolToken,\n            getPositionBorrowAmount(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    /**\n     * @dev Read function checking if\n     * {_poolToken} is allowed to borrow.\n     */\n    function checkTokenAllowed(\n        address _poolAddress\n    )\n        public\n        view\n    {\n        if (WISE_LENDING.borrowPoolData(_poolAddress).allowBorrow == false) {\n            revert NotAllowedToBorrow();\n        }\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeframe\n     */\n    function checkHeartbeat(\n        address _poolToken\n    )\n        public\n        view\n        returns (bool)\n    {\n        return WISE_ORACLE.chainLinkIsDead(_poolToken) == false;\n    }\n\n    /**\n     * @dev Check if the postion with\n     * {_nftId} is locked for interactions.\n     */\n    function _checkPositionLocked(\n        uint256 _nftId\n    )\n        internal\n        view\n    {\n        if (WISE_LENDING.positionLocked(_nftId) == true) {\n            revert PositionLockedWiseSecurity();\n        }\n    }\n\n    /**\n     * @dev Wrapper function for external\n     * {_checkMaxFee} call.\n     */\n    function checkMaxFee(\n        uint256 _paybackETH,\n        uint256 _feeLiquidation,\n        uint256 _maxFeeETH\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return _checkMaxFee(\n            _paybackETH,\n            _feeLiquidation,\n            _maxFeeETH\n        );\n    }\n\n    /**\n     * @dev Returning the possible fee\n     * for liquidation.\n     */\n    function _checkMaxFee(\n        uint256 _paybackETH,\n        uint256 _liquidationFee,\n        uint256 _maxFeeETH\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 feeETH = _paybackETH\n            * _liquidationFee\n            / PRECISION_FACTOR_E18;\n\n        return feeETH < _maxFeeETH\n            ? feeETH\n            : _maxFeeETH;\n    }\n\n    /**\n     * @dev Math function computing the\n     * percentage of the receiving token\n     * which the liquidator receivs for\n     * liquidation.\n     */\n    function calculateWishPercentage(\n        uint256 _nftId,\n        address _receiveToken,\n        uint256 _paybackETH,\n        uint256 _maxFeeETH,\n        uint256 _baseRewardLiquidation\n    )\n        external\n        view\n        returns (uint256)\n    {\n        uint256 feeETH = _checkMaxFee(\n            _paybackETH,\n            _baseRewardLiquidation,\n            _maxFeeETH\n        );\n\n        uint256 numerator = (feeETH + _paybackETH)\n            * PRECISION_FACTOR_E18;\n\n        uint256 denominator = getFullCollateralETH(\n            _nftId,\n            _receiveToken\n        );\n\n        return numerator / denominator + 1;\n    }\n\n    /**\n     * @dev Check function for withdraw flow.\n     * Tests if debt ratio is not greater than\n     * 100% after withdraw of {_poolToken} for\n     * {_amount}.\n     */\n    function _checkHealthState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n    {\n        if (_getState(_nftId, _powerFarm) == true) {\n            revert ResultsInBadDebt();\n        }\n    }\n\n    function _getState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n        returns (bool)\n    {\n        uint256 borrowAmount = overallETHBorrow(\n            _nftId\n        );\n\n        if (borrowAmount == 0) {\n            return false;\n        }\n\n        uint256 overallCollateral = _powerFarm == true\n            ? overallETHCollateralsBare(_nftId)\n            : overallETHCollateralsWeighted(_nftId);\n\n        return overallCollateral\n            * BORROW_PERCENTAGE_CAP\n            / PRECISION_FACTOR_E18\n            < borrowAmount;\n    }\n\n    /**\n     * @dev Check function for registration\n     * of power farms. User can only register\n     * when the postion is empty!\n     */\n    function checksRegister(\n        uint256 _nftId,\n        address _caller\n    )\n        public\n        view\n    {\n        checkOwnerPosition(\n            _nftId,\n            _caller\n        );\n\n        if (overallETHCollateralsWeighted(_nftId) > 0) {\n            revert NotAllowedWiseSecurity();\n        }\n    }\n\n    /**\n     * @dev Pure math function comparing\n     * borrow and collateral amount for\n     * liquidation.\n     */\n    function canLiquidate(\n        uint256 _borrowETHTotal,\n        uint256 _weightedCollateralETH\n    )\n        public\n        pure\n    {\n        if (_borrowETHTotal < _weightedCollateralETH) {\n            revert LiquidationDenied();\n        }\n    }\n\n    /**\n     * @dev Helper function for liquidation checking\n     * return amount of receiving shares for liquidator.\n     * Has to be smaller 50% when no bad debt occurs.\n     */\n    function checkMaxShares(\n        uint256 _nftId,\n        address _tokenToPayback,\n        uint256 _borrowETHTotal,\n        uint256 _unweightedCollateralETH,\n        uint256 _shareAmountToPay\n    )\n        public\n        view\n    {\n        uint256 totalSharesUser = WISE_LENDING.getPositionBorrowShares(\n            _nftId,\n            _tokenToPayback\n        );\n\n        uint256 maxShares = checkBadDebtThreshold(_borrowETHTotal, _unweightedCollateralETH)\n            ? totalSharesUser\n            : totalSharesUser * MAX_LIQUIDATION_50 / PRECISION_FACTOR_E18;\n\n        if (_shareAmountToPay <= maxShares) {\n            return;\n        }\n\n        revert TooManyShares();\n    }\n\n    /**\n     * @dev Helper function for liquidation checking\n     * if postion has bad debt.\n     */\n    function checkBadDebtThreshold(\n        uint256 _borrowETHTotal,\n        uint256 _unweightedCollateral\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _borrowETHTotal * PRECISION_FACTOR_E18\n            >= _unweightedCollateral * BAD_DEBT_THRESHOLD;\n    }\n\n    /**\n     * @dev Helper function computing lending\n     * token amount for {_poolToken}.\n     */\n    function getPositionLendingAmount(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.cashoutAmount(\n            {\n                _poolToken: _poolToken,\n                _shares: WISE_LENDING.getPositionLendingShares(\n                    _nftId,\n                    _poolToken\n                )\n            }\n        );\n    }\n\n    /**\n     * @dev Helper function computing borrow\n     * token amount for {_poolToken}.\n     */\n    function getPositionBorrowAmount(\n        uint256 _nftId,\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.paybackAmount(\n            _poolToken,\n            WISE_LENDING.getPositionBorrowShares(\n                _nftId,\n                _poolToken\n            )\n        );\n    }\n\n    /**\n     * @dev Helper function checking the owner\n     * of {_nftId}. Reverts if owner is invalid.\n     */\n    function checkOwnerPosition(\n        uint256 _nftId,\n        address _caller\n    )\n        public\n        view\n    {\n        if (POSITION_NFTS.isOwner(\n            _nftId,\n            _caller\n        ) == false) {\n            revert NotOwner();\n        }\n    }\n\n    /**\n     * @dev Wrapper function returning the borrow\n     * rate from pool with token {_poolToken}.\n     */\n    function getBorrowRate(\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return WISE_LENDING.borrowPoolData(_poolToken).borrowRate;\n    }\n\n    /**\n     * @dev View function returning the lending\n     * rate from pool with token {_poolToken}.\n     */\n    function getLendingRate(\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 pseudoTotalPool = WISE_LENDING.getPseudoTotalPool(\n            _poolToken\n        );\n\n        if (pseudoTotalPool == 0) {\n            return 0;\n        }\n\n        uint256 adjustedRate = getBorrowRate(_poolToken)\n            * (PRECISION_FACTOR_E18 - WISE_LENDING.globalPoolData(_poolToken).poolFee)\n            / PRECISION_FACTOR_E18;\n\n        return adjustedRate\n            * WISE_LENDING.getPseudoTotalBorrowAmount(_poolToken)\n            / pseudoTotalPool;\n    }\n\n    /**\n     * @dev Internal helper function calculating\n     * the possible withdraw amount of {_poolToken}\n     * under current borrow and collateral amount\n     * of {_nftId}.\n     */\n    function _getPossibleWithdrawAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _interval\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 term = _overallETHBorrow(_nftId, _interval)\n            * PRECISION_FACTOR_E18\n            / BORROW_PERCENTAGE_CAP;\n\n        uint256 withdrawETH = PRECISION_FACTOR_E18\n            * (_overallETHCollateralsWeighted(_nftId, _interval) - term)\n            / WISE_LENDING.lendingPoolData(_poolToken).collateralFactor;\n\n        return WISE_ORACLE.getTokensFromETH(\n            _poolToken,\n            withdrawETH\n        );\n    }\n\n    /**\n     * Locking or unlocking all pools for borrow\n     * and deposit actions. Performs action for\n     * all pools.\n     */\n    function _setPoolState(\n        bool _state\n    )\n        internal\n    {\n        uint256 i;\n        uint256 len = FEE_MANAGER.getPoolTokenAddressesLength();\n\n        while(i < len) {\n\n            wasBlacklisted[\n                FEE_MANAGER.getPoolTokenAdressesByIndex(i)\n            ] = _state;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Wrapper for {_checkBlacklisted}.\n     */\n    function _checkPoolCondition(\n        address _poolToken\n    )\n        internal\n        view\n    {\n        if (_checkBlacklisted(_poolToken) == true) {\n            revert TokenBlackListed();\n        }\n    }\n\n    /**\n     * @dev Internal helper checking of success\n     * for a low level byte call of a function\n     * with {.call()}.\n     */\n    function _checkSuccess(\n        bool _success\n    )\n        internal\n        pure\n    {\n        if (_success == false) {\n            revert SecuritySwapFailed();\n        }\n    }\n}"
    }
  ]
}