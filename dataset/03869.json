{
  "Title": "Restrict deflationary tokens",
  "Content": "##### Description\nAt line https://github.com/tosdis/TosDisFinance/blob/be50dbf8a52a8f919694498bf30394d328d88fbb/StakeMaster/contracts/StakingPool.sol#L124 contract receives token by `safeTransferFrom`, and increases `user.amount` by `_amountToStake`, however that approach doesn't work with deflationary tokens because in that case real received amount will be less than requested. That will break the whole logic of contract if somebody creates pool with deflationary token.\n\n##### Recommendation\nWe recommend to support such tokens or restrict contract usage with them\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "StakeMaster/contracts/StakingPool.sol",
      "content": "pragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract StakingPool is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public stakingToken;\n    IERC20 public rewardToken;\n    uint256 public startBlock;\n    uint256 public lastRewardBlock;\n    uint256 public finishBlock;\n    uint256 public allStakedAmount;\n    uint256 public allPaidReward;\n    uint256 public allRewardDebt;\n    uint256 public poolTokenAmount;\n    uint256 public rewardPerBlock;\n    uint256 public accTokensPerShare; // Accumulated tokens per share\n    uint256 public participants; //Count of participants\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount;     // How many tokens the user has staked.\n        uint256 rewardDebt; // Reward debt\n    }\n\n    mapping (address => UserInfo) public userInfo;\n\n    event FinishBlockUpdated(uint256 newFinishBlock);\n    event PoolReplenished(uint256 amount);\n    event TokensStaked(address indexed user, uint256 amount, uint256 reward);\n    event StakeWithdrawn(address indexed user, uint256 amount, uint256 reward);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n\n    event WithdrawPoolRemainder(address indexed user, uint256 amount);\n\n    constructor(\n        IERC20 _stakingToken,\n        IERC20 _poolToken,\n        uint256 _startBlock,\n        uint256 _finishBlock,\n        uint256 _poolTokenAmount\n    ) public {\n        stakingToken = _stakingToken;\n        rewardToken = _poolToken;\n        require(\n            _startBlock < _finishBlock,\n            \"start block must be less than finish block\"\n        );\n        require(\n            _finishBlock > block.number,\n            \"finish block must be more than current block\"\n        );\n        startBlock = _startBlock;\n        lastRewardBlock = startBlock;\n        finishBlock = _finishBlock;\n        poolTokenAmount = _poolTokenAmount;\n        rewardPerBlock = _poolTokenAmount.div(_finishBlock.sub(_startBlock));\n    }\n\n    function getMultiplier(uint256 _from, uint256 _to)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_to <= finishBlock) {\n            return _to.sub(_from);\n        } else if (_from >= finishBlock) {\n            return 0;\n        } else {\n            return finishBlock.sub(_from);\n        }\n    }\n\n    // View function to see pending Reward on frontend.\n    function pendingReward(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        uint256 tempAccTokensPerShare = accTokensPerShare;\n        if (block.number > lastRewardBlock && allStakedAmount != 0) {\n            uint256 multiplier = getMultiplier(lastRewardBlock, block.number);\n            uint256 reward = multiplier.mul(rewardPerBlock);\n            tempAccTokensPerShare = accTokensPerShare.add(\n                reward.mul(1e18).div(allStakedAmount)\n            );\n        }\n        return user.amount.mul(tempAccTokensPerShare).div(1e18).sub(user.rewardDebt);\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool() public {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        if (allStakedAmount == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n\n        uint256 multiplier = getMultiplier(lastRewardBlock, block.number);\n        uint256 reward = multiplier.mul(rewardPerBlock);\n        accTokensPerShare = accTokensPerShare.add(\n            reward.mul(1e18).div(allStakedAmount)\n        );\n        lastRewardBlock = block.number;\n    }\n\n    function stakeTokens(uint256 _amountToStake) external nonReentrant{\n        updatePool();\n        uint256 pending = 0;\n        UserInfo storage user = userInfo[msg.sender];\n        if (user.amount > 0) {\n            pending = transferPendingReward(user);\n        }\n        else{\n            participants +=1;\n        }\n\n        if (_amountToStake > 0) {\n            stakingToken.safeTransferFrom(msg.sender, address(this), _amountToStake);\n            user.amount = user.amount.add(_amountToStake);\n            allStakedAmount = allStakedAmount.add(_amountToStake);\n        }\n\n        allRewardDebt = allRewardDebt.sub(user.rewardDebt);\n        user.rewardDebt = user.amount.mul(accTokensPerShare).div(1e18);\n        allRewardDebt = allRewardDebt.add(user.rewardDebt);\n        emit TokensStaked(msg.sender, _amountToStake, pending);\n    }\n\n    // Leave the pool. Claim back your tokens.\n    // Unclocks the staked + gained tokens and burns pool shares\n    function withdrawStake(uint256 _amount) external nonReentrant {\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool();\n        uint256 pending = transferPendingReward(user);\n\n        if (_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            stakingToken.safeTransfer(msg.sender, _amount);\n            if(user.amount == 0){\n                participants -= 1;\n            }\n        }\n        allRewardDebt = allRewardDebt.sub(user.rewardDebt);\n        user.rewardDebt = user.amount.mul(accTokensPerShare).div(1e18);\n        allRewardDebt = allRewardDebt.add(user.rewardDebt);\n        allStakedAmount = allStakedAmount.sub(_amount);\n\n        emit StakeWithdrawn(msg.sender, _amount, pending);\n    }\n\n    function transferPendingReward(UserInfo memory user) private returns (uint256) {\n        uint256 pending = user.amount.mul(accTokensPerShare).div(1e18).sub(user.rewardDebt);\n\n        if (pending > 0) {\n            rewardToken.safeTransfer(msg.sender, pending);\n            allPaidReward = allPaidReward.add(pending);\n        }\n\n        return pending;\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external nonReentrant{\n        UserInfo storage user = userInfo[msg.sender];\n        if(user.amount > 0) {\n            stakingToken.safeTransfer(msg.sender, user.amount);\n            emit EmergencyWithdraw(msg.sender, user.amount);\n\n            allStakedAmount = allStakedAmount.sub(user.amount);\n            allRewardDebt = allRewardDebt.sub(user.rewardDebt);\n            user.amount = 0;\n            user.rewardDebt = 0;\n            participants -= 1;\n        }\n    }\n\n\n    function withdrawPoolRemainder() external onlyOwner nonReentrant{\n        require(block.number > finishBlock, \"Allow after finish\");\n        updatePool();\n        uint256 pending = allStakedAmount.mul(accTokensPerShare).div(1e18).sub(allRewardDebt);\n        uint256 returnAmount = poolTokenAmount.sub(allPaidReward).sub(pending);\n        allPaidReward = allPaidReward.add(returnAmount);\n\n        rewardToken.safeTransfer(msg.sender, returnAmount);\n        emit WithdrawPoolRemainder(msg.sender, returnAmount);\n    }\n}"
    }
  ]
}