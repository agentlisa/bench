{
  "Title": "[03] Setters should always have equality checkers",
  "Content": "\nTake a look [here](https://github.com/code-423n4/2024-03-acala/blob/9c71c05cf2d9f0a2603984c50f76fc8a315d4d65/src/orml/rewards/src/lib.rs#L252-L262).\n\n```rust\n\n\tpub fn set_share(who: &T::AccountId, pool: &T::PoolId, new_share: T::Share) {\n\t\tlet (share, _) = Self::shares_and_withdrawn_rewards(pool, who);\n\n\t\tif new_share > share {\n\t\t\tSelf::add_share(who, pool, new_share.saturating_sub(share));\n\t\t} else {\n\t\t\tSelf::remove_share(who, pool, share.saturating_sub(new_share));\n\t\t}\n\t}\n```\n\nThis function sets a new share value for a pool, now there are no checks that ` new_share != share` and as such whenever ` new_share == share` the protocol unnecessarily (wrongly attempts to remove via `share.saturating_sub(new_share`).\n\nAnother instance can be seen here, where protocol in all instances of updating the amounts don't check if the provided amount is not already the stored amount and as such unnecessarily updates `v`, see [here](https://github.com/code-423n4/2024-03-acala/blob/9c71c05cf2d9f0a2603984c50f76fc8a315d4d65/src/modules/incentives/src/lib.rs#L280-L312).\n\n```rust\n\t\tpub fn update_incentive_rewards(\n\t\t\torigin: OriginFor<T>,\n\t\t\tupdates: Vec<(PoolId, Vec<(CurrencyId, Balance)>)>,\n\t\t) -> DispatchResult {\n\t\t\tT::UpdateOrigin::ensure_origin(origin)?;\n\t\t\tfor (pool_id, update_list) in updates {\n\t\t\t\tif let PoolId::Dex(currency_id) = pool_id {\n\t\t\t\t\tensure!(currency_id.is_dex_share_currency_id(), Error::<T>::InvalidPoolId);\n\t\t\t\t}\n\n\t\t\t\tfor (currency_id, amount) in update_list {\n\t\t\t\t\tIncentiveRewardAmounts::<T>::mutate_exists(pool_id, currency_id, |maybe_amount| {\n\t\t\t\t\t\tlet mut v = maybe_amount.unwrap_or_default();\n\t\t\t\t\t\tif amount != v {\n\t\t\t\t\t\t\tv = amount;\n\t\t\t\t\t\t\tSelf::deposit_event(Event::IncentiveRewardAmountUpdated {\n\t\t\t\t\t\t\t\tpool: pool_id,\n\t\t\t\t\t\t\t\treward_currency_id: currency_id,\n\t\t\t\t\t\t\t\treward_amount_per_period: amount,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif v.is_zero() {\n\t\t\t\t\t\t\t*maybe_amount = None;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*maybe_amount = Some(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(())\n\t\t}\n```\n\nThe same idea can also be applied to [this](https://github.com/code-423n4/2024-03-acala/blob/9c71c05cf2d9f0a2603984c50f76fc8a315d4d65/src/modules/incentives/src/lib.rs#L320) `update_claim_reward_deduction_rates()` function.\n\n### Impact\n\nUnnecessary code execution, flawed implementation.\n\n### Recommended Mitigation Steps\n\nAs a rule of thumb, all setters should always have equality checkers as passing an equal to the already stored value hints a mistake and maybe this attempt to add/remove was meant for a different pool.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-acala",
  "Code": [
    {
      "filename": "src/orml/rewards/src/lib.rs",
      "content": "#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::unused_unit)]\n#![allow(clippy::too_many_arguments)]\n\nmod mock;\nmod tests;\n\nuse frame_support::pallet_prelude::*;\nuse orml_traits::RewardHandler;\nuse parity_scale_codec::{FullCodec, HasCompact};\nuse scale_info::TypeInfo;\nuse sp_core::U256;\nuse sp_runtime::{\n\ttraits::{AtLeast32BitUnsigned, MaybeSerializeDeserialize, Member, Saturating, UniqueSaturatedInto, Zero},\n\tFixedPointOperand, RuntimeDebug, SaturatedConversion,\n};\nuse sp_std::{borrow::ToOwned, collections::btree_map::BTreeMap, fmt::Debug, prelude::*};\n\n/// The Reward Pool Info.\n#[derive(Clone, Encode, Decode, PartialEq, Eq, RuntimeDebug, TypeInfo)]\npub struct PoolInfo<Share: HasCompact, Balance: HasCompact, CurrencyId: Ord> {\n\t/// Total shares amount\n\tpub total_shares: Share,\n\t/// Reward infos <reward_currency, (total_reward, total_withdrawn_reward)>\n\tpub rewards: BTreeMap<CurrencyId, (Balance, Balance)>,\n}\n\nimpl<Share, Balance, CurrencyId> Default for PoolInfo<Share, Balance, CurrencyId>\nwhere\n\tShare: Default + HasCompact,\n\tBalance: HasCompact,\n\tCurrencyId: Ord,\n{\n\tfn default() -> Self {\n\t\tSelf {\n\t\t\ttotal_shares: Default::default(),\n\t\t\trewards: BTreeMap::new(),\n\t\t}\n\t}\n}\n\npub use module::*;\n\n#[frame_support::pallet]\npub mod module {\n\n\tuse super::*;\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The share type of pool.\n\t\ttype Share: Parameter\n\t\t\t+ Member\n\t\t\t+ AtLeast32BitUnsigned\n\t\t\t+ Default\n\t\t\t+ Copy\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ Debug\n\t\t\t+ FixedPointOperand;\n\n\t\t/// The reward balance type.\n\t\ttype Balance: Parameter\n\t\t\t+ Member\n\t\t\t+ AtLeast32BitUnsigned\n\t\t\t+ Default\n\t\t\t+ Copy\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ Debug\n\t\t\t+ FixedPointOperand;\n\n\t\t/// The reward pool ID type.\n\t\ttype PoolId: Parameter + Member + Clone + FullCodec;\n\n\t\ttype CurrencyId: Parameter + Member + Copy + MaybeSerializeDeserialize + Ord;\n\n\t\t/// The `RewardHandler`\n\t\ttype Handler: RewardHandler<Self::AccountId, Self::CurrencyId, Balance = Self::Balance, PoolId = Self::PoolId>;\n\t}\n\n\ttype WithdrawnRewards<T> = BTreeMap<<T as Config>::CurrencyId, <T as Config>::Balance>;\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Pool does not exist\n\t\tPoolDoesNotExist,\n\t\tShareDoesNotExist,\n\t\tCanSplitOnlyLessThanShare,\n\t}\n\n\t/// Record reward pool info.\n\t///\n\t/// map PoolId => PoolInfo\n\t#[pallet::storage]\n\t#[pallet::getter(fn pool_infos)]\n\tpub type PoolInfos<T: Config> =\n\t\tStorageMap<_, Twox64Concat, T::PoolId, PoolInfo<T::Share, T::Balance, T::CurrencyId>, ValueQuery>;\n\n\t/// Record share amount, reward currency and withdrawn reward amount for\n\t/// specific `AccountId` under `PoolId`.\n\t///\n\t/// double_map (PoolId, AccountId) => (Share, BTreeMap<CurrencyId, Balance>)\n\t#[pallet::storage]\n\t#[pallet::getter(fn shares_and_withdrawn_rewards)]\n\tpub type SharesAndWithdrawnRewards<T: Config> = StorageDoubleMap<\n\t\t_,\n\t\tTwox64Concat,\n\t\tT::PoolId,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\t(T::Share, WithdrawnRewards<T>),\n\t\tValueQuery,\n\t>;\n\n\t#[pallet::pallet]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(_);\n}\n\nimpl<T: Config> Pallet<T> {\n\tpub fn accumulate_reward(\n\t\tpool: &T::PoolId,\n\t\treward_currency: T::CurrencyId,\n\t\treward_increment: T::Balance,\n\t) -> DispatchResult {\n\t\tif reward_increment.is_zero() {\n\t\t\treturn Ok(());\n\t\t}\n\t\tPoolInfos::<T>::mutate_exists(pool, |maybe_pool_info| -> DispatchResult {\n\t\t\tlet pool_info = maybe_pool_info.as_mut().ok_or(Error::<T>::PoolDoesNotExist)?;\n\n\t\t\tpool_info\n\t\t\t\t.rewards\n\t\t\t\t.entry(reward_currency)\n\t\t\t\t.and_modify(|(total_reward, _)| {\n\t\t\t\t\t*total_reward = total_reward.saturating_add(reward_increment);\n\t\t\t\t})\n\t\t\t\t.or_insert((reward_increment, Zero::zero()));\n\n\t\t\tOk(())\n\t\t})\n\t}\n\n\tpub fn add_share(who: &T::AccountId, pool: &T::PoolId, add_amount: T::Share) {\n\t\tif add_amount.is_zero() {\n\t\t\treturn;\n\t\t}\n\n\t\tPoolInfos::<T>::mutate(pool, |pool_info| {\n\t\t\tlet initial_total_shares = pool_info.total_shares;\n\t\t\tpool_info.total_shares = pool_info.total_shares.saturating_add(add_amount);\n\n\t\t\tlet mut withdrawn_inflation = Vec::<(T::CurrencyId, T::Balance)>::new();\n\n\t\t\tpool_info\n\t\t\t\t.rewards\n\t\t\t\t.iter_mut()\n\t\t\t\t.for_each(|(reward_currency, (total_reward, total_withdrawn_reward))| {\n\t\t\t\t\tlet reward_inflation = if initial_total_shares.is_zero() {\n\t\t\t\t\t\tZero::zero()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tU256::from(add_amount.to_owned().saturated_into::<u128>())\n\t\t\t\t\t\t\t.saturating_mul(total_reward.to_owned().saturated_into::<u128>().into())\n\t\t\t\t\t\t\t.checked_div(initial_total_shares.to_owned().saturated_into::<u128>().into())\n\t\t\t\t\t\t\t.unwrap_or_default()\n\t\t\t\t\t\t\t.as_u128()\n\t\t\t\t\t\t\t.saturated_into()\n\t\t\t\t\t};\n\t\t\t\t\t*total_reward = total_reward.saturating_add(reward_inflation);\n\t\t\t\t\t*total_withdrawn_reward = total_withdrawn_reward.saturating_add(reward_inflation);\n\n\t\t\t\t\twithdrawn_inflation.push((*reward_currency, reward_inflation));\n\t\t\t\t});\n\n\t\t\tSharesAndWithdrawnRewards::<T>::mutate(pool, who, |(share, withdrawn_rewards)| {\n\t\t\t\t*share = share.saturating_add(add_amount);\n\t\t\t\t// update withdrawn inflation for each reward currency\n\t\t\t\twithdrawn_inflation\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.for_each(|(reward_currency, reward_inflation)| {\n\t\t\t\t\t\twithdrawn_rewards\n\t\t\t\t\t\t\t.entry(reward_currency)\n\t\t\t\t\t\t\t.and_modify(|withdrawn_reward| {\n\t\t\t\t\t\t\t\t*withdrawn_reward = withdrawn_reward.saturating_add(reward_inflation);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.or_insert(reward_inflation);\n\t\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tpub fn remove_share(who: &T::AccountId, pool: &T::PoolId, remove_amount: T::Share) {\n\t\tif remove_amount.is_zero() {\n\t\t\treturn;\n\t\t}\n\n\t\t// claim rewards firstly\n\t\tSelf::claim_rewards(who, pool);\n\n\t\tSharesAndWithdrawnRewards::<T>::mutate_exists(pool, who, |share_info| {\n\t\t\tif let Some((mut share, mut withdrawn_rewards)) = share_info.take() {\n\t\t\t\tlet remove_amount = remove_amount.min(share);\n\n\t\t\t\tif remove_amount.is_zero() {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPoolInfos::<T>::mutate_exists(pool, |maybe_pool_info| {\n\t\t\t\t\tif let Some(mut pool_info) = maybe_pool_info.take() {\n\t\t\t\t\t\tlet removing_share = U256::from(remove_amount.saturated_into::<u128>());\n\n\t\t\t\t\t\tpool_info.total_shares = pool_info.total_shares.saturating_sub(remove_amount);\n\n\t\t\t\t\t\t// update withdrawn rewards for each reward currency\n\t\t\t\t\t\twithdrawn_rewards\n\t\t\t\t\t\t\t.iter_mut()\n\t\t\t\t\t\t\t.for_each(|(reward_currency, withdrawn_reward)| {\n\t\t\t\t\t\t\t\tlet withdrawn_reward_to_remove: T::Balance = removing_share\n\t\t\t\t\t\t\t\t\t.saturating_mul(withdrawn_reward.to_owned().saturated_into::<u128>().into())\n\t\t\t\t\t\t\t\t\t.checked_div(share.saturated_into::<u128>().into())\n\t\t\t\t\t\t\t\t\t.unwrap_or_default()\n\t\t\t\t\t\t\t\t\t.as_u128()\n\t\t\t\t\t\t\t\t\t.saturated_into();\n\n\t\t\t\t\t\t\t\tif let Some((total_reward, total_withdrawn_reward)) =\n\t\t\t\t\t\t\t\t\tpool_info.rewards.get_mut(reward_currency)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t*total_reward = total_reward.saturating_sub(withdrawn_reward_to_remove);\n\t\t\t\t\t\t\t\t\t*total_withdrawn_reward =\n\t\t\t\t\t\t\t\t\t\ttotal_withdrawn_reward.saturating_sub(withdrawn_reward_to_remove);\n\n\t\t\t\t\t\t\t\t\t// remove if all reward is withdrawn\n\t\t\t\t\t\t\t\t\tif total_reward.is_zero() {\n\t\t\t\t\t\t\t\t\t\tpool_info.rewards.remove(reward_currency);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t*withdrawn_reward = withdrawn_reward.saturating_sub(withdrawn_reward_to_remove);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif !pool_info.total_shares.is_zero() {\n\t\t\t\t\t\t\t*maybe_pool_info = Some(pool_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tshare = share.saturating_sub(remove_amount);\n\t\t\t\tif !share.is_zero() {\n\t\t\t\t\t*share_info = Some((share, withdrawn_rewards));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpub fn set_share(who: &T::AccountId, pool: &T::PoolId, new_share: T::Share) {\n\t\tlet (share, _) = Self::shares_and_withdrawn_rewards(pool, who);\n\n\t\tif new_share > share {\n\t\t\tSelf::add_share(who, pool, new_share.saturating_sub(share));\n\t\t} else {\n\t\t\tSelf::remove_share(who, pool, share.saturating_sub(new_share));\n\t\t}\n\t}\n\n\tpub fn claim_rewards(who: &T::AccountId, pool: &T::PoolId) {\n\t\tSharesAndWithdrawnRewards::<T>::mutate_exists(pool, who, |maybe_share_withdrawn| {\n\t\t\tif let Some((share, withdrawn_rewards)) = maybe_share_withdrawn {\n\t\t\t\tif share.is_zero() {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPoolInfos::<T>::mutate_exists(pool, |maybe_pool_info| {\n\t\t\t\t\tif let Some(pool_info) = maybe_pool_info {\n\t\t\t\t\t\tlet total_shares = U256::from(pool_info.total_shares.to_owned().saturated_into::<u128>());\n\t\t\t\t\t\tpool_info.rewards.iter_mut().for_each(\n\t\t\t\t\t\t\t|(reward_currency, (total_reward, total_withdrawn_reward))| {\n\t\t\t\t\t\t\t\tSelf::claim_one(\n\t\t\t\t\t\t\t\t\twithdrawn_rewards,\n\t\t\t\t\t\t\t\t\t*reward_currency,\n\t\t\t\t\t\t\t\t\tshare.to_owned(),\n\t\t\t\t\t\t\t\t\ttotal_reward.to_owned(),\n\t\t\t\t\t\t\t\t\ttotal_shares,\n\t\t\t\t\t\t\t\t\ttotal_withdrawn_reward,\n\t\t\t\t\t\t\t\t\twho,\n\t\t\t\t\t\t\t\t\tpool,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tpub fn claim_reward(who: &T::AccountId, pool: &T::PoolId, reward_currency: T::CurrencyId) {\n\t\tSharesAndWithdrawnRewards::<T>::mutate_exists(pool, who, |maybe_share_withdrawn| {\n\t\t\tif let Some((share, withdrawn_rewards)) = maybe_share_withdrawn {\n\t\t\t\tif share.is_zero() {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tPoolInfos::<T>::mutate(pool, |pool_info| {\n\t\t\t\t\tlet total_shares = U256::from(pool_info.total_shares.to_owned().saturated_into::<u128>());\n\t\t\t\t\tif let Some((total_reward, total_withdrawn_reward)) = pool_info.rewards.get_mut(&reward_currency) {\n\t\t\t\t\t\tSelf::claim_one(\n\t\t\t\t\t\t\twithdrawn_rewards,\n\t\t\t\t\t\t\treward_currency,\n\t\t\t\t\t\t\tshare.to_owned(),\n\t\t\t\t\t\t\ttotal_reward.to_owned(),\n\t\t\t\t\t\t\ttotal_shares,\n\t\t\t\t\t\t\ttotal_withdrawn_reward,\n\t\t\t\t\t\t\twho,\n\t\t\t\t\t\t\tpool,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/// Splits share into two parts.\n\t///\n\t/// `move_share` - amount of share to remove and put into `other` share\n\t/// `other` - new account who will own new share\n\t///\n\t/// Similar too claim and add 2 shares later, but does not requires pool\n\t/// inflation and is more efficient.\n\tpub fn transfer_share_and_rewards(\n\t\twho: &T::AccountId,\n\t\tpool: &T::PoolId,\n\t\tmove_share: T::Share,\n\t\tother: &T::AccountId,\n\t) -> DispatchResult {\n\t\tSharesAndWithdrawnRewards::<T>::mutate(pool, other, |increased_share| {\n\t\t\tlet (increased_share, increased_rewards) = increased_share;\n\t\t\tSharesAndWithdrawnRewards::<T>::mutate_exists(pool, who, |share| {\n\t\t\t\tlet (share, rewards) = share.as_mut().ok_or(Error::<T>::ShareDoesNotExist)?;\n\t\t\t\tensure!(move_share < *share, Error::<T>::CanSplitOnlyLessThanShare);\n\t\t\t\tfor (reward_currency, balance) in rewards {\n\t\t\t\t\t// u128 * u128 is always less than u256\n\t\t\t\t\t// move_share / share always less then 1 and share > 0\n\t\t\t\t\t// so final results is computable and is always less or equal than u128\n\t\t\t\t\tlet move_balance = U256::from(balance.to_owned().saturated_into::<u128>())\n\t\t\t\t\t\t* U256::from(move_share.to_owned().saturated_into::<u128>())\n\t\t\t\t\t\t/ U256::from(share.to_owned().saturated_into::<u128>());\n\t\t\t\t\tlet move_balance: Option<u128> = move_balance.try_into().ok();\n\t\t\t\t\tif let Some(move_balance) = move_balance {\n\t\t\t\t\t\tlet move_balance: T::Balance = move_balance.unique_saturated_into();\n\t\t\t\t\t\t*balance = balance.saturating_sub(move_balance);\n\t\t\t\t\t\tincreased_rewards\n\t\t\t\t\t\t\t.entry(*reward_currency)\n\t\t\t\t\t\t\t.and_modify(|increased_reward| {\n\t\t\t\t\t\t\t\t*increased_reward = increased_reward.saturating_add(move_balance);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.or_insert(move_balance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*share = share.saturating_sub(move_share);\n\t\t\t\t*increased_share = increased_share.saturating_add(move_share);\n\t\t\t\tOk(())\n\t\t\t})\n\t\t})\n\t}\n\n\t#[allow(clippy::too_many_arguments)] // just we need to have all these to do the stuff\n\tfn claim_one(\n\t\twithdrawn_rewards: &mut BTreeMap<T::CurrencyId, T::Balance>,\n\t\treward_currency: T::CurrencyId,\n\t\tshare: T::Share,\n\t\ttotal_reward: T::Balance,\n\t\ttotal_shares: U256,\n\t\ttotal_withdrawn_reward: &mut T::Balance,\n\t\twho: &T::AccountId,\n\t\tpool: &T::PoolId,\n\t) {\n\t\tlet withdrawn_reward = withdrawn_rewards.get(&reward_currency).copied().unwrap_or_default();\n\t\tlet reward_to_withdraw = Self::reward_to_withdraw(\n\t\t\tshare,\n\t\t\ttotal_reward,\n\t\t\ttotal_shares,\n\t\t\twithdrawn_reward,\n\t\t\ttotal_withdrawn_reward.to_owned(),\n\t\t);\n\t\tif !reward_to_withdraw.is_zero() {\n\t\t\t*total_withdrawn_reward = total_withdrawn_reward.saturating_add(reward_to_withdraw);\n\t\t\twithdrawn_rewards.insert(reward_currency, withdrawn_reward.saturating_add(reward_to_withdraw));\n\n\t\t\t// pay reward to `who`\n\t\t\tT::Handler::payout(who, pool, reward_currency, reward_to_withdraw);\n\t\t}\n\t}\n\n\tfn reward_to_withdraw(\n\t\tshare: T::Share,\n\t\ttotal_reward: T::Balance,\n\t\ttotal_shares: U256,\n\t\twithdrawn_reward: T::Balance,\n\t\ttotal_withdrawn_reward: T::Balance,\n\t) -> T::Balance {\n\t\tlet total_reward_proportion: T::Balance = U256::from(share.saturated_into::<u128>())\n\t\t\t.saturating_mul(U256::from(total_reward.saturated_into::<u128>()))\n\t\t\t.checked_div(total_shares)\n\t\t\t.unwrap_or_default()\n\t\t\t.as_u128()\n\t\t\t.unique_saturated_into();\n\t\ttotal_reward_proportion\n\t\t\t.saturating_sub(withdrawn_reward)\n\t\t\t.min(total_reward.saturating_sub(total_withdrawn_reward))\n\t}\n}"
    },
    {
      "filename": "src/modules/incentives/src/lib.rs",
      "content": "// This file is part of Acala.\n\n// Copyright (C) 2020-2024 Acala Foundation.\n// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n//! # Incentives Module\n//!\n//! ## Overview\n//!\n//! Acala platform need support different types of rewards for some other protocol.\n//! Each Pool has its own multi currencies rewards and reward accumulation\n//! mechanism. ORML rewards module records the total shares, total multi currencies rewards anduser\n//! shares of specific pool. Incentives module provides hooks to other protocals to manage shares,\n//! accumulates rewards and distributes rewards to users based on their shares.\n//!\n//! Pool types:\n//! 1. Loans: record the shares and rewards for users of Loans(Honzon protocol).\n//! 2. Dex: record the shares and rewards for DEX makers who staking LP token.\n//!\n//! Rewards accumulation:\n//! 1. Incentives: periodicly(AccumulatePeriod), accumulate fixed amount according to Incentive.\n//! Rewards come from RewardsSource, please transfer enough tokens to RewardsSource before\n//! start incentive plan.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::unused_unit)]\n#![allow(clippy::upper_case_acronyms)]\n\nuse frame_support::{pallet_prelude::*, transactional, PalletId};\nuse frame_system::pallet_prelude::*;\nuse module_support::{DEXIncentives, EmergencyShutdown, FractionalRate, IncentivesManager, PoolId, Rate};\nuse orml_traits::{Happened, MultiCurrency, RewardHandler};\nuse primitives::{Amount, Balance, CurrencyId};\nuse sp_runtime::{\n\ttraits::{AccountIdConversion, UniqueSaturatedInto, Zero},\n\tDispatchResult, FixedPointNumber,\n};\nuse sp_std::{collections::btree_map::BTreeMap, prelude::*};\n\nmod mock;\nmod tests;\npub mod weights;\n\npub use module::*;\npub use weights::WeightInfo;\n\n#[frame_support::pallet]\npub mod module {\n\tuse super::*;\n\n\t#[pallet::config]\n\tpub trait Config:\n\t\tframe_system::Config\n\t\t+ orml_rewards::Config<Share = Balance, Balance = Balance, PoolId = PoolId, CurrencyId = CurrencyId>\n\t{\n\t\ttype RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n\t\t/// The period to accumulate rewards\n\t\t#[pallet::constant]\n\t\ttype AccumulatePeriod: Get<BlockNumberFor<Self>>;\n\n\t\t/// The native currency for earning staking\n\t\t#[pallet::constant]\n\t\ttype NativeCurrencyId: Get<CurrencyId>;\n\n\t\t/// The source account for native token rewards.\n\t\t#[pallet::constant]\n\t\ttype RewardsSource: Get<Self::AccountId>;\n\n\t\t/// The origin which may update incentive related params\n\t\ttype UpdateOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Currency for transfer assets\n\t\ttype Currency: MultiCurrency<Self::AccountId, CurrencyId = CurrencyId, Balance = Balance>;\n\n\t\t/// Emergency shutdown.\n\t\ttype EmergencyShutdown: EmergencyShutdown;\n\n\t\t/// The module id, keep DexShare LP.\n\t\t#[pallet::constant]\n\t\ttype PalletId: Get<PalletId>;\n\n\t\t/// Weight information for the extrinsics in this module.\n\t\ttype WeightInfo: WeightInfo;\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Share amount is not enough\n\t\tNotEnough,\n\t\t/// Invalid currency id\n\t\tInvalidCurrencyId,\n\t\t/// Invalid pool id\n\t\tInvalidPoolId,\n\t\t/// Invalid rate\n\t\tInvalidRate,\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(crate) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// Deposit DEX share.\n\t\tDepositDexShare {\n\t\t\twho: T::AccountId,\n\t\t\tdex_share_type: CurrencyId,\n\t\t\tdeposit: Balance,\n\t\t},\n\t\t/// Withdraw DEX share.\n\t\tWithdrawDexShare {\n\t\t\twho: T::AccountId,\n\t\t\tdex_share_type: CurrencyId,\n\t\t\twithdraw: Balance,\n\t\t},\n\t\t/// Claim rewards.\n\t\tClaimRewards {\n\t\t\twho: T::AccountId,\n\t\t\tpool: PoolId,\n\t\t\treward_currency_id: CurrencyId,\n\t\t\tactual_amount: Balance,\n\t\t\tdeduction_amount: Balance,\n\t\t},\n\t\t/// Incentive reward amount updated.\n\t\tIncentiveRewardAmountUpdated {\n\t\t\tpool: PoolId,\n\t\t\treward_currency_id: CurrencyId,\n\t\t\treward_amount_per_period: Balance,\n\t\t},\n\t\t/// Payout deduction rate updated.\n\t\tClaimRewardDeductionRateUpdated { pool: PoolId, deduction_rate: Rate },\n\t\t/// Payout deduction currency updated.\n\t\tClaimRewardDeductionCurrencyUpdated { pool: PoolId, currency: Option<CurrencyId> },\n\t}\n\n\t/// Mapping from pool to its fixed incentive amounts of multi currencies per period.\n\t///\n\t/// IncentiveRewardAmounts: double_map Pool, RewardCurrencyId => RewardAmountPerPeriod\n\t#[pallet::storage]\n\t#[pallet::getter(fn incentive_reward_amounts)]\n\tpub type IncentiveRewardAmounts<T: Config> =\n\t\tStorageDoubleMap<_, Twox64Concat, PoolId, Twox64Concat, CurrencyId, Balance, ValueQuery>;\n\n\t/// Mapping from pool to its claim reward deduction rate.\n\t///\n\t/// ClaimRewardDeductionRates: map Pool => DeductionRate\n\t#[pallet::storage]\n\tpub type ClaimRewardDeductionRates<T: Config> = StorageMap<_, Twox64Concat, PoolId, FractionalRate, ValueQuery>;\n\n\t/// If specified, ClaimRewardDeductionRates only apply to this currency.\n\t///\n\t/// ClaimRewardDeductionCurrency: map Pool => Option<RewardCurrencyId>\n\t#[pallet::storage]\n\tpub type ClaimRewardDeductionCurrency<T: Config> = StorageMap<_, Twox64Concat, PoolId, CurrencyId, OptionQuery>;\n\n\t/// The pending rewards amount, actual available rewards amount may be deducted\n\t///\n\t/// PendingMultiRewards: double_map PoolId, AccountId => BTreeMap<CurrencyId, Balance>\n\t#[pallet::storage]\n\t#[pallet::getter(fn pending_multi_rewards)]\n\tpub type PendingMultiRewards<T: Config> = StorageDoubleMap<\n\t\t_,\n\t\tTwox64Concat,\n\t\tPoolId,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\tBTreeMap<CurrencyId, Balance>,\n\t\tValueQuery,\n\t>;\n\n\t#[pallet::pallet]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(_);\n\n\t#[pallet::hooks]\n\timpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {\n\t\tfn on_initialize(now: BlockNumberFor<T>) -> Weight {\n\t\t\t// accumulate reward periodically\n\t\t\tif now % T::AccumulatePeriod::get() == Zero::zero() {\n\t\t\t\tlet mut count: u32 = 0;\n\t\t\t\tlet shutdown = T::EmergencyShutdown::is_shutdown();\n\n\t\t\t\tfor (pool_id, pool_info) in orml_rewards::PoolInfos::<T>::iter() {\n\t\t\t\t\tif !pool_info.total_shares.is_zero() {\n\t\t\t\t\t\tmatch pool_id {\n\t\t\t\t\t\t\t// do not accumulate incentives for PoolId::Loans after shutdown\n\t\t\t\t\t\t\tPoolId::Loans(_) if shutdown => {\n\t\t\t\t\t\t\t\tlog::debug!(\n\t\t\t\t\t\t\t\t\ttarget: \"incentives\",\n\t\t\t\t\t\t\t\t\t\"on_initialize: skip accumulate incentives for pool {:?} after shutdown\",\n\t\t\t\t\t\t\t\t\tpool_id\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t\tSelf::accumulate_incentives(pool_id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tT::WeightInfo::on_initialize(count)\n\t\t\t} else {\n\t\t\t\tWeight::zero()\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Stake LP token to add shares of Pool::Dex\n\t\t///\n\t\t/// The dispatch origin of this call must be `Signed` by the transactor.\n\t\t///\n\t\t/// - `lp_currency_id`: LP token type\n\t\t/// - `amount`: amount to stake\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::deposit_dex_share())]\n\t\tpub fn deposit_dex_share(\n\t\t\torigin: OriginFor<T>,\n\t\t\tlp_currency_id: CurrencyId,\n\t\t\t#[pallet::compact] amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\t\t\tSelf::do_deposit_dex_share(&who, lp_currency_id, amount)?;\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Unstake LP token to remove shares of Pool::Dex\n\t\t///\n\t\t/// The dispatch origin of this call must be `Signed` by the transactor.\n\t\t///\n\t\t/// - `lp_currency_id`: LP token type\n\t\t/// - `amount`: amount to unstake\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::withdraw_dex_share())]\n\t\tpub fn withdraw_dex_share(\n\t\t\torigin: OriginFor<T>,\n\t\t\tlp_currency_id: CurrencyId,\n\t\t\t#[pallet::compact] amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\t\t\tSelf::do_withdraw_dex_share(&who, lp_currency_id, amount)?;\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Claim all avalible multi currencies rewards for specific PoolId.\n\t\t///\n\t\t/// The dispatch origin of this call must be `Signed` by the transactor.\n\t\t///\n\t\t/// - `pool_id`: pool type\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::claim_rewards())]\n\t\tpub fn claim_rewards(origin: OriginFor<T>, pool_id: PoolId) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tSelf::do_claim_rewards(who, pool_id)\n\t\t}\n\n\t\t/// Update incentive reward amount for specific PoolId\n\t\t///\n\t\t/// The dispatch origin of this call must be `UpdateOrigin`.\n\t\t///\n\t\t/// - `updates`: Vec<(PoolId, Vec<(RewardCurrencyId, FixedAmountPerPeriod)>)>\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_incentive_rewards(\n\t\t\tupdates.iter().fold(0, |count, x| count + x.1.len()) as u32\n\t\t))]\n\t\tpub fn update_incentive_rewards(\n\t\t\torigin: OriginFor<T>,\n\t\t\tupdates: Vec<(PoolId, Vec<(CurrencyId, Balance)>)>,\n\t\t) -> DispatchResult {\n\t\t\tT::UpdateOrigin::ensure_origin(origin)?;\n\t\t\tfor (pool_id, update_list) in updates {\n\t\t\t\tif let PoolId::Dex(currency_id) = pool_id {\n\t\t\t\t\tensure!(currency_id.is_dex_share_currency_id(), Error::<T>::InvalidPoolId);\n\t\t\t\t}\n\n\t\t\t\tfor (currency_id, amount) in update_list {\n\t\t\t\t\tIncentiveRewardAmounts::<T>::mutate_exists(pool_id, currency_id, |maybe_amount| {\n\t\t\t\t\t\tlet mut v = maybe_amount.unwrap_or_default();\n\t\t\t\t\t\tif amount != v {\n\t\t\t\t\t\t\tv = amount;\n\t\t\t\t\t\t\tSelf::deposit_event(Event::IncentiveRewardAmountUpdated {\n\t\t\t\t\t\t\t\tpool: pool_id,\n\t\t\t\t\t\t\t\treward_currency_id: currency_id,\n\t\t\t\t\t\t\t\treward_amount_per_period: amount,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif v.is_zero() {\n\t\t\t\t\t\t\t*maybe_amount = None;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*maybe_amount = Some(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Update claim rewards deduction rates for all rewards currencies of specific PoolId\n\t\t///\n\t\t/// The dispatch origin of this call must be `UpdateOrigin`.\n\t\t///\n\t\t/// - `updates`: Vec<(PoolId, DecutionRate>)>\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_claim_reward_deduction_rates(updates.len() as u32))]\n\t\tpub fn update_claim_reward_deduction_rates(\n\t\t\torigin: OriginFor<T>,\n\t\t\tupdates: Vec<(PoolId, Rate)>,\n\t\t) -> DispatchResult {\n\t\t\tT::UpdateOrigin::ensure_origin(origin)?;\n\t\t\tfor (pool_id, deduction_rate) in updates {\n\t\t\t\tif let PoolId::Dex(currency_id) = pool_id {\n\t\t\t\t\tensure!(currency_id.is_dex_share_currency_id(), Error::<T>::InvalidPoolId);\n\t\t\t\t}\n\t\t\t\tClaimRewardDeductionRates::<T>::mutate_exists(pool_id, |maybe_rate| -> DispatchResult {\n\t\t\t\t\tlet mut v = maybe_rate.unwrap_or_default();\n\t\t\t\t\tif deduction_rate != *v.inner() {\n\t\t\t\t\t\tv.try_set(deduction_rate).map_err(|_| Error::<T>::InvalidRate)?;\n\t\t\t\t\t\tSelf::deposit_event(Event::ClaimRewardDeductionRateUpdated {\n\t\t\t\t\t\t\tpool: pool_id,\n\t\t\t\t\t\t\tdeduction_rate,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif v.inner().is_zero() {\n\t\t\t\t\t\t*maybe_rate = None;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*maybe_rate = Some(v);\n\t\t\t\t\t}\n\t\t\t\t\tOk(())\n\t\t\t\t})?;\n\t\t\t}\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Update claim rewards deduction rates currency\n\t\t///\n\t\t/// The dispatch origin of this call must be `UpdateOrigin`.\n\t\t#[pallet::call_index(5)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_claim_reward_deduction_currency())]\n\t\tpub fn update_claim_reward_deduction_currency(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: PoolId,\n\t\t\tcurrency_id: Option<CurrencyId>,\n\t\t) -> DispatchResult {\n\t\t\tT::UpdateOrigin::ensure_origin(origin)?;\n\t\t\tClaimRewardDeductionCurrency::<T>::mutate_exists(pool_id, |c| *c = currency_id);\n\t\t\tSelf::deposit_event(Event::ClaimRewardDeductionCurrencyUpdated {\n\t\t\t\tpool: pool_id,\n\t\t\t\tcurrency: currency_id,\n\t\t\t});\n\t\t\tOk(())\n\t\t}\n\t}\n}\n\nimpl<T: Config> Pallet<T> {\n\tpub fn account_id() -> T::AccountId {\n\t\tT::PalletId::get().into_account_truncating()\n\t}\n\n\tpub(crate) fn claim_reward_deduction_rates(pool_id: &PoolId) -> Rate {\n\t\tClaimRewardDeductionRates::<T>::get(pool_id).into_inner()\n\t}\n\n\t// accumulate incentive rewards of multi currencies\n\tfn accumulate_incentives(pool_id: PoolId) {\n\t\tfor (reward_currency_id, reward_amount) in IncentiveRewardAmounts::<T>::iter_prefix(pool_id) {\n\t\t\tif reward_amount.is_zero() {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// ignore result so that failure will not block accumulate other type reward for the pool\n\t\t\tlet _ =\n\t\t\t\tSelf::transfer_rewards_and_update_records(pool_id, reward_currency_id, reward_amount).map_err(|e| {\n\t\t\t\t\tlog::warn!(\n\t\t\t\t\t\ttarget: \"incentives\",\n\t\t\t\t\t\t\"accumulate_incentives: failed to accumulate {:?} {:?} rewards for pool {:?} : {:?}\",\n\t\t\t\t\t\treward_amount, reward_currency_id, pool_id, e\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/// Ensure atomic\n\t#[transactional]\n\tfn transfer_rewards_and_update_records(\n\t\tpool_id: PoolId,\n\t\treward_currency_id: CurrencyId,\n\t\treward_amount: Balance,\n\t) -> DispatchResult {\n\t\tT::Currency::transfer(\n\t\t\treward_currency_id,\n\t\t\t&T::RewardsSource::get(),\n\t\t\t&Self::account_id(),\n\t\t\treward_amount,\n\t\t)?;\n\t\t<orml_rewards::Pallet<T>>::accumulate_reward(&pool_id, reward_currency_id, reward_amount)?;\n\t\tOk(())\n\t}\n\n\tfn do_claim_rewards(who: T::AccountId, pool_id: PoolId) -> DispatchResult {\n\t\t// orml_rewards will claim rewards for all currencies rewards\n\t\t<orml_rewards::Pallet<T>>::claim_rewards(&who, &pool_id);\n\n\t\tPendingMultiRewards::<T>::mutate_exists(pool_id, &who, |maybe_pending_multi_rewards| {\n\t\t\tif let Some(pending_multi_rewards) = maybe_pending_multi_rewards {\n\t\t\t\tlet deduction_rate = Self::claim_reward_deduction_rates(&pool_id);\n\t\t\t\tlet deduction_currency = ClaimRewardDeductionCurrency::<T>::get(pool_id);\n\n\t\t\t\tfor (currency_id, pending_reward) in pending_multi_rewards.iter_mut() {\n\t\t\t\t\tif pending_reward.is_zero() {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet deduction_rate = if let Some(deduction_currency) = deduction_currency {\n\t\t\t\t\t\t// only apply deduction rate to specified currency\n\t\t\t\t\t\tif deduction_currency == *currency_id {\n\t\t\t\t\t\t\tdeduction_rate\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tZero::zero()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// apply deduction rate to all currencies\n\t\t\t\t\t\tdeduction_rate\n\t\t\t\t\t};\n\n\t\t\t\t\tlet (payout_amount, deduction_amount) = {\n\t\t\t\t\t\tlet should_deduction_amount = deduction_rate.saturating_mul_int(*pending_reward);\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tpending_reward.saturating_sub(should_deduction_amount),\n\t\t\t\t\t\t\tshould_deduction_amount,\n\t\t\t\t\t\t)\n\t\t\t\t\t};\n\n\t\t\t\t\t// payout reward to claimer and re-accumuated reward.\n\t\t\t\t\tmatch Self::payout_reward_and_reaccumulate_reward(\n\t\t\t\t\t\tpool_id,\n\t\t\t\t\t\t&who,\n\t\t\t\t\t\t*currency_id,\n\t\t\t\t\t\tpayout_amount,\n\t\t\t\t\t\tdeduction_amount,\n\t\t\t\t\t) {\n\t\t\t\t\t\tOk(_) => {\n\t\t\t\t\t\t\t// update state\n\t\t\t\t\t\t\t*pending_reward = Zero::zero();\n\n\t\t\t\t\t\t\tSelf::deposit_event(Event::ClaimRewards {\n\t\t\t\t\t\t\t\twho: who.clone(),\n\t\t\t\t\t\t\t\tpool: pool_id,\n\t\t\t\t\t\t\t\treward_currency_id: *currency_id,\n\t\t\t\t\t\t\t\tactual_amount: payout_amount,\n\t\t\t\t\t\t\t\tdeduction_amount,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\t\tlog::error!(\n\t\t\t\t\t\t\t\ttarget: \"incentives\",\n\t\t\t\t\t\t\t\t\"payout_reward_and_reaccumulate_reward: failed to payout {:?} to {:?} and re-accumulate {:?} {:?} to pool {:?}: {:?}\",\n\t\t\t\t\t\t\t\tpayout_amount, who, deduction_amount, currency_id, pool_id, e\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// clear zero value item of BTreeMap\n\t\t\t\tpending_multi_rewards.retain(|_, v| *v != 0);\n\n\t\t\t\t// if pending_multi_rewards is default, clear the storage\n\t\t\t\tif pending_multi_rewards.is_empty() {\n\t\t\t\t\t*maybe_pending_multi_rewards = None;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tOk(())\n\t}\n\n\t/// Ensure atomic\n\t#[transactional]\n\tfn payout_reward_and_reaccumulate_reward(\n\t\tpool_id: PoolId,\n\t\twho: &T::AccountId,\n\t\treward_currency_id: CurrencyId,\n\t\tpayout_amount: Balance,\n\t\treaccumulate_amount: Balance,\n\t) -> DispatchResult {\n\t\tif !reaccumulate_amount.is_zero() {\n\t\t\t<orml_rewards::Pallet<T>>::accumulate_reward(&pool_id, reward_currency_id, reaccumulate_amount)?;\n\t\t}\n\t\tT::Currency::transfer(reward_currency_id, &Self::account_id(), who, payout_amount)?;\n\t\tOk(())\n\t}\n}\n\nimpl<T: Config> DEXIncentives<T::AccountId, CurrencyId, Balance> for Pallet<T> {\n\tfn do_deposit_dex_share(who: &T::AccountId, lp_currency_id: CurrencyId, amount: Balance) -> DispatchResult {\n\t\tensure!(lp_currency_id.is_dex_share_currency_id(), Error::<T>::InvalidCurrencyId);\n\n\t\tT::Currency::transfer(lp_currency_id, who, &Self::account_id(), amount)?;\n\t\t<orml_rewards::Pallet<T>>::add_share(who, &PoolId::Dex(lp_currency_id), amount.unique_saturated_into());\n\n\t\tSelf::deposit_event(Event::DepositDexShare {\n\t\t\twho: who.clone(),\n\t\t\tdex_share_type: lp_currency_id,\n\t\t\tdeposit: amount,\n\t\t});\n\t\tOk(())\n\t}\n\n\tfn do_withdraw_dex_share(who: &T::AccountId, lp_currency_id: CurrencyId, amount: Balance) -> DispatchResult {\n\t\tensure!(lp_currency_id.is_dex_share_currency_id(), Error::<T>::InvalidCurrencyId);\n\t\tensure!(\n\t\t\t<orml_rewards::Pallet<T>>::shares_and_withdrawn_rewards(&PoolId::Dex(lp_currency_id), &who).0 >= amount,\n\t\t\tError::<T>::NotEnough,\n\t\t);\n\n\t\tT::Currency::transfer(lp_currency_id, &Self::account_id(), who, amount)?;\n\t\t<orml_rewards::Pallet<T>>::remove_share(who, &PoolId::Dex(lp_currency_id), amount.unique_saturated_into());\n\n\t\tSelf::deposit_event(Event::WithdrawDexShare {\n\t\t\twho: who.clone(),\n\t\t\tdex_share_type: lp_currency_id,\n\t\t\twithdraw: amount,\n\t\t});\n\t\tOk(())\n\t}\n}\n\nimpl<T: Config> IncentivesManager<T::AccountId, Balance, CurrencyId, PoolId> for Pallet<T> {\n\tfn get_incentive_reward_amount(pool_id: PoolId, currency_id: CurrencyId) -> Balance {\n\t\tIncentiveRewardAmounts::<T>::get(pool_id, currency_id)\n\t}\n\n\tfn deposit_dex_share(who: &T::AccountId, lp_currency_id: CurrencyId, amount: Balance) -> DispatchResult {\n\t\tSelf::do_deposit_dex_share(who, lp_currency_id, amount)\n\t}\n\n\tfn withdraw_dex_share(who: &T::AccountId, lp_currency_id: CurrencyId, amount: Balance) -> DispatchResult {\n\t\tSelf::do_withdraw_dex_share(who, lp_currency_id, amount)\n\t}\n\n\tfn claim_rewards(who: T::AccountId, pool_id: PoolId) -> DispatchResult {\n\t\tSelf::do_claim_rewards(who, pool_id)\n\t}\n\n\tfn get_claim_reward_deduction_rate(pool_id: PoolId) -> Rate {\n\t\tSelf::claim_reward_deduction_rates(&pool_id)\n\t}\n\n\tfn get_pending_rewards(pool_id: PoolId, who: T::AccountId, reward_currencies: Vec<CurrencyId>) -> Vec<Balance> {\n\t\tlet rewards_map = PendingMultiRewards::<T>::get(pool_id, who);\n\t\tlet mut reward_balances = Vec::new();\n\t\tfor reward_currency in reward_currencies {\n\t\t\tlet reward_amount = rewards_map.get(&reward_currency).copied().unwrap_or_default();\n\t\t\treward_balances.push(reward_amount);\n\t\t}\n\t\treward_balances\n\t}\n}\n\npub struct OnUpdateLoan<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> Happened<(T::AccountId, CurrencyId, Amount, Balance)> for OnUpdateLoan<T> {\n\tfn happened(info: &(T::AccountId, CurrencyId, Amount, Balance)) {\n\t\tlet (who, currency_id, adjustment, _previous_amount) = info;\n\t\tlet adjustment_abs = TryInto::<Balance>::try_into(adjustment.saturating_abs()).unwrap_or_default();\n\n\t\tif adjustment.is_positive() {\n\t\t\t<orml_rewards::Pallet<T>>::add_share(who, &PoolId::Loans(*currency_id), adjustment_abs);\n\t\t} else {\n\t\t\t<orml_rewards::Pallet<T>>::remove_share(who, &PoolId::Loans(*currency_id), adjustment_abs);\n\t\t};\n\t}\n}\n\nimpl<T: Config> RewardHandler<T::AccountId, CurrencyId> for Pallet<T> {\n\ttype Balance = Balance;\n\ttype PoolId = PoolId;\n\n\tfn payout(who: &T::AccountId, pool_id: &Self::PoolId, currency_id: CurrencyId, payout_amount: Self::Balance) {\n\t\tif payout_amount.is_zero() {\n\t\t\treturn;\n\t\t}\n\t\tPendingMultiRewards::<T>::mutate(pool_id, who, |rewards| {\n\t\t\trewards\n\t\t\t\t.entry(currency_id)\n\t\t\t\t.and_modify(|current| *current = current.saturating_add(payout_amount))\n\t\t\t\t.or_insert(payout_amount);\n\t\t});\n\t}\n}\n\npub struct OnEarningBonded<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> Happened<(T::AccountId, Balance)> for OnEarningBonded<T> {\n\tfn happened((who, amount): &(T::AccountId, Balance)) {\n\t\t<orml_rewards::Pallet<T>>::add_share(who, &PoolId::Earning(T::NativeCurrencyId::get()), *amount);\n\t}\n}\n\npub struct OnEarningUnbonded<T>(sp_std::marker::Pha"
    }
  ]
}