{
  "Title": "`previousRewardsHandler` may be null",
  "Content": "##### Description\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/CNCMintingRebalancingRewardsHandler.sol#L64\n\n`previousRewardsHandler` is used to count how much totalCncMinted was minted by the previous `CNCMintingRebalancingRewardsHandler`.\n\nIf this is a new contract, then zero is transmitted. However, the initialize method does not have such a check.\n\n##### Recommendation\nWe recommend adding `previousRewardsHandler != address(0x0)`.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/tokenomics/CNCMintingRebalancingRewardsHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/tokenomics/ICNCMintingRebalancingRewardsHandler.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\nimport \"../../interfaces/pools/IConicPool.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\ncontract CNCMintingRebalancingRewardsHandler is\n    ICNCMintingRebalancingRewardsHandler,\n    Ownable,\n    Initializable\n{\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev the maximum amount of CNC that can be minted for rebalancing rewards\n    uint256 internal constant _MAX_REBALANCING_REWARDS = 1_900_000e18; // 19% of total supply\n\n    /// @dev gives out 5 dollars per 1 hour (assuming 1 CNC = 6 USD) for every 10,000 USD in TVL that needs to be shifted\n    uint256 internal constant _INITIAL_REBALANCING_REWARD_PER_DOLLAR_PER_SECOND =\n        5e18 / uint256(3600 * 1 * 10_000 * 6);\n\n    IController public immutable override controller;\n\n    ICNCToken public immutable cnc;\n\n    ICNCMintingRebalancingRewardsHandler public immutable previousRewardsHandler;\n    uint256 public override totalCncMinted;\n    uint256 public override cncRebalancingRewardPerDollarPerSecond;\n\n    bool internal _isInternal;\n\n    modifier onlyInflationManager() {\n        require(\n            msg.sender == address(controller.inflationManager()),\n            \"only InflationManager can call this function\"\n        );\n        _;\n    }\n\n    constructor(\n        IController _controller,\n        ICNCToken _cnc,\n        ICNCMintingRebalancingRewardsHandler _previousRewardsHandler\n    ) {\n        cncRebalancingRewardPerDollarPerSecond = _INITIAL_REBALANCING_REWARD_PER_DOLLAR_PER_SECOND;\n        controller = _controller;\n        previousRewardsHandler = _previousRewardsHandler;\n        cnc = _cnc;\n    }\n\n    function initialize() external onlyOwner initializer {\n        totalCncMinted = previousRewardsHandler.totalCncMinted();\n    }\n\n    function setCncRebalancingRewardPerDollarPerSecond(\n        uint256 _cncRebalancingRewardPerDollarPerSecond\n    ) external override onlyOwner {\n        cncRebalancingRewardPerDollarPerSecond = _cncRebalancingRewardPerDollarPerSecond;\n        emit SetCncRebalancingRewardPerDollarPerSecond(_cncRebalancingRewardPerDollarPerSecond);\n    }\n\n    function _distributeRebalancingRewards(address pool, address account, uint256 amount) internal {\n        if (totalCncMinted + amount > _MAX_REBALANCING_REWARDS) {\n            amount = _MAX_REBALANCING_REWARDS - totalCncMinted;\n        }\n        if (amount == 0) return;\n        uint256 mintedAmount = cnc.mint(account, amount);\n        if (mintedAmount > 0) {\n            totalCncMinted += mintedAmount;\n            emit RebalancingRewardDistributed(pool, account, address(cnc), mintedAmount);\n        }\n    }\n\n    function handleRebalancingRewards(\n        IConicPool conicPool,\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) external onlyInflationManager {\n        _handleRebalancingRewards(conicPool, account, deviationBefore, deviationAfter);\n    }\n\n    function _handleRebalancingRewards(\n        IConicPool conicPool,\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) internal {\n        if (_isInternal) return;\n        uint256 cncRewardAmount = computeRebalancingRewards(\n            address(conicPool),\n            deviationBefore,\n            deviationAfter\n        );\n        _distributeRebalancingRewards(address(conicPool), account, cncRewardAmount);\n    }\n\n    /// @dev this computes how much CNC a user should get when depositing\n    /// this does not check whether the rewards should still be distributed\n    /// amount CNC = t * CNC/s * (1 - (Δdeviation / initialDeviation))\n    /// where\n    /// CNC/s: the amount of CNC per second to distributed for rebalancing\n    /// t: the time elapsed since the weight update\n    /// Δdeviation: the deviation difference caused by this deposit\n    /// initialDeviation: the deviation after updating weights\n    /// @return the amount of CNC to give to the user as reward\n    function computeRebalancingRewards(\n        address conicPool,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) public view override returns (uint256) {\n        if (deviationBefore < deviationAfter) return 0;\n        uint8 decimals = IConicPool(conicPool).underlying().decimals();\n        uint256 deviationDelta = deviationBefore - deviationAfter;\n        uint256 lastWeightUpdate = controller.lastWeightUpdate(conicPool);\n        uint256 elapsedSinceUpdate = uint256(block.timestamp) - lastWeightUpdate;\n        return\n            (elapsedSinceUpdate * cncRebalancingRewardPerDollarPerSecond).mulDown(\n                deviationDelta.convertScale(decimals, 18)\n            );\n    }\n\n    function rebalance(\n        address conicPool,\n        uint256 underlyingAmount,\n        uint256 minUnderlyingReceived,\n        uint256 minCNCReceived\n    ) external override returns (uint256 underlyingReceived, uint256 cncReceived) {\n        require(controller.isPool(conicPool), \"not a pool\");\n        IConicPool conicPool_ = IConicPool(conicPool);\n        bool rebalancingRewardActive = conicPool_.rebalancingRewardActive();\n        IERC20 underlying = conicPool_.underlying();\n        require(underlying.balanceOf(msg.sender) >= underlyingAmount, \"insufficient underlying\");\n        uint256 deviationBefore = conicPool_.computeTotalDeviation();\n        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);\n        underlying.safeApprove(conicPool, underlyingAmount);\n        _isInternal = true;\n        uint256 lpTokenAmount = conicPool_.deposit(underlyingAmount, 0, false);\n        _isInternal = false;\n        underlyingReceived = conicPool_.withdraw(lpTokenAmount, 0);\n        require(underlyingReceived >= minUnderlyingReceived, \"insufficient underlying received\");\n        uint256 cncBefore = cnc.balanceOf(msg.sender);\n\n        // Only distribute rebalancing rewards if active\n        if (rebalancingRewardActive) {\n            uint256 deviationAfter = conicPool_.computeTotalDeviation();\n            _handleRebalancingRewards(conicPool_, msg.sender, deviationBefore, deviationAfter);\n        }\n\n        cncReceived = cnc.balanceOf(msg.sender) - cncBefore;\n        require(cncReceived >= minCNCReceived, \"insufficient CNC received\");\n        underlying.safeTransfer(msg.sender, underlyingReceived);\n    }\n\n    /// @notice switches the minting rebalancing reward handler by granting the new one minting rights\n    /// and renouncing his own\n    /// `InflationManager.removePoolRebalancingRewardHandler` should be called on every pool before this is called\n    /// this should typically be done as a single batched governance action\n    /// The same governance action should also call `InflationManager.addPoolRebalancingRewardHandler` for each pool\n    /// passing in `newRebalancingRewardsHandler` so that the whole operation is atomic\n    /// @param newRebalancingRewardsHandler the address of the new rebalancing rewards handler\n    function switchMintingRebalancingRewardsHandler(\n        address newRebalancingRewardsHandler\n    ) external onlyOwner {\n        address[] memory pools = controller.listPools();\n        for (uint256 i; i < pools.length; i++) {\n            require(\n                !controller.inflationManager().hasPoolRebalancingRewardHandlers(\n                    pools[i],\n                    address(this)\n                ),\n                \"handler is still registered for a pool\"\n            );\n        }\n        cnc.addMinter(newRebalancingRewardsHandler);\n        cnc.renounceMinterRights();\n    }\n}"
    }
  ]
}