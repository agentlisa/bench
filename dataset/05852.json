{
  "Title": "[04] Using `delegatecall` inside a loop may cause issues with `payable` functions",
  "Content": "\nIf one of the `delegatecall` consumes part of the `msg.value`, other calls might fail, if they expect the full `msg.value`. Consider using a different design, or fully document this decision to avoid potential issues.\n\n```solidity\nfunction multicall(bytes[] calldata data) external payable override returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    bool success;\n    unchecked {\n        for (uint256 i = 0; i < data.length; ++i) {\n            //slither-disable-next-line calls-loop,delegatecall-loop\n            (success, results[i]) = address(this).delegatecall(data[i]);\n            if (!success) revert MulticallFailed();\n        }\n    }\n}\n```\n\nhttps://github.com/delegatexyz/delegate-registry/blob/6d1254de793ccc40134f9bec0b7cb3d9c3632bc1/src/DelegateRegistry.sol#L37\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-delegate",
  "Code": [
    {
      "filename": "src/DelegateRegistry.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.21;\n\nimport {IDelegateRegistry as IDelegateRegistry} from \"./IDelegateRegistry.sol\";\nimport {RegistryHashes as Hashes} from \"./libraries/RegistryHashes.sol\";\nimport {RegistryStorage as Storage} from \"./libraries/RegistryStorage.sol\";\nimport {RegistryOps as Ops} from \"./libraries/RegistryOps.sol\";\n\n/**\n * @title DelegateRegistry\n * @custom:version 2.0\n * @custom:coauthor foobar (0xfoobar)\n * @custom:coauthor mireynolds\n * @notice A standalone immutable registry storing delegated permissions from one address to another\n */\ncontract DelegateRegistry is IDelegateRegistry {\n    /// @dev Only this mapping should be used to verify delegations; the other mapping arrays are for enumerations\n    mapping(bytes32 delegationHash => bytes32[5] delegationStorage) internal delegations;\n\n    /// @dev Vault delegation enumeration outbox, for pushing new hashes only\n    mapping(address from => bytes32[] delegationHashes) internal outgoingDelegationHashes;\n\n    /// @dev Delegate enumeration inbox, for pushing new hashes only\n    mapping(address to => bytes32[] delegationHashes) internal incomingDelegationHashes;\n\n    /**\n     * ----------- WRITE -----------\n     */\n\n    /// @inheritdoc IDelegateRegistry\n    function multicall(bytes[] calldata data) external payable override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        bool success;\n        unchecked {\n            for (uint256 i = 0; i < data.length; ++i) {\n                //slither-disable-next-line calls-loop,delegatecall-loop\n                (success, results[i]) = address(this).delegatecall(data[i]);\n                if (!success) revert MulticallFailed();\n            }\n        }\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function delegateAll(address to, bytes32 rights, bool enable) external payable override returns (bytes32 hash) {\n        hash = Hashes.allHash(msg.sender, rights, to);\n        bytes32 location = Hashes.location(hash);\n        address loadedFrom = _loadFrom(location);\n        if (enable) {\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\n                _pushDelegationHashes(msg.sender, to, hash);\n                _writeDelegationAddresses(location, msg.sender, to, address(0));\n                if (rights != \"\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\n                _updateFrom(location, msg.sender);\n            }\n        } else if (loadedFrom == msg.sender) {\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\n        }\n        emit DelegateAll(msg.sender, to, rights, enable);\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable) external payable override returns (bytes32 hash) {\n        hash = Hashes.contractHash(msg.sender, rights, to, contract_);\n        bytes32 location = Hashes.location(hash);\n        address loadedFrom = _loadFrom(location);\n        if (enable) {\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\n                _pushDelegationHashes(msg.sender, to, hash);\n                _writeDelegationAddresses(location, msg.sender, to, contract_);\n                if (rights != \"\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\n                _updateFrom(location, msg.sender);\n            }\n        } else if (loadedFrom == msg.sender) {\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\n        }\n        emit DelegateContract(msg.sender, to, contract_, rights, enable);\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable) external payable override returns (bytes32 hash) {\n        hash = Hashes.erc721Hash(msg.sender, rights, to, tokenId, contract_);\n        bytes32 location = Hashes.location(hash);\n        address loadedFrom = _loadFrom(location);\n        if (enable) {\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\n                _pushDelegationHashes(msg.sender, to, hash);\n                _writeDelegationAddresses(location, msg.sender, to, contract_);\n                _writeDelegation(location, Storage.POSITIONS_TOKEN_ID, tokenId);\n                if (rights != \"\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\n                _updateFrom(location, msg.sender);\n            }\n        } else if (loadedFrom == msg.sender) {\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\n        }\n        emit DelegateERC721(msg.sender, to, contract_, tokenId, rights, enable);\n    }\n\n    // @inheritdoc IDelegateRegistry\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount) external payable override returns (bytes32 hash) {\n        hash = Hashes.erc20Hash(msg.sender, rights, to, contract_);\n        bytes32 location = Hashes.location(hash);\n        address loadedFrom = _loadFrom(location);\n        if (amount != 0) {\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\n                _pushDelegationHashes(msg.sender, to, hash);\n                _writeDelegationAddresses(location, msg.sender, to, contract_);\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\n                if (rights != \"\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\n                _updateFrom(location, msg.sender);\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\n            } else if (loadedFrom == msg.sender) {\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\n            }\n        } else if (loadedFrom == msg.sender) {\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\n            _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\n        }\n        emit DelegateERC20(msg.sender, to, contract_, rights, amount);\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount) external payable override returns (bytes32 hash) {\n        hash = Hashes.erc1155Hash(msg.sender, rights, to, tokenId, contract_);\n        bytes32 location = Hashes.location(hash);\n        address loadedFrom = _loadFrom(location);\n        if (amount != 0) {\n            if (loadedFrom == Storage.DELEGATION_EMPTY) {\n                _pushDelegationHashes(msg.sender, to, hash);\n                _writeDelegationAddresses(location, msg.sender, to, contract_);\n                _writeDelegation(location, Storage.POSITIONS_TOKEN_ID, tokenId);\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\n                if (rights != \"\") _writeDelegation(location, Storage.POSITIONS_RIGHTS, rights);\n            } else if (loadedFrom == Storage.DELEGATION_REVOKED) {\n                _updateFrom(location, msg.sender);\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\n            } else if (loadedFrom == msg.sender) {\n                _writeDelegation(location, Storage.POSITIONS_AMOUNT, amount);\n            }\n        } else if (loadedFrom == msg.sender) {\n            _updateFrom(location, Storage.DELEGATION_REVOKED);\n            _writeDelegation(location, Storage.POSITIONS_AMOUNT, uint256(0));\n        }\n        emit DelegateERC1155(msg.sender, to, contract_, tokenId, rights, amount);\n    }\n\n    /// @dev Transfer native token out\n    function sweep() external {\n        // TODO: Replace this with correct address at deployment time\n        // This hardcoded address is a CREATE2 factory counterfactual smart contract wallet that will always accept native token transfers\n        uint256 sc = uint256(uint160(0x0000000000000000000000000000000000000000));\n        assembly (\"memory-safe\") {\n            let result := call(gas(), sc, selfbalance(), 0, 0, 0, 0)\n        }\n    }\n\n    /**\n     * ----------- CHECKS -----------\n     */\n\n    /// @inheritdoc IDelegateRegistry\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view override returns (bool valid) {\n        if (!_invalidFrom(from)) {\n            valid = _validateFrom(Hashes.allLocation(from, \"\", to), from);\n            if (!Ops.or(rights == \"\", valid)) valid = _validateFrom(Hashes.allLocation(from, rights, to), from);\n        }\n        assembly (\"memory-safe\") {\n            // Only first 32 bytes of scratch space is accessed\n            mstore(0, iszero(iszero(valid))) // Compiler cleans dirty booleans on the stack to 1, so do the same here\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\n        }\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights) external view override returns (bool valid) {\n        if (!_invalidFrom(from)) {\n            valid = _validateFrom(Hashes.allLocation(from, \"\", to), from) || _validateFrom(Hashes.contractLocation(from, \"\", to, contract_), from);\n            if (!Ops.or(rights == \"\", valid)) {\n                valid = _validateFrom(Hashes.allLocation(from, rights, to), from) || _validateFrom(Hashes.contractLocation(from, rights, to, contract_), from);\n            }\n        }\n        assembly (\"memory-safe\") {\n            // Only first 32 bytes of scratch space is accessed\n            mstore(0, iszero(iszero(valid))) // Compiler cleans dirty booleans on the stack to 1, so do the same here\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\n        }\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view override returns (bool valid) {\n        if (!_invalidFrom(from)) {\n            valid = _validateFrom(Hashes.allLocation(from, \"\", to), from) || _validateFrom(Hashes.contractLocation(from, \"\", to, contract_), from)\n                || _validateFrom(Hashes.erc721Location(from, \"\", to, tokenId, contract_), from);\n            if (!Ops.or(rights == \"\", valid)) {\n                valid = _validateFrom(Hashes.allLocation(from, rights, to), from) || _validateFrom(Hashes.contractLocation(from, rights, to, contract_), from)\n                    || _validateFrom(Hashes.erc721Location(from, rights, to, tokenId, contract_), from);\n            }\n        }\n        assembly (\"memory-safe\") {\n            // Only first 32 bytes of scratch space is accessed\n            mstore(0, iszero(iszero(valid))) // Compiler cleans dirty booleans on the stack to 1, so do the same here\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\n        }\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights) external view override returns (uint256 amount) {\n        if (!_invalidFrom(from)) {\n            amount = (_validateFrom(Hashes.allLocation(from, \"\", to), from) || _validateFrom(Hashes.contractLocation(from, \"\", to, contract_), from))\n                ? type(uint256).max\n                : _loadDelegationUint(Hashes.erc20Location(from, \"\", to, contract_), Storage.POSITIONS_AMOUNT);\n            if (!Ops.or(rights == \"\", amount == type(uint256).max)) {\n                uint256 rightsBalance = (_validateFrom(Hashes.allLocation(from, rights, to), from) || _validateFrom(Hashes.contractLocation(from, rights, to, contract_), from))\n                    ? type(uint256).max\n                    : _loadDelegationUint(Hashes.erc20Location(from, rights, to, contract_), Storage.POSITIONS_AMOUNT);\n                amount = Ops.max(rightsBalance, amount);\n            }\n        }\n        assembly (\"memory-safe\") {\n            mstore(0, amount) // Only first 32 bytes of scratch space being accessed\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\n        }\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view override returns (uint256 amount) {\n        if (!_invalidFrom(from)) {\n            amount = (_validateFrom(Hashes.allLocation(from, \"\", to), from) || _validateFrom(Hashes.contractLocation(from, \"\", to, contract_), from))\n                ? type(uint256).max\n                : _loadDelegationUint(Hashes.erc1155Location(from, \"\", to, tokenId, contract_), Storage.POSITIONS_AMOUNT);\n            if (!Ops.or(rights == \"\", amount == type(uint256).max)) {\n                uint256 rightsBalance = (_validateFrom(Hashes.allLocation(from, rights, to), from) || _validateFrom(Hashes.contractLocation(from, rights, to, contract_), from))\n                    ? type(uint256).max\n                    : _loadDelegationUint(Hashes.erc1155Location(from, rights, to, tokenId, contract_), Storage.POSITIONS_AMOUNT);\n                amount = Ops.max(rightsBalance, amount);\n            }\n        }\n        assembly (\"memory-safe\") {\n            mstore(0, amount) // Only first 32 bytes of scratch space is accessed\n            return(0, 32) // Direct return, skips Solidity's redundant copying to save gas\n        }\n    }\n\n    /**\n     * ----------- ENUMERATIONS -----------\n     */\n\n    /// @inheritdoc IDelegateRegistry\n    function getIncomingDelegations(address to) external view override returns (Delegation[] memory delegations_) {\n        delegations_ = _getValidDelegationsFromHashes(incomingDelegationHashes[to]);\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations_) {\n        delegations_ = _getValidDelegationsFromHashes(outgoingDelegationHashes[from]);\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes) {\n        delegationHashes = _getValidDelegationHashesFromHashes(incomingDelegationHashes[to]);\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes) {\n        delegationHashes = _getValidDelegationHashesFromHashes(outgoingDelegationHashes[from]);\n    }\n\n    /// @inheritdoc IDelegateRegistry\n    function getDelegationsFromHashes(bytes32[] calldata hashes) external view returns (Delegation[] memory delegations_) {\n        delegations_ = new Delegation[](hashes.length);\n        unchecked {\n            for (uint256 i = 0; i < hashes.length; ++i) {\n                bytes32 location = Hashes.location(hashes[i]);\n                address from = _loadFrom(location);\n                if (_invalidFrom(from)) {\n                    delegations_[i] = Delegation({type_: DelegationType.NONE, to: address(0), from: address(0), rights: \"\", amount: 0, contract_: address(0), tokenId: 0});\n                } else {\n                    (, address to, address contract_) = _loadDelegationAddresses(location);\n                    delegations_[i] = Delegation({\n                        type_: Hashes.decodeType(hashes[i]),\n                        to: to,\n                        from: from,\n                        rights: _loadDelegationBytes32(location, Storage.POSITIONS_RIGHTS),\n                        amount: _loadDelegationUint(location, Storage.POSITIONS_AMOUNT),\n                        contract_: contract_,\n                        tokenId: _loadDelegationUint(location, Storage.POSITIONS_TOKEN_ID)\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * ----------- EXTERNAL STORAGE ACCESS -----------\n     */\n\n    function readSlot(bytes32 location) external view returns (bytes32 contents) {\n        assembly {\n            contents := sload(location)\n        }\n    }\n\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory contents) {\n        uint256 length = locations.length;\n        contents = new bytes32[](length);\n        bytes32 tempLocation;\n        bytes32 tempValue;\n        unchecked {\n            for (uint256 i = 0; i < length; ++i) {\n                tempLocation = locations[i];\n                assembly {\n                    tempValue := sload(tempLocation)\n                }\n                contents[i] = tempValue;\n            }\n        }\n    }\n\n    /**\n     * ----------- ERC165 -----------\n     */\n\n    /// @notice Query if a contract implements an ERC-165 interface\n    /// @param interfaceId The interface identifier\n    /// @return valid Whether the queried interface is supported\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return Ops.or(interfaceId == type(IDelegateRegistry).interfaceId, interfaceId == 0x01ffc9a7);\n    }\n\n    /**\n     * ----------- INTERNAL -----------\n     */\n\n    /// @dev Helper function to push new delegation hashes to the incoming and outgoing hashes mappings\n    function _pushDelegationHashes(address from, address to, bytes32 delegationHash) internal {\n        outgoingDelegationHashes[from].push(delegationHash);\n        incomingDelegationHashes[to].push(delegationHash);\n    }\n\n    /// @dev Helper function that writes bytes32 data to delegation data location at array position\n    function _writeDelegation(bytes32 location, uint256 position, bytes32 data) internal {\n        assembly {\n            sstore(add(location, position), data)\n        }\n    }\n\n    /// @dev Helper function that writes uint256 data to delegation data location at array position\n    function _writeDelegation(bytes32 location, uint256 position, uint256 data) internal {\n        assembly {\n            sstore(add(location, position), data)\n        }\n    }\n\n    /// @dev Helper function that writes addresses according to the packing rule for delegation storage\n    function _writeDelegationAddresses(bytes32 location, address from, address to, address contract_) internal {\n        (bytes32 firstSlot, bytes32 secondSlot) = Storage.packAddresses(from, to, contract_);\n        uint256 firstPacked = Storage.POSITIONS_FIRST_PACKED;\n        uint256 secondPacked = Storage.POSITIONS_SECOND_PACKED;\n        assembly {\n            sstore(add(location, firstPacked), firstSlot)\n            sstore(add(location, secondPacked), secondSlot)\n        }\n    }\n\n    /// @dev Helper function that writes from whilst preserving the rest of the storage slot\n    function _updateFrom(bytes32 location, address from) internal {\n        uint256 firstPacked = Storage.POSITIONS_FIRST_PACKED;\n        uint256 cleanAddress = Storage.CLEAN_ADDRESS;\n        uint256 cleanUpper12Bytes = type(uint256).max << 160;\n        assembly {\n            let slot := and(sload(add(location, firstPacked)), cleanUpper12Bytes)\n            sstore(add(location, firstPacked), or(slot, and(from, cleanAddress)))\n        }\n    }\n\n    /// @dev Helper function that takes an array of delegation hashes and returns an array of Delegation structs with their onchain information\n    function _getValidDelegationsFromHashes(bytes32[] storage hashes) internal view returns (Delegation[] memory delegations_) {\n        uint256 count = 0;\n        uint256 hashesLength = hashes.length;\n        bytes32 hash;\n        bytes32[] memory filteredHashes = new bytes32[](hashesLength);\n        unchecked {\n            for (uint256 i = 0; i < hashesLength; ++i) {\n                hash = hashes[i];\n                if (_invalidFrom(_loadFrom(Hashes.location(hash)))) continue;\n                filteredHashes[count++] = hash;\n            }\n            delegations_ = new Delegation[](count);\n            bytes32 location;\n            for (uint256 i = 0; i < count; ++i) {\n                hash = filteredHashes[i];\n                location = Hashes.location(hash);\n                (address from, address to, address contract_) = _loadDelegationAddresses(location);\n                delegations_[i] = Delegation({\n                    type_: Hashes.decodeType(hash),\n                    to: to,\n                    from: from,\n                    rights: _loadDelegationBytes32(location, Storage.POSITIONS_RIGHTS),\n                    amount: _loadDelegationUint(location, Storage.POSITIONS_AMOUNT),\n                    contract_: contract_,\n                    tokenId: _loadDelegationUint(location, Storage.POSITIONS_TOKEN_ID)\n                });\n            }\n        }\n    }\n\n    /// @dev Helper function that takes an array of delegation hashes and returns an array of valid delegation hashes\n    function _getValidDelegationHashesFromHashes(bytes32[] storage hashes) internal view returns (bytes32[] memory validHashes) {\n        uint256 count = 0;\n        uint256 hashesLength = hashes.length;\n        bytes32 hash;\n        bytes32[] memory filteredHashes = new bytes32[](hashesLength);\n        unchecked {\n            for (uint256 i = 0; i < hashesLength; ++i) {\n                hash = hashes[i];\n                if (_invalidFrom(_loadFrom(Hashes.location(hash)))) continue;\n                filteredHashes[count++] = hash;\n            }\n            validHashes = new bytes32[](count);\n            for (uint256 i = 0; i < count; ++i) {\n                validHashes[i] = filteredHashes[i];\n            }\n        }\n    }\n\n    /// @dev Helper function that loads delegation data from a particular array position and returns as bytes32\n    function _loadDelegationBytes32(bytes32 location, uint256 position) internal view returns (bytes32 data) {\n        assembly {\n            data := sload(add(location, position))\n        }\n    }\n\n    /// @dev Helper function that loads delegation data from a particular array position and returns as uint256\n    function _loadDelegationUint(bytes32 location, uint256 position) internal view returns (uint256 data) {\n        assembly {\n            data := sload(add(location, position))\n        }\n    }\n\n    // @dev Helper function that loads the from address from storage according to the packing rule for delegation storage\n    function _loadFrom(bytes32 location) internal view returns (address) {\n        bytes32 data;\n        uint256 firstPacked = Storage.POSITIONS_FIRST_PACKED;\n        assembly {\n            data := sload(add(location, firstPacked))\n        }\n        return Storage.unpackAddress(data);\n    }\n\n    /// @dev Helper function to establish whether a delegation is enabled\n    function _validateFrom(bytes32 location, address from) internal view returns (bool) {\n        return (from == _loadFrom(location));\n    }\n\n    /// @dev Helper function that loads the address for the delegation according to the packing rule for delegation storage\n    function _loadDelegationAddresses(bytes32 location) internal view returns (address from, address to, address contract_) {\n        bytes32 firstSlot;\n        bytes32 secondSlot;\n        uint256 firstPacked = Storage.POSITIONS_FIRST_PACKED;\n        uint256 secondPacked = Storage.POSITIONS_SECOND_PACKED;\n        assembly {\n            firstSlot := sload(add(location, firstPacked))\n            secondSlot := sload(add(location, secondPacked))\n        }\n        (from, to, contract_) = Storage.unpackAddresses(firstSlot, secondSlot);\n    }\n\n    function _invalidFrom(address from) internal pure returns (bool) {\n        return Ops.or(from == Storage.DELEGATION_EMPTY, from == Storage.DELEGATION_REVOKED);\n    }\n}"
    }
  ]
}