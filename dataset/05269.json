{
  "Title": "[L-11] - Users from excluded countries, without wallet authorization can call `cancelUnstake()`",
  "Content": "\nThere is no restriction in [`cancelUnstake()`](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/Staking.sol#L84-L97) to prevent wallets without access to call the function, like in [`stakeSALT()`](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/Staking.sol#L43).\n\nCanceling the unstake process puts back the staked SALT in the contract, like with the staking process.\n\n### Recommendation\n\nConsider not allowing unauthorized users to cancel their unstake process.\n\n```diff\n    function cancelUnstake( uint256 unstakeID ) external nonReentrant\n+       require( exchangeConfig.walletHasAccess(msg.sender), \"Sender does not have exchange access\" );\n```\n\n## Non-Critical Severity Findings\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/staking/Staking.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"../interfaces/ISalt.sol\";\nimport \"./StakingRewards.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Staking SALT provides xSALT at a 1:1 ratio.\n// Unstaking xSALT to reclaim SALT has a default unstake duration of 52 weeks and a minimum duration of two weeks.\n// Expedited unstaking for two weeks allows a default 20% of the SALT to be reclaimed, while unstaking for a full year allows the full 100% to be reclaimed.\n\ncontract Staking is IStaking, StakingRewards\n    {\n\tevent SALTStaked(address indexed user, uint256 amountStaked);\n\tevent UnstakeInitiated(address indexed user, uint256 indexed unstakeID, uint256 amountUnstaked, uint256 claimableSALT, uint256 numWeeks);\n\tevent UnstakeCancelled(address indexed user, uint256 indexed unstakeID);\n\tevent SALTRecovered(address indexed user, uint256 indexed unstakeID, uint256 saltRecovered, uint256 expeditedUnstakeFee);\n\tevent XSALTTransferredFromAirdrop(address indexed toUser, uint256 amountTransferred);\n\n\tusing SafeERC20 for ISalt;\n\n\t// The unstakeIDs for each user - including completed and cancelled unstakes.\n\tmapping(address => uint256[]) private _userUnstakeIDs;\n\n\t// Mapping of unstake IDs to their corresponding Unstake data.\n    mapping(uint256=>Unstake) private _unstakesByID;\n\tuint256 public nextUnstakeID;\n\n\n\tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\tStakingRewards( _exchangeConfig, _poolsConfig, _stakingConfig )\n\t\t{\n\t\t}\n\n\n\t// Stake a given amount of SALT and immediately receive the same amount of xSALT.\n\t// Requires exchange access for the sending wallet.\n\tfunction stakeSALT( uint256 amountToStake ) external nonReentrant\n\t\t{\n\t\trequire( exchangeConfig.walletHasAccess(msg.sender), \"Sender does not have exchange access\" );\n\n\t\t// Increase the user's staking share so that they will receive more future SALT rewards.\n\t\t// No cooldown as it takes default 52 weeks to unstake the xSALT to receive the full amount of staked SALT back.\n\t\t_increaseUserShare( msg.sender, PoolUtils.STAKED_SALT, amountToStake, false );\n\n\t\t// Transfer the SALT from the user's wallet\n\t\tsalt.safeTransferFrom( msg.sender, address(this), amountToStake );\n\n\t\temit SALTStaked(msg.sender, amountToStake);\n\t\t}\n\n\n\t// Unstake a given amount of xSALT over a certain duration.\n\t// Unstaking immediately reduces the user's xSALT balance even though there will be the specified delay to convert it back to SALT\n\t// With a full unstake duration the user receives 100% of their staked amount.\n\t// With expedited unstaking the user receives less.\n\tfunction unstake( uint256 amountUnstaked, uint256 numWeeks ) external nonReentrant returns (uint256 unstakeID)\n\t\t{\n\t\trequire( userShareForPool(msg.sender, PoolUtils.STAKED_SALT) >= amountUnstaked, \"Cannot unstake more than the amount staked\" );\n\n\t\tuint256 claimableSALT = calculateUnstake( amountUnstaked, numWeeks );\n\t\tuint256 completionTime = block.timestamp + numWeeks * ( 1 weeks );\n\n\t\tunstakeID = nextUnstakeID++;\n\t\tUnstake memory u = Unstake( UnstakeState.PENDING, msg.sender, amountUnstaked, claimableSALT, completionTime, unstakeID );\n\n\t\t_unstakesByID[unstakeID] = u;\n\t\t_userUnstakeIDs[msg.sender].push( unstakeID );\n\n\t\t// Decrease the user's staking share so that they will receive less future SALT rewards\n\t\t// This call will send any pending SALT rewards to msg.sender as well.\n\t\t// Note: _decreaseUserShare checks to make sure that the user has the specified staking share balance.\n\t\t_decreaseUserShare( msg.sender, PoolUtils.STAKED_SALT, amountUnstaked, false );\n\n\t\temit UnstakeInitiated(msg.sender, unstakeID, amountUnstaked, claimableSALT, numWeeks);\n\t\t}\n\n\n\t// Cancel a pending unstake.\n\t// Caller will be able to use the xSALT again immediately\n\tfunction cancelUnstake( uint256 unstakeID ) external nonReentrant\n\t\t{\n\t\tUnstake storage u = _unstakesByID[unstakeID];\n\n\t\trequire( u.status == UnstakeState.PENDING, \"Only PENDING unstakes can be cancelled\" );\n\t\trequire( block.timestamp < u.completionTime, \"Unstakes that have already completed cannot be cancelled\" );\n\t\trequire( msg.sender == u.wallet, \"Sender is not the original staker\" );\n\n\t\t// Update the user's share of the rewards for staked SALT\n\t\t_increaseUserShare( msg.sender, PoolUtils.STAKED_SALT, u.unstakedXSALT, false );\n\n\t\tu.status = UnstakeState.CANCELLED;\n\t\temit UnstakeCancelled(msg.sender, unstakeID);\n\t\t}\n\n\n\t// Recover claimable SALT from a completed unstake\n\tfunction recoverSALT( uint256 unstakeID ) external nonReentrant\n\t\t{\n\t\tUnstake storage u = _unstakesByID[unstakeID];\n\t\trequire( u.status == UnstakeState.PENDING, \"Only PENDING unstakes can be claimed\" );\n\t\trequire( block.timestamp >= u.completionTime, \"Unstake has not completed yet\" );\n\t\trequire( msg.sender == u.wallet, \"Sender is not the original staker\" );\n\n\t\tu.status = UnstakeState.CLAIMED;\n\n\t\t// See if the user unstaked early and received only a portion of their original stake.\n\t\t// The portion they did not receive will be considered the expeditedUnstakeFee.\n\t\tuint256 expeditedUnstakeFee = u.unstakedXSALT - u.claimableSALT;\n\n\t\t// Burn 100% of the expeditedUnstakeFee\n\t\tif ( expeditedUnstakeFee > 0 )\n\t\t\t{\n\t\t\t// Send the expeditedUnstakeFee to the SALT contract and burn it\n\t\t\tsalt.safeTransfer( address(salt), expeditedUnstakeFee );\n            salt.burnTokensInContract();\n            }\n\n\t\t// Send the reclaimed SALT back to the user\n\t\tsalt.safeTransfer( msg.sender, u.claimableSALT );\n\n\t\temit SALTRecovered(msg.sender, unstakeID, u.claimableSALT, expeditedUnstakeFee);\n\t\t}\n\n\n\t// Send xSALT from the Airdrop contract to a user\n\tfunction transferStakedSaltFromAirdropToUser(address wallet, uint256 amountToTransfer) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.airdrop()), \"Staking.transferStakedSaltFromAirdropToUser is only callable from the Airdrop contract\" );\n\n\t\t_decreaseUserShare( msg.sender, PoolUtils.STAKED_SALT, amountToTransfer, false );\n\t\t_increaseUserShare( wallet, PoolUtils.STAKED_SALT, amountToTransfer, false );\n\n\t\temit XSALTTransferredFromAirdrop(wallet, amountToTransfer);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\tfunction userXSalt( address wallet ) external view returns (uint256)\n\t\t{\n\t\treturn userShareForPool(wallet, PoolUtils.STAKED_SALT);\n\t\t}\n\n\n\t// Retrieve all pending unstakes associated with a user within a specific range.\n\tfunction unstakesForUser( address user, uint256 start, uint256 end ) public view returns (Unstake[] memory)\n\t\t{\n        // Check if start and end are within the bounds of the array\n        require(end >= start, \"Invalid range: end cannot be less than start\");\n\n        uint256[] memory userUnstakes = _userUnstakeIDs[user];\n\n        require(userUnstakes.length > end, \"Invalid range: end is out of bounds\");\n        require(start < userUnstakes.length, \"Invalid range: start is out of bounds\");\n\n        Unstake[] memory unstakes = new Unstake[](end - start + 1);\n\n        uint256 index;\n        for(uint256 i = start; i <= end; i++)\n            unstakes[index++] = _unstakesByID[ userUnstakes[i]];\n\n        return unstakes;\n    }\n\n\n\t// Retrieve all pending unstakes associated with a user.\n\tfunction unstakesForUser( address user ) external view returns (Unstake[] memory)\n\t\t{\n\t\t// Check to see how many unstakes the user has\n\t\tuint256[] memory unstakeIDs = _userUnstakeIDs[user];\n\t\tif ( unstakeIDs.length == 0 )\n\t\t\treturn new Unstake[](0);\n\n\t\t// Return them all\n\t\treturn unstakesForUser( user, 0, unstakeIDs.length - 1 );\n\t\t}\n\n\n\t// Returns the unstakeIDs for the user\n\tfunction userUnstakeIDs( address user ) external view returns (uint256[] memory)\n\t\t{\n\t\treturn _userUnstakeIDs[user];\n\t\t}\n\n\n\tfunction unstakeByID(uint256 id) external view returns (Unstake memory)\n\t\t{\n\t\treturn _unstakesByID[id];\n\t\t}\n\n\n\t// Calculate the reclaimable amount of SALT based on the amount of unstaked xSALT and unstake duration\n\t// By default, unstaking for two weeks allows 20% of the SALT to be reclaimed, while unstaking for a full year allows the full 100% to be reclaimed.\n\tfunction calculateUnstake( uint256 unstakedXSALT, uint256 numWeeks ) public view returns (uint256)\n\t\t{\n\t\tuint256 minUnstakeWeeks = stakingConfig.minUnstakeWeeks();\n        uint256 maxUnstakeWeeks = stakingConfig.maxUnstakeWeeks();\n        uint256 minUnstakePercent = stakingConfig.minUnstakePercent();\n\n\t\trequire( numWeeks >= minUnstakeWeeks, \"Unstaking duration too short\" );\n\t\trequire( numWeeks <= maxUnstakeWeeks, \"Unstaking duration too long\" );\n\n\t\tuint256 percentAboveMinimum = 100 - minUnstakePercent;\n\t\tuint256 unstakeRange = maxUnstakeWeeks - minUnstakeWeeks;\n\n\t\tuint256 numerator = unstakedXSALT * ( minUnstakePercent * unstakeRange + percentAboveMinimum * ( numWeeks - minUnstakeWeeks ) );\n    \treturn numerator / ( 100 * unstakeRange );\n\t\t}\n\t}"
    }
  ]
}