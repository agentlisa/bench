{
  "Title": "[H-01] `TimeswapPair.sol#borrow()` Improper implementation allows attacker to increase `pool.state.z` to a large value",
  "Content": "_Submitted by WatchPug_\n\nIn the current implementation, `borrow()` takes a user input value of `zIncrease`, while the actual collateral asset transferred in is calculated at L319, the state of `pool.state.z` still increased by the value of the user's input at L332.\n\nEven though a large number of `zIncrease` means that the user needs to add more collateral, the attacker can use a dust amount `xDecrease` (1 wei for example) so that the total collateral needed is rather small.\n\nPlus, the attacker can always `pay()` the dust amount of loan to get back the rather large amount of collateral added.\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338>\n\n```solidity\nfunction borrow(\n    uint256 maturity,\n    address assetTo,\n    address dueTo,\n    uint112 xDecrease,\n    uint112 yIncrease,\n    uint112 zIncrease,\n    bytes calldata data\n) external override lock returns (uint256 id, Due memory dueOut) {\n    require(block.timestamp < maturity, 'E202');\n    require(assetTo != address(0) && dueTo != address(0), 'E201');\n    require(assetTo != address(this) && dueTo != address(this), 'E204');\n    require(xDecrease > 0, 'E205');\n\n    Pool storage pool = pools[maturity];\n    require(pool.state.totalLiquidity > 0, 'E206');\n\n    BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);\n\n    dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);\n    dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);\n    dueOut.startBlock = BlockNumber.get();\n\n    Callback.borrow(collateral, dueOut.collateral, data);\n\n    id = pool.dues[dueTo].insert(dueOut);\n\n    pool.state.reserves.asset -= xDecrease;\n    pool.state.reserves.collateral += dueOut.collateral;\n    pool.state.totalDebtCreated += dueOut.debt;\n\n    pool.state.x -= xDecrease;\n    pool.state.y += yIncrease;\n    pool.state.z += zIncrease;\n\n    asset.safeTransfer(assetTo, xDecrease);\n\n    emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);\n    emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut);\n}\n```\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79>\n\n```solidity\nfunction getCollateral(\n    uint256 maturity,\n    IPair.State memory state,\n    uint112 xDecrease,\n    uint112 zIncrease\n) internal view returns (uint112 collateralIn) {\n    uint256 _collateralIn = maturity;\n    _collateralIn -= block.timestamp;\n    _collateralIn *= zIncrease;\n    _collateralIn = _collateralIn.shiftRightUp(25);\n    uint256 minimum = state.z;\n    minimum *= xDecrease;\n    uint256 denominator = state.x;\n    denominator -= xDecrease;\n    minimum = minimum.divUp(denominator);\n    _collateralIn += minimum;\n    collateralIn = _collateralIn.toUint112();\n}\n```\n\n#### Proof of Concept\n\nNear the maturity time, the attacker can do the following:\n\n1.  `borrow()` a dust amount of assets (`xDecrease` = 1 wei) and increase `pool.state.z` to an extremely large value (20x of previous `state.z` in our tests);\n2.  `pay()` the loan and get back the collateral;\n3.  `lend()` a regular amount of `state.x`, get a large amount of insurance token;\n4.  `burn()` the insurance token and get a large portion of the collateral assets from the defaulted loans.\n\n#### Recommendation\n\nConsider making `pair.borrow()` to be `onlyConvenience`, so that `zIncrease` will be a computed value (based on `xDecrease` and current state) rather than a user input value.\n\n**[Mathepreneur (Timeswap) confirmed](https://github.com/code-423n4/2022-01-timeswap-findings/issues/162)**\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-01-timeswap",
  "Code": [
    {
      "filename": "Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from './interfaces/IPair.sol';\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {MintMath} from './libraries/MintMath.sol';\nimport {BurnMath} from './libraries/BurnMath.sol';\nimport {LendMath} from './libraries/LendMath.sol';\nimport {WithdrawMath} from './libraries/WithdrawMath.sol';\nimport {BorrowMath} from './libraries/BorrowMath.sol';\nimport {PayMath} from './libraries/PayMath.sol';\nimport {SafeTransfer} from './libraries/SafeTransfer.sol';\nimport {Array} from './libraries/Array.sol';\nimport {Callback} from './libraries/Callback.sol';\nimport {BlockNumber} from './libraries/BlockNumber.sol';\n\n/// @title Timeswap Pair\n/// @author Timeswap Labs\n/// @notice It is recommnded to use Timeswap Convenience to interact with this contract.\n/// @notice All error messages are coded and can be found in the documentation.\ncontract TimeswapPair is IPair {\n    using SafeTransfer for IERC20;\n    using Array for Due[];\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc IPair\n    IFactory public immutable override factory;\n    /// @inheritdoc IPair\n    IERC20 public immutable override asset;\n    /// @inheritdoc IPair\n    IERC20 public immutable override collateral;\n    /// @inheritdoc IPair\n    uint16 public immutable override fee;\n    /// @inheritdoc IPair\n    uint16 public immutable override protocolFee;\n\n    /// @dev Stores the individual states of each Pool.\n    mapping(uint256 => Pool) private pools;\n\n    /// @dev Stores the access state for reentrancy guard.\n    uint256 private locked;\n\n    /* ===== VIEW =====*/\n\n    /// @inheritdoc IPair\n    function constantProduct(uint256 maturity)\n        external\n        view\n        override\n        returns (\n            uint112 x,\n            uint112 y,\n            uint112 z\n        )\n    {\n        State memory state = pools[maturity].state;\n        return (state.x, state.y, state.z);\n    }\n\n    /// @inheritdoc IPair\n    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {\n        return pools[maturity].state.reserves;\n    }\n\n    /// @inheritdoc IPair\n    function totalLiquidity(uint256 maturity) external view override returns (uint256) {\n        return pools[maturity].state.totalLiquidity;\n    }\n\n    /// @inheritdoc IPair\n    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].liquidities[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalClaims(uint256 maturity) external view override returns (Claims memory) {\n        return pools[maturity].state.totalClaims;\n    }\n\n    /// @inheritdoc IPair\n    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {\n        return pools[maturity].claims[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {\n        return pools[maturity].state.totalDebtCreated;\n    }\n\n    /// @inheritdoc IPair\n    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {\n        return pools[maturity].dues[owner][id];\n    }\n\n    /* ===== INIT ===== */\n\n    /// @dev Initializes the Pair contract.\n    /// @dev Called by the Timeswap factory contract.\n    /// @param _asset The address of the ERC20 being lent and borrowed.\n    /// @param _collateral The address of the ERC20 as the collateral.\n    /// @param _fee The chosen fee rate.\n    /// @param _protocolFee The chosen protocol fee rate.\n    constructor(\n        IERC20 _asset,\n        IERC20 _collateral,\n        uint16 _fee,\n        uint16 _protocolFee\n    ) {\n        factory = IFactory(msg.sender);\n        asset = _asset;\n        collateral = _collateral;\n        fee = _fee;\n        protocolFee = _protocolFee;\n    }\n\n    /* ===== MODIFIER ===== */\n\n    /// @dev The modifier for reentrancy guard.\n    modifier lock() {\n        require(locked == 0, 'E211');\n        locked = 1;\n        _;\n        locked = 0;\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc IPair\n    function mint(\n        uint256 maturity,\n        address liquidityTo,\n        address dueTo,\n        uint112 xIncrease,\n        uint112 yIncrease,\n        uint112 zIncrease,\n        bytes calldata data\n    )\n        external\n        override\n        lock\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            Due memory dueOut\n        )\n    {\n        require(block.timestamp < maturity, 'E202');\n        require(maturity - block.timestamp < 0x100000000, 'E208');\n        require(liquidityTo != address(0) && dueTo != address(0), 'E201');\n        require(liquidityTo != address(this) && dueTo != address(this), 'E204');\n        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205');\n        \n        Pool storage pool = pools[maturity];\n\n        if (pool.state.totalLiquidity == 0) {\n            uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);\n            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);\n\n            pool.state.totalLiquidity += liquidityTotal;\n            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;\n        } else {\n            uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);\n            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);\n\n            pool.state.totalLiquidity += liquidityTotal;\n            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;\n        }\n        require(liquidityOut > 0, 'E212');\n        pool.liquidities[liquidityTo] += liquidityOut;\n\n        dueOut.debt = MintMath.getDebt(maturity, xIncrease, yIncrease);\n        dueOut.collateral = MintMath.getCollateral(maturity, zIncrease);\n        dueOut.startBlock = BlockNumber.get();\n\n        Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data);\n\n        id = pool.dues[dueTo].insert(dueOut);\n\n        pool.state.reserves.asset += xIncrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x += xIncrease;\n        pool.state.y += yIncrease;\n        pool.state.z += zIncrease;\n\n        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Mint(maturity, msg.sender, liquidityTo, dueTo, xIncrease, liquidityOut, id, dueOut);\n    }\n\n    /// @inheritdoc IPair\n    function burn(\n        uint256 maturity,\n        address assetTo,\n        address collateralTo,\n        uint256 liquidityIn\n    ) external override lock returns (Tokens memory tokensOut) {\n        require(block.timestamp >= maturity, 'E203');\n        require(assetTo != address(0) && collateralTo != address(0), 'E201');\n        require(assetTo != address(this) && collateralTo != address(this), 'E204');\n        require(liquidityIn > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n\n        tokensOut.asset = BurnMath.getAsset(pool.state, liquidityIn);\n        tokensOut.collateral = BurnMath.getCollateral(pool.state, liquidityIn);\n\n        pool.state.totalLiquidity -= liquidityIn;\n\n        pool.liquidities[msg.sender] -= liquidityIn;\n\n        pool.state.reserves.asset -= tokensOut.asset;\n        pool.state.reserves.collateral -= tokensOut.collateral;\n\n        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);\n        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);\n\n        emit Burn(maturity, msg.sender, assetTo, collateralTo, liquidityIn, tokensOut);\n    }\n\n    /// @inheritdoc IPair\n    function lend(\n        uint256 maturity,\n        address bondTo,\n        address insuranceTo,\n        uint112 xIncrease,\n        uint112 yDecrease,\n        uint112 zDecrease,\n        bytes calldata data\n    ) external override lock returns (Claims memory claimsOut) {\n        require(block.timestamp < maturity, 'E202');\n        require(bondTo != address(0) && insuranceTo != address(0), 'E201');\n        require(bondTo != address(this) && insuranceTo != address(this), 'E204');\n        require(xIncrease > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n        require(pool.state.totalLiquidity > 0, 'E206');\n\n        LendMath.check(pool.state, xIncrease, yDecrease, zDecrease, fee);\n\n        claimsOut.bond = LendMath.getBond(maturity, xIncrease, yDecrease);\n        claimsOut.insurance = LendMath.getInsurance(maturity, pool.state, xIncrease, zDecrease);\n\n        Callback.lend(asset, xIncrease, data);\n\n        pool.state.totalClaims.bond += claimsOut.bond;\n        pool.state.totalClaims.insurance += claimsOut.insurance;\n\n        pool.claims[bondTo].bond += claimsOut.bond;\n        pool.claims[insuranceTo].insurance += claimsOut.insurance;\n\n        pool.state.reserves.asset += xIncrease;\n\n        pool.state.x += xIncrease;\n        pool.state.y -= yDecrease;\n        pool.state.z -= zDecrease;\n\n        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Lend(maturity, msg.sender, bondTo, insuranceTo, xIncrease, claimsOut);\n    }\n\n    /// @inheritdoc IPair\n    function withdraw(\n        uint256 maturity,\n        address assetTo,\n        address collateralTo,\n        Claims memory claimsIn\n    ) external override lock returns (Tokens memory tokensOut) {\n        require(block.timestamp >= maturity, 'E203');\n        require(assetTo != address(0) && collateralTo != address(0), 'E201');\n        require(assetTo != address(this) && collateralTo != address(this), 'E204');\n        require(claimsIn.bond > 0 || claimsIn.insurance > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n\n        tokensOut.asset = WithdrawMath.getAsset(pool.state, claimsIn.bond);\n        tokensOut.collateral = WithdrawMath.getCollateral(pool.state, claimsIn.insurance);\n\n        pool.state.totalClaims.bond -= claimsIn.bond;\n        pool.state.totalClaims.insurance -= claimsIn.insurance;\n\n        Claims storage sender = pool.claims[msg.sender];\n\n        sender.bond -= claimsIn.bond;\n        sender.insurance -= claimsIn.insurance;\n\n        pool.state.reserves.asset -= tokensOut.asset;\n        pool.state.reserves.collateral -= tokensOut.collateral;\n\n        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);\n        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);\n\n        emit Withdraw(maturity, msg.sender, assetTo, collateralTo, claimsIn, tokensOut);\n    }\n\n    /// @inheritdoc IPair\n    function borrow(\n        uint256 maturity,\n        address assetTo,\n        address dueTo,\n        uint112 xDecrease,\n        uint112 yIncrease,\n        uint112 zIncrease,\n        bytes calldata data\n    ) external override lock returns (uint256 id, Due memory dueOut) {\n        require(block.timestamp < maturity, 'E202');\n        require(assetTo != address(0) && dueTo != address(0), 'E201');\n        require(assetTo != address(this) && dueTo != address(this), 'E204');\n        require(xDecrease > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n        require(pool.state.totalLiquidity > 0, 'E206');\n\n        BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);\n\n        dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);\n        dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);\n        dueOut.startBlock = BlockNumber.get();\n\n        Callback.borrow(collateral, dueOut.collateral, data);\n\n        id = pool.dues[dueTo].insert(dueOut);\n\n        pool.state.reserves.asset -= xDecrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x -= xDecrease;\n        pool.state.y += yIncrease;\n        pool.state.z += zIncrease;\n\n        asset.safeTransfer(assetTo, xDecrease);\n\n        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut);\n    }\n\n    /// @inheritdoc IPair\n    function pay(\n        uint256 maturity,\n        address to,\n        address owner,\n        uint256[] memory ids,\n        uint112[] memory assetsIn,\n        uint112[] memory collateralsOut,\n        bytes calldata data\n    ) external override lock returns (uint128 assetIn, uint128 collateralOut) {\n        require(block.timestamp < maturity, 'E202');\n        require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');\n        require(to != address(0), 'E201');\n        require(to != address(this), 'E204');\n\n        Pool storage pool = pools[maturity];\n\n        Due[] storage dues = pool.dues[owner];\n\n        for (uint256 i; i < ids.length; i++) {\n            Due storage due = dues[ids[i]];\n            require(due.startBlock != BlockNumber.get(), 'E207');\n            if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');\n            PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);\n            due.debt -= assetsIn[i];\n            due.collateral -= collateralsOut[i];\n            assetIn += assetsIn[i];\n            collateralOut += collateralsOut[i];\n        }\n        if (assetIn > 0) Callback.pay(asset, assetIn, data);\n\n        pool.state.reserves.asset += assetIn;\n        pool.state.reserves.collateral -= collateralOut;\n\n        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut);\n\n        emit Pay(maturity, msg.sender, to, owner, ids, assetsIn, collateralsOut, assetIn, collateralOut);\n    }\n}"
    },
    {
      "filename": "Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from '../interfaces/IPair.sol';\nimport {Math} from './Math.sol';\nimport {FullMath} from './FullMath.sol';\nimport {ConstantProduct} from './ConstantProduct.sol';\nimport {SafeCast} from './SafeCast.sol';\n\n\nlibrary BorrowMath {\n    using Math for uint256;\n    using FullMath for uint256;\n    using ConstantProduct for IPair.State;\n    using SafeCast for uint256;\n\n    function check(\n        IPair.State memory state,\n        uint112 xDecrease,\n        uint112 yIncrease,\n        uint112 zIncrease,\n        uint16 fee\n    ) internal pure {\n        uint128 feeBase = 0x10000 - fee;\n        uint112 xReserve = state.x - xDecrease;\n        uint128 yAdjusted = adjust(state.y, yIncrease, feeBase);\n        uint128 zAdjusted = adjust(state.z, zIncrease, feeBase);\n        state.checkConstantProduct(xReserve, yAdjusted, zAdjusted);\n\n        uint256 minimum = xDecrease;\n        minimum *= state.y;\n        minimum <<= 12;\n        uint256 denominator = xReserve;\n        denominator *= feeBase;\n        minimum = minimum.divUp(denominator);\n        require(yIncrease >= minimum, 'E302');\n    }\n\n    function adjust(\n        uint112 reserve,\n        uint112 increase,\n        uint128 feeBase\n    ) private pure returns (uint128 adjusted) {\n        adjusted = reserve;\n        adjusted <<= 16;\n        adjusted += feeBase * increase;\n    }\n\n    function getDebt(\n        uint256 maturity,\n        uint112 xDecrease,\n        uint112 yIncrease\n    ) internal view returns (uint112 debtIn) {\n        uint256 _debtIn = maturity;\n        _debtIn -= block.timestamp;\n        _debtIn *= yIncrease;\n        _debtIn = _debtIn.shiftRightUp(32);\n        _debtIn += xDecrease;\n        debtIn = _debtIn.toUint112();\n    }\n\n    function getCollateral(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xDecrease,\n        uint112 zIncrease\n    ) internal view returns (uint112 collateralIn) {\n        uint256 _collateralIn = maturity;\n        _collateralIn -= block.timestamp;\n        _collateralIn *= zIncrease;\n        _collateralIn = _collateralIn.shiftRightUp(25);\n        uint256 minimum = state.z;\n        minimum *= xDecrease;\n        uint256 denominator = state.x;\n        denominator -= xDecrease;\n        minimum = minimum.divUp(denominator);\n        _collateralIn += minimum;\n        collateralIn = _collateralIn.toUint112();\n    }\n}"
    }
  ]
}