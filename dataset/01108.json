{
  "Title": "H-4: No slippage protection during repayment due to dynamic slippage params and easily influenced `slot0()`",
  "Content": "# Issue H-4: No slippage protection during repayment due to dynamic slippage params and easily influenced `slot0()` \n\nSource: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/109 \n\n## Found by \n0x52, 0xJuda, 0xMaroutis, 0xblackskull, HHK, IceBear, Kral01, MohammedRizwan, Nyx, kaysoft, lil.eth, lucifero, p-tsanev, peanuts, pks\\_, talfao, tsvetanovv\nThe repayment function lacks slippage protection. It relies on slot0() to calculate sqrtLimitPrice, which in turn determines amounts for restoring liquidation. The dynamic calculation of slippage parameters based on these values leaves the function without adequate slippage protection, potentially reducing profit for the repayer.\n\n## Vulnerability Detail\nThe absence of slippage protection can be attributed to two key reasons. Firstly, the `sqrtPrice` is derived from `slot0()`, **which can be easily manipulated:**\n```Solidity\n     function _getCurrentSqrtPriceX96(\n        bool zeroForA,\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) private view returns (uint160 sqrtPriceX96) {\n        if (!zeroForA) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n        address poolAddress = computePoolAddress(tokenA, tokenB, fee);\n        (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(poolAddress).slot0(); //@audit-issue can be easily manipulated\n    }\n```\nThe calculated `sqrtPriceX96` is used to determine the amounts for restoring liquidation and the number of holdTokens to be swapped for saleTokens:\n```Solidity\n(uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) = _getHoldTokenAmountIn(\n                params.zeroForSaleToken,\n                cache.tickLower,\n                cache.tickUpper,\n                cache.sqrtPriceX96,\n                loan.liquidity,\n                cache.holdTokenDebt\n            );\n``` \nAfter that, the number of `SaleTokemAmountOut` is gained based on the sqrtPrice via QuoterV2.\n\nThen, the slippage params are calculated \n`amountOutMinimum: (saleTokenAmountOut * params.slippageBP1000) /\n                                Constants.BPS\n                        })`\nHowever, the `saleTokenAmountOut` is a dynamic number calculated on the current state of the blockchain, based on the calculations mentioned above. This will lead to the situation that the swap will always satisfy the `amountOutMinimum`.\n\nAs a result, if the repayment of the user is sandwiched (frontrunned), the profit of the repayer is decreased till the repayment satisfies the restored liquidity.\n\n### Proof of concept\nA Proof of Concept (PoC) demonstrates the issue with comments. Although the swap does not significantly impact a strongly founded pool, it does result in a loss of a few dollars for the repayer.\n\n```Javascript\n       let amountWBTC = ethers.utils.parseUnits(\"0.05\", 8); //token0\n        const deadline = (await time.latest()) + 60;\n        const minLeverageDesired = 50;\n        const maxCollateralWBTC = amountWBTC.div(minLeverageDesired);\n\n        const loans = [\n            {\n                liquidity: nftpos[3].liquidity,\n                tokenId: nftpos[3].tokenId,\n            },\n        ];\n\n        const swapParams: ApproveSwapAndPay.SwapParamsStruct = {\n            swapTarget: constants.AddressZero,\n            swapAmountInDataIndex: 0,\n            maxGasForCall: 0,\n            swapData: swapData,\n        };\n\nlet  params = {\n            internalSwapPoolfee: 500,\n            saleToken: WETH_ADDRESS,\n            holdToken: WBTC_ADDRESS,\n            minHoldTokenOut: amountWBTC,\n            maxCollateral: maxCollateralWBTC,\n            externalSwap: swapParams,\n            loans: loans,\n        };\n\nawait borrowingManager.connect(bob).borrow(params, deadline);\n\nconst borrowingKey = await borrowingManager.userBorrowingKeys(bob.address, 0);\n        const swapParamsRep: ApproveSwapAndPay.SwapParamsStruct = {\n            swapTarget: constants.AddressZero,\n            swapAmountInDataIndex: 0,\n            maxGasForCall: 0,\n            swapData: swapData,\n        };\n\n       \n        amountWBTC = ethers.utils.parseUnits(\"0.06\", 8); //token0\n\nlet swapping: ISwapRouter.ExactInputSingleParamsStruct = {\n            tokenIn: WBTC_ADDRESS,\n            tokenOut: WETH_ADDRESS,\n            fee: 500,\n            recipient: alice.address,\n            deadline: deadline,\n            amountIn: ethers.utils.parseUnits(\"100\", 8),\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        };\n        await router.connect(alice).exactInputSingle(swapping);\n        console.log(\"Swap success\");\n\n let paramsRep: LiquidityBorrowingManager.RepayParamsStruct = {\n            isEmergency: false,\n            internalSwapPoolfee: 500,\n            externalSwap: swapParamsRep,\n            borrowingKey: borrowingKey,\n            swapSlippageBP1000: 990, //<=slippage simulated\n        };\n await borrowingManager.connect(bob).repay(paramsRep, deadline);\n        // Without swap\n// Balance of hold token after repay:  BigNumber { value: \"993951415\" }\n// Balance of sale token after repay:  BigNumber { value: \"99005137946252426108\" }\n// When swap\n// Balance of hold token after repay:  BigNumber { value: \"993951415\" }\n// Balance of sale token after repay:  BigNumber { value: \"99000233164653177505\" }\n```\n\nThe following table shows difference of recieved sale token:\n| Swap before repay transaction | Token |  Balance of user after Repay |\n|---------------------------|---------------------|----------------------|\n| No                        | WETH  | 99005137946252426108 |\n| Yes                       | WETH  |99000233164653177505 |\n\nThe difference in the profit after repayment is 4904781599248603 weis, which is at the current market price of around 8 USD. The profit loss will depend on the liquidity in the pool, which depends on the type of pool and related tokens.\n\n## Impact\nThe absence of slippage protection results in potential profit loss for the repayer.\n\n## Code Snippet\n[Slot0 is used here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/abstract/LiquidityManager.sol#L341)\n[Dynamic slippage params are created here](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/abstract/LiquidityManager.sol#L265) - saleTokenAmount is dynamic variable calculated on the state of blockchain.\n\n## Tool used\n\nManual Review\n\n## Recommendation\nTo address this issue, avoid relying on slot0 and instead utilize Uniswap TWAP. Additionally, consider manually setting values for amountOutMin for swaps based on data acquired before repayment.\n\n\n\n## Discussion\n\n**fann95**\n\nI think the severity level is medium since exchange within the pool is not the only way, there is also an external swap.\n\n**fann95**\n\nFixed: https://github.com/RealWagmi/wagmi-leverage/commit/bf84623009654acee8ee26ba2805068d2806e745\n\n**Czar102**\n\n> I think the severity level is medium since exchange within the pool is not the only way, there is also an external swap.\n\nEven though it concerns only a subset of the functionalities of the protocol, the impact seems to be of high severity. Please let me know if that's not the case.\n\n**fann95**\n\n> > I think the severity level is medium since exchange within the pool is not the only way, there is also an external swap.\n> \n> Even though it concerns only a subset of the functionalities of the protocol, the impact seems to be of high severity. Please let me know if that's not the case.\n\nI leave the decision up to you.\n\n**Czar102**\n\nI'll leave it high severity because of the reason mentioned above.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/118",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/abstract/LiquidityManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\nimport \"../vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport \"../vendor0.8/uniswap/TickMath.sol\";\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"../interfaces/IQuoterV2.sol\";\nimport \"./ApproveSwapAndPay.sol\";\nimport \"../Vault.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\nabstract contract LiquidityManager is ApproveSwapAndPay {\n    /**\n     * @notice Represents information about a loan.\n     * @dev This struct is used to store liquidity and tokenId for a loan.\n     * @param liquidity The amount of liquidity for the loan represented by a uint128 value.\n     * @param tokenId The token ID associated with the loan represented by a uint256 value.\n     */\n    struct LoanInfo {\n        uint128 liquidity;\n        uint256 tokenId;\n    }\n    /**\n     * @notice Contains parameters for restoring liquidity.\n     * @dev This struct is used to store various parameters required for restoring liquidity.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param fee The fee associated with the internal swap pool is represented by a uint24 value.\n     * @param slippageBP1000 The slippage in basis points (BP) represented by a uint256 value.\n     * @param totalfeesOwed The total fees owed represented by a uint256 value.\n     * @param totalBorrowedAmount The total borrowed amount represented by a uint256 value.\n     */\n    struct RestoreLiquidityParams {\n        bool zeroForSaleToken;\n        uint24 fee;\n        uint256 slippageBP1000;\n        uint256 totalfeesOwed;\n        uint256 totalBorrowedAmount;\n    }\n    /**\n     * @notice Contains cache data for restoring liquidity.\n     * @dev This struct is used to store cached values required for restoring liquidity.\n     * @param tickLower The lower tick boundary represented by an int24 value.\n     * @param tickUpper The upper tick boundary represented by an int24 value.\n     * @param fee The fee associated with the restoring liquidity pool.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @param sqrtPriceX96 The square root of the price represented by a uint160 value.\n     * @param holdTokenDebt The debt amount associated with the hold token represented by a uint256 value.\n     */\n    struct RestoreLiquidityCache {\n        int24 tickLower;\n        int24 tickUpper;\n        uint24 fee;\n        address saleToken;\n        address holdToken;\n        uint160 sqrtPriceX96;\n        uint256 holdTokenDebt;\n    }\n    /**\n     * @notice The address of the vault contract.\n     */\n    address public immutable VAULT_ADDRESS;\n    /**\n     * @notice The Nonfungible Position Manager contract.\n     */\n    INonfungiblePositionManager public immutable underlyingPositionManager;\n    /**\n     * @notice The QuoterV2 contract.\n     */\n    IQuoterV2 public immutable underlyingQuoterV2;\n\n    /**\n     * @dev Contract constructor.\n     * @param _underlyingPositionManagerAddress Address of the underlying position manager contract.\n     * @param _underlyingQuoterV2 Address of the underlying quoterV2 contract.\n     * @param _underlyingV3Factory Address of the underlying V3 factory contract.\n     * @param _underlyingV3PoolInitCodeHash The init code hash of the underlying V3 pool.\n     */\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    ) ApproveSwapAndPay(_underlyingV3Factory, _underlyingV3PoolInitCodeHash) {\n        // Assign the underlying position manager contract address\n        underlyingPositionManager = INonfungiblePositionManager(_underlyingPositionManagerAddress);\n        // Assign the underlying quoterV2 contract address\n        underlyingQuoterV2 = IQuoterV2(_underlyingQuoterV2);\n        // Generate a unique salt for the new Vault contract\n        bytes32 salt = keccak256(abi.encode(block.timestamp, address(this)));\n        // Deploy a new Vault contract using the generated salt and assign its address to VAULT_ADDRESS\n        VAULT_ADDRESS = address(new Vault{ salt: salt }());\n    }\n\n    error InvalidBorrowedLiquidity(uint256 tokenId);\n    error TooLittleBorrowedLiquidity(uint128 liquidity);\n    error InvalidTokens(uint256 tokenId);\n    error NotApproved(uint256 tokenId);\n    error InvalidRestoredLiquidity(\n        uint256 tokenId,\n        uint128 borrowedLiquidity,\n        uint128 restoredLiquidity,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 holdTokentBalance,\n        uint256 saleTokenBalance\n    );\n\n    /**\n     * @dev Calculates the borrowed amount from a pool's single side position, rounding up if necessary.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param tickLower The lower tick value of the position range.\n     * @param tickUpper The upper tick value of the position range.\n     * @param liquidity The liquidity of the position.\n     * @return borrowedAmount The calculated borrowed amount.\n     */\n    function _getSingleSideRoundUpBorrowedAmount(\n        bool zeroForSaleToken,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) private pure returns (uint256 borrowedAmount) {\n        borrowedAmount = (\n            zeroForSaleToken\n                ? LiquidityAmounts.getAmount1ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n                : LiquidityAmounts.getAmount0ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n        );\n        if (borrowedAmount > Constants.MINIMUM_BORROWED_AMOUNT) {\n            ++borrowedAmount;\n        } else {\n            revert TooLittleBorrowedLiquidity(liquidity);\n        }\n    }\n\n    /**\n     * @dev Extracts liquidity from loans and returns the borrowed amount.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param token0 The address of one of the tokens in the pair.\n     * @param token1 The address of the other token in the pair.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     * @return borrowedAmount The total amount borrowed.\n     */\n    function _extractLiquidity(\n        bool zeroForSaleToken,\n        address token0,\n        address token1,\n        LoanInfo[] memory loans\n    ) internal returns (uint256 borrowedAmount) {\n        if (!zeroForSaleToken) {\n            (token0, token1) = (token1, token0);\n        }\n\n        for (uint256 i; i < loans.length; ) {\n            uint256 tokenId = loans[i].tokenId;\n            uint128 liquidity = loans[i].liquidity;\n            // Extract position-related details\n            {\n                int24 tickLower;\n                int24 tickUpper;\n                uint128 posLiquidity;\n                {\n                    address operator;\n                    address posToken0;\n                    address posToken1;\n\n                    (\n                        ,\n                        operator,\n                        posToken0,\n                        posToken1,\n                        ,\n                        tickLower,\n                        tickUpper,\n                        posLiquidity,\n                        ,\n                        ,\n                        ,\n\n                    ) = underlyingPositionManager.positions(tokenId);\n                    // Check operator approval\n                    if (operator != address(this)) {\n                        revert NotApproved(tokenId);\n                    }\n                    // Check token validity\n                    if (posToken0 != token0 || posToken1 != token1) {\n                        revert InvalidTokens(tokenId);\n                    }\n                }\n                // Check borrowed liquidity validity\n                if (!(liquidity > 0 && liquidity <= posLiquidity)) {\n                    revert InvalidBorrowedLiquidity(tokenId);\n                }\n                // Calculate borrowed amount\n                borrowedAmount += _getSingleSideRoundUpBorrowedAmount(\n                    zeroForSaleToken,\n                    tickLower,\n                    tickUpper,\n                    liquidity\n                );\n            }\n            // Decrease liquidity and move to the next loan\n            _decreaseLiquidity(tokenId, liquidity);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Restores liquidity from loans.\n     * @param params The RestoreLiquidityParams struct containing restoration parameters.\n     * @param externalSwap The SwapParams struct containing external swap details.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     */\n    function _restoreLiquidity(\n        // Create a cache struct to store temporary data\n        RestoreLiquidityParams memory params,\n        SwapParams calldata externalSwap,\n        LoanInfo[] memory loans\n    ) internal {\n        RestoreLiquidityCache memory cache;\n        for (uint256 i; i < loans.length; ) {\n            // Update the cache for the current loan\n            LoanInfo memory loan = loans[i];\n            _upRestoreLiquidityCache(params.zeroForSaleToken, loan, cache);\n            // Calculate the hold token amount to be used for swapping\n            (uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) = _getHoldTokenAmountIn(\n                params.zeroForSaleToken,\n                cache.tickLower,\n                cache.tickUpper,\n                cache.sqrtPriceX96,\n                loan.liquidity,\n                cache.holdTokenDebt\n            );\n\n            if (holdTokenAmountIn > 0) {\n                // Quote exact input single for swap\n                uint256 saleTokenAmountOut;\n                (saleTokenAmountOut, cache.sqrtPriceX96, , ) = underlyingQuoterV2\n                    .quoteExactInputSingle(\n                        IQuoterV2.QuoteExactInputSingleParams({\n                            tokenIn: cache.holdToken,\n                            tokenOut: cache.saleToken,\n                            amountIn: holdTokenAmountIn,\n                            fee: params.fee,\n                            sqrtPriceLimitX96: 0\n                        })\n                    );\n\n                // Perform external swap if external swap target is provided\n                if (externalSwap.swapTarget != address(0)) {\n                    _patchAmountsAndCallSwap(\n                        cache.holdToken,\n                        cache.saleToken,\n                        externalSwap,\n                        holdTokenAmountIn,\n                        (saleTokenAmountOut * params.slippageBP1000) / Constants.BPS\n                    );\n                } else {\n                    // Calculate hold token amount in again for new sqrtPriceX96\n                    (holdTokenAmountIn, , ) = _getHoldTokenAmountIn(\n                        params.zeroForSaleToken,\n                        cache.tickLower,\n                        cache.tickUpper,\n                        cache.sqrtPriceX96,\n                        loan.liquidity,\n                        cache.holdTokenDebt\n                    );\n\n                    // Perform v3 swap exact input and update sqrtPriceX96\n                    _v3SwapExactInput(\n                        v3SwapExactInputParams({\n                            fee: params.fee,\n                            tokenIn: cache.holdToken,\n                            tokenOut: cache.saleToken,\n                            amountIn: holdTokenAmountIn,\n                            amountOutMinimum: (saleTokenAmountOut * params.slippageBP1000) /\n                                Constants.BPS\n                        })\n                    );\n                    // Update the value of sqrtPriceX96 in the cache using the _getCurrentSqrtPriceX96 function\n                    cache.sqrtPriceX96 = _getCurrentSqrtPriceX96(\n                        params.zeroForSaleToken,\n                        cache.saleToken,\n                        cache.holdToken,\n                        cache.fee\n                    );\n                    // Calculate the amounts of token0 and token1 for a given liquidity\n                    (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n                        cache.sqrtPriceX96,\n                        TickMath.getSqrtRatioAtTick(cache.tickLower),\n                        TickMath.getSqrtRatioAtTick(cache.tickUpper),\n                        loan.liquidity\n                    );\n                }\n            }\n            // Get the owner of the Nonfungible Position Manager token by its tokenId\n            address creditor = underlyingPositionManager.ownerOf(loan.tokenId);\n            // Increase liquidity and transfer liquidity owner reward\n            _increaseLiquidity(cache.saleToken, cache.holdToken, loan, amount0, amount1);\n            uint256 liquidityOwnerReward = FullMath.mulDiv(\n                params.totalfeesOwed,\n                cache.holdTokenDebt,\n                params.totalBorrowedAmount\n            ) / Constants.COLLATERAL_BALANCE_PRECISION;\n\n            Vault(VAULT_ADDRESS).transferToken(cache.holdToken, creditor, liquidityOwnerReward);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Retrieves the current square root price in X96 representation.\n     * @param zeroForA Flag indicating whether to treat the tokenA as the 0th token or not.\n     * @param tokenA The address of token A.\n     * @param tokenB The address of token B.\n     * @param fee The fee associated with the Uniswap V3 pool.\n     * @return sqrtPriceX96 The current square root price in X96 representation.\n     */\n    function _getCurrentSqrtPriceX96(\n        bool zeroForA,\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) private view returns (uint160 sqrtPriceX96) {\n        if (!zeroForA) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n        address poolAddress = computePoolAddress(tokenA, tokenB, fee);\n        (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(poolAddress).slot0();\n    }\n\n    /**\n     * @dev Decreases the liquidity of a position by removing tokens.\n     * @param tokenId The ID of the position token.\n     * @param liquidity The amount of liquidity to be removed.\n     */\n    function _decreaseLiquidity(uint256 tokenId, uint128 liquidity) private {\n        // Call the decreaseLiquidity function of underlyingPositionManager contract\n        // with DecreaseLiquidityParams struct as argument\n        (uint256 amount0, uint256 amount1) = underlyingPositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        // Check if both amount0 and amount1 are zero after decreasing liquidity\n        // If true, revert with InvalidBorrowedLiquidity exception\n        if (amount0 == 0 && amount1 == 0) {\n            revert InvalidBorrowedLiquidity(tokenId);\n        }\n        // Call the collect function of underlyingPositionManager contract\n        // with CollectParams struct as argument\n        (amount0, amount1) = underlyingPositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: address(this),\n                amount0Max: uint128(amount0),\n                amount1Max: uint128(amount1)\n            })\n        );\n    }\n\n    /**\n     * @dev Increases the liquidity of a position by providing additional tokens.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param loan An instance of LoanInfo memory struct containing loan details.\n     * @param amount0 The amount of token0 to be added to the liquidity.\n     * @param amount1 The amount of token1 to be added to the liquidity.\n     */\n    function _increaseLiquidity(\n        address saleToken,\n        address holdToken,\n        LoanInfo memory loan,\n        uint256 amount0,\n        uint256 amount1\n    ) private {\n        // increase if not equal to zero to avoid rounding down the amount of restored liquidity.\n        if (amount0 > 0) ++amount0;\n        if (amount1 > 0) ++amount1;\n        // Call the increaseLiquidity function of underlyingPositionManager contract\n        // with IncreaseLiquidityParams struct as argument\n        (uint128 restoredLiquidity, , ) = underlyingPositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: loan.tokenId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        // Check if the restored liquidity is less than the loan liquidity amount\n        // If true, revert with InvalidRestoredLiquidity exception\n        if (restoredLiquidity < loan.liquidity) {\n            // Get the balance of holdToken and saleToken\n            (uint256 holdTokentBalance, uint256 saleTokenBalance) = _getPairBalance(\n                holdToken,\n                saleToken\n            );\n\n            revert InvalidRestoredLiquidity(\n                loan.tokenId,\n                loan.liquidity,\n                restoredLiquidity,\n                amount0,\n                amount1,\n                holdTokentBalance,\n                saleTokenBalance\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of hold token required for a swap.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param tickLower The lower tick of the liquidity range.\n     * @param tickUpper The upper tick of the liquidity range.\n     * @param sqrtPriceX96 The square root of the price ratio of the sale token to the hold token.\n     * @param liquidity The amount of liquidity.\n     * @param holdTokenDebt The amount of hold token debt.\n     * @return holdTokenAmountIn The amount of hold token needed to provide the specified liquidity.\n     * @return amount0 The amount of token0 calculated based on the liquidity.\n     * @return amount1 The amount of token1 calculated based on the liquidity.\n     */\n    function _getHoldTokenAmountIn(\n        bool zeroForSaleToken,\n        int24 tickLower,\n        int24 tickUpper,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        uint256 holdTokenDebt\n    ) private pure returns (uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) {\n        // Call getAmountsForLiquidity function from LiquidityAmounts library\n        // to get the amounts of token0 and token1 for a given liquidity position\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            TickMath.getSqrtRatioAtTick(tickLower),\n            TickMath.getSqrtRatioAtTick(tickUpper),\n            liquidity\n        );\n        // Calculate the holdTokenAmountIn based on the zeroForSaleToken flag\n        if (zeroForSaleToken) {\n            // If zeroForSaleToken is true, check if amount0 is zero\n            // If true, holdTokenAmountIn will be zero. Otherwise, it will be holdTokenDebt - amount1\n            holdTokenAmountIn = amount0 == 0 ? 0 : holdTokenDebt - amount1;\n        } else {\n            // If zeroForSaleToken is false, check if amount1 is zero\n            // If true, holdTokenAmountIn will be zero. Otherwise, it will be holdTokenDebt - amount0\n            holdTokenAmountIn = amount1 == 0 ? 0 : holdTokenDebt - amount0;\n        }\n    }\n\n    /**\n     * @dev Updates the RestoreLiquidityCache struct with data from the underlyingPositionManager contract.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param loan The LoanInfo struct containing loan details.\n     * @param cache The RestoreLiquidityCache struct to be updated.\n     */\n    function _upRestoreLiquidityCache(\n        bool zeroForSaleToken,\n        LoanInfo memory loan,\n        RestoreLiquidityCache memory cache\n    ) internal view {\n        // Get the positions data from `PositionManager` and store it in the cache variables\n        (\n            ,\n            ,\n            cache.saleToken,\n            cache.holdToken,\n            cache.fee,\n            cache.tickLower,\n            cache.tickUpper,\n            ,\n            ,\n            ,\n            ,\n\n        ) = underlyingPositionManager.positions(loan.tokenId);\n        // Swap saleToken and holdToken if zeroForSaleToken is false\n        if (!zeroForSaleToken) {\n            (cache.saleToken, cache.holdToken) = (cache.holdToken, cache.saleToken);\n        }\n        // Calculate the holdTokenDebt using\n        cache.holdTokenDebt = _getSingleSideRoundUpBorrowedAmount(\n            zeroForSaleToken,\n            cache.tickLower,\n            cache.tickUpper,\n            loan.liquidity\n        );\n        // Calculate the square root price using `_getCurrentSqrtPriceX96` function\n        cache.sqrtPriceX96 = _getCurrentSqrtPriceX96(\n            zeroForSaleToken,\n            cache.saleToken,\n            cache.holdToken,\n            cache.fee\n        );\n    }\n}"
    },
    {
      "filename": "wagmi-leverage/contracts/abstract/LiquidityManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\nimport \"../vendor0.8/uniswap/LiquidityAmounts.sol\";\nimport \"../vendor0.8/uniswap/TickMath.sol\";\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"../interfaces/IQuoterV2.sol\";\nimport \"./ApproveSwapAndPay.sol\";\nimport \"../Vault.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\nabstract contract LiquidityManager is ApproveSwapAndPay {\n    /**\n     * @notice Represents information about a loan.\n     * @dev This struct is used to store liquidity and tokenId for a loan.\n     * @param liquidity The amount of liquidity for the loan represented by a uint128 value.\n     * @param tokenId The token ID associated with the loan represented by a uint256 value.\n     */\n    struct LoanInfo {\n        uint128 liquidity;\n        uint256 tokenId;\n    }\n    /**\n     * @notice Contains parameters for restoring liquidity.\n     * @dev This struct is used to store various parameters required for restoring liquidity.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param fee The fee associated with the internal swap pool is represented by a uint24 value.\n     * @param slippageBP1000 The slippage in basis points (BP) represented by a uint256 value.\n     * @param totalfeesOwed The total fees owed represented by a uint256 value.\n     * @param totalBorrowedAmount The total borrowed amount represented by a uint256 value.\n     */\n    struct RestoreLiquidityParams {\n        bool zeroForSaleToken;\n        uint24 fee;\n        uint256 slippageBP1000;\n        uint256 totalfeesOwed;\n        uint256 totalBorrowedAmount;\n    }\n    /**\n     * @notice Contains cache data for restoring liquidity.\n     * @dev This struct is used to store cached values required for restoring liquidity.\n     * @param tickLower The lower tick boundary represented by an int24 value.\n     * @param tickUpper The upper tick boundary represented by an int24 value.\n     * @param fee The fee associated with the restoring liquidity pool.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @param sqrtPriceX96 The square root of the price represented by a uint160 value.\n     * @param holdTokenDebt The debt amount associated with the hold token represented by a uint256 value.\n     */\n    struct RestoreLiquidityCache {\n        int24 tickLower;\n        int24 tickUpper;\n        uint24 fee;\n        address saleToken;\n        address holdToken;\n        uint160 sqrtPriceX96;\n        uint256 holdTokenDebt;\n    }\n    /**\n     * @notice The address of the vault contract.\n     */\n    address public immutable VAULT_ADDRESS;\n    /**\n     * @notice The Nonfungible Position Manager contract.\n     */\n    INonfungiblePositionManager public immutable underlyingPositionManager;\n    /**\n     * @notice The QuoterV2 contract.\n     */\n    IQuoterV2 public immutable underlyingQuoterV2;\n\n    /**\n     * @dev Contract constructor.\n     * @param _underlyingPositionManagerAddress Address of the underlying position manager contract.\n     * @param _underlyingQuoterV2 Address of the underlying quoterV2 contract.\n     * @param _underlyingV3Factory Address of the underlying V3 factory contract.\n     * @param _underlyingV3PoolInitCodeHash The init code hash of the underlying V3 pool.\n     */\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    ) ApproveSwapAndPay(_underlyingV3Factory, _underlyingV3PoolInitCodeHash) {\n        // Assign the underlying position manager contract address\n        underlyingPositionManager = INonfungiblePositionManager(_underlyingPositionManagerAddress);\n        // Assign the underlying quoterV2 contract address\n        underlyingQuoterV2 = IQuoterV2(_underlyingQuoterV2);\n        // Generate a unique salt for the new Vault contract\n        bytes32 salt = keccak256(abi.encode(block.timestamp, address(this)));\n        // Deploy a new Vault contract using the generated salt and assign its address to VAULT_ADDRESS\n        VAULT_ADDRESS = address(new Vault{ salt: salt }());\n    }\n\n    error InvalidBorrowedLiquidity(uint256 tokenId);\n    error TooLittleBorrowedLiquidity(uint128 liquidity);\n    error InvalidTokens(uint256 tokenId);\n    error NotApproved(uint256 tokenId);\n    error InvalidRestoredLiquidity(\n        uint256 tokenId,\n        uint128 borrowedLiquidity,\n        uint128 restoredLiquidity,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 holdTokentBalance,\n        uint256 saleTokenBalance\n    );\n\n    /**\n     * @dev Calculates the borrowed amount from a pool's single side position, rounding up if necessary.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param tickLower The lower tick value of the position range.\n     * @param tickUpper The upper tick value of the position range.\n     * @param liquidity The liquidity of the position.\n     * @return borrowedAmount The calculated borrowed amount.\n     */\n    function _getSingleSideRoundUpBorrowedAmount(\n        bool zeroForSaleToken,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) private pure returns (uint256 borrowedAmount) {\n        borrowedAmount = (\n            zeroForSaleToken\n                ? LiquidityAmounts.getAmount1ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n                : LiquidityAmounts.getAmount0ForLiquidity(\n                    TickMath.getSqrtRatioAtTick(tickLower),\n                    TickMath.getSqrtRatioAtTick(tickUpper),\n                    liquidity\n                )\n        );\n        if (borrowedAmount > Constants.MINIMUM_BORROWED_AMOUNT) {\n            ++borrowedAmount;\n        } else {\n            revert TooLittleBorrowedLiquidity(liquidity);\n        }\n    }\n\n    /**\n     * @dev Extracts liquidity from loans and returns the borrowed amount.\n     * @param zeroForSaleToken A boolean value indicating whether the token for sale is the 0th token or not.\n     * @param token0 The address of one of the tokens in the pair.\n     * @param token1 The address of the other token in the pair.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     * @return borrowedAmount The total amount borrowed.\n     */\n    function _extractLiquidity(\n        bool zeroForSaleToken,\n        address token0,\n        address token1,\n        LoanInfo[] memory loans\n    ) internal returns (uint256 borrowedAmount) {\n        if (!zeroForSaleToken) {\n            (token0, token1) = (token1, token0);\n        }\n\n        for (uint256 i; i < loans.length; ) {\n            uint256 tokenId = loans[i].tokenId;\n            uint128 liquidity = loans[i].liquidity;\n            // Extract position-related details\n            {\n                int24 tickLower;\n                int24 tickUpper;\n                uint128 posLiquidity;\n                {\n                    address operator;\n                    address posToken0;\n                    address posToken1;\n\n                    (\n                        ,\n                        operator,\n                        posToken0,\n                        posToken1,\n                        ,\n                        tickLower,\n                        tickUpper,\n                        posLiquidity,\n                        ,\n                        ,\n                        ,\n\n                    ) = underlyingPositionManager.positions(tokenId);\n                    // Check operator approval\n                    if (operator != address(this)) {\n                        revert NotApproved(tokenId);\n                    }\n                    // Check token validity\n                    if (posToken0 != token0 || posToken1 != token1) {\n                        revert InvalidTokens(tokenId);\n                    }\n                }\n                // Check borrowed liquidity validity\n                if (!(liquidity > 0 && liquidity <= posLiquidity)) {\n                    revert InvalidBorrowedLiquidity(tokenId);\n                }\n                // Calculate borrowed amount\n                borrowedAmount += _getSingleSideRoundUpBorrowedAmount(\n                    zeroForSaleToken,\n                    tickLower,\n                    tickUpper,\n                    liquidity\n                );\n            }\n            // Decrease liquidity and move to the next loan\n            _decreaseLiquidity(tokenId, liquidity);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Restores liquidity from loans.\n     * @param params The RestoreLiquidityParams struct containing restoration parameters.\n     * @param externalSwap The SwapParams struct containing external swap details.\n     * @param loans An array of LoanInfo struct instances containing loan information.\n     */\n    function _restoreLiquidity(\n        // Create a cache struct to store temporary data\n        RestoreLiquidityParams memory params,\n        SwapParams calldata externalSwap,\n        LoanInfo[] memory loans\n    ) internal {\n        RestoreLiquidityCache memory cache;\n        for (uint256 i; i < loans.length; ) {\n            // Update the cache for the current loan\n            LoanInfo memory loan = loans[i];\n            _upRestoreLiquidityCache(params.zeroForSaleToken, loan, cache);\n            // Calculate the hold token amount to be used for swapping\n            (uint256 holdTokenAmountIn, uint256 amount0, uint256 amount1) = _getHoldTokenAmountIn(\n                params.zeroForSaleToken,\n                cache.tickLower,\n                cache.tickUpper,\n                cache.sqrtPriceX96,\n                loan.liquidity,\n                cache.holdTokenDebt\n            );\n\n            if (holdTokenAmountIn > 0) {\n                // Quote exact input single for swap\n                uint256 saleTokenAmountOut;\n                (saleTokenAmountOut, cache.sqrtPriceX96, , ) = underlyingQuoterV2\n                    .quoteExactInputSingle(\n                        IQuoterV2.QuoteExactInputSingleParams({\n                            tokenIn: cache.holdToken,\n                            tokenOut: cache.saleToken,\n                            amountIn: holdTokenAmountIn,\n                            fee: params.fee,\n                            sqrtPriceLimitX96: 0\n                        })\n                    );\n\n                // Perform external swap if external swap target is provided\n                if (externalSwap.swapTarget != address(0)) {\n                    _patchAmountsAndCallSwap(\n                        cache.holdToken,"
    }
  ]
}