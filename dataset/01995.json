{
  "Title": "M-3: Tokens without UniV3 pairs with `tokenToBeneficiary` can be stolen by an attacker",
  "Content": "# Issue M-3: Tokens without UniV3 pairs with `tokenToBeneficiary` can be stolen by an attacker \n\nSource: https://github.com/sherlock-audit/2023-04-splits-judging/issues/26 \n\n## Found by \nctf\\_sec, mstpr-brainbot, obront, theOwl\n\n## Summary\n\nTokens sent to a Swapper that don't share a UniV3 pool with `tokenToBeneficiary` can be stolen, because an attacker can create such a pool with ultra-low liquidity and maintain it for the length of the TWAP, pricing the tokens at ~0 and swapping to steal them.\n\n## Vulnerability Detail\n\nThe oracle uses the TWAP price from Uniswap V3 to determine the price of each asset. \n\nIf a pair is not listed on Uniswap V3, the oracle will not work, so swapping the asset will not be permitted. In this case, the user should be able to withdraw the asset themselves using the `execCalls()` function.\n\nThis will be a relatively common occurrence that doesn't require obscure tokens. Many combinations of tokens on Uniswap are able to be traded because of multi-step hops (ie they don't have a pool directly, but they share a poolmate). However, these multi-step hops are not provided by the oracle. A quick review of [Uniswap Pairs List](https://info.uniswap.org/pairs#/) shows that this would impact token pairs as common as MATIC/WBTC or MAKER/FRAX.\n\nIn these situations, an attacker could steal all of the tokens in question by performing the following:\n- Create a Uniswap V3 pool with the Swapper's `tokenToBeneficiary` and the token in question\n- Seed it with an incredibly low amount of liquidity at a ratio that values that token in question at ~0\n- Maintain this price for the length of the TWAP, which shouldn't be hard with a new, unused pool and low liquidity (ie if the liquidity amount of lower than the gas needed to perform a swap, arbitrage bots will leave it alone)\n- Perform a \"swap\" from this asset to the `tokenToBeneficiary`, stealing the asset and paying ~0 for it\n\n## Impact\n\nAny tokens sent to a Swapper that do not have a pair with `tokenToBeneficiary` in Uniswap V3 can be stolen.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-splits/blob/main/splits-oracle/src/UniV3OracleImpl.sol#L274-L282\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`UniV3OracleImpl.sol` should require the pool being used as an oracle to meet certain liquidity thresholds or have existed for a predefined period of time before returning the price to the Swapper.\n\n\n\n## Discussion\n\n**zobront**\n\nFixed by https://github.com/0xSplits/splits-oracle/pull/3/ by only allowing whitelisted pools.\n\n**jacksanford1**\n\nConfirming that Splits meant for this fix (3) to be linked to this issue (26):\nhttps://github.com/0xSplits/splits-oracle/pull/3#issue-1701222164\n\n**hrishibhat**\n\nConsidering this issue as a valid medium given that this attack is possible only in case of non-existent token pair and is common with the issue of low liquidity underlying pool. \nCombining this issue and #28 with all their duplicates. \n\n\n**hrishibhat**\n\nSherlock's previous rule that held valid for this contest:\nExternal Oracle Price Manipulation: Issues related to price manipulation in an external oracle used by the contracts are not considered valid high/medium.\nBased on the above rule Issue #28 and direct duplicates of the price manipulation of the issue are considered to be low as they are about direct pool manipulation, \n\nHowever, #26 and its dupes mention non-existent pools which can be created by anyone the obtain the desired price which clearly does not fall under the above rule. Allowing tokens to be used which does not yet have a pool to obtain price from cannot be considered directly under the price manipulation rule and is a separate issue.\nHence considering the above issue and its duplicates as valid medium. \n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/65",
  "Code": [
    {
      "filename": "splits-oracle/src/UniV3OracleImpl.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {IUniswapV3Factory} from \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport {OracleLibrary} from \"v3-periphery/libraries/OracleLibrary.sol\";\nimport {TokenUtils} from \"splits-utils/TokenUtils.sol\";\n\nimport {OracleImpl} from \"./OracleImpl.sol\";\nimport {QuotePair, ConvertedQuotePair, SortedConvertedQuotePair} from \"./utils/QuotePair.sol\";\n\n/// @title UniV3 Oracle Implementation\n/// @author 0xSplits\n/// @notice A clone-implementation of an oracle using UniswapV3 TWAP\ncontract UniV3OracleImpl is OracleImpl {\n    /// -----------------------------------------------------------------------\n    /// libraries\n    /// -----------------------------------------------------------------------\n\n    using TokenUtils for address;\n\n    /// -----------------------------------------------------------------------\n    /// errors\n    /// -----------------------------------------------------------------------\n\n    error Pool_DoesNotExist();\n\n    /// -----------------------------------------------------------------------\n    /// structs\n    /// -----------------------------------------------------------------------\n\n    struct InitParams {\n        address owner;\n        bool paused;\n        uint24 defaultFee;\n        uint32 defaultPeriod;\n        uint32 defaultScaledOfferFactor;\n        SetPairOverrideParams[] pairOverrides;\n    }\n\n    struct SetPairOverrideParams {\n        QuotePair quotePair;\n        PairOverride pairOverride;\n    }\n\n    struct PairOverride {\n        uint24 fee;\n        uint32 period;\n        uint32 scaledOfferFactor;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// events\n    /// -----------------------------------------------------------------------\n\n    event SetDefaultFee(uint24 defaultFee);\n    event SetDefaultPeriod(uint32 defaultPeriod);\n    event SetDefaultScaledOfferFactor(uint32 defaultScaledOfferFactor);\n    event SetPairOverrides(SetPairOverrideParams[] params);\n\n    /// -----------------------------------------------------------------------\n    /// storage\n    /// -----------------------------------------------------------------------\n\n    /// -----------------------------------------------------------------------\n    /// storage - constants & immutables\n    /// -----------------------------------------------------------------------\n\n    /// @dev percentages measured in hundredths of basis points\n    uint32 internal constant PERCENTAGE_SCALE = 100_00_00; // = 100%\n\n    address public immutable uniV3OracleFactory;\n    IUniswapV3Factory public immutable uniswapV3Factory;\n    address public immutable weth9;\n\n    /// -----------------------------------------------------------------------\n    /// storage - mutables\n    /// -----------------------------------------------------------------------\n\n    /// slot 0 - 0 byte free\n\n    /// OwnableImpl storage\n    /// address internal $owner;\n    /// 20 bytes\n\n    /// PausableImpl storage\n    /// bool internal $paused;\n    /// 1 byte\n\n    /// default uniswap pool fee\n    /// @dev PERCENTAGE_SCALE = 1e6 = 100_00_00 = 100%;\n    /// fee = 30_00 = 0.3% is the uniswap default\n    /// unless overriden, getQuoteAmounts will revert if a non-permitted pool fee is used\n    /// 3 bytes\n    uint24 internal $defaultFee;\n\n    /// default twap period\n    /// @dev unless overriden, getQuoteAmounts will revert if zero\n    /// 4 bytes\n    uint32 internal $defaultPeriod;\n\n    /// default price scaling factor\n    /// @dev PERCENTAGE_SCALE = 1e6 = 100_00_00 = 100% = no discount or premium\n    /// 99_00_00 = 99% = 1% discount to oracle; 101_00_00 = 101% = 1% premium to oracle\n    /// 4 bytes\n    uint32 internal $defaultScaledOfferFactor;\n\n    /// slot 1 - 0 bytes free\n\n    /// overrides for specific quote pairs\n    /// 32 bytes\n    mapping(address => mapping(address => PairOverride)) internal $_pairOverrides;\n\n    /// -----------------------------------------------------------------------\n    /// constructor & initializer\n    /// -----------------------------------------------------------------------\n\n    constructor(IUniswapV3Factory uniswapV3Factory_, address weth9_) {\n        uniV3OracleFactory = msg.sender;\n        uniswapV3Factory = uniswapV3Factory_;\n        weth9 = weth9_;\n    }\n\n    function initializer(InitParams calldata params_) external {\n        // only uniV3OracleFactory may call `initializer`\n        if (msg.sender != uniV3OracleFactory) revert Unauthorized();\n\n        __initOwnable(params_.owner);\n        $paused = params_.paused;\n        $defaultFee = params_.defaultFee;\n        $defaultPeriod = params_.defaultPeriod;\n        $defaultScaledOfferFactor = params_.defaultScaledOfferFactor;\n\n        _setPairOverrides(params_.pairOverrides);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions\n    /// -----------------------------------------------------------------------\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external\n    /// -----------------------------------------------------------------------\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - onlyOwner\n    /// -----------------------------------------------------------------------\n\n    /// set defaultFee\n    function setDefaultFee(uint24 defaultFee_) external onlyOwner {\n        $defaultFee = defaultFee_;\n        emit SetDefaultFee(defaultFee_);\n    }\n\n    /// set defaultPeriod\n    function setDefaultPeriod(uint32 defaultPeriod_) external onlyOwner {\n        $defaultPeriod = defaultPeriod_;\n        emit SetDefaultPeriod(defaultPeriod_);\n    }\n\n    /// set defaultScaledOfferFactor\n    function setDefaultScaledOfferFactor(uint32 defaultScaledOfferFactor_) external onlyOwner {\n        $defaultScaledOfferFactor = defaultScaledOfferFactor_;\n        emit SetDefaultScaledOfferFactor(defaultScaledOfferFactor_);\n    }\n\n    /// set pair overrides\n    function setPairOverrides(SetPairOverrideParams[] calldata params_) external onlyOwner {\n        _setPairOverrides(params_);\n        emit SetPairOverrides(params_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - view\n    /// -----------------------------------------------------------------------\n\n    function defaultFee() external view returns (uint24) {\n        return $defaultFee;\n    }\n\n    function defaultPeriod() external view returns (uint32) {\n        return $defaultPeriod;\n    }\n\n    function defaultScaledOfferFactor() external view returns (uint32) {\n        return $defaultScaledOfferFactor;\n    }\n\n    /// get pair override for an array of quote pairs\n    function getPairOverrides(QuotePair[] calldata quotePairs_)\n        external\n        view\n        returns (PairOverride[] memory pairOverrides)\n    {\n        uint256 length = quotePairs_.length;\n        pairOverrides = new PairOverride[](length);\n        for (uint256 i; i < length;) {\n            pairOverrides[i] = _getPairOverride(quotePairs_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// get amounts for an array of quotes\n    function getQuoteAmounts(QuoteParams[] calldata quoteParams_)\n        external\n        view\n        override\n        pausable\n        returns (uint256[] memory quoteAmounts)\n    {\n        uint256 length = quoteParams_.length;\n        quoteAmounts = new uint256[](length);\n        for (uint256 i; i < length;) {\n            quoteAmounts[i] = _getQuoteAmount(quoteParams_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - private & internal\n    /// -----------------------------------------------------------------------\n\n    /// set pair overrides\n    function _setPairOverrides(SetPairOverrideParams[] calldata params_) internal {\n        uint256 length = params_.length;\n        for (uint256 i; i < length;) {\n            _setPairOverride(params_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// set pair override\n    function _setPairOverride(SetPairOverrideParams calldata params_) internal {\n        SortedConvertedQuotePair memory scqp = _convertAndSortQuotePair(params_.quotePair);\n        $_pairOverrides[scqp.cToken0][scqp.cToken1] = params_.pairOverride;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - private & internal - views\n    /// -----------------------------------------------------------------------\n\n    /// get quote amount for a trade\n    function _getQuoteAmount(QuoteParams calldata quoteParams_) internal view returns (uint256) {\n        ConvertedQuotePair memory cqp = quoteParams_.quotePair._convert(_convertToken);\n        SortedConvertedQuotePair memory scqp = cqp._sort();\n\n        PairOverride memory po = _getPairOverride(scqp);\n        if (po.scaledOfferFactor == 0) {\n            po.scaledOfferFactor = $defaultScaledOfferFactor;\n        }\n\n        // skip oracle if converted tokens are equal\n        if (cqp.cBase == cqp.cQuote) {\n            return quoteParams_.baseAmount * po.scaledOfferFactor / PERCENTAGE_SCALE;\n        }\n\n        if (po.fee == 0) {\n            po.fee = $defaultFee;\n        }\n        if (po.period == 0) {\n            po.period = $defaultPeriod;\n        }\n\n        address pool = uniswapV3Factory.getPool(scqp.cToken0, scqp.cToken1, po.fee);\n        if (pool == address(0)) {\n            revert Pool_DoesNotExist();\n        }\n\n        // reverts if period is zero or > oldest observation\n        (int24 arithmeticMeanTick,) = OracleLibrary.consult({pool: pool, secondsAgo: po.period});\n\n        uint256 unscaledAmountToBeneficiary = OracleLibrary.getQuoteAtTick({\n            tick: arithmeticMeanTick,\n            baseAmount: quoteParams_.baseAmount,\n            baseToken: cqp.cBase,\n            quoteToken: cqp.cQuote\n        });\n\n        return unscaledAmountToBeneficiary * po.scaledOfferFactor / PERCENTAGE_SCALE;\n    }\n\n    /// get pair override\n    function _getPairOverride(QuotePair calldata quotePair_) internal view returns (PairOverride memory) {\n        return _getPairOverride(_convertAndSortQuotePair(quotePair_));\n    }\n\n    /// get pair overrides\n    function _getPairOverride(SortedConvertedQuotePair memory scqp_) internal view returns (PairOverride memory) {\n        return $_pairOverrides[scqp_.cToken0][scqp_.cToken1];\n    }\n\n    /// convert & sort tokens into canonical order\n    function _convertAndSortQuotePair(QuotePair calldata quotePair_)\n        internal\n        view\n        returns (SortedConvertedQuotePair memory)\n    {\n        return quotePair_._convert(_convertToken)._sort();\n    }\n\n    /// convert eth (0x0) to weth\n    function _convertToken(address token_) internal view returns (address) {\n        return token_._isETH() ? weth9 : token_;\n    }\n}"
    }
  ]
}