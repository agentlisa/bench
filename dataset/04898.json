{
  "Title": "[M-01] There is no slippage check for the eth deposits processing in the `LibDepositing.processDeposits`",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L138-L142> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L209-L211> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L83> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L93> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L101>\n\nThe `LibDepositing.depositEtherToL2` function is called by the TaikoL1.depositEtherToL2 to deposit ether to the `L2 chain`. The maximum number of `unprocessed eth deposits` are capped at `_config.ethDepositRingBufferSize - 1` as shown here:\n\n```solidity\n        unchecked {\n            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount\n                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess\n                    < _config.ethDepositRingBufferSize - 1;\n        }\n```\n\nThe Taiko configuration states that `ethDepositRingBufferSize == 1024`. Hence the maximum unprocessed eth deposits allowed by the taiko L1 contract is `capped at 1023`.\n\nWhen the L2 block is proposed by calling the `LibProposing.proposeBlock` function by the TaikoL1 contract,  it processes the unprocessed `eth deposits` by calling the `LibDepositing.processDeposits`. But it is allowed to process `at most 32 eth deposits per block` as per the following conditional check in the `processDeposits` function.\n\n```solidity\ndeposits_ = new TaikoData.EthDeposit[(numPending.min(_config.ethDepositMaxCountPerBlock));\n```\n\nHere the `ethDepositMaxCountPerBlock == 32` as configured in the `TaikoL1.getConfig` function.\n\nAnd the `fee amount` for each of the `eth deposits` are calculated as follows:\n\n```solidity\nuint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));\n\nuint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;\n\ndeposits_[i].amount -= _fee; \n```\n\nHence the `deposited eth amount` is deducted by the calculated `_fee amount` for the `eth deposit transaction`. If the basefee of the `L1 block` increases significantly then the maximum fee of `ethDepositMaxFee: 1 ether / 10` will be applied. Thus deducting that amount from the `transferred eth deposit to the recipient in L2`.\n\nNow let's consider the following scenario:\n\n1.  `nextEthDepositToProcess` is currently `100`.\n2.  `numEthDeposits` is `1060` currently.\n3.  The number of proposed L2 blocks required to process 1060th eth deposit is = 1060 - 100 / 32 = 30 L2 blocks.\n4.  As a result all the `above 30 L2 blocks` will not be proposed in a single L1 block and will require multiple L1 blocks for it.\n5.  If there is `huge congestion` in the mainnet during this time the `block.basefee` of the subsequent `L1 blocks` would increase. And this could prompt the maximum fee of `_config.ethDepositMaxFee` to be charged on the deposited amount (in the `LibDepositing.processDeposits` function, since subsequent L1 block would have a higher `block.basefee`) thus prompting loss of funds on the recipient.\n6.  For example let's assume the depositor deposit `1.1 ether` and current gas fee is `0.01 ether`. Hence the recipient expects to receive approximately `1.09 ether` at the time of the deposit on L1. But when the deposit is processed in a subsequent L1 block, if the fee amount increases to the maximum amount of `0.1 ether` then the recipient will only get approximately `1 ether` only. This will cost the recipient a `loss of 0.9 ether`. If there was a slippage check a depositor can set for his eth deposits then the he can prevent excessive gas costs during processing.\n\n### Proof of Concept\n\n```solidity\n        unchecked {\n            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount\n                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess\n                    < _config.ethDepositRingBufferSize - 1;\n        }\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L138-L142>\n\n```solidity\n            ethDepositRingBufferSize: 1024,\n            ethDepositMinCountPerBlock: 8,\n            ethDepositMaxCountPerBlock: 32,\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L209-L211>\n\n```solidity\n            uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L83>\n\n```solidity\n                uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L93>\n\n```solidity\n                    deposits_[i].amount -= _fee;\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L101>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nHence it is recommended to add a slippage check for the fee amount of the deposited eth amount in the `LibDepositing.processDeposits` function, since `depositEtherToL2` and `processDepositare` two different transactions with a delay during which the L1 block `basefee` can increase significantly causing loss of funds to the recipient in the form of fee increase.\n\n\n**[dantaik (Taiko) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/321#issuecomment-2033375181):**\n > Thank you for the feedback. The current issue is **valid but minor** as we believe users can choose not to deposit Ether using the `depositEtherToL2` function if there are already many deposits pending in the queue. Going forward, the processing of such deposits will likely be moved to the node software directly.\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/321#issuecomment-2045819455):**\n > Agree this is valid, the impact is most likely small, but I think the likelihood of it occurring at some point is relatively high.  The user is exposed to non-deterministic behavior that they cannot fully understand ahead of signing a transaction.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L1/libs/LibDepositing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"../TaikoData.sol\";\n\n/// @title LibDepositing\n/// @notice A library for handling Ether deposits in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibDepositing {\n    using LibAddress for address;\n    using LibAddress for address payable;\n    using LibMath for uint256;\n\n    /// @notice Emitted when Ether is deposited.\n    /// @dev Any events defined here must also be defined in TaikoEvents.sol.\n    event EthDeposited(TaikoData.EthDeposit deposit);\n\n    /// @dev Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_INVALID_ETH_DEPOSIT();\n\n    /// @dev Deposits Ether to Layer 2.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _recipient The recipient address.\n    function depositEtherToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        address _recipient\n    )\n        internal\n    {\n        if (!canDepositEthToL2(_state, _config, msg.value)) {\n            revert L1_INVALID_ETH_DEPOSIT();\n        }\n\n        _resolver.resolve(\"bridge\", false).sendEther(msg.value);\n\n        // Append the deposit to the queue.\n        address recipient_ = _recipient == address(0) ? msg.sender : _recipient;\n        uint256 slot = _state.slotA.numEthDeposits % _config.ethDepositRingBufferSize;\n\n        // range of msg.value is checked by next line.\n        _state.ethDeposits[slot] = _encodeEthDeposit(recipient_, msg.value);\n\n        emit EthDeposited(\n            TaikoData.EthDeposit({\n                recipient: recipient_,\n                amount: uint96(msg.value),\n                id: _state.slotA.numEthDeposits\n            })\n        );\n\n        // Unchecked is safe:\n        // - uint64 can store up to ~1.8 * 1e19, which can represent 584K years\n        // if we are depositing at every second\n        unchecked {\n            _state.slotA.numEthDeposits++;\n        }\n    }\n\n    /// @dev Processes the ETH deposits in a batched manner.\n    function processDeposits(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        address _feeRecipient\n    )\n        internal\n        returns (TaikoData.EthDeposit[] memory deposits_)\n    {\n        // Calculate the number of pending deposits.\n        uint256 numPending = _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess;\n\n        if (numPending < _config.ethDepositMinCountPerBlock) {\n            deposits_ = new TaikoData.EthDeposit[](0);\n        } else {\n            deposits_ =\n                new TaikoData.EthDeposit[](numPending.min(_config.ethDepositMaxCountPerBlock));\n            uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));\n            uint64 j = _state.slotA.nextEthDepositToProcess;\n            uint96 totalFee;\n            for (uint256 i; i < deposits_.length;) {\n                uint256 data = _state.ethDeposits[j % _config.ethDepositRingBufferSize];\n                deposits_[i] = TaikoData.EthDeposit({\n                    recipient: address(uint160(data >> 96)),\n                    amount: uint96(data),\n                    id: j\n                });\n                uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;\n\n                // Unchecked is safe:\n                // - _fee cannot be bigger than deposits_[i].amount\n                // - all values are in the same range (uint96) except loop\n                // counter, which obviously cannot be bigger than uint95\n                // otherwise the function would be gassing out.\n                unchecked {\n                    deposits_[i].amount -= _fee;\n                    totalFee += _fee;\n                    ++i;\n                    ++j;\n                }\n            }\n            _state.slotA.nextEthDepositToProcess = j;\n            // This is the fee deposit\n            _state.ethDeposits[_state.slotA.numEthDeposits % _config.ethDepositRingBufferSize] =\n                _encodeEthDeposit(_feeRecipient, totalFee);\n\n            // Unchecked is safe:\n            // - uint64 can store up to ~1.8 * 1e19, which can represent 584K\n            // years if we are depositing at every second\n            unchecked {\n                _state.slotA.numEthDeposits++;\n            }\n        }\n    }\n\n    /// @dev Checks if Ether deposit is allowed for Layer 2.\n    function canDepositEthToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // Unchecked is safe:\n        // - both numEthDeposits and _state.slotA.nextEthDepositToProcess are\n        // indexes. One is tracking all deposits (numEthDeposits: unprocessed)\n        // and the next to be processed, so nextEthDepositToProcess cannot be\n        // bigger than numEthDeposits\n        // - ethDepositRingBufferSize cannot be 0 by default (validity checked\n        // in LibVerifying)\n        unchecked {\n            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount\n                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess\n                    < _config.ethDepositRingBufferSize - 1;\n        }\n    }\n\n    /// @dev Encodes the given deposit into a uint256.\n    /// @param _addr The address of the deposit recipient.\n    /// @param _amount The amount of the deposit.\n    /// @return The encoded deposit.\n    function _encodeEthDeposit(address _addr, uint256 _amount) private pure returns (uint256) {\n        if (_amount > type(uint96).max) revert L1_INVALID_ETH_DEPOSIT();\n        return (uint256(uint160(_addr)) << 96) | _amount;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/TaikoL1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../common/EssentialContract.sol\";\nimport \"./libs/LibDepositing.sol\";\nimport \"./libs/LibProposing.sol\";\nimport \"./libs/LibProving.sol\";\nimport \"./libs/LibVerifying.sol\";\nimport \"./ITaikoL1.sol\";\nimport \"./TaikoErrors.sol\";\nimport \"./TaikoEvents.sol\";\n\n/// @title TaikoL1\n/// @notice This contract serves as the \"base layer contract\" of the Taiko protocol, providing\n/// functionalities for proposing, proving, and verifying blocks. The term \"base layer contract\"\n/// means that although this is usually deployed on L1, it can also be deployed on L2s to create\n/// L3 \"inception layers\". The contract also handles the deposit and withdrawal of Taiko tokens\n/// and Ether. Additionally, this contract doesn't hold any Ether. Ether deposited to L2 are held\n/// by the Bridge contract.\n/// @dev Labeled in AddressResolver as \"taiko\"\n/// @custom:security-contact security@taiko.xyz\ncontract TaikoL1 is EssentialContract, ITaikoL1, TaikoEvents, TaikoErrors {\n    /// @notice The TaikoL1 state.\n    TaikoData.State public state;\n\n    uint256[50] private __gap;\n\n    modifier whenProvingNotPaused() {\n        if (state.slotB.provingPaused) revert L1_PROVING_PAUSED();\n        _;\n    }\n\n    /// @dev Fallback function to receive Ether from Hooks\n    receive() external payable {\n        if (!_inNonReentrant()) revert L1_RECEIVE_DISABLED();\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    /// @param _genesisBlockHash The block hash of the genesis block.\n    function init(\n        address _owner,\n        address _addressManager,\n        bytes32 _genesisBlockHash\n    )\n        external\n        initializer\n    {\n        __Essential_init(_owner, _addressManager);\n        LibVerifying.init(state, getConfig(), _genesisBlockHash);\n    }\n\n    /// @inheritdoc ITaikoL1\n    function proposeBlock(\n        bytes calldata _params,\n        bytes calldata _txList\n    )\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n        TaikoData.Config memory config = getConfig();\n\n        (meta_, deposits_) = LibProposing.proposeBlock(state, config, this, _params, _txList);\n\n        if (!state.slotB.provingPaused) {\n            LibVerifying.verifyBlocks(state, config, this, config.maxBlocksToVerifyPerProposal);\n        }\n    }\n\n    /// @inheritdoc ITaikoL1\n    function proveBlock(\n        uint64 _blockId,\n        bytes calldata _input\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        whenProvingNotPaused\n    {\n        (\n            TaikoData.BlockMetadata memory meta,\n            TaikoData.Transition memory tran,\n            TaikoData.TierProof memory proof\n        ) = abi.decode(_input, (TaikoData.BlockMetadata, TaikoData.Transition, TaikoData.TierProof));\n\n        if (_blockId != meta.id) revert L1_INVALID_BLOCK_ID();\n\n        TaikoData.Config memory config = getConfig();\n\n        uint8 maxBlocksToVerify = LibProving.proveBlock(state, config, this, meta, tran, proof);\n\n        LibVerifying.verifyBlocks(state, config, this, maxBlocksToVerify);\n    }\n\n    /// @inheritdoc ITaikoL1\n    function verifyBlocks(uint64 _maxBlocksToVerify)\n        external\n        nonReentrant\n        whenNotPaused\n        whenProvingNotPaused\n    {\n        LibVerifying.verifyBlocks(state, getConfig(), this, _maxBlocksToVerify);\n    }\n\n    /// @notice Pause block proving.\n    /// @param _pause True if paused.\n    function pauseProving(bool _pause) external {\n        _authorizePause(msg.sender);\n        LibProving.pauseProving(state, _pause);\n    }\n\n    /// @notice Deposits Ether to Layer 2.\n    /// @param _recipient Address of the recipient for the deposited Ether on\n    /// Layer 2.\n    function depositEtherToL2(address _recipient) external payable nonReentrant whenNotPaused {\n        LibDepositing.depositEtherToL2(state, getConfig(), this, _recipient);\n    }\n\n    /// @inheritdoc EssentialContract\n    function unpause() public override {\n        super.unpause(); // permission checked inside\n        state.slotB.lastUnpausedAt = uint64(block.timestamp);\n    }\n\n    /// @notice Checks if Ether deposit is allowed for Layer 2.\n    /// @param _amount Amount of Ether to be deposited.\n    /// @return true if Ether deposit is allowed, false otherwise.\n    function canDepositEthToL2(uint256 _amount) public view returns (bool) {\n        return LibDepositing.canDepositEthToL2(state, getConfig(), _amount);\n    }\n\n    /// @notice See {LibProposing-isBlobReusable}.\n    function isBlobReusable(bytes32 _blobHash) public view returns (bool) {\n        return LibProposing.isBlobReusable(state, getConfig(), _blobHash);\n    }\n\n    /// @notice Gets the details of a block.\n    /// @param _blockId Index of the block.\n    /// @return blk_ The block.\n    /// @return ts_ The transition used to verify this block.\n    function getBlock(uint64 _blockId)\n        public\n        view\n        returns (TaikoData.Block memory blk_, TaikoData.TransitionState memory ts_)\n    {\n        uint64 slot;\n        (blk_, slot) = LibUtils.getBlock(state, getConfig(), _blockId);\n\n        if (blk_.verifiedTransitionId != 0) {\n            ts_ = state.transitions[slot][blk_.verifiedTransitionId];\n        }\n    }\n\n    /// @notice Gets the state transition for a specific block.\n    /// @param _blockId Index of the block.\n    /// @param _parentHash Parent hash of the block.\n    /// @return The state transition data of the block.\n    function getTransition(\n        uint64 _blockId,\n        bytes32 _parentHash\n    )\n        public\n        view\n        returns (TaikoData.TransitionState memory)\n    {\n        return LibUtils.getTransition(state, getConfig(), _blockId, _parentHash);\n    }\n\n    /// @notice Gets the state variables of the TaikoL1 contract.\n    /// @return a_ State variables stored at SlotA.\n    /// @return b_ State variables stored at SlotB.\n    function getStateVariables()\n        public\n        view\n        returns (TaikoData.SlotA memory a_, TaikoData.SlotB memory b_)\n    {\n        a_ = state.slotA;\n        b_ = state.slotB;\n    }\n\n    /// @inheritdoc ITaikoL1\n    function getConfig() public view virtual override returns (TaikoData.Config memory) {\n        // All hard-coded configurations:\n        // - treasury: the actual TaikoL2 address.\n        // - anchorGasLimit: 250_000 (based on internal devnet, its ~220_000\n        // after 256 L2 blocks)\n        return TaikoData.Config({\n            chainId: 167_008,\n            // Assume the block time is 3s, the protocol will allow ~1 month of\n            // new blocks without any verification.\n            blockMaxProposals: 864_000,\n            blockRingBufferSize: 864_100,\n            // Can be overridden by the tier config.\n            maxBlocksToVerifyPerProposal: 10,\n            blockMaxGasLimit: 15_000_000,\n            // Each go-ethereum transaction has a size limit of 128KB,\n            // and right now txList is still saved in calldata, so we set it\n            // to 120KB.\n            blockMaxTxListBytes: 120_000,\n            blobExpiry: 24 hours,\n            blobAllowedForDA: false,\n            blobReuseEnabled: false,\n            livenessBond: 250e18, // 250 Taiko token\n            // ETH deposit related.\n            ethDepositRingBufferSize: 1024,\n            ethDepositMinCountPerBlock: 8,\n            ethDepositMaxCountPerBlock: 32,\n            ethDepositMinAmount: 1 ether,\n            ethDepositMaxAmount: 10_000 ether,\n            ethDepositGas: 21_000,\n            ethDepositMaxFee: 1 ether / 10,\n            blockSyncThreshold: 16\n        });\n    }\n\n    function _authorizePause(address)\n        internal\n        view\n        virtual\n        override\n        onlyFromOwnerOrNamed(\"chain_pauser\")\n    { }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibDepositing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"../TaikoData.sol\";\n\n/// @title LibDepositing\n/// @notice A library for handling Ether deposits in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibDepositing {\n    using LibAddress for address;\n    using LibAddress for address payable;\n    using LibMath for uint256;\n\n    /// @notice Emitted when Ether is deposited.\n    /// @dev Any events defined here must also be defined in TaikoEvents.sol.\n    event EthDeposited(TaikoData.EthDeposit deposit);\n\n    /// @dev Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_INVALID_ETH_DEPOSIT();\n\n    /// @dev Deposits Ether to Layer 2.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _recipient The recipient address.\n    function depositEtherToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        address _recipient\n    )\n        internal\n    {\n        if (!canDepositEthToL2(_state, _config, msg.value)) {\n            revert L1_INVALID_ETH_DEPOSIT();\n        }\n\n        _resolver.resolve(\"bridge\", false).sendEther(msg.value);\n\n        // Append the deposit to the queue.\n        address recipient_ = _recipient == address(0) ? msg.sender : _recipient;\n        uint256 slot = _state.slotA.numEthDeposits % _config.ethDepositRingBufferSize;\n\n        // range of msg.value is checked by next line.\n        _state.ethDeposits[slot] = _encodeEthDeposit(recipient_, msg.value);\n\n        emit EthDeposited(\n            TaikoData.EthDeposit({\n                recipient: recipient_,\n                amount: uint96(msg.value),\n                id: _state.slotA.numEthDeposits\n            })\n        );\n\n        // Unchecked is safe:\n        // - uint64 can store up to ~1.8 * 1e19, which can represent 584K years\n        // if we are depositing at every second\n        unchecked {\n            _state.slotA.numEthDeposits++;\n        }\n    }\n\n    /// @dev Processes the ETH deposits in a batched manner.\n    function processDeposits(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        address _feeRecipient\n    )\n        internal\n        returns (TaikoData.EthDeposit[] memory deposits_)\n    {\n        // Calculate the number of pending deposits.\n        uint256 numPending = _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess;\n\n        if (numPending < _config.ethDepositMinCountPerBlock) {\n            deposits_ = new TaikoData.EthDeposit[](0);\n        } else {\n            deposits_ =\n                new TaikoData.EthDeposit[](numPending.min(_config.ethDepositMaxCountPerBlock));\n            uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));\n            uint64 j = _state.slotA.nextEthDepositToProcess;\n            uint96 totalFee;\n            for (uint256 i; i < deposits_.length;) {\n                uint256 data = _state.ethDeposits[j % _config.ethDepositRingBufferSize];\n                deposits_[i] = TaikoData.EthDeposit({\n                    recipient: address(uint160(data >> 96)),\n                    amount: uint96(data),\n                    id: j\n                });\n                uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;\n\n                // Unchecked is safe:\n                // - _fee cannot be bigger than deposits_[i].amount\n                // - all values are in the same range (uint96) except loop\n                // counter, which obviously cannot be bigger than uint95\n                // otherwise the function would be gassing out.\n                unchecked {\n                    deposits_[i].amount -= _fee;\n                    totalFee += _fee;\n                    ++i;\n                    ++j;\n                }\n            }\n            _state.slotA.nextEthDepositToProcess = j;\n            // This is the fee deposit\n            _state.ethDeposits[_state.slotA.numEthDeposits % _config.ethDepositRingBufferSize] =\n                _encodeEthDeposit(_feeRecipient, totalFee);\n\n            // Unchecked is safe:\n            // - uint64 can store up to ~1.8 * 1e19, which can represent 584K\n            // years if we are depositing at every second\n            unchecked {\n                _state.slotA.numEthDeposits++;\n            }\n        }\n    }\n\n    /// @dev Checks if Ether deposit is allowed for Layer 2.\n    function canDepositEthToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // Unchecked is safe:\n        // - both numEthDeposits and _state.slotA.nextEthDepositToProcess are\n        // indexes. One is tracking all deposits (numEthDeposits: unprocessed)\n        // and the next to be processed, so nextEthDepositToProcess cannot be\n        // bigger than numEthDeposits\n        // - ethDepositRingBufferSize cannot be 0 by default (validity checked\n        // in LibVerifying)\n        unchecked {\n            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount\n                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess\n                    < _config.ethDepositRingBufferSize - 1;\n        }\n    }\n\n    /// @dev Encodes the given deposit into a uint256.\n    /// @param _addr The address of the deposit recipient.\n    /// @param _amount The amount of the deposit.\n    /// @return The encoded deposit.\n    function _encodeEthDeposit(address _addr, uint256 _amount) private pure returns (uint256) {\n        if (_amount > type(uint96).max) revert L1_INVALID_ETH_DEPOSIT();\n        return (uint256(uint160(_addr)) << 96) | _amount;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibDepositing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"../TaikoData.sol\";\n\n/// @title LibDepositing\n/// @notice A library for handling Ether deposits in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibDepositing {\n    using LibAddress for address;\n    using LibAddress for address payable;\n    using LibMath for uint256;\n\n    /// @notice Emitted when Ether is deposited.\n    /// @dev Any events defined here must also be defined in TaikoEvents.sol.\n    event EthDeposited(TaikoData.EthDeposit deposit);\n\n    /// @dev Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_INVALID_ETH_DEPOSIT();\n\n    /// @dev Deposits Ether to Layer 2.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _recipient The recipient address.\n    function depositEtherToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        address _recipient\n    )\n        internal\n    {\n        if (!canDepositEthToL2(_state, _config, msg.value)) {\n            revert L1_INVALID_ETH_DEPOSIT();\n        }\n\n        _resolver.resolve(\"bridge\", false).sendEther(msg.value);\n\n        // Append the deposit to the queue.\n        address recipient_ = _recipient == address(0) ? msg.sender : _recipient;\n        uint256 slot = _state.slotA.numEthDeposits % _config.ethDepositRingBufferSize;\n\n        // range of msg.value is checked by next line.\n        _state.ethDeposits[slot] = _encodeEthDeposit(recipient_, msg.value);\n\n        emit EthDeposited(\n            TaikoData.EthDeposit({\n                recipient: recipient_,\n                amount: uint96(msg.value),\n                id: _state.slotA.numEthDeposits\n            })\n        );\n\n        // Unchecked is safe:\n        // - uint64 can store up to ~1.8 * 1e19, which can represent 584K years\n        // if we are depositing at every second\n        unchecked {\n            _state.slotA.numEthDeposits++;\n        }\n    }\n\n    /// @dev Processes the ETH deposits in a batched manner.\n    function processDeposits(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        address _feeRecipient\n    )\n        internal\n        returns (TaikoData.EthDeposit[] memory deposits_)\n    {\n        // Calculate the number of pending deposits.\n        uint256 numPending = _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess;\n\n        if (numPending < _config.ethDepositMinCountPerBlock) {\n            deposits_ = new TaikoData.EthDeposit[](0);\n        } else {\n            deposits_ =\n                new TaikoData.EthDeposit[](numPending.min(_config.ethDepositMaxCountPerBlock));\n            uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));\n            uint64 j = _state.slotA.nextEthDepositToProcess;\n            uint96 totalFee;\n            for (uint256 i; i < deposits_.length;) {\n                uint256 data = _state.ethDeposits[j % _config.ethDepositRingBufferSize];\n                deposits_[i] = TaikoData.EthDeposit({\n                    recipient: address(uint160(data >> 96)),\n                    amount: uint96(data),\n                    id: j\n                });\n                uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;\n\n                // Unchecked is safe:\n                // - _fee cannot be bigger than deposits_[i].amount\n                // - all values are in the same range (uint96) except loop\n                // counter, which obviously cannot be bigger than uint95\n                // otherwise the function would be gassing out.\n                unchecked {\n                    deposits_[i].amount -= _fee;\n                    totalFee += _fee;\n                    ++i;\n                    ++j;\n                }\n            }\n            _state.slotA.nextEthDepositToProcess = j;\n            // This is the fee deposit\n            _state.ethDeposits[_state.slotA.numEthDeposits % _config.ethDepositRingBufferSize] =\n                _encodeEthDeposit(_feeRecipient, totalFee);\n\n            // Unchecked is safe:\n            // - uint64 can store up to ~1.8 * 1e19, which can represent 584K\n            // years if we are depositing at every second\n            unchecked {\n                _state.slotA.numEthDeposits++;\n            }\n        }\n    }\n\n    /// @dev Checks if Ether deposit is allowed for Layer 2.\n    function canDepositEthToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // Unchecked is safe:\n        // - both numEthDeposits and _state.slotA.nextEthDepositToProcess are\n        // indexes. One is tracking all deposits (numEthDeposits: unprocessed)\n        // and the next to be processed, so nextEthDepositToProcess cannot be\n        // bigger than numEthDeposits\n        // - ethDepositRingBufferSize cannot be 0 by default (validity checked\n        // in LibVerifying)\n        unchecked {\n            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount\n                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess\n                    < _config.ethDepositRingBufferSize - 1;\n        }\n    }\n\n    /// @dev Encodes the given deposit into a uint256.\n    /// @param _addr The address of the deposit recipient.\n    /// @param _amount The amount of the deposit.\n    /// @return The encoded deposit.\n    function _encodeEthDeposit(address _addr, uint256 _amount) private pure returns (uint256) {\n        if (_amount > type(uint96).max) revert L1_INVALID_ETH_DEPOSIT();\n        return (uint256(uint160(_addr)) << 96) | _amount;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibDepositing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"../TaikoData.sol\";\n\n/// @title LibDepositing\n/// @notice A library for handling Ether deposits in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibDepositing {\n    using LibAddress for address;\n    using LibAddress for address payable;\n    using LibMath for uint256;\n\n    /// @notice Emitted when Ether is deposited.\n    /// @dev Any events defined here must also be defined in TaikoEvents.sol.\n    event EthDeposited(TaikoData.EthDeposit deposit);\n\n    /// @dev Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_INVALID_ETH_DEPOSIT();\n\n    /// @dev Deposits Ether to Layer 2.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _recipient The recipient address.\n    function depositEtherToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        address _recipient\n    )\n        internal\n    {\n        if (!canDepositEthToL2(_state, _config, msg.value)) {\n            revert L1_INVALID_ETH_DEPOSIT();\n        }\n\n        _resolver.resolve(\"bridge\", false).sendEther(msg.value);\n\n        // Append the deposit to the queue.\n        address recipient_ = _recipient == address(0) ? msg.sender : _recipient;\n        uint256 slot = _state.slotA.numEthDeposits % _config.ethDepositRingBufferSize;\n\n        // range of msg.value is checked by next line.\n        _state.ethDeposits[slot] = _encodeEthDeposit(recipient_, msg.value);\n\n        emit EthDeposited(\n            TaikoData.EthDeposit({\n                recipient: recipient_,\n                amount: uint96(msg.value),\n                id: _state.slotA.numEthDeposits\n            })\n        );\n\n        // Unchecked is safe:\n        // - uint64 can store up to ~1.8 * 1e19, which can represent 584K years\n        // if we are depositing at every second\n        unchecked {\n            _state.slotA.numEthDeposits++;\n        }\n    }\n\n    /// @dev Processes the ETH deposits in a batched manner.\n    function processDeposits(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        address _feeRecipient\n    )\n        internal\n        returns (TaikoData.EthDeposit[] memory deposits_)\n    {\n        // Calculate the number of pending deposits.\n        uint256 numPending = _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess;\n\n        if (numPending < _config.ethDepositMinCountPerBlock) {\n            deposits_ = new TaikoData.EthDeposit[](0);\n        } else {\n            deposits_ =\n                new TaikoData.EthDeposit[](numPending.min(_config.ethDepositMaxCountPerBlock));\n            uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));\n            uint64 j = _state.slotA.nextEthDepositToProcess;\n            uint96 totalFee;\n            for (uint256 i; i < deposits_.length;) {\n                uint256 data = _state.ethDeposits[j % _config.ethDepositRingBufferSize];\n                deposits_[i] = TaikoData.EthDeposit({\n                    recipient: address(uint160(data >> 96)),\n                    amount: uint96(data),\n                    id: j\n                });\n                uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;\n\n                // Unchecked is safe:\n                // - _fee cannot be bigger than deposits_[i].amount\n                // - all values are in the same range (uint96) except loop\n                // counter, which obviously cannot be bigger than uint95\n                // otherwise the function would be gassing out.\n                unchecked {\n                    deposits_[i].amount -= _fee;\n                    totalFee += _fee;\n                    ++i;\n                    ++j;\n                }\n            }\n            _state.slotA.nextEthDepositToProcess = j;\n            // This is the fee deposit\n            _state.ethDeposits[_state.slotA.numEthDeposits % _config.ethDepositRingBufferSize] =\n                _encodeEthDeposit(_feeRecipient, totalFee);\n\n            // Unchecked is safe:\n            // - uint64 can store up to ~1.8 * 1e19, which can represent 584K\n            // years if we are depositing at every second\n            unchecked {\n                _state.slotA.numEthDeposits++;\n            }\n        }\n    }\n\n    /// @dev Checks if Ether deposit is allowed for Layer 2.\n    function canDepositEthToL2(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // Unchecked is safe:\n        // - both numEthDeposits and _state.slotA.nextEthDepositToProcess are\n        // indexes. One is tracking all deposits (numEthDeposits: unprocessed)\n        // and the next to be processed, so nextEthDepositToProcess cannot be\n        // bigger than numEthDeposits\n        // - ethDepositRingBufferSize cannot be 0 by default (validity checked\n        // in LibVerifying)\n        unchecked {\n            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount\n                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess\n                    < _config.ethDepositRingBufferSize - 1;\n        }\n    }\n\n    /// @dev Encodes the given deposit into a uint256.\n    /// @param _addr The address of the deposit recipient.\n    /// @param _amount The amount of the deposit.\n    /// @return The encoded deposit.\n    function _encodeEthDeposit(address _addr, uint256 _amount) private pure returns (uint256) {\n        if (_amount > type(uint96).max) revert L1_INVALID_ETH_DEPOSIT();\n        return (uint256(uint160(_addr)) << 96) | _amount;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibDepositing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"../TaikoData.sol\";\n\n/// @title LibDepositing\n/// @notice A library for handling Ether deposits in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibDepositing {\n    using LibAddress for address;\n    using LibAddress for address payable;\n    using LibMath for uint256;\n\n    /// @notice Emitted when Ether is deposited.\n    /// @dev Any events defined here must also be defined in TaikoEvents.sol.\n    event EthDeposited(Tai"
    }
  ]
}