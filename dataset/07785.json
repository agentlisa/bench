{
  "Title": "[G-06] Unnecessary cast in `Mailbox.serializeL2Transaction`",
  "Content": "\nIt's possible to remove the following casts:\n\n```diff\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) public pure returns (L2CanonicalTransaction memory) {\n        return\n            L2CanonicalTransaction({\n                txType: PRIORITY_OPERATION_L2_TX_TYPE,\n                from: uint256(uint160(_sender)),\n                to: uint256(uint160(_contractAddressL2)),\n                ergsLimit: _ergsLimit,\n                ergsPerPubdataByteLimit: uint256(1),\n                maxFeePerErg: uint256(0),\n                maxPriorityFeePerErg: uint256(0),\n                paymaster: uint256(0),\n-               reserved: [uint256(_txId), _l2Value, 0, 0, 0, 0],\n+               reserved: [_txId, _l2Value, 0, 0, 0, 0],\n                data: _calldata,\n                signature: new bytes(0),\n                factoryDeps: _hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n    }\n```\n\n**Affected source code:**\n\n*   [Mailbox.sol:206](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/Mailbox.sol#L206)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-zksync-v2-contest",
  "Code": [
    {
      "filename": "ethereum/contracts/zksync/facets/Mailbox.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMailbox.sol\";\nimport \"../libraries/Merkle.sol\";\nimport \"../libraries/PriorityQueue.sol\";\nimport \"../Storage.sol\";\nimport \"../Config.sol\";\nimport \"../../common/libraries/UncheckedMath.sol\";\nimport \"../../common/L2ContractHelper.sol\";\nimport \"./Base.sol\";\n\n/// @title zkSync Mailbox contract providing interfaces for L1 <-> L2 interaction.\n/// @author Matter Labs\ncontract MailboxFacet is Base, IMailbox {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @notice Prove that a specific arbitrary-length message was sent in a specific L2 block number\n    /// @param _blockNumber The executed L2 block number in which the message appeared\n    /// @param _index The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _message Information about the sent message: sender address, the message itself, tx index in the L2 block where the message was sent\n    /// @param _proof Merkle proof for inclusion of L2 log that was sent with the message\n    /// @return Whether the proof is valid\n    function proveL2MessageInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _L2MessageToLog(_message), _proof);\n    }\n\n    /// @notice Prove that a specific L2 log was sent in a specific L2 block\n    /// @param _blockNumber The executed L2 block number in which the log appeared\n    /// @param _index The position of the l2log in the L2 logs Merkle tree\n    /// @param _log Information about the sent log\n    /// @param _proof Merkle proof for inclusion of the L2 log\n    function proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool) {\n        return _proveL2LogInclusion(_blockNumber, _index, _log, _proof);\n    }\n\n    /// @dev Prove that a specific L2 log was sent in a specific L2 block number\n    function _proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) internal view returns (bool) {\n        require(_blockNumber <= s.totalBlocksExecuted, \"xx\");\n\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBlock, _log.sender, _log.key, _log.value)\n        );\n        // Check that hashed log is not the default one,\n        // otherwise it means that the value is out of range of sent L2 -> L1 logs\n        require(hashedLog != L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, \"tw\");\n        // Check that the proof length is exactly the same as tree height, to prevent\n        // any shorter/longer paths attack on the Merkle path validation\n        require(_proof.length == L2_TO_L1_LOG_MERKLE_TREE_HEIGHT, \"rz\");\n\n        bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_blockNumber];\n\n        return actualRootHash == calculatedRootHash;\n    }\n\n    /// @dev Convert arbitrary-length message to the raw l2 log\n    function _L2MessageToLog(L2Message calldata _message) internal pure returns (L2Log memory) {\n        return\n            L2Log({\n                l2ShardId: 0,\n                isService: true,\n                txNumberInBlock: _message.txNumberInBlock,\n                sender: L2_TO_L1_MESSENGER,\n                key: bytes32(uint256(uint160(_message.sender))),\n                value: keccak256(_message.data)\n            });\n    }\n\n    /// @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    /// @return The estimated ergs\n    function l2TransactionBaseCost(\n        uint256, // _gasPrice\n        uint256, // _ergsLimit\n        uint32 // _calldataLength\n    ) public pure returns (uint256) {\n        // TODO: estimate gas for L1 execute\n        return 0;\n    }\n\n    /// @notice Request execution of L2 transaction from L1.\n    /// @param _contractL2 The L2 receiver address\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return canonicalTxHash The hash of the requested L2 transaction. This hash can be used to follow the transaction status\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n        canonicalTxHash = _requestL2Transaction(msg.sender, _contractL2, _l2Value, _calldata, _ergsLimit, _factoryDeps);\n    }\n\n    function _requestL2Transaction(\n        address _sender,\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_ergsLimit <= PRIORITY_TX_MAX_ERGS_LIMIT, \"ui\");\n        uint64 expirationBlock = uint64(block.number + PRIORITY_EXPIRATION);\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n        // TODO: Restore after stable priority op fee modeling. (SMA-1230)\n        // uint256 baseCost = l2TransactionBaseCost(tx.gasprice, _ergsLimit, uint32(_calldata.length));\n        // uint256 layer2Tip = msg.value - baseCost;\n\n        canonicalTxHash = _writePriorityOp(\n            _sender,\n            txId,\n            _l2Value,\n            _contractL2,\n            _calldata,\n            expirationBlock,\n            _ergsLimit,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Stores a transaction record in storage & send event about that\n    function _writePriorityOp(\n        address _sender,\n        uint256 _txId,\n        uint256 _l2Value,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint64 _expirationBlock,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        L2CanonicalTransaction memory transaction = serializeL2Transaction(\n            _txId,\n            _l2Value,\n            _sender,\n            _contractAddressL2,\n            _calldata,\n            _ergsLimit,\n            _factoryDeps\n        );\n        canonicalTxHash = keccak256(abi.encode(transaction));\n\n        s.priorityQueue.pushBack(\n            PriorityOperation({\n                canonicalTxHash: canonicalTxHash,\n                expirationBlock: _expirationBlock,\n                layer2Tip: uint192(0) // TODO: Restore after fee modeling will be stable. (SMA-1230)\n            })\n        );\n\n        // Data that needed for operator to simulate priority queue offchain\n        emit NewPriorityRequest(_txId, canonicalTxHash, _expirationBlock, transaction, _factoryDeps);\n    }\n\n    /// @dev Accepts the parameters of the l2 transaction and converts it to the canonical form.\n    /// @param _txId Priority operation ID, used as a unique identifier so that transactions always have a different hash\n    /// @param _l2Value `msg.value` of L2 transaction. Please note, this ether is not transferred with requesting priority op,\n    /// but will be taken from the balance in L2 during the execution\n    /// @param _sender The L2 address of the account that initiates the transaction\n    /// @param _contractAddressL2 The L2 receiver address\n    /// @param _calldata The input of the L2 transaction\n    /// @param _ergsLimit Maximum amount of ergs that transaction can consume during execution on L2\n    /// @param _factoryDeps An array of L2 bytecodes that will be marked as known on L2\n    /// @return The canonical form of the l2 transaction parameters\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) public pure returns (L2CanonicalTransaction memory) {\n        return\n            L2CanonicalTransaction({\n                txType: PRIORITY_OPERATION_L2_TX_TYPE,\n                from: uint256(uint160(_sender)),\n                to: uint256(uint160(_contractAddressL2)),\n                ergsLimit: _ergsLimit,\n                ergsPerPubdataByteLimit: uint256(1),\n                maxFeePerErg: uint256(0),\n                maxPriorityFeePerErg: uint256(0),\n                paymaster: uint256(0),\n                reserved: [uint256(_txId), _l2Value, 0, 0, 0, 0],\n                data: _calldata,\n                signature: new bytes(0),\n                factoryDeps: _hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n    }\n\n    /// @notice Hashes the L2 bytecodes and returns them in the format in which they are processed by the bootloader\n    function _hashFactoryDeps(bytes[] calldata _factoryDeps)\n        internal\n        pure\n        returns (uint256[] memory hashedFactoryDeps)\n    {\n        uint256 factoryDepsLen = _factoryDeps.length;\n        hashedFactoryDeps = new uint256[](factoryDepsLen);\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n\n            // Store the resulting hash sequentially in bytes.\n            assembly {\n                mstore(add(hashedFactoryDeps, mul(add(i, 1), 32)), hashedBytecode)\n            }\n        }\n    }\n}"
    }
  ]
}