{
  "Title": "Conflated staking pool reward balances",
  "Content": "Each staking pool specifies its own reward token and [corresponding balance](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L210-L214) in the same aggregate contract. When retrieving this value, the [token balance of the aggregate contract](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L158) is returned. Since there could be multiple staking pools with the same reward token, this could include balances from other pools. It could also include any reward token balances that were directly sent to the contract.\n\n\nMoreover, current user rewards [could also be overstated](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L178), which would [prevent users from claiming the last rewards](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L212). Since [rewards are claimed](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L298) when withdrawing stake, anyone could prevent users from unstaking by directly sending reward tokens to the staking pool contract. Any non-zero amount would be sufficient to trigger this scenario. If this occurs, a recovery agent could still [retrieve](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Recoverable.sol#L49) the funds from the aggregate pool contract and distribute them as desired, although it is not clear how they should distribute the remaining rewards.\n\n\nConsider reading the pool balance from the saved record.\n\n\n**Update:** *Fixed as of commit `8b660b13cf9fbcde0bfedb3819dbb670ba74b09a` in [pull request #156](https://github.com/neptune-mutual-blue/protocol/pull/156).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/StakingPoolCoreLibV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable ordering  */\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"./StoreKeyUtil.sol\";\nimport \"./ProtoUtilV1.sol\";\nimport \"./NTransferUtilV2.sol\";\n\nlibrary StakingPoolCoreLibV1 {\n  using StoreKeyUtil for IStore;\n  using NTransferUtilV2 for IERC20;\n\n  bytes32 public constant NS_POOL = \"ns:pool:staking\";\n  bytes32 public constant NS_POOL_NAME = \"ns:pool:staking:name\";\n  bytes32 public constant NS_POOL_LOCKED = \"ns:pool:staking:locked\";\n  bytes32 public constant NS_POOL_LOCKUP_PERIOD_IN_BLOCKS = \"ns:pool:staking:lockup:period\";\n  bytes32 public constant NS_POOL_STAKING_TARGET = \"ns:pool:staking:target\";\n  bytes32 public constant NS_POOL_CUMULATIVE_STAKING_AMOUNT = \"ns:pool:staking:cum:amount\";\n  bytes32 public constant NS_POOL_STAKING_TOKEN = \"ns:pool:staking:token\";\n  bytes32 public constant NS_POOL_STAKING_TOKEN_UNI_STABLECOIN_PAIR = \"ns:pool:staking:token:uni:pair\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN = \"ns:pool:reward:token\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN_UNI_STABLECOIN_PAIR = \"ns:pool:reward:token:uni:pair\";\n  bytes32 public constant NS_POOL_STAKING_TOKEN_BALANCE = \"ns:pool:staking:token:balance\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN_DEPOSITS = \"ns:pool:reward:token:deposits\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN_DISTRIBUTION = \"ns:pool:reward:token:distrib\";\n  bytes32 public constant NS_POOL_MAX_STAKE = \"ns:pool:reward:token\";\n  bytes32 public constant NS_POOL_REWARD_PER_BLOCK = \"ns:pool:reward:per:block\";\n  bytes32 public constant NS_POOL_REWARD_PLATFORM_FEE = \"ns:pool:reward:platform:fee\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN_BALANCE = \"ns:pool:reward:token:balance\";\n\n  bytes32 public constant NS_POOL_DEPOSIT_HEIGHTS = \"ns:pool:deposit:heights\";\n  bytes32 public constant NS_POOL_REWARD_HEIGHTS = \"ns:pool:reward:heights\";\n  bytes32 public constant NS_POOL_TOTAL_REWARD_GIVEN = \"ns:pool:reward:total:given\";\n\n  /**\n   * @dev Reports the remaining amount of tokens that can be staked in this pool\n   */\n  function getAvailableToStakeInternal(IStore s, bytes32 key) external view returns (uint256) {\n    uint256 totalStaked = getTotalStaked(s, key);\n    uint256 target = getTarget(s, key);\n\n    if (totalStaked >= target) {\n      return 0;\n    }\n\n    return target - totalStaked;\n  }\n\n  function getTarget(IStore s, bytes32 key) public view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_STAKING_TARGET, key);\n  }\n\n  function getRewardPlatformFee(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_REWARD_PLATFORM_FEE, key);\n  }\n\n  function getTotalStaked(IStore s, bytes32 key) public view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_CUMULATIVE_STAKING_AMOUNT, key);\n  }\n\n  function getRewardPerBlock(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_REWARD_PER_BLOCK, key);\n  }\n\n  function getLockupPeriodInBlocks(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_LOCKUP_PERIOD_IN_BLOCKS, key);\n  }\n\n  function getRewardTokenBalance(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_REWARD_TOKEN_BALANCE, key);\n  }\n\n  function getMaximumStakeInternal(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_MAX_STAKE, key);\n  }\n\n  function getStakingTokenAddressInternal(IStore s, bytes32 key) external view returns (address) {\n    return s.getAddressByKeys(NS_POOL_STAKING_TOKEN, key);\n  }\n\n  function getStakingTokenStablecoinPairAddressInternal(IStore s, bytes32 key) external view returns (address) {\n    return s.getAddressByKeys(NS_POOL_STAKING_TOKEN_UNI_STABLECOIN_PAIR, key);\n  }\n\n  function getRewardTokenAddressInternal(IStore s, bytes32 key) external view returns (address) {\n    return s.getAddressByKeys(NS_POOL_REWARD_TOKEN, key);\n  }\n\n  function getRewardTokenStablecoinPairAddressInternal(IStore s, bytes32 key) external view returns (address) {\n    return s.getAddressByKeys(NS_POOL_REWARD_TOKEN_UNI_STABLECOIN_PAIR, key);\n  }\n\n  function ensureValidStakingPool(IStore s, bytes32 key) external view {\n    require(checkIfStakingPoolExists(s, key), \"Pool invalid or closed\");\n  }\n\n  function checkIfStakingPoolExists(IStore s, bytes32 key) public view returns (bool) {\n    return s.getBoolByKeys(NS_POOL, key);\n  }\n\n  function validateAddOrEditPoolInternal(\n    IStore s,\n    bytes32 key,\n    string calldata name,\n    address[] calldata addresses,\n    uint256[] calldata values\n  ) public view returns (bool) {\n    require(key > 0, \"Invalid key\");\n\n    bool exists = checkIfStakingPoolExists(s, key);\n\n    if (exists == false) {\n      require(bytes(name).length > 0, \"Invalid name\");\n      require(addresses[0] != address(0), \"Invalid staking token\");\n      // require(addresses[1] != address(0), \"Invalid staking token pair\"); // A POD doesn't have any pair with stablecion\n      require(addresses[2] != address(0), \"Invalid reward token\");\n      require(addresses[3] != address(0), \"Invalid reward token pair\");\n      require(values[4] > 0, \"Provide lockup period in blocks\");\n      require(values[5] > 0, \"Provide reward token allocation\");\n      require(values[3] > 0, \"Provide reward per block\");\n      require(values[0] > 0, \"Please provide staking target\");\n    }\n\n    return exists;\n  }\n\n  /**\n   * @dev Adds or edits the pool by key\n   *\n   * @custom:suppress-malicious-erc Risk tolerable. The ERC-20 `addresses[1]`, `addresses[2]`, and `addresses[3]` can be trusted\n   * as these can be supplied only by an admin.\n   *\n   * @param key Enter the key of the pool you want to create or edit\n   * @param name Enter a name for this pool\n   * @param addresses[0] stakingToken The token which is staked in this pool\n   * @param addresses[1] uniStakingTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   * @param addresses[2] rewardToken The token which is rewarded in this pool\n   * @param addresses[3] uniRewardTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   * @param values[0] stakingTarget Specify the target amount in the staking token. You can not exceed the target.\n   * @param values[1] maxStake Specify the maximum amount that can be staken at a time.\n   * @param values[2] platformFee Enter the platform fee which is deducted on reward and on the reward token\n   * @param values[3] rewardPerBlock Specify the amount of reward token awarded per block\n   * @param values[4] lockupPeriodInBlocks Enter a lockup period during when the staked tokens can't be withdrawn\n   * @param values[5] rewardTokenDeposit Enter the value of reward token you are depositing in this transaction.\n   */\n  function addOrEditPoolInternal(\n    IStore s,\n    bytes32 key,\n    string calldata name,\n    address[] calldata addresses,\n    uint256[] calldata values\n  ) external {\n    // @suppress-zero-value-check The uint values are checked in the function `validateAddOrEditPoolInternal`\n    bool poolExists = validateAddOrEditPoolInternal(s, key, name, addresses, values);\n\n    if (poolExists == false) {\n      _initializeNewPool(s, key, addresses);\n    }\n\n    if (bytes(name).length > 0) {\n      s.setStringByKeys(NS_POOL, key, name);\n    }\n\n    _updatePoolValues(s, key, values);\n\n    // If `values[5] --> rewardTokenDeposit` is specified, the contract\n    // pulls the reward tokens to this contract address\n    if (values[5] > 0) {\n      IERC20(addresses[2]).ensureTransferFrom(msg.sender, address(this), values[5]);\n    }\n  }\n\n  /**\n   * @dev Updates the values of a staking pool by the given key\n   * @param s Provide an instance of the store\n   * @param key Enter the key of the pool you want to create or edit\n   * @param values[0] stakingTarget Specify the target amount in the staking token. You can not exceed the target.\n   * @param values[1] maxStake Specify the maximum amount that can be staken at a time.\n   * @param values[2] platformFee Enter the platform fee which is deducted on reward and on the reward token\n   * @param values[3] rewardPerBlock Specify the amount of reward token awarded per block\n   * @param values[4] lockupPeriodInBlocks Enter a lockup period during when the staked tokens can't be withdrawn\n   * @param values[5] rewardTokenDeposit Enter the value of reward token you are depositing in this transaction.\n   */\n  function _updatePoolValues(\n    IStore s,\n    bytes32 key,\n    uint256[] calldata values\n  ) private {\n    if (values[0] > 0) {\n      s.setUintByKeys(NS_POOL_STAKING_TARGET, key, values[0]);\n    }\n\n    if (values[1] > 0) {\n      s.setUintByKeys(NS_POOL_MAX_STAKE, key, values[1]);\n    }\n\n    if (values[2] > 0) {\n      s.setUintByKeys(NS_POOL_REWARD_PLATFORM_FEE, key, values[2]);\n    }\n\n    if (values[3] > 0) {\n      s.setUintByKeys(NS_POOL_REWARD_PER_BLOCK, key, values[3]);\n    }\n\n    if (values[4] > 0) {\n      s.setUintByKeys(NS_POOL_LOCKUP_PERIOD_IN_BLOCKS, key, values[4]);\n    }\n\n    if (values[5] > 0) {\n      s.addUintByKeys(NS_POOL_REWARD_TOKEN_DEPOSITS, key, values[5]);\n      s.addUintByKeys(NS_POOL_REWARD_TOKEN_BALANCE, key, values[5]);\n    }\n  }\n\n  /**\n   * @dev Initializes a new pool by the given key. Assumes that the pool does not exist.\n   *\n   * @custom:warning This feature should not be accessible outside of this library.\n   *\n   * @param s Provide an instance of the store\n   * @param key Enter the key of the pool you want to create or edit\n   * @param addresses[0] stakingToken The token which is staked in this pool\n   * @param addresses[1] uniStakingTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   * @param addresses[2] rewardToken The token which is rewarded in this pool\n   * @param addresses[3] uniRewardTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   *\n   */\n  function _initializeNewPool(\n    IStore s,\n    bytes32 key,\n    address[] calldata addresses\n  ) private {\n    s.setAddressByKeys(NS_POOL_STAKING_TOKEN, key, addresses[0]);\n    s.setAddressByKeys(NS_POOL_STAKING_TOKEN_UNI_STABLECOIN_PAIR, key, addresses[1]);\n    s.setAddressByKeys(NS_POOL_REWARD_TOKEN, key, addresses[2]);\n    s.setAddressByKeys(NS_POOL_REWARD_TOKEN_UNI_STABLECOIN_PAIR, key, addresses[3]);\n\n    s.setBoolByKeys(NS_POOL, key, true);\n  }\n}"
    },
    {
      "filename": "contracts/libraries/StakingPoolLibV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable ordering  */\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"./StoreKeyUtil.sol\";\nimport \"./ProtoUtilV1.sol\";\nimport \"./NTransferUtilV2.sol\";\nimport \"./ValidationLibV1.sol\";\nimport \"./StakingPoolCoreLibV1.sol\";\n\nlibrary StakingPoolLibV1 {\n  using ProtoUtilV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using RegistryLibV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using StakingPoolCoreLibV1 for IStore;\n  using NTransferUtilV2 for IERC20;\n\n  /**\n   * @dev Gets the info of a given staking pool by key\n   * @param s Specify the store instance\n   * @param key Provide the staking pool key to fetch info for\n   * @param you Specify the address to customize the info for\n   * @param name Returns the name of the staking pool\n   * @param addresses[0] stakingToken --> Returns the address of the token which is staked in this pool\n   * @param addresses[1] stakingTokenStablecoinPair --> Returns the pair address of the staking token and stablecoin\n   * @param addresses[2] rewardToken --> Returns the address of the token which is rewarded in this pool\n   * @param addresses[3] rewardTokenStablecoinPair --> Returns the pair address of the reward token and stablecoin\n   * @param values[0] totalStaked --> Returns the total units of staked tokens\n   * @param values[1] target --> Returns the target amount to stake (as staking token unit)\n   * @param values[2] maximumStake --> Returns the maximum amount of staking token units that can be added at a time\n   * @param values[3] stakeBalance --> Returns the amount of staking token currently locked in the pool\n   * @param values[4] cumulativeDeposits --> Returns the total amount tokens which were deposited in this pool\n   * @param values[5] rewardPerBlock --> Returns the unit of reward tokens awarded on each block for each unit of staking token\n   * @param values[6] platformFee --> Returns the % rate (multipled by ProtoUtilV1.MULTIPLIER) charged by protocol on rewards\n   * @param values[7] lockupPeriod --> Returns the period until when a stake can't be withdrawn\n   * @param values[8] rewardTokenBalance --> Returns the balance of the reward tokens still left in the pool\n   * @param values[9] accountStakeBalance --> Returns your stake amount\n   * @param values[10] totalBlockSinceLastReward --> Returns the number of blocks since your last reward\n   * @param values[11] rewards --> The amount of reward tokens you have accumulated till this block\n   * @param values[12] canWithdrawFromBlockHeight --> The block height after which you are allowed to withdraw your stake\n   * @param values[13] lastDepositHeight --> Returns the block number of your last deposit\n   * @param values[14] lastRewardHeight --> Returns the block number of your last reward\n   */\n  function getInfoInternal(\n    IStore s,\n    bytes32 key,\n    address you\n  )\n    external\n    view\n    returns (\n      string memory name,\n      address[] memory addresses,\n      uint256[] memory values\n    )\n  {\n    addresses = new address[](4);\n    values = new uint256[](15);\n\n    bool valid = s.checkIfStakingPoolExists(key);\n\n    if (valid) {\n      name = s.getStringByKeys(StakingPoolCoreLibV1.NS_POOL, key);\n\n      addresses[0] = s.getStakingTokenAddressInternal(key);\n      addresses[1] = s.getStakingTokenStablecoinPairAddressInternal(key);\n      addresses[2] = s.getRewardTokenAddressInternal(key);\n      addresses[3] = s.getRewardTokenStablecoinPairAddressInternal(key);\n\n      values[0] = s.getTotalStaked(key);\n      values[1] = s.getTarget(key);\n      values[2] = s.getMaximumStakeInternal(key);\n      values[3] = getPoolStakeBalanceInternal(s, key);\n      values[4] = getPoolCumulativeDeposits(s, key);\n      values[5] = s.getRewardPerBlock(key);\n      values[6] = s.getRewardPlatformFee(key);\n      values[7] = s.getLockupPeriodInBlocks(key);\n      values[8] = s.getRewardTokenBalance(key);\n      values[9] = getAccountStakingBalanceInternal(s, key, you);\n      values[10] = getTotalBlocksSinceLastRewardInternal(s, key, you);\n      values[11] = calculateRewardsInternal(s, key, you);\n      values[12] = canWithdrawFromBlockHeightInternal(s, key, you);\n      values[13] = getLastDepositHeight(s, key, you);\n      values[14] = getLastRewardHeight(s, key, you);\n    }\n  }\n\n  function getPoolStakeBalanceInternal(IStore s, bytes32 key) public view returns (uint256) {\n    uint256 totalStake = s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key);\n    return totalStake;\n  }\n\n  function getPoolCumulativeDeposits(IStore s, bytes32 key) public view returns (uint256) {\n    uint256 totalStake = s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_CUMULATIVE_STAKING_AMOUNT, key);\n    return totalStake;\n  }\n\n  function getAccountStakingBalanceInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    return s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, account);\n  }\n\n  function getTotalBlocksSinceLastRewardInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    uint256 from = getLastRewardHeight(s, key, account);\n\n    if (from == 0) {\n      return 0;\n    }\n\n    return block.number - from;\n  }\n\n  function canWithdrawFromBlockHeightInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    uint256 lastDepositHeight = getLastDepositHeight(s, key, account);\n\n    if (lastDepositHeight == 0) {\n      return 0;\n    }\n\n    uint256 lockupPeriod = s.getLockupPeriodInBlocks(key);\n\n    return lastDepositHeight + lockupPeriod;\n  }\n\n  function getLastDepositHeight(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    return s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_DEPOSIT_HEIGHTS, key, account);\n  }\n\n  function getLastRewardHeight(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    return s.getUintByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_HEIGHTS, key, account);\n  }\n\n  function getStakingPoolRewardTokenBalance(IStore s, bytes32 key) public view returns (uint256) {\n    IERC20 rewardToken = IERC20(s.getAddressByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_TOKEN, key));\n    address stakingPool = s.getStakingPoolAddress();\n\n    return rewardToken.balanceOf(stakingPool);\n  }\n\n  function calculateRewardsInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  ) public view returns (uint256) {\n    uint256 totalBlocks = getTotalBlocksSinceLastRewardInternal(s, key, account);\n\n    if (totalBlocks == 0) {\n      return 0;\n    }\n\n    uint256 rewardPerBlock = s.getRewardPerBlock(key);\n    uint256 myStake = getAccountStakingBalanceInternal(s, key, account);\n    uint256 rewards = (myStake * rewardPerBlock * totalBlocks) / 1 ether;\n\n    uint256 poolBalance = getStakingPoolRewardTokenBalance(s, key);\n\n    return rewards > poolBalance ? poolBalance : rewards;\n  }\n\n  /**\n   * @dev Withdraws the rewards of the caller (if any or if available).\n   *\n   *\n   * @custom:suppress-malicious-erc The ERC-20 `rewardtoken` can't be manipulated via user input.\n   *\n   */\n  function withdrawRewardsInternal(\n    IStore s,\n    bytes32 key,\n    address account\n  )\n    public\n    returns (\n      address rewardToken,\n      uint256 rewards,\n      uint256 platformFee\n    )\n  {\n    require(s.getRewardPlatformFee(key) <= ProtoUtilV1.MULTIPLIER, \"Invalid reward platform fee\");\n    rewards = calculateRewardsInternal(s, key, account);\n\n    s.setUintByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_HEIGHTS, key, account, block.number);\n\n    if (rewards == 0) {\n      return (address(0), 0, 0);\n    }\n\n    rewardToken = s.getAddressByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_TOKEN, key);\n\n    // Update (decrease) the balance of reward token\n    s.subtractUintByKeys(StakingPoolCoreLibV1.NS_POOL_REWARD_TOKEN_BALANCE, key, rewards);\n\n    // Update total rewards given\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_TOTAL_REWARD_GIVEN, key, account, rewards); // To this account\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_TOTAL_REWARD_GIVEN, key, rewards); // To everyone\n\n    // @suppress-division Checked side effects. If the reward platform fee is zero\n    // or a very small number, platform fee becomes zero because of data loss\n    platformFee = (rewards * s.getRewardPlatformFee(key)) / ProtoUtilV1.MULTIPLIER;\n\n    // @suppress-subtraction If `getRewardPlatformFee` is 100%, the following can result in zero value.\n    if (rewards - platformFee > 0) {\n      IERC20(rewardToken).ensureTransfer(msg.sender, rewards - platformFee);\n    }\n\n    if (platformFee > 0) {\n      IERC20(rewardToken).ensureTransfer(s.getTreasury(), platformFee);\n    }\n  }\n\n  /**\n   * @dev Deposit the specified amount of staking token to the specified pool.\n   *\n   * @custom:suppress-malicious-erc The ERC-20 `stakingToken` can't be manipulated via user input.\n   *\n   */\n  function depositInternal(\n    IStore s,\n    bytes32 key,\n    uint256 amount\n  )\n    external\n    returns (\n      address stakingToken,\n      address rewardToken,\n      uint256 rewards,\n      uint256 rewardsPlatformFee\n    )\n  {\n    require(amount > 0, \"Enter an amount\");\n    require(amount <= s.getMaximumStakeInternal(key), \"Stake too high\");\n    require(amount <= s.getAvailableToStakeInternal(key), \"Target achieved or cap exceeded\");\n\n    stakingToken = s.getStakingTokenAddressInternal(key);\n\n    // First withdraw your rewards\n    (rewardToken, rewards, rewardsPlatformFee) = withdrawRewardsInternal(s, key, msg.sender);\n\n    // Individual state\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, msg.sender, amount);\n    s.setUintByKeys(StakingPoolCoreLibV1.NS_POOL_DEPOSIT_HEIGHTS, key, msg.sender, block.number);\n\n    // Global state\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, amount);\n    s.addUintByKeys(StakingPoolCoreLibV1.NS_POOL_CUMULATIVE_STAKING_AMOUNT, key, amount);\n\n    IERC20(stakingToken).ensureTransferFrom(msg.sender, address(this), amount);\n  }\n\n  /**\n   * @dev Withdraw the specified amount of staking token from the specified pool.\n   *\n   * @custom:suppress-malicious-erc The ERC-20 `stakingToken` can't be manipulated via user input.\n   *\n   */\n  function withdrawInternal(\n    IStore s,\n    bytes32 key,\n    uint256 amount\n  )\n    external\n    returns (\n      address stakingToken,\n      address rewardToken,\n      uint256 rewards,\n      uint256 rewardsPlatformFee\n    )\n  {\n    require(amount > 0, \"Please specify amount\");\n\n    require(getAccountStakingBalanceInternal(s, key, msg.sender) >= amount, \"Insufficient balance\");\n    require(block.number > canWithdrawFromBlockHeightInternal(s, key, msg.sender), \"Withdrawal too early\");\n\n    stakingToken = s.getStakingTokenAddressInternal(key);\n\n    // First withdraw your rewards\n    (rewardToken, rewards, rewardsPlatformFee) = withdrawRewardsInternal(s, key, msg.sender);\n\n    // @suppress-subtraction The maximum amount that can be withdrawn is the staked balance\n    // and therefore underflow is not possible.\n    // Individual state\n    s.subtractUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, msg.sender, amount);\n\n    // Global state\n    s.subtractUintByKeys(StakingPoolCoreLibV1.NS_POOL_STAKING_TOKEN_BALANCE, key, amount);\n\n    IERC20(stakingToken).ensureTransfer(msg.sender, amount);\n  }\n}"
    }
  ]
}