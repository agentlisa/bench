{
  "Title": "[M-09] LibProposing:proposeBlock allows blocks with a zero parentMetaHash to be proposed after the genesis block and avoid parent block verification",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L108> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L213> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L121>\n\nThe proposeBlock at the LibProposing library has the following check to ensure the proposed block has the correct parentMetaHash set:\n\n```solidity\nfunction proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n    ...\nif (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n    ...\n    }\n```\n\nHowever, there are no sanity checks to ensure params.parentMetaHash is not zero outside of the genesis block.\n\n### Impact\n\nMalicious proposers can propose new blocks without any parentMetaHash.\nThis can induce a maliciously-generated block to be artificially contested as the final block relies on data held by the meta\\_ variable.\nSnippet 1:\n\n```solidity\nTaikoData.Block memory blk = TaikoData.Block({\n            metaHash: keccak256(abi.encode(meta_)),\n...\n})\n```\n\nThis also generates issues for independent provers, as they may not utilize the proposed block's data to attempt to prove it and utilize the correct parentMetaHash, which will make the LibProving:proveBlock call revert with an L1\\_BLOCK_MISTATCH error:\n\n```solidity\nfunction proveBlock\n\t...\n\tif (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {\n            revert L1_BLOCK_MISMATCH();\n        }\n\t...\n}\n```\n\nAlso, according to the documentation, [Â If the parent block hash is incorrect, the winning transition won't be used for block verification, and the prover will forfeit their validity bond entirely.](https://taiko.mirror.xyz/Z4I5ZhreGkyfdaL5I9P0Rj0DNX4zaWFmcws-0CVMJ2A#:\\~:text=If%20the%20parent%20block%20hash%20is%20incorrect%2C%20the%20winning%20transition%20won%27t%20be%20used%20for%20block%20verification%2C%20and%20the%20prover%20will%20forfeit%20their%20validity%20bond%20entirely) If a maliciously proposed block with zero parent block hash is contested and a higher-tier prover ends up proving the proposed block, then he/she loses its own validity bond.\n\n### Proof of Concept\n\nThe test suite contains the TaikoL1TestBase:proposeBlock that creates new block proposals with a zero parentMetaHash. This is called multiple times at tests like test_L1\\_verifying_multiple_blocks_once and test_L1\\_multiple_blocks_in_one_L1\\_block at the TaikoL1.t.sol test file, demonstrating the lack of reversion if the parentMetaHash is not zero outside of the genesis block.\n\n### Recommended Mitigation Steps\n\nMake sure to check the parentMetaHash value is not zero if it isn't at the genesis block, otherwise users are going to be able to wrongly induce contestations.\n\n**[adaki2004 (Taiko) confirmed](https://github.com/code-423n4/2024-03-taiko-findings/issues/218#issuecomment-2033993978)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProposing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../hooks/IHook.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibDepositing.sol\";\n\n/// @title LibProposing\n/// @notice A library for handling block proposals in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProposing {\n    using LibAddress for address;\n\n    /// @notice The maximum number of bytes allowed per blob.\n    /// @dev According to EIP4844, each blob has up to 4096 field elements, and each\n    /// field element has 32 bytes.\n    uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a block is proposed.\n    /// @param blockId The ID of the proposed block.\n    /// @param assignedProver The address of the assigned prover.\n    /// @param livenessBond The liveness bond of the proposed block.\n    /// @param meta The metadata of the proposed block.\n    /// @param depositsProcessed The EthDeposit array about processed deposits in this proposed\n    /// block.\n    event BlockProposed(\n        uint256 indexed blockId,\n        address indexed assignedProver,\n        uint96 livenessBond,\n        TaikoData.BlockMetadata meta,\n        TaikoData.EthDeposit[] depositsProcessed\n    );\n\n    /// @notice Emitted when a blob is cached.\n    /// @param blobHash The hash of the cached blob.\n    event BlobCached(bytes32 blobHash);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_BLOB_FOR_DA_DISABLED();\n    error L1_BLOB_NOT_FOUND();\n    error L1_BLOB_NOT_REUSABLE();\n    error L1_BLOB_REUSE_DISABLED();\n    error L1_INVALID_HOOK();\n    error L1_INVALID_PARAM();\n    error L1_INVALID_PROVER();\n    error L1_LIVENESS_BOND_NOT_RECEIVED();\n    error L1_PROPOSER_NOT_EOA();\n    error L1_TOO_MANY_BLOCKS();\n    error L1_TXLIST_OFFSET();\n    error L1_TXLIST_SIZE();\n    error L1_UNAUTHORIZED();\n    error L1_UNEXPECTED_PARENT();\n\n    /// @dev Proposes a Taiko L2 block.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _data Encoded data bytes containing the block params.\n    /// @param _txList Transaction list bytes (if not blob).\n    /// @return meta_ The constructed block's metadata.\n    /// @return deposits_ The EthDeposit array about processed deposits in this proposed\n    /// block.\n    function proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n        TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));\n\n        // We need a prover that will submit proofs after the block has been submitted\n        if (params.assignedProver == address(0)) {\n            revert L1_INVALID_PROVER();\n        }\n\n        if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\n        // Taiko, as a Based Rollup, enables permissionless block proposals.\n        // However, if the \"proposer\" address is set to a non-zero value, we\n        // ensure that only that specific address has the authority to propose\n        // blocks.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n\n        // It's essential to ensure that the ring buffer for proposed blocks\n        // still has space for at least one more block.\n        if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {\n            revert L1_TOO_MANY_BLOCKS();\n        }\n\n        bytes32 parentMetaHash =\n            _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;\n\n        // Check if parent block has the right meta hash\n        // This is to allow the proposer to make sure the block builds on the expected latest chain\n        // state\n        if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n\n        // Each transaction must handle a specific quantity of L1-to-L2\n        // Ether deposits.\n        deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);\n\n        // Initialize metadata to compute a metaHash, which forms a part of\n        // the block data to be stored on-chain for future integrity checks.\n        // If we choose to persist all data fields in the metadata, it will\n        // require additional storage slots.\n        unchecked {\n            meta_ = TaikoData.BlockMetadata({\n                l1Hash: blockhash(block.number - 1),\n                difficulty: 0, // to be initialized below\n                blobHash: 0, // to be initialized below\n                extraData: params.extraData,\n                depositsHash: keccak256(abi.encode(deposits_)),\n                coinbase: params.coinbase,\n                id: b.numBlocks,\n                gasLimit: _config.blockMaxGasLimit,\n                timestamp: uint64(block.timestamp),\n                l1Height: uint64(block.number - 1),\n                txListByteOffset: 0, // to be initialized below\n                txListByteSize: 0, // to be initialized below\n                minTier: 0, // to be initialized below\n                blobUsed: _txList.length == 0,\n                parentMetaHash: parentMetaHash\n            });\n        }\n\n        // Update certain meta fields\n        if (meta_.blobUsed) {\n            if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();\n\n            if (params.blobHash != 0) {\n                if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();\n\n                // We try to reuse an old blob\n                if (!isBlobReusable(_state, _config, params.blobHash)) {\n                    revert L1_BLOB_NOT_REUSABLE();\n                }\n                meta_.blobHash = params.blobHash;\n            } else {\n                // Always use the first blob in this transaction. If the\n                // proposeBlock functions are called more than once in the same\n                // L1 transaction, these multiple L2 blocks will share the same\n                // blob.\n                meta_.blobHash = blobhash(0);\n\n                if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();\n\n                // Depends on the blob data price, it may not make sense to\n                // cache the blob which costs 20,000 (sstore) + 631 (event)\n                // extra gas.\n                if (_config.blobReuseEnabled && params.cacheBlobForReuse) {\n                    _state.reusableBlobs[meta_.blobHash] = block.timestamp;\n                    emit BlobCached(meta_.blobHash);\n                }\n            }\n\n            // Check that the txList data range is within the max size of a blob\n            if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {\n                revert L1_TXLIST_OFFSET();\n            }\n\n            meta_.txListByteOffset = params.txListByteOffset;\n            meta_.txListByteSize = params.txListByteSize;\n        } else {\n            // The proposer must be an Externally Owned Account (EOA) for\n            // calldata usage. This ensures that the transaction is not an\n            // internal one, making calldata retrieval more straightforward for\n            // Taiko node software.\n            if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();\n\n            // The txList is the full byte array without any offset\n            if (params.txListByteOffset != 0) {\n                revert L1_INVALID_PARAM();\n            }\n\n            meta_.blobHash = keccak256(_txList);\n            meta_.txListByteOffset = 0;\n            meta_.txListByteSize = uint24(_txList.length);\n        }\n\n        // Check that the tx length is non-zero and within the supported range\n        if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {\n            revert L1_TXLIST_SIZE();\n        }\n\n        // Following the Merge, the L1 mixHash incorporates the\n        // prevrandao value from the beacon chain. Given the possibility\n        // of multiple Taiko blocks being proposed within a single\n        // Ethereum block, we choose to introduce a salt to this random\n        // number as the L2 mixHash.\n        meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));\n\n        // Use the difficulty as a random number\n        meta_.minTier = ITierProvider(_resolver.resolve(\"tier_provider\", false)).getMinTier(\n            uint256(meta_.difficulty)\n        );\n\n        // Create the block that will be stored onchain\n        TaikoData.Block memory blk = TaikoData.Block({\n            metaHash: keccak256(abi.encode(meta_)),\n            // Safeguard the liveness bond to ensure its preservation,\n            // particularly in scenarios where it might be altered after the\n            // block's proposal but before it has been proven or verified.\n            livenessBond: _config.livenessBond,\n            blockId: b.numBlocks,\n            proposedAt: meta_.timestamp,\n            proposedIn: uint64(block.number),\n            // For a new block, the next transition ID is always 1, not 0.\n            nextTransitionId: 1,\n            // For unverified block, its verifiedTransitionId is always 0.\n            verifiedTransitionId: 0,\n            assignedProver: params.assignedProver\n        });\n\n        // Store the block in the ring buffer\n        _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;\n\n        // Increment the counter (cursor) by 1.\n        unchecked {\n            ++_state.slotB.numBlocks;\n        }\n\n        {\n            IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n            uint256 tkoBalance = tko.balanceOf(address(this));\n\n            // Run all hooks.\n            // Note that address(this).balance has been updated with msg.value,\n            // prior to any code in this function has been executed.\n            address prevHook;\n            for (uint256 i; i < params.hookCalls.length; ++i) {\n                if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {\n                    revert L1_INVALID_HOOK();\n                }\n\n                // When a hook is called, all ether in this contract will be send to the hook.\n                // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n                // back to this contract for the next hook to use.\n                // Proposers shall choose use extra hooks wisely.\n                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n                    blk, meta_, params.hookCalls[i].data\n                );\n\n                prevHook = params.hookCalls[i].hook;\n            }\n            // Refund Ether\n            if (address(this).balance != 0) {\n                msg.sender.sendEther(address(this).balance);\n            }\n\n            // Check that after hooks, the Taiko Token balance of this contract\n            // have increased by the same amount as _config.livenessBond (to prevent)\n            // multiple draining payments by a malicious proposer nesting the same\n            // hook.\n            if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {\n                revert L1_LIVENESS_BOND_NOT_RECEIVED();\n            }\n        }\n\n        emit BlockProposed({\n            blockId: blk.blockId,\n            assignedProver: blk.assignedProver,\n            livenessBond: _config.livenessBond,\n            meta: meta_,\n            depositsProcessed: deposits_\n        });\n    }\n\n    /// @notice Checks if a blob is reusable.\n    /// @param _state Current TaikoData.State.\n    /// @param _config The TaikoData.Config.\n    /// @param _blobHash The blob hash\n    /// @return true if the blob is reusable, false otherwise.\n    function isBlobReusable(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        bytes32 _blobHash\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp;\n    }\n\n    function _isProposerPermitted(\n        TaikoData.SlotB memory _slotB,\n        IAddressResolver _resolver\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (_slotB.numBlocks == 1) {\n            // Only proposer_one can propose the first block after genesis\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n        }\n\n        address proposer = _resolver.resolve(\"proposer\", true);\n        return proposer == address(0) || msg.sender == proposer;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProposing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../hooks/IHook.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibDepositing.sol\";\n\n/// @title LibProposing\n/// @notice A library for handling block proposals in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProposing {\n    using LibAddress for address;\n\n    /// @notice The maximum number of bytes allowed per blob.\n    /// @dev According to EIP4844, each blob has up to 4096 field elements, and each\n    /// field element has 32 bytes.\n    uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a block is proposed.\n    /// @param blockId The ID of the proposed block.\n    /// @param assignedProver The address of the assigned prover.\n    /// @param livenessBond The liveness bond of the proposed block.\n    /// @param meta The metadata of the proposed block.\n    /// @param depositsProcessed The EthDeposit array about processed deposits in this proposed\n    /// block.\n    event BlockProposed(\n        uint256 indexed blockId,\n        address indexed assignedProver,\n        uint96 livenessBond,\n        TaikoData.BlockMetadata meta,\n        TaikoData.EthDeposit[] depositsProcessed\n    );\n\n    /// @notice Emitted when a blob is cached.\n    /// @param blobHash The hash of the cached blob.\n    event BlobCached(bytes32 blobHash);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_BLOB_FOR_DA_DISABLED();\n    error L1_BLOB_NOT_FOUND();\n    error L1_BLOB_NOT_REUSABLE();\n    error L1_BLOB_REUSE_DISABLED();\n    error L1_INVALID_HOOK();\n    error L1_INVALID_PARAM();\n    error L1_INVALID_PROVER();\n    error L1_LIVENESS_BOND_NOT_RECEIVED();\n    error L1_PROPOSER_NOT_EOA();\n    error L1_TOO_MANY_BLOCKS();\n    error L1_TXLIST_OFFSET();\n    error L1_TXLIST_SIZE();\n    error L1_UNAUTHORIZED();\n    error L1_UNEXPECTED_PARENT();\n\n    /// @dev Proposes a Taiko L2 block.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _data Encoded data bytes containing the block params.\n    /// @param _txList Transaction list bytes (if not blob).\n    /// @return meta_ The constructed block's metadata.\n    /// @return deposits_ The EthDeposit array about processed deposits in this proposed\n    /// block.\n    function proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n        TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));\n\n        // We need a prover that will submit proofs after the block has been submitted\n        if (params.assignedProver == address(0)) {\n            revert L1_INVALID_PROVER();\n        }\n\n        if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\n        // Taiko, as a Based Rollup, enables permissionless block proposals.\n        // However, if the \"proposer\" address is set to a non-zero value, we\n        // ensure that only that specific address has the authority to propose\n        // blocks.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n\n        // It's essential to ensure that the ring buffer for proposed blocks\n        // still has space for at least one more block.\n        if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {\n            revert L1_TOO_MANY_BLOCKS();\n        }\n\n        bytes32 parentMetaHash =\n            _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;\n\n        // Check if parent block has the right meta hash\n        // This is to allow the proposer to make sure the block builds on the expected latest chain\n        // state\n        if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n\n        // Each transaction must handle a specific quantity of L1-to-L2\n        // Ether deposits.\n        deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);\n\n        // Initialize metadata to compute a metaHash, which forms a part of\n        // the block data to be stored on-chain for future integrity checks.\n        // If we choose to persist all data fields in the metadata, it will\n        // require additional storage slots.\n        unchecked {\n            meta_ = TaikoData.BlockMetadata({\n                l1Hash: blockhash(block.number - 1),\n                difficulty: 0, // to be initialized below\n                blobHash: 0, // to be initialized below\n                extraData: params.extraData,\n                depositsHash: keccak256(abi.encode(deposits_)),\n                coinbase: params.coinbase,\n                id: b.numBlocks,\n                gasLimit: _config.blockMaxGasLimit,\n                timestamp: uint64(block.timestamp),\n                l1Height: uint64(block.number - 1),\n                txListByteOffset: 0, // to be initialized below\n                txListByteSize: 0, // to be initialized below\n                minTier: 0, // to be initialized below\n                blobUsed: _txList.length == 0,\n                parentMetaHash: parentMetaHash\n            });\n        }\n\n        // Update certain meta fields\n        if (meta_.blobUsed) {\n            if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();\n\n            if (params.blobHash != 0) {\n                if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();\n\n                // We try to reuse an old blob\n                if (!isBlobReusable(_state, _config, params.blobHash)) {\n                    revert L1_BLOB_NOT_REUSABLE();\n                }\n                meta_.blobHash = params.blobHash;\n            } else {\n                // Always use the first blob in this transaction. If the\n                // proposeBlock functions are called more than once in the same\n                // L1 transaction, these multiple L2 blocks will share the same\n                // blob.\n                meta_.blobHash = blobhash(0);\n\n                if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();\n\n                // Depends on the blob data price, it may not make sense to\n                // cache the blob which costs 20,000 (sstore) + 631 (event)\n                // extra gas.\n                if (_config.blobReuseEnabled && params.cacheBlobForReuse) {\n                    _state.reusableBlobs[meta_.blobHash] = block.timestamp;\n                    emit BlobCached(meta_.blobHash);\n                }\n            }\n\n            // Check that the txList data range is within the max size of a blob\n            if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {\n                revert L1_TXLIST_OFFSET();\n            }\n\n            meta_.txListByteOffset = params.txListByteOffset;\n            meta_.txListByteSize = params.txListByteSize;\n        } else {\n            // The proposer must be an Externally Owned Account (EOA) for\n            // calldata usage. This ensures that the transaction is not an\n            // internal one, making calldata retrieval more straightforward for\n            // Taiko node software.\n            if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();\n\n            // The txList is the full byte array without any offset\n            if (params.txListByteOffset != 0) {\n                revert L1_INVALID_PARAM();\n            }\n\n            meta_.blobHash = keccak256(_txList);\n            meta_.txListByteOffset = 0;\n            meta_.txListByteSize = uint24(_txList.length);\n        }\n\n        // Check that the tx length is non-zero and within the supported range\n        if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {\n            revert L1_TXLIST_SIZE();\n        }\n\n        // Following the Merge, the L1 mixHash incorporates the\n        // prevrandao value from the beacon chain. Given the possibility\n        // of multiple Taiko blocks being proposed within a single\n        // Ethereum block, we choose to introduce a salt to this random\n        // number as the L2 mixHash.\n        meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));\n\n        // Use the difficulty as a random number\n        meta_.minTier = ITierProvider(_resolver.resolve(\"tier_provider\", false)).getMinTier(\n            uint256(meta_.difficulty)\n        );\n\n        // Create the block that will be stored onchain\n        TaikoData.Block memory blk = TaikoData.Block({\n            metaHash: keccak256(abi.encode(meta_)),\n            // Safeguard the liveness bond to ensure its preservation,\n            // particularly in scenarios where it might be altered after the\n            // block's proposal but before it has been proven or verified.\n            livenessBond: _config.livenessBond,\n            blockId: b.numBlocks,\n            proposedAt: meta_.timestamp,\n            proposedIn: uint64(block.number),\n            // For a new block, the next transition ID is always 1, not 0.\n            nextTransitionId: 1,\n            // For unverified block, its verifiedTransitionId is always 0.\n            verifiedTransitionId: 0,\n            assignedProver: params.assignedProver\n        });\n\n        // Store the block in the ring buffer\n        _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;\n\n        // Increment the counter (cursor) by 1.\n        unchecked {\n            ++_state.slotB.numBlocks;\n        }\n\n        {\n            IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n            uint256 tkoBalance = tko.balanceOf(address(this));\n\n            // Run all hooks.\n            // Note that address(this).balance has been updated with msg.value,\n            // prior to any code in this function has been executed.\n            address prevHook;\n            for (uint256 i; i < params.hookCalls.length; ++i) {\n                if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {\n                    revert L1_INVALID_HOOK();\n                }\n\n                // When a hook is called, all ether in this contract will be send to the hook.\n                // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n                // back to this contract for the next hook to use.\n                // Proposers shall choose use extra hooks wisely.\n                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n                    blk, meta_, params.hookCalls[i].data\n                );\n\n                prevHook = params.hookCalls[i].hook;\n            }\n            // Refund Ether\n            if (address(this).balance != 0) {\n                msg.sender.sendEther(address(this).balance);\n            }\n\n            // Check that after hooks, the Taiko Token balance of this contract\n            // have increased by the same amount as _config.livenessBond (to prevent)\n            // multiple draining payments by a malicious proposer nesting the same\n            // hook.\n            if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {\n                revert L1_LIVENESS_BOND_NOT_RECEIVED();\n            }\n        }\n\n        emit BlockProposed({\n            blockId: blk.blockId,\n            assignedProver: blk.assignedProver,\n            livenessBond: _config.livenessBond,\n            meta: meta_,\n            depositsProcessed: deposits_\n        });\n    }\n\n    /// @notice Checks if a blob is reusable.\n    /// @param _state Current TaikoData.State.\n    /// @param _config The TaikoData.Config.\n    /// @param _blobHash The blob hash\n    /// @return true if the blob is reusable, false otherwise.\n    function isBlobReusable(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        bytes32 _blobHash\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp;\n    }\n\n    function _isProposerPermitted(\n        TaikoData.SlotB memory _slotB,\n        IAddressResolver _resolver\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (_slotB.numBlocks == 1) {\n            // Only proposer_one can propose the first block after genesis\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n        }\n\n        address proposer = _resolver.resolve(\"proposer\", true);\n        return proposer == address(0) || msg.sender == proposer;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProving.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"../../verifiers/IVerifier.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibUtils.sol\";\n\n/// @title LibProving\n/// @notice A library for handling block contestation and proving in the Taiko\n/// protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProving {\n    using LibMath for uint256;\n\n    /// @notice Keccak hash of the string \"RETURN_LIVENESS_BOND\".\n    bytes32 public constant RETURN_LIVENESS_BOND = keccak256(\"RETURN_LIVENESS_BOND\");\n\n    /// @notice The tier name for optimistic proofs.\n    bytes32 public constant TIER_OP = bytes32(\"tier_optimistic\");\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a transition is proved.\n    /// @param blockId The block ID.\n    /// @param tran The transition data.\n    /// @param prover The prover's address.\n    /// @param validityBond The validity bond amount.\n    /// @param tier The tier of the proof.\n    event TransitionProved(\n        uint256 indexed blockId,\n        TaikoData.Transition tran,\n        address prover,\n        uint96 validityBond,\n        uint16 tier\n    );\n\n    /// @notice Emitted when a transition is contested.\n    /// @param blockId The block ID.\n    /// @param tran The transition data.\n    /// @param contester The contester's address.\n    /// @param contestBond The contest bond amount.\n    /// @param tier The tier of the proof.\n    event TransitionContested(\n        uint256 indexed blockId,\n        TaikoData.Transition tran,\n        address contester,\n        uint96 contestBond,\n        uint16 tier\n    );\n\n    /// @notice Emitted when proving is paused or unpaused.\n    /// @param paused The pause status.\n    event ProvingPaused(bool paused);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_ALREADY_CONTESTED();\n    error L1_ALREADY_PROVED();\n    error L1_ASSIGNED_PROVER_NOT_ALLOWED();\n    error L1_BLOCK_MISMATCH();\n    error L1_INVALID_BLOCK_ID();\n    error L1_INVALID_PAUSE_STATUS();\n    error L1_INVALID_TIER();\n    error L1_INVALID_TRANSITION();\n    error L1_MISSING_VERIFIER();\n    error L1_NOT_ASSIGNED_PROVER();\n\n    /// @notice Pauses or unpauses the proving process.\n    /// @param _state Current TaikoData.State.\n    /// @param _pause The pause status.\n    function pauseProving(TaikoData.State storage _state, bool _pause) external {\n        if (_state.slotB.provingPaused == _pause) revert L1_INVALID_PAUSE_STATUS();\n        _state.slotB.provingPaused = _pause;\n\n        if (!_pause) {\n            _state.slotB.lastUnpausedAt = uint64(block.timestamp);\n        }\n        emit ProvingPaused(_pause);\n    }\n\n    /// @dev Proves or contests a block transition.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _meta The block's metadata.\n    /// @param _tran The transition data.\n    /// @param _proof The proof.\n    /// @param maxBlocksToVerify_ The number of blocks to be verified with this transaction.\n    function proveBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        TaikoData.BlockMetadata memory _meta,\n        TaikoData.Transition memory _tran,\n        TaikoData.TierProof memory _proof\n    )\n        internal\n        returns (uint8 maxBlocksToVerify_)\n    {\n        // Make sure parentHash is not zero\n        // To contest an existing transition, simply use any non-zero value as\n        // the blockHash and stateRoot.\n        if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) {\n            revert L1_INVALID_TRANSITION();\n        }\n\n        // Check that the block has been proposed but has not yet been verified.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (_meta.id <= b.lastVerifiedBlockId || _meta.id >= b.numBlocks) {\n            revert L1_INVALID_BLOCK_ID();\n        }\n\n        uint64 slot = _meta.id % _config.blockRingBufferSize;\n        TaikoData.Block storage blk = _state.blocks[slot];\n\n        // Check the integrity of the block data. It's worth noting that in\n        // theory, this check may be skipped, but it's included for added\n        // caution.\n        if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {\n            revert L1_BLOCK_MISMATCH();\n        }\n\n        // Each transition is uniquely identified by the parentHash, with the\n        // blockHash and stateRoot open for later updates as higher-tier proofs\n        // become available. In cases where a transition with the specified\n        // parentHash does not exist, the transition ID (tid) will be set to 0.\n        (uint32 tid, TaikoData.TransitionState storage ts) =\n            _createTransition(_state, blk, _tran, slot);\n\n        // The new proof must meet or exceed the minimum tier required by the\n        // block or the previous proof; it cannot be on a lower tier.\n        if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) {\n            revert L1_INVALID_TIER();\n        }\n\n        // Retrieve the tier configurations. If the tier is not supported, the\n        // subsequent action will result in a revert.\n        ITierProvider.Tier memory tier =\n            ITierProvider(_resolver.resolve(\"tier_provider\", false)).getTier(_proof.tier);\n\n        // Check if this prover is allowed to submit a proof for this block\n        _checkProverPermission(_state, blk, ts, tid, tier);\n\n        // We must verify the proof, and any failure in proof verification will\n        // result in a revert.\n        //\n        // It's crucial to emphasize that the proof can be assessed in two\n        // potential modes: \"proving mode\" and \"contesting mode.\" However, the\n        // precise verification logic is defined within each tier's IVerifier\n        // contract implementation. We simply specify to the verifier contract\n        // which mode it should utilize - if the new tier is higher than the\n        // previous tier, we employ the proving"
    }
  ]
}