{
  "Title": "[H-06] `WstEth` derivative assumes a `~1=1` peg of stETH to ETH",
  "Content": "\nThe `WstEth` contract implements the ETH derivative for the Lido protocol. The stETH token is the liquid representation of the ETH staked in this protocol.\n\nThere are two different places in the codebase that indicate that the implementation is assuming a peg of 1 ETH \\~= 1 stETH, each with different consequences. Even though both tokens have a tendency to keep the peg, this hasn't been always the case as it can be seen in [this charth](https://nomics.com/exchanges/curve-curve-finance-ethereum/markets/0xae7ab96520de3a18e5e111b5eaab095312d7fe84-0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee) or [this dashboard](https://dune.com/LidoAnalytical/Curve-ETHstETH). There have been many episodes of market volatility that affected the price of stETH, notably the one in last June when stETH traded at \\~0.93 ETH.\n\nThe first indication of such an assumption is the implementation of `ethPerDerivative`. This function is intended to work as an estimation of the current value in ETH of one unit (1e18) of the underlying asset. In this implementation, the function simply queries the amount of stETH for one unit (1e18) of wstETH and returns that value, which clearly indicates a conversion rate of 1 stETH = 1 ETH.\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L86-L88>\n\n```solidity\nfunction ethPerDerivative(uint256 _amount) public view returns (uint256) {\n    return IWStETH(WST_ETH).getStETHByWstETH(10 ** 18);\n}\n```\n\nThe other indication and most critical one is in the `withdraw` function. This function is used by the `SafEth` contract to unstake user positions and rebalance weights. In the implementation for the `WstEth` derivative, the function will unwrap the wstETH for stETH and use the Curve pool to exchange the stETH for ETH:\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L56-L67>\n\n```solidity\n56:     function withdraw(uint256 _amount) external onlyOwner {\n57:         IWStETH(WST_ETH).unwrap(_amount);\n58:         uint256 stEthBal = IERC20(STETH_TOKEN).balanceOf(address(this));\n59:         IERC20(STETH_TOKEN).approve(LIDO_CRV_POOL, stEthBal);\n60:         uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;\n61:         IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut);\n62:         // solhint-disable-next-line\n63:         (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n64:             \"\"\n65:         );\n66:         require(sent, \"Failed to send Ether\");\n67:     }\n```\n\nThe issue is the calculation of the `minOut` variable that is sent to the Curve `exchange` function to validate the output amount of the trade. As we can see in line 60, the calculation is simply applying the slippage percentage to stETH balance. This means that for example, given the default slippage value of 1%, trading 1 stETH will succeed only if the rate is above 0.99. Larger amounts will be more concerning as the Curve AMM implements non-linear invariants, the price impact will be bigger. The `rebalanceToWeights` function withdraws **all the balance** before rebalancing, which means it will try to swap all the stETH held by the contract.\n\nThis could be mitigated by adjusting the `maxSlippage` variable to allow for lower exchange rates. However this would imply additional issues. First, the `setMaxSlippage` is an admin function that needs to be manually updated with extreme care. In times of high volatility the owners won't be able to update this variable as frequently as needed to keep up with the exchange rate. This means that users that want to exit their position won't be able to do so since the exchange for this derivative will fail (see PoC for a detailed example). Second, on the contrary, if the owners decide to set a higher slippage value by default to allow for unexpected market conditions, withdrawals and rebalancing (in particular) will be victim of sandwich attacks by MEV bots.\n\n### Proof of Concept\n\nThe following test replicates the market conditions during last June where stETH was trading at 0.93 ETH (needs to be forked from mainnet at block \\~15000000). Here, the user wants to exit their position but the call to `unstake` will revert since the exchange in the Curve pool will fail as the output amount will be less than the expected minimum.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/a2895a85360276cf4f29d23de3282859).\n\n```solidity\n// Run this test forking mainnet at block height 15000000\nfunction test_WstEth_withdraw_AssumesPegToEth() public {\n    // Setup derivative\n    vm.prank(deployer);\n    safEth.addDerivative(address(wstEth), 1e18);\n\n    // Deal balance to user\n    uint256 depositValue = 1 ether;\n    vm.deal(user, depositValue);\n\n    // user stakes ether\n    vm.prank(user);\n    safEth.stake{value: depositValue}();\n\n    // user tries to unstake, action will fail due to stETH being prices at around 0.93-0.95 ETH\n    uint256 userShares = safEth.balanceOf(user);\n    vm.prank(user);\n    vm.expectRevert(\"Exchange resulted in fewer coins than expected\");\n    safEth.unstake(userShares);\n}\n```\n\n### Recommendation\n\nThe user should be able to decide on the slippage and set the expected minimum output amount to correctly handle different market conditions and user expectations. Similar to how decentralized exchanges work, the user experience can be improved by using a front-end that queries current exchange rates and offers the user a preview of the estimated output amount.\n\nThe `ethPerDerivative` function should also take into account the results of swapping the stETH for ETH using the Curve pool, similar to how the `SfrxEth` derivative implementation works.\n\n**[toshiSat (Asymmetry) confirmed](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/588#issuecomment-1500489141)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Using Chainlink to get price instead of assuming 1:1.<br>\n\n**Status:** Not fully mitigated. Full details in reports from [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/40) and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/13) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-03-asymmetry",
  "Code": [
    {
      "filename": "contracts/SafEth/derivatives/WstEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/curve/IStEthEthPool.sol\";\nimport \"../../interfaces/lido/IWStETH.sol\";\n\n/// @title Derivative contract for wstETH\n/// @author Asymmetry Finance\ncontract WstEth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant WST_ETH =\n        0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address public constant LIDO_CRV_POOL =\n        0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\n    address public constant STETH_TOKEN =\n        0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"Lido\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Owner only function to Convert derivative into ETH\n        @dev - Owner is set to SafEth contract\n     */\n    function withdraw(uint256 _amount) external onlyOwner {\n        IWStETH(WST_ETH).unwrap(_amount);\n        uint256 stEthBal = IERC20(STETH_TOKEN).balanceOf(address(this));\n        IERC20(STETH_TOKEN).approve(LIDO_CRV_POOL, stEthBal);\n        uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;\n        IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut);\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n        @notice - Owner only function to Deposit ETH into derivative\n        @dev - Owner is set to SafEth contract\n     */\n    function deposit() external payable onlyOwner returns (uint256) {\n        uint256 wstEthBalancePre = IWStETH(WST_ETH).balanceOf(address(this));\n        // solhint-disable-next-line\n        (bool sent, ) = WST_ETH.call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n        uint256 wstEthBalancePost = IWStETH(WST_ETH).balanceOf(address(this));\n        uint256 wstEthAmount = wstEthBalancePost - wstEthBalancePre;\n        return (wstEthAmount);\n    }\n\n    /**\n        @notice - Get price of derivative in terms of ETH\n     */\n    function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        return IWStETH(WST_ETH).getStETHByWstETH(10 ** 18);\n    }\n\n    /**\n        @notice - Total derivative balance\n     */\n    function balance() public view returns (uint256) {\n        return IERC20(WST_ETH).balanceOf(address(this));\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/derivatives/WstEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/curve/IStEthEthPool.sol\";\nimport \"../../interfaces/lido/IWStETH.sol\";\n\n/// @title Derivative contract for wstETH\n/// @author Asymmetry Finance\ncontract WstEth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant WST_ETH =\n        0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address public constant LIDO_CRV_POOL =\n        0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\n    address public constant STETH_TOKEN =\n        0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"Lido\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Owner only function to Convert derivative into ETH\n        @dev - Owner is set to SafEth contract\n     */\n    function withdraw(uint256 _amount) external onlyOwner {\n        IWStETH(WST_ETH).unwrap(_amount);\n        uint256 stEthBal = IERC20(STETH_TOKEN).balanceOf(address(this));\n        IERC20(STETH_TOKEN).approve(LIDO_CRV_POOL, stEthBal);\n        uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;\n        IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut);\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n        @notice - Owner only function to Deposit ETH into derivative\n        @dev - Owner is set to SafEth contract\n     */\n    function deposit() external payable onlyOwner returns (uint256) {\n        uint256 wstEthBalancePre = IWStETH(WST_ETH).balanceOf(address(this));\n        // solhint-disable-next-line\n        (bool sent, ) = WST_ETH.call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n        uint256 wstEthBalancePost = IWStETH(WST_ETH).balanceOf(address(this));\n        uint256 wstEthAmount = wstEthBalancePost - wstEthBalancePre;\n        return (wstEthAmount);\n    }\n\n    /**\n        @notice - Get price of derivative in terms of ETH\n     */\n    function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        return IWStETH(WST_ETH).getStETHByWstETH(10 ** 18);\n    }\n\n    /**\n        @notice - Total derivative balance\n     */\n    function balance() public view returns (uint256) {\n        return IERC20(WST_ETH).balanceOf(address(this));\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}