{
  "Title": "[M-04] `safeTransfer` function does not check for existence of ERC20 token contract",
  "Content": "\n[TransferHelper.sol#L21](https://github.com/code-423n4/2022-09-quickswap/blob/main/src/core/contracts/libraries/TransferHelper.sol#L21)<br>\n\nThe `safeTransfer` function does not check for the existence of the ERC20 token contract , `TransferHelper.sol` performs a transfer with a low-level call without confirming the contract's existence\n\n```js\nfunction safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TF');\n  }\n\n```\n\nThe low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\n\nIt allows malicious people to pair with a qualified token like ETH with [dubious] tokens that they can destroy later, and most importantly, to run the safeTransfer function even if the token contract is later destroyed.\n\n### Proof of Concept\n\n1 Alice creates a pair of A and B Tokens (For exampleETH - TestToken Pair).<br>\nThe creator and only owner of TestToken is Alice.\n\n2 Next, Alice destroys the TestToken with a Selfdestruct based on onlyowner privilege.\n\n3 Bob, unaware of this, deposits ETH into the pool to trade from the ETH-TestToken pair, but cannot receive any tokens because `safeTransfer` does not check for the existence of the contract.\n\n### Recommended Mitigation Steps\n\nHave the SafeTransfer function check the existence of the contract before every transaction.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-09-quickswap-findings/issues/86#issuecomment-1264738710):**\n > This is technically correct but requires some pretty explicit external requirements that cannot be easily fixed by a permission-less protocol.\n> \n> Mainly that if someone creates a pool with an ERC20 that can be self destructed, that pool's paired asset is going to be locked in some form as well.\n> \n> I am going to downgrade to M due to the external factors required for this to occur.  The recommended fix could ensure more assets don't become locked as a result of the self destruct. \n\n**[sameepsi (QuickSwap & StellaSwap) disputed and commented](https://github.com/code-423n4/2022-09-quickswap-findings/issues/86#issuecomment-1266445479):**\n > Tokens that are destructible are non-standard tokens. We cannot add support for all types of non-standard tokens in the protocol. This protocol is intended to work fine with standard tokens.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-quickswap-findings/issues/86#issuecomment-1266996633):**\n > Going to leave as Medium. I understand the sponsor's point here, but also believe there is a fix that would at least reduce some of the risk here. I do agree it is certainly an edge case. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-09-quickswap",
  "Code": [
    {
      "filename": "src/core/contracts/libraries/TransferHelper.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '../interfaces/IERC20Minimal.sol';\n\n/// @title TransferHelper\n/// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries\nlibrary TransferHelper {\n  /// @notice Transfers tokens from msg.sender to a recipient\n  /// @dev Calls transfer on token contract, errors with TF if transfer fails\n  /// @param token The contract address of the token which will be transferred\n  /// @param to The recipient of the transfer\n  /// @param value The value of the transfer\n  function safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TF');\n  }\n}"
    }
  ]
}