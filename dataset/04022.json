{
  "Title": "[L03] Long and complex function",
  "Content": "The [exported anonymous function of `make-release.ts`](https://github.com/celo-org/celo-monorepo/blob/0e876e5cad0e93f5dd1fff853f4be3c9a0e5c2a7/packages/protocol/scripts/truffle/make-release.ts#L124) is too long and complex. This function spans around 100 lines and has four levels of nested conditional blocks. This affects readability and maintainability of the code.\n\n\nConsider refactoring long and complex functions. Blocks of code that require comments can be extracted as internal helper functions with descriptive names. The same can be done with blocks of code inside conditionals. Consider following the top-to-bottom definition of functions and the stepdown rule from the [Clean Code book](https://www.goodreads.com/book/show/3735293-clean-code) to define every public API function followed by their lower-level helpers, which allows reviewers to easily dig into the implementation details that they care about. Consider measuring the [cyclomatic complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity) of the code and keeping it low.\n\n\n**Update**: *Fixed in [PR#6408](https://github.com/celo-org/celo-monorepo/pull/6408).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/scripts/truffle/make-release.ts",
      "content": "// tslint:disable: max-classes-per-file\n// tslint:disable: no-console\nimport { ASTDetailedVersionedReport } from '@celo/protocol/lib/compatibility/report'\nimport { getCeloContractDependencies } from '@celo/protocol/lib/contract-dependencies'\nimport { CeloContractName } from '@celo/protocol/lib/registry-utils'\nimport { linkedLibraries } from '@celo/protocol/migrationsConfig'\nimport { Address, eqAddress, NULL_ADDRESS } from '@celo/utils/lib/address'\nimport { readdirSync, readJsonSync, writeJsonSync } from 'fs-extra'\nimport { basename, join } from 'path'\nimport { RegistryInstance } from 'types'\n\n/*\n * A script that reads a backwards compatibility report, deploys changed contracts, and creates\n * a corresponding JSON file to be proposed with `celocli governance:propose`\n *\n * Expects the following flags:\n *   report: The filepath of the backwards compatibility report\n *   network: The network for which artifacts should be\n *\n * Run using truffle exec, e.g.:\n * truffle exec scripts/truffle/make-release \\\n *   --network alfajores --build_directory build/alfajores/ --report report.json \\\n *   --initialize_data initialize_data.json --proposal proposal.json\n */\n\nclass ContractAddresses {\n  static async create(contracts: string[], registry: RegistryInstance) {\n    const addresses = new Map()\n    await Promise.all(\n      contracts.map(async (contract: string) => {\n        const registeredAddress = await registry.getAddressForString(contract)\n        if (!eqAddress(registeredAddress, NULL_ADDRESS)) {\n          addresses.set(contract, registeredAddress)\n        }\n      })\n    )\n    return new ContractAddresses(addresses)\n  }\n\n  constructor(public addresses: Map<string, Address>) {}\n\n  public get = (contract: string): Address => {\n    if (this.addresses.has(contract)) {\n      return this.addresses.get(contract)\n    } else {\n      throw new Error(`Unable to find address for ${contract}`)\n    }\n  }\n\n  public set = (contract: string, address: Address) => {\n    this.addresses.set(contract, address)\n  }\n}\n\nconst REGISTRY_ADDRESS = '0x000000000000000000000000000000000000ce10'\n\nconst isProxiedContract = (contractName: string) => {\n  if (contractName.endsWith('Proxy')) {\n    return false\n  }\n\n  try {\n    artifacts.require(`${contractName}Proxy`)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nconst isCoreContract = (contractName: string) =>\n  Object.keys(CeloContractName).includes(contractName)\n\nconst deployImplementation = async (\n  contractName: string,\n  Contract: Truffle.Contract<Truffle.ContractInstance>,\n  dryRun: boolean\n) => {\n  console.log(`Deploying ${contractName}`)\n  // Hack to trick truffle, which checks that the provided address has code\n  const contract = await (dryRun ? Contract.at(REGISTRY_ADDRESS) : Contract.new())\n  // Sanity check that any contracts that are being changed set a version number.\n  const getVersionNumberAbi = contract.abi.find(\n    (abi: any) => abi.type === 'function' && abi.name === 'getVersionNumber'\n  )\n  if (!getVersionNumberAbi) {\n    throw new Error(`Contract ${contractName} has changes but does not specify a version number`)\n  }\n  return contract\n}\n\nconst deployProxy = async (contractName: string, addresses: ContractAddresses, dryRun: boolean) => {\n  // Explicitly forbid upgrading to a new Governance proxy contract.\n  // Upgrading to a new Governance proxy contract would require ownership of all\n  // contracts to be moved to the new governance contract, possibly including contracts\n  // deployed in this script.\n  // Because this depends on ordering (i.e. was the new GovernanceProxy deployed\n  // before or after other contracts in this script?), and that ordering is not being\n  // checked, fail if there are storage incompatible changes to Governance.\n  if (contractName === 'Governance') {\n    throw new Error(`Storage incompatible changes to Governance are not yet supported`)\n  }\n  console.log(`Deploying ${contractName}Proxy`)\n  const Proxy = await artifacts.require(`${contractName}Proxy`)\n  // Hack to trick truffle, which checks that the provided address has code\n  const proxy = await (dryRun ? Proxy.at(REGISTRY_ADDRESS) : Proxy.new())\n\n  // This makes essentially every contract dependent on Governance.\n  console.log(`Transferring ownership of ${contractName}Proxy to Governance`)\n  if (!dryRun) {\n    await proxy._transferOwnership(addresses.get('Governance'))\n  }\n\n  return proxy\n}\n\nexport interface ProposalTx {\n  contract: string\n  function: string\n  args: string[]\n  value: string\n  description?: string\n}\n\nmodule.exports = async (callback: (error?: any) => number) => {\n  try {\n    const argv = require('minimist')(process.argv.slice(2), {\n      string: ['report', 'network', 'proposal', 'libraries', 'initialize_data', 'build_directory'],\n      boolean: ['dry_run'],\n    })\n    const fullReport = readJsonSync(argv.report)\n    const report: ASTDetailedVersionedReport = fullReport.report\n    const initializationData = readJsonSync(argv.initialize_data)\n    const dependencies = getCeloContractDependencies()\n    const contracts = readdirSync(join(argv.build_directory, 'contracts')).map((x) =>\n      basename(x, '.json')\n    )\n    const registry = await artifacts.require('Registry').at(REGISTRY_ADDRESS)\n    const addresses = await ContractAddresses.create(contracts, registry)\n    const released: Set<string> = new Set([])\n    const proposal: ProposalTx[] = []\n\n    const release = async (contractName: string) => {\n      if (released.has(contractName)) {\n        return\n      } else {\n        // 1. Release all dependencies.\n        const contractDependencies = dependencies.get(contractName)\n        for (const dependency of contractDependencies) {\n          await release(dependency)\n        }\n        // 2. Link dependencies.\n        const Contract = await artifacts.require(contractName)\n        await Promise.all(contractDependencies.map((d) => Contract.link(d, addresses.get(d))))\n\n        // 3. Deploy new versions of the contract, if needed.\n        const shouldDeployImplementation = Object.keys(report.contracts).includes(contractName)\n        const isLibrary = linkedLibraries[contractName]\n        if (shouldDeployImplementation) {\n          const contract = await deployImplementation(contractName, Contract, argv.dry_run)\n          const setImplementationTx: ProposalTx = {\n            contract: `${contractName}Proxy`,\n            function: '_setImplementation',\n            args: [contract.address],\n            value: '0',\n          }\n\n          // 4. Deploy new versions of the proxy, if needed\n          const shouldDeployProxy = report.contracts[contractName].changes.storage.length > 0\n          if (!shouldDeployProxy) {\n            proposal.push(setImplementationTx)\n          } else {\n            const proxy = await deployProxy(contractName, addresses, argv.dry_run)\n\n            // 5. Update the contract's address to the new proxy in the proposal\n            addresses.set(contractName, proxy.address)\n            proposal.push({\n              contract: 'Registry',\n              function: 'setAddressFor',\n              args: [contractName, proxy.address],\n              value: '0',\n              description: `Registry: ${contractName} -> ${proxy.address}`,\n            })\n\n            // 6. If the implementation has an initialize function, add it to the proposal\n            const initializeAbi = (contract as any).abi.find(\n              (abi: any) => abi.type === 'function' && abi.name === 'initialize'\n            )\n            if (initializeAbi) {\n              const args = initializationData[contractName]\n              const callData = web3.eth.abi.encodeFunctionCall(initializeAbi, args)\n              console.log(`Add 'Initializing ${contractName} with: ${args}' to proposal`)\n              proposal.push({\n                contract: `${contractName}Proxy`,\n                function: '_setAndInitializeImplementation',\n                args: [contract.address, callData],\n                value: '0',\n              })\n            } else {\n              proposal.push(setImplementationTx)\n            }\n          }\n        } else if (isLibrary) {\n          const contract = await deployImplementation(contractName, Contract, argv.dry_run)\n          addresses.set(contractName, contract.address)\n        }\n        // 7. Mark the contract as released\n        released.add(contractName)\n      }\n    }\n    for (const contractName of contracts) {\n      if (isCoreContract(contractName) && isProxiedContract(contractName)) {\n        await release(contractName)\n      }\n    }\n    writeJsonSync(argv.proposal, proposal, { spaces: 2 })\n    callback()\n  } catch (error) {\n    callback(error)\n  }\n}"
    }
  ]
}