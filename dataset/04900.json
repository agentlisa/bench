{
  "Title": "[M-04] A recalled ERC20 bridge transfer can lock tokens in the bridge",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L320-L335> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L43-L45> \n\n<https://github.com/circlefin/stablecoin-evm/blob/0828084aec860712531e8d79fde478927a34b3f4/contracts/v1/FiatTokenV1.sol#L133-L136>\n\nA recalling ERC20 bridge transfer can lock funds in the bridge if the call to mint tokens fail on the source chain. Depending on the Native token logic this could either be a permanent lock or a lock of an unknown period of time.\n\nExample of how this can happen with the provided USDCAdapter:\n\nUSDC limits the amount of USDC that can be minted on each chain by giving each minter a minting allowance. If the minting allowance is reach minting will revert. If this happens in a recalled message the tokens together with the ETH value is locked.\n\n### Proof of Concept\n\nUSDC limits the amount of USDC that can be minted on each chain by giving each minter a minting allowance.\n\nIf `_amount <= mintingAllowedAmount` is reached for the `USDCAdapter` tokens can not be minted but since this is a recalled message the funds are stuck.\n\nBoth `onMessageIncovation()` and `onMessageRecalled()` call `_transferToken()` to either mint or release tokens.\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L320-L335>\n\n```solidity\n    function _transferTokens(\n        CanonicalERC20 memory _ctoken,\n        address _to,\n        uint256 _amount\n    )\n        private\n        returns (address token_)\n    {\n        if (_ctoken.chainId == block.chainid) {\n            token_ = _ctoken.addr;\n            IERC20(token_).safeTransfer(_to, _amount);\n        } else {\n            token_ = _getOrDeployBridgedToken(_ctoken);\n            IBridgedERC20(token_).mint(_to, _amount);\n        }\n    }\n```\n\nA recalled message to bridge USDC L1->L2 will revert when we attempt to mint through the `USDCAdapter`\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L43-L45>\n\n```solidity\n    function _mintToken(address _account, uint256 _amount) internal override {\n        usdc.mint(_account, _amount);\n    \n```\n\nOn the following condition in the native USDC contract\n\n<https://github.com/circlefin/stablecoin-evm/blob/0828084aec860712531e8d79fde478927a34b3f4/contracts/v1/FiatTokenV1.sol#L133-L136>\n\n```solidity\n        require(\n            _amount <= mintingAllowedAmount,\n            \"FiatToken: mint amount exceeds minterAllowance\"\n        );\n```\n\nCourse of events that ends in locked funds:\n\n1.  User bridges USDC from L2->L1\n2.  The message is recalled from L1\n3.  The USDCAdapter has reached the `mintingAllowedAmount`\n4.  The recalled message is stuck because minting reverts. The USDC and ETH passed in are both locked.\n\n### Tools Used\n\nFoundry, VScode\n\n### Recommended Mitigation Steps\n\nAdd new functionality in the vault that allows users to send a new message to the destination chain again with new message data if `onMessageRecalls()` can not mint tokens. We give users the ability to redeem for canonical tokens instead of being stuck.\n\n\n**[dantaik (Taiko) acknowledged and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/279#issuecomment-2033383461):**\n > Thank you for your feedback. In your example, if the user cannot mint tokens in USDCAdapter by using `recallMessage`, the user can wait and call `recallMessage` again.  That's why recallMessage is _retriable_. \n> \n> There is no perfect solution here, and I personally don't want to make the bridge too complicated by introducing this re-send-another-message feature.\n> \n> Adding a warning on the bridge UI to show a warning message might be a good solution, something like \"USDC on Taiko has reached 95% of its max supply cap, bridging USDC to Taiko may end up your fund becoming unavailable for some time until others bridge USDC away from Taiko\".\n> \n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/279#issuecomment-2049345554):**\n > The sponsor comments simply show their isn't a great solution to the problem, it still represents a loss of user funds (if it goes on forever) or a  denial of service and a risk that users should be aware of. \n> \n> @dontonka / @adaki2004 (Taiko) any last comments here?\n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/279#issuecomment-2049448918):**\n> We are OK with med, no issue. Please proceed accordinlgy - as we dont have:\n> 1. the perfect solution to the problem\n> 2. the intention to fix it ATM - since we wont be using any native tokens anytime soon.\n> \n> But please proceed the way which is suitable for the wardens better, we appreciate their efforts. (So not questioning the severity)\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/tokenvault/ERC20Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../libs/LibAddress.sol\";\nimport \"./BridgedERC20.sol\";\nimport \"./BaseVault.sol\";\n\n/// @title ERC20Vault\n/// @notice This vault holds all ERC20 tokens (excluding Ether) that users have\n/// deposited. It also manages the mapping between canonical ERC20 tokens and\n/// their bridged tokens.\n/// @dev Labeled in AddressResolver as \"erc20_vault\".\n/// @custom:security-contact security@taiko.xyz\ncontract ERC20Vault is BaseVault {\n    using LibAddress for address;\n    using SafeERC20 for IERC20;\n\n    /// @dev Represents a canonical ERC20 token.\n    struct CanonicalERC20 {\n        uint64 chainId;\n        address addr;\n        uint8 decimals;\n        string symbol;\n        string name;\n    }\n\n    /// @dev Represents an operation to send tokens to another chain.\n    struct BridgeTransferOp {\n        uint64 destChainId;\n        address destOwner;\n        address to;\n        address token;\n        uint256 amount;\n        uint256 gasLimit;\n        uint256 fee;\n        address refundTo;\n        string memo;\n    }\n\n    /// @notice Mappings from bridged tokens to their canonical tokens.\n    mapping(address btoken => CanonicalERC20 canonical) public bridgedToCanonical;\n\n    /// @notice Mappings from canonical tokens to their bridged tokens. Also storing\n    /// the chainId for tokens across other chains aside from Ethereum.\n    mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged;\n\n    /// @notice Mappings from bridged tokens to their blacklist status.\n    mapping(address btoken => bool blacklisted) public btokenBlacklist;\n\n    uint256[47] private __gap;\n\n    /// @notice Emitted when a new bridged token is deployed.\n    /// @param srcChainId The chain ID of the canonical token.\n    /// @param ctoken The address of the canonical token.\n    /// @param btoken The address of the bridged token.\n    /// @param ctokenSymbol The symbol of the canonical token.\n    /// @param ctokenName The name of the canonical token.\n    /// @param ctokenDecimal The decimal of the canonical token.\n    event BridgedTokenDeployed(\n        uint256 indexed srcChainId,\n        address indexed ctoken,\n        address indexed btoken,\n        string ctokenSymbol,\n        string ctokenName,\n        uint8 ctokenDecimal\n    );\n\n    /// @notice Emitted when a bridged token is changed.\n    /// @param srcChainId The chain ID of the canonical token.\n    /// @param ctoken The address of the canonical token.\n    /// @param btokenOld The address of the old bridged token.\n    /// @param btokenNew The address of the new bridged token.\n    /// @param ctokenSymbol The symbol of the canonical token.\n    /// @param ctokenName The name of the canonical token.\n    /// @param ctokenDecimal The decimal of the canonical token.\n    event BridgedTokenChanged(\n        uint256 indexed srcChainId,\n        address indexed ctoken,\n        address btokenOld,\n        address btokenNew,\n        string ctokenSymbol,\n        string ctokenName,\n        uint8 ctokenDecimal\n    );\n\n    /// @notice Emitted when a token is sent to another chain.\n    /// @param msgHash The hash of the message.\n    /// @param from The address of the sender.\n    /// @param to The address of the recipient.\n    /// @param destChainId The chain ID of the destination chain.\n    /// @param ctoken The address of the canonical token.\n    /// @param token The address of the bridged token.\n    /// @param amount The amount of tokens sent.\n    event TokenSent(\n        bytes32 indexed msgHash,\n        address indexed from,\n        address indexed to,\n        uint64 destChainId,\n        address ctoken,\n        address token,\n        uint256 amount\n    );\n\n    /// @notice Emitted when a token is released from a message.\n    /// @param msgHash The hash of the message.\n    /// @param from The address of the sender.\n    /// @param ctoken The address of the canonical token.\n    /// @param token The address of the bridged token.\n    /// @param amount The amount of tokens released.\n    event TokenReleased(\n        bytes32 indexed msgHash, address indexed from, address ctoken, address token, uint256 amount\n    );\n\n    /// @notice Emitted when a token is received from another chain.\n    /// @param msgHash The hash of the message.\n    /// @param from The address of the sender.\n    /// @param to The address of the recipient.\n    /// @param srcChainId The chain ID of the source chain.\n    /// @param ctoken The address of the canonical token.\n    /// @param token The address of the bridged token.\n    /// @param amount The amount of tokens received.\n    event TokenReceived(\n        bytes32 indexed msgHash,\n        address indexed from,\n        address indexed to,\n        uint64 srcChainId,\n        address ctoken,\n        address token,\n        uint256 amount\n    );\n\n    error VAULT_BTOKEN_BLACKLISTED();\n    error VAULT_CTOKEN_MISMATCH();\n    error VAULT_INVALID_TOKEN();\n    error VAULT_INVALID_AMOUNT();\n    error VAULT_INVALID_NEW_BTOKEN();\n    error VAULT_INVALID_TO();\n    error VAULT_NOT_SAME_OWNER();\n\n    /// @notice Change bridged token.\n    /// @param _ctoken The canonical token.\n    /// @param _btokenNew The new bridged token address.\n    /// @return btokenOld_ The old bridged token address.\n    function changeBridgedToken(\n        CanonicalERC20 calldata _ctoken,\n        address _btokenNew\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        onlyOwner\n        returns (address btokenOld_)\n    {\n        if (_btokenNew == address(0) || bridgedToCanonical[_btokenNew].addr != address(0)) {\n            revert VAULT_INVALID_NEW_BTOKEN();\n        }\n\n        if (btokenBlacklist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED();\n\n        if (IBridgedERC20(_btokenNew).owner() != owner()) {\n            revert VAULT_NOT_SAME_OWNER();\n        }\n\n        btokenOld_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];\n\n        if (btokenOld_ != address(0)) {\n            CanonicalERC20 memory ctoken = bridgedToCanonical[btokenOld_];\n\n            // The ctoken must match the saved one.\n            if (\n                ctoken.decimals != _ctoken.decimals\n                    || keccak256(bytes(ctoken.symbol)) != keccak256(bytes(_ctoken.symbol))\n                    || keccak256(bytes(ctoken.name)) != keccak256(bytes(_ctoken.name))\n            ) revert VAULT_CTOKEN_MISMATCH();\n\n            delete bridgedToCanonical[_btokenNew];\n            btokenBlacklist[btokenOld_] = true;\n\n            // Start the migration\n            IBridgedERC20(btokenOld_).changeMigrationStatus(_btokenNew, false);\n            IBridgedERC20(_btokenNew).changeMigrationStatus(btokenOld_, true);\n        }\n\n        bridgedToCanonical[_btokenNew] = _ctoken;\n        canonicalToBridged[_ctoken.chainId][_ctoken.addr] = _btokenNew;\n\n        emit BridgedTokenChanged({\n            srcChainId: _ctoken.chainId,\n            ctoken: _ctoken.addr,\n            btokenOld: btokenOld_,\n            btokenNew: _btokenNew,\n            ctokenSymbol: _ctoken.symbol,\n            ctokenName: _ctoken.name,\n            ctokenDecimal: _ctoken.decimals\n        });\n    }\n\n    /// @notice Transfers ERC20 tokens to this vault and sends a message to the\n    /// destination chain so the user can receive the same amount of tokens by\n    /// invoking the message call.\n    /// @param _op Option for sending ERC20 tokens.\n    /// @return message_ The constructed message.\n    function sendToken(BridgeTransferOp calldata _op)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        returns (IBridge.Message memory message_)\n    {\n        if (_op.amount == 0) revert VAULT_INVALID_AMOUNT();\n        if (_op.token == address(0)) revert VAULT_INVALID_TOKEN();\n        if (btokenBlacklist[_op.token]) revert VAULT_BTOKEN_BLACKLISTED();\n\n        (bytes memory data, CanonicalERC20 memory ctoken, uint256 balanceChange) =\n            _handleMessage(msg.sender, _op.token, _op.to, _op.amount);\n\n        IBridge.Message memory message = IBridge.Message({\n            id: 0, // will receive a new value\n            from: address(0), // will receive a new value\n            srcChainId: 0, // will receive a new value\n            destChainId: _op.destChainId,\n            srcOwner: msg.sender,\n            destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,\n            to: resolve(_op.destChainId, name(), false),\n            refundTo: _op.refundTo,\n            value: msg.value - _op.fee,\n            fee: _op.fee,\n            gasLimit: _op.gasLimit,\n            data: data,\n            memo: _op.memo\n        });\n\n        bytes32 msgHash;\n        (msgHash, message_) =\n            IBridge(resolve(\"bridge\", false)).sendMessage{ value: msg.value }(message);\n\n        emit TokenSent({\n            msgHash: msgHash,\n            from: message_.srcOwner,\n            to: _op.to,\n            destChainId: _op.destChainId,\n            ctoken: ctoken.addr,\n            token: _op.token,\n            amount: balanceChange\n        });\n    }\n\n    /// @inheritdoc IMessageInvocable\n    function onMessageInvocation(bytes calldata _data)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n    {\n        (CanonicalERC20 memory ctoken, address from, address to, uint256 amount) =\n            abi.decode(_data, (CanonicalERC20, address, address, uint256));\n\n        // `onlyFromBridge` checked in checkProcessMessageContext\n        IBridge.Context memory ctx = checkProcessMessageContext();\n\n        // Don't allow sending to disallowed addresses.\n        // Don't send the tokens back to `from` because `from` is on the source chain.\n        if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();\n\n        // Transfer the ETH and the tokens to the `to` address\n        address token = _transferTokens(ctoken, to, amount);\n        to.sendEther(msg.value);\n\n        emit TokenReceived({\n            msgHash: ctx.msgHash,\n            from: from,\n            to: to,\n            srcChainId: ctx.srcChainId,\n            ctoken: ctoken.addr,\n            token: token,\n            amount: amount\n        });\n    }\n\n    /// @inheritdoc IRecallableSender\n    function onMessageRecalled(\n        IBridge.Message calldata _message,\n        bytes32 _msgHash\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n    {\n        // `onlyFromBridge` checked in checkRecallMessageContext\n        checkRecallMessageContext();\n\n        (bytes memory data) = abi.decode(_message.data[4:], (bytes));\n        (CanonicalERC20 memory ctoken,,, uint256 amount) =\n            abi.decode(data, (CanonicalERC20, address, address, uint256));\n\n        // Transfer the ETH and tokens back to the owner\n        address token = _transferTokens(ctoken, _message.srcOwner, amount);\n        _message.srcOwner.sendEther(_message.value);\n\n        emit TokenReleased({\n            msgHash: _msgHash,\n            from: _message.srcOwner,\n            ctoken: ctoken.addr,\n            token: token,\n            amount: amount\n        });\n    }\n\n    /// @inheritdoc BaseVault\n    function name() public pure override returns (bytes32) {\n        return \"erc20_vault\";\n    }\n\n    function _transferTokens(\n        CanonicalERC20 memory _ctoken,\n        address _to,\n        uint256 _amount\n    )\n        private\n        returns (address token_)\n    {\n        if (_ctoken.chainId == block.chainid) {\n            token_ = _ctoken.addr;\n            IERC20(token_).safeTransfer(_to, _amount);\n        } else {\n            token_ = _getOrDeployBridgedToken(_ctoken);\n            IBridgedERC20(token_).mint(_to, _amount);\n        }\n    }\n\n    /// @dev Handles the message on the source chain and returns the encoded\n    /// call on the destination call.\n    /// @param _user The user's address.\n    /// @param _token The token address.\n    /// @param _to To address.\n    /// @param _amount Amount to be sent.\n    /// @return msgData_ Encoded message data.\n    /// @return ctoken_ The canonical token.\n    /// @return balanceChange_ User token balance actual change after the token\n    /// transfer. This value is calculated so we do not assume token balance\n    /// change is the amount of token transferred away.\n    function _handleMessage(\n        address _user,\n        address _token,\n        address _to,\n        uint256 _amount\n    )\n        private\n        returns (bytes memory msgData_, CanonicalERC20 memory ctoken_, uint256 balanceChange_)\n    {\n        // If it's a bridged token\n        if (bridgedToCanonical[_token].addr != address(0)) {\n            ctoken_ = bridgedToCanonical[_token];\n            IBridgedERC20(_token).burn(msg.sender, _amount);\n            balanceChange_ = _amount;\n        } else {\n            // If it's a canonical token\n            IERC20Metadata meta = IERC20Metadata(_token);\n            ctoken_ = CanonicalERC20({\n                chainId: uint64(block.chainid),\n                addr: _token,\n                decimals: meta.decimals(),\n                symbol: meta.symbol(),\n                name: meta.name()\n            });\n\n            // Query the balance then query it again to get the actual amount of\n            // token transferred into this address, this is more accurate than\n            // simply using `amount` -- some contract may deduct a fee from the\n            // transferred amount.\n            IERC20 t = IERC20(_token);\n            uint256 _balance = t.balanceOf(address(this));\n            t.safeTransferFrom({ from: msg.sender, to: address(this), value: _amount });\n            balanceChange_ = t.balanceOf(address(this)) - _balance;\n        }\n\n        msgData_ = abi.encodeCall(\n            this.onMessageInvocation, abi.encode(ctoken_, _user, _to, balanceChange_)\n        );\n    }\n\n    /// @dev Retrieve or deploy a bridged ERC20 token contract.\n    /// @param ctoken CanonicalERC20 data.\n    /// @return btoken Address of the bridged token contract.\n    function _getOrDeployBridgedToken(CanonicalERC20 memory ctoken)\n        private\n        returns (address btoken)\n    {\n        btoken = canonicalToBridged[ctoken.chainId][ctoken.addr];\n\n        if (btoken == address(0)) {\n            btoken = _deployBridgedToken(ctoken);\n        }\n    }\n\n    /// @dev Deploy a new BridgedERC20 contract and initialize it.\n    /// This must be called before the first time a bridged token is sent to\n    /// this chain.\n    /// @param ctoken CanonicalERC20 data.\n    /// @return btoken Address of the deployed bridged token contract.\n    function _deployBridgedToken(CanonicalERC20 memory ctoken) private returns (address btoken) {\n        bytes memory data = abi.encodeCall(\n            BridgedERC20.init,\n            (\n                owner(),\n                addressManager,\n                ctoken.addr,\n                ctoken.chainId,\n                ctoken.decimals,\n                ctoken.symbol,\n                ctoken.name\n            )\n        );\n\n        btoken = address(new ERC1967Proxy(resolve(\"bridged_erc20\", false), data));\n        bridgedToCanonical[btoken] = ctoken;\n        canonicalToBridged[ctoken.chainId][ctoken.addr] = btoken;\n\n        emit BridgedTokenDeployed({\n            srcChainId: ctoken.chainId,\n            ctoken: ctoken.addr,\n            btoken: btoken,\n            ctokenSymbol: ctoken.symbol,\n            ctokenName: ctoken.name,\n            ctokenDecimal: ctoken.decimals\n        });\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../BridgedERC20Base.sol\";\n\n/// @title IUSDC\n/// @custom:security-contact security@taiko.xyz\ninterface IUSDC {\n    /// @notice Burns a specific amount of tokens.\n    /// @param _amount The amount of token to be burned.\n    function burn(uint256 _amount) external;\n\n    /// @notice Mints a specific amount of new tokens to an address.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _amount The amount of tokens to mint.\n    function mint(address _to, uint256 _amount) external;\n\n    /// @notice Transfers tokens from one address to another.\n    /// @param from The address which you want to send tokens from.\n    /// @param _to The address which you want to transfer to.\n    /// @param _amount The amount of tokens to be transferred.\n    /// @return true if the transfer was successful, otherwise false.\n    function transferFrom(address from, address _to, uint256 _amount) external returns (bool);\n}\n\n/// @title USDCAdapter\n/// @custom:security-contact security@taiko.xyz\ncontract USDCAdapter is BridgedERC20Base {\n    /// @notice The USDC instance.\n    /// @dev Slot 1.\n    IUSDC public usdc;\n    uint256[49] private __gap;\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    /// @param _usdc The USDC instance.\n    function init(address _owner, address _addressManager, IUSDC _usdc) external initializer {\n        __Essential_init(_owner, _addressManager);\n        usdc = _usdc;\n    }\n\n    function _mintToken(address _account, uint256 _amount) internal override {\n        usdc.mint(_account, _amount);\n    }\n\n    function _burnToken(address _from, uint256 _amount) internal override {\n        usdc.transferFrom(_from, address(this), _amount);\n        usdc.burn(_amount);\n    }\n}"
    },
    {
      "filename": "contracts/v1/FiatTokenV1.sol",
      "content": "/**\n * SPDX-License-Identifier: Apache-2.0\n *\n * Copyright (c) 2023, Circle Internet Financial, LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.6.12;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { AbstractFiatTokenV1 } from \"./AbstractFiatTokenV1.sol\";\nimport { Ownable } from \"./Ownable.sol\";\nimport { Pausable } from \"./Pausable.sol\";\nimport { Blacklistable } from \"./Blacklistable.sol\";\n\n/**\n * @title FiatToken\n * @dev ERC20 Token backed by fiat reserves\n */\ncontract FiatTokenV1 is AbstractFiatTokenV1, Ownable, Pausable, Blacklistable {\n    using SafeMath for uint256;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    string public currency;\n    address public masterMinter;\n    bool internal initialized;\n\n    /// @dev A mapping that stores the balance and blacklist states for a given address.\n    /// The first bit defines whether the address is blacklisted (1 if blacklisted, 0 otherwise).\n    /// The last 255 bits define the balance for the address.\n    mapping(address => uint256) internal balanceAndBlacklistStates;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    uint256 internal totalSupply_ = 0;\n    mapping(address => bool) internal minters;\n    mapping(address => uint256) internal minterAllowed;\n\n    event Mint(address indexed minter, address indexed to, uint256 amount);\n    event Burn(address indexed burner, uint256 amount);\n    event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);\n    event MinterRemoved(address indexed oldMinter);\n    event MasterMinterChanged(address indexed newMasterMinter);\n\n    /**\n     * @notice Initializes the fiat token contract.\n     * @param tokenName       The name of the fiat token.\n     * @param tokenSymbol     The symbol of the fiat token.\n     * @param tokenCurrency   The fiat currency that the token represents.\n     * @param tokenDecimals   The number of decimals that the token uses.\n     * @param newMasterMinter The masterMinter address for the fiat token.\n     * @param newPauser       The pauser address for the fiat token.\n     * @param newBlacklister  The blacklister address for the fiat token.\n     * @param newOwner        The owner of the fiat token.\n     */\n    function initialize(\n        string memory tokenName,\n        string memory tokenSymbol,\n        string memory tokenCurrency,\n        uint8 tokenDecimals,\n        address newMasterMinter,\n        address newPauser,\n        address newBlacklister,\n        address newOwner\n    ) public {\n        require(!initialized, \"FiatToken: contract is already initialized\");\n        require(\n            newMasterMinter != address(0),\n            \"FiatToken: new masterMinter is the zero address\"\n        );\n        require(\n            newPauser != address(0),\n            \"FiatToken: new pauser is the zero address\"\n        );\n        require(\n            newBlacklister != address(0),\n            \"FiatToken: new blacklister is the zero address\"\n        );\n        require(\n            newOwner != address(0),\n            \"FiatToken: new owner is the zero address\"\n        );\n\n        name = tokenName;\n        symbol = tokenSymbol;\n        currency = tokenCurrency;\n        decimals = tokenDecimals;\n        masterMinter = newMasterMinter;\n        pauser = newPauser;\n        blacklister = newBlacklister;\n        setOwner(newOwner);\n        initialized = true;\n    }\n\n    /**\n     * @dev Throws if called by any account other than a minter.\n     */\n    modifier onlyMinters() {\n        require(minters[msg.sender], \"FiatToken: caller is not a minter\");\n        _;\n    }\n\n    /**\n     * @notice Mints fiat tokens to an address.\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of the caller.\n     * @return True if the operation was successful.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        whenNotPaused\n        onlyMinters\n        notBlacklisted(msg.sender)\n        notBlacklisted(_to)\n        returns (bool)\n    {\n        require(_to != address(0), \"FiatToken: mint to the zero address\");\n        require(_amount > 0, \"FiatToken: mint amount not greater than 0\");\n\n        uint256 mintingAllowedAmount = minterAllowed[msg.sender];\n        require(\n            _amount <= mintingAllowedAmount,\n            \"FiatToken: mint amount exceeds minterAllowance\"\n        );\n\n        totalSupply_ = totalSupply_.add(_amount);\n        _setBalance(_to, _balanceOf(_to).add(_amount));\n        minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount);\n        emit Mint(msg.sender, _to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the masterMinter\n     */\n    modifier onlyMasterMinter() {\n        require(\n            msg.sender == masterMinter,\n            \"FiatToken: caller is not the masterMinter\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Gets the minter allowance for an account.\n     * @param minter The address to check.\n     * @return The remaining minter allowance for the account.\n     */\n    function minterAllowance(address minter) external view returns (uint256) {\n        return minterAllowed[minter];\n    }\n\n    /**\n     * @notice Checks if an account is a minter.\n     * @param account The address to check.\n     * @return True if the account is a minter, false if the account is not a minter.\n     */\n    function isMinter(address account) external view returns (bool) {\n        return minters[account];\n    }\n\n    /**\n     * @notice Gets the remaining amount of fiat tokens a spender is allowed to transfer on\n     * behalf of the token owner.\n     * @param owner   The token owner's address.\n     * @param spender The spender's address.\n     * @return The remaining allowance.\n     */\n    function allowance(address owner, address spender)\n        external\n        override\n        view\n        returns (uint256)\n    {\n        return allowed[owner][spender];\n    }\n\n    /**\n     * @notice Gets the totalSupply of the fiat token.\n     * @return The totalSupply of the fiat token.\n     */\n    function totalSupply() external override view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @notice Gets the fiat token balance of an account.\n     * @param account  The address to check.\n     * @return balance The fiat token balance of the account.\n     */\n    function balanceOf(address account)\n        external\n        override\n        view\n        returns (uint256)\n    {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @notice Sets a fiat token allowance for a spender to spend on behalf of the caller.\n     * @param spender The spender's address.\n     * @param value   The allowance amount.\n     * @return True if the operation was successful.\n     */\n    function approve(address spender, uint256 value)\n        external\n        virtual\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(spender)\n        returns (bool)\n    {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Internal function to set allowance.\n     * @param owner     Token owner's address.\n     * @param spender   Spender's address.\n     * @param value     Allowance amount.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal override {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @notice Transfers tokens from an address to another by spending the caller's allowance.\n     * @dev The caller must have some fiat token allowance on the payer's tokens.\n     * @param from  Payer's address.\n     * @param to    Payee's address.\n     * @param value Transfer amount.\n     * @return True if the operation was successful.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(from)\n        notBlacklisted(to)\n        returns (bool)\n    {\n        require(\n            value <= allowed[from][msg.sender],\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        _transfer(from, to, value);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        return true;\n    }\n\n    /**\n     * @notice Transfers tokens from the caller.\n     * @param to    Payee's address.\n     * @param value Transfer amount.\n     * @return True if the operation was successful.\n     */\n    function transfer(address to, uint256 value)\n        external\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(to)\n        returns (bool)\n    {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Internal function to process transfers.\n     * @param from  Payer's address.\n     * @param to    Payee's address.\n     * @param value Transfer amount.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(\n            value <= _balanceOf(from),\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n        _setBalance(from, _balanceOf(from).sub(value));\n        _setBalance(to, _balanceOf(to).add(value));\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @notice Adds or updates a new minter with a mint allowance.\n     * @param minter The address of the minter.\n     * @param minterAllowedAmount The minting amount allowed for the minter.\n     * @return True if the operation was successful.\n     */\n    function configureMinter(address minter, uint256 minterAllowedAmount)\n        external\n        whenNotPaused\n        onlyMasterMinter\n        returns (bool)\n    {\n        minters[minter] = true;\n        minterAllowed[minter] = minterAllowedAmount;\n        emit MinterConfigured(minter, minterAllowedAmount);\n        return true;\n    }\n\n    /**\n     * @notice Removes a minter.\n     * @param minter The address of the minter to remove.\n     * @return True if the operation was successful.\n     */\n    function removeMinter(address minter)\n        external\n        onlyMasterMinter\n        returns (bool)\n    {\n        minters[minter] = false;\n        minterAllowed[minter] = 0;\n        emit MinterRemoved(minter);\n        return true;\n    }\n\n    /**\n     * @notice Allows a minter to burn some of its own tokens.\n     * @dev The caller must be a minter, must not be blacklisted, and the amount to burn\n     * should be less than or equal to the account's balance.\n     * @param _amount the amount of tokens to be burned.\n     */\n    function burn(uint256 _amount)\n        external\n        whenNotPaused\n        onlyMinters\n        notBlacklisted(msg.sender)\n    {\n        uint256 balance = _balanceOf(msg.sender);\n        require(_amount > 0, \"FiatToken: burn amount not greater than 0\");\n        require(balance >= _amount, \"FiatToken: burn amount exceeds balance\");\n\n        totalSupply_ = totalSupply_.sub(_amount);\n        _setBalance(msg.sender, balance.sub(_amount));\n        emit Burn(msg.sender, _amount);\n        emit Transfer(msg.sender, address(0), _amount);\n    }\n\n    /**\n     * @notice Updates the master minter address.\n     * @param _newMasterMinter The address of the new master minter.\n     */\n    function updateMasterMinter(address _newMasterMinter) external onlyOwner {\n        require(\n            _newMasterMinter != address(0),\n            \"FiatToken: new masterMinter is the zero address\"\n        );\n        masterMinter = _newMasterMinter;\n        emit MasterMinterChanged(masterMinter);\n    }\n\n    /**\n     * @inheritdoc Blacklistable\n     */\n    function _blacklist(address _account) internal override {\n        _setBlacklistState(_account, true);\n    }\n\n    /**\n     * @inheritdoc Blacklistable\n     */\n    function _unBlacklist(address _account) internal override {\n        _setBlacklistState(_account, false);\n    }\n\n    /**\n     * @dev Helper method that sets the blacklist state of an account.\n     * @param _account         The address of the account.\n     * @param _shouldBlacklist True if the account should be blacklisted, false if the account should be unblacklisted.\n     */\n    function _setBlacklistState(address _account, bool _shouldBlacklist)\n        internal\n        virtual\n    {\n        _deprecatedBlacklisted[_account] = _shouldBlacklist;\n    }\n\n    /**\n     * @dev Helper method that sets the balance of an account.\n     * @param _account The address of the account.\n     * @param _balance The new fiat token balance of the account.\n     */\n    function _setBalance(address _account, uint256 _balance) internal virtual {\n        balanceAndBlacklistStates[_account] = _balance;\n    }\n\n    /**\n     * @inheritdoc Blacklistable\n     */\n    function _isBlacklisted(address _account)\n        internal\n        virtual\n        override\n        view\n        returns (bool)\n    {\n        return _deprecatedBlacklisted[_account];\n    }\n\n    /**\n     * @dev Helper method to obtain the balance of an account.\n     * @param _account  The address of the account.\n     * @return          The fiat token balance of the account.\n     */\n    function _balanceOf(address _account)\n        internal\n        virtual\n        view\n        returns (uint256)\n    {\n        return balanceAndBlacklistStates[_account];\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/tokenvault/ERC20Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../bridge/IBridge.sol\";\nimport \"../libs/LibAddress.sol\";\nimport \"./BridgedERC20.sol\";\nimport \"./BaseVault.sol\";\n\n/// @title ERC20Vault\n/// @notice This vault holds all ERC20 tokens (excluding Ether) that users have\n/// deposited. It also manages the mapping between canonical ERC20 tokens and\n/// their bridged tokens.\n/// @dev Labe"
    }
  ]
}