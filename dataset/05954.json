{
  "Title": "[11] TODOs included in code/comments",
  "Content": "\nEx. `LendingLedger.sol`, line 48 and `GaugeController.sol` line 59\n\n[https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/LendingLedger.sol#L48](https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/LendingLedger.sol#L48)\n\n[https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/GaugeController.sol#L59](https://github.com/code-423n4/2023-08-verwa/blob/a693b4db05b9e202816346a6f9cada94f28a2698/src/GaugeController.sol#L59)\n\n```solidity\ngovernance = _governance; // TODO: Maybe change to Oracle\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-verwa",
  "Code": [
    {
      "filename": "src/LendingLedger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {GaugeController} from \"./GaugeController.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract LendingLedger {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n\n    // State\n    address public governance;\n    GaugeController public gaugeController;\n    mapping(address => bool) public lendingMarketWhitelist;\n    /// @dev Lending Market => Lender => Epoch => Balance\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public lendingMarketBalances; // cNote balances of users within the lending markets, indexed by epoch\n    /// @dev Lending Market => Lender => Epoch\n    mapping(address => mapping(address => uint256)) public lendingMarketBalancesEpoch; // Epoch when the last update happened\n    /// @dev Lending Market => Epoch => Balance\n    mapping(address => mapping(uint256 => uint256)) public lendingMarketTotalBalance; // Total balance locked within the market, i.e. sum of lendingMarketBalances for all\n    /// @dev Lending Market => Epoch\n    mapping(address => uint256) public lendingMarketTotalBalanceEpoch; // Epoch when the last update happened\n\n    /// @dev Lending Market => Lender => Epoch\n    mapping(address => mapping(address => uint256)) public userClaimedEpoch; // Until which epoch a user has claimed for a particular market (exclusive this value)\n\n    struct RewardInformation {\n        bool set;\n        uint248 amount;\n    }\n    mapping(uint256 => RewardInformation) public rewardInformation;\n\n    /// @notice Check that a provided timestamp is a valid epoch (divisible by WEEK) or infinity\n    /// @param _timestamp Timestamp to check\n    modifier is_valid_epoch(uint256 _timestamp) {\n        require(_timestamp % WEEK == 0 || _timestamp == type(uint256).max, \"Invalid timestamp\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    constructor(address _gaugeController, address _governance) {\n        gaugeController = GaugeController(_gaugeController);\n        governance = _governance; // TODO: Maybe change to Oracle\n    }\n\n    /// @notice Fill in gaps in the user market balances history (if any exist)\n    /// @param _market Address of the market\n    /// @param _lender Address of the lender\n    /// @param _forwardTimestampLimit Until which epoch (provided as timestamp) should the update be applied. If it is higher than the current epoch timestamp, this will be used.\n    function _checkpoint_lender(\n        address _market,\n        address _lender,\n        uint256 _forwardTimestampLimit\n    ) private {\n        uint256 currEpoch = (block.timestamp / WEEK) * WEEK;\n\n        uint256 lastUserUpdateEpoch = lendingMarketBalancesEpoch[_market][_lender];\n        uint256 updateUntilEpoch = Math.min(currEpoch, _forwardTimestampLimit);\n        if (lastUserUpdateEpoch == 0) {\n            // Store epoch of first deposit\n            userClaimedEpoch[_market][_lender] = currEpoch;\n            lendingMarketBalancesEpoch[_market][_lender] = currEpoch;\n        } else if (lastUserUpdateEpoch < currEpoch) {\n            // Fill in potential gaps in the user balances history\n            uint256 lastUserBalance = lendingMarketBalances[_market][_lender][lastUserUpdateEpoch];\n            for (uint256 i = lastUserUpdateEpoch; i <= updateUntilEpoch; i += WEEK) {\n                lendingMarketBalances[_market][_lender][i] = lastUserBalance;\n            }\n            if (updateUntilEpoch > lastUserUpdateEpoch) {\n                lendingMarketBalancesEpoch[_market][_lender] = updateUntilEpoch;\n            }\n        }\n    }\n\n    /// @notice Fill in gaps in the market total balances history (if any exist)\n    /// @param _market Address of the market\n    /// @param _forwardTimestampLimit Until which epoch (provided as timestamp) should the update be applied. If it is higher than the current epoch timestamp, this will be used.\n    function _checkpoint_market(address _market, uint256 _forwardTimestampLimit) private {\n        uint256 currEpoch = (block.timestamp / WEEK) * WEEK;\n        uint256 lastMarketUpdateEpoch = lendingMarketTotalBalanceEpoch[_market];\n        uint256 updateUntilEpoch = Math.min(currEpoch, _forwardTimestampLimit);\n        if (lastMarketUpdateEpoch == 0) {\n            lendingMarketTotalBalanceEpoch[_market] = currEpoch;\n        } else if (lastMarketUpdateEpoch < currEpoch) {\n            // Fill in potential gaps in the market total balances history\n            uint256 lastMarketBalance = lendingMarketTotalBalance[_market][lastMarketUpdateEpoch];\n            for (uint256 i = lastMarketUpdateEpoch; i <= updateUntilEpoch; i += WEEK) {\n                lendingMarketTotalBalance[_market][i] = lastMarketBalance;\n            }\n            if (updateUntilEpoch > lastMarketUpdateEpoch) {\n                // Only update epoch when we actually checkpointed to avoid decreases\n                lendingMarketTotalBalanceEpoch[_market] = updateUntilEpoch;\n            }\n        }\n    }\n\n    /// @notice Trigger a checkpoint explicitly.\n    ///     Never needs to be called explicitly, but could be used to ensure the checkpoints within the other functions consume less gas (because they need to forward less epochs)\n    /// @param _market Address of the market\n    /// @param _forwardTimestampLimit Until which epoch (provided as timestamp) should the update be applied. If it is higher than the current epoch timestamp, this will be used.\n    function checkpoint_market(address _market, uint256 _forwardTimestampLimit)\n        external\n        is_valid_epoch(_forwardTimestampLimit)\n    {\n        require(lendingMarketTotalBalanceEpoch[_market] > 0, \"No deposits for this market\");\n        _checkpoint_market(_market, _forwardTimestampLimit);\n    }\n\n    /// @param _market Address of the market\n    /// @param _lender Address of the lender\n    /// @param _forwardTimestampLimit Until which epoch (provided as timestamp) should the update be applied. If it is higher than the current epoch timestamp, this will be used.\n    function checkpoint_lender(\n        address _market,\n        address _lender,\n        uint256 _forwardTimestampLimit\n    ) external is_valid_epoch(_forwardTimestampLimit) {\n        require(lendingMarketBalancesEpoch[_market][_lender] > 0, \"No deposits for this lender in this market\");\n        _checkpoint_lender(_market, _lender, _forwardTimestampLimit);\n    }\n\n    /// @notice Function that is called by the lending market on cNOTE deposits / withdrawals\n    /// @param _lender The address of the lender\n    /// @param _delta The amount of cNote deposited (positive) or withdrawn (negative)\n    function sync_ledger(address _lender, int256 _delta) external {\n        address lendingMarket = msg.sender;\n        require(lendingMarketWhitelist[lendingMarket], \"Market not whitelisted\");\n\n        _checkpoint_lender(lendingMarket, _lender, type(uint256).max);\n        uint256 currEpoch = (block.timestamp / WEEK) * WEEK;\n        int256 updatedLenderBalance = int256(lendingMarketBalances[lendingMarket][_lender][currEpoch]) + _delta;\n        require(updatedLenderBalance >= 0, \"Lender balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketBalances[lendingMarket][_lender][currEpoch] = uint256(updatedLenderBalance);\n\n        _checkpoint_market(lendingMarket, type(uint256).max);\n        int256 updatedMarketBalance = int256(lendingMarketTotalBalance[lendingMarket][currEpoch]) + _delta;\n        require(updatedMarketBalance >= 0, \"Market balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketTotalBalance[lendingMarket][currEpoch] = uint256(updatedMarketBalance);\n    }\n\n    /// @notice Claim the CANTO for a given market. Can only be performed for prior (i.e. finished) epochs, not the current one\n    /// @param _market Address of the market\n    /// @param _claimFromTimestamp From which epoch (provided as timestmap) should the claim start. Usually, this parameter should be set to 0, in which case the epoch of the last claim will be used.\n    ///     However, it can be useful to skip certain epochs, e.g. when the balance was very low or 0 (after everything was withdrawn) and the gas usage should be reduced.\n    ///     Note that all rewards are forfeited forever if epochs are explicitly skipped by providing this parameter\n    /// @param _claimUpToTimestamp Until which epoch (provided as timestamp) should the claim be applied. If it is higher than the timestamp of the previous epoch, this will be used\n    ///     Set to type(uint256).max to claim all possible epochs\n    function claim(\n        address _market,\n        uint256 _claimFromTimestamp,\n        uint256 _claimUpToTimestamp\n    ) external is_valid_epoch(_claimFromTimestamp) is_valid_epoch(_claimUpToTimestamp) {\n        address lender = msg.sender;\n        uint256 userLastClaimed = userClaimedEpoch[_market][lender];\n        require(userLastClaimed > 0, \"No deposits for this user\");\n        _checkpoint_lender(_market, lender, _claimUpToTimestamp);\n        _checkpoint_market(_market, _claimUpToTimestamp);\n        uint256 currEpoch = (block.timestamp / WEEK) * WEEK;\n        uint256 claimStart = Math.max(userLastClaimed, _claimFromTimestamp);\n        uint256 claimEnd = Math.min(currEpoch - WEEK, _claimUpToTimestamp);\n        uint256 cantoToSend;\n        if (claimEnd >= claimStart) {\n            // This ensures that we only set userClaimedEpoch when a claim actually happened\n            for (uint256 i = claimStart; i <= claimEnd; i += WEEK) {\n                uint256 userBalance = lendingMarketBalances[_market][lender][i];\n                uint256 marketBalance = lendingMarketTotalBalance[_market][i];\n                RewardInformation memory ri = rewardInformation[i];\n                require(ri.set, \"Reward not set yet\"); // Can only claim for epochs where rewards are set, even if it is set to 0\n                uint256 marketWeight = gaugeController.gauge_relative_weight_write(_market, i); // Normalized to 1e18\n                cantoToSend += (marketWeight * userBalance * ri.amount) / (1e18 * marketBalance); // (marketWeight / 1e18) * (userBalance / marketBalance) * ri.amount;\n            }\n            userClaimedEpoch[_market][lender] = claimEnd + WEEK;\n        }\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: cantoToSend}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n\n    /// @notice Used by governance to set the overall CANTO rewards per epoch\n    /// @param _fromEpoch From which epoch (provided as timestamp) to set the rewards from\n    /// @param _toEpoch Until which epoch (provided as timestamp) to set the rewards to\n    /// @param _amountPerEpoch The amount per epoch\n    function setRewards(\n        uint256 _fromEpoch,\n        uint256 _toEpoch,\n        uint248 _amountPerEpoch\n    ) external is_valid_epoch(_fromEpoch) is_valid_epoch(_toEpoch) onlyGovernance {\n        for (uint256 i = _fromEpoch; i <= _toEpoch; i += WEEK) {\n            RewardInformation storage ri = rewardInformation[i];\n            require(!ri.set, \"Rewards already set\");\n            ri.set = true;\n            ri.amount = _amountPerEpoch;\n        }\n    }\n\n    /// @notice Used by governance to whitelist a lending market\n    /// @param _market Address of the market to whitelist\n    /// @param _isWhiteListed Whether the market is whitelisted or not\n    function whiteListLendingMarket(address _market, bool _isWhiteListed) external onlyGovernance {\n        require(lendingMarketWhitelist[_market] != _isWhiteListed, \"No change\");\n        lendingMarketWhitelist[_market] = _isWhiteListed;\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Gauge types removed (resulting in the removal of the differentiation between tracking of total / sum)\n///         - Different whitelisting of gauge addresses because of removed types\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewGauge(address indexed gauge_address);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n    mapping(address => bool) public isValidGauge;\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(uint256 => Point) points_sum;\n    mapping(uint256 => uint256) changes_sum;\n    uint256 public time_sum;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance; // TODO: Maybe change to Oracle\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_sum = last_epoch;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum() internal returns (uint256) {\n        uint256 t = time_sum;\n        Point memory pt = points_sum[t];\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            uint256 d_bias = pt.slope * WEEK;\n            if (pt.bias > d_bias) {\n                pt.bias -= d_bias;\n                uint256 d_slope = changes_sum[t];\n                pt.slope -= d_slope;\n            } else {\n                pt.bias = 0;\n                pt.slope = 0;\n            }\n            points_sum[t] = pt;\n            if (t > block.timestamp) time_sum = t;\n        }\n        return pt.bias;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param _gauge The gauge address\n    function add_gauge(address _gauge) external onlyGovernance {\n        require(!isValidGauge[_gauge], \"Gauge already exists\");\n        isValidGauge[_gauge] = true;\n        emit NewGauge(_gauge);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(isValidGauge[_gauge], \"Invalid gauge address\");\n        isValidGauge[_gauge] = false;\n        _change_gauge_weight(_gauge, 0);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_sum();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_sum();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_sum[t].bias;\n        if (total_weight > 0) {\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_sum();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n\n    /// @notice Allows governance to overwrite gauge weights\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {\n        _change_gauge_weight(_gauge, _weight);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(isValidGauge[_gauge_addr], \"Invalid gauge address\");\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int128 bias*/\n            int128 slope_, /*uint256 ts*/\n\n        ) = ve.getLastUserPoint(msg.sender);\n        require(slope_ >= 0, \"Invalid slope\");\n        uint256 slope = uint256(uint128(slope_));\n        uint256 lock_end = ve.lockEnd(msg.sender);\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n        require(lock_end > next_time, \"Lock expires too soon\");\n        VotedSlope memory old_slope = vote_user_slopes[msg.sender][_gauge_addr];\n        uint256 old_dt = 0;\n        if (old_slope.end > next_time) old_dt = old_slope.end - next_time;\n        uint256 old_bias = old_slope.slope * old_dt;\n        VotedSlope memory new_slope = VotedSlope({\n            slope: (slope * _user_weight) / 10_000,\n            end: lock_end,\n            power: _user_weight\n        });\n        uint256 new_dt = lock_end - next_time;\n        uint256 new_bias = new_slope.slope * new_dt;\n\n        // Check and update powers (weights) used\n        uint256 power_used = vote_user_power[msg.sender];\n        power_used = power_used + new_slope.power - old_slope.power;\n        require(power_used >= 0 && power_used <= 10_000, \"Used too much power\");\n        vote_user_power[msg.sender] = power_used;\n\n        // Remove old and schedule new slope changes\n        // Remove slope changes for old slopes\n        // Schedule recording of initial slope for next_time\n        uint256 old_weight_bias = _get_weight(_gauge_addr);\n        uint256 old_weight_slope = points_weight[_gauge_addr][next_time].slope;\n        uint256 old_sum_bias = _get_sum();\n        uint256 old_sum_slope = points_sum[next_time].slope;\n\n        points_weight[_gauge_addr][next_time].bias = Math.max(old_weight_bias + new_bias, old_bias) - old_bias;\n        points_sum[next_time].bias = Math.max(old_sum_bias + new_bias, old_bias) - old_bias;\n        if (old_slope.end > next_time) {\n            points_weight[_gauge_addr][next_time].slope =\n                Math.max(old_weight_slope + new_slope.slope, old_slope.slope) -\n                old_slope.slope;\n            points_sum[next_time].slope = Math.max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope;\n        } else {\n            points_weight[_gauge_addr][next_time].slope += new_slope.slope;\n            points_sum[next_time].slope += new_slope.slope;\n        }\n        if (old_slope.end > block.timestamp) {\n            // Cancel old slope changes if they still didn't happen\n            changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope;\n            changes_sum[old_slope.end] -= old_slope.slope;\n        }\n        // Add slope changes for new slopes\n        changes_weight[_gauge_addr][new_slope.end] += new_slope.slope;\n        changes_sum[new_slope.end] += new_slope.slope;\n\n        _get_sum();\n\n        vote_user_slopes[msg.sender][_gauge_addr] = new_slope;\n\n        // Record last action time\n        last_user_vote[msg.sender][_gauge_addr] = block.timestamp;\n    }\n\n    /// @notice Get current gauge weight\n    /// @param _gauge Gauge address\n    /// @return Gauge weight\n    function get_gauge_weight(address _gauge) external view returns (uint256) {\n        return points_weight[_gauge][time_weight[_gauge]].bias;\n    }\n\n    /// @notice Get total weight\n    /// @return Total weight\n    function get_total_weight() external view returns (uint256) {\n        return points_sum[time_sum].bias;\n    }\n}"
    }
  ]
}