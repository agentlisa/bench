{
  "Title": "[M-04] Proposal requiring native coin transfers cannot be executed",
  "Content": "\n### Lines of code\n\nProposals that require sending native coins in at least one of their calls cannot be executed.\n\n### Proof of Concept\n\nThe [InterchainProposalExecutor.\\_execute](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/interchain-governance-executor/InterchainProposalExecutor.sol#L41) executes cross-chain governance proposals. The function [extracts the list of calls to make under the proposal](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/interchain-governance-executor/InterchainProposalExecutor.sol#L54) and [calls `_executeProposal`](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/interchain-governance-executor/InterchainProposalExecutor.sol#L73). `_executeProposal`, in its turn, makes distinct calls and sends native coins along with each call as specified by the `call.value` argument:\n\n```solidity\n(bool success, bytes memory result) = call.target.call{ value: call.value }(call.callData);\n```\n\nHowever, `InterchainProposalExecutor._execute` is called from a non-payable function, [AxelarExecutable.execute](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/gmp-sdk/executable/AxelarExecutable.sol#L17), and thus native coins cannot be passed in the call. As a result, proposal calls that have the `value` argument greater than `0` cannot be executed.\n\nSending native funds to the contract in advance cannot be a solution because such funds can be stolen by back-running and executing a proposal that would consume them.\n\n### Recommended Mitigation Steps\n\nConsider implementing an alternative `AxelarExecutable` contract (i.e. `AxelarExecutablePayable`) that has the `execute` function payable and consider inheriting in `InterchainProposalExecutor` from this alternative implementation, not from `AxelarExecutable`.\n\n### Assessed type\n\nPayable\n\n**[deanamiel (Axelar) disputed and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/319#issuecomment-1678528117):**\n > The intention is for the contract that executes the proposal to have been already funded with native value. Native value is not meant to be sent with the call to `AxelarExecutable.execute()`.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/319#issuecomment-1702654158):**\n> The `InterchainProposalExecutor` contract, in line 20, states that this contract is abstract. The only derived contract in the repository is the `TestProposalExecutor` intended for testing purposes. @deanamiel - can you show the concrete implementation for such a derived contract that is going to be deployed?\n> \n> Given the code in scope, there would not be a `receive` function to be able to fund the contract with native tokens. This would render this submission valid.\n\n**[deanamiel (Axelar) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/319#issuecomment-1709224208):**\n > So it would be the contract that inherits `AxelarExecutable` that would need to be funded with native value for proposal execution. If we look at `InterchainGovernance` as an example, this contract does contain a receive function [here](https://github.com/axelarnetwork/axelar-gmp-sdk-solidity/blob/main/contracts/governance/InterchainGovernance.sol#L203). Does this answer your question?\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/319#issuecomment-1711476650):**\n> @deanamiel - the issue is that the `InterchainProposalExecutor` contract can not be funded with native funds, but attempts to execute proposals (target contracts) that potentially require native funds (see [L76](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/interchain-governance-executor/InterchainProposalExecutor.sol#L76)).\n> \n> I'm inclined to leave this submission as medium severity, as it does not allow using the `InterchainProposalExecutor` contract in conjunction with proposals that require native funds.\n\n**[milapsheth (Axelar) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/319#issuecomment-1801775763):**\n> We acknowledge the severity. The solution is to add a receive function as mentioned in [#344](https://github.com/code-423n4/2023-07-axelar-findings/issues/344), since the design expects to fund tokens to the contract and then execute. This funding `+` execution can be done within a contract atomically if there's a concern of another proposal stealing tokens.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/interchain-governance-executor/InterchainProposalExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { StringToAddress } from '../gmp-sdk/util/AddressString.sol';\nimport { AxelarExecutable } from '../gmp-sdk/executable/AxelarExecutable.sol';\nimport { IInterchainProposalExecutor } from './interfaces/IInterchainProposalExecutor.sol';\nimport { InterchainCalls } from './lib/InterchainCalls.sol';\n\n/**\n * @title InterchainProposalExecutor\n * @dev This contract is intended to be the destination contract for `InterchainProposalSender` contract.\n * The proposal will be finally executed from this contract on the destination chain.\n *\n * The contract maintains whitelists for proposal senders and proposal callers. Proposal senders\n * are InterchainProposalSender contracts at the source chain and proposal callers are contracts\n * that call the InterchainProposalSender at the source chain.\n * For most governance system, the proposal caller should be the Timelock contract.\n *\n * This contract is abstract and some of its functions need to be implemented in a derived contract.\n */\ncontract InterchainProposalExecutor is IInterchainProposalExecutor, AxelarExecutable, Ownable {\n    // Whitelisted proposal callers. The proposal caller is the contract that calls the `InterchainProposalSender` at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedCallers;\n\n    // Whitelisted proposal senders. The proposal sender is the `InterchainProposalSender` contract address at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedSenders;\n\n    constructor(address _gateway, address _owner) AxelarExecutable(_gateway) {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @dev Executes the proposal. The source address must be a whitelisted sender.\n     * @param sourceAddress The source address\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal override {\n        _beforeProposalExecuted(sourceChain, sourceAddress, payload);\n\n        // Check that the source address is whitelisted\n        if (!whitelistedSenders[sourceChain][StringToAddress.toAddress(sourceAddress)]) {\n            revert NotWhitelistedSourceAddress();\n        }\n\n        // Decode the payload\n        (address interchainProposalCaller, InterchainCalls.Call[] memory calls) = abi.decode(payload, (address, InterchainCalls.Call[]));\n\n        // Check that the caller is whitelisted\n        if (!whitelistedCallers[sourceChain][interchainProposalCaller]) {\n            revert NotWhitelistedCaller();\n        }\n\n        // Execute the proposal with the given arguments\n        _executeProposal(calls);\n\n        _onProposalExecuted(sourceChain, sourceAddress, interchainProposalCaller, payload);\n\n        emit ProposalExecuted(keccak256(abi.encode(sourceChain, sourceAddress, interchainProposalCaller, payload)));\n    }\n\n    /**\n     * @dev Executes the proposal. Calls each target with the respective value, signature, and data.\n     * @param calls The calls to execute.\n     */\n    function _executeProposal(InterchainCalls.Call[] memory calls) internal {\n        for (uint256 i = 0; i < calls.length; i++) {\n            InterchainCalls.Call memory call = calls[i];\n            (bool success, bytes memory result) = call.target.call{ value: call.value }(call.callData);\n\n            if (!success) {\n                _onTargetExecutionFailed(call, result);\n            } else {\n                _onTargetExecuted(call, result);\n            }\n        }\n    }\n\n    /**\n     * @dev Set the proposal caller whitelist status\n     * @param sourceChain The source chain\n     * @param sourceCaller The source caller\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalCaller(\n        string calldata sourceChain,\n        address sourceCaller,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedCallers[sourceChain][sourceCaller] = whitelisted;\n        emit WhitelistedProposalCallerSet(sourceChain, sourceCaller, whitelisted);\n    }\n\n    /**\n     * @dev Set the proposal sender whitelist status\n     * @param sourceChain The source chain\n     * @param sourceSender The source sender\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalSender(\n        string calldata sourceChain,\n        address sourceSender,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedSenders[sourceChain][sourceSender] = whitelisted;\n        emit WhitelistedProposalSenderSet(sourceChain, sourceSender, whitelisted);\n    }\n\n    /**\n     * @dev A callback function that is called before the proposal is executed.\n     * This function can be used to handle the payload before the proposal is executed.\n     * @param sourceChain The source chain from where the proposal was sent.\n     * @param sourceAddress The source address that sent the proposal. The source address should be the `InterchainProposalSender` contract address at the source chain.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, calldata.\n     */\n    function _beforeProposalExecuted(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload before the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called after the proposal is executed.\n     * This function emits an event containing the hash of the payload to signify successful execution.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _onProposalExecuted(\n        string calldata, /* sourceChain */\n        string calldata, /* sourceAddress */\n        address, /* caller */\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload after the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called when the execution of a target contract within a proposal fails.\n     * This function will revert the transaction providing the failure reason if present in the failure data.\n     * @param result The return data from the failed call to the target contract.\n     */\n    function _onTargetExecutionFailed(\n        InterchainCalls.Call memory, /* call */\n        bytes memory result\n    ) internal virtual {\n        // You can add your own logic here to handle the failure of the target contract execution. The code below is just an example.\n        if (result.length > 0) {\n            // The failure data is a revert reason string.\n            assembly {\n                revert(add(32, result), mload(result))\n            }\n        } else {\n            // There is no failure data, just revert with no reason.\n            revert ProposalExecuteFailed();\n        }\n    }\n\n    /**\n     * @dev Called after a target is successfully executed. The derived contract should implement this function.\n     * This function should do some post-execution work, such as emitting events.\n     * @param call The call that has been executed.\n     * @param result The result of the call.\n     */\n    function _onTargetExecuted(InterchainCalls.Call memory call, bytes memory result) internal virtual {\n        // You can add your own logic here to handle the success of each target contract execution.\n    }\n}"
    },
    {
      "filename": "contracts/gmp-sdk/executable/AxelarExecutable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\n\ncontract AxelarExecutable is IAxelarExecutable {\n    IAxelarGateway public immutable gateway;\n\n    constructor(address gateway_) {\n        if (gateway_ == address(0)) revert InvalidAddress();\n\n        gateway = IAxelarGateway(gateway_);\n    }\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash)) revert NotApprovedByGateway();\n\n        _execute(sourceChain, sourceAddress, payload);\n    }\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (!gateway.validateContractCallAndMint(commandId, sourceChain, sourceAddress, payloadHash, tokenSymbol, amount))\n            revert NotApprovedByGateway();\n\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\n    }\n\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {}\n\n    function _executeWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    {
      "filename": "contracts/governance/InterchainGovernance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AxelarExecutable } from '../executable/AxelarExecutable.sol';\nimport { TimeLock } from '../utils/TimeLock.sol';\nimport { SafeNativeTransfer } from '../libs/SafeNativeTransfer.sol';\nimport { IInterchainGovernance } from '../interfaces/IInterchainGovernance.sol';\nimport { Caller } from '../utils/Caller.sol';\n\n/**\n * @title Interchain Governance contract\n * @notice This contract handles cross-chain governance actions. It includes functionality\n * to create, cancel, and execute governance proposals.\n */\ncontract InterchainGovernance is AxelarExecutable, TimeLock, Caller, IInterchainGovernance {\n    using SafeNativeTransfer for address;\n\n    enum GovernanceCommand {\n        ScheduleTimeLockProposal,\n        CancelTimeLockProposal\n    }\n\n    string public governanceChain;\n    string public governanceAddress;\n    bytes32 public immutable governanceChainHash;\n    bytes32 public immutable governanceAddressHash;\n\n    /**\n     * @notice Initializes the contract\n     * @param gateway_ The address of the Axelar gateway contract\n     * @param governanceChain_ The name of the governance chain\n     * @param governanceAddress_ The address of the governance contract\n     * @param minimumTimeDelay The minimum time delay for timelock operations\n     */\n    constructor(\n        address gateway_,\n        string memory governanceChain_,\n        string memory governanceAddress_,\n        uint256 minimumTimeDelay\n    ) AxelarExecutable(gateway_) TimeLock(minimumTimeDelay) {\n        if (bytes(governanceChain_).length == 0 || bytes(governanceAddress_).length == 0) {\n            revert InvalidAddress();\n        }\n\n        governanceChain = governanceChain_;\n        governanceAddress = governanceAddress_;\n        governanceChainHash = keccak256(bytes(governanceChain_));\n        governanceAddressHash = keccak256(bytes(governanceAddress_));\n    }\n\n    /**\n     * @notice Modifier to check if the caller is the governance contract\n     * @param sourceChain The source chain of the proposal, must equal the governance chain\n     * @param sourceAddress The source address of the proposal, must equal the governance address\n     */\n    modifier onlyGovernance(string calldata sourceChain, string calldata sourceAddress) {\n        if (\n            keccak256(bytes(sourceChain)) != governanceChainHash ||\n            keccak256(bytes(sourceAddress)) != governanceAddressHash\n        ) revert NotGovernance();\n\n        _;\n    }\n\n    /**\n     * @notice Modifier to check if the caller is the contract itself\n     */\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /**\n     * @notice Returns the ETA of a proposal\n     * @param target The address of the contract targeted by the proposal\n     * @param callData The call data to be sent to the target contract\n     * @param nativeValue The amount of native tokens to be sent to the target contract\n     * @return uint256 The ETA of the proposal\n     */\n    function getProposalEta(\n        address target,\n        bytes calldata callData,\n        uint256 nativeValue\n    ) external view returns (uint256) {\n        return _getTimeLockEta(_getProposalHash(target, callData, nativeValue));\n    }\n\n    /**\n     * @notice Executes a proposal\n     * @dev The proposal is executed by calling the target contract with calldata. Native value is\n     * transferred with the call to the target contract.\n     * @param target The target address of the contract to call\n     * @param callData The data containing the function and arguments for the contract to call\n     * @param nativeValue The amount of native token to send to the target contract\n     */\n    function executeProposal(\n        address target,\n        bytes calldata callData,\n        uint256 nativeValue\n    ) external payable {\n        bytes32 proposalHash = _getProposalHash(target, callData, nativeValue);\n\n        _finalizeTimeLock(proposalHash);\n\n        emit ProposalExecuted(proposalHash, target, callData, nativeValue, block.timestamp);\n\n        _call(target, callData, nativeValue);\n    }\n\n    /**\n     * @notice Withdraws native token from the contract\n     * @param recipient The address to send the native token to\n     * @param amount The amount of native token to send\n     * @dev This function is only callable by the contract itself after passing according proposal\n     */\n    function withdraw(address recipient, uint256 amount) external onlySelf {\n        recipient.safeNativeTransfer(amount);\n    }\n\n    /**\n     * @notice Internal function to execute a proposal action\n     * @param sourceChain The source chain of the proposal, must equal the governance chain\n     * @param sourceAddress The source address of the proposal, must equal the governance address\n     * @param payload The payload of the proposal\n     */\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal override onlyGovernance(sourceChain, sourceAddress) {\n        (uint256 command, address target, bytes memory callData, uint256 nativeValue, uint256 eta) = abi.decode(\n            payload,\n            (uint256, address, bytes, uint256, uint256)\n        );\n\n        if (target == address(0)) revert InvalidTarget();\n\n        _processCommand(command, target, callData, nativeValue, eta);\n    }\n\n    /**\n     * @notice Internal function to process a governance command\n     * @param commandType The type of the command, 0 for proposal creation and 1 for proposal cancellation\n     * @param target The target address the proposal will call\n     * @param callData The data the encodes the function and arguments to call on the target contract\n     * @param nativeValue The nativeValue of native token to be sent to the target contract\n     * @param eta The time after which the proposal can be executed\n     */\n    function _processCommand(\n        uint256 commandType,\n        address target,\n        bytes memory callData,\n        uint256 nativeValue,\n        uint256 eta\n    ) internal virtual {\n        bytes32 proposalHash = _getProposalHash(target, callData, nativeValue);\n\n        if (commandType == uint256(GovernanceCommand.ScheduleTimeLockProposal)) {\n            eta = _scheduleTimeLock(proposalHash, eta);\n\n            emit ProposalScheduled(proposalHash, target, callData, nativeValue, eta);\n            return;\n        } else if (commandType == uint256(GovernanceCommand.CancelTimeLockProposal)) {\n            _cancelTimeLock(proposalHash);\n\n            emit ProposalCancelled(proposalHash, target, callData, nativeValue, eta);\n            return;\n        } else {\n            revert InvalidCommand();\n        }\n    }\n\n    /**\n     * @dev Get proposal hash using the target, callData, and nativeValue\n     */\n    function _getProposalHash(\n        address target,\n        bytes memory callData,\n        uint256 nativeValue\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(target, callData, nativeValue));\n    }\n\n    /**\n     * @notice Overrides internal function of AxelarExecutable, will always revert\n     * as this governance module does not support execute with token.\n     */\n    function _executeWithToken(\n        string calldata, /* sourceChain */\n        string calldata, /* sourceAddress */\n        bytes calldata, /* payload */\n        string calldata, /* tokenSymbol */\n        uint256 /* amount */\n    ) internal pure override {\n        revert TokenNotSupported();\n    }\n\n    /**\n     * @notice Allow contract to receive native gas token\n     */\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/interchain-governance-executor/InterchainProposalExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { StringToAddress } from '../gmp-sdk/util/AddressString.sol';\nimport { AxelarExecutable } from '../gmp-sdk/executable/AxelarExecutable.sol';\nimport { IInterchainProposalExecutor } from './interfaces/IInterchainProposalExecutor.sol';\nimport { InterchainCalls } from './lib/InterchainCalls.sol';\n\n/**\n * @title InterchainProposalExecutor\n * @dev This contract is intended to be the destination contract for `InterchainProposalSender` contract.\n * The proposal will be finally executed from this contract on the destination chain.\n *\n * The contract maintains whitelists for proposal senders and proposal callers. Proposal senders\n * are InterchainProposalSender contracts at the source chain and proposal callers are contracts\n * that call the InterchainProposalSender at the source chain.\n * For most governance system, the proposal caller should be the Timelock contract.\n *\n * This contract is abstract and some of its functions need to be implemented in a derived contract.\n */\ncontract InterchainProposalExecutor is IInterchainProposalExecutor, AxelarExecutable, Ownable {\n    // Whitelisted proposal callers. The proposal caller is the contract that calls the `InterchainProposalSender` at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedCallers;\n\n    // Whitelisted proposal senders. The proposal sender is the `InterchainProposalSender` contract address at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedSenders;\n\n    constructor(address _gateway, address _owner) AxelarExecutable(_gateway) {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @dev Executes the proposal. The source address must be a whitelisted sender.\n     * @param sourceAddress The source address\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal override {\n        _beforeProposalExecuted(sourceChain, sourceAddress, payload);\n\n        // Check that the source address is whitelisted\n        if (!whitelistedSenders[sourceChain][StringToAddress.toAddress(sourceAddress)]) {\n            revert NotWhitelistedSourceAddress();\n        }\n\n        // Decode the payload\n        (address interchainProposalCaller, InterchainCalls.Call[] memory calls) = abi.decode(payload, (address, InterchainCalls.Call[]));\n\n        // Check that the caller is whitelisted\n        if (!whitelistedCallers[sourceChain][interchainProposalCaller]) {\n            revert NotWhitelistedCaller();\n        }\n\n        // Execute the proposal with the given arguments\n        _executeProposal(calls);\n\n        _onProposalExecuted(sourceChain, sourceAddress, interchainProposalCaller, payload);\n\n        emit ProposalExecuted(keccak256(abi.encode(sourceChain, sourceAddress, interchainProposalCaller, payload)));\n    }\n\n    /**\n     * @dev Executes the proposal. Calls each target with the respective value, signature, and data.\n     * @param calls The calls to execute.\n     */\n    function _executeProposal(InterchainCalls.Call[] memory calls) internal {\n        for (uint256 i = 0; i < calls.length; i++) {\n            InterchainCalls.Call memory call = calls[i];\n            (bool success, bytes memory result) = call.target.call{ value: call.value }(call.callData);\n\n            if (!success) {\n                _onTargetExecutionFailed(call, result);\n            } else {\n                _onTargetExecuted(call, result);\n            }\n        }\n    }\n\n    /**\n     * @dev Set the proposal caller whitelist status\n     * @param sourceChain The source chain\n     * @param sourceCaller The source caller\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalCaller(\n        string calldata sourceChain,\n        address sourceCaller,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedCallers[sourceChain][sourceCaller] = whitelisted;\n        emit WhitelistedProposalCallerSet(sourceChain, sourceCaller, whitelisted);\n    }\n\n    /**\n     * @dev Set the proposal sender whitelist status\n     * @param sourceChain The source chain\n     * @param sourceSender The source sender\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalSender(\n        string calldata sourceChain,\n        address sourceSender,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedSenders[sourceChain][sourceSender] = whitelisted;\n        emit WhitelistedProposalSenderSet(sourceChain, sourceSender, whitelisted);\n    }\n\n    /**\n     * @dev A callback function that is called before the proposal is executed.\n     * This function can be used to handle the payload before the proposal is executed.\n     * @param sourceChain The source chain from where the proposal was sent.\n     * @param sourceAddress The source address that sent the proposal. The source address should be the `InterchainProposalSender` contract address at the source chain.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, calldata.\n     */\n    function _beforeProposalExecuted(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload before the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called after the proposal is executed.\n     * This function emits an event containing the hash of the payload to signify successful execution.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _onProposalExecuted(\n        string calldata, /* sourceChain */\n        string calldata, /* sourceAddress */\n        address, /* caller */\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload after the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called when the execution of a target contract within a proposal fails.\n     * This function will revert the transaction providing the failure reason if present in the failure data.\n     * @param result The return data from the failed call to the target contract.\n     */\n    function _onTargetExecutionFailed(\n        InterchainCalls.Call memory, /* call */\n        bytes memory result\n    ) internal virtual {\n        // You can add your own logic here to handle the failure of the target contract execution. The code below is just an example.\n        if (result.length > 0) {\n            // The failure data is a revert reason string.\n            assembly {\n                revert(add(32, result), mload(result))\n            }\n        } else {\n            // There is no failure data, just revert with no reason.\n            revert ProposalExecuteFailed();\n        }\n    }\n\n    /**\n     * @dev Called after a target is successfully executed. The derived contract should implement this function.\n     * This function should do some post-execution work, such as emitting events.\n     * @param call The call that has been executed.\n     * @param result The result of the call.\n     */\n    function _onTargetExecuted(InterchainCalls.Call memory call, bytes memory result) internal virtual {\n        // You can add your own logic here to handle the success of each target contract execution.\n    }\n}"
    }
  ]
}