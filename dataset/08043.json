{
  "Title": "[M-10] Possible that unanimous votes is unachievable",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L370\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L1066\n\n\n# Vulnerability details\n\n## Impact\nCurrently, the `votingPower` calculation rounds down for every user except the `splitRecipient`. This can cause situations where 99.99% of votes (i.e., an unanimous vote) are not achieved, even if all vote in favor of a proposal. This can be very bad for a party, as certain proposals (transferring precious tokens out) require an unamimous vote and are therefore not executable.\n\n## Proof Of Concept\nLet's say for the sake of simplicity that 100 persons contribute 2 wei and `splitBps` is 10 (1%). `votingPower` for all users that contributed will be 1 and 2 for the `splitRecipient`, meaning the maximum achievable vote percentage is 102 / 200 = 51%.\n\nOf course, this is an extreme example, but it shows that the current calculation can introduce siginificant rounding errors that impact the functionality of the protocol.\n\n## Recommended Mitigation Steps\nInstead of requiring more than 99.99% of the votes, ensure that the individual votingPower sum to the total contribution. For instance, one user (e.g., the last one to claim) could receive all the remaining votingPower, which would require a running sum of the already claimed votingPower.\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/Crowdfund.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./CrowdfundNFT.sol\";\n\n// Base contract for AuctionCrowdfund/BuyCrowdfund.\n// Holds post-win/loss logic. E.g., burning contribution NFTs and creating a\n// party after winning.\nabstract contract Crowdfund is ERC721Receiver, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        Invalid,\n        Active,\n        Expired,\n        Busy, // Temporary. mid-settlement state\n        Lost,\n        Won\n    }\n\n    // PartyGovernance options that must be known and fixed at crowdfund creation.\n    // This is a subset of PartyGovernance.GovernanceOpts.\n    struct FixedGovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Fee bps for governance distributions.\n        uint16 feeBps;\n        // Fee recipeint for governance distributions.\n        address payable feeRecipient;\n    }\n\n    // Options to be passed into `_initialize()` when the crowdfund is created.\n    struct CrowdfundOptions {\n        string name;\n        string symbol;\n        address payable splitRecipient;\n        uint16 splitBps;\n        address initialContributor;\n        address initialDelegate;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    // A record of a single contribution made by a user.\n    // Stored in `_contributionsByContributor`.\n    struct Contribution {\n        // The value of `Crowdfund.totalContributions` when this contribution was made.\n        uint96 previousTotalContributions;\n        // How much was this contribution.\n        uint96 amount;\n    }\n\n    error PartyAlreadyExistsError(Party party);\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error InvalidGovernanceOptionsError(bytes32 actualHash, bytes32 expectedHash);\n    error InvalidDelegateError();\n    error NoPartyError();\n    error OnlyContributorAllowedError();\n    error NotAllowedByGateKeeperError(address contributor, IGateKeeper gateKeeper, bytes12 gateKeeperId, bytes gateData);\n    error SplitRecipientAlreadyBurnedError();\n    error InvalidBpsError(uint16 bps);\n\n    event Burned(address contributor, uint256 ethUsed, uint256 ethOwed, uint256 votingPower);\n    event Contributed(address contributor, uint256 amount, address delegate, uint256 previousTotalContributions);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The party instance created by `_createParty()`, if any after a\n    ///         successful crowdfund.\n    Party public party;\n    /// @notice The total (recorded) ETH contributed to this crowdfund.\n    uint96 public totalContributions;\n    /// @notice The gatekeeper contract to use (if non-null) to restrict who can\n    ///         contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper strategy to use.\n    bytes12 public gateKeeperId;\n    /// @notice Who will receive a reserved portion of governance power when\n    ///         the governance party is created.\n    address payable public splitRecipient;\n    /// @notice How much governance power to reserve for `splitRecipient`,\n    ///         in bps, where 10,000 = 100%.\n    uint16 public splitBps;\n    // Whether the share for split recipient has been claimed through `burn()`.\n    bool private _splitRecipientHasBurned;\n    /// @notice Hash of party governance options passed into `initialize()`.\n    ///         Used to check whether the `GovernanceOpts` passed into\n    ///         `_createParty()` matches.\n    bytes32 public governanceOptsHash;\n    /// @notice Who a contributor last delegated to.\n    mapping(address => address) public delegationsByContributor;\n    // Array of contributions by a contributor.\n    // One is created for every nonzero contribution made.\n    mapping (address => Contribution[]) private _contributionsByContributor;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(CrowdfundOptions memory opts)\n        internal\n    {\n        CrowdfundNFT._initialize(opts.name, opts.symbol);\n        // Check that BPS values do not exceed the max.\n        if (opts.governanceOpts.feeBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.feeBps);\n        }\n        if (opts.governanceOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.passThresholdBps);\n        }\n        if (opts.splitBps > 1e4) {\n            revert InvalidBpsError(opts.splitBps);\n        }\n        governanceOptsHash = _hashFixedGovernanceOpts(opts.governanceOpts);\n        splitRecipient = opts.splitRecipient;\n        splitBps = opts.splitBps;\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialBalance = address(this).balance.safeCastUint256ToUint96();\n        if (initialBalance > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, initialBalance, opts.initialDelegate, 0, \"\");\n        }\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    /// @notice Burn the participation NFT for `contributor`, potentially\n    ///         minting voting power and/or refunding unused ETH. `contributor`\n    ///         may also be the split recipient, regardless of whether they are\n    ///         also a contributor or not. This can be called by anyone on a\n    ///         contributor's behalf to unlock their voting power in the\n    ///         governance stage ensuring delegates receive their voting\n    ///         power and governance is not stalled.\n    /// @dev If the party has won, someone needs to call `_createParty()` first. After\n    ///      which, `burn()` will refund unused ETH and mint governance tokens for the\n    ///      given `contributor`.\n    ///      If the party has lost, this will only refund unused ETH (all of it) for\n    ///      the given `contributor`.\n    /// @param contributor The contributor whose NFT to burn for.\n    function burn(address payable contributor)\n        public\n    {\n        return _burn(contributor, getCrowdfundLifecycle(), party);\n    }\n\n    /// @notice `burn()` in batch form.\n    /// @param contributors The contributors whose NFT to burn for.\n    function batchBurn(address payable[] calldata contributors)\n        external\n    {\n        Party party_ = party;\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        for (uint256 i = 0; i < contributors.length; ++i) {\n            _burn(contributors[i], lc, party_);\n        }\n    }\n\n    /// @notice Contribute to this crowdfund and/or update your delegation for the\n    ///         governance phase should the crowdfund succeed.\n    ///         For restricted crowdfunds, `gateData` can be provided to prove\n    ///         membership to the gatekeeper.\n    /// @param delegate The address to delegate to for the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    function contribute(address delegate, bytes memory gateData)\n        public\n        payable\n    {\n        _contribute(\n            msg.sender,\n            msg.value.safeCastUint256ToUint96(),\n            delegate,\n            // We cannot use `address(this).balance - msg.value` as the previous\n            // total contributions in case someone forces (suicides) ETH into this\n            // contract. This wouldn't be such a big deal for open crowdfunds\n            // but private ones (protected by a gatekeeper) could be griefed\n            // because it would ultimately result in governance power that\n            // is unattributed/unclaimable, meaning that party will never be\n            // able to reach 100% consensus.\n            totalContributions,\n            gateData\n        );\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        override(ERC721Receiver, CrowdfundNFT)\n        pure\n        returns (bool)\n    {\n        return ERC721Receiver.supportsInterface(interfaceId) ||\n            CrowdfundNFT.supportsInterface(interfaceId);\n    }\n\n    /// @notice Retrieve info about a participant's contributions.\n    /// @dev This will only be called off-chain so doesn't have to be optimal.\n    /// @param contributor The contributor to retrieve contributions for.\n    /// @return ethContributed The total ETH contributed by `contributor`.\n    /// @return ethUsed The total ETH used by `contributor` to acquire the NFT.\n    /// @return ethOwed The total ETH refunded back to `contributor`.\n    /// @return votingPower The total voting power minted to `contributor`.\n    function getContributorInfo(address contributor)\n        external\n        view\n        returns (\n            uint256 ethContributed,\n            uint256 ethUsed,\n            uint256 ethOwed,\n            uint256 votingPower\n        )\n    {\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        Contribution[] storage contributions = _contributionsByContributor[contributor];\n        uint256 numContributions = contributions.length;\n        for (uint256 i = 0; i < numContributions; ++i) {\n            ethContributed += contributions[i].amount;\n        }\n        if (lc == CrowdfundLifecycle.Won || lc == CrowdfundLifecycle.Lost) {\n            (ethUsed, ethOwed, votingPower) = _getFinalContribution(contributor);\n        }\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public virtual view returns (CrowdfundLifecycle);\n\n    // Get the final sale price of the bought assets. This will also be the total\n    // voting power of the governance party.\n    function _getFinalPrice() internal virtual view returns (uint256);\n\n    // Can be called after a party has won.\n    // Deploys and initializes a a `Party` instance via the `PartyFactory`\n    // and transfers the bought NFT to it.\n    // After calling this, anyone can burn CF tokens on a contributor's behalf\n    // with the `burn()` function.\n    function _createParty(\n        IPartyFactory partyFactory,\n        FixedGovernanceOpts memory governanceOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        returns (Party party_)\n    {\n        if (party != Party(payable(0))) {\n            revert PartyAlreadyExistsError(party);\n        }\n        {\n            bytes16 governanceOptsHash_ = _hashFixedGovernanceOpts(governanceOpts);\n            if (governanceOptsHash_ != governanceOptsHash) {\n                revert InvalidGovernanceOptionsError(governanceOptsHash_, governanceOptsHash);\n            }\n        }\n        party = party_ = partyFactory\n            .createParty(\n                address(this),\n                Party.PartyOptions({\n                    name: name,\n                    symbol: symbol,\n                    governance: PartyGovernance.GovernanceOpts({\n                        hosts: governanceOpts.hosts,\n                        voteDuration: governanceOpts.voteDuration,\n                        executionDelay: governanceOpts.executionDelay,\n                        passThresholdBps: governanceOpts.passThresholdBps,\n                        totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\n                        feeBps: governanceOpts.feeBps,\n                        feeRecipient: governanceOpts.feeRecipient\n                    })\n                }),\n                preciousTokens,\n                preciousTokenIds\n            );\n        // Transfer the acquired NFTs to the new party.\n        for (uint256 i = 0; i < preciousTokens.length; ++i) {\n            preciousTokens[i].transferFrom(address(this), address(party_), preciousTokenIds[i]);\n        }\n    }\n\n    // Overloaded single token wrapper for _createParty()\n    function _createParty(\n        IPartyFactory partyFactory,\n        FixedGovernanceOpts memory governanceOpts,\n        IERC721 preciousToken,\n        uint256 preciousTokenId\n    )\n        internal\n        returns (Party party_)\n    {\n        IERC721[] memory tokens = new IERC721[](1);\n        tokens[0] = preciousToken;\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = preciousTokenId;\n        return _createParty(partyFactory, governanceOpts, tokens, tokenIds);\n    }\n\n    function _hashFixedGovernanceOpts(FixedGovernanceOpts memory opts)\n        internal\n        pure\n        returns (bytes16 h)\n    {\n        // Hash in place.\n        assembly {\n            // Replace the address[] hosts field with its hash temporarily.\n            let oldHostsFieldValue := mload(opts)\n            mstore(opts, keccak256(add(mload(opts), 0x20), mul(mload(mload(opts)), 32)))\n            // Hash the entire struct.\n            h := keccak256(opts, 0xC0)\n            // Restore old hosts field value.\n            mstore(opts, oldHostsFieldValue)\n        }\n    }\n\n    function _getFinalContribution(address contributor)\n        internal\n        view\n        returns (uint256 ethUsed, uint256 ethOwed, uint256 votingPower)\n    {\n        uint256 totalEthUsed = _getFinalPrice();\n        {\n            Contribution[] storage contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            for (uint256 i = 0; i < numContributions; ++i) {\n                Contribution memory c = contributions[i];\n                if (c.previousTotalContributions >= totalEthUsed) {\n                    // This entire contribution was not used.\n                    ethOwed += c.amount;\n                } else if (c.previousTotalContributions + c.amount <= totalEthUsed) {\n                    // This entire contribution was used.\n                    ethUsed += c.amount;\n                } else {\n                    // This contribution was partially used.\n                    uint256 partialEthUsed = totalEthUsed - c.previousTotalContributions;\n                    ethUsed += partialEthUsed;\n                    ethOwed = c.amount - partialEthUsed;\n                }\n            }\n        }\n        // one SLOAD with optimizer on\n        address splitRecipient_ = splitRecipient;\n        uint256 splitBps_ = splitBps;\n        if (splitRecipient_ == address(0)) {\n            splitBps_ = 0;\n        }\n        votingPower = ((1e4 - splitBps_) * ethUsed) / 1e4;\n        if (splitRecipient_ == contributor) {\n            // Split recipient is also the contributor so just add the split\n            // voting power.\n            votingPower += (splitBps_ * totalEthUsed + (1e4 - 1)) / 1e4; // round up\n        }\n    }\n\n    function _contribute(\n        address contributor,\n        uint96 amount,\n        address delegate,\n        uint96 previousTotalContributions,\n        bytes memory gateData\n    )\n        internal\n    {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n        // Must not be blocked by gatekeeper.\n        if (gateKeeper != IGateKeeper(address(0))) {\n            if (!gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        // Update delegate.\n        // OK if this happens out of cycle.\n        delegationsByContributor[contributor] = delegate;\n        emit Contributed(contributor, amount, delegate, previousTotalContributions);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount != 0) {\n            // Increase total contributions.\n            totalContributions += amount;\n\n            // Only allow contributions while the crowdfund is active.\n            {\n                CrowdfundLifecycle lc = getCrowdfundLifecycle();\n                if (lc != CrowdfundLifecycle.Active) {\n                    revert WrongLifecycleError(lc);\n                }\n            }\n            // Create contributions entry for this contributor.\n            Contribution[] storage contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            if (numContributions >= 1) {\n                Contribution memory lastContribution = contributions[numContributions - 1];\n                if (lastContribution.previousTotalContributions == previousTotalContributions) {\n                    // No one else has contributed since so just reuse the last entry.\n                    lastContribution.amount += amount;\n                    contributions[numContributions - 1] = lastContribution;\n                    return;\n                }\n            }\n            // Add a new contribution entry.\n            contributions.push(Contribution({\n                previousTotalContributions: previousTotalContributions,\n                amount: amount\n            }));\n            // Mint a participation NFT if this is their first contribution.\n            if (numContributions == 0) {\n                _mint(contributor);\n            }\n        }\n    }\n\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)\n        private\n    {\n        // If the CF has won, a party must have been created prior.\n        if (lc == CrowdfundLifecycle.Won) {\n            if (party_ == Party(payable(0))) {\n                revert NoPartyError();\n            }\n        } else if (lc != CrowdfundLifecycle.Lost) {\n            // Otherwise it must have lost.\n            revert WrongLifecycleError(lc);\n        }\n        // Split recipient can burn even if they don't have a token.\n        if (contributor == splitRecipient) {\n            if (_splitRecipientHasBurned) {\n                revert SplitRecipientAlreadyBurnedError();\n            }\n            _splitRecipientHasBurned = true;\n        }\n        // Revert if already burned or does not exist.\n        if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {\n            CrowdfundNFT._burn(contributor);\n        }\n        // Compute the contributions used and owed to the contributor, along\n        // with the voting power they'll have in the governance stage.\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =\n            _getFinalContribution(contributor);\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            party_.mint(\n                contributor,\n                votingPower,\n                delegate\n            );\n        }\n        // Refund any ETH owed back to the contributor.\n        contributor.transferEth(ethOwed);\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\n    }\n\n    function _getPartyFactory() internal view returns (IPartyFactory) {\n        return IPartyFactory(_GLOBALS.getAddress(LibGlobals.GLOBAL_PARTY_FACTORY));\n    }\n}"
    },
    {
      "filename": "contracts/party/PartyGovernance.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../distribution/ITokenDistributorParty.sol\";\nimport \"../distribution/ITokenDistributor.sol\";\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../tokens/IERC1155.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../proposals/IProposalExecutionEngine.sol\";\nimport \"../proposals/LibProposal.sol\";\nimport \"../proposals/ProposalStorage.sol\";\n\nimport \"./IPartyFactory.sol\";\n\n/// @notice Base contract for a Party encapsulating all governance functionality.\nabstract contract PartyGovernance is\n    ITokenDistributorParty,\n    ERC721Receiver,\n    ERC1155Receiver,\n    ProposalStorage,\n    Implementation,\n    ReadOnlyDelegateCall\n{\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibSafeCast for int192;\n    using LibSafeCast for uint96;\n\n    // States a proposal can be in.\n    enum ProposalStatus {\n        // The proposal does not exist.\n        Invalid,\n        // The proposal has been proposed (via `propose()`), has not been vetoed\n        // by a party host, and is within the voting window. Members can vote on\n        // the proposal and party hosts can veto the proposal.\n        Voting,\n        // The proposal has either exceeded its voting window without reaching\n        // `passThresholdBps` of votes or was vetoed by a party host.\n        Defeated,\n        // The proposal reached at least `passThresholdBps` of votes but is still\n        // waiting for `executionDelay` to pass before it can be executed. Members\n        // can continue to vote on the proposal and party hosts can veto at this time.\n        Passed,\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\n        // has arrived.\n        Ready,\n        // The proposal has been executed at least once but has further steps to\n        // complete so it needs to be executed again. No other proposals may be\n        // executed while a proposal is in the `InProgress` state. No voting or\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\n        InProgress,\n        // The proposal was executed and completed all its steps. No voting or\n        // vetoing can occur and it cannot be cancelled nor executed again.\n        Complete,\n        // The proposal was executed at least once but did not complete before\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\n        Cancelled\n    }\n\n    struct GovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Total voting power of governance NFTs.\n        uint96 totalVotingPower;\n        // Fee bps for distributions.\n        uint16 feeBps;\n        // Fee recipeint for distributions.\n        address payable feeRecipient;\n    }\n\n    // Subset of `GovernanceOpts` that are commonly read together for\n    // efficiency.\n    struct GovernanceValues {\n        uint40 voteDuration;\n        uint40 executionDelay;\n        uint16 passThresholdBps;\n        uint96 totalVotingPower;\n    }\n\n    // A snapshot of voting power for a member.\n    struct VotingPowerSnapshot {\n        // The timestamp when the snapshot was taken.\n        uint40 timestamp;\n        // Voting power that was delegated to this user by others.\n        uint96 delegatedVotingPower;\n        // The intrinsic (not delegated from someone else) voting power of this user.\n        uint96 intrinsicVotingPower;\n        // Whether the user was delegated to another at this snapshot.\n        bool isDelegated;\n    }\n\n    // Proposal details chosen by proposer.\n    struct Proposal {\n        // Time beyond which the proposal can no longer be executed.\n        // If the proposal has already been executed, and is still InProgress,\n        // this value is ignored.\n        uint40 maxExecutableTime;\n        // The minimum seconds this proposal can remain in the InProgress status\n        // before it can be cancelled.\n        uint40 cancelDelay;\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\n        // by encoded proposal args specific to the proposal type. See\n        // ProposalExecutionEngine for details.\n        bytes proposalData;\n    }\n\n    // Accounting and state tracking values for a proposal.\n    // Fits in a word.\n    struct ProposalStateValues {\n        // When the proposal was proposed.\n        uint40 proposedTime;\n        // When the proposal passed the vote.\n        uint40 passedTime;\n        // When the proposal was first executed.\n        uint40 executedTime;\n        // When the proposal completed.\n        uint40 completedTime;\n        // Number of accept votes.\n        uint96 votes; // -1 == vetoed\n    }\n\n    // Storage states for a proposal.\n    struct ProposalState {\n        // Accounting and state tracking values.\n        ProposalStateValues values;\n        // Hash of the proposal.\n        bytes32 hash;\n        // Whether a member has voted for (accepted) this proposal already.\n        mapping (address => bool) hasVoted;\n    }\n\n    event Proposed(\n        uint256 proposalId,\n        address proposer,\n        Proposal proposal\n    );\n    event ProposalAccepted(\n        uint256 proposalId,\n        address voter,\n        uint256 weight\n    );\n\n    event PartyInitialized(GovernanceOpts opts, IERC721[] preciousTokens, uint256[] preciousTokenIds);\n    event ProposalPassed(uint256 indexed proposalId);\n    event ProposalVetoed(uint256 indexed proposalId, address host);\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event DistributionCreated(ITokenDistributor.TokenType tokenType, address token, uint256 tokenId);\n    event VotingPowerDelegated(address indexed owner, address indexed delegate);\n    event HostStatusTransferred(address oldHost, address newHost);\n\n    error MismatchedPreciousListLengths();\n    error BadProposalStatusError(ProposalStatus status);\n    error ProposalExistsError(uint256 proposalId);\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\n    error ProposalHasNoVotesError(uint256 proposalId);\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\n    error OnlyPartyHostError();\n    error OnlyActiveMemberError();\n    error InvalidDelegateError();\n    error BadPreciousListError();\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoOrHostError(address notDao, address partyDao);\n    error OnlyWhenEmergencyActionsAllowedError();\n    error AlreadyVotedError(address voter);\n    error InvalidNewHostError();\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\n    error InvalidBpsError(uint16 bps);\n\n    uint256 constant private UINT40_HIGH_BIT = 1 << 39;\n    uint96 constant private VETO_VALUE = uint96(int96(-1));\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Whether the DAO has emergency powers for this party.\n    bool public emergencyExecuteDisabled;\n    /// @notice Distribution fee bps.\n    uint16 public feeBps;\n    /// @notice Distribution fee recipient.\n    address payable public feeRecipient;\n    /// @notice The hash of the list of precious NFTs guarded by the party.\n    bytes32 public preciousListHash;\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\n    uint256 public lastProposalId;\n    /// @notice Whether an address is a party host.\n    mapping(address => bool) public isHost;\n    /// @notice The last person a voter delegated its voting power to.\n    mapping(address => address) public delegationsByVoter;\n    // Constant governance parameters, fixed from the inception of this party.\n    GovernanceValues private _governanceValues;\n    // ProposalState by proposal ID.\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\n    // Snapshots of voting power per user, each sorted by increasing time.\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\n\n    modifier onlyHost() {\n        if (!isHost[msg.sender]) {\n            revert OnlyPartyHostError();\n        }\n        _;\n    }\n\n    // Caller must own a governance NFT at the current time.\n    modifier onlyActiveMember() {\n        {\n            VotingPowerSnapshot memory snap =\n                _getLastVotingPowerSnapshotForVoter(msg.sender);\n            // Must have either delegated voting power or intrinsic voting power.\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig can call.\n    modifier onlyPartyDao() {\n        {\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig or a party host can call.\n    modifier onlyPartyDaoOrHost() {\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\n            revert OnlyPartyDaoOrHostError(msg.sender, partyDao);\n        }\n        _;\n    }\n\n    // Only if `emergencyExecuteDisabled` is not true.\n    modifier onlyWhenEmergencyExecuteAllowed() {\n        if (emergencyExecuteDisabled) {\n            revert OnlyWhenEmergencyActionsAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\n    function _initialize(\n        GovernanceOpts memory opts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        virtual\n    {\n        // Check BPS are valid.\n        if (opts.feeBps > 1e4) {\n            revert InvalidBpsError(opts.feeBps);\n        }\n        if (opts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(opts.passThresholdBps);\n        }\n        // Initialize the proposal execution engine.\n        _initProposalImpl(\n            IProposalExecutionEngine(\n                _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)\n            ),\n            \"\"\n        );\n        // Set the governance parameters.\n        _governanceValues = GovernanceValues({\n            voteDuration: opts.voteDuration,\n            executionDelay: opts.executionDelay,\n            passThresholdBps: opts.passThresholdBps,\n            totalVotingPower: opts.totalVotingPower\n        });\n        // Set fees.\n        feeBps = opts.feeBps;\n        feeRecipient = opts.feeRecipient;\n        // Set the precious list.\n        _setPreciousList(preciousTokens, preciousTokenIds);\n        // Set the party hosts.\n        for (uint256 i=0; i < opts.hosts.length; ++i) {\n            isHost[opts.hosts[i]] = true;\n        }\n        emit PartyInitialized(opts, preciousTokens, preciousTokenIds);\n    }\n\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\n    ///      Initial use case is to facilitate eip-1271 signatures.\n    fallback() external {\n        _readOnly"
    }
  ]
}