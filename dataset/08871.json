{
  "Title": "[M-07] FeeBurner initiates swap without any slippage checks if Chainlink oracle fails",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L43-L88\nhttps://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/swappers/SwapperRouter.sol#L414-L425\nhttps://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/swappers/SwapperRouter.sol#L439\n\n\n# Vulnerability details\n\n## Impact\nWhile the SwapperRouter contract isn't explicitly in scope, it's a dependency of the FeeBurner contract which *is* in scope. So I think it's valid to make this submission.\n\nThe SwapperRouter contract uses the chainlink oracle to compute the minimum amount of tokens it should expect from the swap. The value is then used for the slippage check. But, if the chainlink oracle fails, for whatever reason, the contract uses `0` for the slippage check instead. Thus there's a scenario where swaps initiated by the FeeBurner contract can be sandwiched.\n\n## Proof of Concept\n1. multiple swaps initiated through [`FeeBurner.burnToTarget()`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L43-L88)\n2. SwapperRouter calls [`_minTokenAmountOut()`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/swappers/SwapperRouter.sol#L220) to determine `min_out` parameter.\n3. [`minTokenAmountOut()`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/swappers/SwapperRouter.sol#L414-L425) returns `0` when Chainlink oracle fails\n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nEither revert the transaction or initiate the transaction with a default slippage of 99%. In the case of Curve, you can get the expected amount through `get_dy()` and then multiply the value by 0.99. Use that as the `min_out` value and you don't have to worry about chainlink\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/tokenomics/FeeBurner.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../interfaces/IFeeBurner.sol\";\nimport \"../../interfaces/ISwapperRouter.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\n\n/**\n * The Fee Burner converts all of the callers Backd LP Tokens to a single target Backd LP Token.\n * It first burns the Pool LP Tokens for the Pool underlying.\n * Then it swaps all the underlyings for the target Pool underlying.\n * Finally it deposits the Pool underlying into the target Pool to get the target LP Token.\n */\ncontract FeeBurner is IFeeBurner {\n    using SafeERC20 for IERC20;\n    using UncheckedMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n\n    IAddressProvider private immutable _addressProvider; // Address Provider, used for getting pools and swapper router\n\n    event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token\n\n    constructor(address addressProvider_) {\n        _addressProvider = IAddressProvider(addressProvider_);\n    }\n\n    receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool\n\n    /**\n     * @notice Converts callers Tokens to target Backd LP Token for the given tokens_.\n     * @param tokens_ The Tokens to convert to the targetLpToken_.\n     * @param targetLpToken_ The LP Token that should be received.\n     * @return received The amount of the target LP Token received.\n     */\n    function burnToTarget(address[] memory tokens_, address targetLpToken_)\n        public\n        payable\n        override\n        returns (uint256 received)\n    {\n        require(tokens_.length != 0, \"No tokens to burn\");\n\n        // Swapping tokens for WETH\n        ILiquidityPool targetPool_ = _addressProvider.getPoolForToken(targetLpToken_);\n        address targetUnderlying_ = targetPool_.getUnderlying();\n        ISwapperRouter swapperRouter_ = _swapperRouter();\n        bool burningEth_;\n        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) {\n            IERC20 token_ = IERC20(tokens_[i]);\n\n            // Handling ETH\n            if (address(token_) == address(0)) {\n                if (msg.value == 0) continue;\n                burningEth_ = true;\n                swapperRouter_.swapAll{value: msg.value}(address(token_), _WETH);\n                continue;\n            }\n\n            // Handling ERC20\n            uint256 tokenBalance_ = token_.balanceOf(msg.sender);\n            if (tokenBalance_ == 0) continue;\n            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_);\n            if (address(token_) == targetUnderlying_) continue;\n            _approve(address(token_), address(swapperRouter_));\n            swapperRouter_.swap(address(token_), _WETH, tokenBalance_);\n        }\n        require(burningEth_ || msg.value == 0, Error.INVALID_VALUE);\n\n        // Swapping WETH for target underlying\n        _approve(_WETH, address(swapperRouter_));\n        swapperRouter_.swapAll(_WETH, targetUnderlying_);\n\n        // Depositing target underlying into target pool\n        uint256 targetLpTokenBalance_ = _depositInPool(targetUnderlying_, targetPool_);\n\n        // Transfering LP tokens back to sender\n        IERC20(targetLpToken_).safeTransfer(msg.sender, targetLpTokenBalance_);\n        emit Burned(targetLpToken_, targetLpTokenBalance_);\n        return targetLpTokenBalance_;\n    }\n\n    /**\n     * @dev Deposits underlying into pool to receive LP Tokens.\n     * @param underlying_ The underlying of the pool.\n     * @param pool_ The pool to deposit into.\n     * @return received The amount of LP Tokens received.\n     */\n    function _depositInPool(address underlying_, ILiquidityPool pool_)\n        internal\n        returns (uint256 received)\n    {\n        // Handling ETH deposits\n        if (underlying_ == address(0)) {\n            uint256 ethBalance_ = address(this).balance;\n            return pool_.deposit{value: ethBalance_}(ethBalance_);\n        }\n\n        // Handling ERC20 deposits\n        _approve(underlying_, address(pool_));\n        return pool_.deposit(IERC20(underlying_).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Gets the swapper router.\n     * @return The swapper router.\n     */\n    function _swapperRouter() internal view returns (ISwapperRouter) {\n        return _addressProvider.getSwapperRouter();\n    }\n}"
    },
    {
      "filename": "protocol/contracts/swappers/SwapperRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../access/Authorization.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/DecimalScale.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/ISwapperRouter.sol\";\nimport \"../../interfaces/vendor/UniswapRouter02.sol\";\nimport \"../../interfaces/vendor/IWETH.sol\";\nimport \"../../interfaces/IERC20Full.sol\";\nimport \"../../interfaces/vendor/ICurveSwapEth.sol\";\n\n/**\n * The swapper router handles the swapping from one token to another.\n * By default it does all swaps through WETH, in two steps checking which DEX is better for each stage of the swap.\n * It also supports ETH in or out and handles it by converting to WETH and back.\n */\ncontract SwapperRouter is ISwapperRouter, Authorization {\n    using SafeERC20 for IERC20;\n    using DecimalScale for uint256;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    // Dex contracts\n    address private constant _UNISWAP = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router, used for swapping tokens on Uniswap\n    address private constant _SUSHISWAP = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router, used for swapping tokens on Sushiswap\n    IWETH private constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH, used for wrapping and unwrapping ETH for swaps\n\n    IAddressProvider private immutable _addressProvider; // Address provider used for getting oracle provider\n\n    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset\n    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swapping with WETH\n\n    event Swapped(address fromToken, address toToken, uint256 amountIn, uint256 amountOut); // Emmited after a successfull swap\n    event SetSlippageTolerance(uint256 value); // Emitted after a successful setting of slippage tolerance\n    event SetCurvePool(address token, address curvePool); // Emitted after a successful setting of a Curve Pool\n\n    constructor(address addressProvider_)\n        Authorization(IAddressProvider(addressProvider_).getRoleManager())\n    {\n        _addressProvider = IAddressProvider(addressProvider_);\n        slippageTolerance = 0.97e18;\n    }\n\n    receive() external payable {} // Used for receiving ETH when unwrapping WETH\n\n    /**\n     * @notice Swaps all of the users balance of fromToken for toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @return amountOut The amount of toToken received.\n     */\n    function swapAll(address fromToken_, address toToken_)\n        external\n        payable\n        override\n        returns (uint256 amountOut)\n    {\n        // Swapping if from token is ETH\n        if (fromToken_ == address(0)) {\n            return swap(fromToken_, toToken_, address(this).balance);\n        }\n\n        // Swapping if from token is ERC20\n        return swap(fromToken_, toToken_, IERC20(fromToken_).balanceOf(address(msg.sender)));\n    }\n\n    /**\n     * @notice Set slippage tolerance for swaps.\n     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.\n     * @param slippageTolerance_ New slippage tolerance.\n     */\n    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {\n        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);\n        slippageTolerance = slippageTolerance_;\n        emit SetSlippageTolerance(slippageTolerance_);\n    }\n\n    /**\n     * @notice Sets the Curve Pool to use for swapping a token with WETH.\n     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zero address.\n     * @param token_ The token to set the Curve Pool for.\n     * @param curvePool_ The address of the Curve Pool.\n     */\n    function setCurvePool(address token_, address curvePool_) external override onlyGovernance {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(curvePool_ != address(curvePools[token_]), Error.SAME_ADDRESS_NOT_ALLOWED);\n        curvePools[token_] = ICurveSwapEth(curvePool_);\n        emit SetCurvePool(token_, curvePool_);\n    }\n\n    /**\n     * @notice Gets the amount of toToken received by swapping amountIn of fromToken.\n     * @dev In the case where a custom swapper is used, return value may not be precise.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken being swapped.\n     * @return amountOut The amount of toToken received by swapping amountIn of fromToken.\n     */\n    function getAmountOut(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_\n    ) external view override returns (uint256 amountOut) {\n        if (fromToken_ == toToken_ || amountIn_ == 0) return amountIn_;\n\n        return _getTokenOut(toToken_, _getWethOut(fromToken_, amountIn_));\n    }\n\n    /**\n     * @notice Swaps an amount of fromToken to toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken to swap for toToken.\n     * @return amountOut The amount of toToken received.\n     */\n    function swap(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_\n    ) public payable override returns (uint256 amountOut) {\n        // Validating ETH value sent\n        require(msg.value == (fromToken_ == address(0) ? amountIn_ : 0), Error.INVALID_AMOUNT);\n        if (amountIn_ == 0) {\n            emit Swapped(fromToken_, toToken_, 0, 0);\n            return 0;\n        }\n\n        // Handling swap between the same token\n        if (fromToken_ == toToken_) {\n            if (fromToken_ == address(0)) {\n                payable(msg.sender).transfer(amountIn_);\n            }\n            emit Swapped(fromToken_, toToken_, amountIn_, amountIn_);\n            return amountIn_;\n        }\n\n        // Transferring to contract if ERC20\n        if (fromToken_ != address(0)) {\n            IERC20(fromToken_).safeTransferFrom(msg.sender, address(this), amountIn_);\n        }\n\n        // Swapping token via WETH\n        uint256 amountOut_ = _swapWethForToken(toToken_, _swapForWeth(fromToken_));\n        emit Swapped(fromToken_, toToken_, amountIn_, amountOut_);\n        return _returnTokens(toToken_, amountOut_);\n    }\n\n    /**\n     * @dev Swaps the full contract balance of token to WETH.\n     * @param token_ The token to swap to WETH.\n     * @return amountOut The amount of WETH received from the swap.\n     */\n    function _swapForWeth(address token_) internal returns (uint256 amountOut) {\n        if (token_ == address(_WETH)) return _WETH.balanceOf(address(this));\n\n        // Handling ETH -> WETH\n        if (token_ == address(0)) {\n            uint256 ethBalance_ = address(this).balance;\n            if (ethBalance_ == 0) return 0;\n            _WETH.deposit{value: ethBalance_}();\n            return ethBalance_;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            uint256 amount_ = IERC20(token_).balanceOf(address(this));\n            if (amount_ == 0) return 0;\n            _approve(token_, address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                tokenIndex_,\n                wethIndex_,\n                amount_,\n                _minWethAmountOut(amount_, token_)\n            );\n            return _WETH.balanceOf(address(this));\n        }\n\n        // Handling ERC20 -> WETH\n        return _swap(token_, address(_WETH), IERC20(token_).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Swaps the full contract balance of WETH to token.\n     * @param token_ The token to swap WETH to.\n     * @return amountOut The amount of token received from the swap.\n     */\n    function _swapWethForToken(address token_, uint256 amount_)\n        internal\n        returns (uint256 amountOut)\n    {\n        if (amount_ == 0) return 0;\n        if (token_ == address(_WETH)) return amount_;\n\n        // Handling WETH -> ETH\n        if (token_ == address(0)) {\n            _WETH.withdraw(amount_);\n            return amount_;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            _approve(address(_WETH), address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                wethIndex_,\n                tokenIndex_,\n                amount_,\n                _minTokenAmountOut(amount_, token_)\n            );\n            return IERC20(token_).balanceOf(address(this));\n        }\n\n        // Handling WETH -> ERC20\n        return _swap(address(_WETH), token_, amount_);\n    }\n\n    /**\n     * @dev Swaps an amount of fromToken to toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amount_ The amount of fromToken to swap.\n     * @return amountOut The amount of toToken received from the swap.\n     */\n    function _swap(\n        address fromToken_,\n        address toToken_,\n        uint256 amount_\n    ) internal returns (uint256 amountOut) {\n        if (amount_ == 0) return 0;\n        if (fromToken_ == toToken_) return amount_;\n        address dex_ = _getBestDex(fromToken_, toToken_, amount_);\n        _approve(fromToken_, dex_);\n        address[] memory path_ = new address[](2);\n        path_[0] = fromToken_;\n        path_[1] = toToken_;\n        return\n            UniswapRouter02(dex_).swapExactTokensForTokens(\n                amount_,\n                _getAmountOutMin(amount_, fromToken_, toToken_),\n                path_,\n                address(this),\n                block.timestamp\n            )[1];\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Returns an amount of tokens to the sender.\n     * @param token_ The token to return to sender.\n     * @param amount_ The amount of tokens to return to sender.\n     * @return amountReturned The amount of tokens returned to sender.\n     */\n    function _returnTokens(address token_, uint256 amount_)\n        internal\n        returns (uint256 amountReturned)\n    {\n        // Returning if ETH\n        if (token_ == address(0)) {\n            payable(msg.sender).transfer(amount_);\n            return amount_;\n        }\n\n        // Returning if ERC20\n        IERC20(token_).safeTransfer(msg.sender, amount_);\n        return amount_;\n    }\n\n    /**\n     * @dev Gets the amount of WETH received by swapping amount of token\n     *      In the case where a custom swapper is used, return value may not be precise.\n     * @param token_ The token to swap from.\n     * @param amount_ The mount of token being swapped.\n     * @return amountOut The amount of WETH received by swapping amount of token.\n     */\n    function _getWethOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256 amountOut)\n    {\n        if (token_ == address(_WETH) || token_ == address(0)) return amount_;\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(tokenIndex_, wethIndex_, amount_);\n        }\n\n        return\n            _tokenAmountOut(\n                token_,\n                address(_WETH),\n                amount_,\n                _getBestDex(token_, address(_WETH), amount_)\n            );\n    }\n\n    /**\n     * @dev Gets the amount of token received by swapping amount of WETH\n     *      In the case where a custom swapper is used, return value may not be precise.\n     * @param token_ The token to swap to.\n     * @param amount_ The amount of WETH being swapped.\n     * @return amountOut The amount of token received by swapping amount of WETH.\n     */\n    function _getTokenOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256 amountOut)\n    {\n        if (token_ == address(_WETH) || token_ == address(0)) return amount_;\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(wethIndex_, tokenIndex_, amount_);\n        }\n\n        return\n            _tokenAmountOut(\n                address(_WETH),\n                token_,\n                amount_,\n                _getBestDex(address(_WETH), token_, amount_)\n            );\n    }\n\n    /**\n     * @dev Gets the best dex to use for swapping tokens based on which gives the highest amount out.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amount_ The amount of fromToken to swap.\n     * @return bestDex The best dex to use for swapping tokens based on which gives the highest amount out\n     */\n    function _getBestDex(\n        address fromToken_,\n        address toToken_,\n        uint256 amount_\n    ) internal view returns (address bestDex) {\n        address uniswap_ = _UNISWAP;\n        address sushiswap_ = _SUSHISWAP;\n        return\n            _tokenAmountOut(fromToken_, toToken_, amount_, uniswap_) >=\n                _tokenAmountOut(fromToken_, toToken_, amount_, sushiswap_)\n                ? uniswap_\n                : sushiswap_;\n    }\n\n    /**\n     * @notice Gets the amount of toToken received by swapping amountIn of fromToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken being swapped.\n     * @param dex_ The DEX to use for the swap.\n     * @return amountOut The amount of toToken received by swapping amountIn of fromToken.\n     */\n    function _tokenAmountOut(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_,\n        address dex_\n    ) internal view returns (uint256 amountOut) {\n        address[] memory path_ = new address[](2);\n        path_[0] = fromToken_;\n        path_[1] = toToken_;\n        return UniswapRouter02(dex_).getAmountsOut(amountIn_, path_)[1];\n    }\n\n    /**\n     * @dev Returns the minimum amount of toToken_ to receive from swap.\n     * @param amount_ The amount of fromToken_ being swapped.\n     * @param fromToken_ The Token being swapped from.\n     * @param toToken_ The Token being swapped to.\n     * @return amountOutMin The minimum amount of toToken_ to receive from swap.\n     */\n    function _getAmountOutMin(\n        uint256 amount_,\n        address fromToken_,\n        address toToken_\n    ) internal view returns (uint256 amountOutMin) {\n        return\n            fromToken_ == address(_WETH)\n                ? _minTokenAmountOut(amount_, toToken_)\n                : _minWethAmountOut(amount_, fromToken_);\n    }\n\n    /**\n     * @dev Returns the minimum amount of Token to receive from swap.\n     * @param wethAmount_ The amount of WETH being swapped.\n     * @param token_ The Token the WETH is being swapped to.\n     * @return minAmountOut The minimum amount of Token to receive from swap.\n     */\n    function _minTokenAmountOut(uint256 wethAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        uint256 priceInEth_ = _getPriceInEth(token_);\n        if (priceInEth_ == 0) return 0;\n        return\n            wethAmount_.scaledDiv(priceInEth_).scaledMul(slippageTolerance).scaleTo(\n                IERC20Full(token_).decimals()\n            );\n    }\n\n    /**\n     * @dev Returns the minimum amount of WETH to receive from swap.\n     * @param tokenAmount_ The amount of Token being swapped.\n     * @param token_ The Token that is being swapped for WETH.\n     * @return minAmountOut The minimum amount of WETH to receive from swap.\n     */\n    function _minWethAmountOut(uint256 tokenAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        uint256 priceInEth_ = _getPriceInEth(token_);\n        if (priceInEth_ == 0) return 0;\n        return\n            tokenAmount_.scaledMul(priceInEth_).scaledMul(slippageTolerance).scaleFrom(\n                IERC20Full(token_).decimals()\n            );\n    }\n\n    /**\n     * @dev Returns the price in ETH of the given token. If no oracle exists for the token, returns 0.\n     * @param token_ The token to get the price for.\n     * @return tokenPriceInEth The price of the token in ETH.\n     */\n    function _getPriceInEth(address token_) internal view returns (uint256 tokenPriceInEth) {\n        try _addressProvider.getOracleProvider().getPriceETH(token_) returns (uint256 price_) {\n            return price_;\n        } catch {\n            return 0;\n        }\n    }\n\n    /**\n     * @dev Returns the Curve Pool coin indices for a given Token.\n     * @param curvePool_ The Curve Pool to return the indices for.\n     * @param token_ The Token to get the indices for.\n     * @return wethIndex_ The coin index for WETH.\n     * @return tokenIndex_ The coin index for the Token.\n     */\n    function _getIndices(ICurveSwapEth curvePool_, address token_)\n        internal\n        view\n        returns (uint256 wethIndex_, uint256 tokenIndex_)\n    {\n        return curvePool_.coins(1) == token_ ? (0, 1) : (1, 0);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/swappers/SwapperRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../access/Authorization.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/DecimalScale.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/ISwapperRouter.sol\";\nimport \"../../interfaces/vendor/UniswapRouter02.sol\";\nimport \"../../interfaces/vendor/IWETH.sol\";\nimport \"../../interfaces/IERC20Full.sol\";\nimport \"../../interfaces/vendor/ICurveSwapEth.sol\";\n\n/**\n * The swapper router handles the swapping from one token to another.\n * By default it does all swaps through WETH, in two steps checking which DEX is better for each stage of the swap.\n * It also supports ETH in or out and handles it by converting to WETH and back.\n */\ncontract SwapperRouter is ISwapperRouter, Authorization {\n    using SafeERC20 for IERC20;\n    using DecimalScale for uint256;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    // Dex contracts\n    address private constant _UNISWAP = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router, used for swapping tokens on Uniswap\n    address private constant _SUSHISWAP = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router, used for swapping tokens on Sushiswap\n    IWETH private constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH, used for wrapping and unwrapping ETH for swaps\n\n    IAddressProvider private immutable _addressProvider; // Address provider used for getting oracle provider\n\n    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset\n    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swapping with WETH\n\n    event Swapped(address fromToken, address toToken, uint256 amountIn, uint256 amountOut); // Emmited after a successfull swap\n    event SetSlippageTolerance(uint256 value); // Emitted after a successful setting of slippage tolerance\n    event SetCurvePool(address token, address curvePool); // Emitted after a successful setting of a Curve Pool\n\n    constructor(address addressProvider_)\n        Authorization(IAddressProvider(addressProvider_).getRoleManager())\n    {\n        _addressProvider = IAddressProvider(addressProvider_);\n        slippageTolerance = 0.97e18;\n    }\n\n    receive() external payable {} // Used for receiving ETH when unwrapping WETH\n\n    /**\n     * @notice Swaps all of the users balance of fromToken for toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @return amountOut The amount of toToken received.\n     */\n    function swapAll(address fromToken_, address toToken_)\n        external\n        payable\n        override\n        returns (uint256 amountOut)\n    {\n        // Swapping if from token is ETH\n        if (fromToken_ == address(0)) {\n            return swap(fromToken_, toToken_, address(this).balance);\n        }\n\n        // Swapping if from token is ERC20\n        return swap(fromToken_, toToken_, IERC20(fromToken_).balanceOf(address(msg.sender)));\n    }\n\n    /**\n     * @notice Set slippage tolerance for swaps.\n     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.\n     * @param slippageTolerance_ New slippage tolerance.\n     */\n    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {\n        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);\n        slippageTolerance = slippageTolerance_;\n        emit SetSlippageTolerance(slippageTolerance_);\n    }\n\n    /**\n     * @notice Sets the Curve Pool to use for swapping a token with WETH.\n     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zero address.\n     * @param token_ The token to set the Curve Pool for.\n     * @param curvePool_ The address of the Curve Pool.\n     */\n    function setCurvePool(address token_, address curvePool_) external override onlyGovernance {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(curvePool_ != address(curvePools[token_]), Error.SAME_ADDRESS_NOT_ALLOWED);\n        curvePools[token_] = ICurveSwapEth(curvePool_);\n        emit SetCurvePool(token_, curvePool_);\n    }\n\n    /**\n     * @notice Gets the amount of toToken received by swapping amountIn of fromToken.\n     * @dev In the case where a custom swapper is used, return value may not be precise.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken being swapped.\n     * @return amountOut The amount of toToken received by swapping amountIn of fromToken.\n     */\n    function getAmountOut(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_\n    ) external view override returns (uint256 amountOut) {\n        if (fromToken_ == toToken_ || amountIn_ == 0) return amountIn_;\n\n        return _getTokenOut(toToken_, _getWethOut(fromToken_, amountIn_));\n    }\n\n    /**\n     * @notice Swaps an amount of fromToken to toToken.\n     * @param fromToken_ The token to swap from.\n     * @param toToken_ The token to swap to.\n     * @param amountIn_ The amount of fromToken to swap for toToken.\n     * @return amountOut The amount of toToken received.\n     */\n    function swap(\n        address fromToken_,\n        address toToken_,\n        uint256 amountIn_\n    ) public payable override returns (uint256 amountOut) {\n        // Validating ETH value sent\n        require(msg.value == (fromToken_ == address(0) ? amountIn_ : 0), Error.INVALID_AMOUNT);\n        if (amountIn_ == 0) {\n            emit Swapped(fromToken_, toToken_, 0, 0);\n            return 0;\n        }\n\n        // Handling swap between the same token\n        if (fromToken_ == toToken_) {\n            if (fromToken_ == address(0)) {\n                payable(msg.sender).transfer(amountIn_);\n            }\n            emit Swapped(fromToken_, toToken_, amountIn_, amountIn_);\n            return amountIn_;\n        }\n\n        // Transferring to contract if ERC20\n        if (fromToken_ != address(0)) {\n            IERC20(fromToken_).safeTransferFrom(msg.sender, address(this), amountIn_);\n        }\n\n        // Swapping token via WETH\n        uint256 amountOut_ = _swapWethForToken(toToken_, _swapForWeth(fromToken_));\n        emit Swapped(fromToken_, toToken_, amountIn_, amountOut_);\n        return _returnTokens(toToken_, amountOut_);\n    }\n\n    /**\n     * @dev Swaps the full contract balance of token to WETH.\n     * @param token_ The token to swap to WETH.\n     * @return amountOut The amount of WETH received from the swap.\n     */\n    function _swapForWeth(address token_) internal returns (uint256 amountOut) {\n        if (token_ == address(_WETH)) return _WETH.balanceOf(address(this));\n\n        // Handling ETH -> WETH\n        if (token_ == address(0)) {\n            uint256 ethBalance_ = address(this).balance;\n            if (ethBalance_ == 0) return 0;\n            _WETH.deposit{value: ethBalance_}();\n            return ethBalance_;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            uint256 amount_ = IERC20(token_).balanceOf(address(this));\n            if (amount_ == 0) return 0;\n            _approve(token_, address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                tokenIndex_,\n                wethIndex_,\n                amount_,\n                _minWethAmountOut(amount_, token_)\n            );\n            return _WETH.balanceOf(address(this));\n        }\n\n        // Handling ERC20 -> WETH\n        return _swap(token_, address(_WETH), IERC20(token_).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Swaps the full contract balance of WETH to token.\n     * @param token_ The token to swap WETH to.\n     * @return amountOut The amount of token received from the swap.\n     */\n    function _swapWethForToken(address token_, uint256 amount_)\n        internal\n        returns (uint256 amountOut)\n    {\n        if (amount_ == 0) return 0;\n        if (token_ == address(_WETH)) return amount_;\n\n        // Handling WETH -> ETH\n        if (token_ == address(0)) {\n            _WETH.withdraw(amount_);\n            return amount_;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            _approve(address(_WETH), address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                wethIndex_,\n                tokenIndex_,\n                amount_,\n                _minTokenAmountOut(amount_, token_)\n            );\n            return IERC20(token_).balanceOf(address(this));\n        }\n\n        // Handling WETH -> ERC20\n        return _swap(address(_WETH), token_, amount_);\n    }\n\n    /**\n     * @dev Swaps an amount of fromToken to toToken.\n     * @param fromToken_ The tok"
    }
  ]
}