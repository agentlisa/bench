{
  "Title": "[M-31] Incorrect accounting logic for `fallback` gas will lead to insolvency",
  "Content": "\n### Lines of code\n\n<br><https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L823> <br><https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1044>\n\n### Proof of Concept\n\n    // on root chain\n    function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {\n        ......\n        uint256 availableGas = _depositedGas - _gasToBridgeOut;\n        uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());\n\n        if (minExecCost > availableGas) {\n            _forceRevert();\n            return;\n        }\n\n        _replenishGas(minExecCost);\n\n        //Account for excess gas\n        accumulatedFees += availableGas - minExecCost;\n    }\n\n    // on branch chain\n    function _payFallbackGas(uint32 _depositNonce, uint256 _initialGas) internal virtual {\n        ......\n        IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), minExecCost);\n        wrappedNativeToken.withdraw(minExecCost);\n        _replenishGas(minExecCost);\n    }\n\nAs above, when paying execution gas on the root chain, the excessive gas is added to `accumulatedFees`. So theoretically, all deposited gas is used up and no gas has been reserved for `anyFallback` on the branch chain. The withdrawl in `_payFallbackGas` on the branch chain will cause insolvency:\n\n    // on branch chain\n    function _payExecutionGas(address _recipient, uint256 _initialGas) internal virtual {\n        ......\n        uint256 gasLeft = gasleft();\n        uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft);\n\n        if (minExecCost > gasRemaining) {\n            _forceRevert();\n            return;\n        }\n\n        _replenishGas(minExecCost);\n\n        //Transfer gas remaining to recipient\n        SafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);\n        ......\n        }\n    }\n\n    // on root chain\n    function _payFallbackGas(uint32 _settlementNonce, uint256 _initialGas) internal virtual {\n        uint256 gasLeft = gasleft();\n        uint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);\n\n        if (minExecCost > getSettlement[_settlementNonce].gasToBridgeOut) {\n            _forceRevert();\n            return;\n        }\n\n        getSettlement[_settlementNonce].gasToBridgeOut -= minExecCost.toUint128();\n    }\n\nAs above, when paying execution gas on the branch chain, the excessive gas has be sent to the recipent. So therotically, all deposited gas is used up and no gas has been reserved for `anyFallback` on the root chain. `_payFallbackGas` does not `_replenishGas`, which will cause insolvency of the gas budget in `AnycallConfig`.\n\n### Recommended Mitigation Steps\n\nDeduct `fallback` gas from deposited gas.\n\n### Assessed type\n\nContext\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1654301154)**\n\n**[Trust (judge) decreased severity to Medium](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1655692181)**\n\n**[xuwinnie (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1655754684):**\n > Hey, I believe this is not a dup of [#786](https://github.com/code-423n4/2023-05-maia-findings/issues/786). This issue is mainly about accounting logic. I have described two scenes:\n> 1. Execute on `root` and `fallback` on branch: insolvency of the port's weth balance.\n> 2. Execute on `branch` and `fallback` on root: insolvency of the budget.\n>  \n> Even though fix from #786 is applied, the accounting logic is still incorrect. If the port's balance is reduced, it comes to scene 1: insolvency of the port's balance.\n>\n>  And this issue will cause insolvency of h-weth, so I think it reaches high.\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1655877017):**\n > > As above, when paying execution gas on the root chain, the excessive gas is added to `accumulatedFees`. So theoretically, all deposited gas is used up and no gas has been reserved for `anyFallback` on the branch chain. The withdrawal in `_payFallbackGas` on the branch chain will cause insolvency.\n> \n> 1. This isn't accurate. `fallback` gas for a call from the Root -> Branch is enforced and allocated in `_manageGasOut`, not `_payExecutionGas`, so the proposed fix will not lead to `hToken` insolvency on the Root. Although, the proposed fix should have the added detail that the balance should be obtained from `bridgeToRoot` and not a withdrawal. This can only be done once per failed deposit state, meaning it would need to be set to true and `FALLBACK_RESERVE` replenished to be deducted again.\n> \n> > As above, when paying execution gas on the branch chain, the excessive gas has be sent to the recipent. So theoretically, all deposited gas is used up and no gas has been reserved for `anyFallback` on the root chain. `_payFallbackGas` does not `_replenishGas`, which will cause insolvency of the gas budget in `AnycallConfig`.\n> \n> 2. This is also invalid since `MIN_FALLBACK_RESERVE` is enforced for keeping deposited gas in the Branch Port and gas is replenished upon `_payFallbackGas` withdrawing from the Port in an appropriate manner.\n> \n> I believe this was marked as a duplicate, owing to the fact that in 1. you described a situation in #786, where a error exists and proposed the same appropriate fix.\n\n**[xuwinnie (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1656470345):**\n> Thanks for explaining @0xBugsy. To make my point clearer, I'll give an example:\n>\n> Suppose a user calls `retrieveDeposit` and deposited 20 unit gas. `depositedGas` is 20 and `gasToBridgeOut(remoteExecutionGas)` is `0`. On the root chain, the whole process does not involve `_manageGasOut`. In `_payExecutionGas`, suppose 12 unit is replenished and then 8 unit is added to `accumulatedFees`. On the branch chain, `fallback` costs 14 gas, and then 14 units are withdrawn from the port and replenished. Overall: 20 units in, 34 units out.\n>\n> As you mentioned, I believe `_manageGasOut` should be used to manage `fallback` gas, but it seems to be only managing remote execution gas. I'm not sure I've understood everything correctly, if I misunderstood something, please tell me.\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1656676212):**\n > I believe you are not considering the fact that `Fallback` Gas is reserved every time a remote call is initiated. So if in your scenario you are calling `retrieveDeposit`, this means that the deposit already has `fallback` gas reserved in the origin branch. We are also sure that `fallback` is yet to be triggered, so this balance has not been double spent. This is enforced directly in the callout functions in branches, whereas in the Root, this is enforced in the `_manageGasOut` where gas minimum is checked and assets are converted to destination chain gas.\n> \n> Hope this made it clearer!\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1656676910):**\n > We recognize the audit's findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.\n\n**[xuwinnie (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1656714298):**\n > Hey @Trust @0xBugsy - sorry for delaying the judging process but I still need to add something.\n>> \"that deposit already has `fallback` gas reserved in the origin branch. We are also sure that `fallback` is yet to be triggered, so this balance has not been double spent.\"\n> This is not true. The balance is double spent. Let's suppose the user deposited this gas in a tx on the branch. On the root chain, although tx fails and `anyExecute` returns false, gas is still charged (since it is not `forceReverted`). So double spending occurs (on root `anyExecute` and branch `anyFallback`).\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1656723672):**\n > I believe there may have been some language barrier in our communication but what I now believe has happened is: \n> \n> 1. You disclosed everything that was covered in detail in #786.\n> 2. Added the fact, that opposed to what #786 claims, porting the Branch functioning is not enough since once initiating a cross-chain call. We should always deduct the chain's `FALLBACK_RESERVE` from the deposited gas (in the root deduct branch `fallback` reserve gas units and in branch `reverse`), which would mean the solution put forward in #786 is not 100% accurate complete .\n> \n> By the way, this was not at all made obvious in the issue took some reading between the lines, but happy we got to some understanding. Obviously, do correct me if my interpretation of what was said is incorrect in any way.\n\n**[xuwinnie (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1656726800):**\n > @0xBugsy - Yeah, this is what I want to say. I'm sorry if my previous expression is not clear enough!\n\n**[xuwinnie (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1656729258):**\n > Hi @Trust - to conclude, the core issue I described here is double spending of deposited gas which will lead to insolvency of the port's weth. I believe none of 786 or its dups has mentioned it. Thanks for your attention!\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/313#issuecomment-1656744312):**\n > Upon further inspection, the warden has uncovered a different root cause than previously dupped submissions. The risks associated are deemed of Medium severity.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\n\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\n\nimport {IApp, IRootBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\nimport {IRootRouter as IRouter} from \"./interfaces/IRootRouter.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {\n    IRootBridgeAgent,\n    DepositParams,\n    DepositMultipleParams,\n    Settlement,\n    SettlementStatus,\n    SettlementParams,\n    SettlementMultipleParams,\n    UserFeeInfo,\n    SwapCallbackData\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Library for Cross Chain Deposit Parameters Validation.\nlibrary CheckParamsLib {\n    /**\n     * @notice Function to check cross-chain deposit parameters and verify deposits made on branch chain are valid.\n     * @param _localPortAddress Address of local Port.\n     * @param _dParams Cross Chain swap parameters.\n     * @param _fromChain Chain ID of the chain where the deposit was made.\n     * @dev Local hToken must be recognized and address must match underlying if exists otherwise only local hToken is checked.\n     *\n     */\n    function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)\n        internal\n        view\n        returns (bool)\n    {\n        if (\n            (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.\n                || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.\n                || (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) //Check underlying exists.\n        ) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/// @title Library for Root Bridge Agent Deployment.\nlibrary DeployRootBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) external returns (RootBridgeAgent) {\n        return new RootBridgeAgent(\n            _wrappedNativeToken,\n            _localChainId,\n            _daoAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localPortAddress,\n            _localRouterAddress\n        );\n    }\n}\n\n/// @title  Root Bridge Agent Contract\ncontract RootBridgeAgent is IRootBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ADDRESS_SIZE = 20;\n\n    uint8 internal constant PARAMS_GAS_IN = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// BridgeIn Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint24 public immutable localChainId;\n\n    /// @notice Local Wrapped Native Token\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Address of DAO.\n    address public immutable daoAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are stored.\n    address public immutable localPortAddress;\n\n    /// @notice Local Anycall Address\n    address public immutable localAnyCallAddress;\n\n    /// @notice Local Anyexec Address\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address of Root Bridge Agent Executor.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH BRIDGE AGENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain -> Branch Bridge Agent Address. For N chains, each Root Bridge Agent Address has M =< N Branch Bridge Agent Address.\n    mapping(uint256 => address) public getBranchBridgeAgent;\n\n    /// @notice If true, bridge agent manager has allowed for a new given branch bridge agent to be synced/added.\n    mapping(uint256 => bool) public isBranchBridgeAgentAllowed;\n\n    /*///////////////////////////////////////////////////////////////\n                        SETTLEMENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public settlementNonce;\n\n    /// @notice Mapping from Settlement nonce to Deposit Struct.\n    mapping(uint32 => Settlement) public getSettlement;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint256 => mapping(uint32 => bool)) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 155_000; // 100_000 for anycall + 55_000 for fallback\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 155_000; // 100_000 for anycall + 30_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Execution\n\n    uint256 public initialGas;\n    UserFeeInfo public userFeeInfo;\n\n    /*///////////////////////////////////////////////////////////////\n                        DAO STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public accumulatedFees;\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _wrappedNativeToken Local Wrapped Native Token.\n     *     @param _daoAddress Address of DAO.\n     *     @param _localChainId Local Chain Id.\n     *     @param _localAnyCallAddress Local Anycall Address.\n     *     @param _localPortAddress Local Port Address.\n     *     @param _localRouterAddress Local Port Address.\n     */\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) {\n        require(address(_wrappedNativeToken) != address(0), \"Wrapped native token cannot be zero address\");\n        require(_daoAddress != address(0), \"DAO cannot be zero address\");\n        require(_localAnyCallAddress != address(0), \"Anycall Address cannot be zero address\");\n        require(_localAnyCallExecutorAddress != address(0), \"Anycall Executor Address cannot be zero address\");\n        require(_localPortAddress != address(0), \"Port Address cannot be zero address\");\n        require(_localRouterAddress != address(0), \"Router Address cannot be zero address\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        factoryAddress = msg.sender;\n        daoAddress = _daoAddress;\n        localChainId = _localChainId;\n        localAnyCallAddress = _localAnyCallAddress;\n        localPortAddress = _localPortAddress;\n        localRouterAddress = _localRouterAddress;\n        bridgeAgentExecutorAddress = DeployRootBridgeAgentExecutor.deploy(address(this));\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        settlementNonce = 1;\n        accumulatedFees = 1; //Avoid paying 20k gas in first `payExecutionGas` making MIN_EXECUTION_OVERHEAD constant.\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function getSettlementEntry(uint32 _settlementNonce) external view returns (Settlement memory) {\n        return getSettlement[_settlementNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {\n        //Update User Gas available.\n        if (initialGas == 0) {\n            userFeeInfo.depositedGas = uint128(msg.value);\n            userFeeInfo.gasToBridgeOut = _remoteExecutionGas;\n        }\n        //Clear Settlement with updated gas.\n        _retrySettlement(_settlementNonce);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function redeemSettlement(uint32 _depositNonce) external lock {\n        //Get deposit owner.\n        address depositOwner = getSettlement[_depositNonce].owner;\n\n        //Update Deposit\n        if (getSettlement[_depositNonce].status != SettlementStatus.Failed || depositOwner == address(0)) {\n            revert SettlementRedeemUnavailable();\n        } else if (\n            msg.sender != depositOwner && msg.sender != address(IPort(localPortAddress).getUserAccount(depositOwner))\n        ) {\n            revert NotSettlementOwner();\n        }\n        _redeemSettlement(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ROOT ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOut(address _recipient, bytes memory _data, uint24 _toChain) external payable lock requiresRouter {\n        //Encode Data for call.\n        bytes memory data =\n            abi.encodePacked(bytes1(0x00), _recipient, settlementNonce++, _data, _manageGasOut(_toChain));\n\n        //Perform Call to clear hToken balance on destination branch chain.\n        _performCall(data, _toChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridge(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address _globalAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        uint24 _toChain\n    ) external payable lock requiresRouter {\n        //Get destination Local Address from Global Address.\n        address localAddress = IPort(localPortAddress).getLocalTokenFromGlobal(_globalAddress, _toChain);\n\n        //Get destination Underlying Address from Local Address.\n        address underlyingAddress = IPort(localPortAddress).getUnderlyingTokenFromLocal(localAddress, _toChain);\n\n        //Check if valid assets\n        if (localAddress == address(0) || (underlyingAddress == address(0) && _deposit > 0)) {\n            revert InvalidInputParams();\n        }\n\n        //Prepare data for call\n        bytes memory data = abi.encodePacked(\n            bytes1(0x01),\n            _recipient,\n            settlementNonce,\n            localAddress,\n            underlyingAddress,\n            _amount,\n            _deposit,\n            _data,\n            _manageGasOut(_toChain)\n        );\n\n        //Update State to reflect bridgeOut\n        _updateStateOnBridgeOut(\n            msg.sender, _globalAddress, localAddress, underlyingAddress, _amount, _deposit, _toChain\n        );\n\n        //Create Settlement\n        _createSettlement(_owner, _recipient, localAddress, underlyingAddress, _amount, _deposit, data, _toChain);\n\n        //Perform Call to clear hToken balance on destination branch chain and perform call.\n        _performCall(data, _toChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridgeMultiple(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address[] memory _globalAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint24 _toChain\n    ) external payable lock requiresRouter {\n        address[] memory hTokens = new address[](_globalAddresses.length);\n        address[] memory tokens = new address[](_globalAddresses.length);\n        for (uint256 i = 0; i < _globalAddresses.length;) {\n            //Populate Addresses for Settlement\n            hTokens[i] = IPort(localPortAddress).getLocalTokenFromGlobal(_globalAddresses[i], _toChain);\n            tokens[i] = IPort(localPortAddress).getUnderlyingTokenFromLocal(hTokens[i], _toChain);\n\n            if (hTokens[i] == address(0) || (tokens[i] == address(0) && _deposits[i] > 0)) revert InvalidInputParams();\n\n            _updateStateOnBridgeOut(\n                msg.sender, _globalAddresses[i], hTokens[i], tokens[i], _amounts[i], _deposits[i], _toChain\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        //Prepare data for call with settlement of multiple assets\n        bytes memory data = abi.encodePacked(\n            bytes1(0x02),\n            _recipient,\n            uint8(hTokens.length),\n            settlementNonce,\n            hTokens,\n            tokens,\n            _amounts,\n            _deposits,\n            _data,\n            _manageGasOut(_toChain)\n        );\n\n        //Create Settlement Balance\n        _createMultipleSettlement(_owner, _recipient, hTokens, tokens, _amounts, _deposits, data, _toChain);\n\n        //Perform Call to destination Branch Chain.\n        _performCall(data, _toChain);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint24 _fromChain)\n        public\n        requiresAgentExecutor\n    {\n        //Check Deposit info from Cross Chain Parameters.\n        if (!CheckParamsLib.checkParams(localPortAddress, _dParams, _fromChain)) {\n            revert InvalidInputParams();\n        }\n\n        //Get global address\n        address globalAddress = IPort(localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _fromChain);\n\n        //Check if valid asset\n        if (globalAddress == address(0)) revert InvalidInputParams();\n\n        //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n        IPort(localPortAddress).bridgeToRoot(_recipient, globalAddress, _dParams.amount, _dParams.deposit, _fromChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeInMultiple(address _recipient, DepositMultipleParams memory _dParams, uint24 _fromChain)\n        external\n        requiresAgentExecutor\n    {\n        for (uint256 i = 0; i < _dParams.hTokens.length;) {\n            bridgeIn(\n                _recipient,\n                DepositParams({\n                    hToken: _dParams.hTokens[i],\n                    token: _dParams.tokens[i],\n                    amount: _dParams.amounts[i],\n                    deposit: _dParams.deposits[i],\n                    toChain: _dParams.toChain,\n                    depositNonce: 0\n                }),\n                _fromChain\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the token balance state by moving assets from root omnichain environment to branch chain, when a user wants to bridge out tokens from the root bridge agent chain.\n     *     @param _sender address of the sender.\n     *     @param _globalAddress address of the global token.\n     *     @param _localAddress address of the local token.\n     *     @param _underlyingAddress address of the underlying token.\n     *     @param _amount amount of hTokens to be bridged out.\n     *     @param _deposit amount of underlying tokens to be bridged out.\n     *     @param _toChain chain to bridge to.\n     */\n    function _updateStateOnBridgeOut(\n        address _sender,\n        address _globalAddress,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        uint24 _toChain\n    ) internal {\n        if (_amount - _deposit > 0) {\n            //Move output hTokens from Root to Branch\n            if (_localAddress == address(0)) revert UnrecognizedLocalAddress();\n            _globalAddress.safeTransferFrom(_sender, localPortAddress, _amount - _deposit);\n        }\n\n        if (_deposit > 0) {\n            //Verify there is enough balance to clear native tokens if needed\n            if (_underlyingAddress == address(0)) revert UnrecognizedUnderlyingAddress();\n            if (IERC20hTokenRoot(_globalAddress).getTokenBalance(_toChain) < _deposit) {\n                revert InsufficientBalanceForSettlement();\n            }\n            IPort(localPortAddress).burn(_sender, _globalAddress, _deposit, _toChain);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                SETTLEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to store a Settlement instance. Settlement should be reopened if fallback occurs.\n     *    @param _owner settlement owner address.\n     *    @param _recipient destination chain reciever address.\n     *    @param _hToken deposited global token address.\n     *    @param _token deposited global token address.\n     *    @param _amount amounts of total hTokens + Tokens output.\n     *    @param _deposit amount of underlying / native token to output.\n     *    @param _callData calldata to execute on destination Router.\n     *    @param _toChain Destination chain identificator.\n     *\n     */\n    function _createSettlement(\n        address _owner,\n        address _recipient,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        bytes memory _callData,\n        uint24 _toChain\n    ) internal {\n        //Cast to Dynamic\n        address[] memory hTokens = new address[](1);\n        hTokens[0] = _hToken;\n        address[] memory tokens = new address[](1);\n        tokens[0] = _token;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _amount;\n        uint256[] memory deposits = new uint256[](1);\n        deposits[0] = _deposit;\n\n        //Call createSettlement\n        _createMultipleSettlement(_owner, _recipient, hTokens, tokens, amounts, deposits, _callData, _toChain);\n    }\n\n    /**\n     * @notice Function to create a settlemment. Settlement should be reopened if fallback occurs.\n     *    @param _owner settlement owner address.\n     *    @param _recipient destination chain reciever address.\n     *    @param _hTokens deposited global token addresses.\n     *    @param _tokens deposited global token addresses.\n     *    @param _amounts amounts of total hTokens + Tokens output.\n     *    @param _deposits amount of underlying / native tokens to output.\n     *    @param _callData calldata to execute on destination Router.\n     *    @param _toChain Destination chain identificator.\n     *\n     *\n     */\n    function _createMultipleSettlement(\n        address _owner,\n        address _recipient,\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        bytes memory _callData,\n        uint24 _toChain\n    ) internal {\n        // Update State\n        getSettlement[_getAndIncrementSettlementNonce()] = Settlement({\n            owner: _owner,\n            recipient: _recipient,\n            hTokens: _hTokens,\n            tokens: _tokens,\n            amounts: _amounts,\n            deposits: _deposits,\n            callData: _callData,\n            toChain: _toChain,\n            status: SettlementStatus.Success,\n            gasToBridgeOut: userFeeInfo.gasToBridgeOut\n        });\n    }\n\n    /**\n     * @notice Function to retry a user's Settlement balance with a new amount of gas to bridge out of Root Bridge Agent's Omnichain Environment.\n     *    @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _retrySettlement(uint32 _settlementNonce) internal returns (bool) {\n        //Get Settlement\n        Settlement memory settlement = getSettlement[_settlementNonce];\n\n        //Check if Settlement hasn't been redeemed.\n        if (settlement.owner == address(0)) return false;\n\n        //abi encodePacked\n        bytes memory newGas = abi.encodePacked(_manageGasOut(settlement.toChain));\n\n        //overwrite last 16bytes of callData\n        for (uint256 i = 0; i < newGas.length;) {\n            settlement.callData[settlement.callData.length - 16 + i] = newGas[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        //Update Gas To Bridge Out\n        settlementReference.gasToBridgeOut = userFeeInfo.gasToBridgeOut;\n\n        //Set Settlement Calldata to send to Branch Chain\n        settlementReference.callData = settlement.callData;\n\n        //Update Settlement Staus\n        settlementReference.status = SettlementStatus.Success;\n\n        //Retry call with additional gas\n        _performCall(settlement.callData, settlement.toChain);\n\n        //Retry Success\n        return true;\n    }\n\n    /**\n     * @notice Function to retry a user's Settlement balance.\n     *     @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _redeemSettlement(uint32 _settlementNonce) internal {\n        // Get storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        //Clear Global hTokens To Recipient on Root Chain cancelling Settlement to Branch\n        for (uint256 i = 0; i < settlement.hTokens.length;) {\n            //Check if asset\n            if (settlement.hTokens[i] != address(0)) {\n                //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n                IPort(localPortAddress).bridgeToRoot(\n                    msg.sender,\n                    IPort(localPortAddress).getGlobalTokenFromLocal(settlement.hTokens[i], settlement.toChain),\n                    settlement.amounts[i],\n                    settlement.deposits[i],\n                    settlement.toChain\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Settlement\n        delete getSettlement[_settlementNonce];\n    }\n\n    /**\n     * @notice Function to reopen a user's Settlement balance as pending and thus retryable by users. Called upon anyFallback of triggered by Branch Bridge Agent.\n     *     @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _reopenSettlemment(uint32 _settlementNonce) internal {\n        //Update Deposit\n        getSettlement[_settlementNonce].status = SettlementStatus.Failed;\n    }\n\n    /**\n     * @notice Function that returns Deposit nonce and increments nonce counter.\n     *\n     */\n    function _getAndIncrementSettlementNonce() internal returns (uint32) {\n        return settlementNonce++;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    GAS SWAP INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint24 private constant GLOBAL_DIVISIONER = 1e6; // for basis point (0.0001%)\n\n    //Local mapping of valid gas pools\n    mapping(address => bool) private approvedGasPool;\n\n    /// @inheritdoc IRootBridgeAgent\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external {\n        if (!approvedGasPool[msg.sender]) revert CallerIsNotPool();\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n\n        address(data.tokenIn).safeTransfer(msg.sender, uint256(amount0 > 0 ? amount0 : amount1));\n    }\n\n    /**\n     * @notice Swaps gas tokens from the given branch chain to the root chain\n     * @param _amount amount of gas token to swap\n     * @param _fromChain chain to swap from\n     */\n    function _gasSwapIn(uint256 _amount, uint24 _fromChain) internal returns (uint256) {\n        //Get fromChain's Gas Pool Info\n        (bool zeroForOneOnInflow, uint24 priceImpactPercentage, address gasTokenGlobalAddress, address poolAddress) =\n            IPort(localPortAddress).getGasPoolInfo(_fromChain);\n\n        //Check if valid addresses\n        if (gasTokenGlobalAddress == address(0) || poolAddress == address(0)) revert InvalidGasPool();\n\n        //Move Gas hTokens from Branch to Root / Mint Sufficient hTokens to match new port deposit\n        IPort(localPortAddress).bridgeToRoot(address(this), gasTokenGlobalAddress, _amount, _amount, _fromChain);\n\n        //Save Gas Pool for future use\n        if (!approvedGasPool[poolAddress]) approvedGasPool[poolAddress] = true;\n\n        //Get sqrtPriceX96\n        (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();\n\n        // Calculate Price limit depending on pre-set price impact\n        uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (priceImpactPercentage / 2)) / GLOBAL_DIVISIONER;\n\n        //Get limit\n        uint160 sqrtPriceLimitX96 =\n            zeroForOneOnInflow ? sqrtPriceX96 - exactSqrtPriceImpact : sqrtPriceX96 + exactSqrtPriceImpact;\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        try IUniswapV3Pool(poolAddress).swap(\n            address(this),\n            zeroForOneOnInflow,\n            int256(_amount),\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({tokenIn: gasTokenGlobalAddress}))\n        ) returns (int256 amount0, int256 amount1) {\n            return uint256(zeroForOneOnInflow ? amount1 : amount0);\n        } catch (bytes memory) {\n            _forceRevert();\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Swaps gas tokens from the given root chain to the branch chain\n     * @param _amount amount of gas token to swap\n     * @param _toChain chain to swap to\n     */\n    function _gasSwapOut(uint256 _amount, uint24 _toChain) internal returns (uint256, address) {\n        //Get fromChain's Gas Pool Info\n        (bool zeroForOneOnInflow, uint24 priceImpactPercentage, address gasTokenGlobalAddress, address poolAddress) =\n            IPort(localPortAddress).getGasPoolInfo(_toChain);\n\n        //Check if valid addresses\n        if (gasTokenGlobalAddress == address(0) || poolAddress == address(0)) revert InvalidGasPool();\n\n        //Save Gas Pool for future use\n        if (!approvedGasPool[poolAddress]) approvedGasPool[poolAddress] = true;\n\n        uint160 sqrtPriceLimitX96;\n        {\n            //Get sqrtPriceX96\n            (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();\n\n            // Calculate Price limit depending on pre-set price impact\n            uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (priceImpactPercentage / 2)) / GLOBAL_DIVISIONER;\n\n            //Get limit\n            sqrtPriceLimitX96 =\n                zeroForOneOnInflow ? sqrtPriceX96 + exactSqrtPriceImpact : sqrtPriceX96 - exactSqrtPriceImpact;\n        }\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        (int256 amount0, int256 amount1) = IUniswapV3Pool(poolAddress).swap(\n            address(this),\n            !zeroForOneOnInflow,\n            int256(_amount),\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({tokenIn: address(wrappedNativeToken)}))\n        );\n\n        return (uint256(!zeroForOneOnInflow ? amount1 : amount0), gasTokenGlobalAddress);\n    }\n\n    /**\n     * @notice Manages gas costs of bridging from Root to a given Branch.\n     * @param _toChain destination chain.\n     */\n    function _manageGasOut(uint24 _toChain) internal returns (uint128) {\n        uint256 amountOut;\n        address gasToken;\n        uint256 _initialGas = initialGas;\n\n        if (_toChain == localChainId) {\n            //Transfer gasToBridgeOut Local Branch Bridge Agent if remote initiated call.\n            if (_initialGas > 0) {\n                address(wrappedNativeToken).safeTransfer(getBranchBridgeAgent[localChainId], userFeeInfo.gasToBridgeOut);\n            }\n\n            return uint128(userFeeInfo.gasToBridgeOut);\n        }\n\n        if (_initialGas > 0) {\n            if (userFeeInfo.gasToBridgeOut <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();\n            (amountOut, gasToken) = _gasSwapOut(userFeeInfo.gasToBridgeOut, _toChain);\n        } else {\n            if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();\n            wrappedNativeToken.deposit{value: msg.value}();\n            (amountOut, gasToken) = _gasSwapOut(msg.value, _toChain);\n        }\n\n        IPort(localPortAddress).burn(address(this), gasToken, amountOut, _toChain);\n        return amountOut.toUint128();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ANYCALL INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal function performs call to AnycallProxy Contract for cross-chain messaging.\n    function _performCall(bytes memory _calldata, uint256 _toChain) internal {\n        address callee = getBranchBridgeAgent[_toChain];\n\n        if (callee == address(0)) revert UnrecognizedBridgeAgent();\n\n        if (_toChain != localChainId) {\n            //Sends message to AnycallProxy\n            IAnycallProxy(localAnyCallAddress).anyCall(\n                callee, _calldata, _toChain, AnycallFlags.FLAG_ALLOW_FALLBACK_DST, \"\"\n            );\n        } else {\n            //Execute locally\n            IBranchBridgeAgent(callee).anyExecute(_calldata);\n        }\n    }\n\n    /**\n     * @notice Pays for the remote call execution gas. Demands that the user has enough gas to replenish gas for the anycall config contract or forces reversion.\n     * @param _depositedGas available user gas to pay for execution.\n     * @param _gasToBridgeOut amount of gas needed to bridge out.\n     * @param _initialGas initial gas used by the transaction.\n     * @param _fromChain chain remote action initiated from.\n     */\n    function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain)\n        internal\n    {\n        //reset initial remote execution gas and remote execution fee information\n        delete(initialGas);\n        delete(userFeeInfo);\n\n        if (_fromChain == localChainId) return;\n\n        //Get Available Gas\n        uint256 availableGas = _depositedGas - _gasToBridgeOut;\n\n        //Get Root Environment Execution Cost\n        uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());\n\n        //Check if sufficient balance\n        if (minExecCost > availableGas) {\n            _forceRevert();\n            return;\n        }\n\n        //Replenish Gas\n        _replenishGas(minExecCost);\n\n        //Account for excess gas\n        accumulatedFees += availableGas - minExecCost;\n    }\n\n    /**\n     * @notice Updates the user de"
    }
  ]
}