{
  "Title": "Lack of Event Emissions",
  "Content": "Throughout the codebase, several instances were identified where events should be emitted.\n\n\n* When `Whitelist` is deployed, the `owner` [is set](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/predeploys/Whitelist.sol#L17-L19) by the constructor. Because `owner` is not set using `_transferOwnership`, the `OwnershipTransferred` event is not emitted.\n* The [`updateMessenger` function](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/predeploys/L2MessageQueue.sol#L47) does not emit an event upon the successful update of the `L2ScrollMessenger` address.\n* The [`L2GatewayRouter`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2GatewayRouter.sol) does not emit an event [when setting `defaultERC20Gateway`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2GatewayRouter.sol#L43) in the `initialize` function.\n\n\nConsider emitting the `OwnershipTransferred` event, as well as an event when the address of the `L2ScrollMessenger` gets updated on the `L2MessageQueue` contract. Furthermore, consider emitting the `SetERC20Gateway` event when the `L2GatewayRouter` is initialized. Emitting events provides a way for external integrations to track changes being made to the contract configuration by external integrations. This is especially important for monitoring operations and proper incident response, particularly with regard to trusted entities with special privileges.\n\n\n***Update:** Resolved in [pull request #650](https://github.com/scroll-tech/scroll/pull/650) at commit [90cf7b7](https://github.com/scroll-tech/scroll/pull/650/commits/90cf7b7af59e87134d71947034788b4c81709fbf).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L2/predeploys/Whitelist.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableBase} from \"../../libraries/common/OwnableBase.sol\";\nimport {IWhitelist} from \"../../libraries/common/IWhitelist.sol\";\n\ncontract Whitelist is OwnableBase, IWhitelist {\n    /// @notice Emitted when account whitelist status changed.\n    /// @param _account The address of account whose status is changed.\n    /// @param _status The current whitelist status.\n    event WhitelistStatusChanged(address indexed _account, bool _status);\n\n    /// @notice Keep track whether the account is whitelisted.\n    mapping(address => bool) private isWhitelisted;\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    /// @notice See {IWhitelist-isSenderAllowed}\n    function isSenderAllowed(address _sender) external view returns (bool) {\n        return isWhitelisted[_sender];\n    }\n\n    /// @notice Update the whitelist status\n    /// @param _accounts The list of addresses to update.\n    /// @param _status The whitelist status to update.\n    function updateWhitelistStatus(address[] memory _accounts, bool _status) external onlyOwner {\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            isWhitelisted[_accounts[i]] = _status;\n            emit WhitelistStatusChanged(_accounts[i], _status);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/L2/predeploys/L2MessageQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {AppendOnlyMerkleTree} from \"../../libraries/common/AppendOnlyMerkleTree.sol\";\nimport {OwnableBase} from \"../../libraries/common/OwnableBase.sol\";\n\n/// @title L2MessageQueue\n/// @notice The original idea is from Optimism, see [OVM_L2ToL1MessagePasser](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/L2/predeploys/OVM_L2ToL1MessagePasser.sol).\n/// The L2 to L1 Message Passer is a utility contract which facilitate an L1 proof of the\n/// of a message on L2. The L1 Cross Domain Messenger performs this proof in its\n/// _verifyStorageProof function, which verifies the existence of the transaction hash in this\n/// contract's `sentMessages` mapping.\ncontract L2MessageQueue is AppendOnlyMerkleTree, OwnableBase {\n    /// @notice Emitted when a new message is added to the merkle tree.\n    /// @param index The index of the corresponding message.\n    /// @param messageHash The hash of the corresponding message.\n    event AppendMessage(uint256 index, bytes32 messageHash);\n\n    /// @notice The address of L2ScrollMessenger contract.\n    address public messenger;\n\n    constructor(address _owner) {\n        _transferOwnership(_owner);\n    }\n\n    function initialize() external {\n        _initializeMerkleTree();\n    }\n\n    /// @notice record the message to merkle tree and compute the new root.\n    /// @param _messageHash The hash of the new added message.\n    function appendMessage(bytes32 _messageHash) external returns (bytes32) {\n        require(msg.sender == messenger, \"only messenger\");\n\n        (uint256 _currentNonce, bytes32 _currentRoot) = _appendMessageHash(_messageHash);\n\n        // We can use the event to compute the merkle tree locally.\n        emit AppendMessage(_currentNonce, _messageHash);\n\n        return _currentRoot;\n    }\n\n    /// @notice Update the address of messenger.\n    /// @dev You are not allowed to update messenger when there are some messages appended.\n    /// @param _messenger The address of messenger to update.\n    function updateMessenger(address _messenger) external onlyOwner {\n        require(nextMessageIndex == 0, \"cannot update messenger\");\n\n        messenger = _messenger;\n    }\n}"
    }
  ]
}