{
  "Title": "M-12: `QVBaseStrategy::reviewRecipients()` doesn't check if the recipient is already accepted or rejected, and overwrites the current status",
  "Content": "# Issue M-12: `QVBaseStrategy::reviewRecipients()` doesn't check if the recipient is already accepted or rejected, and overwrites the current status \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/699 \n\n## Found by \n0x00ffDa, BenRai, gkrastenov, osmanozdemir1, xAriextz\n\n## Vulnerability Detail\nIn the QV strategy contracts, recipients register themselves and wait for a pool manager to accept the registration. Pool managers can accept or reject recipients with the `reviewRecipients()` function. There is also a threshold (`reviewThreshold`) for recipients to be accepted. For example, if the `reviewThreshold` is 2, a pending recipient gets accepted when two managers accept this recipient and the `recipientStatus` is updated.\n\nHowever, `QVBaseStrategy::reviewRecipients()` function doesn't check the recipient's current status. This one alone may not be an issue because managers may want to change the status of the recipient etc.  \nBut on top of that, the function also doesn't take the previous review counts into account when updating the status, and overwrites the status immediately after reaching the threshold. I'll share a scenario later about this below.\n\nHere is the `reviewRecipients()` function:  \n[https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L254C1-L288C6](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L254C1-L288C6)\n\n```solidity\nfile: QVBaseStrategy.sol\n    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)\n        external\n        virtual\n        onlyPoolManager(msg.sender)\n        onlyActiveRegistration\n    {\n        // make sure the arrays are the same length\n        uint256 recipientLength = _recipientIds.length;\n        if (recipientLength != _recipientStatuses.length) revert INVALID();\n\n        for (uint256 i; i < recipientLength;) {\n            Status recipientStatus = _recipientStatuses[i];\n            address recipientId = _recipientIds[i];\n\n            // if the status is none or appealed then revert\n            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) { //@audit these are the input parameter statuse not the recipient's status.\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            reviewsByStatus[recipientId][recipientStatus]++;\n\n -->        if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) { //@audit recipientStatus is updated right after the threshold is reached. It can overwrite if the status is already set.\n                Recipient storage recipient = recipients[recipientId];\n                recipient.recipientStatus = recipientStatus;\n\n                emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));\n            }\n\n            emit Reviewed(recipientId, recipientStatus, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\n\nAs I mentioned above, the function updates the `recipientStatus` immediately after reaching the threshold. Here is a scenario of why this might be an issue.\n\n**Example Scenario**  \nThe pool has 5 managers and the `reviewThreshold` is 2.\n\n1. The first manager rejects the recipient\n    \n2. The second manager accepts the recipient\n    \n3. The third manager rejects the recipient. -&gt; `recipientStatus` updated -&gt; `status = REJECTED`\n    \n4. The fourth manager rejects the recipient -&gt; status still `REJECTED`\n    \n5. The last manager accepts the recipient -&gt;`recipientStatus` updated again -&gt; `status = ACCEPTED`\n    \n\n*3 managers rejected and 2 managers accepted the recipient but the recipient status is overwritten without checking the recipient's previous status and is ACCEPTED now.*\n\n## Coded PoC\n\nYou can prove the scenario above with the PoC. You can use the protocol's own setup for this.  \n\\- Copy the snippet below and paste it into the `QVBaseStrategy.t.sol` test file.  \n\\- Run forge test `--match-test test_reviewRecipient_reviewTreshold_OverwriteTheLastOne`\n\n```solidity\n//@audit More managers rejected but the recipient is accepted\n    function test_reviewRecipient_reviewTreshold_OverwriteTheLastOne() public virtual {\n        address recipientId = __register_recipient();\n\n        // Create rejection status\n        address[] memory recipientIds = new address[](1);\n        recipientIds[0] = recipientId;\n        IStrategy.Status[] memory Statuses = new IStrategy.Status[](1);\n        Statuses[0] = IStrategy.Status.Rejected;\n\n        // Reject three times with different managers\n        vm.startPrank(pool_manager1());\n        qvStrategy().reviewRecipients(recipientIds, Statuses);\n\n        vm.startPrank(pool_manager2());\n        qvStrategy().reviewRecipients(recipientIds, Statuses);\n\n        vm.startPrank(pool_manager3());\n        qvStrategy().reviewRecipients(recipientIds, Statuses);\n\n        // Three managers rejected. Status will be rejected.\n        assertEq(uint8(qvStrategy().getRecipientStatus(recipientId)), uint8(IStrategy.Status.Rejected));\n        assertEq(qvStrategy().reviewsByStatus(recipientId, IStrategy.Status.Rejected), 3);\n\n        // Accept two times after three rejections\n        Statuses[0] = IStrategy.Status.Accepted;\n        vm.startPrank(pool_admin());\n        qvStrategy().reviewRecipients(recipientIds, Statuses);\n\n        vm.startPrank(pool_manager4());\n        qvStrategy().reviewRecipients(recipientIds, Statuses);\n\n        // 3 Rejected, 2 Accepted, but status is Accepted because it overwrites right after passing threshold.\n        assertEq(uint8(qvStrategy().getRecipientStatus(recipientId)), uint8(IStrategy.Status.Accepted));\n        assertEq(qvStrategy().reviewsByStatus(recipientId, IStrategy.Status.Rejected), 3);\n        assertEq(qvStrategy().reviewsByStatus(recipientId, IStrategy.Status.Accepted), 2);\n    }\n```\n\nYou can find the test results below:\n\n```solidity\nRunning 1 test for test/foundry/strategies/QVSimpleStrategy.t.sol:QVSimpleStrategyTest\n[PASS] test_reviewRecipient_reviewTreshold_OverwriteTheLastOne() (gas: 249604)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 10.92ms\n```\n\n## Impact\nRecipient status might be overwritten with less review counts.\n\n## Code Snippet\n[https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L254C1-L288C6](https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L254C1-L288C6)\n\n```solidity\nfile: QVBaseStrategy.sol\n    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)\n        external\n        virtual\n        onlyPoolManager(msg.sender)\n        onlyActiveRegistration\n    {\n        // make sure the arrays are the same length\n        uint256 recipientLength = _recipientIds.length;\n        if (recipientLength != _recipientStatuses.length) revert INVALID();\n\n        for (uint256 i; i < recipientLength;) {\n            Status recipientStatus = _recipientStatuses[i];\n            address recipientId = _recipientIds[i];\n\n            // if the status is none or appealed then revert\n            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) { //@audit these are the input parameter statuse not the recipient's status.\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            reviewsByStatus[recipientId][recipientStatus]++;\n\n -->        if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) { //@audit recipientStatus is updated right after the threshold is reached. It can overwrite if the status is already set.\n                Recipient storage recipient = recipients[recipientId];\n                recipient.recipientStatus = recipientStatus;\n\n                emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));\n            }\n\n            emit Reviewed(recipientId, recipientStatus, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nChecking the review counts before updating the state might be helpful to mitigate this issue\n\n\n\n## Discussion\n\n**0xKurt**\n\n@nfrgosselin \nHow to deal with this depends of how the pool admin wants to approve or reject applications:\n\n1. Count each status --> 4 accepted and 2 rejected with threshold at 8 this would be approved\n2. Whatever the last status set is --> the last manager to set the status\n3. Once the status is set it cannot be changed\n\nThese are a couple example we thought of. WDYT?\n\n**sherlock-admin2**\n\n> Escalate\n> \n> #589 and #699 are essentially describing the same root cause. All relevant dupes associated with this two issues should be combined, as both are describing the possibility of pool manager reviewing a recipient multiple times leading to overwritten recipient status.\n\n    You've deleted an escalation for this issue.\n\n**osmanozdemir1**\n\n> Escalate\n> \n> #589 and #699 are essentially describing the same root cause. All relevant dupes associated with this two issues should be combined, as both are describing the possibility of pool manager reviewing a recipient multiple times leading to overwritten recipient status.\n\nThis issue doesn't describe same manager reviewing a recipient multiple times. As you can see in the coded PoC above, every review is made by different managers. This issue is far different than the #589 and describes recipient can be changed even with less review counts.\n\n**nevillehuang**\n\nI still stand that both are duplicates. Both are describing the same root cause of not checking the previous status and not respecting review threshold, allowing  overwriting of recipient status \n\n**BenRai1**\n\nI would side with @osmanozdemir1 on that. The issues https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/589 and https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/699 are different since they describe two different issues where the fix is different. \n\nThe first issue would be fixed by tracking what manager already voted for what recipient. This would not fix the issue where the last manager who reviews a recipient can turn the result even if more managers voted for an other result. Just becasue both issues are in the same function this does not mean that they are the same\n\n\n**nevillehuang**\n\n> I would side with @osmanozdemir1 on that. The issues #589 and #699 are different since they describe two different issues where the fix is different.\n> \n> The first issue would be fixed by tracking what manager already voted for what recipient. This would not fix the issue where the last manager who reviews a recipient can turn the result even if more managers voted for an other result. Just becasue both issues are in the same function this does not mean that they are the same\n\nOn second thought, you are right, the issues are not duplicates. One is talking about pool managers potentially casting many votes influencing recipient status by bypassing `reviewThreshold`, while the other is pool managers casting votes as expected but doesn't respect the majority outcome. Removing escalation\n\n**0xf1b0**\n\nIn my report #315, I mentioned both cases described in #589 and this one. If it's not a duplicate I should be added to the #699 \"found by\" list.\n\n**nevillehuang**\n\nEscalate\n\nOn third thought, report #315 mentions both issues, and again convinces me that #589 and #699 are stemming from the same root cause of ineffective reviewThresholds. Both issues stems from overriding recipient status, regardless it being the same pool manager or multiple different pool manager.  #315 should be made a primary issue and all other issues should be dupped under it.\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> On third thought, report #315 mentions both issues, and again convinces me that #589 and #699 are stemming from the same root cause of ineffective reviewThresholds. Both issues stems from overriding recipient status, regardless it being the same pool manager or multiple different pool manager.  #315 should be made a primary issue and all other issues should be dupped under it.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**osmanozdemir1**\n\n> Escalate\n> \n> On third thought, report #315 mentions both issues, and again convinces me that #589 and #699 are stemming from the same root cause of ineffective reviewThresholds. Both issues stems from overriding recipient status, regardless it being the same pool manager or multiple different pool manager. #315 should be made a primary issue and all other issues should be dupped under it.\n\nI disagree with this comment and disagree with both of these issues being duplicates. \nThe solution of the first issue is tracking which manager reviewed which recipient with a mapping. This solution is implemented in this [fix](https://github.com/allo-protocol/allo-v2/pull/350/files). The fix of the first issue does not solve the second issue. The solution of the second issue can be implemented in different ways depending on the developer team's intentions. Which is mentioned [here](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/699#issuecomment-1753463336), and the fix is implemented [here](https://github.com/allo-protocol/allo-v2/pull/349/files). As you can see the fixes of these two issues are quite different.\n\nJust because one submission (#315) mentioning two different issues together doesn't mean those two issues are the same, and doesn't mean all of them should be duped together. It only means that the submitter preferred to submit them together to strengthen his/her submission. As you can see in the Sherlock documentation, [best practices number 3](https://docs.sherlock.xyz/audits/judging/judging#x.-best-practices): _\"Do not submit multiple issues in a single submission. Even if the 2 completely different issues occur on the same line, please make sure to separately submit them\"_\n \nI'm not sure if the Sherlock allows labelling one submission with two different duplicate labels in these kind of situations. #315 might be duped under both of these two primary issues or it can be duped under the one with less duplicates according to the Sherlock rules and the judge's decision.\n\n\n\n**0xf1b0**\n\nBy the way, my report #315 also includes a mention of and a proposed fix for #729 issue. Since it's my first time participating in a contest and I don't have the capability to escalate, I'll leave it here with the hope that it will be taken into consideration.\n\n**0xf1b0**\n\nI will certainly need to reconsider the issue submission process.\n\nHowever, it's important to note that \"best practices\" should not be interpreted as rigid rules. The documentation does not explicitly state that deviating from these practices will result in no rewards or that only a single issue will be acknowledged.\n\nMoreover, the question of whether these issues are truly separate remains a subject of debate.\n\n**neeksec**\n\nI suggest to keep the orignal judging.\n\n> Both are describing the same root cause of not checking the previous status and not respecting review threshold\n\nThis one is not checking the previous status and #589 is not respecting review threshold. Although these two bugs both alow to manipulate review status, the root cause is different. The fixes are also different which was well described by https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/699#issuecomment-1763517995.\n\n**jacksanford1**\n\nhttps://github.com/allo-protocol/allo-v2/pull/349\n\n**Evert0x**\n\nPlanning to reject escalation and keep issue state.\n\nRoot cause is different in the mentioned issues.\n\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/699/#issuecomment-1763461674): rejected\n\n**jack-the-pug**\n\nNot Fixed.\n\nManagers who haven't voted yet can still change a recipient's status by voting for another status.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title QVBaseStrategy\n/// @notice Base strategy for quadratic voting strategies\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\nabstract contract QVBaseStrategy is BaseStrategy {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId ID of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    /// @param status The updated status of the recipient\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender, Status status);\n\n    /// @notice Emitted when a recipient is registered\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event RecipientStatusUpdated(address indexed recipientId, Status status, address sender);\n    /// @notice Emitted when the pool timestamps are updated\n    /// @param registrationStartTime The start time for the registration\n    /// @param registrationEndTime The end time for the registration\n    /// @param allocationStartTime The start time for the allocation\n    /// @param allocationEndTime The end time for the allocation\n    /// @param sender The sender of the transaction\n    event TimestampsUpdated(\n        uint64 registrationStartTime,\n        uint64 registrationEndTime,\n        uint64 allocationStartTime,\n        uint64 allocationEndTime,\n        address sender\n    );\n\n    /// @notice Emitted when a recipient receives votes\n    /// @param recipientId ID of the recipient\n    /// @param votes The votes allocated to the recipient\n    /// @param allocator The allocator assigning the votes\n    event Allocated(address indexed recipientId, uint256 votes, address allocator);\n\n    /// @notice Emitted when a recipient is reviewed\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event Reviewed(address indexed recipientId, Status status, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    // slot 0\n    /// @notice The total number of votes cast for all recipients\n    uint256 public totalRecipientVotes;\n\n    // slot 1\n    /// @notice The number of votes required to review a recipient\n    uint256 public reviewThreshold;\n\n    // slot 2\n    /// @notice The start and end times for registrations and allocations\n    /// @dev The values will be in milliseconds since the epoch\n    uint64 public registrationStartTime;\n    uint64 public registrationEndTime;\n    uint64 public allocationStartTime;\n    uint64 public allocationEndTime;\n\n    // slot 3\n    /// @notice Whether or not the strategy is using registry gating\n    bool public registryGating;\n\n    /// @notice Whether or not the strategy requires metadata\n    bool public metadataRequired;\n\n    /// @notice The registry contract\n    IRegistry private _registry;\n\n    // slots [4...n]\n    /// @notice The status of the recipient for this strategy only\n    /// @dev There is a core `IStrategy.RecipientStatus` that this should map to\n    enum InternalRecipientStatus {\n        None,\n        Pending,\n        Accepted,\n        Rejected,\n        Appealed\n    }\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParams {\n        // slot 0\n        bool registryGating;\n        bool metadataRequired;\n        // slot 1\n        uint256 reviewThreshold;\n        // slot 2\n        uint64 registrationStartTime;\n        uint64 registrationEndTime;\n        uint64 allocationStartTime;\n        uint64 allocationEndTime;\n    }\n\n    /// @notice The details of the recipient\n    struct Recipient {\n        // slot 0\n        uint256 totalVotesReceived;\n        // slot 1\n        bool useRegistryAnchor;\n        address recipientAddress;\n        Metadata metadata;\n        Status recipientStatus;\n    }\n\n    /// @notice The details of the allocator\n    struct Allocator {\n        // slot 0\n        uint256 voiceCredits;\n        // slots [1...n]\n        mapping(address => uint256) voiceCreditsCastToRecipient;\n        mapping(address => uint256) votesCastToRecipient;\n    }\n\n    /// @notice The details of the recipient are returned using their ID\n    /// @dev recipientId => Recipient\n    mapping(address => Recipient) public recipients;\n\n    /// @notice The details of the allocator are returned using their address\n    /// @dev allocator address => Allocator\n    mapping(address => Allocator) public allocators;\n\n    /// @notice Returns whether or not the recipient has been paid out using their ID\n    /// @dev recipientId => paid out\n    mapping(address => bool) public paidOut;\n\n    // recipientId -> status -> count\n    mapping(address => mapping(Status => uint256)) public reviewsByStatus;\n\n    /// ================================\n    /// ========== Modifier ============\n    /// ================================\n\n    /// @notice Modifier to check if the registration is active\n    /// @dev Reverts if the registration is not active\n    modifier onlyActiveRegistration() {\n        _checkOnlyActiveRegistration();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    modifier onlyActiveAllocation() {\n        _checkOnlyActiveAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    modifier onlyAfterAllocation() {\n        _checkOnlyAfterAllocation();\n        _;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ====================================\n    /// =========== Initialize =============\n    /// ====================================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    function initialize(uint256 _poolId, bytes memory _data) external virtual;\n\n    /// @notice Internal initialize function\n    /// @param _poolId The ID of the pool\n    /// @param _params The initialize params for the strategy\n    function __QVBaseStrategy_init(uint256 _poolId, InitializeParams memory _params) internal {\n        __BaseStrategy_init(_poolId);\n\n        registryGating = _params.registryGating;\n        metadataRequired = _params.metadataRequired;\n        _registry = allo.getRegistry();\n\n        reviewThreshold = _params.reviewThreshold;\n\n        _updatePoolTimestamps(\n            _params.registrationStartTime,\n            _params.registrationEndTime,\n            _params.allocationStartTime,\n            _params.allocationEndTime\n        );\n    }\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Get recipient status\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view virtual override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Checks if a pool is active or not\n    /// @return Whether the pool is active or not\n    function _isPoolActive() internal view virtual override returns (bool) {\n        if (registrationStartTime <= block.timestamp && block.timestamp <= registrationEndTime) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Review recipient(s) application(s)\n    /// @dev You can review multiple recipients at once or just one. This can only be called by a pool manager and\n    ///      only during active registration.\n    /// @param _recipientIds Ids of the recipients\n    /// @param _recipientStatuses Statuses of the recipients\n    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)\n        external\n        virtual\n        onlyPoolManager(msg.sender)\n        onlyActiveRegistration\n    {\n        // make sure the arrays are the same length\n        uint256 recipientLength = _recipientIds.length;\n        if (recipientLength != _recipientStatuses.length) revert INVALID();\n\n        for (uint256 i; i < recipientLength;) {\n            Status recipientStatus = _recipientStatuses[i];\n            address recipientId = _recipientIds[i];\n\n            // if the status is none or appealed then revert\n            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            reviewsByStatus[recipientId][recipientStatus]++;\n\n            if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) {\n                Recipient storage recipient = recipients[recipientId];\n                recipient.recipientStatus = recipientStatus;\n\n                emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));\n            }\n\n            emit Reviewed(recipientId, recipientStatus, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) external onlyPoolManager(msg.sender) {\n        _updatePoolTimestamps(_registrationStartTime, _registrationEndTime, _allocationStartTime, _allocationEndTime);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Check if the registration is active\n    /// @dev Reverts if the registration is not active\n    function _checkOnlyActiveRegistration() internal view virtual {\n        if (registrationStartTime > block.timestamp || block.timestamp > registrationEndTime) {\n            revert REGISTRATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    function _checkOnlyActiveAllocation() internal view virtual {\n        if (allocationStartTime > block.timestamp || block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    function _checkOnlyAfterAllocation() internal view virtual {\n        if (block.timestamp < allocationEndTime) revert ALLOCATION_NOT_ENDED();\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function _updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) internal {\n        // validate the timestamps for this strategy\n        if (\n            block.timestamp > _registrationStartTime || _registrationStartTime > _registrationEndTime\n                || _registrationStartTime > _allocationStartTime || _allocationStartTime > _allocationEndTime\n                || _registrationEndTime > _allocationEndTime\n        ) {\n            revert INVALID();\n        }\n\n        // Set the new values\n        registrationStartTime = _registrationStartTime;\n        registrationEndTime = _registrationEndTime;\n        allocationStartTime = _allocationStartTime;\n        allocationEndTime = _allocationEndTime;\n\n        // emit the event\n        emit TimestampsUpdated(\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\n        );\n    }\n\n    /// @notice Submit application to pool\n    /// @dev The '_data' parameter is encoded as follows:\n    ///     - If registryGating is true, then the data is encoded as (address recipientId, address recipientAddress, Metadata metadata)\n    ///     - If registryGating is false, then the data is encoded as (address recipientAddress, address registryAnchor, Metadata metadata)\n    /// @param _data The data to be decoded\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The ID of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        onlyActiveRegistration\n        returns (address recipientId)\n    {\n        address recipientAddress;\n        address registryAnchor;\n        bool isUsingRegistryAnchor;\n\n        Metadata memory metadata;\n\n        // decode data custom to this strategy\n        if (registryGating) {\n            (recipientId, recipientAddress, metadata) = abi.decode(_data, (address, address, Metadata));\n\n            // when registry gating is enabled, the recipientId must be a profile member\n            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        } else {\n            (recipientAddress, registryAnchor, metadata) = abi.decode(_data, (address, address, Metadata));\n            isUsingRegistryAnchor = registryAnchor != address(0);\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // when using registry anchor, the ID of the recipient must be a profile member\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        }\n\n        // make sure that if metadata is required, it is provided\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        // make sure the recipient address is not the zero address\n        if (recipientAddress == address(0)) revert RECIPIENT_ERROR(recipientId);\n\n        Recipient storage recipient = recipients[recipientId];\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.metadata = metadata;\n        recipient.useRegistryAnchor = registryGating ? true : isUsingRegistryAnchor;\n\n        Status currentStatus = recipient.recipientStatus;\n\n        if (currentStatus == Status.None) {\n            // recipient registering new application\n            recipient.recipientStatus = Status.Pending;\n            emit Registered(recipientId, _data, _sender);\n        } else {\n            if (currentStatus == Status.Accepted) {\n                // recipient updating accepted application\n                recipient.recipientStatus = Status.Pending;\n            } else if (currentStatus == Status.Rejected) {\n                // recipient updating rejected application\n                recipient.recipientStatus = Status.Appealed;\n            }\n\n            // emit the new status with the '_data' that was passed in\n            emit UpdatedRegistration(recipientId, _data, _sender, recipient.recipientStatus);\n        }\n    }\n\n    /// @notice Distribute the tokens to the recipients\n    /// @dev The '_sender' must be a pool manager and the allocation must have ended\n    /// @param _recipientIds The recipient ids\n    /// @param _sender The sender of the transaction\n    function _distribute(address[] memory _recipientIds, bytes memory, address _sender)\n        internal\n        virtual\n        override\n        onlyPoolManager(_sender)\n        onlyAfterAllocation\n    {\n        uint256 payoutLength = _recipientIds.length;\n        for (uint256 i; i < payoutLength;) {\n            address recipientId = _recipientIds[i];\n            Recipient storage recipient = recipients[recipientId];\n\n            PayoutSummary memory payout = _getPayout(recipientId, \"\");\n            uint256 amount = payout.amount;\n\n            if (paidOut[recipientId] || !_isAcceptedRecipient(recipientId) || amount == 0) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            IAllo.Pool memory pool = allo.getPool(poolId);\n            _transferAmount(pool.token, recipient.recipientAddress, amount);\n\n            paidOut[recipientId] = true;\n\n            emit Distributed(recipientId, recipient.recipientAddress, amount, _sender);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Check if sender is a profile member\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return If the '_sender' is a profile member\n    function _isProfileMember(address _anchor, address _sender) internal view returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Getter for a recipient using the ID\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory) {\n        return recipients[_recipientId];\n    }\n\n    /// ====================================\n    /// ============ QV Helper ==============\n    /// ====================================\n\n    /// @notice Calculate the square root of a number (Babylonian method)\n    /// @param x The number\n    /// @return y The square root\n    function _sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /// @notice Allocate voice credits to a recipient\n    /// @dev This can only be called during active allocation period\n    /// @param _allocator The allocator details\n    /// @param _recipient The recipient details\n    /// @param _recipientId The ID of the recipient\n    /// @param _voiceCreditsToAllocate The voice credits to allocate to the recipient\n    /// @param _sender The sender of the transaction\n    function _qv_allocate(\n        Allocator storage _allocator,\n        Recipient storage _recipient,\n        address _recipientId,\n        uint256 _voiceCreditsToAllocate,\n        address _sender\n    ) internal onlyActiveAllocation {\n        // check the `_voiceCreditsToAllocate` is > 0\n        if (_voiceCreditsToAllocate == 0) revert INVALID();\n\n        // get the previous values\n        uint256 creditsCastToRecipient = _allocator.voiceCreditsCastToRecipient[_recipientId];\n        uint256 votesCastToRecipient = _allocator.votesCastToRecipient[_recipientId];\n\n        // get the total credits and calculate the vote result\n        uint256 totalCredits = _voiceCreditsToAllocate + creditsCastToRecipient;\n        uint256 voteResult = _sqrt(totalCredits * 1e18);\n\n        // update the values\n        voteResult -= votesCastToRecipient;\n        totalRecipientVotes += voteResult;\n        _recipient.totalVotesReceived += voteResult;\n\n        _allocator.voiceCreditsCastToRecipient[_recipientId] += totalCredits;\n        _allocator.votesCastToRecipient[_recipientId] += voteResult;\n\n        // emit the event with the vote results\n        emit Allocated(_recipientId, voteResult, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return If the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view virtual returns (bool);\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return If the allocator is valid\n    function _isValidAllocator(address _allocator) internal view virtual override returns (bool);\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return If the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        virtual\n        returns (bool);\n\n    /// @notice Get the payout for a single recipient\n    /// @param _recipientId The ID of the recipient\n    /// @return The payout as a 'PayoutSummary' struct\n    function _getPayout(address _recipientId, bytes memory)\n        internal\n        view\n        virtual\n        override\n        returns (PayoutSummary memory)\n    {\n        Recipient memory recipient = recipients[_recipientId];\n\n        // Calculate the payout amount based on the percentage of total votes\n        uint256 amount;\n        if (!paidOut[_recipientId] && totalRecipientVotes != 0) {\n            amount = poolAmount * recipient.totalVotesReceived / totalRecipientVotes;\n        }\n        return PayoutSummary(recipient.recipientAddress, amount);\n    }\n}"
    },
    {
      "filename": "allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title QVBaseStrategy\n/// @notice Base strategy for quadratic voting strategies\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\nabstract contract QVBaseStrategy is BaseStrategy {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId ID of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    /// @param status The updated status of the recipient\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender, Status status);\n\n    /// @notice Emitted when a recipient is registered\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event RecipientStatusUpdated(address indexed recipientId, Status status, address sender);\n    /// @notice Emitted when the pool timestamps are updated\n    /// @param registrationStartTime The start time for the registration\n    /// @param registrationEndTime The end time for the registration\n    /// @param allocationStartTime The start time for the allocation\n    /// @param allocationEndTime The end time for the allocation\n    /// @param sender The sender of the transaction\n    event TimestampsUpdated(\n        uint64 registrationStartTime,\n        uint64 registrationEndTime,\n        uint64 allocationStartTime,\n        uint64 allocationEndTime,\n        address sender\n    );\n\n    /// @notice Emitted when a recipient receives votes\n    /// @param recipientId ID of the recipient\n    /// @param votes The votes allocated to the recipient\n    /// @param allocator The allocator assigning the votes\n    event Allocated(address indexed recipientId, uint256 votes, address allocator);\n\n    /// @notice Emitted when a recipient is reviewed\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event Reviewed(address indexed recipientId, Status status, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    // slot 0\n    /// @notice The total number of votes cast for all recipients\n    uint256 public totalRecipientVotes;\n\n    // slot 1\n    /// @notice The number of votes required to review a recipient\n    uint256 public reviewThreshold;\n\n    // slot 2\n    /// @notice The start and end times for registrations and allocations\n    /// @dev The values will be in milliseconds since the epoch\n    uint64 public registrationStartTime;\n    uint64 public registrationEndTime;\n    uint64 public allocationStartTime;\n    uint64 public allocationEndTime;\n\n    // slot 3\n    /// @notice Whether or not the strategy is using registry gating\n    bool public registryGating;\n\n    /// @notice Whether or not the strategy requires metadata\n    bool public metadataRequired;\n\n    /// @notice The registry contract\n    IRegistry private _registry;\n\n    // slots [4...n]\n    /// @notice The status of the recipient for this strategy only\n    /// @dev There is a core `IStrategy.RecipientStatus` that this should map to\n    enum InternalRecipientStatus {\n        None,\n        Pending,\n        Accepted,\n        Rejected,\n        Appealed\n    }\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParams {\n        // slot 0\n        bool registryGating;\n        bool metadataRequired;\n        // slot 1\n        uint256 reviewThreshold;\n        // slot 2\n        uint64 registrationStartTime;\n        uint64 registrationEndTime;\n        uint64 allocationStartTime;\n        uint64 allocationEndTime;\n    }\n\n    /// @notice The details of the recipient\n    struct Recipient {\n        // slot 0\n        uint256 totalVotesReceived;\n        // slot 1\n        bool useRegistryAnchor;\n        address recipientAddress;\n        Metadata metadata;\n        Status recipientStatus;\n    }\n\n    /// @notice The details of the allocator\n    struct Allocator {\n        // slot 0\n        uint256 voiceCredits;\n        // slots [1...n]\n        mapping(address => uint256) voiceCreditsCastToRecipient;\n        mapping(address => uint256) votesCastToRecipient;\n    }\n\n    /// @notice The details of the recipient are returned using their ID\n    /// @dev recipientId => Recipient\n    mapping(address => Recipient) public recipients;\n\n    /// @notice The details of the allocator are returned using their address\n    /// @dev allocator address => Allocator\n    mapping(address => Allocator) public allocators;\n\n    /// @notice Returns whether or not the recipient has been paid out using their ID\n    /// @dev recipientId => paid out\n    mapping(address => bool) public paidOut;\n\n    // recipientId -> status -> count\n    mapping(address => mapping(Status => uint256)) public reviewsByStatus;\n\n    /// ================================\n    /// ========== Modifier ============\n    /// ================================\n\n    /// @notice Modifier to check if the registration is active\n    /// @dev Reverts if the registration is not active\n    modifier onlyActiveRegistration() {\n        _checkOnlyActiveRegistration();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    modifier onlyActiveAllocation() {\n        _checkOnlyActiveAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    modifier onlyAfterAllocation() {\n        _checkOnlyAfterAllocation();\n        _;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ====================================\n    /// =========== Initialize =============\n    /// ====================================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    function initialize(uint256 _poolId, bytes memory _data) external virtual;\n\n    /// @notice Internal initialize function\n    /// @param _poolId The ID of the pool\n    /// @param _params The initialize params for the strategy\n    function __QVBaseStrategy_init(uint256 _poolId, InitializeParams memory _params) internal {\n        __BaseStrategy_init(_poolId);\n\n        registryGating = _params.registryGating;\n        metadataRequired = _params.metadataRequired;\n        _registry = allo.getRegistry();\n\n        reviewThreshold = _params.reviewThreshold;\n\n        _updatePoolTimestamps(\n            _params.registrationStartTime,\n            _params.registrationEndTime,\n            _params.allocationStartTime,\n            _params.allocationEndTime\n        );\n    }\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }"
    }
  ]
}