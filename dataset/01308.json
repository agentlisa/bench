{
  "Title": "Front-Running redeem Can Prevent Indexers From Receiving Rewards for Allocations",
  "Content": "The [`redeem`](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L366) function in `Escrow.sol` enables Indexers to receive query rewards by submitting a signed Receipt Aggregate Voucher (RAV) and `allocationIDProof`. However, anyone who knows the contents of a valid `signedRAV` and `allocationIDProof` can call `redeem` regardless of whether the proof and signed RAV belong to them. This is because `redeem` only checks that the contents and signature of the passed-in `signedRAV` and `allocationIDProof` are valid, but does not check that the caller is the originator of the signatures and calldata. Additionally, the function uses the caller to [determine the amount of GRT](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L377-L384) that will be sent as the query reward to the `Staking` contract.\n\n\nConsequently, a malicious user who knows a valid `signedRAV` and `allocationIDProof` can call `redeem`, which, if the user does not have a GRT balance in the `Escrow` contract, will result in zero GRT being rewarded for an `allocationID`. This also prevents future calls to `redeem` that correspond to the same `allocationID` as the ID will have been [marked as used](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/AllocationIDTracker.sol#L65) in the `AllocationIDTracker` as part of the [`redeem` function's logic](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L390-L394). This effectively prevents an Indexer from being rewarded for a given `allocationID`. The following example outlines a proposed attack against an Indexer:\n\n\n1. An Indexer calls `redeem` with their `signedRAV` and `allocationIDProof` on the Ethereum Mainnet.\n2. A malicious user sees the proposed transaction in the public mempool, creates a duplicate transaction using the now public information, and pays to front-run the Indexer's transaction.\n3. The malicious user's call to redeem happens first, and because they do not have any GRT balance in the `Escrow` contract, zero GRT will be awarded to the `allocationID` via the [collect](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L395) call. Note that both `redeem` and `collect` (in `Staking.sol`) will pass even though zero GRT is awarded to an Indexer. Additionally, this uses the `allocationID` in the `AllocationIDTracker` contract.\n4. The Indexer's redeem call happens and fails because `useAllocationID` will now revert.\n\n\nConsider deriving the Indexer address to pull GRT from via the `getAllocation` function in the Staking contract instead of using the `msg.sender` as the expected address in the `redeem` function. This prevents the wrong address' `EscrowAccount` 's GRT balance from being used and always ensures that regardless of who calls `redeem`, the correct address will be used when moving GRT to the `Staking` contract.\n\n\n***Update:** Resolved in [pull request #58.](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/pull/58) The Graph's core developersÂ stated:*\n\n\n\n> *Thank you for finding and highlighting this critical issue. We have investigated it further and discussed a few solutions. To prevent possible front-running attacks and allow the vesting contracts to redeem, we decided to proceed with the suggested solution to use the Indexer indicated in the allocation as the receiver (i.e., obtaining the receiver address from the staking contract using `allocationID`). The associated issue can be found [here](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/issues/31).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/Escrow.sol",
      "content": "// Copyright 2023-, Semiotic AI, Inc.\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {TAPVerifier} from \"./TAPVerifier.sol\";\nimport {AllocationIDTracker} from \"./AllocationIDTracker.sol\";\nimport {IStaking} from \"./IStaking.sol\";\n\n/**\n * @title Escrow\n * @dev This contract allows `senders` to deposit escrow for specific `receivers`,\n *      which can later be redeemed using Receipt Aggregate Vouchers (`RAV`) signed\n *      by an authorized `signer`. `Senders` can deposit escrow for `receivers`,\n *      authorize `signers` to create signed `RAVs`, and withdraw escrow after a\n *      set `thawingPeriod` number of seconds. `Receivers` can redeem signed `RAVs` to\n *      claim escrow.\n * @notice This contract uses the `TAPVerifier` contract for recovering signer addresses\n *         from `RAVs`.\n */\ncontract Escrow {\n    using SafeERC20 for IERC20;\n\n    struct EscrowAccount {\n        uint256 balance; // Total escrow balance for a sender-receiver pair\n        uint256 amountThawing; // Amount of escrow currently being thawed\n        uint256 thawEndTimestamp; // Block number at which thawing period ends (zero if not thawing)\n    }\n\n    struct SenderAuthorization {\n        address sender; // Sender the signer is authorized to sign for\n        uint256 thawEndTimestamp; // Block number at which thawing period ends (zero if not thawing)\n    }\n\n    // Stores how much escrow each sender has deposited for each receiver, as well as thawing information\n    mapping(address sender => mapping(address reciever => EscrowAccount escrowAccount))\n        public escrowAccounts;\n    // Map of signer to authorized signer information\n    mapping(address signer => SenderAuthorization authorizedSigner)\n        public authorizedSigners;\n\n    // The ERC20 token used for escrow\n    IERC20 public immutable escrowToken;\n\n    // Graph staking contract\n    IStaking public immutable staking;\n\n    // The contract used for verifying receipt aggregate vouchers\n    TAPVerifier public immutable tapVerifier;\n\n    // The contract used for tracking used allocation IDs\n    AllocationIDTracker public immutable allocationIDTracker;\n\n    // The duration (in seconds) in which escrow funds are thawing before they can be withdrawn\n    uint256 public immutable withdrawEscrowThawingPeriod;\n\n    // The duration (in seconds) in which a signer is thawing before they can be revoked\n    uint256 public immutable revokeSignerThawingPeriod;\n\n    // Custom error to indicate insufficient escrow balance\n    error InsufficientEscrow(uint256 available, uint256 required);\n\n    // Custom error to indicate escrow is still thawing\n    error EscrowStillThawing(\n        uint256 currentTimestamp,\n        uint256 thawEndTimestamp\n    );\n\n    // Custom error to indicate escrow thawing has not been initiated\n    error EscrowNotThawing();\n\n    // Custom error to indicate invalid signer proof\n    error InvalidSignerProof();\n\n    // Custom error to indicate provided signer is not one of provided senders authorized signers\n    error SignerNotAuthorizedBySender(address signer, address sender);\n\n    // Custom error to indicate signer already authorized\n    error SignerAlreadyAuthorized(address signer, address authorizingSender);\n\n    // Custom error to indicate signer is still thawing\n    error SignerStillThawing(\n        uint256 currentTimestamp,\n        uint256 thawEndTimestamp\n    );\n\n    // Custom error to indicate signer thawing has not been initiated\n    error SignerNotThawing();\n\n    // Custom error to indicate invalid RAV signer\n    error InvalidRAVSigner();\n\n    /**\n     * @dev Emitted when escrow is deposited for a receiver.\n     */\n    event Deposit(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when escrow is redeemed by a receiver.\n     * @notice If the actual amount redeemed is less than the expected amount,\n     *         there was insufficient escrow available to redeem.\n     */\n    event Redeem(\n        address indexed sender,\n        address indexed receiver,\n        address indexed allocationID,\n        uint256 expectedAmount,\n        uint256 actualAmount\n    );\n\n    /**\n     * @dev Emitted when a thaw request is made for escrow.\n     */\n    event Thaw(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount,\n        uint256 totalAmountThawing,\n        uint256 thawEndTimestamp\n    );\n\n    /**\n     * @dev Emitted when a thaw request is made for authorized signer\n     */\n    event ThawSigner(\n        address indexed sender,\n        address indexed authorizedSigner,\n        uint256 thawEndTimestamp\n    );\n\n    /**\n     * @dev Emitted when a authorized signer has been revoked\n     */\n    event RevokeAuthorizedSigner(\n        address indexed sender,\n        address indexed authorizedSigner\n    );\n\n    /**\n     * @dev Emitted when thawed escrow is withdrawn by the sender.\n     */\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when a signer is authorized to sign RAVs for a sender.\n     */\n    event AuthorizeSigner(address indexed signer, address indexed sender);\n\n    constructor(\n        address escrowToken_,\n        address staking_,\n        address tapVerifier_,\n        address allocationIDTracker_,\n        uint256 withdrawEscrowThawingPeriod_,\n        uint256 revokeSignerThawingPeriod_\n    ) {\n        escrowToken = IERC20(escrowToken_);\n        staking = IStaking(staking_);\n        tapVerifier = TAPVerifier(tapVerifier_);\n        allocationIDTracker = AllocationIDTracker(allocationIDTracker_);\n        withdrawEscrowThawingPeriod = withdrawEscrowThawingPeriod_;\n        revokeSignerThawingPeriod = revokeSignerThawingPeriod_;\n    }\n\n    /**\n     * @notice Approve the staking contract to pull any amount of tokens from this contract.\n     * @dev Increased gas efficiency instead of approving on each voucher redeem\n     */\n    function approveAll() external {\n        escrowToken.approve(address(staking), type(uint256).max);\n    }\n\n    /**\n     * @dev Deposits escrow for a receiver.\n     * @param receiver Address of the receiver.\n     * @param amount Amount of escrow to deposit.\n     * @notice The escrow must be approved for transfer by the sender.\n     * @notice REVERT: this function will revert if the escrow transfer fails.\n     */\n    function deposit(address receiver, uint256 amount) external {\n        escrowAccounts[msg.sender][receiver].balance += amount;\n        escrowToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Deposit(msg.sender, receiver, amount);\n    }\n\n    /**\n     * @dev Requests to thaw a specific amount of escrow from a receiver's escrow account.\n     * @param receiver Address of the receiver the escrow account is for.\n     * @param amount Amount of escrow to thaw.\n     * @notice REVERT with error:\n     *               - InsufficientEscrow: if the sender receiver escrow account does\n     *                 not have enough escrow (greater than `amount`)\n     */\n    function thaw(address receiver, uint256 amount) external {\n        EscrowAccount storage account = escrowAccounts[msg.sender][\n            receiver\n        ];\n        uint256 totalThawingRequested = account.amountThawing + amount;\n\n        // Check if the escrow balance is sufficient\n        if (account.balance < totalThawingRequested) {\n            revert InsufficientEscrow({\n                available: account.balance,\n                required: totalThawingRequested\n            });\n        }\n\n        // Increase the amount being thawed\n        account.amountThawing = totalThawingRequested;\n        // Set when the thaw is complete (thawing period number of seconds after current timestamp)\n        account.thawEndTimestamp =\n            block.timestamp +\n            withdrawEscrowThawingPeriod;\n\n        emit Thaw(\n            msg.sender,\n            receiver,\n            amount,\n            account.amountThawing,\n            account.thawEndTimestamp\n        );\n    }\n\n    /**\n     * @dev Withdraws all thawed escrow from a receiver's escrow account.\n     * @param receiver Address of the receiver.\n     * @notice REVERT with error:\n     *               - EscrowNotThawing: There is no escrow currently thawing\n     *               - EscrowStillThawing: ThawEndTimestamp has not been reached\n     *                 for escrow currently thawing\n     */\n    function withdraw(address receiver) external {\n        EscrowAccount storage account = escrowAccounts[msg.sender][\n            receiver\n        ];\n        if (account.thawEndTimestamp == 0) {\n            revert EscrowNotThawing();\n        }\n\n        if (account.thawEndTimestamp > block.timestamp) {\n            revert EscrowStillThawing({\n                currentTimestamp: block.timestamp,\n                thawEndTimestamp: account.thawEndTimestamp\n            });\n        }\n\n        // Amount is the minimum between the amount being thawed and the actual balance\n        uint256 amount = account.amountThawing > account.balance\n            ? account.balance\n            : account.amountThawing;\n\n        unchecked {\n            account.balance -= amount; // Reduce the balance by the withdrawn amount (no underflow risk)\n        }\n        account.amountThawing = 0;\n        account.thawEndTimestamp = 0;\n        escrowToken.safeTransfer(msg.sender, amount);\n        emit Withdraw(msg.sender, receiver, amount);\n    }\n\n    /**\n     * @dev Authorizes a signer to sign RAVs for the sender.\n     * @param signer Address of the authorized signer.\n     * @param proof The proof provided by the signer to authorize the sender.\n     * @notice REVERT with error:\n     *               - SignerAlreadyAuthorized: Signer is currently authorized for a sender\n     *               - InvalidSignerProof: The provided signer proof is invalid\n     */\n    function authorizeSigner(address signer, bytes calldata proof) external {\n        if (authorizedSigners[signer].sender != address(0)) {\n            revert SignerAlreadyAuthorized(\n                signer,\n                authorizedSigners[signer].sender\n            );\n        }\n\n        verifyAuthorizedSignerProof(proof, signer);\n\n        authorizedSigners[signer].sender = msg.sender;\n        authorizedSigners[signer].thawEndTimestamp = 0;\n        emit AuthorizeSigner(signer, msg.sender);\n    }\n\n    /**\n     * @dev Starts thawing a signer to be removed from the authorized signers list.\n     * @param signer Address of the signer to remove.\n     * @notice REVERT with error:\n     *               - SignerNotAuthorizedBySender: The provided signer is either not authorized or\n     *                 authorized by a different sender\n     */\n    function thawSigner(address signer) external {\n        SenderAuthorization storage authorization = authorizedSigners[signer];\n\n        if (authorization.sender != msg.sender) {\n            revert SignerNotAuthorizedBySender(\n                signer,\n                authorizedSigners[signer].sender\n            );\n        }\n\n        authorization.thawEndTimestamp =\n            block.timestamp +\n            revokeSignerThawingPeriod;\n        emit ThawSigner(\n            authorization.sender,\n            signer,\n            authorization.thawEndTimestamp\n        );\n    }\n\n    /**\n     * @dev Revokes a signer from the authorized signers list if thawed.\n     * @param signer Address of the signer to remove.\n     * @notice REVERT with error:\n     *               - SignerNotAuthorizedBySender: The provided signer is either not authorized or\n     *                 authorized by a different sender\n     *               - SignerNotThawing: No thaw was initiated for the provided signer\n     *               - SignerStillThawing: ThawEndTimestamp has not been reached\n     *                 for provided signer\n     */\n    function revokeAuthorizedSigner(address signer) external {\n        SenderAuthorization storage authorization = authorizedSigners[signer];\n\n        if (authorization.sender != msg.sender) {\n            revert SignerNotAuthorizedBySender(\n                signer,\n                authorizedSigners[signer].sender\n            );\n        }\n\n        if (authorization.thawEndTimestamp == 0) {\n            revert SignerNotThawing();\n        }\n\n        if (authorization.thawEndTimestamp > block.timestamp) {\n            revert SignerStillThawing({\n                currentTimestamp: block.timestamp,\n                thawEndTimestamp: authorization.thawEndTimestamp\n            });\n        }\n\n        delete authorizedSigners[signer];\n        emit RevokeAuthorizedSigner(authorization.sender, signer);\n    }\n\n    /**\n     * @dev Redeems escrow (up to amount available in escrow) for a receiver using a signed RAV.\n     * @param signedRAV Signed RAV containing the receiver and escrow amount.\n     * @param allocationIDProof Proof of allocationID ownership.\n     * @notice REVERT: This function may revert if ECDSA.recover fails, check Open Zeppelin ECDSA library for details.\n     * @notice REVERT with error:\n     *               - InvalidRAVSigner: If the RAV is signed by a signer who is not authorized by any sender\n     *               - AllocationIDTracker.AllocationIDPreviouslyClaimed: If the allocation ID was previously claimed\n     *               - AllocationIDTracker.InvalidProof: If the allocation ID ownership proof is not valid\n     */\n    function redeem(\n        TAPVerifier.SignedRAV calldata signedRAV,\n        bytes calldata allocationIDProof\n    ) external {\n        address signer = tapVerifier.recoverRAVSigner(signedRAV);\n\n        if (authorizedSigners[signer].sender == address(0)) {\n            revert InvalidRAVSigner();\n        }\n\n        address sender = authorizedSigners[signer].sender;\n        address receiver = msg.sender;\n        address allocationId = signedRAV.rav.allocationId;\n\n        // Amount is the minimum between the amount owed on rav and the actual balance\n        uint256 amount = signedRAV.rav.valueAggregate >\n            escrowAccounts[sender][receiver].balance\n            ? escrowAccounts[sender][receiver].balance\n            : signedRAV.rav.valueAggregate;\n\n        unchecked {\n            escrowAccounts[sender][receiver].balance -= amount;\n        }\n\n        allocationIDTracker.useAllocationID(\n            sender,\n            allocationId,\n            allocationIDProof\n        );\n        staking.collect(amount, allocationId);\n        emit Redeem(\n            sender,\n            msg.sender,\n            signedRAV.rav.allocationId,\n            signedRAV.rav.valueAggregate,\n            amount\n        );\n    }\n\n    /**\n     * @dev Retrieves the amount of escrow deposited by a sender for a receiver.\n     * @param sender Address of the sender.\n     * @param receiver Address of the receiver.\n     * @return The amount of escrow deposited.\n     */\n    function getEscrowAmount(\n        address sender,\n        address receiver\n    ) external view returns (uint256) {\n        return escrowAccounts[sender][receiver].balance;\n    }\n\n    /**\n     * @dev Retrieves the escrow account details for a sender-receiver pair of the sender that a signer is authorized for.\n     * @param signer Address of the authorized signer.\n     * @param receiver Address of the receiver.\n     * @return The escrow account details.\n     */\n    function getEscrowAccountFromSignerAddress(\n        address signer,\n        address receiver\n    ) external view returns (EscrowAccount memory) {\n        return escrowAccounts[authorizedSigners[signer].sender][receiver];\n    }\n\n    /**\n     * @dev Verifies a proof that authorizes the sender to authorize the signer.\n     * @param proof The proof provided by the signer to authorize the sender.\n     * @param signer The address of the signer being authorized.\n     * @notice REVERT with error:\n     *               - InvalidSignerProof: If the given proof is not valid\n     */\n    function verifyAuthorizedSignerProof(\n        bytes calldata proof,\n        address signer\n    ) private view {\n        // Generate the hash of the sender's address\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender));\n\n        // Generate the digest to be signed by the signer\n        bytes32 digest = ECDSA.toEthSignedMessageHash(messageHash);\n\n        // Verify that the recovered signer matches the expected signer\n        if (ECDSA.recover(digest, proof) != signer) {\n            revert InvalidSignerProof();\n        }\n    }\n}"
    },
    {
      "filename": "src/AllocationIDTracker.sol",
      "content": "// Copyright 2023-, Semiotic AI, Inc.\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title AllocationIDTracker\n * @dev This contract tracks the allocation IDs of the RAVs that have been submitted to\n *      ensure that each allocation ID is only used once. It is external to escrow\n *      contract to allow for updating the escrow contract without losing the list of\n *      used allocation IDs.\n * @notice This contract is intended to be used with the `Escrow` contract.\n */\ncontract AllocationIDTracker {\n    // senders used allocation IDs\n    mapping(address sender => mapping(address allocationId => bool isUsed))\n        private _sendersUsedAllocationIDs;\n\n    // Custom error to indicate the provided allocation ID was previously claimed and no longer valid\n    error AllocationIDPreviouslyClaimed(address sender, address allocationID);\n\n    // Custom error to indicate the provided proof is not valid\n    error InvalidProof();\n\n    /**\n     * @dev Emitted when an allocation ID is used.\n     */\n    event AllocationIDUsed(\n        address indexed sender,\n        address indexed allocationID\n    );\n\n    /**\n     * @dev Checks if an allocation ID has been used.\n     * @param allocationID The allocation ID to check.\n     * @return True if the allocation ID has been used, false otherwise.\n     */\n    function isAllocationIDUsed(\n        address sender,\n        address allocationID\n    ) external view returns (bool) {\n        return _sendersUsedAllocationIDs[sender][allocationID];\n    }\n\n    /**\n     * @dev Marks an allocation ID as used.\n     * @param sender The sender of the token to receiver.\n     * @param allocationID The allocation ID to mark as used.\n     * @param proof ECDSA Proof signed by the receiver's allocationID consisting of packed (sender address, allocationID, collateral contract address).\n     * @notice REVERT with error:\n     *               - AllocationIDPreviouslyClaimed: If the (sender, allocationID) pair was previously claimed\n     *               - InvalidProof: If the proof is not valid\n     */\n    function useAllocationID(\n        address sender,\n        address allocationID,\n        bytes calldata proof\n    ) external {\n        if (_sendersUsedAllocationIDs[sender][allocationID] == true) {\n            revert AllocationIDPreviouslyClaimed(sender, allocationID);\n        }\n        verifyProof(proof, sender, allocationID);\n\n        _sendersUsedAllocationIDs[sender][allocationID] = true;\n        emit AllocationIDUsed(sender, allocationID);\n    }\n\n    /**\n     * @dev Verifies a proof.\n     * @param proof ECDSA Proof signed by the receiver's allocationID consisting of packed (sender address, allocationID, collateral contract address).\n     * @param sender The sender of the token to receiver.\n     * @param allocationID The allocation ID to verify.\n     * @notice REVERT with error:\n     *               - InvalidProof: If the proof is not valid\n     */\n    function verifyProof(\n        bytes calldata proof,\n        address sender,\n        address allocationID\n    ) private view {\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(sender, allocationID, msg.sender)\n        );\n        bytes32 digest = ECDSA.toEthSignedMessageHash(messageHash);\n        if (ECDSA.recover(digest, proof) != allocationID) {\n            revert InvalidProof();\n        }\n    }\n}"
    },
    {
      "filename": "src/Escrow.sol",
      "content": "// Copyright 2023-, Semiotic AI, Inc.\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {TAPVerifier} from \"./TAPVerifier.sol\";\nimport {AllocationIDTracker} from \"./AllocationIDTracker.sol\";\nimport {IStaking} from \"./IStaking.sol\";\n\n/**\n * @title Escrow\n * @dev This contract allows `senders` to deposit escrow for specific `receivers`,\n *      which can later be redeemed using Receipt Aggregate Vouchers (`RAV`) signed\n *      by an authorized `signer`. `Senders` can deposit escrow for `receivers`,\n *      authorize `signers` to create signed `RAVs`, and withdraw escrow after a\n *      set `thawingPeriod` number of seconds. `Receivers` can redeem signed `RAVs` to\n *      claim escrow.\n * @notice This contract uses the `TAPVerifier` contract for recovering signer addresses\n *         from `RAVs`.\n */\ncontract Escrow {\n    using SafeERC20 for IERC20;\n\n    struct EscrowAccount {\n        uint256 balance; // Total escrow balance for a sender-receiver pair\n        uint256 amountThawing; // Amount of escrow currently being thawed\n        uint256 thawEndTimestamp; // Block number at which thawing period ends (zero if not thawing)\n    }\n\n    struct SenderAuthorization {\n        address sender; // Sender the signer is authorized to sign for\n        uint256 thawEndTimestamp; // Block number at which thawing period ends (zero if not thawing)\n    }\n\n    // Stores how much escrow each sender has deposited for each receiver, as well as thawing information\n    mapping(address sender => mapping(address reciever => EscrowAccount escrowAccount))\n        public escrowAccounts;\n    // Map of signer to authorized signer information\n    mapping(address signer => SenderAuthorization authorizedSigner)\n        public authorizedSigners;\n\n    // The ERC20 token used for escrow\n    IERC20 public immutable escrowToken;\n\n    // Graph staking contract\n    IStaking public immutable staking;\n\n    // The contract used for verifying receipt aggregate vouchers\n    TAPVerifier public immutable tapVerifier;\n\n    // The contract used for tracking used allocation IDs\n    AllocationIDTracker public immutable allocationIDTracker;\n\n    // The duration (in seconds) in which escrow funds are thawing before they can be withdrawn\n    uint256 public immutable withdrawEscrowThawingPeriod;\n\n    // The duration (in seconds) in which a signer is thawing before they can be revoked\n    uint256 public immutable revokeSignerThawingPeriod;\n\n    // Custom error to indicate insufficient escrow balance\n    error InsufficientEscrow(uint256 available, uint256 required);\n\n    // Custom error to indicate escrow is still thawing\n    error EscrowStillThawing(\n        uint256 currentTimestamp,\n        uint256 thawEndTimestamp\n    );\n\n    // Custom error to indicate escrow thawing has not been initiated\n    error EscrowNotThawing();\n\n    // Custom error to indicate invalid signer proof\n    error InvalidSignerProof();\n\n    // Custom error to indicate provided signer is not one of provided senders authorized signers\n    error SignerNotAuthorizedBySender(address signer, address sender);\n\n    // Custom error to indicate signer already authorized\n    error SignerAlreadyAuthorized(address signer, address authorizingSender);\n\n    // Custom error to indicate signer is still thawing\n    error SignerStillThawing(\n        uint256 currentTimestamp,\n        uint256 thawEndTimestamp\n    );\n\n    // Custom error to indicate signer thawing has not been initiated\n    error SignerNotThawing();\n\n    // Custom error to indicate invalid RAV signer\n    error InvalidRAVSigner();\n\n    /**\n     * @dev Emitted when escrow is deposited for a receiver.\n     */\n    event Deposit(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when escrow is redeemed by a receiver.\n     * @notice If the actual amount redeemed is less than the expected amount,\n     *         there was insufficient escrow available to redeem.\n     */\n    event Redeem(\n        address indexed sender,\n        address indexed receiver,\n        address indexed allocationID,\n        uint256 expectedAmount,\n        uint256 actualAmount\n    );\n\n    /**\n     * @dev Emitted when a thaw request is made for escrow.\n     */\n    event Thaw(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount,\n        uint256 totalAmountThawing,\n        uint256 thawEndTimestamp\n    );\n\n    /**\n     * @dev Emitted when a thaw request is made for authorized signer\n     */\n    event ThawSigner(\n        address indexed sender,\n        address indexed authorizedSigner,\n        uint256 thawEndTimestamp\n    );\n\n    /**\n     * @dev Emitted when a authorized signer has been revoked\n     */\n    event RevokeAuthorizedSigner(\n        address indexed sender,\n        address indexed authorizedSigner\n    );\n\n    /**\n     * @dev Emitted when thawed escrow is withdrawn by the sender.\n     */\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when a signer is authorized to sign RAVs for a sender.\n     */\n    event AuthorizeSigner(address indexed signer, address indexed sender);\n\n    constructor(\n        address escrowToken_,\n        address staking_,\n        address tapVerifier_,\n        address allocationIDTracker_,\n        uint256 withdrawEscrowThawingPeriod_,\n        uint256 revokeSignerThawingPeriod_\n    ) {\n        escrowToken = IERC20(escrowToken_);\n        staking = IStaking(staking_);\n        tapVerifier = TAPVerifier(tapVerifier_);\n        allocationIDTracker = AllocationIDTracker(allocationIDTracker_);\n        withdrawEscrowThawingPeriod = withdrawEscrowThawingPeriod_;\n        revokeSignerThawingPeriod = revokeSignerThawingPeriod_;\n    }\n\n    /**\n     * @notice Approve the staking contract to pull any amount of tokens from this contract.\n     * @dev Increased gas efficiency instead of approving on each voucher redeem\n     */\n    function approveAll() external {\n        escrowToken.approve(address(staking), type(uint256).max);\n    }\n\n    /**\n     * @dev Deposits escrow for a receiver.\n     * @param receiver Address of the receiver.\n     * @param amount Amount of escrow to deposit.\n     * @notice The escrow must be approved for transfer by the sender.\n     * @notice REVERT: this function will revert if the escrow transfer fails.\n     */\n    function deposit(address receiver, uint256 amount) external {\n        escrowAccounts[msg.sender][receiver].balance += amount;\n        escrowToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Deposit(msg.sender, receiver, amount);\n    }\n\n    /**\n     * @dev Requests to thaw a specific amount of escrow from a receiver's escrow account.\n     * @param receiver Address of the receiver the escrow account is for.\n     * @param amount Amount of escrow to thaw.\n     * @notice REVERT with error:\n     *               - InsufficientEscrow: if the sender receiver escrow account does\n     *                 not have enough escrow (greater than `amount`)\n     */\n    function thaw(address receiver, uint256 amount) external {\n        EscrowAccount storage account = escrowAccounts[msg.sender][\n            receiver\n        ];\n        uint256 totalThawingRequested = account.amountThawing + amount;\n\n        // Check if the escrow balance is sufficient\n        if (account.balance < totalThawingRequested) {\n            revert InsufficientEscrow({\n                available: account.balance,\n                required: totalThawingRequested\n            });\n        }\n\n        // Increase the amount being thawed\n        account.amountThawing = totalThawingRequested;\n        // Set when the thaw is complete (thawing period number of seconds after current timestamp)\n        account.thawEndTimestamp =\n            block.timestamp +\n            withdrawEscrowThawingPeriod;\n\n        emit Thaw(\n            msg.sender,\n            receiver,\n            amount,\n            account.amountThawing,\n            account.thawEndTimestamp\n        );\n    }\n\n    /**\n     * @dev Withdraws all thawed escrow from a receiver's escrow account.\n     * @param receiver Address of the receiver.\n     * @notice REVERT with error:\n     *               - EscrowNotThawing: There is no escrow currently thawing\n     *               - EscrowStillThawing: ThawEndTimestamp has not been reached\n     *                 for escrow currently thawing\n     */\n    function withdraw(address receiver) external {\n        EscrowAccount storage account = escrowAccounts[msg.sender][\n            receiver\n        ];\n        if (account.thawEndTimestamp == 0) {\n            revert EscrowNotThawing();\n        }\n\n        if (account.thawEndTimestamp > block.timestamp) {\n            revert EscrowStillThawing({\n                currentTimestamp: block.timestamp,\n                thawEndTimestamp: account.thawEndTimestamp\n            });\n        }\n\n        // Amount is the minimum between the amount being thawed and the actual balance\n        uint256 amount = account.amountThawing > account.balance\n            ? account.balance\n            : account.amountThawing;\n\n        unchecked {\n            account.balance -= amount; // Reduce the balance by the withdrawn amount (no underflow risk)\n        }\n        account.amountThawing = 0;\n        account.thawEndTimestamp = 0;\n        escrowToken.safeTransfer(msg.sender, amount);\n        emit Withdraw(msg.sender, receiver, amount);\n    }\n\n    /**\n     * @dev Authorizes a signer to sign RAVs for the sender.\n     * @param signer Address of the authorized signer.\n     * @param proof The proof provided by the signer to authorize the sender.\n     * @notice REVERT with error:\n     *               - SignerAlreadyAuthorized: Signer is currently authorized for a sender\n     *               - InvalidSignerProof: The provided signer proof is invalid\n     */\n    function authorizeSigner(address signer, bytes calldata proof) external {\n        if (authorizedSigners[signer].sender != address(0)) {\n            revert SignerAlreadyAuthorized(\n                signer,\n                authorizedSigners[signer].sender\n            );\n        }\n\n        verifyAuthorizedSignerProof(proof, signer);\n\n        authorizedSigners[signer].sender = msg.sender;\n        authorizedSigners[signer].thawEndTimestamp = 0;\n        emit AuthorizeSigner(signer, msg.sender);\n    }\n\n    /**\n     * @dev Starts thawing a signer to be removed from the authorized signers list.\n     * @param signer Address of the signer to remove.\n     * @notice REVERT with error:\n     *               - SignerNotAuthorizedBySender: The provided signer is either not authorized or\n     *                 authorized by a different sender\n     */\n    function thawSigner(address signer) external {\n        SenderAuthorization storage authorization = authorizedSigners[signer];\n\n        if (authorization.sender != msg.sender) {\n            revert SignerNotAuthorizedBySender(\n                signer,\n                authorizedSigners[signer].sender\n            );\n        }\n\n        authorization.thawEndTimestamp =\n            block.timestamp +\n            revokeSignerThawingPeriod;\n        emit ThawSigner(\n            authorization.sender,\n            signer,\n            authorization.thawEndTimestamp\n        );\n    }\n\n    /**\n     * @dev Revokes a signer from the authorized signers list if thawed.\n     * @param signer Address of the signer to remove.\n     * @notice REVERT with error:\n     *               - SignerNotAuthorizedBySender: The provided signer is either not authorized or\n     *                 authorized by a different sender\n     *               - SignerNotThawing: No thaw was initiated for the provided signer\n     *               - SignerStillThawing: ThawEndTimestamp has not been reached\n     *                 for provided signer\n     */\n    function revokeAuthorizedSigner(address signer) external {\n        SenderAuthorization storage authorization = authorizedSigners[signer];\n\n        if (authorization.sender != msg.sender) {\n            revert SignerNotAuthorizedBySender(\n                signer,\n                authorizedSigners[signer].sender\n            );\n        }\n\n        if (authorization.thawEndTimestamp == 0) {\n            revert SignerNotThawing();\n        }"
    }
  ]
}