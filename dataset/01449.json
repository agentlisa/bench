{
  "Title": "M-2: Lender is able to steal borrowers collateral by calling rollLoan  with unfavourable terms on behalf of the borrower.",
  "Content": "# Issue M-2: Lender is able to steal borrowers collateral by calling rollLoan  with unfavourable terms on behalf of the borrower. \n\nSource: https://github.com/sherlock-audit/2023-08-cooler-judging/issues/26 \n\n## Found by \n0xMosh, 0xbepresent, 0xmurali7, ADM, B353N, Breeje, BugHunter101, Chinmay, Delvir0, HChang26, Kow, Kral01, Mlome, SBSecurity, SanketKogekar, Silvermist, Yanev, banditx0x, carrotsmuggler, castle\\_chain, cats, deadrxsezzz, detectiveking, deth, evilakela, hals, jovi, libratus, mahdikarimi, ni8mare, nmirchev8, p-tsanev, pengun, sandy, tvdung94\nA Lender is able to call provideNewTermsForRoll with whatever terms they want and then can call rollLoan on behalf of the borrower forcing them to roll the loan with the terms they provided. They can abuse this to make the loan so unfavourable for the borrower to repay that they must forfeit their collateral to the lender.\n\n## Vulnerability Detail\nSay a user has 100 collateral tokens valued at $1,500 and they wish to borrow 1,000 debt tokens valued at $1,000 they would would call: (values have simplified for ease of math)\n```Solidity\nrequestLoan(\"1,000 debt tokens\", \"5% interest\", \"10 loan tokens for each collateral\", \"1 year\")\n```\nIf a lender then clears the request the borrower would expect to have 1 year to payback 1,050 debt tokens to be able to receive their collateral back.\n\nHowever a lender is able to call provideNewTermsForRoll with whatever terms they wish: i.e. \n```Solidity\nprovideNewTermsForRoll(\"loanID\", \"10000000% interest\", \"1000 loan tokens for each collateral\" , \"1 year\")\n```\nThey can then follow this up with a call to rollLoan(loanID):\nDuring the rollLoan function  the interest is recalculated using:\n```Solidity\n    function interestFor(uint256 amount_, uint256 rate_, uint256 duration_) public pure returns (uint256) {\n        uint256 interest = (rate_ * duration_) / 365 days;\n        return (amount_ * interest) / DECIMALS_INTEREST;\n    }\n```\nAs rate_ & duration_ are controllable by the borrower when they call provideNewTermsForRoll they can input a large number that the amount returned is much larger then the value of the collateral.  i.e. input a rate_ of amount * 3 and duration of 365 days so that the interestFor returns 3,000.\n\nThis amount gets added to the existing [loan.amount](https://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L203) and would make it too costly to ever repay as the borrower would have to spend more then the collateral is worth to get it back. i.e. borrower now would now need to send 4,050 debt tokens to receive their $1,500 worth of collateral back instead of the expected 1050.\n\nThe extra amount should result in more collateral needing to be sent however it is calculated using loan.request.loanToCollateral which is also controlled by the lender when they call provideNewTermsForRoll,  allowing them to input a value that will result in newCollateralFor returning 0 and no new collateral needing to be sent.\n\n```Solidity\n    function newCollateralFor(uint256 loanID_) public view returns (uint256) {\n        Loan memory loan = loans[loanID_];\n        // Accounts for all outstanding debt (borrowed amount + interest).\n        uint256 neededCollateral = collateralFor(loan.amount, loan.request.loanToCollateral);  \n        // Lender can force neededCollateral to always be less than loan.collateral\n\n        return neededCollateral > loan.collateral ? neededCollateral - loan.collateral : 0;\n    }\n```\nAs a result a borrower who was expecting to have repay 1050 tokens to get back their collateral may now need to spend many multiples more of that and will just be forced to just forfeit their collateral to the lender. \n\n\n## Impact\nBorrower will be forced to payback the loan at unfavourable terms or forfeit their collateral.\n\n## Code Snippet\n[Cooler.sol#L192-L217](https://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L192-L217)\n[Cooler.sol#L282-L300](https://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L282-L300)\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd a check restricting rollLoan to only be callable by the owner. i.e.:\n```Solidity\nfunction rollLoan(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n        \n        if (msg.sender != owner()) revert OnlyApproved();\n```\nNote: unrelated but rollLoan is also missing its event should add:\n```Solidity\nfactory().newEvent(reqID_, CoolerFactory.Events.RollLoan, 0);\n```\n\n\n\n## Discussion\n\n**jkoppel**\n\nWhether this is medium or high depends on how likely borrowers are to make massively over-collateralized loans\n\n**0xRusowsky**\n\nimo a Medium\n\n**Oot2k**\n\nescalate\nsplit frontrunning and access control into own issues\n\n**sherlock-admin2**\n\n > escalate\n> split frontrunning and access control into own issues\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xRusowsky**\n\n- fix: https://github.com/ohmzeus/Cooler/pull/54\n- https://github.com/ohmzeus/Cooler/pull/60\n- https://github.com/ohmzeus/Cooler/pull/61\n\n**Oot2k**\n\nFollowing issues are not duplicates of 26 and should be grouped together and treaded as another issue:\n16 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/16)\n18 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/18)\n72 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/72)\n99 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/99)\n130 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/130)\n137 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/137)\n150 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/150)\n204 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/204)\n221 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/221)\n243 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/243)\n271 (https://github.com/sherlock-audit/2023-08-cooler-judging/issues/271)\n\n226 -> Invalid\n\n**Oot2k**\n\nAddition:\n226 shows attack path and root cause, mentions tokens that are not supported -> sherlock has to decide if valid/invalid \n231 is not duplicate of this issue and should be grouped with the other ones mentioned above\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nThe respective set of issues has been separated\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Oot2k](https://github.com/sherlock-audit/2023-08-cooler-judging/issues/26/#issuecomment-1717154911): accepted\n\n**jkoppel**\n\nFix confirmed. Sponsor agreed to accept some economic concerns with the fix, but no security concerns were identified.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/107",
  "Code": [
    {
      "filename": "Cooler/src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Clone} from \"clones/Clone.sol\";\n\nimport {IDelegate} from \"interfaces/IDelegate.sol\";\nimport {CoolerFactory} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Cooler Loans.\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration, peer-to-peer\n///         loans for a user-defined debt-collateral pair.\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\n///         to save gas on deployment.\ncontract Cooler is Clone {\n    using SafeTransferLib for ERC20;\n\n    // --- ERRORS ----------------------------------------------------\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n    error ZeroCollateralReturned();\n    error NotCoolerCallback();\n\n    // --- DATA STRUCTURES -------------------------------------------\n\n    /// @notice A loan begins with a borrow request.\n    struct Request {\n        uint256 amount;             // Amount to be borrowed.\n        uint256 interest;           // Annualized percentage to be paid as interest.\n        uint256 loanToCollateral;   // Requested loan-to-collateral ratio.\n        uint256 duration;           // Time to repay the loan before it defaults.\n        bool active;                // Any lender can clear an active loan request.\n    }\n\n    /// @notice A request is converted to a loan when a lender clears it.\n    struct Loan {\n        Request request;        // Loan terms specified in the request.\n        uint256 amount;         // Amount of debt owed to the lender.\n        uint256 unclaimed;      // Amount of debt tokens repaid but unclaimed.\n        uint256 collateral;     // Amount of collateral pledged.\n        uint256 expiry;         // Time when the loan defaults.\n        address lender;         // Lender's address.\n        bool repayDirect;       // If this is false, repaid tokens must be claimed by lender.\n        bool callback;          // If this is true, the lender must inherit CoolerCallback.\n    }\n\n    // --- IMMUTABLES ------------------------------------------------\n\n    // This makes the code look prettier.\n    uint256 private constant DECIMALS_INTEREST = 1e18;\n\n    /// @notice This address owns the collateral in escrow.\n    function owner() public pure returns (address _owner) {\n        return _getArgAddress(0x0);\n    }\n\n    /// @notice This token is borrowed against.\n    function collateral() public pure returns (ERC20 _collateral) {\n        return ERC20(_getArgAddress(0x14));\n    }\n\n    /// @notice This token is lent.\n    function debt() public pure returns (ERC20 _debt) {\n        return ERC20(_getArgAddress(0x28));\n    }\n    \n    /// @notice This contract created the Cooler\n    function factory() public pure returns (CoolerFactory _factory) {\n        return CoolerFactory(_getArgAddress(0x3c));\n    }\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice Arrays stores all the loan requests.\n    Request[] public requests;\n\n    /// @notice Arrays stores all the granted loans.\n    Loan[] public loans;\n\n    /// @notice Facilitates transfer of lender ownership to new addresses\n    mapping(uint256 => address) public approvals;\n\n    // --- BORROWER --------------------------------------------------\n\n    /// @notice Request a loan with given parameters.\n    ///         Collateral is taken at time of request.\n    /// @param  amount_ of debt tokens to borrow.\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    /// @return reqID of the created request. Equivalent to the index of request in requests[].\n    function requestLoan(\n        uint256 amount_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        requests.push(\n            Request({\n                amount: amount_,\n                interest: interest_,\n                loanToCollateral: loanToCollateral_,\n                duration: duration_,\n                active: true\n            })\n        );\n\n        // The collateral is taken upfront. Will be escrowed\n        // until the loan is repaid or defaulted.\n        collateral().safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralFor(amount_, loanToCollateral_)\n        );\n\n        // Log the event.\n        factory().newEvent(reqID, CoolerFactory.Events.RequestLoan, 0);\n    }\n\n    /// @notice Cancel a loan request and get the collateral back.\n    /// @param  reqID_ index of request in requests[].\n    function rescindRequest(uint256 reqID_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n\n        Request storage req = requests[reqID_];\n\n        if (!req.active) revert Deactivated();\n\n        // Update storage and send collateral back to the owner.\n        req.active = false;\n        collateral().safeTransfer(owner(), collateralFor(req.amount, req.loanToCollateral));\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.RescindRequest, 0);\n    }\n\n    /// @notice Repay a loan to get the collateral back.\n    /// @dev    Despite a malicious lender could reenter with the callback, the\n    ///         usage of `msg.sender` prevents any economical benefit to the\n    ///         attacker, since they would be repaying the loan themselves.\n    /// @param  loanID_ index of loan in loans[]\n    /// @param  repaid_ debt tokens to be repaid.\n    /// @return collateral given back to the borrower.\n    function repayLoan(uint256 loanID_, uint256 repaid_) external returns (uint256) {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n\n        if (repaid_ > loan.amount) repaid_ = loan.amount;\n\n        uint256 decollateralized = (loan.collateral * repaid_) / loan.amount;\n        if (decollateralized == 0) revert ZeroCollateralReturned();\n\n        // Update loan memory.\n        loan.amount -= repaid_;\n        loan.collateral -= decollateralized;\n\n        address repayTo;\n        // Check whether repayment needs to be manually claimed or not.\n        if (loan.repayDirect) {\n            repayTo = loan.lender;\n        } else {\n            repayTo = address(this);\n            loan.unclaimed += repaid_;\n        }\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        // Transfer repaid debt back to the lender and (de)collateral back to the owner.\n        debt().safeTransferFrom(msg.sender, repayTo, repaid_);\n        collateral().safeTransfer(owner(), decollateralized);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.RepayLoan, repaid_);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRepay(loanID_, repaid_);\n        return decollateralized;\n    }\n\n    /// @notice Roll a loan over with new terms.\n    ///         provideNewTermsForRoll must have been called beforehand by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function rollLoan(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n        if (!loan.request.active) revert NotRollable();\n\n        // Check whether rolling the loan requires pledging more collateral or not (if there was a previous repayment).\n        uint256 newCollateral = newCollateralFor(loanID_);\n        uint256 newDebt = interestFor(loan.amount, loan.request.interest, loan.request.duration);\n\n        // Update memory accordingly.\n        loan.amount += newDebt;\n        loan.collateral += newCollateral;\n        loan.expiry += loan.request.duration;\n        loan.request.active = false;\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        if (newCollateral > 0) {\n            collateral().safeTransferFrom(msg.sender, address(this), newCollateral);\n        }\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRoll(loanID_, newDebt, newCollateral);\n    }\n\n    /// @notice Delegate voting power on collateral.\n    /// @param  to_ address to delegate.\n    function delegateVoting(address to_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n        IDelegate(address(collateral())).delegate(to_);\n    }\n\n    // --- LENDER ----------------------------------------------------\n\n    /// @notice Fill a requested loan as a lender.\n    /// @param  reqID_ index of request in requests[].\n    /// @param  repayDirect_ lender should input false if concerned about debt token blacklisting.\n    /// @param  isCallback_ true if the lender implements the CoolerCallback abstract. False otherwise.\n    /// @return loanID of the granted loan. Equivalent to the index of loan in loans[].\n    function clearRequest(\n        uint256 reqID_,\n        bool repayDirect_,\n        bool isCallback_\n    ) external returns (uint256 loanID) {\n        Request memory req = requests[reqID_];\n\n        // If necessary, ensure lender implements the CoolerCallback abstract.\n        if (isCallback_ && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\n\n        // Ensure loan request is active. \n        if (!req.active) revert Deactivated();\n\n        // Clear the loan request in memory.\n        req.active = false;\n\n        // Calculate and store loan terms.\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n        loanID = loans.length;\n        loans.push(\n            Loan({\n                request: req,\n                amount: req.amount + interest,\n                unclaimed: 0,\n                collateral: collat,\n                expiry: expiration,\n                lender: msg.sender,\n                repayDirect: repayDirect_,\n                callback: isCallback_\n            })\n        );\n\n        // Clear the loan request storage.\n        requests[reqID_].active = false;\n\n        // Transfer debt tokens to the owner of the request.\n        debt().safeTransferFrom(msg.sender, owner(), req.amount);\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.ClearRequest, 0);\n    }\n\n    /// @notice Provide new terms for loan to be rolled over.\n    /// @param  loanID_ index of loan in loans[].\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    function provideNewTermsForRoll(\n        uint256 loanID_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external {\n        Loan storage loan = loans[loanID_];\n\n        if (msg.sender != loan.lender) revert OnlyApproved();\n\n        loan.request =\n            Request(\n                loan.amount,\n                interest_,\n                loanToCollateral_,\n                duration_,\n                true\n            );\n    }\n\n    /// @notice Claim debt tokens if repayDirect was false.\n    /// @param  loanID_ index of loan in loans[].\n    function claimRepaid(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        // Update storage.\n        uint256 claim = loan.unclaimed;\n        delete loans[loanID_].unclaimed;\n\n        // Transfer repaid debt back to the lender.\n        debt().safeTransfer(loan.lender, claim);\n    }\n\n    /// @notice Claim collateral upon loan default.\n    /// @param loanID_ index of loan in loans[]\n    /// @return defaulted debt by the borrower, collateral kept by the lender, elapsed time since expiry.\n    function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256) {\n        Loan memory loan = loans[loanID_];\n        delete loans[loanID_];\n\n        if (block.timestamp <= loan.expiry) revert NoDefault();\n\n        // Transfer defaulted collateral to the lender.\n        collateral().safeTransfer(loan.lender, loan.collateral);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.DefaultLoan, 0);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onDefault(loanID_, loan.amount, loan.collateral);\n        return (loan.amount, loan.collateral, block.timestamp - loan.expiry);\n    }\n\n    /// @notice Approve transfer of loan ownership rights to a new address.\n    /// @param  to_ address to be approved.\n    /// @param  loanID_ index of loan in loans[].\n    function approveTransfer(address to_, uint256 loanID_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update transfer approvals.\n        approvals[loanID_] = to_;\n    }\n\n    /// @notice Execute loan ownership transfer. Must be previously approved by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function transferOwnership(uint256 loanID_) external {\n        if (msg.sender != approvals[loanID_]) revert OnlyApproved();\n\n        // Update the load lender.\n        loans[loanID_].lender = msg.sender;\n        // Clear transfer approvals.\n        approvals[loanID_] = address(0);\n    }\n\n    /// @notice Set direct repayment of a given loan.\n    /// @param  loanID_ of lender's loan.\n    /// @param  direct_ true if a direct repayment is desired. False otherwise.\n    function setDirectRepay(uint256 loanID_, bool direct_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update the repayment method.\n        loans[loanID_].repayDirect = direct_;\n    }\n\n    // --- AUX FUNCTIONS ---------------------------------------------\n\n    /// @notice Compute collateral needed for loan amount at given loan to collateral ratio.\n    /// @param  amount_ of collateral tokens.\n    /// @param  loanToCollateral_ ratio for loan.\n    function collateralFor(uint256 amount_, uint256 loanToCollateral_) public view returns (uint256) {\n        return (amount_ * (10 ** collateral().decimals())) / loanToCollateral_;\n    }\n\n    /// @notice compute collateral needed to roll loan.\n    /// @param  loanID_ of loan to roll.\n    function newCollateralFor(uint256 loanID_) public view returns (uint256) {\n        Loan memory loan = loans[loanID_];\n        // Accounts for all outstanding debt (borrowed amount + interest).\n        uint256 neededCollateral = collateralFor(\n            loan.amount,\n            loan.request.loanToCollateral\n        );\n\n        return\n            neededCollateral > loan.collateral ?\n            neededCollateral - loan.collateral :\n            0;\n    }\n\n    /// @notice Compute interest cost on amount for duration at given annualized rate.\n    /// @param  amount_ of debt tokens.\n    /// @param  rate_ of interest (annualized).\n    /// @param  duration_ of loan in seconds.\n    /// @return Interest in debt token terms.\n    function interestFor(uint256 amount_, uint256 rate_, uint256 duration_) public pure returns (uint256) {\n        uint256 interest = (rate_ * duration_) / 365 days;\n        return (amount_ * interest) / DECIMALS_INTEREST;\n    }\n\n    /// @notice Check if given loan is in default.\n    /// @param  loanID_ index of loan in loans[].\n    /// @return Defaulted status.\n    function isDefaulted(uint256 loanID_) external view returns (bool) {\n        return block.timestamp > loans[loanID_].expiry;\n    }\n\n    /// @notice Check if a given request is active.\n    /// @param  reqID_ index of request in requests[].\n    /// @return Active status.\n    function isActive(uint256 reqID_) external view returns (bool) {\n        return requests[reqID_].active;\n    }\n\n    /// @notice Getter for Request data as a struct.\n    /// @param  reqID_ index of request in requests[].\n    /// @return Request struct.\n    function getRequest(uint256 reqID_) external view returns (Request memory) {\n        return requests[reqID_];\n    }\n\n    /// @notice Getter for Loan data as a struct.\n    /// @param loanID_ index of loan in loans[].\n    /// @return Loan struct.\n    function getLoan(uint256 loanID_) external view returns (Loan memory) {\n        return loans[loanID_];\n    }\n}"
    },
    {
      "filename": "Cooler/src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Clone} from \"clones/Clone.sol\";\n\nimport {IDelegate} from \"interfaces/IDelegate.sol\";\nimport {CoolerFactory} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Cooler Loans.\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration, peer-to-peer\n///         loans for a user-defined debt-collateral pair.\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\n///         to save gas on deployment.\ncontract Cooler is Clone {\n    using SafeTransferLib for ERC20;\n\n    // --- ERRORS ----------------------------------------------------\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n    error ZeroCollateralReturned();\n    error NotCoolerCallback();\n\n    // --- DATA STRUCTURES -------------------------------------------\n\n    /// @notice A loan begins with a borrow request.\n    struct Request {\n        uint256 amount;             // Amount to be borrowed.\n        uint256 interest;           // Annualized percentage to be paid as interest.\n        uint256 loanToCollateral;   // Requested loan-to-collateral ratio.\n        uint256 duration;           // Time to repay the loan before it defaults.\n        bool active;                // Any lender can clear an active loan request.\n    }\n\n    /// @notice A request is converted to a loan when a lender clears it.\n    struct Loan {\n        Request request;        // Loan terms specified in the request.\n        uint256 amount;         // Amount of debt owed to the lender.\n        uint256 unclaimed;      // Amount of debt tokens repaid but unclaimed.\n        uint256 collateral;     // Amount of collateral pledged.\n        uint256 expiry;         // Time when the loan defaults.\n        address lender;         // Lender's address.\n        bool repayDirect;       // If this is false, repaid tokens must be claimed by lender.\n        bool callback;          // If this is true, the lender must inherit CoolerCallback.\n    }\n\n    // --- IMMUTABLES ------------------------------------------------\n\n    // This makes the code look prettier.\n    uint256 private constant DECIMALS_INTEREST = 1e18;\n\n    /// @notice This address owns the collateral in escrow.\n    function owner() public pure returns (address _owner) {\n        return _getArgAddress(0x0);\n    }\n\n    /// @notice This token is borrowed against.\n    function collateral() public pure returns (ERC20 _collateral) {\n        return ERC20(_getArgAddress(0x14));\n    }\n\n    /// @notice This token is lent.\n    function debt() public pure returns (ERC20 _debt) {\n        return ERC20(_getArgAddress(0x28));\n    }\n    \n    /// @notice This contract created the Cooler\n    function factory() public pure returns (CoolerFactory _factory) {\n        return CoolerFactory(_getArgAddress(0x3c));\n    }\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice Arrays stores all the loan requests.\n    Request[] public requests;\n\n    /// @notice Arrays stores all the granted loans.\n    Loan[] public loans;\n\n    /// @notice Facilitates transfer of lender ownership to new addresses\n    mapping(uint256 => address) public approvals;\n\n    // --- BORROWER --------------------------------------------------\n\n    /// @notice Request a loan with given parameters.\n    ///         Collateral is taken at time of request.\n    /// @param  amount_ of debt tokens to borrow.\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    /// @return reqID of the created request. Equivalent to the index of request in requests[].\n    function requestLoan(\n        uint256 amount_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        requests.push(\n            Request({\n                amount: amount_,\n                interest: interest_,\n                loanToCollateral: loanToCollateral_,\n                duration: duration_,\n                active: true\n            })\n        );\n\n        // The collateral is taken upfront. Will be escrowed\n        // until the loan is repaid or defaulted.\n        collateral().safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralFor(amount_, loanToCollateral_)\n        );\n\n        // Log the event.\n        factory().newEvent(reqID, CoolerFactory.Events.RequestLoan, 0);\n    }\n\n    /// @notice Cancel a loan request and get the collateral back.\n    /// @param  reqID_ index of request in requests[].\n    function rescindRequest(uint256 reqID_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n\n        Request storage req = requests[reqID_];\n\n        if (!req.active) revert Deactivated();\n\n        // Update storage and send collateral back to the owner.\n        req.active = false;\n        collateral().safeTransfer(owner(), collateralFor(req.amount, req.loanToCollateral));\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.RescindRequest, 0);\n    }\n\n    /// @notice Repay a loan to get the collateral back.\n    /// @dev    Despite a malicious lender could reenter with the callback, the\n    ///         usage of `msg.sender` prevents any economical benefit to the\n    ///         attacker, since they would be repaying the loan themselves.\n    /// @param  loanID_ index of loan in loans[]\n    /// @param  repaid_ debt tokens to be repaid.\n    /// @return collateral given back to the borrower.\n    function repayLoan(uint256 loanID_, uint256 repaid_) external returns (uint256) {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n\n        if (repaid_ > loan.amount) repaid_ = loan.amount;\n\n        uint256 decollateralized = (loan.collateral * repaid_) / loan.amount;\n        if (decollateralized == 0) revert ZeroCollateralReturned();\n\n        // Update loan memory.\n        loan.amount -= repaid_;\n        loan.collateral -= decollateralized;\n\n        address repayTo;\n        // Check whether repayment needs to be manually claimed or not.\n        if (loan.repayDirect) {\n            repayTo = loan.lender;\n        } else {\n            repayTo = address(this);\n            loan.unclaimed += repaid_;\n        }\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        // Transfer repaid debt back to the lender and (de)collateral back to the owner.\n        debt().safeTransferFrom(msg.sender, repayTo, repaid_);\n        collateral().safeTransfer(owner(), decollateralized);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.RepayLoan, repaid_);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRepay(loanID_, repaid_);\n        return decollateralized;\n    }\n\n    /// @notice Roll a loan over with new terms.\n    ///         provideNewTermsForRoll must have been called beforehand by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function rollLoan(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n        if (!loan.request.active) revert NotRollable();\n\n        // Check whether rolling the loan requires pledging more collateral or not (if there was a previous repayment).\n        uint256 newCollateral = newCollateralFor(loanID_);\n        uint256 newDebt = interestFor(loan.amount, loan.request.interest, loan.request.duration);\n\n        // Update memory accordingly.\n        loan.amount += newDebt;\n        loan.collateral += newCollateral;\n        loan.expiry += loan.request.duration;\n        loan.request.active = false;\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        if (newCollateral > 0) {\n            collateral().safeTransferFrom(msg.sender, address(this), newCollateral);\n        }\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRoll(loanID_, newDebt, newCollateral);\n    }\n\n    /// @notice Delegate voting power on collateral.\n    /// @param  to_ address to delegate.\n    function delegateVoting(address to_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n        IDelegate(address(collateral())).delegate(to_);\n    }\n\n    // --- LENDER ----------------------------------------------------\n\n    /// @notice Fill a requested loan as a lender.\n    /// @param  reqID_ index of request in requests[].\n    /// @param  repayDirect_ lender should input false if concerned about debt token blacklisting.\n    /// @param  isCallback_ true if the lender implements the CoolerCallback abstract. False otherwise.\n    /// @return loanID of the granted loan. Equivalent to the index of loan in loans[].\n    function clearRequest(\n        uint256 reqID_,\n        bool repayDirect_,\n        bool isCallback_\n    ) external returns (uint256 loanID) {\n        Request memory req = requests[reqID_];\n\n        // If necessary, ensure lender implements the CoolerCallback abstract.\n        if (isCallback_ && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\n\n        // Ensure loan request is active. \n        if (!req.active) revert Deactivated();\n\n        // Clear the loan request in memory.\n        req.active = false;\n\n        // Calculate and store loan terms.\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n        loanID = loans.length;\n        loans.push(\n            Loan({\n                request: req,\n                amount: req.amount + interest,\n                unclaimed: 0,\n                collateral: collat,\n                expiry: expiration,\n                lender: msg.sender,\n                repayDirect: repayDirect_,\n                callback: isCallback_\n            })\n        );\n\n        // Clear the loan request storage.\n        requests[reqID_].active = false;\n\n        // Transfer debt tokens to the owner of the request.\n        debt().safeTransferFrom(msg.sender, owner(), req.amount);\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.ClearRequest, 0);\n    }\n\n    /// @notice Provide new terms for loan to be rolled over.\n    /// @param  loanID_ index of loan in loans[].\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    function provideNewTermsForRoll(\n        uint256 loanID_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external {\n        Loan storage loan = loans[loanID_];\n\n        if (msg.sender != loan.lender) revert OnlyApproved();\n\n        loan.request =\n            Request(\n                loan.amount,\n                interest_,\n                loanToCollateral_,\n                duration_,\n                true\n            );\n    }\n\n    /// @notice Claim debt tokens if repayDirect was false.\n    /// @param  loanID_ index of loan in loans[].\n    function claimRepaid(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        // Update storage.\n        uint256 claim = loan.unclaimed;\n        delete loans[loanID_].unclaimed;\n\n        // Transfer repaid debt back to the lender.\n        debt().safeTransfer(loan.lender, claim);\n    }\n\n    /// @notice Claim collateral upon loan default.\n    /// @param loanID_ index of loan in loans[]\n    /// @return defaulted debt by the borrower, collateral kept by the lender, elapsed time since expiry.\n    function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256) {\n        Loan memory loan = loans[loanID_];\n        delete loans[loanID_];\n\n        if (block.timestamp <= loan.expiry) revert NoDefault();\n\n        // Transfer defaulted collateral to the lender.\n        collateral().safeTransfer(loan.lender, loan.collateral);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.DefaultLoan, 0);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onDefault(loanID_, loan.amount, loan.collateral);\n        return (loan.amount, loan.collateral, block.timestamp - loan.expiry);\n    }\n\n    /// @notice Approve transfer of loan ownership rights to a new address.\n    /// @param  to_ address to be approved.\n    /// @param  loanID_ index of loan in loans[].\n    function approveTransfer(address to_, uint256 loanID_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update transfer approvals.\n        approvals[loanID_] = to_;\n    }\n\n    /// @notice Execute loan ownership transfer. Must be previously approved by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function transferOwnership(uint256 loanID_) external {\n        if (msg.sender != approvals[loanID_]) revert OnlyApproved();\n\n        // Update the load lender.\n        loans[loanID_].lender = msg.sender;\n        // Clear transfer approvals.\n        approvals[loanID_] = address(0);\n    }\n\n    /// @notice Set direct repayment of a given loan.\n    /// @param  loanID_ of lender's loan.\n    /// @param  direct_ true if a direct repayment is desired. False otherwise.\n    function setDirectRepay(uint256 loanID_, bool direct_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update the repayment method.\n        loans[loanID_].repayDirect = direct_;\n    }\n\n    // --- AUX FUNCTIONS ---------------------------------------------\n\n    /// @notice Compute collateral needed for loan amount at given loan to collateral ratio.\n    /// @param  amount_ of collateral tokens.\n    /// @param  loanToCollateral_ ratio for loan.\n    function collateralFor(uint256 amount_, uint256 loanToCollateral_) public view returns (uint256) {\n        return (amount_ * (10 ** collateral().decimals())) / loanToCollateral_;\n    }\n\n    /// @notice compute collateral needed to roll loan.\n    /// @param  loanID_ of loan to roll.\n    function newCollateralFor(uint256 loanID_) public view returns (uint256) {\n        Loan memory loan = loans[loanID_];\n        // Accounts for all outstanding debt (borrowed amount + interest).\n        uint256 neededCollateral = collateralFor(\n            loan.amount,\n            loan.request.loanToCollateral\n        );\n\n        return\n            neededCollateral > loan.collateral ?\n            neededCollateral - loan.collateral :\n            0;\n    }\n\n    /// @notice Compute interest cost on amount for duration at given annualized rate.\n    /// @param  amount_ of debt tokens.\n    /// @param  rate_ of interest (annualized).\n    /// @param  duration_ of loan in seconds.\n    /// @return Interest in debt token terms.\n    function interestFor(uint256 amount_, uint256 rate_, uint256 duration_) public pure returns (uint256) {\n        uint256 interest = (rate_ * duration_) / 365 days;\n        return (amount_ * interest) / DECIMALS_INTEREST;\n    }\n\n    /// @notice Check if given loan is in default.\n    /// @param  loanID_ index of loan in loans[].\n    /// @return Defaulted status.\n    function isDefaulted(uint256 loanID_) external view returns (bool) {\n        return block.timestamp > loans[loanID_].expiry;\n    }\n\n    /// @notice Check if a given request is a"
    }
  ]
}