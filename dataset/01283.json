{
  "Title": "M-3: `Vault.update(anyUser,0,0,0)` can be called for free to increase `checkpoint.count` and pay smaller keeper fee than necessary",
  "Content": "# Issue M-3: `Vault.update(anyUser,0,0,0)` can be called for free to increase `checkpoint.count` and pay smaller keeper fee than necessary \n\nSource: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/29 \n\n## Found by \npanprog\n\nVault re-balances its deposits and redemptions once per oracle epoch, but since multiple users can deposit/redeem, rebalance keeper fee is shared equally between all users depositing and redeeming in the same epoch. For this reason, `checkpoint.count` counts the number of users who will split the keeper fee (each user pays `keeper fee / checkpoint.count`)\n\nThe problem is that there are currently 2 types of users who increase `checkpoint.count` while they do not pay any fee:\n1. Any user calling `Vault.update(user, 0, 0, 0)` isn't charged any fee but increases `checkpoint.count`\n2. Any user claiming assets is charged full `settlementFee` from the amount he claims, but is not charged any other (shared) fees after that, but still increases `checkpoint.count`\n\nThe 1st point is more severe, because it allows to intentionally reduce the keeper fee paid by calling `Vault.update(0,0,0)` from different random accounts (which costs only gas fees and nothing more). Each such call increases `checkpoint.count` and thus reduces the keeper fees paid by the attacker.\n\nAttack scenario:\n1. User deposits or withdraws from his normal account. `checkpoint.count = 1` for the epoch. Normally the user will pay the sum of the `settlementFee` of all the vault markets.\n2. User uses any 3 addresses without any funds other than ETH for gas to call `Vault.update(address1/2/3, 0,0,0)`. Each of these calls costs only gas to the user, but increases `checkpoint.count` to the value of 4.\n3. Once the epoch settles, user will only pay `settlementFee / 4` for his deposit/withdrawal, but the vault will still pay the Markets full `settlementFee` at the expense of the other vault users.\n\n## Vulnerability Detail\n\n`Vault._update(user, 0, 0, 0)` will pass all invariants checks:\n```solidity\n// invariant\n// @audit operator - pass\nif (msg.sender != account && !IVaultFactory(address(factory())).operators(account, msg.sender))\n    revert VaultNotOperatorError();\n// @audit 0,0,0 is single-sided - pass\nif (!depositAssets.add(redeemShares).add(claimAssets).eq(depositAssets.max(redeemShares).max(claimAssets)))\n    revert VaultNotSingleSidedError();\n// @audit depositAssets == 0 - pass\nif (depositAssets.gt(_maxDeposit(context)))\n    revert VaultDepositLimitExceededError();\n// @audit redeemShares == 0 - pass\nif (redeemShares.gt(_maxRedeem(context)))\n    revert VaultRedemptionLimitExceededError();\n// @audit depositAssets == 0 - pass\nif (!depositAssets.isZero() && depositAssets.lt(context.settlementFee))\n    revert VaultInsufficientMinimumError();\n// @audit redeemShares == 0 - pass\nif (!redeemShares.isZero() && context.latestCheckpoint.toAssets(redeemShares, context.settlementFee).isZero())\n    revert VaultInsufficientMinimumError();\n// @audit since this will be called by **different** users in the same epoch, this will also pass\nif (context.local.current != context.local.latest) revert VaultExistingOrderError();\n```\n\nIt then calculates amount to claim by calling `_socialize`:\n```solidity\n// asses socialization and settlement fee\nUFixed6 claimAmount = _socialize(context, depositAssets, redeemShares, claimAssets);\n...\nfunction _socialize(\n    Context memory context,\n    UFixed6 depositAssets,\n    UFixed6 redeemShares,\n    UFixed6 claimAssets\n) private view returns (UFixed6 claimAmount) {\n    // @audit global assets must be 0 to make (0,0,0) pass this function\n    if (context.global.assets.isZero()) return UFixed6Lib.ZERO;\n    UFixed6 totalCollateral = UFixed6Lib.from(_collateral(context).max(Fixed6Lib.ZERO));\n    claimAmount = claimAssets.muldiv(totalCollateral.min(context.global.assets), context.global.assets);\n\n    // @audit for (0,0,0) this will revert (underflow)\n    if (depositAssets.isZero() && redeemShares.isZero()) claimAmount = claimAmount.sub(context.settlementFee);\n}\n```\n\n`_socialize` will immediately return 0 if `context.global.assets == 0`.\nIf `context.global.assets > 0`, then this function will revert in the last line due to underflow (trying to subtract `settlementFee` from 0 `claimAmount`)\n\nThis is the condition for this issue to happen: global assets must be 0. Global assets are the amounts redeemed but not yet claimed by users. So this can reasonably happen in the first days of the vault life, when users mostly only deposit, or claim everything they withdraw.\n\nOnce this function passes, the following lines increase `checkpoint.count`:\n```solidity\n// update positions\ncontext.global.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\ncontext.local.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\ncontext.currentCheckpoint.update(depositAssets, redeemShares);\n...\n// Checkpoint library:\n...\nfunction update(Checkpoint memory self, UFixed6 deposit, UFixed6 redemption) internal pure {\n    (self.deposit, self.redemption) = (self.deposit.add(deposit), self.redemption.add(redemption));\n    self.count++;\n}\n```\n\nThe rest of the function executes normally.\n\nDuring position settlement, pending user deposits and redeems are reduced by the `keeper fees / checkpoint.count`:\n```solidity\n// Account library:\n...\nfunction processLocal(\n    Account memory self,\n    uint256 latestId,\n    Checkpoint memory checkpoint,\n    UFixed6 deposit,\n    UFixed6 redemption\n) internal pure {\n    self.latest = latestId;\n    (self.assets, self.shares) = (\n        self.assets.add(checkpoint.toAssetsLocal(redemption)),\n        self.shares.add(checkpoint.toSharesLocal(deposit))\n    );\n    (self.deposit, self.redemption) = (self.deposit.sub(deposit), self.redemption.sub(redemption));\n}\n...\n// Checkpoint library\n// toAssetsLocal / toSharesLocal calls _withoutKeeperLocal to calculate keeper fees:\n...\n    function _withoutKeeperLocal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 keeperPer = self.count == 0 ? UFixed6Lib.ZERO : self.keeper.div(UFixed6Lib.from(self.count));\n        return _withoutKeeper(amount, keeperPer);\n    }\n```\n\nAlso notice that in `processLocal` the only thing which keeper fees influence are deposits and redemptions, but not claims.\n\n## Proof of concept\n\nThe scenario above is demonstrated in the test, add this to Vault.test.ts:\n```solidity\nit('inflate checkpoint count', async () => {\n    const settlementFee = parse6decimal('10.00')\n    const marketParameter = { ...(await market.parameter()) }\n    marketParameter.settlementFee = settlementFee\n    await market.connect(owner).updateParameter(marketParameter)\n    const btcMarketParameter = { ...(await btcMarket.parameter()) }\n    btcMarketParameter.settlementFee = settlementFee\n    await btcMarket.connect(owner).updateParameter(btcMarketParameter)\n\n    const deposit = parse6decimal('10000')\n    await vault.connect(user).update(user.address, deposit, 0, 0)\n    await updateOracle()\n    await vault.settle(user.address)\n\n    const deposit2 = parse6decimal('10000')\n    await vault.connect(user2).update(user2.address, deposit2, 0, 0)\n\n    // inflate checkpoint.count\n    await vault.connect(btcUser1).update(btcUser1.address, 0, 0, 0)\n    await vault.connect(btcUser2).update(btcUser2.address, 0, 0, 0)\n\n    await updateOracle()\n    await vault.connect(user2).settle(user2.address)\n\n    const checkpoint2 = await vault.checkpoints(3)\n    console.log(\"checkpoint count = \" + checkpoint2.count)\n\n    var account = await vault.accounts(user.address);\n    var assets = await vault.convertToAssets(account.shares);\n    console.log(\"User shares:\" + account.shares + \" assets: \" + assets);\n    var account = await vault.accounts(user2.address);\n    var assets = await vault.convertToAssets(account.shares);\n    console.log(\"User2 shares:\" + account.shares + \" assets: \" + assets);\n})\n```\n\nConsole output:\n```solidity\ncheckpoint count = 3\nUser shares:10000000000 assets: 9990218973\nUser2 shares:10013140463 assets: 10003346584\n```\n\nSo the user2 inflates his deposited amounts by paying smaller keeper fee.\n\nIf 2 lines which inflate checkpoint count (after corresponding comment) are deleted, then the output is:\n```solidity\ncheckpoint count = 1\nUser shares:10000000000 assets: 9990218973\nUser2 shares:9999780702 assets: 9989999890\n```\n\nSo if not inflated, user2 pays correct amount and has roughly the same assets as user1 after his deposit.\n\n## Impact\n\nMalicious vault user can inflate `checkpoint.count` to pay much smaller keeper fee than they should at the expense of the other vault users.\n\n## Code Snippet\n\n`Vault.update(0,0,0)` will increase `checkpoint.count` here:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/Vault.sol#L300\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider reverting (0,0,0) vault updates, or maybe redirecting to `settle` in this case. Additionally, consider updating checkpoint only if `depositAssets` or `redeemShares` are not zero:\n```solidity\nif (!depositAssets.isZero() || !redeemShares.isZero())\n    context.currentCheckpoint.update(depositAssets, redeemShares);\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**polarzero** commented:\n> Medium. Perfectly explained and demonstrated in the report.\n\n\n\n**kbrizzle**\n\nFixed in: https://github.com/equilibria-xyz/perennial-v2/pull/111.\n\n**panprog**\n\n1. `Vault(user,0,0,0)` increasing `checkpoint.count` (medium severity) - fixed\n2. Any user who is claiming still increases `checkpoint.count`, although he pays for the claim fully and doesn't participate in paying the keeper fee for deposit/redeem, thus he shouldn't increase `checkpoint.count` (low severity) - not fixed\n\n\n**kbrizzle**\n\nSince (2) is overcharging the fee instead of undercharging (claim pays entire settlement fee instead of splitting the resulting fee with others in version), we're going to leave this as-is. We'll make a note of this in case we improve the claiming flow in the future.\n\n**jacksanford1**\n\nBased on @kbrizzle's comment, Sherlock will consider the issue brought up in #2 in the comment above by panprog as acknowledged. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/112",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/Vault.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IVaultFactory.sol\";\nimport \"./types/Account.sol\";\nimport \"./types/Checkpoint.sol\";\nimport \"./types/Registration.sol\";\nimport \"./types/Mapping.sol\";\nimport \"./types/VaultParameter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./lib/StrategyLib.sol\";\n\n/// @title Vault\n/// @notice Deploys underlying capital by weight in maker positions across registered markets\n/// @dev Vault deploys and rebalances collateral between the registered markets, while attempting to\n///      maintain `targetLeverage` with its open maker positions at any given time. Deposits are only gated in so much\n///      as to cap the maximum amount of assets in the vault.\n///\n///      All registered markets are expected to be on the same \"clock\", i.e. their oracle.current() is always equal.\n///\n///      The vault has a \"delayed settlement\" mechanism. After depositing to or redeeming from the vault, a user must\n///      wait until the next settlement of all underlying markets in order for vault settlement to be available.\ncontract Vault is IVault, Instance {\n    /// @dev The vault's name\n    string private _name;\n\n    /// @dev The underlying asset\n    Token18 public asset;\n\n    /// @dev The vault parameter set\n    VaultParameterStorage private _parameter;\n\n    /// @dev The total number of registered markets\n    uint256 public totalMarkets;\n\n    /// @dev Per-market registration state variables\n    mapping(uint256 => RegistrationStorage) private _registrations;\n\n    /// @dev Per-account accounting state variables\n    mapping(address => AccountStorage) private _accounts;\n\n    /// @dev Per-id accounting state variables\n    mapping(uint256 => CheckpointStorage) private _checkpoints;\n\n    /// @dev Per-id id-mapping state variables\n    mapping(uint256 => MappingStorage) private _mappings;\n\n    /// @notice Initializes the vault\n    /// @param asset_ The underlying asset\n    /// @param initialMarket The initial market to register\n    /// @param name_ The vault's name\n    function initialize(\n        Token18 asset_,\n        IMarket initialMarket,\n        UFixed6 cap,\n        string calldata name_\n    ) external initializer(1) {\n        __Instance__initialize();\n\n        asset = asset_;\n        _name = name_;\n        _register(initialMarket);\n        _updateMarket(0, 1, UFixed6Lib.ZERO);\n        _updateParameter(VaultParameter(cap));\n    }\n\n    /// @notice Returns the vault parameter set\n    /// @return The vault parameter set\n    function parameter() external view returns (VaultParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the registration for a given market\n    /// @param marketId The market id\n    /// @return The registration for the given market\n    function registrations(uint256 marketId) external view returns (Registration memory) {\n        return _registrations[marketId].read();\n    }\n\n    /// @notice Returns the account state for a account\n    /// @param account The account to query\n    /// @return The account state for the given account\n    function accounts(address account) external view returns (Account memory) {\n        return _accounts[account].read();\n    }\n\n    /// @notice Returns the checkpoint for a given id\n    /// @param id The id to query\n    /// @return The checkpoint for the given id\n    function checkpoints(uint256 id) external view returns (Checkpoint memory) {\n        return _checkpoints[id].read();\n    }\n\n    /// @notice Returns the mapping for a given id\n    /// @param id The id to query\n    /// @return The mapping for the given id\n    function mappings(uint256 id) external view returns (Mapping memory) {\n        return _mappings[id].read();\n    }\n\n    /// @notice Returns the name of the vault\n    /// @return The name of the vault\n    function name() external view returns (string memory) {\n        return string(abi.encodePacked(\"Perennial V2 Vault: \", _name));\n    }\n\n    /// @notice Returns the total number of underlying assets at the last checkpoint\n    /// @return The total number of underlying assets at the last checkpoint\n    function totalAssets() public view returns (Fixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.assets\n            .add(Fixed6Lib.from(checkpoint.deposit))\n            .sub(Fixed6Lib.from(checkpoint.toAssetsGlobal(checkpoint.redemption)));\n    }\n\n    /// @notice Returns the total number of shares at the last checkpoint\n    /// @return The total number of shares at the last checkpoint\n    function totalShares() public view returns (UFixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.shares\n            .add(checkpoint.toSharesGlobal(checkpoint.deposit))\n            .sub(checkpoint.redemption);\n    }\n\n    /// @notice Converts a given amount of assets to shares\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets\n    function convertToShares(UFixed6 assets) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.from(totalAssets().max(Fixed6Lib.ZERO)), totalShares());\n        return _totalShares.isZero() ? assets : assets.muldiv(_totalShares, _totalAssets);\n    }\n\n    /// @notice Converts a given amount of shares to assets\n    /// @param shares Number of shares to convert to assets\n    /// @return Amount of assets for the given shares\n    function convertToAssets(UFixed6 shares) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.from(totalAssets().max(Fixed6Lib.ZERO)), totalShares());\n        return _totalShares.isZero() ? shares : shares.muldiv(_totalAssets, _totalShares);\n    }\n\n    /// @notice Registers a new market\n    /// @param market The market to register\n    function register(IMarket market) external onlyOwner {\n        settle(address(0));\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (_registrations[marketId].read().market == market) revert VaultMarketExistsError();\n        }\n\n        _register(market);\n    }\n\n    /// @notice Handles the registration for a new market\n    /// @param market The market to register\n    function _register(IMarket market) private {\n        if (!IVaultFactory(address(factory())).marketFactory().instances(market)) revert VaultNotMarketError();\n        if (!market.token().eq(asset)) revert VaultIncorrectAssetError();\n\n        asset.approve(address(market));\n\n        uint256 newMarketId = totalMarkets++;\n        _registrations[newMarketId].store(Registration(market, 0, UFixed6Lib.ZERO));\n        emit MarketRegistered(newMarketId, market);\n    }\n\n    /// @notice Settles, then updates the registration parameters for a given market\n    /// @param marketId The market id\n    /// @param newWeight The new weight\n    /// @param newLeverage The new leverage\n    function updateMarket(uint256 marketId, uint256 newWeight, UFixed6 newLeverage) external onlyOwner {\n        settle(address(0));\n        _updateMarket(marketId, newWeight, newLeverage);\n    }\n\n    /// @notice Updates the registration parameters for a given market\n    /// @param marketId The market id\n    /// @param newWeight The new weight\n    /// @param newLeverage The new leverage\n    function _updateMarket(uint256 marketId, uint256 newWeight, UFixed6 newLeverage) private {\n        if (marketId >= totalMarkets) revert VaultMarketDoesNotExistError();\n\n        Registration memory registration = _registrations[marketId].read();\n        registration.weight = newWeight;\n        registration.leverage = newLeverage;\n        _registrations[marketId].store(registration);\n        emit MarketUpdated(marketId, newWeight, newLeverage);\n    }\n\n    /// @notice Settles, then updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function updateParameter(VaultParameter memory newParameter) external onlyOwner {\n        settle(address(0));\n        _updateParameter(newParameter);\n    }\n\n    /// @notice Updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function _updateParameter(VaultParameter memory newParameter) private {\n        _parameter.store(newParameter);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Claims the accrued rewards for each registered market\n    /// @dev Callable by owner in case vault accrues rewards, since it is not able to disperse them itself\n    function claimReward() external onlyOwner {\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            _registrations[marketId].read().market.claimReward();\n            _registrations[marketId].read().market.reward().push(factory().owner());\n        }\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @dev Also rebalances the collateral and position of the vault without a deposit or withdraw\n    /// @param account The account that should be synced\n    function settle(address account) public whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _manage(context, UFixed6Lib.ZERO, false);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates `account`, depositing `depositAssets` assets, redeeming `redeemShares` shares, and claiming `claimAssets` assets\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function update(\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) external whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _checkpoint(context);\n        _update(context, account, depositAssets, redeemShares, claimAssets);\n        _saveContext(context, account);\n    }\n\n    /// @notice loads or initializes the current checkpoint\n    /// @param context The context to use\n    function _checkpoint(Context memory context) private {\n        context.currentId = context.global.current;\n        if (_mappings[context.currentId].read().next(context.currentIds)) {\n            context.currentId++;\n            context.currentCheckpoint.initialize(context.global, asset.balanceOf());\n            _mappings[context.currentId].store(context.currentIds);\n        } else {\n            context.currentCheckpoint = _checkpoints[context.currentId].read();\n        }\n    }\n\n    /// @notice Handles updating the account's position\n    /// @param context The context to use\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) private {\n        // magic values\n        if (claimAssets.eq(UFixed6Lib.MAX)) claimAssets = context.local.assets;\n        if (redeemShares.eq(UFixed6Lib.MAX)) redeemShares = context.local.shares;\n\n        // invariant\n        if (msg.sender != account && !IVaultFactory(address(factory())).operators(account, msg.sender))\n            revert VaultNotOperatorError();\n        if (!depositAssets.add(redeemShares).add(claimAssets).eq(depositAssets.max(redeemShares).max(claimAssets)))\n            revert VaultNotSingleSidedError();\n        if (depositAssets.gt(_maxDeposit(context)))\n            revert VaultDepositLimitExceededError();\n        if (redeemShares.gt(_maxRedeem(context)))\n            revert VaultRedemptionLimitExceededError();\n        if (!depositAssets.isZero() && depositAssets.lt(context.settlementFee))\n            revert VaultInsufficientMinimumError();\n        if (!redeemShares.isZero() && context.latestCheckpoint.toAssets(redeemShares, context.settlementFee).isZero())\n            revert VaultInsufficientMinimumError();\n\n        if (context.local.current != context.local.latest) revert VaultExistingOrderError();\n\n        // asses socialization and settlement fee\n        UFixed6 claimAmount = _socialize(context, depositAssets, redeemShares, claimAssets);\n\n        // update positions\n        context.global.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.local.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.currentCheckpoint.update(depositAssets, redeemShares);\n\n        // manage assets\n        asset.pull(msg.sender, UFixed18Lib.from(depositAssets));\n        _manage(context, claimAmount, true);\n        asset.push(msg.sender, UFixed18Lib.from(claimAmount));\n\n        emit Updated(msg.sender, account, context.currentId, depositAssets, redeemShares, claimAssets);\n    }\n\n    /// @notice Returns the claim amount after socialization and settlement fee\n    /// @param context The context to use\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function _socialize(\n        Context memory context,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) private view returns (UFixed6 claimAmount) {\n        if (context.global.assets.isZero()) return UFixed6Lib.ZERO;\n        UFixed6 totalCollateral = UFixed6Lib.from(_collateral(context).max(Fixed6Lib.ZERO));\n        claimAmount = claimAssets.muldiv(totalCollateral.min(context.global.assets), context.global.assets);\n\n        if (depositAssets.isZero() && redeemShares.isZero()) claimAmount = claimAmount.sub(context.settlementFee);\n    }\n\n    /// @notice Handles settling the vault's underlying markets\n    function _settleUnderlying() private {\n        for (uint256 marketId; marketId < totalMarkets; marketId++)\n            _registrations[marketId].read().market.update(\n                address(this),\n                UFixed6Lib.MAX,\n                UFixed6Lib.ZERO,\n                UFixed6Lib.ZERO,\n                Fixed6Lib.ZERO,\n                false\n            );\n    }\n\n    /// @notice Handles settling the vault state\n    /// @dev Run before every stateful operation to settle up the latest global state of the vault\n    /// @param context The context to use\n    function _settle(Context memory context, address account) private {\n        // settle global positions\n        while (\n            context.global.current > context.global.latest &&\n            _mappings[context.global.latest + 1].read().ready(context.latestIds)\n        ) {\n            uint256 newLatestId = context.global.latest + 1;\n            context.latestCheckpoint = _checkpoints[newLatestId].read();\n            (Fixed6 collateralAtId, UFixed6 feeAtId, UFixed6 keeperAtId) = _collateralAtId(context, newLatestId);\n            context.latestCheckpoint.complete(collateralAtId, feeAtId, keeperAtId);\n\n            context.global.processGlobal(\n                newLatestId,\n                context.latestCheckpoint,\n                context.latestCheckpoint.deposit,\n                context.latestCheckpoint.redemption\n            );\n            _checkpoints[newLatestId].store(context.latestCheckpoint);\n        }\n\n        if (account == address(0)) return;\n\n        // settle local position\n        if (\n            context.local.current > context.local.latest &&\n            _mappings[context.local.current].read().ready(context.latestIds)\n        ) {\n            uint256 newLatestId = context.local.current;\n            Checkpoint memory checkpoint = _checkpoints[newLatestId].read();\n            context.local.processLocal(\n                newLatestId,\n                checkpoint,\n                context.local.deposit,\n                context.local.redemption\n            );\n        }\n    }\n\n    /// @notice Manages the internal collateral and position strategy of the vault\n    /// @param withdrawAmount The amount of assets that need to be withdrawn from the markets into the vault\n    /// @param rebalance Whether to rebalance the vault's position\n    function _manage(Context memory context, UFixed6 withdrawAmount, bool rebalance) private {\n        (Fixed6 collateral, UFixed6 assets) = _treasury(context, withdrawAmount);\n\n        if (!rebalance || collateral.lt(Fixed6Lib.ZERO)) return;\n\n        StrategyLib.MarketTarget[] memory targets = StrategyLib.allocate(\n            context.registrations,\n            UFixed6Lib.from(collateral.max(Fixed6Lib.ZERO)),\n            assets\n        );\n\n        for (uint256 marketId; marketId < context.markets.length; marketId++)\n            if (targets[marketId].collateral.lt(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId]);\n        for (uint256 marketId; marketId < context.markets.length; marketId++)\n            if (targets[marketId].collateral.gte(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId]);\n    }\n\n    /// @notice Returns the amount of collateral and assets in the vault\n    /// @param context The context to use\n    /// @param withdrawAmount The amount of assets that need to be withdrawn from the markets into the vault\n    function _treasury(Context memory context, UFixed6 withdrawAmount) private view returns (Fixed6 collateral, UFixed6 assets) {\n        collateral = _collateral(context).sub(Fixed6Lib.from(withdrawAmount));\n\n        // collateral currently deployed\n        Fixed6 liabilities = Fixed6Lib.from(context.global.assets.add(context.global.deposit));\n        // net assets\n        assets = UFixed6Lib.from(collateral.sub(liabilities).max(Fixed6Lib.ZERO))\n            // approximate assets up for redemption\n            .mul(context.global.shares.unsafeDiv(context.global.shares.add(context.global.redemption)))\n            // deploy assets up for deposit\n            .add(context.global.deposit);\n    }\n\n    /// @notice Adjusts the position on `market` to `targetPosition`\n    /// @param target The new state to target\n    function _retarget(Registration memory registration, StrategyLib.MarketTarget memory target) private {\n        registration.market.update(\n            address(this),\n            target.position,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            target.collateral,\n            false\n        );\n    }\n\n    /// @notice Loads the context for the given `account`\n    /// @param account Account to load the context for\n    /// @return context The context\n    function _loadContext(address account) private view returns (Context memory context) {\n        context.parameter = _parameter.read();\n\n        context.currentIds.initialize(totalMarkets);\n        context.latestIds.initialize(totalMarkets);\n        context.registrations = new Registration[](totalMarkets);\n        context.markets = new MarketContext[](totalMarkets);\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            // parameter\n            Registration memory registration = _registrations[marketId].read();\n            MarketParameter memory marketParameter = registration.market.parameter();\n            context.registrations[marketId] = registration;\n            context.settlementFee = context.settlementFee.add(marketParameter.settlementFee);\n\n            // global\n            Global memory global = registration.market.global();\n            Position memory currentPosition = registration.market.pendingPosition(global.currentId);\n\n            context.markets[marketId].latestPrice = global.latestPrice.abs();\n            context.markets[marketId].currentPosition = currentPosition.maker;\n            context.markets[marketId].currentNet = currentPosition.net();\n            context.totalWeight += registration.weight;\n\n            // local\n            Local memory local = registration.market.locals(address(this));\n            Position memory latestAccountPosition = registration.market.positions(address(this));\n            Position memory currentAccountPosition = registration.market.pendingPositions(address(this), local.currentId);\n            context.markets[marketId].collateral = local.collateral;\n            context.markets[marketId].latestAccountPosition = latestAccountPosition.maker;\n            context.markets[marketId].currentAccountPosition = currentAccountPosition.maker;\n\n            // ids\n            context.latestIds.update(marketId, local.latestId);\n            context.currentIds.update(marketId, local.currentId);\n        }\n\n        if (account != address(0)) context.local = _accounts[account].read();\n        context.global = _accounts[address(0)].read();\n        context.latestCheckpoint = _checkpoints[context.global.latest].read();\n    }\n\n    /// @notice Saves the context into storage\n    /// @param context Context to use\n    /// @param account Account to save the context for\n    function _saveContext(Context memory context, address account) private {\n        if (account != address(0)) _accounts[account].store(context.local);\n        _accounts[address(0)].store(context.global);\n        _checkpoints[context.currentId].store(context.currentCheckpoint);\n    }\n\n    /// @notice The maximum available deposit amount\n    /// @param context Context to use in calculation\n    /// @return Maximum available deposit amount\n    function _maxDeposit(Context memory context) private view returns (UFixed6) {\n        if (context.latestCheckpoint.unhealthy()) return UFixed6Lib.ZERO;\n        UFixed6 collateral = UFixed6Lib.from(totalAssets().max(Fixed6Lib.ZERO)).add(context.global.deposit);\n        return context.global.assets.add(context.parameter.cap.sub(collateral.min(context.parameter.cap)));\n    }\n\n    /// @notice The maximum available redemption amount for `account`\n    /// @param context Context to use\n    /// @return redemptionAmount Maximum available redemption amount\n    function _maxRedeem(Context memory context) private view returns (UFixed6 redemptionAmount) {\n        if (context.latestCheckpoint.unhealthy()) return UFixed6Lib.ZERO;\n\n        redemptionAmount = UFixed6Lib.MAX;\n        for (uint256 marketId; marketId < context.markets.length; marketId++) {\n            MarketContext memory marketContext = context.markets[marketId];\n            Registration memory registration = context.registrations[marketId];\n            // If market has 0 weight, leverage, or position, skip\n            if (\n                registration.weight == 0 ||\n                registration.leverage.isZero() ||\n                (marketContext.latestAccountPosition.isZero() && marketContext.currentAccountPosition.isZero())\n            ) continue;\n\n            UFixed6 collateral = marketContext.currentPosition\n                .sub(marketContext.currentNet.min(marketContext.currentPosition))           // available maker\n                .min(_closablePosition(context, marketId).mul(StrategyLib.LEVERAGE_BUFFER)) // available closable\n                .muldiv(marketContext.latestPrice, registration.leverage)                   // available collateral\n                .muldiv(context.totalWeight, registration.weight);                          // collateral in market\n\n            redemptionAmount = redemptionAmount.min(context.latestCheckpoint.toShares(collateral, UFixed6Lib.ZERO));\n        }\n    }\n\n    /// @notice Returns the closable position amount for `marketId`\n    /// @param context Context to use\n    /// @param marketId Market to use\n    /// @return closable The closable amount\n    function _closablePosition(Context memory context, uint256 marketId) private view returns (UFixed6 closable) {\n        // latest position\n        Position memory latestPosition = context.registrations[marketId].market.positions(address(this));\n        UFixed6 previousMaker;\n        (previousMaker, closable) = _loadPosition(\n            latestPosition,\n            latestPosition,\n            previousMaker,\n            latestPosition.maker\n        );\n\n        // pending positions\n        for (uint256 id = context.latestIds.get(marketId) + 1; id <= context.currentIds.get(marketId); id++) {\n            (previousMaker, closable) = _loadPosition(\n                latestPosition,\n                context.registrations[marketId].market.pendingPositions(address(this), id),\n                previousMaker,\n                closable\n            );\n        }\n    }\n\n    /// @notice Loads one position for the closable position calculation\n    /// @param latestPosition The latest position\n    /// @param position The position to load\n    /// @param previousMaker The previous maker amount\n    /// @param previousClosable The previous closable amount\n    /// @return nextMaker The next maker amount\n    /// @return nextClosable The next closable amount\n    function _loadPosition(\n        Position memory latestPosition,\n        Position memory position,\n        UFixed6 previousMaker,\n        UFixed6 previousClosable\n    ) private pure returns (UFixed6 nextMaker, UFixed6 nextClosable) {\n        position.adjust(latestPosition);\n        nextClosable = previousClosable.sub(previousMaker.sub(position.maker.min(previousMaker)));\n        nextMaker = position.maker;\n    }\n\n    /// @notice Returns the real amount of collateral in the vault\n    /// @return value The real amount of collateral in the vault\n    function _collateral(Context memory context) public view returns (Fixed6 value) {\n        value = Fixed6Lib.from(UFixed6Lib.from(asset.balanceOf()));\n        for (uint256 marketId; marketId < context.markets.length; marketId++)\n            value = value.add(context.markets[marketId].collateral);\n    }\n\n    /// @notice Returns the collateral and fee information for the vault at position\n    /// @param context Context to use\n    /// @param id Position to use\n    /// @return value The snapshotted amount of collateral in the vault\n    /// @return fee The snapshotted amount of fee in that position\n    /// @return keeper The snapshotted amount of keeper in that position\n    function _collateralAtId(Context memory context, uint256 id) public view returns (Fixed6 value, UFixed6 fee, UFixed6 keeper) {\n        Mapping memory mappingAtId = _mappings[id].read();\n        for (uint256 marketId; marketId < mappingAtId.length(); marketId++) {\n            Position memory currentAccountPosition = context.registrations[marketId].market\n                .pendingPositions(address(this), mappingAtId.get(marketId));\n            value = value.add(currentAccountPosition.collateral);\n            fee = fee.add(currentAccountPosition.fee);\n            keeper = keeper.add(currentAccountPosition.keeper);\n        }\n    }\n}"
    }
  ]
}