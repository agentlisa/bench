{
  "Title": "safeApproveAllTokens Implementation Differs From Documentation",
  "Content": "The `safeApproveAllTokens` function [comments](https://github.com/OriginProtocol/origin-dollar/blob/eb11498c376b65696c90981757221b076d6226aa/contracts/contracts/strategies/balancer/BalancerMetaPoolStrategy.sol#L421) specify that the function should approve the Balancer pool to transfer all supported assets from the strategy, as well as approve the `wstEth` and `sfrxEth` contracts to pull `stEth` and `frxEth` from the Strategy for wrapping purposes. However, the function does not perform the necessary approvals to wrap the tokens, and additionally, it approves the Balancer vault and Aura rewards pool to [withdraw an unlimited number of BPTs](https://github.com/OriginProtocol/origin-dollar/blob/eb11498c376b65696c90981757221b076d6226aa/contracts/contracts/strategies/balancer/BalancerMetaPoolStrategy.sol#L431).\n\n\nConsider correcting the `safeApproveAllTokens` function to follow its intended behavior.Â \n\n\n***Update:** Resolved in [pull request #1776](https://github.com/OriginProtocol/origin-dollar/pull/1776).*\n\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/balancer/BalancerMetaPoolStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Balancer MetaStablePool Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BaseAuraStrategy, BaseBalancerStrategy } from \"./BaseAuraStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { IMetaStablePool } from \"../../interfaces/balancer/IMetaStablePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\ncontract BalancerMetaPoolStrategy is BaseAuraStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        BaseBalancerConfig memory _balancerConfig,\n        address _auraRewardPoolAddress\n    )\n        InitializableAbstractStrategy(_stratConfig)\n        BaseBalancerStrategy(_balancerConfig)\n        BaseAuraStrategy(_auraRewardPoolAddress)\n    {}\n\n    /**\n     * @notice Deposits an `_amount` of vault collateral assets\n     * from the this strategy contract to the Balancer pool.\n     * @param _asset Address of the Vault collateral asset\n     * @param _amount The amount of Vault collateral assets to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        assets[0] = _asset;\n        amounts[0] = _amount;\n\n        _deposit(assets, amounts);\n    }\n\n    /**\n     * @notice Deposits specified vault collateral assets\n     * from the this strategy contract to the Balancer pool.\n     * @param _assets Address of the Vault collateral assets\n     * @param _amounts The amount of each asset to deposit\n     */\n    function deposit(address[] memory _assets, uint256[] memory _amounts)\n        external\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_assets, _amounts);\n    }\n\n    /**\n     * @notice Deposits all supported assets in this strategy contract to the Balancer pool.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 assetsLength = assetsMapped.length;\n        address[] memory assets = new address[](assetsLength);\n        uint256[] memory amounts = new uint256[](assetsLength);\n\n        // For each vault collateral asset\n        for (uint256 i = 0; i < assetsLength; ++i) {\n            assets[i] = assetsMapped[i];\n            // Get the asset balance in this strategy contract\n            amounts[i] = IERC20(assets[i]).balanceOf(address(this));\n        }\n        _deposit(assets, amounts);\n    }\n\n    function _deposit(address[] memory _assets, uint256[] memory _amounts)\n        internal\n    {\n        require(_assets.length == _amounts.length, \"Array length missmatch\");\n\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256[] memory mappedAmounts = new uint256[](tokens.length);\n        address[] memory mappedAssets = new address[](tokens.length);\n\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            address asset = _assets[i];\n            uint256 amount = _amounts[i];\n\n            require(assetToPToken[asset] != address(0), \"Unsupported asset\");\n            mappedAssets[i] = toPoolAsset(_assets[i]);\n\n            if (amount > 0) {\n                emit Deposit(asset, platformAddress, amount);\n\n                // wrap rebasing assets like stETH and frxETH to wstETH and sfrxETH\n                (, mappedAmounts[i]) = wrapPoolAsset(asset, amount);\n            }\n        }\n\n        uint256[] memory amountsIn = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Convert IERC20 type to address\n            poolAssets[i] = address(tokens[i]);\n\n            // For each of the mapped assets\n            for (uint256 j = 0; j < mappedAssets.length; ++j) {\n                // If the pool asset is the same as the mapped asset\n                if (poolAssets[i] == mappedAssets[j]) {\n                    amountsIn[i] = mappedAmounts[j];\n                }\n            }\n        }\n\n        uint256 minBPT = getBPTExpected(_assets, _amounts);\n        uint256 minBPTwSlippage = minBPT.mulTruncate(1e18 - maxDepositSlippage);\n\n        /* EXACT_TOKENS_IN_FOR_BPT_OUT:\n         * User sends precise quantities of tokens, and receives an\n         * estimated but unknown (computed at run time) quantity of BPT.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [EXACT_TOKENS_IN_FOR_BPT_OUT, amountsIn, minimumBPT]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolJoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amountsIn,\n            minBPTwSlippage\n        );\n\n        IBalancerVault.JoinPoolRequest memory request = IBalancerVault\n            .JoinPoolRequest(poolAssets, amountsIn, userData, false);\n\n        // Add the pool assets in this strategy to the balancer pool\n        balancerVault.joinPool(\n            balancerPoolId,\n            address(this),\n            address(this),\n            request\n        );\n\n        // Deposit the Balancer Pool Tokens (BPT) into Aura\n        _lpDepositAll();\n    }\n\n    /**\n     * @notice Withdraw a Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _asset Address of the Vault collateral asset\n     * @param _amount The amount of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        assets[0] = _asset;\n        amounts[0] = _amount;\n\n        _withdraw(_recipient, assets, amounts);\n    }\n\n    /**\n     * @notice Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _assets Addresses of the Vault collateral assets\n     * @param _amounts The amounts of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address[] memory _assets,\n        uint256[] memory _amounts\n    ) external onlyVault nonReentrant {\n        _withdraw(_recipient, _assets, _amounts);\n    }\n\n    /**\n     * @dev Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _assets Addresses of the Vault collateral assets\n     * @param _amounts The amounts of Vault collateral assets to withdraw\n     */\n    function _withdraw(\n        address _recipient,\n        address[] memory _assets,\n        uint256[] memory _amounts\n    ) internal {\n        require(_assets.length == _amounts.length, \"Invalid input arrays\");\n\n        // STEP 1 - Calculate the max about of Balancer Pool Tokens (BPT) to withdraw\n\n        // Estimate the required amount of Balancer Pool Tokens (BPT) for the assets\n        uint256 maxBPTtoWithdraw = getBPTExpected(_assets, _amounts);\n        // Increase BPTs by the max allowed slippage\n        // Any excess BPTs will be left in this strategy contract\n        maxBPTtoWithdraw = maxBPTtoWithdraw.mulTruncate(\n            1e18 + maxWithdrawalSlippage\n        );\n\n        // STEP 2  - Withdraw the Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        // Withdraw BPT from Aura allowing for BPTs left in this strategy contract from previous withdrawals\n        _lpWithdraw(\n            maxBPTtoWithdraw - IERC20(platformAddress).balanceOf(address(this))\n        );\n\n        // STEP 3 - Calculate the Balancer pool assets and amounts from the vault collateral assets\n\n        // Get all the supported balancer pool assets\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n        // Calculate the balancer pool assets and amounts to withdraw\n        uint256[] memory poolAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        // Is the wrapped asset amount indexed by the assets array, not the order of the Balancer pool tokens\n        // eg wstETH and sfrxETH amounts, not the stETH and frxETH amounts\n        uint256[] memory wrappedAssetAmounts = new uint256[](_assets.length);\n\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n\n            // for each of the vault assets\n            for (uint256 j = 0; j < _assets.length; ++j) {\n                // Convert the Balancer pool asset back to a vault collateral asset\n                address vaultAsset = fromPoolAsset(poolAssets[i]);\n\n                // If the vault asset equals the vault asset mapped from the Balancer pool asset\n                if (_assets[j] == vaultAsset) {\n                    (, poolAmountsOut[i]) = toPoolAsset(\n                        vaultAsset,\n                        _amounts[j]\n                    );\n                    wrappedAssetAmounts[j] = poolAmountsOut[i];\n\n                    /* Because of the potential Balancer rounding error mentioned below\n                     * the contract might receive 1-2 WEI smaller amount than required\n                     * in the withdraw user data encoding. If slightly lesser token amount\n                     * is received the strategy can not unwrap the pool asset as it is\n                     * smaller than expected.\n                     *\n                     * For that reason we `overshoot` the required tokens expected to\n                     * circumvent the error\n                     */\n                    if (poolAmountsOut[i] > 0) {\n                        poolAmountsOut[i] += 2;\n                    }\n                }\n            }\n        }\n\n        // STEP 4 - Withdraw the balancer pool assets from the pool\n\n        /* Custom asset exit: BPT_IN_FOR_EXACT_TOKENS_OUT:\n         * User sends an estimated but unknown (computed at run time) quantity of BPT,\n         * and receives precise quantities of specified tokens.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [BPT_IN_FOR_EXACT_TOKENS_OUT, amountsOut, maxBPTAmountIn]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT,\n            poolAmountsOut,\n            maxBPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(\n                poolAssets,\n                /* We specify the exact amount of a tokens we are expecting in the encoded\n                 * userData, for that reason we don't need to specify the amountsOut here.\n                 *\n                 * Also Balancer has a rounding issue that can make a transaction fail:\n                 * https://github.com/balancer/balancer-v2-monorepo/issues/2541\n                 * which is an extra reason why this field is empty.\n                 */\n                new uint256[](tokens.length),\n                userData,\n                false\n            );\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            // TODO: this is incorrect and should be altered when/if we intend to support\n            // pools that deal with native ETH\n            payable(address(this)),\n            request\n        );\n\n        // STEP 5 - Unswap balancer pool assets to vault collateral assets and sent to the vault.\n\n        // For each of the specified assets\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            uint256 assetAmount = 0;\n            if (wrappedAssetAmounts[i] > 0) {\n                assetAmount = unwrapPoolAsset(\n                    _assets[i],\n                    wrappedAssetAmounts[i]\n                );\n            }\n\n            // Transfer the vault collateral assets to the recipient, which is typically the vault\n            if (_amounts[i] > 0) {\n                IERC20(_assets[i]).safeTransfer(_recipient, _amounts[i]);\n\n                emit Withdrawal(_assets[i], platformAddress, _amounts[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws all supported Vault collateral assets from the Balancer pool\n     * and send to the OToken's Vault.\n     *\n     * Is only executable by the OToken's Vault or the Governor.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        // STEP 1 - Withdraw all Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        _lpWithdrawAll();\n\n        // STEP 2 - Calculate the minumum amount of pool assets to accept for the BPTs\n\n        // Get the BPTs withdrawn from Aura plus any that were already in this strategy contract\n        uint256 BPTtoWithdraw = IERC20(platformAddress).balanceOf(\n            address(this)\n        );\n\n        // Get the balancer pool assets and their total balances\n        (IERC20[] memory tokens, uint256[] memory balances, ) = balancerVault\n            .getPoolTokens(balancerPoolId);\n\n        // the strategy's share of the pool assets\n        uint256 strategyShare = BPTtoWithdraw.divPrecisely(\n            IERC20(platformAddress).totalSupply()\n        );\n\n        uint256[] memory minAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n            minAmountsOut[i] = balances[i]\n                .mulTruncate(strategyShare)\n                .mulTruncate(1e18 - maxWithdrawalSlippage);\n        }\n\n        // STEP 3 - Withdraw the Balancer pool assets from the pool\n\n        /* Proportional exit: EXACT_BPT_IN_FOR_TOKENS_OUT:\n         * User sends a precise quantity of BPT, and receives an estimated but unknown\n         * (computed at run time) quantity of a single token\n         *\n         * ['uint256', 'uint256']\n         * [EXACT_BPT_IN_FOR_TOKENS_OUT, bptAmountIn]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n            BPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(poolAssets, minAmountsOut, userData, false);\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            // TODO: this is incorrect and should be altered when/if we intend to support\n            // pools that deal with native ETH\n            payable(address(this)),\n            request\n        );\n\n        // STEP 4 - Convert the balancer pool assets to the vault collateral assets and send to the vault\n\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address poolAsset = address(tokens[i]);\n            // Convert the balancer pool asset to the vault collateral asset\n            address asset = fromPoolAsset(poolAsset);\n            // Get the balancer pool assets withdraw from the pool plus any that were already in this strategy contract\n            uint256 poolAssetAmount = IERC20(poolAsset).balanceOf(\n                address(this)\n            );\n\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            uint256 assetAmount = 0;\n            if (poolAssetAmount > 0) {\n                assetAmount = unwrapPoolAsset(asset, poolAssetAmount);\n            }\n\n            // Transfer the vault collateral assets to the vault\n            if (assetAmount > 0) {\n                IERC20(asset).safeTransfer(vaultAddress, assetAmount);\n                emit Withdrawal(asset, platformAddress, assetAmount);\n            }\n        }\n    }\n\n    /**\n     * @notice Approves the Balancer pool to transfer all supported\n     * assets from this strategy.\n     * Also approve any suppered assets that are wrapped in the Balancer pool\n     * like stETH and frxETH, to be transferred from this strategy to their\n     * respective wrapper contracts. eg wstETH and sfrxETH.\n     *\n     * Is only executable by the Governor.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _approveAsset(assetsMapped[i]);\n        }\n        _approveBase();\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address) internal override {\n        address poolAsset = toPoolAsset(_asset);\n        if (_asset == stETH) {\n            // slither-disable-next-line unused-return\n            IERC20(stETH).approve(wstETH, 1e50);\n        } else if (_asset == frxETH) {\n            // slither-disable-next-line unused-return\n            IERC20(frxETH).approve(sfrxETH, 1e50);\n        }\n        _approveAsset(poolAsset);\n    }\n\n    /**\n     * @dev Approves the Balancer Vault to transfer an asset from\n     * this strategy. The assets could be a Vault collateral asset\n     * like WETH or rETH; or a Balancer pool asset that wraps the vault asset\n     * like wstETH or sfrxETH.\n     */\n    function _approveAsset(address _asset) internal {\n        IERC20 asset = IERC20(_asset);\n        // slither-disable-next-line unused-return\n        asset.approve(address(balancerVault), type(uint256).max);\n    }\n\n    /**\n     * @notice Returns the rate supplied by the Balancer configured rate\n     * provider. Rate is used to normalize the token to common underlying\n     * pool denominator. (ETH for ETH Liquid staking derivatives)\n     *\n     * @param _asset Address of the Balancer pool asset\n     * @return rate of the corresponding asset\n     */\n    function getRateProviderRate(address _asset)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        IMetaStablePool pool = IMetaStablePool(platformAddress);\n        IRateProvider[] memory providers = pool.getRateProviders();\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256 providersLength = providers.length;\n        for (uint256 i = 0; i < providersLength; ++i) {\n            // _assets and corresponding rate providers are all in the same order\n            if (address(tokens[i]) == _asset) {\n                // rate provider doesn't exist, defaults to 1e18\n                if (address(providers[i]) == address(0)) {\n                    return 1e18;\n                }\n                return providers[i].getRate();\n            }\n        }\n\n        // should never happen\n        assert(false);\n    }\n}"
    }
  ]
}