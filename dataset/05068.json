{
  "Title": "[08] Unused field",
  "Content": "\n[`Vesting::UserData`](https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/tokens/Vesting.sol#L47-L52):\n\n```solidity\nFile: tap-token/contracts/tokens/Vesting.sol\n\n47:    struct UserData {\n48:        uint256 amount;\n49:        uint256 claimed;\n50:        uint256 latestClaimTimestamp;\n           // @audit-issue not used \n51:        bool revoked;\n52:    }\n```\n\nThe field `revoked` in `UserData` is not used, consider removing it.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/tokens/Vesting.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract Vesting is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice the vested token\n    IERC20 public token;\n\n    /// @notice returns the start time for vesting\n    uint256 public start;\n\n    /// @notice returns the cliff period\n    uint256 public immutable cliff;\n\n    /// @notice returns total vesting duration\n    uint256 public immutable duration;\n\n    /// @notice returns total available tokens\n    uint256 public seeded;\n\n    /// @notice returns total registered amount\n    uint256 public totalRegisteredAmount;\n\n    /// @notice Used for initial unlock\n    uint256 private __initialUnlockTimeOffset;\n\n    /// @notice user vesting data\n    struct UserData {\n        uint256 amount;\n        uint256 claimed;\n        uint256 latestClaimTimestamp;\n        bool revoked;\n    }\n\n    mapping(address => UserData) public users;\n\n    uint256 private __totalClaimed;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NotStarted();\n    error NothingToClaim();\n    error Initialized();\n    error AddressNotValid();\n    error AmountNotValid();\n    error AlreadyRegistered();\n    error NoTokens();\n    error NotEnough();\n    error BalanceTooLow();\n    error VestingDurationNotValid();\n    error Overflow();\n\n    // *************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when a new user is registered\n    event UserRegistered(address indexed user, uint256 indexed amount);\n    /// @notice event emitted when someone claims available tokens\n    event Claimed(address indexed user, uint256 indexed amount);\n\n    /// @notice creates a new Vesting contract\n    /// @param _cliff cliff period\n    /// @param _duration vesting period\n    constructor(uint256 _cliff, uint256 _duration, address _owner) {\n        if (_duration == 0) revert VestingDurationNotValid();\n\n        cliff = _cliff;\n        duration = _duration;\n\n        _transferOwnership(_owner);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns total claimable\n    function claimable() external view returns (uint256) {\n        return _vested(seeded) - __totalClaimed;\n    }\n\n    /// @notice returns total claimable for user\n    /// @param _user the user address\n    function claimable(address _user) public view returns (uint256) {\n        return _vested(users[_user].amount) - users[_user].claimed;\n    }\n\n    /// @notice returns total vested amount\n    function vested() external view returns (uint256) {\n        return _vested(seeded);\n    }\n\n    /// @notice returns total vested amount for user\n    /// @param _user the user address\n    function vested(address _user) external view returns (uint256) {\n        return _vested(users[_user].amount);\n    }\n\n    /// @notice returns total claimed\n    function totalClaimed() external view returns (uint256) {\n        return __totalClaimed;\n    }\n\n    /// @notice Compute the time needed to unlock an amount of tokens, given a total amount.\n    /// @param _start The start time\n    /// @param _totalAmount The total amount to be vested\n    /// @param _amount The amount to be unlocked\n    /// @param _duration The vesting duration\n    function computeTimeFromAmount(uint256 _start, uint256 _totalAmount, uint256 _amount, uint256 _duration)\n        external\n        pure\n        returns (uint256)\n    {\n        return _computeTimeFromAmount(_start, _totalAmount, _amount, _duration);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice claim available tokens\n    /// @dev claim works for msg.sender\n    function claim() external nonReentrant {\n        if (start == 0) revert NotStarted();\n        uint256 _claimable = claimable(msg.sender);\n        if (_claimable == 0) revert NothingToClaim();\n\n        __totalClaimed += _claimable;\n        users[msg.sender].claimed += _claimable;\n        users[msg.sender].latestClaimTimestamp = block.timestamp;\n\n        token.safeTransfer(msg.sender, _claimable);\n        emit Claimed(msg.sender, _claimable);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice adds a new user\n    /// @dev should be called before init\n    /// @param _user the user address\n    /// @param _amount user weight\n    function registerUser(address _user, uint256 _amount) external onlyOwner {\n        if (start > 0) revert Initialized();\n        if (_user == address(0)) revert AddressNotValid();\n        if (_amount == 0) revert AmountNotValid();\n        if (users[_user].amount > 0) revert AlreadyRegistered();\n\n        UserData memory data;\n        data.amount = _amount;\n        users[_user] = data;\n\n        totalRegisteredAmount += _amount;\n\n        emit UserRegistered(_user, _amount);\n    }\n\n    /// @notice adds multiple users\n    /// @dev should be called before init\n    /// @param _users the user addresses\n    /// @param _amounts user weights\n    function registerUsers(address[] calldata _users, uint256[] calldata _amounts) external onlyOwner {\n        if (start > 0) revert Initialized();\n        if (_users.length != _amounts.length) revert(\"Lengths not equal\");\n\n        // Gas ops\n        uint256 _totalAmount = totalRegisteredAmount;\n        uint256 _cachedTotalAmount = _totalAmount;\n\n        UserData memory data;\n\n        uint256 len = _users.length;\n        for (uint256 i; i < len;) {\n            // Checks\n            if (_users[i] == address(0)) revert AddressNotValid();\n            if (_amounts[i] == 0) revert AmountNotValid();\n            if (users[_users[i]].amount > 0) revert AlreadyRegistered();\n\n            // Effects\n            data.amount = _amounts[i];\n            users[_users[i]] = data;\n            emit UserRegistered(_users[i], _amounts[i]);\n\n            _totalAmount += _amounts[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Record new totals\n        if (_cachedTotalAmount > _totalAmount) revert Overflow();\n        totalRegisteredAmount = _totalAmount;\n    }\n\n    /// @notice init the contract with total amount.\n    /// @dev If initial unlock is used, it'll compute the time needed to unlock it\n    /// and subtract it from the start time, so the user can claim it immediately.\n    /// @param _seededAmount total vested amount, cannot be 0.\n    /// @param _initialUnlock initial unlock percentage, in BPS.\n    function init(IERC20 _token, uint256 _seededAmount, uint256 _initialUnlock) external onlyOwner {\n        if (start > 0) revert Initialized();\n        if (_seededAmount == 0) revert NoTokens();\n        if (totalRegisteredAmount > _seededAmount) revert NotEnough();\n\n        token = _token;\n        uint256 availableToken = _token.balanceOf(address(this));\n        if (availableToken < _seededAmount) revert BalanceTooLow();\n\n        seeded = _seededAmount;\n        start = block.timestamp;\n\n        if (_initialUnlock > 10_000) revert AmountNotValid();\n        if (_initialUnlock > 0) {\n            uint256 initialUnlockAmount = (_seededAmount * _initialUnlock) / 10_000;\n\n            __initialUnlockTimeOffset =\n                _computeTimeFromAmount(block.timestamp, _seededAmount, initialUnlockAmount, duration);\n        }\n    }\n\n    /// @notice Compute the time needed to unlock an amount of tokens, given a total amount.\n    /// @param _start The start time\n    /// @param _totalAmount The total amount to be vested\n    /// @param _amount The amount to be unlocked\n    /// @param _duration The vesting duration\n    function _computeTimeFromAmount(uint256 _start, uint256 _totalAmount, uint256 _amount, uint256 _duration)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _start - (_start - ((_amount * _duration) / _totalAmount));\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n\n    /// @notice Returns amount of vested tokens up to the current time\n    /// @param _totalAmount The total amount to be vested\n    function _vested(uint256 _totalAmount) internal view returns (uint256) {\n        uint256 _cliff = cliff;\n        uint256 _start = start;\n        uint256 _duration = duration;\n\n        if (_start == 0) return 0; // Not started\n\n        if (_cliff > 0) {\n            _start = _start + _cliff; // Apply cliff offset\n            if (block.timestamp < _start) return 0; // Cliff not reached\n        }\n\n        if (block.timestamp >= _start + _duration) return _totalAmount; // Fully vested\n\n        _start = _start - __initialUnlockTimeOffset; // Offset initial unlock so it's claimable immediately\n        return (_totalAmount * (block.timestamp - _start)) / _duration; // Partially vested\n    }\n}"
    }
  ]
}