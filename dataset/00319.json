{
  "Title": "M-1: Incorrect game type can be proven and finalized due to unsafe cast",
  "Content": "# Issue M-1: Incorrect game type can be proven and finalized due to unsafe cast \n\nSource: https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/84 \n\n## Found by \nStiglitz, guhu95, lemonmon, obront\n## Summary\n\nThe `gameProxy.gameType().raw()` conversions used by OptimismPortal2 in the proving and finalization steps incorrectly casts the `gameType` to a `uint8` instead of a `uint32`, which causes mismatched game types to be considered equivalent. In the event that a game is exploitable, this can be used to skirt around the off-chain monitoring to finalize an invalid withdrawal.\n\n## Vulnerability Detail\n\nEach game can be queried for its `gameType`, which is compared to the current `respectedGameType` in the Portal to confirm the game is valid.\n\nGameType is represented as a `uint32`, allowing numbers up to `2 ** 32 - 1`.\n```solidity\ntype GameType is uint32;\n```\n\nHowever, when converting the GameType to an integer type in order to perform comparisons in the proving and finalization process, we unsafely downcase to a `uint8`:\n```solidity\nfunction raw(GameType _gametype) internal pure returns (uint8 gametype_) {\n    assembly {\n        gametype_ := _gametype\n    }\n}\n```\n\nThis means that for any `oldGameType % 256 == X`, any `newGameType % 256 == X` will be considered the same game type.\n\n**This has the potential to shortcut the safeguards to allow malicious games to be finalized.**\n\nAs is explained in the comments, only games of the current `respectedGameType` will be watched by the off-chain challenger. This is why we do not allow games that pre-date the last update to be finalized:\n\n> // The game must have been created after `respectedGameTypeUpdatedAt`. This is to prevent users from creating\n> // invalid disputes against a deployed game type while the off-chain challenge agents are not watching.\n\nHowever, the watcher will not be watching games where `gameType % 256 == respectedGameType % 256`.\n\nLet's imagine a situation where game type `0` has been deemed unsafe. It is well known that a user can force a `DEFENDER_WINS` state, even when it is not correct.\n\nAt a future date, when the current game type is `256`, a user creates a game with `gameType = 0`. It is not watched by the off chain challenger. This game can be used to prove an invalid state, and then finalize their withdrawal, all while not being watched by the off chain monitoring system.\n\n## Proof of Concept\n\nThe following proof of concept can be added to  its own file in `test/L1` to demonstrate the vulnerability:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport \"./OptimismPortal2.t.sol\";\n\ncontract UnsafeDowncastTest is CommonTest {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes[] _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    function setUp() public override {\n        super.enableFaultProofs();\n        super.setUp();\n\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) =\n            ffi.getProveWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            messagePasserStorageRoot: _storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(optimismPortal2), 0xFFFFFFFF);\n    }\n\n    function testWrongGameTypeSucceeds() external {\n        // we start with respected gameType == 256\n        vm.prank(superchainConfig.guardian());\n        optimismPortal2.setRespectedGameType(GameType.wrap(256));\n\n        // create a game with gameType == 0, which we know is exploitable\n        FaultDisputeGame game = FaultDisputeGame(\n            payable(\n                address(\n                    disputeGameFactory.create(\n                        GameType.wrap(0), Claim.wrap(_outputRoot), abi.encode(uint(0xFF))\n                    )\n                )\n            )\n        );\n\n        // proving works, even though gameType is incorrect\n        vm.warp(block.timestamp + 1);\n        optimismPortal2.proveWithdrawalTransaction({\n            _tx: _defaultTx,\n            _disputeGameIndex: disputeGameFactory.gameCount() - 1,\n            _outputRootProof: _outputRootProof,\n            _withdrawalProof: _withdrawalProof\n        });\n\n        // warp beyond the game duration and resolve the game\n        vm.warp(block.timestamp + 4 days);\n        game.resolveClaim(0);\n        game.resolve();\n\n        // warp another 4 days so withdrawal can be finalized\n        vm.warp(block.timestamp + 4 days);\n\n        // finalizing works, even though gameType is incorrect\n        uint beforeBal = bob.balance;\n        optimismPortal2.finalizeWithdrawalTransaction(_defaultTx);\n        assertEq(bob.balance, beforeBal + 100);\n    }\n}\n```\n\n## Impact\n\nThe user is able to prove and finalize their withdrawal against a game that is not being watched and is known to be invalid. This would allow them to prove arbitrary withdrawals and steal all funds in the Portal.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/lib/LibUDT.sol#L117-L126\n\nhttps://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/L1/OptimismPortal2.sol#L260-L261\n\nhttps://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/L1/OptimismPortal2.sol#L497-L500\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n- function raw(GameType _gametype) internal pure returns (uint8 gametype_) {\n+ function raw(GameType _gametype) internal pure returns (uint32 gametype_) {\n      assembly {\n          gametype_ := _gametype\n      }\n}\n```\n\n\n\n## Discussion\n\n**smartcontracts**\n\nWe see this as a valid medium severity issue\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/ethereum-optimism/optimism/pull/10152\n\n\n**nevillehuang**\n\nBased on scope highlighted below (issue exists and affects portal contract, which is a non-game contract) and [sherlock scoping rules](https://docs.sherlock.xyz/audits/judging/judging#iii.-sherlocks-standards)\n\nhttps://docs.google.com/document/d/1xjvPwAzD2Zxtx8-P6UE69TuoBwtZPbpwf5zBHAvBJBw/edit\n\n> 2. In case the vulnerability exists in a library and an in-scope contract uses it and is affected by this bug this is a valid issue.\n\nI believe this is a medium severity issue given the following constraints:\n\n- At least 256 games must exist in a single game type\n- This issue doesn't bypass the airgap/Delayed WETH safety net, so can still be monitored off-chain to trigger a fallback mechanism to pause the system and update the respected game type if a game resolves incorrectly. \n\n**zobront**\n\nEscalate\n\nI believe this issue should be judged as High Severity.\n\nThe purpose of this contest was to examine the safeguards that could lead to the catastrophic consequences of having an invalid fault proof accepted. We were given the constraints of assuming the game is buggy. This means that (a) none of those issues were accepted, but also that (b) issues that would arise IF the system were very buggy are valid.\n\nThis is the only issue in the contest that poses this extreme risk.\n\nWhile it has the condition that 255 other games are created, based on the assumption that the game is buggy, it doesn't seem out of the question that a large number of additional game types would need to be deployed. This is the only requirement for this issue to be exploitable (counter to what the judge mentioned above), because Optimism's off chain watcher only watches the currently active game).\n\nMore importantly, in the event that this happens, the consequences are catastrophic. A game that is (a) not being watched and (b) known to be buggy, is accepted as valid (both in the proving step of withdrawal and the finalization step of withdrawal). \n\nThis leads to a very real, very extreme risk of a fraudulent withdrawal getting through the system.\n\nWith the constraints of the contest in mind (assuming the game is buggy), as well as the potential billions of dollars of lost funds that could occur, I believe this is the exact kind of issue that was crucial to find, and clearly fits the criteria for High Severity.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I believe this issue should be judged as High Severity.\n> \n> The purpose of this contest was to examine the safeguards that could lead to the catastrophic consequences of having an invalid fault proof accepted. We were given the constraints of assuming the game is buggy. This means that (a) none of those issues were accepted, but also that (b) issues that would arise IF the system were very buggy are valid.\n> \n> This is the only issue in the contest that poses this extreme risk.\n> \n> While it has the condition that 255 other games are created, based on the assumption that the game is buggy, it doesn't seem out of the question that a large number of additional game types would need to be deployed. This is the only requirement for this issue to be exploitable (counter to what the judge mentioned above), because Optimism's off chain watcher only watches the currently active game).\n> \n> More importantly, in the event that this happens, the consequences are catastrophic. A game that is (a) not being watched and (b) known to be buggy, is accepted as valid (both in the proving step of withdrawal and the finalization step of withdrawal). \n> \n> This leads to a very real, very extreme risk of a fraudulent withdrawal getting through the system.\n> \n> With the constraints of the contest in mind (assuming the game is buggy), as well as the potential billions of dollars of lost funds that could occur, I believe this is the exact kind of issue that was crucial to find, and clearly fits the criteria for High Severity.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**guhu95**\n\n**Three additional points to support the escalation in favor of high:**\n1. There isn't a constraint of 256 prior games due to use of non-sequential game types.\n2. DoS impact that is caused by the mitigation actions qualifies for high severity.\n3. Off-chain monitoring for this issue is not plausible without prior knowledge of the issue.\n\n#### 1. Games types are not sequential\n\n > \"- At least 256 games must exist in a single game type\"\n \n > \"While it has the condition that 255 other games are created\"\n \n This appears to be neither a constraint nor a condition:\n \n1. `setImplementation` [does not require sequential](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol#L189-L192) game type values.\n2. The 3 [already defined `GameTypes`](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/libraries/DisputeTypes.sol#L104-L111) are not sequential: 0, 1, and 255, and all are [configured in the same factory during deployment](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/scripts/Deploy.s.sol#L327-L329). \n3. The further use of non-sequential game types is highly likely due to \"namespacing\" via higher order bits, as is already done with predeploy addresses (`0x42...01`), and with their implementation addresses (`0xc0de...01`) etc. This kind of namespacing will result in many exploitable collisions.\n\n#### 2. The DoS impact of mitigation qualifies as high\n\n> ...to pause the system and update the respected game type if a game resolves incorrectly.\n\nSwitching the respected game type pauses the bridge for a significant amount of time qualifying as a DoS issue for the valid withdrawals delayed by the mitigation.\n\nThe DoS impact for a valid withdrawal that would otherwise be finalizable is well over one week:\n1. Off-chain monitoring needs to detect the suspicious `WithdrawalProven` that was not expected. The issue needs to be validated to require pausing (SLA of 24 hours).\n3. A new implementation of the dispute game, with a new [game type value, and the new anchor registry (which are immutable)](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L46-L52) will need to be deployed.\n4. The factory will need to be updated [by the owner (SLA of 72 hours) to include the new implementation](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol#L189).\n5. The respected game type for the portal would [need to be updated](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/L1/OptimismPortal2.sol#L448-L449) by guardian (SLA of 24 hours).\n6. New dispute games will need to be created by proposers for the withdrawals backlog caused by the delays.\n7. Only after all these steps the re-proving for previously valid withdrawals for previously valid games can be restarted, and would require waiting at least 7 days from the point of unpausing.\n\nBecause this blocks all cross-chain interactions on the bridge for a prolonged period of time, and delays message passing, it blocks all cross-chain protocols operating across this bridge (including their time-sensitive operations) and not only locks up funds.\n\n#### 3. Off-chain monitoring is conditional on knowing of this issue\n\n> - This issue doesn't bypass the airgap/Delayed WETH safety net, so can still be monitored off-chain to trigger a fallback mechanism \n\nWhile it is theoretically possible to monitor for this off-chain, it is unlikely to result in this action without knowledge of this vulnerability. This is because a creation of new instance of an old game, that is no longer \"respected\" by the portal, should not raise cause for concern (if the issue is unknown at that point).\n\n\n**trust1995**\n\nEscalate\n\nFirstly, the finding is brilliant and extremely well noticed by the participants. In my mind, the finding falls under Low severity, with the reasoning below:\n\n- As far as devs are concerned, there are a [maximum ](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/f216b0d3ad08c1a0ead557ea74691aaefd5fd489/optimism/packages/contracts-bedrock/src/libraries/DisputeTypes.sol#L48) of 256 game types. The bug is an unsynchronized view between the underlying structure and the definition of GameType as uint32. All evidence points to the fact Optimism _did not_ plan to make use of over 256 game types.\n- From a practical standpoint, even if over 256 game types were planned to be supported, to get to such a high amount of different game types is extremely unlikely (as of now, three are planned). The odds of the architecture not getting refactored, closing the issue, by the time 256 game types are needed, I estimate to be under a thousandth of a percent.\n- For there to be an impact, the following must hold:\n- A new, **vulnerable** game type must be defined (highly hypothetical) after 256 game types.\n- It's encoding suffix must line up with the `respectedGameId` set by the admin\n- All honest challengers must not look at the vulnerable game type, despite the fact that challenging it is +EV (they are guaranteed to pick up the attacker's bond if the claim is invalid)\n- The airgap is **not** bypassed - At any the guardian is able to blacklist the game and make it unfinalizable. This reason caused for dozens of issues in this contest to be invalidated, and not applying it for this bug is inconsistent and shows unsound logic.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Firstly, the finding is brilliant and extremely well noticed by the participants. In my mind, the finding falls under Low severity, with the reasoning below:\n> \n> - As far as devs are concerned, there are a [maximum ](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/f216b0d3ad08c1a0ead557ea74691aaefd5fd489/optimism/packages/contracts-bedrock/src/libraries/DisputeTypes.sol#L48) of 256 game types. The bug is an unsynchronized view between the underlying structure and the definition of GameType as uint32. All evidence points to the fact Optimism _did not_ plan to make use of over 256 game types.\n> - From a practical standpoint, even if over 256 game types were planned to be supported, to get to such a high amount of different game types is extremely unlikely (as of now, three are planned). The odds of the architecture not getting refactored, closing the issue, by the time 256 game types are needed, I estimate to be under a thousandth of a percent.\n> - For there to be an impact, the following must hold:\n> - A new, **vulnerable** game type must be defined (highly hypothetical) after 256 game types.\n> - It's encoding suffix must line up with the `respectedGameId` set by the admin\n> - All honest challengers must not look at the vulnerable game type, despite the fact that challenging it is +EV (they are guaranteed to pick up the attacker's bond if the claim is invalid)\n> - The airgap is **not** bypassed - At any the guardian is able to blacklist the game and make it unfinalizable. This reason caused for dozens of issues in this contest to be invalidated, and not applying it for this bug is inconsistent and shows unsound logic.\n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**guhu95**\n\n@trust1995 the main argument you present (sequential game types constraint on likelihood) is refuted by the evidence in my message above yours (see _\"1. Games types are not sequential\"_)\n\nWould you mind specifying what part of the reasoning or evidence you agree and disagree with?\n\nThere are more details and links above, but for your convenience these are: **1.** Setter doesn't require sequential numbers. **2.** The three existing games are non-sequential (1, 2, **255**) and are all added to the factory on deployment. **3.** Namespacing via higher bits is already prevalent in the codebase and makes this a highly probable scenario.\n\n**trust1995**\n\nThe game types defined below follow a common pattern where the upper value is set as a placeholder for a safe non-production value. It's clearly not meant to assume they do skipping as a policy, and any experienced developer can confirm the intention is to keep running from 0,1, up to 255.\n```\nlibrary GameTypes {\n    /// @dev A dispute game type the uses the cannon vm.\n    GameType internal constant CANNON = GameType.wrap(0);\n    /// @dev A permissioned dispute game type the uses the cannon vm.\n    GameType internal constant PERMISSIONED_CANNON = GameType.wrap(1);\n    /// @notice A dispute game type that uses an alphabet vm.\n    ///         Not intended for production use.\n    GameType internal constant ALPHABET = GameType.wrap(255);\n}\n```\n\nThis is further confirmed by their docs which outline the intended structure of the GameID:\n```\n/// @notice A `GameId` represents a packed 1 byte game ID, an 11 byte timestamp, and a 20 byte address.\n/// @dev The packed layout of this type is as follows:\n/// ┌───────────┬───────────┐\n/// │   Bits    │   Value   │\n/// ├───────────┼───────────┤\n/// │ [0, 8)    │ Game Type │\n/// │ [8, 96)   │ Timestamp │\n/// │ [96, 256) │ Address   │\n/// └───────────┴───────────┘\n```\n\nIt's very hard to look at these points of evidence and think there is any intention to have more than 256 game types to be played. I realize the issue will be heavily debated since a lot of money is on the line, so throwing this quote which summarizes escalations in a nutshell:\n> “It is difficult to get a man to understand something, when his salary depends on his not understanding it.” - Upton Sinclair\n\n**guhu95**\n\n> the fact Optimism _did not_ plan to make use of over 256 game types\n\n> any intention to have more than 256 game types to be played\n\n> the intention is to keep running from 0,1, up to 255\n\nThe project clearly decided (before this contest) that game types values higher than `256` are needed. This is easy to see in these facts:\n1. They've previously (in Jan) [refactored `GameType` from `uint8` to `uint32`](https://github.com/ethereum-optimism/optimism/pull/9220/commits/cde603aa4e458a84cb7b367c5f2176f77ea9dd80), leaving no room for doubt on this aspect.\n2. They've [fixed the vulnerability as recommended](https://github.com/ethereum-optimism/optimism/pull/10152/commits/eba00dbb382f4323305401eaa99630f03f07dd12) instead of switching back to `uint8`.\n3. They've accepted the finding as valid.\n\nThe team's intention (and explicit previous switch) to use `uint32` over `uint8` clearly shows the likelihood of using game types with values > 255. This removes this incorrectly considered constraint.\n\nThis finding justifies **high severity** for both the unconditionally broken key safety mechanism of `respectedGameType` allowing forged withdrawals, and the prolonged bridge DoS which would result from its mitigation.\n\n**MightyFox3**\n\nIssues predicted to arise from future integrations or updates, which aren't documented in the [current documentation](https://docs.sherlock.xyz/audits/judging/judging) or README, are not considered valid. For instance, although the audit currently includes only three game types, even if the number were to exceed 255 in future implementations, such scenarios are categorized under future integrations.\n\n> Future issues: Issues that result out of a future integration/implementation that was not mentioned in the docs/README or because of a future change in the code (as a fix to another issue) are not valid issues.\n\nReferencing the [Optimism official dispute game documents](https://specs.optimism.io/experimental/fault-proof/stage-one/dispute-game-interface.html), the game type is clearly defined as a uint8. This definition does not suggest any future expansion beyond 255 game types, thereby rendering any inconsistencies between the code and documents as minor and of low severity.\n\n**bemic**\n\nThe previous comment by @guhu95 seems to be a sufficient counterargument. Nevertheless, the fact that a 2-day-old github profile is part of the discussion is interesting.\n\n**trust1995**\n\n> The previous comment by @guhu95 seems to be a sufficient counterargument. Nevertheless, the fact that a 2-day-old github profile is part of the discussion is interesting.\n\nYou really will do anything to get the last answer in a thread, even with 0 content to add except cringeworthy ad-hominem.\n\n**bemic**\n\nPardon, let me clarify.\n\nI do not find the argument \"_future integration/implementation/code change_\" to be related. The problem stems from the current state of the codebase, where no changes are necessary.\n\nAs mentioned, few months ago the team made a very specific change to the code using a PR called \"Bump GameType size to 32 bits\", where they changed the type from `uint8` to `uint32`. This clearly indicates that a number > 255 is expected.\n\nIt is important to note again, that this does not necessarily mean more than 255 games. Larger type can be used to encode different game types more categorically.\n\nYou correctly pointed out that the documentation contains `uint8`. However, the documentation cannot be taken as a source of truth in cases like this one. Otherwise, projects can describe the correct and expected behavior in their documentation and use the argument \"_inconsistencies between code and documentation_\" as a reason to mark every problem as Low.\n\n\n**guhu95**\n\nRegarding:\n\n> Issues predicted to arise from future integrations or updates, which aren't documented in the [current documentation](https://docs.sherlock.xyz/audits/judging/judging) or README, are not considered valid.\n\nFirst, the [game type is an argument](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L107) of the both the game [and the factory](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol#L189), so can have any value depending on usage - so all `uint32`'s possible **4294967296** values are fully in scope, and not only the specific 3 values. It's `uint32`, not [an enum](https://docs.soliditylang.org/en/v0.8.25/structure-of-a-contract.html#enum-types).\n\nSecond, even if it was an enum, in this case the README explicitly allows \"future integrations issues\" for `OptimismPortal2`:\n\n> **Should potential issues, like broken assumptions about function behavior, be reported if they could pose risks in future integrations, even if they might not be an issue in the context of the scope? If yes, can you elaborate on properties/invariants that should hold?**  \n> Yes, but this should be limited to the OptimismPortal2 contract. Contracts other than the OptimismPortal2 contract are not intended for external integrations and risks for future integrations into these contracts will likely not be considered valid.\n\n\n**trust1995**\n\n> You correctly pointed out that the documentation contains `uint8`. However, the documentation cannot be taken as a source of truth in cases like this one. Otherwise, projects can describe the correct and expected behavior in their documentation and use the argument \"_inconsistencies between code and documentation_\" as a reason to mark every problem as Low.\n\nWe've seen two strong points of evidence for source of truth - the in-code documentation of GameType and the docs page. On the other hand we see a commit bumping GameType to uint32, without adding any game types. It seems speculative to infer they plan to use larger values, contest rules state we need to give project the assumption of competence in cases like these. For impact to occur, the following has to occur:\n- Optimism must intend to creative game types of uint8\n- Future audits of the codebase with the new game type **must miss** a bug that is **directly in scope**\n- The issue must be missed by the extremely detailed test suite ran by Optimism\n- The mismatched game type (the phantom game) must not be tracked, or must have a **second unrelated vulnerability** allowing to use it for proofs\n- Finally the air-gap protections must be bypassed, a fact which reduced to Low many other submissions.\n\n> First, the [game type is an argument](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L107) of the both the game [and the factory](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol#L189), so can have any value depending on usage - so all `uint32`'s possible **4294967296** values are fully in scope, and not only the specific 3 values. It's `uint32`, not [an enum](https://docs.soliditylang.org/en/v0.8.25/structure-of-a-contract.html#enum-types).\n\nNope, not anything that can be misconfigured by an admin can be viewed as in-scope. That's an indefensible statement which, if correct, would inflate any contest by dozens of useless findings.\n\n\n\n\n\n**nevillehuang**\n\n1. It is not impossible to ever reach over 255 gametypes, given any possible incorrect resolution logic will also force a game type upgrade, however I believe the likelihood is low. Since the root cause is in a non-game contract, based on agreed upon scope and low likelihood,  I believe medium severity is appropriate, as no safety mechanism is bypassed. \n\n<br/>\n\n2. I don't think we can assume the behavior of off-chain mechanisms here that act as a safety mechanism, since it is explicitly mentioned as out of scope and that such scenarios will always be monitored comprehensively.\n\n> Off-chain mechanisms exist as part of the system but are not in scope for this competition. Assume that comprehensive monitoring exists that will detect most obviously detectable malicious activity.\n\n**zobront**\n\n@nevillehuang Making sure you've seen this comment from OptimismPortal2:\n\n> // The game must have been created after `respectedGameTypeUpdatedAt`. This is to prevent users from creating\n> // invalid disputes against a deployed game type while the off-chain challenge agents are not watching.\n\nYou should check with the Optimism team about this if you're unclear. This situation is explicitly not being watched, and therefore is the exact kind of bypass this whole contest was designed to detect. \n\nIf they agree that this bypasses the safety mechanism, I can't see how this could be anything except High Severity.\n\n**guhu95**\n\n@nevillehuang in addition to the above consideration of off-chain watchers, please also consider the DoS impact of mitigation described above in https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/84#issuecomment-2073880067. \n\nI am no expert on Sherlock rules, but to me the DoS impact appears to also qualify for high severity.\n\n**MightyFox3**\n\n> 1. It is not impossible to ever reach over 255 gametypes, given any possible incorrect resolution logic will also force a game type upgrade, however I believe the likelihood is low. Since the root cause is in a non-game contract, based on agreed upon scope and low likelihood,  I believe medium severity is appropriate, as no safety mechanism is bypassed.\n> \n> \n> 2. I don't think we can assume the behavior of off-chain mechanisms here that act as a safety mechanism, since it is explicitly mentioned as out of scope and that such scenarios will always be monitored comprehensively.\n> \n> > Off-chain mechanisms exist as part of the system but are not in scope for this competition. Assume that comprehensive monitoring exists that will detect most obviously detectable malicious activity.\n\nOnly three games are currently implemented, even though there are over 255 game types planned for the future. This does not apply to the existing codebase. Thank you.\n\n**guhu95**\n\n> 1. It is not impossible to ever reach over 255 gametypes, given any possible incorrect resolution logic will also force a game type upgrade, however **I believe the likelihood is low**. Since the root cause is in a non-game contract, based on agreed upon scope and **low likelihood**\n\n@nevillehuang since it also might have been lost in the long discussion, I'd like to point out again the fact the Optimism [explicitly decided to switch from `uint8` to `uint32`](https://github.com/ethereum-optimism/optimism/pull/9220/commits/cde603aa4e458a84cb7b367c5f2176f77ea9dd80). Would you not agree that this directly establishes the likelihood as likely? Why would they switch from `uint8` to `uint32` if they didn't consider it necessarily needed and therefore likely? \n\nFurthermore, as any value above max `uint8` may trigger the bug, any \"next\" game can cause this, without having to go through 255 game types before that.\n\nPlease reconsider your view of the likelihood of a game type with value > 255, especially given Optimism's explicit switch away from `uint8`. \n\n------\n\nTo sum up, I see three independent arguments for high being presented:\n1. Possible bypass of safeguards as documented by the team, and pointed out in https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/84#issuecomment-2081733431\n2. The likelihood argument discussed throughout the issue, but mostly summed up in https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/84#issuecomment-2078702993 (and in the current comment)\n3. Severe and prolonged DoS due to mitigation as presented in https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/84#issuecomment-2073880067\n\n**nevillehuang**\n\n@guhu95 \n\nThis depends on **255 distinct unique gametype**, NOT 255 FDG games of the same type. My understanding is that to reach this point, an additional 250+ game types must have been introduced from new game types or game type switches (s",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/205",
  "Code": [
    {
      "filename": "optimism/packages/contracts-bedrock/src/dispute/lib/LibUDT.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"src/libraries/DisputeTypes.sol\";\n\n/// @title LibClock\n/// @notice This library contains helper functions for working with the `Clock` type.\nlibrary LibClock {\n    /// @notice Packs a `Duration` and `Timestamp` into a `Clock` type.\n    /// @param _duration The `Duration` to pack into the `Clock` type.\n    /// @param _timestamp The `Timestamp` to pack into the `Clock` type.\n    /// @return clock_ The `Clock` containing the `_duration` and `_timestamp`.\n    function wrap(Duration _duration, Timestamp _timestamp) internal pure returns (Clock clock_) {\n        assembly {\n            clock_ := or(shl(0x40, _duration), _timestamp)\n        }\n    }\n\n    /// @notice Pull the `Duration` out of a `Clock` type.\n    /// @param _clock The `Clock` type to pull the `Duration` out of.\n    /// @return duration_ The `Duration` pulled out of `_clock`.\n    function duration(Clock _clock) internal pure returns (Duration duration_) {\n        // Shift the high-order 64 bits into the low-order 64 bits, leaving only the `duration`.\n        assembly {\n            duration_ := shr(0x40, _clock)\n        }\n    }\n\n    /// @notice Pull the `Timestamp` out of a `Clock` type.\n    /// @param _clock The `Clock` type to pull the `Timestamp` out of.\n    /// @return timestamp_ The `Timestamp` pulled out of `_clock`.\n    function timestamp(Clock _clock) internal pure returns (Timestamp timestamp_) {\n        // Clean the high-order 192 bits by shifting the clock left and then right again, leaving\n        // only the `timestamp`.\n        assembly {\n            timestamp_ := shr(0xC0, shl(0xC0, _clock))\n        }\n    }\n\n    /// @notice Get the value of a `Clock` type in the form of the underlying uint128.\n    /// @param _clock The `Clock` type to get the value of.\n    /// @return clock_ The value of the `Clock` type as a uint128 type.\n    function raw(Clock _clock) internal pure returns (uint128 clock_) {\n        assembly {\n            clock_ := _clock\n        }\n    }\n}\n\n/// @title LibClaim\n/// @notice This library contains helper functions for working with the `Claim` type.\nlibrary LibClaim {\n    /// @notice Get the value of a `Claim` type in the form of the underlying bytes32.\n    /// @param _claim The `Claim` type to get the value of.\n    /// @return claim_ The value of the `Claim` type as a bytes32 type.\n    function raw(Claim _claim) internal pure returns (bytes32 claim_) {\n        assembly {\n            claim_ := _claim\n        }\n    }\n}\n\n/// @title LibDuration\n/// @notice This library contains helper functions for working with the `Duration` type.\nlibrary LibDuration {\n    /// @notice Get the value of a `Duration` type in the form of the underlying uint64.\n    /// @param _duration The `Duration` type to get the value of.\n    /// @return duration_ The value of the `Duration` type as a uint64 type.\n    function raw(Duration _duration) internal pure returns (uint64 duration_) {\n        assembly {\n            duration_ := _duration\n        }\n    }\n}\n\n/// @title LibHash\n/// @notice This library contains helper functions for working with the `Hash` type.\nlibrary LibHash {\n    /// @notice Get the value of a `Hash` type in the form of the underlying bytes32.\n    /// @param _hash The `Hash` type to get the value of.\n    /// @return hash_ The value of the `Hash` type as a bytes32 type.\n    function raw(Hash _hash) internal pure returns (bytes32 hash_) {\n        assembly {\n            hash_ := _hash\n        }\n    }\n}\n\n/// @title LibTimestamp\n/// @notice This library contains helper functions for working with the `Timestamp` type.\nlibrary LibTimestamp {\n    /// @notice Get the value of a `Timestamp` type in the form of the underlying uint64.\n    /// @param _timestamp The `Timestamp` type to get the value of.\n    /// @return timestamp_ The value of the `Timestamp` type as a uint64 type.\n    function raw(Timestamp _timestamp) internal pure returns (uint64 timestamp_) {\n        assembly {\n            timestamp_ := _timestamp\n        }\n    }\n}\n\n/// @title LibVMStatus\n/// @notice This library contains helper functions for working with the `VMStatus` type.\nlibrary LibVMStatus {\n    /// @notice Get the value of a `VMStatus` type in the form of the underlying uint8.\n    /// @param _vmstatus The `VMStatus` type to get the value of.\n    /// @return vmstatus_ The value of the `VMStatus` type as a uint8 type.\n    function raw(VMStatus _vmstatus) internal pure returns (uint8 vmstatus_) {\n        assembly {\n            vmstatus_ := _vmstatus\n        }\n    }\n}\n\n/// @title LibGameType\n/// @notice This library contains helper functions for working with the `GameType` type.\nlibrary LibGameType {\n    /// @notice Get the value of a `GameType` type in the form of the underlying uint8.\n    /// @param _gametype The `GameType` type to get the value of.\n    /// @return gametype_ The value of the `GameType` type as a uint8 type.\n    function raw(GameType _gametype) internal pure returns (uint8 gametype_) {\n        assembly {\n            gametype_ := _gametype\n        }\n    }\n}"
    },
    {
      "filename": "optimism/packages/contracts-bedrock/src/L1/OptimismPortal2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"src/libraries/SafeCall.sol\";\nimport { DisputeGameFactory, IDisputeGame } from \"src/dispute/DisputeGameFactory.sol\";\nimport { SystemConfig } from \"src/L1/SystemConfig.sol\";\nimport { SuperchainConfig } from \"src/L1/SuperchainConfig.sol\";\nimport { Constants } from \"src/libraries/Constants.sol\";\nimport { Types } from \"src/libraries/Types.sol\";\nimport { Hashing } from \"src/libraries/Hashing.sol\";\nimport { SecureMerkleTrie } from \"src/libraries/trie/SecureMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"src/vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"src/L1/ResourceMetering.sol\";\nimport { ISemver } from \"src/universal/ISemver.sol\";\nimport { Constants } from \"src/libraries/Constants.sol\";\n\nimport \"src/libraries/DisputeTypes.sol\";\n\n/// @custom:proxied\n/// @title OptimismPortal2\n/// @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n///         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\n///         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\ncontract OptimismPortal2 is Initializable, ResourceMetering, ISemver {\n    /// @notice Represents a proven withdrawal.\n    /// @custom:field disputeGameProxy The address of the dispute game proxy that the withdrawal was proven against.\n    /// @custom:field timestamp        Timestamp at whcih the withdrawal was proven.\n    struct ProvenWithdrawal {\n        IDisputeGame disputeGameProxy;\n        uint64 timestamp;\n    }\n\n    /// @notice The delay between when a withdrawal transaction is proven and when it may be finalized.\n    uint256 internal immutable PROOF_MATURITY_DELAY_SECONDS;\n\n    /// @notice The delay between when a dispute game is resolved and when a withdrawal proven against it may be\n    ///         finalized.\n    uint256 internal immutable DISPUTE_GAME_FINALITY_DELAY_SECONDS;\n\n    /// @notice Version of the deposit event.\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /// @notice The L2 gas limit set when eth is deposited using the receive() function.\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /// @notice Address of the L2 account which initiated a withdrawal in this transaction.\n    ///         If the of this variable is the default L2 sender address, then we are NOT inside of\n    ///         a call to finalizeWithdrawalTransaction.\n    address public l2Sender;\n\n    /// @notice A list of withdrawal hashes which have been successfully finalized.\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /// @custom:legacy\n    /// @custom:spacer provenWithdrawals\n    /// @notice Spacer taking up the legacy `provenWithdrawals` mapping slot.\n    bytes32 private spacer_52_0_32;\n\n    /// @custom:legacy\n    /// @custom:spacer paused\n    /// @notice Spacer for backwards compatibility.\n    bool private spacer_53_0_1;\n\n    /// @notice Contract of the Superchain Config.\n    SuperchainConfig public superchainConfig;\n\n    /// @custom:legacy\n    /// @custom:spacer l2Oracle\n    /// @notice Spacer taking up the legacy `l2Oracle` address slot.\n    address private spacer_54_0_20;\n\n    /// @notice Contract of the SystemConfig.\n    /// @custom:network-specific\n    SystemConfig public systemConfig;\n\n    /// @notice Address of the DisputeGameFactory.\n    /// @custom:network-specific\n    DisputeGameFactory public disputeGameFactory;\n\n    /// @notice A mapping of withdrawal hashes to proof submitters to `ProvenWithdrawal` data.\n    mapping(bytes32 => mapping(address => ProvenWithdrawal)) public provenWithdrawals;\n\n    /// @notice A mapping of dispute game addresses to whether or not they are blacklisted.\n    mapping(IDisputeGame => bool) public disputeGameBlacklist;\n\n    /// @notice The game type that the OptimismPortal consults for output proposals.\n    GameType public respectedGameType;\n\n    /// @notice The timestamp at which the respected game type was last updated.\n    uint64 public respectedGameTypeUpdatedAt;\n\n    /// @notice Mapping of withdrawal hashes to addresses that have submitted a proof for the withdrawal.\n    mapping(bytes32 => address[]) public proofSubmitters;\n\n    /// @notice Emitted when a transaction is deposited from L1 to L2.\n    ///         The parameters of this event are read by the rollup node and used to derive deposit\n    ///         transactions on L2.\n    /// @param from       Address that triggered the deposit transaction.\n    /// @param to         Address that the deposit transaction is directed to.\n    /// @param version    Version of this deposit transaction event.\n    /// @param opaqueData ABI encoded deposit data to be parsed off-chain.\n    event TransactionDeposited(address indexed from, address indexed to, uint256 indexed version, bytes opaqueData);\n\n    /// @notice Emitted when a withdrawal transaction is proven.\n    /// @param withdrawalHash Hash of the withdrawal transaction.\n    /// @param from           Address that triggered the withdrawal transaction.\n    /// @param to             Address that the withdrawal transaction is directed to.\n    event WithdrawalProven(bytes32 indexed withdrawalHash, address indexed from, address indexed to);\n\n    /// @notice Emitted when a withdrawal transaction is finalized.\n    /// @param withdrawalHash Hash of the withdrawal transaction.\n    /// @param success        Whether the withdrawal transaction was successful.\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /// @notice Reverts when paused.\n    modifier whenNotPaused() {\n        require(!paused(), \"OptimismPortal: paused\");\n        _;\n    }\n\n    /// @notice Semantic version.\n    /// @custom:semver 3.5.0\n    string public constant version = \"3.5.0\";\n\n    /// @notice Constructs the OptimismPortal contract.\n    constructor(\n        uint256 _proofMaturityDelaySeconds,\n        uint256 _disputeGameFinalityDelaySeconds,\n        GameType _initialRespectedGameType\n    ) {\n        PROOF_MATURITY_DELAY_SECONDS = _proofMaturityDelaySeconds;\n        DISPUTE_GAME_FINALITY_DELAY_SECONDS = _disputeGameFinalityDelaySeconds;\n        respectedGameType = _initialRespectedGameType;\n\n        initialize({\n            _disputeGameFactory: DisputeGameFactory(address(0)),\n            _systemConfig: SystemConfig(address(0)),\n            _superchainConfig: SuperchainConfig(address(0))\n        });\n    }\n\n    /// @notice Initializer.\n    /// @param _disputeGameFactory Contract of the DisputeGameFactory.\n    /// @param _systemConfig Contract of the SystemConfig.\n    /// @param _superchainConfig Contract of the SuperchainConfig.\n    function initialize(\n        DisputeGameFactory _disputeGameFactory,\n        SystemConfig _systemConfig,\n        SuperchainConfig _superchainConfig\n    )\n        public\n        initializer\n    {\n        disputeGameFactory = _disputeGameFactory;\n        systemConfig = _systemConfig;\n        superchainConfig = _superchainConfig;\n        if (l2Sender == address(0)) {\n            l2Sender = Constants.DEFAULT_L2_SENDER;\n        }\n        __ResourceMetering_init();\n    }\n\n    /// @notice Getter function for the contract of the SystemConfig on this chain.\n    ///         Public getter is legacy and will be removed in the future. Use `systemConfig()` instead.\n    /// @return Contract of the SystemConfig on this chain.\n    /// @custom:legacy\n    function SYSTEM_CONFIG() external view returns (SystemConfig) {\n        return systemConfig;\n    }\n\n    /// @notice Getter function for the address of the guardian.\n    ///         Public getter is legacy and will be removed in the future. Use `SuperchainConfig.guardian()` instead.\n    /// @return Address of the guardian.\n    /// @custom:legacy\n    function GUARDIAN() external view returns (address) {\n        return guardian();\n    }\n\n    /// @notice Getter function for the address of the guardian.\n    ///         Public getter is legacy and will be removed in the future. Use `SuperchainConfig.guardian()` instead.\n    /// @return Address of the guardian.\n    /// @custom:legacy\n    function guardian() public view returns (address) {\n        return superchainConfig.guardian();\n    }\n\n    /// @notice Getter for the current paused status.\n    function paused() public view returns (bool) {\n        return superchainConfig.paused();\n    }\n\n    /// @notice Getter for the proof maturity delay.\n    function proofMaturityDelaySeconds() public view returns (uint256) {\n        return PROOF_MATURITY_DELAY_SECONDS;\n    }\n\n    /// @notice Getter for the dispute game finality delay.\n    function disputeGameFinalityDelaySeconds() public view returns (uint256) {\n        return DISPUTE_GAME_FINALITY_DELAY_SECONDS;\n    }\n\n    /// @notice Computes the minimum gas limit for a deposit.\n    ///         The minimum gas limit linearly increases based on the size of the calldata.\n    ///         This is to prevent users from creating L2 resource usage without paying for it.\n    ///         This function can be used when interacting with the portal to ensure forwards\n    ///         compatibility.\n    /// @param _byteCount Number of bytes in the calldata.\n    /// @return The minimum gas limit for a deposit.\n    function minimumGasLimit(uint64 _byteCount) public pure returns (uint64) {\n        return _byteCount * 16 + 21000;\n    }\n\n    /// @notice Accepts value so that users can send ETH directly to this contract and have the\n    ///         funds be deposited to their address on L2. This is intended as a convenience\n    ///         function for EOAs. Contracts should call the depositTransaction() function directly\n    ///         otherwise any deposited funds will be lost due to address aliasing.\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /// @notice Accepts ETH value without triggering a deposit to L2.\n    ///         This function mainly exists for the sake of the migration between the legacy\n    ///         Optimism system and Bedrock.\n    function donateETH() external payable {\n        // Intentionally empty.\n    }\n\n    /// @notice Getter for the resource config.\n    ///         Used internally by the ResourceMetering contract.\n    ///         The SystemConfig is the source of truth for the resource config.\n    /// @return ResourceMetering ResourceConfig\n    function _resourceConfig() internal view override returns (ResourceMetering.ResourceConfig memory) {\n        return systemConfig.resourceConfig();\n    }\n\n    /// @notice Proves a withdrawal transaction.\n    /// @param _tx               Withdrawal transaction to finalize.\n    /// @param _disputeGameIndex Index of the dispute game to prove the withdrawal against.\n    /// @param _outputRootProof  Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n    /// @param _withdrawalProof  Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _disputeGameIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    )\n        external\n        whenNotPaused\n    {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(_tx.target != address(this), \"OptimismPortal: you cannot send messages to the portal contract\");\n\n        // Fetch the dispute game proxy from the `DisputeGameFactory` contract.\n        (GameType gameType,, IDisputeGame gameProxy) = disputeGameFactory.gameAtIndex(_disputeGameIndex);\n        Claim outputRoot = gameProxy.rootClaim();\n\n        // The game type of the dispute game must be the respected game type.\n        require(gameType.raw() == respectedGameType.raw(), \"OptimismPortal: invalid game type\");\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot.raw() == Hashing.hashOutputRootProof(_outputRootProof),\n            \"OptimismPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash][msg.sender];\n\n        // We do not allow for proving withdrawals against dispute games that have resolved against the favor\n        // of the root claim.\n        require(\n            gameProxy.status() != GameStatus.CHALLENGER_WINS,\n            \"OptimismPortal: cannot prove against invalid dispute games\"\n        );\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // in the case that an honest user proves their withdrawal against a dispute game that\n        // resolves against the root claim, or the dispute game is blacklisted, we allow\n        // re-proving the withdrawal against a new proposal.\n        IDisputeGame oldGame = provenWithdrawal.disputeGameProxy;\n        require(\n            provenWithdrawal.timestamp == 0 || oldGame.status() == GameStatus.CHALLENGER_WINS\n                || disputeGameBlacklist[oldGame] || oldGame.gameType().raw() != respectedGameType.raw(),\n            \"OptimismPortal: withdrawal hash has already been proven, and the old dispute game is not invalid\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey), hex\"01\", _withdrawalProof, _outputRootProof.messagePasserStorageRoot\n            ),\n            \"OptimismPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `disputeGameProxy` & `timestamp` in the\n        // `provenWithdrawals` mapping. A `withdrawalHash` can only be proven once unless the dispute game it proved\n        // against resolves against the favor of the root claim.\n        provenWithdrawals[withdrawalHash][msg.sender] =\n            ProvenWithdrawal({ disputeGameProxy: gameProxy, timestamp: uint64(block.timestamp) });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n\n        // Add the proof submitter to the list of proof submitters for this withdrawal hash.\n        proofSubmitters[withdrawalHash].push(msg.sender);\n    }\n\n    /// @notice Finalizes a withdrawal transaction.\n    /// @param _tx Withdrawal transaction to finalize.\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx) external whenNotPaused {\n        finalizeWithdrawalTransactionExternalProof(_tx, msg.sender);\n    }\n\n    /// @notice Finalizes a withdrawal transaction, using an external proof submitter.\n    /// @param _tx Withdrawal transaction to finalize.\n    /// @param _proofSubmitter Address of the proof submitter.\n    function finalizeWithdrawalTransactionExternalProof(\n        Types.WithdrawalTransaction memory _tx,\n        address _proofSubmitter\n    )\n        public\n        whenNotPaused\n    {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER, \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Compute the withdrawal hash.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n\n        // Check that the withdrawal can be finalized.\n        checkWithdrawal(withdrawalHash, _proofSubmitter);\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use a custom low level method\n        // SafeCall.callWithMinGas to ensure two key properties\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\n        //      amount of data (and this is OK because we don't care about the returndata here).\n        //   2. The amount of gas provided to the execution context of the target is at least the\n        //      gas limit specified by the user. If there is not enough gas in the current context\n        //      to accomplish this, `callWithMinGas` will revert.\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if (!success && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"OptimismPortal: withdrawal failed\");\n        }\n    }\n\n    /// @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n    ///         deriving deposit transactions. Note that if a deposit is made by a contract, its\n    ///         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n    ///         using the CrossDomainMessenger contracts for a simpler developer experience.\n    /// @param _to         Target address on L2.\n    /// @param _value      ETH value to send to the recipient.\n    /// @param _gasLimit   Amount of L2 gas to purchase by burning gas on L1.\n    /// @param _isCreation Whether or not the transaction is a contract creation.\n    /// @param _data       Data to trigger the recipient with.\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    )\n        public\n        payable\n        metered(_gasLimit)\n    {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(_to == address(0), \"OptimismPortal: must send to address(0) when creating a contract\");\n        }\n\n        // Prevent depositing transactions that have too small of a gas limit. Users should pay\n        // more for more resource usage.\n        require(_gasLimit >= minimumGasLimit(uint64(_data.length)), \"OptimismPortal: gas limit too small\");\n\n        // Prevent the creation of deposit transactions that have too much calldata. This gives an\n        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure\n        // that the transaction can fit into the p2p network policy of 128kb even though deposit\n        // transactions are not gossipped over the p2p network.\n        require(_data.length <= 120_000, \"OptimismPortal: data too large\");\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(msg.value, _value, _gasLimit, _isCreation, _data);\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /// @notice Blacklists a dispute game. Should only be used in the event that a dispute game resolves incorrectly.\n    /// @param _disputeGame Dispute game to blacklist.\n    function blacklistDisputeGame(IDisputeGame _disputeGame) external {\n        require(msg.sender == guardian(), \"OptimismPortal: only the guardian can blacklist dispute games\");\n        disputeGameBlacklist[_disputeGame] = true;\n    }\n\n    /// @notice Sets the respected game type. Changing this value can alter the security properties of the system,\n    ///         depending on the new game's behavior.\n    /// @param _gameType The game type to consult for output proposals.\n    function setRespectedGameType(GameType _gameType) external {\n        require(msg.sender == guardian(), \"OptimismPortal: only the guardian can set the respected game type\");\n        respectedGameType = _gameType;\n        respectedGameTypeUpdatedAt = uint64(block.timestamp);\n    }\n\n    /// @notice Checks if a withdrawal can be finalized. This function will revert if the withdrawal cannot be\n    ///         finalized, and otherwise has no side-effects.\n    /// @param _withdrawalHash Hash of the withdrawal to check.\n    /// @param _proofSubmitter The submitter of the proof for the withdrawal hash\n    function checkWithdrawal(bytes32 _withdrawalHash, address _proofSubmitter) public view {\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[_withdrawalHash][_proofSubmitter];\n        IDisputeGame disputeGameProxy = provenWithdrawal.disputeGameProxy;\n\n        // The dispute game must not be blacklisted.\n        require(!disputeGameBlacklist[disputeGameProxy], \"OptimismPortal: dispute game has been blacklisted\");\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(\n            provenWithdrawal.timestamp != 0,\n            \"OptimismPortal: withdrawal has not been proven by proof submitter address yet\"\n        );\n\n        uint64 createdAt = disputeGameProxy.createdAt().raw();\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the Dispute Game. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp > createdAt,\n            \"OptimismPortal: withdrawal timestamp less than dispute game creation timestamp\"\n        );\n\n        // A proven withdrawal must wait at least `PROOF_MATURITY_DELAY_SECONDS` before finalizing.\n        require(\n            block.timestamp - provenWithdrawal.timestamp > PROOF_MATURITY_DELAY_SECONDS,\n            \"OptimismPortal: proven withdrawal has not matured yet\"\n        );\n\n        // A proven withdrawal must wait until the dispute game it was proven against has been\n        // resolved in favor of the root claim (the output proposal). This is to prevent users\n        // from finalizing withdrawals proven against non-finalized output roots.\n        require(\n            disputeGameProxy.status() == GameStatus.DEFENDER_WINS,\n            \"OptimismPortal: output proposal has not been validated\"\n        );\n\n        // The game type of the dispute game must be the respected game type. This was also checked in\n        // `proveWithdrawalTransaction`, but we check it again in case the respected game type has changed since\n        // the withdrawal was proven.\n        require(disputeGameProxy.gameType().raw() == respectedGameType.raw(), \"OptimismPortal: invalid game type\");\n\n        // The game must have been created after `respectedGameTypeUpdatedAt`. This is to prevent users from creating\n        // invalid disputes against a deployed game type while the off-chain challenge agents are not watching.\n        require(\n            createdAt >= respectedGameTypeUpdatedAt,\n            \"OptimismPortal: dispute game created before respected game type was updated\"\n        );\n\n        // Before a withdrawal can be finalized, the dispute game it was proven against must have been\n        // resolved for at least `DISPUTE_GAME_FINALITY_DELAY_SECONDS`. This is to allow for manual\n        // intervention in the event that a dispute game is resolved incorrectly.\n        require(\n            block.timestamp - disputeGameProxy.resolvedAt().raw() > DISPUTE_GAME_FINALITY_DELAY_SECONDS,\n            \"OptimismPortal: output proposal in air-gap\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(!finalizedWithdrawals[_withdrawalHash], \"OptimismPortal: withdrawal has already been finalized\");\n    }\n\n    /// @notice External getter for the number of proof submitters for a withdrawal hash.\n    /// @param _withdrawalHash Hash of the withdrawal.\n    /// @return The number of proof submitters for the withdrawal hash.\n    function numProofSubmitters(bytes32 _withdrawalHash) external view returns (uint256) {\n        return proofSubmitters[_withdrawalHash].length;\n    }\n}"
    },
    {
      "filename": "optimism/packages/contracts-bedrock/src/L1/OptimismPortal2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"src/libraries/SafeCall.sol\";\nimport { DisputeGameFactory, IDisputeGame } from \"src/dispute/DisputeGameFactory.sol\";\nimport { SystemConfig } from \"src/L1/SystemConfig.sol\";\nimport { SuperchainConfig } from \"src/L1/SuperchainConfig.sol\";\nimport { Constants } from \"src/libraries/Constants.sol\";\nimport { Types } from \"src/libraries/Types.sol\";\nimport { Hashing } from \"src/libraries/Hashing.sol\";\nimport { SecureMerkleTrie } from \"src/libraries/trie/SecureMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"src/vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"src/L1/ResourceMetering.sol\";\nimport { ISemver } from \"src/universal/ISemver.sol\";\nimport { Constants } from \"src/libraries/Constants.sol\";\n\nimport \"src/libraries/DisputeTypes.sol\";\n\n/// @custom:proxied\n/// @title OptimismPortal2\n/// @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n///         and L2. Messages sent directly to the OptimismPort"
    }
  ]
}