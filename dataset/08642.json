{
  "Title": "[M-16] `_storeRebase()` is called with the wrong parameters",
  "Content": "_Submitted by BowTiedWardens, also found by hansfriese, hubble, minhquanym, PwnedNoMore, shung, TrungOre, and WatchPug_\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L110-L114>\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L97-L100>\n\n### Vulnerability Details\n\n`_storeRebase()`'s signature is as such:\n\n*   [Yieldy.sol#\\_storeRebase()](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L110-L114)\n\n```solidity\nFile: Yieldy.sol\n104:     /**\n105:         @notice emits event with data about rebase\n106:         @param _previousCirculating uint\n107:         @param _profit uint\n108:         @param _epoch uint\n109:      */\n110:     function _storeRebase(\n111:         uint256 _previousCirculating,\n112:         uint256 _profit,\n113:         uint256 _epoch\n114:     ) internal {\n```\n\nHowever, instead of being called with the expected `_previousCirculating` value, it's called with the current circulation value:\n\n*   [Yieldy.sol#rebase()](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L97-L100)\n\n```solidity\nFile: Yieldy.sol\n89:             uint256 updatedTotalSupply = currentTotalSupply + _profit;\n...\n103:             _totalSupply = updatedTotalSupply;\n104: \n105:             _storeRebase(updatedTotalSupply, _profit, _epoch); // @audit-info this should be currentTotalSupply otherwise previous = current\n```\n\nAs a consequence, the functionality isn't doing what it was created for.\n\n### Recommended Mitigation Steps\n\nConsider calling `_storeRebase()` with `currentTotalSupply`:\n\n```diff\nFile: Yieldy.sol\n- 105:             _storeRebase(updatedTotalSupply, _profit, _epoch);\n+ 105:             _storeRebase(currentTotalSupply, _profit, _epoch);\n```\n**[toshiSat (Yieldy) confirmed and resolved](https://github.com/code-423n4/2022-06-yieldy-findings/issues/259#issuecomment-1167809101)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-yieldy-contest",
  "Code": [
    {
      "filename": "src/contracts/Yieldy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldyStorage.sol\";\nimport \"../libraries/ERC20PermitUpgradeable.sol\";\n\ncontract Yieldy is\n    YieldyStorage,\n    ERC20PermitUpgradeable,\n    AccessControlUpgradeable\n{\n    event LogSupply(\n        uint256 indexed epoch,\n        uint256 timestamp,\n        uint256 totalSupply\n    );\n\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n\n    /**\n        @notice initialize function\n        @param _tokenName erc20 token name\n        @param _tokenSymbol erc20 token symbol\n        @param _decimal decimal amount\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _decimal\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        ERC20PermitUpgradeable.__ERC20Permit_init(_tokenName);\n        AccessControlUpgradeable.__AccessControl_init();\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(MINTER_BURNER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(REBASE_ROLE, ADMIN_ROLE);\n\n        decimal = _decimal;\n        WAD = 10**decimal;\n        rebasingCreditsPerToken = WAD;\n        _setIndex(WAD);\n    }\n\n    /**\n        @notice called by the admin role address to set the staking contract. Can only be called\n        once. \n        @param _stakingContract address of the staking contract\n     */\n    function initializeStakingContract(address _stakingContract)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        require(stakingContract == address(0), \"Already Initialized\");\n        require(_stakingContract != address(0), \"Invalid address\");\n        stakingContract = _stakingContract;\n        _setupRole(MINTER_BURNER_ROLE, _stakingContract);\n        _setupRole(REBASE_ROLE, _stakingContract);\n    }\n\n    /**\n        @notice sets index to get the value of rebases from the beginning of the contract\n        @param _index uint - initial index\n     */\n    function _setIndex(uint256 _index) internal {\n        index = creditsForTokenBalance(_index);\n    }\n\n    /**\n        @notice increases Yieldy supply to increase staking balances relative to profit_\n        @param _profit uint256 - amount of rewards to distribute\n        @param _epoch uint256 - epoch number\n     */\n    function rebase(uint256 _profit, uint256 _epoch)\n        external\n        onlyRole(REBASE_ROLE)\n    {\n        uint256 currentTotalSupply = _totalSupply;\n        require(_totalSupply > 0, \"Can't rebase if not circulating\");\n\n        if (_profit == 0) {\n            emit LogSupply(_epoch, block.timestamp, currentTotalSupply);\n            emit LogRebase(_epoch, 0, getIndex());\n        } else {\n            uint256 updatedTotalSupply = currentTotalSupply + _profit;\n\n            if (updatedTotalSupply > MAX_SUPPLY) {\n                updatedTotalSupply = MAX_SUPPLY;\n            }\n\n            rebasingCreditsPerToken = rebasingCredits / updatedTotalSupply;\n            require(rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n            _totalSupply = updatedTotalSupply;\n\n            _storeRebase(updatedTotalSupply, _profit, _epoch);\n        }\n    }\n\n    /**\n        @notice emits event with data about rebase\n        @param _previousCirculating uint\n        @param _profit uint\n        @param _epoch uint\n     */\n    function _storeRebase(\n        uint256 _previousCirculating,\n        uint256 _profit,\n        uint256 _epoch\n    ) internal {\n        uint256 rebasePercent = (_profit * WAD) / _previousCirculating;\n\n        rebases.push(\n            Rebase({\n                epoch: _epoch,\n                rebase: rebasePercent,\n                totalStakedBefore: _previousCirculating,\n                totalStakedAfter: _totalSupply,\n                amountRebased: _profit,\n                index: getIndex(),\n                blockNumberOccurred: block.number\n            })\n        );\n\n        emit LogSupply(_epoch, block.timestamp, _totalSupply);\n        emit LogRebase(_epoch, rebasePercent, getIndex());\n    }\n\n    /**\n        @notice gets balanceOf Yieldy\n        @param _wallet address\n        @return uint\n     */\n    function balanceOf(address _wallet) public view override returns (uint256) {\n        return creditBalances[_wallet] / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate credits based on balance amount\n        @param _amount uint\n        @return uint\n     */\n    function creditsForTokenBalance(uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        return _amount * rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate balance based on _credits amount\n        @param _credits uint\n        @return uint\n     */\n    function tokenBalanceForCredits(uint256 _credits)\n        public\n        view\n        returns (uint256)\n    {\n        return _credits / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice get current index to show what how much Yieldy the user would have gained if staked from the beginning\n        @return uint - current index\n     */\n    function getIndex() public view returns (uint256) {\n        return tokenBalanceForCredits(index);\n    }\n\n    /**\n        @notice transfers to _to address with an amount of _value\n        @param _to address\n        @param _value uint\n        @return bool - transfer succeeded\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        require(_to != address(0), \"Invalid address\");\n\n        uint256 creditAmount = _value * rebasingCreditsPerToken;\n        require(creditAmount <= creditBalances[msg.sender], \"Not enough funds\");\n\n        creditBalances[msg.sender] = creditBalances[msg.sender] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n        @notice transfer from address to address with amount\n        @param _from address\n        @param _to address\n        @param _value uint\n        @return bool\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        require(_allowances[_from][msg.sender] >= _value, \"Allowance too low\");\n\n        uint256 newValue = _allowances[_from][msg.sender] - _value;\n        _allowances[_from][msg.sender] = newValue;\n        emit Approval(_from, msg.sender, newValue);\n\n        uint256 creditAmount = creditsForTokenBalance(_value);\n        creditBalances[_from] = creditBalances[_from] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n        @notice should be same as yield decimal\n     */\n    function decimals() public view override returns (uint8) {\n        return decimal;\n    }\n\n    /**\n        @notice called from the staking contract co create Yieldy tokens\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function mint(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _mint(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 mint functionality\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function _mint(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Mint to the zero address\");\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        creditBalances[_address] = creditBalances[_address] + creditAmount;\n        rebasingCredits = rebasingCredits + creditAmount;\n\n        _totalSupply = _totalSupply + _amount;\n\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _address, _amount);\n    }\n\n    /**\n        @notice called from the staking contract co burn Yieldy tokens\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function burn(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _burn(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 burn functionality\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function _burn(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        uint256 currentCredits = creditBalances[_address];\n        require(currentCredits >= creditAmount, \"Not enough balance\");\n\n        creditBalances[_address] = creditBalances[_address] - creditAmount;\n        rebasingCredits = rebasingCredits - creditAmount;\n        _totalSupply = _totalSupply - _amount;\n\n        emit Transfer(_address, address(0), _amount);\n    }\n}"
    },
    {
      "filename": "src/contracts/Yieldy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldyStorage.sol\";\nimport \"../libraries/ERC20PermitUpgradeable.sol\";\n\ncontract Yieldy is\n    YieldyStorage,\n    ERC20PermitUpgradeable,\n    AccessControlUpgradeable\n{\n    event LogSupply(\n        uint256 indexed epoch,\n        uint256 timestamp,\n        uint256 totalSupply\n    );\n\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n\n    /**\n        @notice initialize function\n        @param _tokenName erc20 token name\n        @param _tokenSymbol erc20 token symbol\n        @param _decimal decimal amount\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _decimal\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        ERC20PermitUpgradeable.__ERC20Permit_init(_tokenName);\n        AccessControlUpgradeable.__AccessControl_init();\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(MINTER_BURNER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(REBASE_ROLE, ADMIN_ROLE);\n\n        decimal = _decimal;\n        WAD = 10**decimal;\n        rebasingCreditsPerToken = WAD;\n        _setIndex(WAD);\n    }\n\n    /**\n        @notice called by the admin role address to set the staking contract. Can only be called\n        once. \n        @param _stakingContract address of the staking contract\n     */\n    function initializeStakingContract(address _stakingContract)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        require(stakingContract == address(0), \"Already Initialized\");\n        require(_stakingContract != address(0), \"Invalid address\");\n        stakingContract = _stakingContract;\n        _setupRole(MINTER_BURNER_ROLE, _stakingContract);\n        _setupRole(REBASE_ROLE, _stakingContract);\n    }\n\n    /**\n        @notice sets index to get the value of rebases from the beginning of the contract\n        @param _index uint - initial index\n     */\n    function _setIndex(uint256 _index) internal {\n        index = creditsForTokenBalance(_index);\n    }\n\n    /**\n        @notice increases Yieldy supply to increase staking balances relative to profit_\n        @param _profit uint256 - amount of rewards to distribute\n        @param _epoch uint256 - epoch number\n     */\n    function rebase(uint256 _profit, uint256 _epoch)\n        external\n        onlyRole(REBASE_ROLE)\n    {\n        uint256 currentTotalSupply = _totalSupply;\n        require(_totalSupply > 0, \"Can't rebase if not circulating\");\n\n        if (_profit == 0) {\n            emit LogSupply(_epoch, block.timestamp, currentTotalSupply);\n            emit LogRebase(_epoch, 0, getIndex());\n        } else {\n            uint256 updatedTotalSupply = currentTotalSupply + _profit;\n\n            if (updatedTotalSupply > MAX_SUPPLY) {\n                updatedTotalSupply = MAX_SUPPLY;\n            }\n\n            rebasingCreditsPerToken = rebasingCredits / updatedTotalSupply;\n            require(rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n            _totalSupply = updatedTotalSupply;\n\n            _storeRebase(updatedTotalSupply, _profit, _epoch);\n        }\n    }\n\n    /**\n        @notice emits event with data about rebase\n        @param _previousCirculating uint\n        @param _profit uint\n        @param _epoch uint\n     */\n    function _storeRebase(\n        uint256 _previousCirculating,\n        uint256 _profit,\n        uint256 _epoch\n    ) internal {\n        uint256 rebasePercent = (_profit * WAD) / _previousCirculating;\n\n        rebases.push(\n            Rebase({\n                epoch: _epoch,\n                rebase: rebasePercent,\n                totalStakedBefore: _previousCirculating,\n                totalStakedAfter: _totalSupply,\n                amountRebased: _profit,\n                index: getIndex(),\n                blockNumberOccurred: block.number\n            })\n        );\n\n        emit LogSupply(_epoch, block.timestamp, _totalSupply);\n        emit LogRebase(_epoch, rebasePercent, getIndex());\n    }\n\n    /**\n        @notice gets balanceOf Yieldy\n        @param _wallet address\n        @return uint\n     */\n    function balanceOf(address _wallet) public view override returns (uint256) {\n        return creditBalances[_wallet] / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate credits based on balance amount\n        @param _amount uint\n        @return uint\n     */\n    function creditsForTokenBalance(uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        return _amount * rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate balance based on _credits amount\n        @param _credits uint\n        @return uint\n     */\n    function tokenBalanceForCredits(uint256 _credits)\n        public\n        view\n        returns (uint256)\n    {\n        return _credits / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice get current index to show what how much Yieldy the user would have gained if staked from the beginning\n        @return uint - current index\n     */\n    function getIndex() public view returns (uint256) {\n        return tokenBalanceForCredits(index);\n    }\n\n    /**\n        @notice transfers to _to address with an amount of _value\n        @param _to address\n        @param _value uint\n        @return bool - transfer succeeded\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        require(_to != address(0), \"Invalid address\");\n\n        uint256 creditAmount = _value * rebasingCreditsPerToken;\n        require(creditAmount <= creditBalances[msg.sender], \"Not enough funds\");\n\n        creditBalances[msg.sender] = creditBalances[msg.sender] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n        @notice transfer from address to address with amount\n        @param _from address\n        @param _to address\n        @param _value uint\n        @return bool\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        require(_allowances[_from][msg.sender] >= _value, \"Allowance too low\");\n\n        uint256 newValue = _allowances[_from][msg.sender] - _value;\n        _allowances[_from][msg.sender] = newValue;\n        emit Approval(_from, msg.sender, newValue);\n\n        uint256 creditAmount = creditsForTokenBalance(_value);\n        creditBalances[_from] = creditBalances[_from] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n        @notice should be same as yield decimal\n     */\n    function decimals() public view override returns (uint8) {\n        return decimal;\n    }\n\n    /**\n        @notice called from the staking contract co create Yieldy tokens\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function mint(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _mint(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 mint functionality\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function _mint(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Mint to the zero address\");\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        creditBalances[_address] = creditBalances[_address] + creditAmount;\n        rebasingCredits = rebasingCredits + creditAmount;\n\n        _totalSupply = _totalSupply + _amount;\n\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _address, _amount);\n    }\n\n    /**\n        @notice called from the staking contract co burn Yieldy tokens\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function burn(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _burn(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 burn functionality\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function _burn(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        uint256 currentCredits = creditBalances[_address];\n        require(currentCredits >= creditAmount, \"Not enough balance\");\n\n        creditBalances[_address] = creditBalances[_address] - creditAmount;\n        rebasingCredits = rebasingCredits - creditAmount;\n        _totalSupply = _totalSupply - _amount;\n\n        emit Transfer(_address, address(0), _amount);\n    }\n}"
    },
    {
      "filename": "src/contracts/Yieldy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldyStorage.sol\";\nimport \"../libraries/ERC20PermitUpgradeable.sol\";\n\ncontract Yieldy is\n    YieldyStorage,\n    ERC20PermitUpgradeable,\n    AccessControlUpgradeable\n{\n    event LogSupply(\n        uint256 indexed epoch,\n        uint256 timestamp,\n        uint256 totalSupply\n    );\n\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n\n    /**\n        @notice initialize function\n        @param _tokenName erc20 token name\n        @param _tokenSymbol erc20 token symbol\n        @param _decimal decimal amount\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _decimal\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        ERC20PermitUpgradeable.__ERC20Permit_init(_tokenName);\n        AccessControlUpgradeable.__AccessControl_init();\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(MINTER_BURNER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(REBASE_ROLE, ADMIN_ROLE);\n\n        decimal = _decimal;\n        WAD = 10**decimal;\n        rebasingCreditsPerToken = WAD;\n        _setIndex(WAD);\n    }\n\n    /**\n        @notice called by the admin role address to set the staking contract. Can only be called\n        once. \n        @param _stakingContract address of the staking contract\n     */\n    function initializeStakingContract(address _stakingContract)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        require(stakingContract == address(0), \"Already Initialized\");\n        require(_stakingContract != address(0), \"Invalid address\");\n        stakingContract = _stakingContract;\n        _setupRole(MINTER_BURNER_ROLE, _stakingContract);\n        _setupRole(REBASE_ROLE, _stakingContract);\n    }\n\n    /**\n        @notice sets index to get the value of rebases from the beginning of the contract\n        @param _index uint - initial index\n     */\n    function _setIndex(uint256 _index) internal {\n        index = creditsForTokenBalance(_index);\n    }\n\n    /**\n        @notice increases Yieldy supply to increase staking balances relative to profit_\n        @param _profit uint256 - amount of rewards to distribute\n        @param _epoch uint256 - epoch number\n     */\n    function rebase(uint256 _profit, uint256 _epoch)\n        external\n        onlyRole(REBASE_ROLE)\n    {\n        uint256 currentTotalSupply = _totalSupply;\n        require(_totalSupply > 0, \"Can't rebase if not circulating\");\n\n        if (_profit == 0) {\n            emit LogSupply(_epoch, block.timestamp, currentTotalSupply);\n            emit LogRebase(_epoch, 0, getIndex());\n        } else {\n            uint256 updatedTotalSupply = currentTotalSupply + _profit;\n\n            if (updatedTotalSupply > MAX_SUPPLY) {\n                updatedTotalSupply = MAX_SUPPLY;\n            }\n\n            rebasingCreditsPerToken = rebasingCredits / updatedTotalSupply;\n            require(rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n            _totalSupply = updatedTotalSupply;\n\n            _storeRebase(updatedTotalSupply, _profit, _epoch);\n        }\n    }\n\n    /**\n        @notice emits event with data about rebase\n        @param _previousCirculating uint\n        @param _profit uint\n        @param _epoch uint\n     */\n    function _storeRebase(\n        uint256 _previousCirculating,\n        uint256 _profit,\n        uint256 _epoch\n    ) internal {\n        uint256 rebasePercent = (_profit * WAD) / _previousCirculating;\n\n        rebases.push(\n            Rebase({\n                epoch: _epoch,\n                rebase: rebasePercent,\n                totalStakedBefore: _previousCirculating,\n                totalStakedAfter: _totalSupply,\n                amountRebased: _profit,\n                index: getIndex(),\n                blockNumberOccurred: block.number\n            })\n        );\n\n        emit LogSupply(_epoch, block.timestamp, _totalSupply);\n        emit LogRebase(_epoch, rebasePercent, getIndex());\n    }\n\n    /**\n        @notice gets balanceOf Yieldy\n        @param _wallet address\n        @return uint\n     */\n    function balanceOf(address _wallet) public view override returns (uint256) {\n        return creditBalances[_wallet] / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate credits based on balance amount\n        @param _amount uint\n        @return uint\n     */\n    function creditsForTokenBalance(uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        return _amount * rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate balance based on _credits amount\n        @param _credits uint\n        @return uint\n     */\n    function tokenBalanceForCredits(uint256 _credits)\n        public\n        view\n        returns (uint256)\n    {\n        return _credits / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice get current index to show what how much Yieldy the user would have gained if staked from the beginning\n        @return uint - current index\n     */\n    function getIndex() public view returns (uint256) {\n        return tokenBalanceForCredits(index);\n    }\n\n    /**\n        @notice transfers to _to address with an amount of _value\n        @param _to address\n        @param _value uint\n        @return bool - transfer succeeded\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        returns (bool)\n    {\n        require(_to != address(0), \"Invalid address\");\n\n        uint256 creditAmount = _value * rebasingCreditsPerToken;\n        require(creditAmount <= creditBalances[msg.sender], \"Not enough funds\");\n\n        creditBalances[msg.sender] = creditBalances[msg.sender] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n        @notice transfer from address to address with amount\n        @param _from address\n        @param _to address\n        @param _value uint\n        @return bool\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        require(_allowances[_from][msg.sender] >= _value, \"Allowance too low\");\n\n        uint256 newValue = _allowances[_from][msg.sender] - _value;\n        _allowances[_from][msg.sender] = newValue;\n        emit Approval(_from, msg.sender, newValue);\n\n        uint256 creditAmount = creditsForTokenBalance(_value);\n        creditBalances[_from] = creditBalances[_from] - creditAmount;\n        creditBalances[_to] = creditBalances[_to] + creditAmount;\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n        @notice should be same as yield decimal\n     */\n    function decimals() public view override returns (uint8) {\n        return decimal;\n    }\n\n    /**\n        @notice called from the staking contract co create Yieldy tokens\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function mint(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _mint(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 mint functionality\n        @param _address to receive tokens\n        @param _amount to mint to _address\n     */\n    function _mint(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Mint to the zero address\");\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        creditBalances[_address] = creditBalances[_address] + creditAmount;\n        rebasingCredits = rebasingCredits + creditAmount;\n\n        _totalSupply = _totalSupply + _amount;\n\n        require(_totalSupply < MAX_SUPPLY, \"Max supply\");\n        emit Transfer(address(0), _address, _amount);\n    }\n\n    /**\n        @notice called from the staking contract co burn Yieldy tokens\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function burn(address _address, uint256 _amount)\n        external\n        onlyRole(MINTER_BURNER_ROLE)\n    {\n        _burn(_address, _amount);\n    }\n\n    /**\n        @notice internal override for stock erc20 burn functionality\n        @param _address to burns tokens from\n        @param _amount to burn from _address\n     */\n    function _burn(address _address, uint256 _amount) internal override {\n        require(_address != address(0), \"Burn from the zero address\");\n        if (_amount == 0) {\n            return;\n        }\n\n        uint256 creditAmount = _amount * rebasingCreditsPerToken;\n        uint256 currentCredits = creditBalances[_address];\n        require(currentCredits >= creditAmount, \"Not enough balance\");\n\n        creditBalances[_address] = creditBalances[_address] - creditAmount;\n        rebasingCredits = rebasingCredits - creditAmount;\n        _totalSupply = _totalSupply - _amount;\n\n        emit Transfer(_address, address(0), _amount);\n    }\n}"
    },
    {
      "filename": "src/contracts/Yieldy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldyStorage.sol\";\nimport \"../libraries/ERC20PermitUpgradeable.sol\";\n\ncontract Yieldy is\n    YieldyStorage,\n    ERC20PermitUpgradeable,\n    AccessControlUpgradeable\n{\n    event LogSupply(\n        uint256 indexed epoch,\n        uint256 timestamp,\n        uint256 totalSupply\n    );\n\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n\n    /**\n        @notice initialize function\n        @param _tokenName erc20 token name\n        @param _tokenSymbol erc20 token symbol\n        @param _decimal decimal amount\n     */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _decimal\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        ERC20PermitUpgradeable.__ERC20Permit_init(_tokenName);\n        AccessControlUpgradeable.__AccessControl_init();\n\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(MINTER_BURNER_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(REBASE_ROLE, ADMIN_ROLE);\n\n        decimal = _decimal;\n        WAD = 10**decimal;\n        rebasingCreditsPerToken = WAD;\n        _setIndex(WAD);\n    }\n\n    /**\n        @notice called by the admin role address to set the staking contract. Can only be called\n        once. \n        @param _stakingContract address of the staking contract\n     */\n    function initializeStakingContract(address _stakingContract)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        require(stakingContract == address(0), \"Already Initialized\");\n        require(_stakingContract != address(0), \"Invalid address\");\n        stakingContract = _stakingContract;\n        _setupRole(MINTER_BURNER_ROLE, _stakingContract);\n        _setupRole(REBASE_ROLE, _stakingContract);\n    }\n\n    /**\n        @notice sets index to get the value of rebases from the beginning of the contract\n        @param _index uint - initial index\n     */\n    function _setIndex(uint256 _index) internal {\n        index = creditsForTokenBalance(_index);\n    }\n\n    /**\n        @notice increases Yieldy supply to increase staking balances relative to profit_\n        @param _profit uint256 - amount of rewards to distribute\n        @param _epoch uint256 - epoch number\n     */\n    function rebase(uint256 _profit, uint256 _epoch)\n        external\n        onlyRole(REBASE_ROLE)\n    {\n        uint256 currentTotalSupply = _totalSupply;\n        require(_totalSupply > 0, \"Can't rebase if not circulating\");\n\n        if (_profit == 0) {\n            emit LogSupply(_epoch, block.timestamp, currentTotalSupply);\n            emit LogRebase(_epoch, 0, getIndex());\n        } else {\n            uint256 updatedTotalSupply = currentTotalSupply + _profit;\n\n            if (updatedTotalSupply > MAX_SUPPLY) {\n                updatedTotalSupply = MAX_SUPPLY;\n            }\n\n            rebasingCreditsPerToken = rebasingCredits / updatedTotalSupply;\n            require(rebasingCreditsPerToken > 0, \"Invalid change in supply\");\n\n            _totalSupply = updatedTotalSupply;\n\n            _storeRebase(updatedTotalSupply, _profit, _epoch);\n        }\n    }\n\n    /**\n        @notice emits event with data about rebase\n        @param _previousCirculating uint\n        @param _profit uint\n        @param _epoch uint\n     */\n    function _storeRebase(\n        uint256 _previousCirculating,\n        uint256 _profit,\n        uint256 _epoch\n    ) internal {\n        uint256 rebasePercent = (_profit * WAD) / _previousCirculating;\n\n        rebases.push(\n            Rebase({\n                epoch: _epoch,\n                rebase: rebasePercent,\n                totalStakedBefore: _previousCirculating,\n                totalStakedAfter: _totalSupply,\n                amountRebased: _profit,\n                index: getIndex(),\n                blockNumberOccurred: block.number\n            })\n        );\n\n        emit LogSupply(_epoch, block.timestamp, _totalSupply);\n        emit LogRebase(_epoch, rebasePercent, getIndex());\n    }\n\n    /**\n        @notice gets balanceOf Yieldy\n        @param _wallet address\n        @return uint\n     */\n    function balanceOf(address _wallet) public view override returns (uint256) {\n        return creditBalances[_wallet] / rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate credits based on balance amount\n        @param _amount uint\n        @return uint\n     */\n    function creditsForTokenBalance(uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        return _amount * rebasingCreditsPerToken;\n    }\n\n    /**\n        @notice calculate balance based on _credits amount\n        @param _credits uint\n        @return uint\n     */\n    function tokenBalanceForCredits(uint256 _credits)"
    }
  ]
}