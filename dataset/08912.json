{
  "Title": "[19] Empty blocks should be removed or emit something",
  "Content": "The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)\n\n*There are 3 instances of this issue:*\n```solidity\nFile: protocol/contracts/zaps/PoolMigrationZap.sol   #1\n\n31:       receive() external payable {}\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L31\n\n```solidity\nFile: protocol/contracts/RewardHandler.sol   #2\n\n30:       receive() external payable {}\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L30\n\n```solidity\nFile: protocol/contracts/tokenomics/FeeBurner.sol   #3\n\n35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/zaps/PoolMigrationZap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/zaps/IPoolMigrationZap.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\n\n/**\n * This is a Zap contract to assist in the migration from the V1 Backd Pools to the new Backd Pools.\n */\ncontract PoolMigrationZap is IPoolMigrationZap {\n    using SafeERC20 for IERC20;\n\n    mapping(address => ILiquidityPool) internal _underlyingNewPools; // A mapping from underlyings to new pools\n\n    event Migrated(address user, address oldPool, address newPool, uint256 lpTokenAmount); // Emitted when a migration is completed\n\n    constructor(address newAddressProviderAddress_) {\n        address[] memory newPools_ = IAddressProvider(newAddressProviderAddress_).allPools();\n        for (uint256 i; i < newPools_.length; ++i) {\n            ILiquidityPool newPool_ = ILiquidityPool(newPools_[i]);\n            address underlying_ = newPool_.getUnderlying();\n            _underlyingNewPools[underlying_] = newPool_;\n            if (underlying_ == address(0)) continue;\n            IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max);\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Migrates all of a users balance from the old pools to the new pools.\n     * @dev The user must have balance in all pools given, otherwise transaction will revert.\n     * @param oldPoolAddresses_ The list of old pools to migrate for the user.\n     */\n    function migrateAll(address[] calldata oldPoolAddresses_) external override {\n        for (uint256 i; i < oldPoolAddresses_.length; ) {\n            migrate(oldPoolAddresses_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Migrates a users balance from an old pool to a new pool.\n     * @dev The user must have balance in the pool given, otherwise transaction will revert.\n     * @param oldPoolAddress_ The old pool to migrate for the user.\n     */\n    function migrate(address oldPoolAddress_) public override {\n        ILiquidityPool oldPool_ = ILiquidityPool(oldPoolAddress_);\n        IERC20 lpToken_ = IERC20(oldPool_.getLpToken());\n        uint256 lpTokenAmount_ = lpToken_.balanceOf(msg.sender);\n        require(lpTokenAmount_ != 0, \"No LP Tokens\");\n        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\");\n        lpToken_.safeTransferFrom(msg.sender, address(this), lpTokenAmount_);\n        uint256 underlyingAmount_ = oldPool_.redeem(lpTokenAmount_);\n        address underlying_ = oldPool_.getUnderlying();\n        ILiquidityPool newPool_ = _underlyingNewPools[underlying_];\n        uint256 ethValue_ = underlying_ == address(0) ? underlyingAmount_ : 0;\n        newPool_.depositFor{value: ethValue_}(msg.sender, underlyingAmount_);\n        emit Migrated(msg.sender, address(oldPool_), address(newPool_), lpTokenAmount_);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/RewardHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IFeeBurner.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IRewardHandler.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\ncontract RewardHandler is IRewardHandler, Preparable, Authorization {\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = IAddressProvider(controller.addressProvider());\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Burns all accumulated fees and pays these out to the BKD locker.\n     */\n    function burnFees() external override {\n        IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());\n        IFeeBurner feeBurner = addressProvider.getFeeBurner();\n        address targetLpToken = bkdLocker.rewardToken();\n        address[] memory pools = addressProvider.allPools();\n        uint256 ethBalance = address(this).balance;\n        address[] memory tokens = new address[](pools.length);\n        for (uint256 i; i < pools.length; i = i.uncheckedInc()) {\n            ILiquidityPool pool = ILiquidityPool(pools[i]);\n            address underlying = pool.getUnderlying();\n            if (underlying != address(0)) {\n                _approve(underlying, address(feeBurner));\n            }\n            tokens[i] = underlying;\n        }\n        feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);\n        uint256 burnedAmount = IERC20(targetLpToken).balanceOf(address(this));\n        IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);\n        bkdLocker.depositFees(burnedAmount);\n        emit Burned(targetLpToken, burnedAmount);\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) > 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/FeeBurner.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../interfaces/IFeeBurner.sol\";\nimport \"../../interfaces/ISwapperRouter.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\n\n/**\n * The Fee Burner converts all of the callers Backd LP Tokens to a single target Backd LP Token.\n * It first burns the Pool LP Tokens for the Pool underlying.\n * Then it swaps all the underlyings for the target Pool underlying.\n * Finally it deposits the Pool underlying into the target Pool to get the target LP Token.\n */\ncontract FeeBurner is IFeeBurner {\n    using SafeERC20 for IERC20;\n    using UncheckedMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n\n    IAddressProvider private immutable _addressProvider; // Address Provider, used for getting pools and swapper router\n\n    event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token\n\n    constructor(address addressProvider_) {\n        _addressProvider = IAddressProvider(addressProvider_);\n    }\n\n    receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool\n\n    /**\n     * @notice Converts callers Tokens to target Backd LP Token for the given tokens_.\n     * @param tokens_ The Tokens to convert to the targetLpToken_.\n     * @param targetLpToken_ The LP Token that should be received.\n     * @return received The amount of the target LP Token received.\n     */\n    function burnToTarget(address[] memory tokens_, address targetLpToken_)\n        public\n        payable\n        override\n        returns (uint256 received)\n    {\n        require(tokens_.length != 0, \"No tokens to burn\");\n\n        // Swapping tokens for WETH\n        ILiquidityPool targetPool_ = _addressProvider.getPoolForToken(targetLpToken_);\n        address targetUnderlying_ = targetPool_.getUnderlying();\n        ISwapperRouter swapperRouter_ = _swapperRouter();\n        bool burningEth_;\n        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) {\n            IERC20 token_ = IERC20(tokens_[i]);\n\n            // Handling ETH\n            if (address(token_) == address(0)) {\n                if (msg.value == 0) continue;\n                burningEth_ = true;\n                swapperRouter_.swapAll{value: msg.value}(address(token_), _WETH);\n                continue;\n            }\n\n            // Handling ERC20\n            uint256 tokenBalance_ = token_.balanceOf(msg.sender);\n            if (tokenBalance_ == 0) continue;\n            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_);\n            if (address(token_) == targetUnderlying_) continue;\n            _approve(address(token_), address(swapperRouter_));\n            swapperRouter_.swap(address(token_), _WETH, tokenBalance_);\n        }\n        require(burningEth_ || msg.value == 0, Error.INVALID_VALUE);\n\n        // Swapping WETH for target underlying\n        _approve(_WETH, address(swapperRouter_));\n        swapperRouter_.swapAll(_WETH, targetUnderlying_);\n\n        // Depositing target underlying into target pool\n        uint256 targetLpTokenBalance_ = _depositInPool(targetUnderlying_, targetPool_);\n\n        // Transfering LP tokens back to sender\n        IERC20(targetLpToken_).safeTransfer(msg.sender, targetLpTokenBalance_);\n        emit Burned(targetLpToken_, targetLpTokenBalance_);\n        return targetLpTokenBalance_;\n    }\n\n    /**\n     * @dev Deposits underlying into pool to receive LP Tokens.\n     * @param underlying_ The underlying of the pool.\n     * @param pool_ The pool to deposit into.\n     * @return received The amount of LP Tokens received.\n     */\n    function _depositInPool(address underlying_, ILiquidityPool pool_)\n        internal\n        returns (uint256 received)\n    {\n        // Handling ETH deposits\n        if (underlying_ == address(0)) {\n            uint256 ethBalance_ = address(this).balance;\n            return pool_.deposit{value: ethBalance_}(ethBalance_);\n        }\n\n        // Handling ERC20 deposits\n        _approve(underlying_, address(pool_));\n        return pool_.deposit(IERC20(underlying_).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Gets the swapper router.\n     * @return The swapper router.\n     */\n    function _swapperRouter() internal view returns (ISwapperRouter) {\n        return _addressProvider.getSwapperRouter();\n    }\n}"
    }
  ]
}