{
  "Title": "[M-05] If the underlying NFT is burned, getPFP may return incorrect results",
  "Content": "\nProfilePicture.getPFP will return information about the underlying NFT and when `addressRegistry.getAddress(cidNFTID) ! = ERC721(nftContract).ownerOf(nftID)`, it will return 0.\n\nBut if the underlying NFT is burned, getPFP may return incorrect information\n\n```solidity\n    function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {\n        if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);\n        ProfilePictureData storage pictureData = pfp[_pfpID];\n        nftContract = pictureData.nftContract;\n        nftID = pictureData.nftID;\n        uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);\n        IAddressRegistry addressRegistry = cidNFT.addressRegistry();\n        if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {\n            nftContract = address(0);\n            nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0\n        }\n    }\n```\n\nConsider the following scenario.\n\n1.  Alice mints a ProfilePicture NFT (pfp NFT) with the underlying NFT, and later mints a CidNFT by transferring the pfp NFT to the CidNFT contract.<br>\n    **Noting that alice does not call AddressRegistry.register to register the CidNFT.**<br>\n    Since getAddress returns 0, ProfilePicture.getPFP will also return 0.\n\n```solidity\n    function getAddress(uint256 _cidNFTID) external view returns (address user) {\n        user = ERC721(cidNFT).ownerOf(_cidNFTID);\n        if (_cidNFTID != cidNFTs[user]) {\n            // User owns CID NFT, but has not registered it\n            user = address(0);\n        }\n    }\n```\n\n2.  Alice sends the underlying NFT to Bob, who does what Alice did before.\n\n3.  Bob sold the underlying NFT to Charlie and Charlie burned it for some reason, now if Alice or Bob calls ProfilePicture.getPFP(), it will return the contract address and id of the underlying NFT since `getAddress() == ownerOf() == address(0)`.\n\nWhen integrating with other projects, there may be bugs because getPFP returns an incorrect result.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-pfp-protocol/src/ProfilePicture.sol#L94-L105><br>\n<https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-identity-protocol/src/AddressRegistry.sol#L86-L92>\n\n### Recommended Mitigation Steps\n\nChange to\n\n```diff\n    function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {\n        if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);\n        ProfilePictureData storage pictureData = pfp[_pfpID];\n        nftContract = pictureData.nftContract;\n        nftID = pictureData.nftID;\n        uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);\n        IAddressRegistry addressRegistry = cidNFT.addressRegistry();\n-       if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {\n+       if (cidNFTID == 0 || ERC721(nftContract).ownerOf(nftID) == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {\n            nftContract = address(0);\n            nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0\n        }\n    }\n```\n\n**[OpenCoreCH (Canto Identity) confirmed and commented](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/209#issuecomment-1489270847):**\n > Very interesting edge case, enjoyed reading it! For an ERC721 compliant NFT this is not the case, because the standard explicitly says:\n> ```\n>     /// @dev NFTs assigned to zero address are considered invalid, and queries\n>     ///  about them do throw.\n> ```\n> Therefore, the existing `ownerOf` will throw.\n> \n> However, in my experience there are some NFTs that do not adhere strictly to ERC721 when it comes to this. Because of that, I'll still implement a fix for this.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-03-canto-identity-subprotocols-contest",
  "Code": [
    {
      "filename": "canto-pfp-protocol/src/ProfilePicture.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport \"../interface/Turnstile.sol\";\nimport \"../interface/ICidNFT.sol\";\n\ncontract ProfilePicture is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reference to the CID NFT\n    ICidNFT private immutable cidNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Data that is stored per PFP\n    struct ProfilePictureData {\n        /// @notice Reference to the NFT contract\n        address nftContract;\n        /// @notice Referenced nft ID\n        uint256 nftID;\n    }\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the pfp data per NFT\n    mapping(uint256 => ProfilePictureData) private pfp;\n\n    /// @notice Name with which the subprotocol is registered\n    string public subprotocolName;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event PfpAdded(\n        address indexed minter,\n        uint256 indexed pfpNftID,\n        address indexed referencedContract,\n        uint256 referencedNftId\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error PFPNoLongerOwnedByOriginalOwner(uint256 tokenID);\n    error PFPNotOwnedByCaller(address caller, address nftContract, uint256 nftID);\n\n    /// @notice Initiates CSR on mainnet\n    /// @param _cidNFT Address of the CID NFT\n    /// @param _subprotocolName Name with which the subprotocol is / will be registered in the registry. Registration will not be performed automatically\n    constructor(address _cidNFT, string memory _subprotocolName) ERC721(\"Profile Picture\", \"PFP\") {\n        cidNFT = ICidNFT(_cidNFT);\n        subprotocolName = _subprotocolName;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    /// @dev Reverts if PFP is no longer owned by owner of associated CID NFT\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        (address nftContract, uint256 nftID) = getPFP(_id);\n        if (nftContract == address(0)) revert PFPNoLongerOwnedByOriginalOwner(_id);\n        return ERC721(nftContract).tokenURI(nftID);\n    }\n\n    /// @notice Mint a new PFP NFT\n    /// @param _nftContract The nft contract address to reference\n    /// @param _nftID The nft ID to reference\n    function mint(address _nftContract, uint256 _nftID) external {\n        uint256 tokenId = ++numMinted;\n        if (ERC721(_nftContract).ownerOf(_nftID) != msg.sender)\n            revert PFPNotOwnedByCaller(msg.sender, _nftContract, _nftID);\n        ProfilePictureData storage pictureData = pfp[tokenId];\n        pictureData.nftContract = _nftContract;\n        pictureData.nftID = _nftID;\n        _mint(msg.sender, tokenId);\n        emit PfpAdded(msg.sender, tokenId, _nftContract, _nftID);\n    }\n\n    /// @notice Query the referenced profile picture\n    /// @dev Checks if the PFP is still owned by the owner of the CID NFT\n    /// @param _pfpID Profile picture NFT ID to query\n    /// @return nftContract The referenced NFT contract (address(0) if no longer owned), nftID The referenced NFT ID\n    function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {\n        if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);\n        ProfilePictureData storage pictureData = pfp[_pfpID];\n        nftContract = pictureData.nftContract;\n        nftID = pictureData.nftID;\n        uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);\n        IAddressRegistry addressRegistry = cidNFT.addressRegistry();\n        if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {\n            nftContract = address(0);\n            nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0\n        }\n    }\n}"
    },
    {
      "filename": "canto-identity-protocol/src/AddressRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"../interface/Turnstile.sol\";\n\n/// @title Address Registry\n/// @notice Allows users to register their CID NFT\ncontract AddressRegistry {\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address of the CID NFT\n    address public immutable cidNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Stores the mappings of users to their CID NFT\n    mapping(address => uint256) private cidNFTs;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event CIDNFTAdded(address indexed user, uint256 indexed cidNFTID);\n    event CIDNFTRemoved(address indexed user, uint256 indexed cidNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error NFTNotOwnedByUser(uint256 cidNFTID, address caller);\n    error NoCIDNFTRegisteredForUser(address caller);\n    error RemoveOnTransferOnlyCallableByCIDNFT();\n\n    /// @param _cidNFT Address of the CID NFT contract\n    constructor(address _cidNFT) {\n        cidNFT = _cidNFT;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Register a CID NFT to the address of the caller. NFT has to be owned by the caller\n    /// @dev Will overwrite existing registration if any exists\n    function register(uint256 _cidNFTID) external {\n        if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender)\n            // ownerOf reverts if non-existing ID is provided\n            revert NFTNotOwnedByUser(_cidNFTID, msg.sender);\n        cidNFTs[msg.sender] = _cidNFTID;\n        emit CIDNFTAdded(msg.sender, _cidNFTID);\n    }\n\n    /// @notice Remove the current registration of the caller\n    function remove() external {\n        uint256 cidNFTID = cidNFTs[msg.sender];\n        if (cidNFTID == 0) revert NoCIDNFTRegisteredForUser(msg.sender);\n        delete cidNFTs[msg.sender];\n        emit CIDNFTRemoved(msg.sender, cidNFTID);\n    }\n\n    /// @notice Called by the CID NFT contract on transfers to remove an existing association\n    /// @param _transferFrom Current owner of the CID NFT\n    /// @param _cidNFTID Transferred CID NFT ID\n    function removeOnTransfer(address _transferFrom, uint256 _cidNFTID) external {\n        if (msg.sender != cidNFT) revert RemoveOnTransferOnlyCallableByCIDNFT();\n        uint256 cidNFTIDRegistered = cidNFTs[_transferFrom];\n        if (cidNFTIDRegistered != _cidNFTID) return; // Was not registered\n        delete cidNFTs[_transferFrom];\n        emit CIDNFTRemoved(_transferFrom, cidNFTIDRegistered);\n    }\n\n    /// @notice Get the CID NFT ID that is registered for the provided user\n    /// @param _user Address to query\n    /// @return cidNFTID The registered CID NFT ID. 0 when no CID NFT is registered for the given address\n    function getCID(address _user) external view returns (uint256 cidNFTID) {\n        cidNFTID = cidNFTs[_user];\n    }\n\n    /// @notice Get the address that is registered for a given CID NFT ID\n    /// @param _cidNFTID CID NFT ID to query\n    /// @return user The user that is currently registered for the given CID NFT. address(0) if no user is registered\n    function getAddress(uint256 _cidNFTID) external view returns (address user) {\n        user = ERC721(cidNFT).ownerOf(_cidNFTID);\n        if (_cidNFTID != cidNFTs[user]) {\n            // User owns CID NFT, but has not registered it\n            user = address(0);\n        }\n    }\n}"
    }
  ]
}