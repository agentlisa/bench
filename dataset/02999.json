{
  "Title": "M-20: UniV2Adapter#getExecutionData doesn't properly handle native ETH swaps",
  "Content": "# Issue M-20: UniV2Adapter#getExecutionData doesn't properly handle native ETH swaps \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/33 \n\n## Found by \nChom, 0x52\n\n## Summary\n\nUniV2Adapter#getExecutionData doesn't properly account for native ETH trades which makes them impossible. Neither method selected supports direct ETH trades, and sender/target are not set correctly for TradingUtils_executeTrade to automatically convert\n\n## Vulnerability Detail\n\n    spender = address(Deployments.UNIV2_ROUTER);\n    target = address(Deployments.UNIV2_ROUTER);\n    // msgValue is always zero for uniswap\n\n    if (\n        tradeType == TradeType.EXACT_IN_SINGLE ||\n        tradeType == TradeType.EXACT_IN_BATCH\n    ) {\n        executionCallData = abi.encodeWithSelector(\n            IUniV2Router2.swapExactTokensForTokens.selector,\n            trade.amount,\n            trade.limit,\n            data.path,\n            from,\n            trade.deadline\n        );\n    } else if (\n        tradeType == TradeType.EXACT_OUT_SINGLE ||\n        tradeType == TradeType.EXACT_OUT_BATCH\n    ) {\n        executionCallData = abi.encodeWithSelector(\n            IUniV2Router2.swapTokensForExactTokens.selector,\n            trade.amount,\n            trade.limit,\n            data.path,\n            from,\n            trade.deadline\n        );\n    }\n\nUniV2Adapter#getExecutionData either returns the swapTokensForExactTokens or swapExactTokensForTokens, neither of with support native ETH. It also doesn't set spender and target like UniV3Adapter, so _executeTrade won't automatically convert it to a WETH call. The result is that all Uniswap V2 calls made with native ETH will fail. Given that Notional operates in native ETH rather than WETH, this is an important feature that currently does not function.\n\n## Impact\n\nUniswap V2 calls won't support native ETH\n\n## Code Snippet\n\n[UniV2Adapter.sol#L12-L52](https://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/adapters/UniV2Adapter.sol#L12-L52)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere are two possible solutions:\n\n1) Change the way that target and sender are set to match the implementation in UniV3Adapter\n2) Modify the return data to return the correct selector for each case (swapExactETHForTokens, swapTokensForExactETH, etc.)\n\nGiven that the infrastructure for Uniswap V3 already exists in TradingUtils_executeTrade the first option would be the easiest, and would give the same results considering it's basically the same as what the router is doing internally anyways.\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000 \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/trading/adapters/UniV2Adapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../../../interfaces/trading/ITradingModule.sol\";\nimport \"../../../interfaces/uniswap/v2/IUniV2Router2.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\n\nlibrary UniV2Adapter {\n\n    struct UniV2Data { address[] path; }\n\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 /* msgValue */,\n            bytes memory executionCallData\n        )\n    {\n        TradeType tradeType = trade.tradeType;\n        UniV2Data memory data = abi.decode(trade.exchangeData, (UniV2Data));\n\n        spender = address(Deployments.UNIV2_ROUTER);\n        target = address(Deployments.UNIV2_ROUTER);\n        // msgValue is always zero for uniswap\n\n        if (\n            tradeType == TradeType.EXACT_IN_SINGLE ||\n            tradeType == TradeType.EXACT_IN_BATCH\n        ) {\n            executionCallData = abi.encodeWithSelector(\n                IUniV2Router2.swapExactTokensForTokens.selector,\n                trade.amount,\n                trade.limit,\n                data.path,\n                from,\n                trade.deadline\n            );\n        } else if (\n            tradeType == TradeType.EXACT_OUT_SINGLE ||\n            tradeType == TradeType.EXACT_OUT_BATCH\n        ) {\n            executionCallData = abi.encodeWithSelector(\n                IUniV2Router2.swapTokensForExactTokens.selector,\n                trade.amount,\n                trade.limit,\n                data.path,\n                from,\n                trade.deadline\n            );\n        }\n    }\n}"
    }
  ]
}