{
  "Title": "[G-05] Cache external call to avoid re-calling same external function",
  "Content": "\nSince ` IYieldToken(_yt).decimals()` and `IERC20Metadata(_yt).decimals()` are calling same `decimals()` function on same `_yt` address contract. That means both call will return same result since same function on same contract called just interface to prepare instances are different but underlying decimals definition is same so this call can be cached after at first call instead of re-calling in same function twice.\n\nThis call is called to YieldToken decimals function.\nSo it saves 1 External call which includes another external call in YieldToken decimals function. So it saves a lot of gas caching ` IYieldToken(_yt).decimals()` in PrincipalTokenUtil::_computeYield function.\n\n```solidity\nFile : src/libraries/PrincipalTokenUtil.sol\n\n55:       function _computeYield(\n...        \n68:        uint256 userYTBalanceInRay = IYieldToken(_yt).actualBalanceOf(_user).toRay(\n69:            IYieldToken(_yt).decimals() //@audit cache this\n70:        );\n...        \n129:        return _userYieldIBT + newYieldInIBTRay.fromRay(IERC20Metadata(_yt).decimals());//@audit use cached valued instead of re-calling decimals()\n130:    }\n```\n(https://github.com/code-423n4/2024-02-spectra/blob/main/src/libraries/PrincipalTokenUtil.sol#L55C1-L130C6)\n\n\n```solidity\n\n15:    contract YieldToken is IYieldToken, ERC20PermitUpgradeable {\n...\n105:    function decimals()\n106:        public\n107:        view\n108:        virtual\n109:        override(IYieldToken, ERC20Upgradeable)\n110:        returns (uint8)\n111:    {\n112:        return IERC20Metadata(pt).decimals();\n113:    }\n\n```\n\n(https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/YieldToken.sol#L105C1-L113C6)\n\n**Recommended Mitigation Steps:**\n\n```diff\nFile : src/libraries/PrincipalTokenUtil.sol\n\n55:       function _computeYield(\n...        \n+           uint256 _ytDecimals = IYieldToken(_yt).decimals();\n  68:        uint256 userYTBalanceInRay = IYieldToken(_yt).actualBalanceOf(_user).toRay(\n- 69:            IYieldToken(_yt).decimals()\n+ 69:            _ytDecimals\n  70:        );\n\n        ...      \n\n- 129:        return _userYieldIBT + newYieldInIBTRay.fromRay(IERC20Metadata(_yt).decimals());\n+ 129:        return _userYieldIBT + newYieldInIBTRay.fromRay(_ytDecimals);\n130:    }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-spectra",
  "Code": [
    {
      "filename": "src/libraries/PrincipalTokenUtil.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"../interfaces/IYieldToken.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport \"openzeppelin-math/Math.sol\";\nimport \"../libraries/RayMath.sol\";\n\nlibrary PrincipalTokenUtil {\n    using Math for uint256;\n    using RayMath for uint256;\n\n    error AssetDoesNotImplementMetadata();\n\n    uint256 private constant SAFETY_BOUND = 100; // used to favour the protocol in case of approximations\n    uint256 private constant FEE_DIVISOR = 1e18; // equivalent to 100% fees\n\n    /** @dev See {IPrincipalToken-convertToSharesWithRate}. */\n    function _convertToSharesWithRate(\n        uint256 _assets,\n        uint256 _rate,\n        uint256 _ibtUnit,\n        Math.Rounding _rounding\n    ) internal pure returns (uint256 shares) {\n        if (_rate == 0) {\n            revert IPrincipalToken.RateError();\n        }\n        return _assets.mulDiv(_ibtUnit, _rate, _rounding);\n    }\n\n    /** @dev See {IPrincipalToken-convertToAssetsWithRate}. */\n    function _convertToAssetsWithRate(\n        uint256 _shares,\n        uint256 _rate,\n        uint256 _ibtUnit,\n        Math.Rounding _rounding\n    ) internal pure returns (uint256 assets) {\n        return _shares.mulDiv(_rate, _ibtUnit, _rounding);\n    }\n\n    /**\n     * @dev Computes the yield for a specified user since the last update.\n     * @param _user The address for which the yield is to be calculated.\n     * @param _userYieldIBT the current yield of user in IBT\n     * @param _oldIBTRate the previous deposit IBT rate of user (in Ray)\n     * @param _ibtRate the current IBT rate (in Ray)\n     * @param _oldPTRate the previous deposit pt rate of user (in Ray)\n     * @param _ptRate the current PT rate (in Ray)\n     * @param _yt the address of YT\n     * @return returns the calculated yield in IBT of user\n     */\n    function _computeYield(\n        address _user,\n        uint256 _userYieldIBT,\n        uint256 _oldIBTRate,\n        uint256 _ibtRate,\n        uint256 _oldPTRate,\n        uint256 _ptRate,\n        address _yt\n    ) external view returns (uint256) {\n        if (_oldPTRate == _ptRate && _ibtRate == _oldIBTRate) {\n            return _userYieldIBT;\n        }\n        uint256 newYieldInIBTRay;\n        uint256 userYTBalanceInRay = IYieldToken(_yt).actualBalanceOf(_user).toRay(\n            IYieldToken(_yt).decimals()\n        );\n        // ibtOfPT is the yield generated by each PT corresponding to the YTs that the user holds\n        uint256 ibtOfPTInRay = userYTBalanceInRay.mulDiv(_oldPTRate, _oldIBTRate);\n        if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {\n            // only positive yield happened\n            newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);\n        } else {\n            if (_oldPTRate > _ptRate) {\n                // PT depeg happened\n                uint256 yieldInAssetRay;\n                if (_ibtRate >= _oldIBTRate) {\n                    // both negative and positive yield happened, more positive\n                    yieldInAssetRay =\n                        _convertToAssetsWithRate(\n                            userYTBalanceInRay,\n                            _oldPTRate - _ptRate,\n                            RayMath.RAY_UNIT,\n                            Math.Rounding.Floor\n                        ) +\n                        _convertToAssetsWithRate(\n                            ibtOfPTInRay,\n                            _ibtRate - _oldIBTRate,\n                            RayMath.RAY_UNIT,\n                            Math.Rounding.Floor\n                        );\n                } else {\n                    // either both negative and positive yield happened, more negative\n                    // or only negative yield happened\n                    uint256 actualNegativeYieldInAssetRay = _convertToAssetsWithRate(\n                        userYTBalanceInRay,\n                        _oldPTRate - _ptRate,\n                        RayMath.RAY_UNIT,\n                        Math.Rounding.Floor\n                    );\n                    uint256 expectedNegativeYieldInAssetRay = Math.ceilDiv(\n                        ibtOfPTInRay * (_oldIBTRate - _ibtRate),\n                        RayMath.RAY_UNIT\n                    );\n                    yieldInAssetRay = expectedNegativeYieldInAssetRay >\n                        actualNegativeYieldInAssetRay\n                        ? 0\n                        : actualNegativeYieldInAssetRay - expectedNegativeYieldInAssetRay;\n                    yieldInAssetRay = yieldInAssetRay.fromRay(\n                        IERC4626(IPrincipalToken(IYieldToken(_yt).getPT()).underlying()).decimals()\n                    ) < SAFETY_BOUND\n                        ? 0\n                        : yieldInAssetRay;\n                }\n                newYieldInIBTRay = _convertToSharesWithRate(\n                    yieldInAssetRay,\n                    _ibtRate,\n                    RayMath.RAY_UNIT,\n                    Math.Rounding.Floor\n                );\n            } else {\n                // PT rate increased or did not depeg on IBT rate decrease\n                revert IPrincipalToken.RateError();\n            }\n        }\n        return _userYieldIBT + newYieldInIBTRay.fromRay(IERC20Metadata(_yt).decimals());\n    }\n\n    /**\n     * @dev Attempts to fetch the token decimals. Reverts if the attempt failed in some way.\n     * @param _token The token address\n     * @return The ERC20 token decimals\n     */\n    function _tryGetTokenDecimals(address _token) external view returns (uint8) {\n        (bool success, bytes memory encodedDecimals) = _token.staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return uint8(returnedDecimals);\n            }\n        }\n        revert AssetDoesNotImplementMetadata();\n    }\n\n    /**\n     * @dev Compute tokenization fee for a given amount\n     * @param _amount The amount to tokenize\n     * @param _pt The address of the pt on which the fee is being paid\n     * @param _registry The address of registry that stores fee rate\n     * @return returns The calculated tokenization fee\n     */\n    function _computeTokenizationFee(\n        uint256 _amount,\n        address _pt,\n        address _registry\n    ) internal view returns (uint256) {\n        return\n            _amount\n                .mulDiv(IRegistry(_registry).getTokenizationFee(), FEE_DIVISOR, Math.Rounding.Ceil)\n                .mulDiv(\n                    FEE_DIVISOR - IRegistry(_registry).getFeeReduction(_pt, msg.sender),\n                    FEE_DIVISOR,\n                    Math.Rounding.Ceil\n                );\n    }\n\n    /**\n     * @dev Compute yield fee for a given amount\n     * @param _amount the amount of yield\n     * @param _registry the address of registry that stores fee rate\n     * @return returns the calculated yield fee\n     */\n    function _computeYieldFee(uint256 _amount, address _registry) internal view returns (uint256) {\n        return _amount.mulDiv(IRegistry(_registry).getYieldFee(), FEE_DIVISOR, Math.Rounding.Ceil);\n    }\n\n    /**\n     * @dev Compute flashloan fee for a given amount\n     * @param _amount the amount to flashloan\n     * @param _registry the address of registry that stores fee rate\n     * @return returns the calculated flashloan fee\n     */\n    function _computeFlashloanFee(\n        uint256 _amount,\n        address _registry\n    ) internal view returns (uint256) {\n        return\n            _amount.mulDiv(\n                IRegistry(_registry).getPTFlashLoanFee(),\n                FEE_DIVISOR,\n                Math.Rounding.Ceil\n            );\n    }\n}"
    },
    {
      "filename": "src/tokens/YieldToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"openzeppelin-erc20-extensions/ERC20PermitUpgradeable.sol\";\nimport \"openzeppelin-erc20-basic/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"../interfaces/IYieldToken.sol\";\n\n/**\n * @title Yield Token contract\n * @notice A YieldToken (YT) is a Spectra token that keeps track of users' yield ownership. It is minted at same times and amounts as a PT.\n */\ncontract YieldToken is IYieldToken, ERC20PermitUpgradeable {\n    using Math for uint256;\n\n    address private pt;\n\n    // constructor\n    constructor() {\n        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.\n    }\n\n    /**\n     * @notice Initializer of the contract.\n     * @param _name The name of the yt token.\n     * @param _symbol The symbol of the yt token.\n     * @param _pt The address of the pt associated with this yt token.\n     */\n    function initialize(\n        string calldata _name,\n        string calldata _symbol,\n        address _pt\n    ) external initializer {\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n        pt = _pt;\n    }\n\n    /** @dev See {IYieldToken-burnWithoutUpdate} */\n    function burnWithoutUpdate(address from, uint256 amount) external override {\n        if (msg.sender != pt) {\n            revert CallerIsNotPtContract();\n        }\n        _burn(from, amount);\n    }\n\n    /** @dev See {IYieldToken-mint} */\n    function mint(address to, uint256 amount) external override {\n        if (msg.sender != pt) {\n            revert CallerIsNotPtContract();\n        }\n        _mint(to, amount);\n    }\n\n    /** @dev See {IYieldToken-burn} */\n    function burn(uint256 amount) public override {\n        IPrincipalToken(pt).updateYield(msg.sender);\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {\n        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {\n        IPrincipalToken(pt).beforeYtTransfer(from, to);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /** @dev See {IERC20Upgradeable-decimals} */\n    function decimals()\n        public\n        view\n        virtual\n        override(IYieldToken, ERC20Upgradeable)\n        returns (uint8)\n    {\n        return IERC20Metadata(pt).decimals();\n    }\n\n    /** @dev See {IYieldToken-getPT} */\n    function getPT() public view virtual override returns (address) {\n        return pt;\n    }\n\n    /** @dev See {IYieldToken-balanceOf} */\n    function balanceOf(\n        address account\n    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {\n        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;\n    }\n\n    /** @dev See {IYieldToken-actualBalanceOf} */\n    function actualBalanceOf(address account) public view override returns (uint256) {\n        return super.balanceOf(account);\n    }\n}"
    }
  ]
}