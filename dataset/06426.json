{
  "Title": "[M-12] `ValidatorWithdrawalVault.settleFunds` doesn't check amount that user has inside `NodeELRewardVault` to pay for penalty",
  "Content": "\n`ValidatorWithdrawalVault.settleFunds` doesn't check amount that user has inside `NodeELRewardVault` to pay for penalty. That value can increase operator's earned amount, which can avoid slashing.\n\n### Proof of Concept\n\nWhen a validator withdraws from beacon chain the `ValidatorWithdrawalVault.settleFunds` function is called. This function calculates amount that a validator [has earned](https://github.com/code-423n4/2023-06-stader/blob/main/contracts/ValidatorWithdrawalVault.sol#L62) for attestations as a validator. So only the balance of this contract [is considered](https://github.com/code-423n4/2023-06-stader/blob/main/contracts/ValidatorWithdrawalVault.sol#L99).\n\nThe function [fetches penalty amount](https://github.com/code-423n4/2023-06-stader/blob/main/contracts/ValidatorWithdrawalVault.sol#L64). This penalty amount contains [of 3 points](https://github.com/code-423n4/2023-06-stader/blob/main/contracts/Penalty.sol#L111): `_mevTheftPenalty`, `_missedAttestationPenalty` and `_missedAttestationPenalty`.\n\nIn this case, if the penalty amount is bigger than the validator's earning on `ValidatorWithdrawalVault`, the [SD collateral is slashed](https://github.com/code-423n4/2023-06-stader/blob/main/contracts/ValidatorWithdrawalVault.sol#L66-L69).\n\nNow, we need to understand how validator receives funds in this system. All attestation payments come to `ValidatorWithdrawalVault`, while `mev`/`block` proposal funds are coming to `SocializingPool` or `NodeELRewardVault` (depends on user's choice). So actually, `_missedAttestationPenalty` is responding to `ValidatorWithdrawalVault` earning, while `_mevTheftPenalty` is responding to `NodeELRewardVault` earnings.\n\nThat means, `NodeELRewardVault` balance should also be checked in order to find out how many earnings a validator has and they should be also counted when applying the penalty.\n\nSimple example:\n1. A validator wants to exit.\n2. An operator earning is 0.1 eth inside `ValidatorWithdrawalVault`.\n3. The accrued penalty is 0.11, which means the user will be slashed.\n4. The operator also has `NodeELRewardVault` where their operator's reward is 0.05 eth.\n5. As result, the user has enough balance to cover penalty, but they were still penalized.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nAs you accrue `_mevTheftPenalty` inside `ValidatorWithdrawalVault`, you also should calculate the operator's rewards inside `NodeELRewardVault`.\n\n### Assessed type\n\nError\n\n**[manoj9april (Stader) acknowledged and commented](https://github.com/code-423n4/2022-06-stader-findings/issues/84#issuecomment-1596567203):**\n > Rewards are treated separately between CL and EL. We will take this suggestion into account for next upgrades.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-06-stader-findings/issues/84#issuecomment-1616855027):**\n > Keeping medium severity as this report shows how an operator could be slashed, despite having earned more than the penalty if we combine EL and CL rewards, which could lead to a loss of funds.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-stader",
  "Code": [
    {
      "filename": "contracts/ValidatorWithdrawalVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\nimport './library/ValidatorStatus.sol';\n\nimport './VaultProxy.sol';\nimport './interfaces/IPenalty.sol';\nimport './interfaces/IPoolUtils.sol';\nimport './interfaces/INodeRegistry.sol';\nimport './interfaces/IStaderStakePoolManager.sol';\nimport './interfaces/IValidatorWithdrawalVault.sol';\nimport './interfaces/SDCollateral/ISDCollateral.sol';\nimport './interfaces/IOperatorRewardsCollector.sol';\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\ncontract ValidatorWithdrawalVault is IValidatorWithdrawalVault {\n    bool internal vaultSettleStatus;\n    using Math for uint256;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {}\n\n    // Allows the contract to receive ETH\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    function distributeRewards() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 totalRewards = address(this).balance;\n        if (!staderConfig.onlyOperatorRole(msg.sender) && totalRewards > staderConfig.getRewardsThreshold()) {\n            emit DistributeRewardFailed(totalRewards, staderConfig.getRewardsThreshold());\n            revert InvalidRewardAmount();\n        }\n        if (totalRewards == 0) {\n            revert NotEnoughRewardToDistribute();\n        }\n        (uint256 userShare, uint256 operatorShare, uint256 protocolShare) = IPoolUtils(staderConfig.getPoolUtils())\n            .calculateRewardShare(poolId, totalRewards);\n\n        // Distribute rewards\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit DistributedRewards(userShare, operatorShare, protocolShare);\n    }\n\n    function settleFunds() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        address nodeRegistry = IPoolUtils(staderConfig.getPoolUtils()).getNodeRegistry(poolId);\n        if (msg.sender != nodeRegistry) {\n            revert CallerNotNodeRegistryContract();\n        }\n        (uint256 userSharePrelim, uint256 operatorShare, uint256 protocolShare) = calculateValidatorWithdrawalShare();\n\n        uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);\n\n        if (operatorShare < penaltyAmount) {\n            ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);\n            penaltyAmount = operatorShare;\n        }\n\n        uint256 userShare = userSharePrelim + penaltyAmount;\n        operatorShare = operatorShare - penaltyAmount;\n\n        // Final settlement\n        vaultSettleStatus = true;\n        IPenalty(staderConfig.getPenaltyContract()).markValidatorSettled(poolId, validatorId);\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit SettledFunds(userShare, operatorShare, protocolShare);\n    }\n\n    function calculateValidatorWithdrawalShare()\n        public\n        view\n        returns (\n            uint256 _userShare,\n            uint256 _operatorShare,\n            uint256 _protocolShare\n        )\n    {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 TOTAL_STAKED_ETH = staderConfig.getStakedEthPerNode();\n        uint256 collateralETH = getCollateralETH(poolId, staderConfig); // 0, incase of permissioned NOs\n        uint256 usersETH = TOTAL_STAKED_ETH - collateralETH;\n        uint256 contractBalance = address(this).balance;\n\n        uint256 totalRewards;\n\n        if (contractBalance <= usersETH) {\n            _userShare = contractBalance;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else if (contractBalance <= TOTAL_STAKED_ETH) {\n            _userShare = usersETH;\n            _operatorShare = contractBalance - _userShare;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else {\n            totalRewards = contractBalance - TOTAL_STAKED_ETH;\n            _operatorShare = collateralETH;\n            _userShare = usersETH;\n        }\n        if (totalRewards > 0) {\n            (uint256 userReward, uint256 operatorReward, uint256 protocolReward) = IPoolUtils(\n                staderConfig.getPoolUtils()\n            ).calculateRewardShare(poolId, totalRewards);\n            _userShare += userReward;\n            _operatorShare += operatorReward;\n            _protocolShare += protocolReward;\n        }\n    }\n\n    // HELPER METHODS\n\n    function getCollateralETH(uint8 _poolId, IStaderConfig _staderConfig) internal view returns (uint256) {\n        return IPoolUtils(_staderConfig.getPoolUtils()).getCollateralETH(_poolId);\n    }\n\n    function getOperatorAddress(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal view returns (address) {\n        return UtilLib.getOperatorAddressByValidatorId(_poolId, _validatorId, _staderConfig);\n    }\n\n    function getUpdatedPenaltyAmount(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal returns (uint256) {\n        address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);\n        (, bytes memory pubkey, , , , , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);\n        bytes[] memory pubkeyArray = new bytes[](1);\n        pubkeyArray[0] = pubkey;\n        IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray);\n        return IPenalty(_staderConfig.getPenaltyContract()).totalPenaltyAmount(pubkey);\n    }\n}"
    },
    {
      "filename": "contracts/ValidatorWithdrawalVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\nimport './library/ValidatorStatus.sol';\n\nimport './VaultProxy.sol';\nimport './interfaces/IPenalty.sol';\nimport './interfaces/IPoolUtils.sol';\nimport './interfaces/INodeRegistry.sol';\nimport './interfaces/IStaderStakePoolManager.sol';\nimport './interfaces/IValidatorWithdrawalVault.sol';\nimport './interfaces/SDCollateral/ISDCollateral.sol';\nimport './interfaces/IOperatorRewardsCollector.sol';\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\ncontract ValidatorWithdrawalVault is IValidatorWithdrawalVault {\n    bool internal vaultSettleStatus;\n    using Math for uint256;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {}\n\n    // Allows the contract to receive ETH\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    function distributeRewards() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 totalRewards = address(this).balance;\n        if (!staderConfig.onlyOperatorRole(msg.sender) && totalRewards > staderConfig.getRewardsThreshold()) {\n            emit DistributeRewardFailed(totalRewards, staderConfig.getRewardsThreshold());\n            revert InvalidRewardAmount();\n        }\n        if (totalRewards == 0) {\n            revert NotEnoughRewardToDistribute();\n        }\n        (uint256 userShare, uint256 operatorShare, uint256 protocolShare) = IPoolUtils(staderConfig.getPoolUtils())\n            .calculateRewardShare(poolId, totalRewards);\n\n        // Distribute rewards\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit DistributedRewards(userShare, operatorShare, protocolShare);\n    }\n\n    function settleFunds() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        address nodeRegistry = IPoolUtils(staderConfig.getPoolUtils()).getNodeRegistry(poolId);\n        if (msg.sender != nodeRegistry) {\n            revert CallerNotNodeRegistryContract();\n        }\n        (uint256 userSharePrelim, uint256 operatorShare, uint256 protocolShare) = calculateValidatorWithdrawalShare();\n\n        uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);\n\n        if (operatorShare < penaltyAmount) {\n            ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);\n            penaltyAmount = operatorShare;\n        }\n\n        uint256 userShare = userSharePrelim + penaltyAmount;\n        operatorShare = operatorShare - penaltyAmount;\n\n        // Final settlement\n        vaultSettleStatus = true;\n        IPenalty(staderConfig.getPenaltyContract()).markValidatorSettled(poolId, validatorId);\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit SettledFunds(userShare, operatorShare, protocolShare);\n    }\n\n    function calculateValidatorWithdrawalShare()\n        public\n        view\n        returns (\n            uint256 _userShare,\n            uint256 _operatorShare,\n            uint256 _protocolShare\n        )\n    {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 TOTAL_STAKED_ETH = staderConfig.getStakedEthPerNode();\n        uint256 collateralETH = getCollateralETH(poolId, staderConfig); // 0, incase of permissioned NOs\n        uint256 usersETH = TOTAL_STAKED_ETH - collateralETH;\n        uint256 contractBalance = address(this).balance;\n\n        uint256 totalRewards;\n\n        if (contractBalance <= usersETH) {\n            _userShare = contractBalance;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else if (contractBalance <= TOTAL_STAKED_ETH) {\n            _userShare = usersETH;\n            _operatorShare = contractBalance - _userShare;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else {\n            totalRewards = contractBalance - TOTAL_STAKED_ETH;\n            _operatorShare = collateralETH;\n            _userShare = usersETH;\n        }\n        if (totalRewards > 0) {\n            (uint256 userReward, uint256 operatorReward, uint256 protocolReward) = IPoolUtils(\n                staderConfig.getPoolUtils()\n            ).calculateRewardShare(poolId, totalRewards);\n            _userShare += userReward;\n            _operatorShare += operatorReward;\n            _protocolShare += protocolReward;\n        }\n    }\n\n    // HELPER METHODS\n\n    function getCollateralETH(uint8 _poolId, IStaderConfig _staderConfig) internal view returns (uint256) {\n        return IPoolUtils(_staderConfig.getPoolUtils()).getCollateralETH(_poolId);\n    }\n\n    function getOperatorAddress(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal view returns (address) {\n        return UtilLib.getOperatorAddressByValidatorId(_poolId, _validatorId, _staderConfig);\n    }\n\n    function getUpdatedPenaltyAmount(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal returns (uint256) {\n        address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);\n        (, bytes memory pubkey, , , , , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);\n        bytes[] memory pubkeyArray = new bytes[](1);\n        pubkeyArray[0] = pubkey;\n        IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray);\n        return IPenalty(_staderConfig.getPenaltyContract()).totalPenaltyAmount(pubkey);\n    }\n}"
    },
    {
      "filename": "contracts/ValidatorWithdrawalVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\nimport './library/ValidatorStatus.sol';\n\nimport './VaultProxy.sol';\nimport './interfaces/IPenalty.sol';\nimport './interfaces/IPoolUtils.sol';\nimport './interfaces/INodeRegistry.sol';\nimport './interfaces/IStaderStakePoolManager.sol';\nimport './interfaces/IValidatorWithdrawalVault.sol';\nimport './interfaces/SDCollateral/ISDCollateral.sol';\nimport './interfaces/IOperatorRewardsCollector.sol';\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\ncontract ValidatorWithdrawalVault is IValidatorWithdrawalVault {\n    bool internal vaultSettleStatus;\n    using Math for uint256;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {}\n\n    // Allows the contract to receive ETH\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    function distributeRewards() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 totalRewards = address(this).balance;\n        if (!staderConfig.onlyOperatorRole(msg.sender) && totalRewards > staderConfig.getRewardsThreshold()) {\n            emit DistributeRewardFailed(totalRewards, staderConfig.getRewardsThreshold());\n            revert InvalidRewardAmount();\n        }\n        if (totalRewards == 0) {\n            revert NotEnoughRewardToDistribute();\n        }\n        (uint256 userShare, uint256 operatorShare, uint256 protocolShare) = IPoolUtils(staderConfig.getPoolUtils())\n            .calculateRewardShare(poolId, totalRewards);\n\n        // Distribute rewards\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit DistributedRewards(userShare, operatorShare, protocolShare);\n    }\n\n    function settleFunds() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        address nodeRegistry = IPoolUtils(staderConfig.getPoolUtils()).getNodeRegistry(poolId);\n        if (msg.sender != nodeRegistry) {\n            revert CallerNotNodeRegistryContract();\n        }\n        (uint256 userSharePrelim, uint256 operatorShare, uint256 protocolShare) = calculateValidatorWithdrawalShare();\n\n        uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);\n\n        if (operatorShare < penaltyAmount) {\n            ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);\n            penaltyAmount = operatorShare;\n        }\n\n        uint256 userShare = userSharePrelim + penaltyAmount;\n        operatorShare = operatorShare - penaltyAmount;\n\n        // Final settlement\n        vaultSettleStatus = true;\n        IPenalty(staderConfig.getPenaltyContract()).markValidatorSettled(poolId, validatorId);\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit SettledFunds(userShare, operatorShare, protocolShare);\n    }\n\n    function calculateValidatorWithdrawalShare()\n        public\n        view\n        returns (\n            uint256 _userShare,\n            uint256 _operatorShare,\n            uint256 _protocolShare\n        )\n    {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 TOTAL_STAKED_ETH = staderConfig.getStakedEthPerNode();\n        uint256 collateralETH = getCollateralETH(poolId, staderConfig); // 0, incase of permissioned NOs\n        uint256 usersETH = TOTAL_STAKED_ETH - collateralETH;\n        uint256 contractBalance = address(this).balance;\n\n        uint256 totalRewards;\n\n        if (contractBalance <= usersETH) {\n            _userShare = contractBalance;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else if (contractBalance <= TOTAL_STAKED_ETH) {\n            _userShare = usersETH;\n            _operatorShare = contractBalance - _userShare;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else {\n            totalRewards = contractBalance - TOTAL_STAKED_ETH;\n            _operatorShare = collateralETH;\n            _userShare = usersETH;\n        }\n        if (totalRewards > 0) {\n            (uint256 userReward, uint256 operatorReward, uint256 protocolReward) = IPoolUtils(\n                staderConfig.getPoolUtils()\n            ).calculateRewardShare(poolId, totalRewards);\n            _userShare += userReward;\n            _operatorShare += operatorReward;\n            _protocolShare += protocolReward;\n        }\n    }\n\n    // HELPER METHODS\n\n    function getCollateralETH(uint8 _poolId, IStaderConfig _staderConfig) internal view returns (uint256) {\n        return IPoolUtils(_staderConfig.getPoolUtils()).getCollateralETH(_poolId);\n    }\n\n    function getOperatorAddress(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal view returns (address) {\n        return UtilLib.getOperatorAddressByValidatorId(_poolId, _validatorId, _staderConfig);\n    }\n\n    function getUpdatedPenaltyAmount(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal returns (uint256) {\n        address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);\n        (, bytes memory pubkey, , , , , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);\n        bytes[] memory pubkeyArray = new bytes[](1);\n        pubkeyArray[0] = pubkey;\n        IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray);\n        return IPenalty(_staderConfig.getPenaltyContract()).totalPenaltyAmount(pubkey);\n    }\n}"
    }
  ]
}