{
  "Title": "[H-02] Token Change Can Be Frontrun, Blocking Token",
  "Content": "# Lines of code\n\nhttps://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L246\nhttps://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L266\nhttps://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L605\n\n\n# Vulnerability details\n\n## Impact\nThis vulnerability allows malicious actors to block other users from changing tokens of their projects. Furthermore if ownership over the token contract is transferred to the `JBTokenStore` contract prior to the change, as suggested in the [recourse section of Juicebox's 24.05.2022 post-mortem update](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/main/security/postmortem/5.24.2022.md#Recourse), this vulnerability would allow an attacker to become the owner of tokens being transferred. For `JBToken` based tokens this would allow an attacker to begin issuing arbitrary amounts the token that was meant to be transferred.\n\n## Proof of Concept\n**Exploit scenario:**\n1. Wanting to assign their token to their JB project an unsuspecting owner / admin transfers ownership to a `JBTokenStore` contract, either directly by calling `transferOwnership` on the token or indirectly by calling the `changeFor` method on an older `JBTokenStore` contract with `_newOwner` set as the new `JBTokenStore` contract. (For the newer Juicebox contracts the `JBController` contract's `changeTokenOf` method would be called) \n2. Seeing this change an attacker submits a `changeTokenFor` calling transaction to the new `JBController` contract, triggering the `JBTokenStore` contract's `changeFor` method, linking it to one of the attacker's projects (this could be created in advance or as part of the same transaction via an attack contract)\n3. The attacker can then gain ownership over the token by calling `changeTokenFor` again with the `_newOwner` set to the attacker's address\n4. Assuming the token has an owner restricted `mint` method like `JBToken` based tokens the attacker can now mint an arbitrary amount of the token\n\n## Tools Used\nManual review.\n\n## Recommended Mitigation Steps\nBefore allowing a caller to change to a specific token ensure that they have control over it. This can be achieved by storing a list of trusted older JB directories and projects which are then queried. Alternatively the contract could require the caller to actually be the `.owner()`  address of the token to migrate, this would require admins to:\n1. Call `changeTokenOf` with themselves as the new owner\n2. Call the new change token method on the newer contract, since they are the owner they'd pass the check\n3. Independently transfer the ownership to the new token store to ensure that it can issue tokens\n\nFuture migrations can be made more seamless by having older contracts directly call new contracts via a sub-call, removing a necessary transaction for the admin. The newer contracts needs to verify that the older contract is the owner address of the token that's being set and also has approval of the project owner which is being configured.\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-juicebox-v2-contest",
  "Code": [
    {
      "filename": "contracts/JBTokenStore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport './abstract/JBControllerUtility.sol';\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBTokenStore.sol';\nimport './libraries/JBOperations.sol';\nimport './JBToken.sol';\n\n/**\n  @notice\n  Manage token minting, burning, and account balances.\n\n  @dev\n  Token balances can be either represented internally or claimed as ERC-20s into wallets.\n  This contract manages these two representations and allows claiming.\n\n  @dev\n  The total supply of a project's tokens and the balance of each account are calculated in this contract.\n\n  @dev\n  Each project can bring their own token if they prefer, and swap between tokens at any time.\n  \n  @dev\n  Adheres to -\n  IJBTokenStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBControllerUtility: Includes convenience functionality for checking if the message sender is the current controller of the project whose data is being manipulated.\n  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n*/\ncontract JBTokenStore is IJBTokenStore, JBControllerUtility, JBOperatable {\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error CANT_REMOVE_TOKEN_IF_ITS_REQUIRED();\n  error EMPTY_NAME();\n  error EMPTY_SYMBOL();\n  error INSUFFICIENT_FUNDS();\n  error INSUFFICIENT_UNCLAIMED_TOKENS();\n  error PROJECT_ALREADY_HAS_TOKEN();\n  error RECIPIENT_ZERO_ADDRESS();\n  error TOKEN_ALREADY_IN_USE();\n  error TOKEN_NOT_FOUND();\n  error TOKENS_MUST_HAVE_18_DECIMALS();\n\n  //*********************************************************************//\n  // ---------------- public immutable stored properties --------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Mints ERC-721's that represent project ownership and transfers.\n  */\n  IJBProjects public immutable override projects;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Each project's attached token contract.\n\n    _projectId The ID of the project to which the token belongs.\n  */\n  mapping(uint256 => IJBToken) public override tokenOf;\n\n  /**\n    @notice\n    The ID of the project that each token belongs to.\n\n    _token The token to check the project association of.\n  */\n  mapping(IJBToken => uint256) public override projectOf;\n\n  /**\n    @notice\n    The total supply of unclaimed tokens for each project.\n\n    _projectId The ID of the project to which the token belongs.\n  */\n  mapping(uint256 => uint256) public override unclaimedTotalSupplyOf;\n\n  /**\n    @notice\n    Each holder's balance of unclaimed tokens for each project.\n\n    _holder The holder of balance.\n    _projectId The ID of the project to which the token belongs.\n  */\n  mapping(address => mapping(uint256 => uint256)) public override unclaimedBalanceOf;\n\n  /**\n    @notice\n    A flag indicating if tokens are required to be issued as claimed for a particular project.\n\n    _projectId The ID of the project to which the requirement applies.\n  */\n  mapping(uint256 => bool) public override requireClaimFor;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The total supply of tokens for each project, including claimed and unclaimed tokens.\n\n    @param _projectId The ID of the project to get the total token supply of.\n\n    @return totalSupply The total supply of the project's tokens.\n  */\n  function totalSupplyOf(uint256 _projectId) external view override returns (uint256 totalSupply) {\n    // Get a reference to the total supply of the project's unclaimed tokens.\n    totalSupply = unclaimedTotalSupplyOf[_projectId];\n\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // If the project has a current token, add it's total supply to the total.\n    if (_token != IJBToken(address(0))) totalSupply = totalSupply + _token.totalSupply(_projectId);\n  }\n\n  /**\n    @notice\n    The total balance of tokens a holder has for a specified project, including claimed and unclaimed tokens.\n\n    @param _holder The token holder to get a balance for.\n    @param _projectId The project to get the `_holder`s balance of.\n\n    @return balance The project token balance of the `_holder\n  */\n  function balanceOf(address _holder, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256 balance)\n  {\n    // Get a reference to the holder's unclaimed balance for the project.\n    balance = unclaimedBalanceOf[_holder][_projectId];\n\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // If the project has a current token, add the holder's balance to the total.\n    if (_token != IJBToken(address(0))) balance = balance + _token.balanceOf(_holder, _projectId);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /**\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n  */\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory\n  ) JBOperatable(_operatorStore) JBControllerUtility(_directory) {\n    projects = _projects;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Issues a project's ERC-20 tokens that'll be used when claiming tokens.\n\n    @dev\n    Deploys a project's ERC-20 token contract.\n\n    @dev\n    Only a project's current controller can issue its token.\n\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC-20's name.\n    @param _symbol The ERC-20's symbol.\n\n    @return token The token that was issued.\n  */\n  function issueFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  ) external override onlyController(_projectId) returns (IJBToken token) {\n    // There must be a name.\n    if (bytes(_name).length == 0) revert EMPTY_NAME();\n\n    // There must be a symbol.\n    if (bytes(_symbol).length == 0) revert EMPTY_SYMBOL();\n\n    // The project shouldn't already have a token.\n    if (tokenOf[_projectId] != IJBToken(address(0))) revert PROJECT_ALREADY_HAS_TOKEN();\n\n    // Deploy the token contract.\n    token = new JBToken(_name, _symbol);\n\n    // Store the token contract.\n    tokenOf[_projectId] = token;\n\n    // Store the project for the token.\n    projectOf[token] = _projectId;\n\n    emit Issue(_projectId, token, _name, _symbol, msg.sender);\n  }\n\n  /**\n    @notice\n    Swap the current project's token for another, and transfer ownership of the current token to another address if needed.\n\n    @dev\n    Only a project's current controller can change its token.\n\n    @dev\n    This contract must have access to all of the token's `IJBToken` interface functions.\n\n    @dev\n    Can't change to a token that's currently being used by another project.\n\n    @dev\n    Changing to the zero address will remove the current token without adding a new one.\n\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token. Send an empty address to remove the project's current token without adding a new one, if claiming tokens isn't currency required by the project\n    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.\n\n    @return oldToken The token that was removed as the project's token.\n  */\n  function changeFor(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  ) external override onlyController(_projectId) returns (IJBToken oldToken) {\n    // Can't remove the project's token if the project requires claiming tokens.\n    if (_token == IJBToken(address(0)) && requireClaimFor[_projectId])\n      revert CANT_REMOVE_TOKEN_IF_ITS_REQUIRED();\n\n    // Can't change to a token already in use.\n    if (projectOf[_token] != 0) revert TOKEN_ALREADY_IN_USE();\n\n    // Can't change to a token that doesn't use 18 decimals.\n    if (_token != IJBToken(address(0)) && _token.decimals() != 18)\n      revert TOKENS_MUST_HAVE_18_DECIMALS();\n\n    // Get a reference to the current token for the project.\n    oldToken = tokenOf[_projectId];\n\n    // Store the new token.\n    tokenOf[_projectId] = _token;\n\n    // Store the project for the new token if the new token isn't the zero address.\n    if (_token != IJBToken(address(0))) projectOf[_token] = _projectId;\n\n    // Reset the project for the old token if it isn't the zero address.\n    if (oldToken != IJBToken(address(0))) projectOf[oldToken] = 0;\n\n    // If there's a current token and a new owner was provided, transfer ownership of the old token to the new owner.\n    if (_newOwner != address(0) && oldToken != IJBToken(address(0)))\n      oldToken.transferOwnership(_projectId, _newOwner);\n\n    emit Change(_projectId, _token, oldToken, _newOwner, msg.sender);\n  }\n\n  /**\n    @notice\n    Mint new project tokens.\n\n    @dev\n    Only a project's current controller can mint its tokens.\n\n    @param _holder The address receiving the new tokens.\n    @param _projectId The ID of the project to which the tokens belong.\n    @param _amount The amount of tokens to mint.\n    @param _preferClaimedTokens A flag indicating whether there's a preference for minted tokens to be claimed automatically into the `_holder`s wallet if the project currently has a token contract attached.\n  */\n  function mintFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _amount,\n    bool _preferClaimedTokens\n  ) external override onlyController(_projectId) {\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // Save a reference to whether there exists a token and the caller prefers these claimed tokens or the project requires it.\n    bool _shouldClaimTokens = (requireClaimFor[_projectId] || _preferClaimedTokens) &&\n      _token != IJBToken(address(0));\n\n    if (_shouldClaimTokens)\n      // If tokens should be claimed, mint tokens into the holder's wallet.\n      _token.mint(_projectId, _holder, _amount);\n    else {\n      // Otherwise, add the tokens to the unclaimed balance and total supply.\n      unclaimedBalanceOf[_holder][_projectId] = unclaimedBalanceOf[_holder][_projectId] + _amount;\n      unclaimedTotalSupplyOf[_projectId] = unclaimedTotalSupplyOf[_projectId] + _amount;\n    }\n\n    emit Mint(_holder, _projectId, _amount, _shouldClaimTokens, _preferClaimedTokens, msg.sender);\n  }\n\n  /**\n    @notice\n    Burns a project's tokens.\n\n    @dev\n    Only a project's current controller can burn its tokens.\n\n    @param _holder The address that owns the tokens being burned.\n    @param _projectId The ID of the project to which the burned tokens belong.\n    @param _amount The amount of tokens to burn.\n    @param _preferClaimedTokens A flag indicating whether there's a preference for tokens to burned from the `_holder`s wallet if the project currently has a token contract attached.\n  */\n  function burnFrom(\n    address _holder,\n    uint256 _projectId,\n    uint256 _amount,\n    bool _preferClaimedTokens\n  ) external override onlyController(_projectId) {\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // Get a reference to the amount of unclaimed project tokens the holder has.\n    uint256 _unclaimedBalance = unclaimedBalanceOf[_holder][_projectId];\n\n    // Get a reference to the amount of the project's current token the holder has in their wallet.\n    uint256 _claimedBalance = _token == IJBToken(address(0))\n      ? 0\n      : _token.balanceOf(_holder, _projectId);\n\n    // There must be adequate tokens to burn across the holder's claimed and unclaimed balance.\n    if (_amount > _claimedBalance + _unclaimedBalance) revert INSUFFICIENT_FUNDS();\n\n    // The amount of tokens to burn.\n    uint256 _claimedTokensToBurn;\n\n    // If there's no balance, redeem no tokens.\n    if (_claimedBalance == 0)\n      _claimedTokensToBurn = 0;\n      // If prefer converted, redeem tokens before redeeming unclaimed tokens.\n    else if (_preferClaimedTokens)\n      _claimedTokensToBurn = _claimedBalance < _amount ? _claimedBalance : _amount;\n      // Otherwise, redeem unclaimed tokens before claimed tokens.\n    else _claimedTokensToBurn = _unclaimedBalance < _amount ? _amount - _unclaimedBalance : 0;\n\n    // The amount of unclaimed tokens to redeem.\n    uint256 _unclaimedTokensToBurn = _amount - _claimedTokensToBurn;\n\n    // Subtract the tokens from the unclaimed balance and total supply.\n    if (_unclaimedTokensToBurn > 0) {\n      // Reduce the holders balance and the total supply.\n      unclaimedBalanceOf[_holder][_projectId] =\n        unclaimedBalanceOf[_holder][_projectId] -\n        _unclaimedTokensToBurn;\n      unclaimedTotalSupplyOf[_projectId] =\n        unclaimedTotalSupplyOf[_projectId] -\n        _unclaimedTokensToBurn;\n    }\n\n    // Burn the claimed tokens.\n    if (_claimedTokensToBurn > 0) _token.burn(_projectId, _holder, _claimedTokensToBurn);\n\n    emit Burn(\n      _holder,\n      _projectId,\n      _amount,\n      _unclaimedBalance,\n      _claimedBalance,\n      _preferClaimedTokens,\n      msg.sender\n    );\n  }\n\n  /**\n    @notice\n    Claims internally accounted for tokens into a holder's wallet.\n\n    @dev\n    Only a token holder or an operator specified by the token holder can claim its unclaimed tokens.\n\n    @param _holder The owner of the tokens being claimed.\n    @param _projectId The ID of the project whose tokens are being claimed.\n    @param _amount The amount of tokens to claim.\n  */\n  function claimFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _amount\n  ) external override requirePermission(_holder, _projectId, JBOperations.CLAIM) {\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // The project must have a token contract attached.\n    if (_token == IJBToken(address(0))) revert TOKEN_NOT_FOUND();\n\n    // Get a reference to the amount of unclaimed project tokens the holder has.\n    uint256 _unclaimedBalance = unclaimedBalanceOf[_holder][_projectId];\n\n    // There must be enough unclaimed tokens to claim.\n    if (_unclaimedBalance < _amount) revert INSUFFICIENT_UNCLAIMED_TOKENS();\n\n    // Subtract the claim amount from the holder's unclaimed project token balance.\n    unclaimedBalanceOf[_holder][_projectId] = unclaimedBalanceOf[_holder][_projectId] - _amount;\n\n    // Subtract the claim amount from the project's unclaimed total supply.\n    unclaimedTotalSupplyOf[_projectId] = unclaimedTotalSupplyOf[_projectId] - _amount;\n\n    // Mint the equivalent amount of the project's token for the holder.\n    _token.mint(_projectId, _holder, _amount);\n\n    emit Claim(_holder, _projectId, _unclaimedBalance, _amount, msg.sender);\n  }\n\n  /**\n    @notice\n    Allows a holder to transfer unclaimed tokens to another account.\n\n    @dev\n    Only a token holder or an operator can transfer its unclaimed tokens.\n\n    @param _holder The address to transfer tokens from.\n    @param _projectId The ID of the project whose tokens are being transferred.\n    @param _recipient The recipient of the tokens.\n    @param _amount The amount of tokens to transfer.\n  */\n  function transferFrom(\n    address _holder,\n    uint256 _projectId,\n    address _recipient,\n    uint256 _amount\n  ) external override requirePermission(_holder, _projectId, JBOperations.TRANSFER) {\n    // Can't transfer to the zero address.\n    if (_recipient == address(0)) revert RECIPIENT_ZERO_ADDRESS();\n\n    // Get a reference to the holder's unclaimed project token balance.\n    uint256 _unclaimedBalance = unclaimedBalanceOf[_holder][_projectId];\n\n    // The holder must have enough unclaimed tokens to transfer.\n    if (_amount > _unclaimedBalance) revert INSUFFICIENT_UNCLAIMED_TOKENS();\n\n    // Subtract from the holder's unclaimed token balance.\n    unclaimedBalanceOf[_holder][_projectId] = unclaimedBalanceOf[_holder][_projectId] - _amount;\n\n    // Add the unclaimed project tokens to the recipient's balance.\n    unclaimedBalanceOf[_recipient][_projectId] =\n      unclaimedBalanceOf[_recipient][_projectId] +\n      _amount;\n\n    emit Transfer(_holder, _projectId, _recipient, _amount, msg.sender);\n  }\n\n  /**\n    @notice\n    Allows a project to force all future mints of its tokens to be claimed into the holder's wallet, or revoke the flag if it's already set.\n\n    @dev\n    Only a token holder or an operator can require claimed token.\n\n    @param _projectId The ID of the project being affected.\n    @param _flag A flag indicating whether or not claiming should be required.\n  */\n  function shouldRequireClaimingFor(uint256 _projectId, bool _flag)\n    external\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.REQUIRE_CLAIM)\n  {\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // The project must have a token contract attached.\n    if (_token == IJBToken(address(0))) revert TOKEN_NOT_FOUND();\n\n    // Store the flag.\n    requireClaimFor[_projectId] = _flag;\n\n    emit ShouldRequireClaim(_projectId, _flag, msg.sender);\n  }\n}"
    },
    {
      "filename": "contracts/JBTokenStore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport './abstract/JBControllerUtility.sol';\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBTokenStore.sol';\nimport './libraries/JBOperations.sol';\nimport './JBToken.sol';\n\n/**\n  @notice\n  Manage token minting, burning, and account balances.\n\n  @dev\n  Token balances can be either represented internally or claimed as ERC-20s into wallets.\n  This contract manages these two representations and allows claiming.\n\n  @dev\n  The total supply of a project's tokens and the balance of each account are calculated in this contract.\n\n  @dev\n  Each project can bring their own token if they prefer, and swap between tokens at any time.\n  \n  @dev\n  Adheres to -\n  IJBTokenStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBControllerUtility: Includes convenience functionality for checking if the message sender is the current controller of the project whose data is being manipulated.\n  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n*/\ncontract JBTokenStore is IJBTokenStore, JBControllerUtility, JBOperatable {\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error CANT_REMOVE_TOKEN_IF_ITS_REQUIRED();\n  error EMPTY_NAME();\n  error EMPTY_SYMBOL();\n  error INSUFFICIENT_FUNDS();\n  error INSUFFICIENT_UNCLAIMED_TOKENS();\n  error PROJECT_ALREADY_HAS_TOKEN();\n  error RECIPIENT_ZERO_ADDRESS();\n  error TOKEN_ALREADY_IN_USE();\n  error TOKEN_NOT_FOUND();\n  error TOKENS_MUST_HAVE_18_DECIMALS();\n\n  //*********************************************************************//\n  // ---------------- public immutable stored properties --------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Mints ERC-721's that represent project ownership and transfers.\n  */\n  IJBProjects public immutable override projects;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Each project's attached token contract.\n\n    _projectId The ID of the project to which the token belongs.\n  */\n  mapping(uint256 => IJBToken) public override tokenOf;\n\n  /**\n    @notice\n    The ID of the project that each token belongs to.\n\n    _token The token to check the project association of.\n  */\n  mapping(IJBToken => uint256) public override projectOf;\n\n  /**\n    @notice\n    The total supply of unclaimed tokens for each project.\n\n    _projectId The ID of the project to which the token belongs.\n  */\n  mapping(uint256 => uint256) public override unclaimedTotalSupplyOf;\n\n  /**\n    @notice\n    Each holder's balance of unclaimed tokens for each project.\n\n    _holder The holder of balance.\n    _projectId The ID of the project to which the token belongs.\n  */\n  mapping(address => mapping(uint256 => uint256)) public override unclaimedBalanceOf;\n\n  /**\n    @notice\n    A flag indicating if tokens are required to be issued as claimed for a particular project.\n\n    _projectId The ID of the project to which the requirement applies.\n  */\n  mapping(uint256 => bool) public override requireClaimFor;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The total supply of tokens for each project, including claimed and unclaimed tokens.\n\n    @param _projectId The ID of the project to get the total token supply of.\n\n    @return totalSupply The total supply of the project's tokens.\n  */\n  function totalSupplyOf(uint256 _projectId) external view override returns (uint256 totalSupply) {\n    // Get a reference to the total supply of the project's unclaimed tokens.\n    totalSupply = unclaimedTotalSupplyOf[_projectId];\n\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // If the project has a current token, add it's total supply to the total.\n    if (_token != IJBToken(address(0))) totalSupply = totalSupply + _token.totalSupply(_projectId);\n  }\n\n  /**\n    @notice\n    The total balance of tokens a holder has for a specified project, including claimed and unclaimed tokens.\n\n    @param _holder The token holder to get a balance for.\n    @param _projectId The project to get the `_holder`s balance of.\n\n    @return balance The project token balance of the `_holder\n  */\n  function balanceOf(address _holder, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256 balance)\n  {\n    // Get a reference to the holder's unclaimed balance for the project.\n    balance = unclaimedBalanceOf[_holder][_projectId];\n\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // If the project has a current token, add the holder's balance to the total.\n    if (_token != IJBToken(address(0))) balance = balance + _token.balanceOf(_holder, _projectId);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /**\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n  */\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory\n  ) JBOperatable(_operatorStore) JBControllerUtility(_directory) {\n    projects = _projects;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Issues a project's ERC-20 tokens that'll be used when claiming tokens.\n\n    @dev\n    Deploys a project's ERC-20 token contract.\n\n    @dev\n    Only a project's current controller can issue its token.\n\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC-20's name.\n    @param _symbol The ERC-20's symbol.\n\n    @return token The token that was issued.\n  */\n  function issueFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  ) external override onlyController(_projectId) returns (IJBToken token) {\n    // There must be a name.\n    if (bytes(_name).length == 0) revert EMPTY_NAME();\n\n    // There must be a symbol.\n    if (bytes(_symbol).length == 0) revert EMPTY_SYMBOL();\n\n    // The project shouldn't already have a token.\n    if (tokenOf[_projectId] != IJBToken(address(0))) revert PROJECT_ALREADY_HAS_TOKEN();\n\n    // Deploy the token contract.\n    token = new JBToken(_name, _symbol);\n\n    // Store the token contract.\n    tokenOf[_projectId] = token;\n\n    // Store the project for the token.\n    projectOf[token] = _projectId;\n\n    emit Issue(_projectId, token, _name, _symbol, msg.sender);\n  }\n\n  /**\n    @notice\n    Swap the current project's token for another, and transfer ownership of the current token to another address if needed.\n\n    @dev\n    Only a project's current controller can change its token.\n\n    @dev\n    This contract must have access to all of the token's `IJBToken` interface functions.\n\n    @dev\n    Can't change to a token that's currently being used by another project.\n\n    @dev\n    Changing to the zero address will remove the current token without adding a new one.\n\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token. Send an empty address to remove the project's current token without adding a new one, if claiming tokens isn't currency required by the project\n    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.\n\n    @return oldToken The token that was removed as the project's token.\n  */\n  function changeFor(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  ) external override onlyController(_projectId) returns (IJBToken oldToken) {\n    // Can't remove the project's token if the project requires claiming tokens.\n    if (_token == IJBToken(address(0)) && requireClaimFor[_projectId])\n      revert CANT_REMOVE_TOKEN_IF_ITS_REQUIRED();\n\n    // Can't change to a token already in use.\n    if (projectOf[_token] != 0) revert TOKEN_ALREADY_IN_USE();\n\n    // Can't change to a token that doesn't use 18 decimals.\n    if (_token != IJBToken(address(0)) && _token.decimals() != 18)\n      revert TOKENS_MUST_HAVE_18_DECIMALS();\n\n    // Get a reference to the current token for the project.\n    oldToken = tokenOf[_projectId];\n\n    // Store the new token.\n    tokenOf[_projectId] = _token;\n\n    // Store the project for the new token if the new token isn't the zero address.\n    if (_token != IJBToken(address(0))) projectOf[_token] = _projectId;\n\n    // Reset the project for the old token if it isn't the zero address.\n    if (oldToken != IJBToken(address(0))) projectOf[oldToken] = 0;\n\n    // If there's a current token and a new owner was provided, transfer ownership of the old token to the new owner.\n    if (_newOwner != address(0) && oldToken != IJBToken(address(0)))\n      oldToken.transferOwnership(_projectId, _newOwner);\n\n    emit Change(_projectId, _token, oldToken, _newOwner, msg.sender);\n  }\n\n  /**\n    @notice\n    Mint new project tokens.\n\n    @dev\n    Only a project's current controller can mint its tokens.\n\n    @param _holder The address receiving the new tokens.\n    @param _projectId The ID of the project to which the tokens belong.\n    @param _amount The amount of tokens to mint.\n    @param _preferClaimedTokens A flag indicating whether there's a preference for minted tokens to be claimed automatically into the `_holder`s wallet if the project currently has a token contract attached.\n  */\n  function mintFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _amount,\n    bool _preferClaimedTokens\n  ) external override onlyController(_projectId) {\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // Save a reference to whether there exists a token and the caller prefers these claimed tokens or the project requires it.\n    bool _shouldClaimTokens = (requireClaimFor[_projectId] || _preferClaimedTokens) &&\n      _token != IJBToken(address(0));\n\n    if (_shouldClaimTokens)\n      // If tokens should be claimed, mint tokens into the holder's wallet.\n      _token.mint(_projectId, _holder, _amount);\n    else {\n      // Otherwise, add the tokens to the unclaimed balance and total supply.\n      unclaimedBalanceOf[_holder][_projectId] = unclaimedBalanceOf[_holder][_projectId] + _amount;\n      unclaimedTotalSupplyOf[_projectId] = unclaimedTotalSupplyOf[_projectId] + _amount;\n    }\n\n    emit Mint(_holder, _projectId, _amount, _shouldClaimTokens, _preferClaimedTokens, msg.sender);\n  }\n\n  /**\n    @notice\n    Burns a project's tokens.\n\n    @dev\n    Only a project's current controller can burn its tokens.\n\n    @param _holder The address that owns the tokens being burned.\n    @param _projectId The ID of the project to which the burned tokens belong.\n    @param _amount The amount of tokens to burn.\n    @param _preferClaimedTokens A flag indicating whether there's a preference for tokens to burned from the `_holder`s wallet if the project currently has a token contract attached.\n  */\n  function burnFrom(\n    address _holder,\n    uint256 _projectId,\n    uint256 _amount,\n    bool _preferClaimedTokens\n  ) external override onlyController(_projectId) {\n    // Get a reference to the project's current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // Get a reference to the amount of unclaimed project tokens the holder has.\n    uint256 _unclaimedBalance = unclaimedBalanceOf[_holder][_projectId];\n\n    // Get a reference to the amount of the project's current token the holder has in their wallet.\n    uint256 _claimedBalance = _token == IJBToken(address(0))\n      ? 0\n      : _token.balanceOf(_holder, _projectId);\n\n    // There must be adequate tokens to burn across the holder's claimed and unclaimed balance.\n    if (_amount > _claimedBalance + _unclaimedBalance) revert INSUFFICIENT_FUNDS();\n\n    // The amount of tokens to burn.\n    uint256 _claimedTokensToBurn;\n\n    // If there's no balance, redeem no tokens.\n    if (_claimedBalance == 0)\n      _claimedTokensToBurn = 0;\n      // If prefer converted, redeem tokens before redeeming unclaimed tokens.\n    else if (_preferClaimedTokens)\n      _claimedTokensToBurn = _claimedBalance < _amount ? _claimedBalance : _amount;\n      // Otherwise, redeem unclaimed tokens before claimed tokens.\n    else _claimedTokensToBurn = _unclaimedBalance < _amount ? _amount - _unclaimedBalance : 0;\n\n    // The amount of unclaimed tokens to redeem.\n    uint256 _unclaimedTokensToBurn = _amount - _claimedTokensToBurn;\n\n    // Subtract the tokens from the unclaimed balance and total supply.\n    if (_unclaimedTokensToBurn > 0) {\n      // Reduce the holders balance and the total supply.\n      unclaimedBalanceOf[_holder][_projectId] =\n        unclaimedBalanceOf[_holder][_projectId] -\n        _unclaimedTokensToBurn;\n      unclaimedTotalSupplyOf[_projectId] =\n        unclaimedTotalSupplyOf[_projectId] -\n        _unclaimedTokensToBurn;\n    }\n\n    // Burn the claimed tokens.\n    if (_claimedTokensToBurn > 0) _token.burn(_projectId, _holder, _claimedTokensToBurn);\n\n    emit Burn(\n      _holder,\n      _projectId,\n      _amount,\n      _unclaimedBalance,\n      _claimedBalance,\n      _preferClaimedTokens,\n      msg.sender\n    );\n  }\n\n  /**\n    @notice\n    Claims internally accounted for tokens into a holder's wallet.\n\n    @dev\n    Only a token holder or an operator specified by the token holder can claim its unclaimed tokens.\n\n    @param _holder The owner of the tokens being clai"
    }
  ]
}