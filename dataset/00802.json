{
  "Title": "Updates from the `secondary pool` to the `primary pool` may not be sent because there are `no rewards` for the secondary pool",
  "Content": "# Updates from the `secondary pool` to the `primary pool` may not be sent because there are `no rewards` for the secondary pool\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L157\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L157</a>\n\n\n## Summary\n\nThe [SDLPoolCCIPControllerSecondary::performUpkeep()](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66) function is only available when there is a [`message of rewards`](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L157) from the `SDLPoolCCIPControllerPrimary`. That could be a problem if there are not rewards to distribute in a specific `secondary chain` causing that queue updates from the `secondarly chain` will not be informed to the `SDLPoolPrimary`.\n\n## Vulnerability Details\n\nThe `secondary chain` informs to the `primary chain` the new `numNewRESDLTokens` and `totalRESDLSupplyChange` using the [SDLPoolCCIPControllerSecondary::performUpkeep](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66C14-L66C27) function, then the primary chain receives the [information](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol#L300) and it calculates the new [mintStartIndex](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol#L305). Note that the `primary chain` increments the `reSDLSupplyByChain` in the `code line 300`, this so that the `primary chain` has the information on how much supply of reSDL tokens there is in the `secondary chain`:\n\n```solidity\nFile: SDLPoolCCIPControllerPrimary.sol\n294:     function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n295:         uint64 sourceChainSelector = _message.sourceChainSelector;\n296: \n297:         (uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange) = abi.decode(_message.data, (uint256, int256));\n298: \n299:         if (totalRESDLSupplyChange > 0) {\n300:             reSDLSupplyByChain[sourceChainSelector] += uint256(totalRESDLSupplyChange);\n301:         } else if (totalRESDLSupplyChange < 0) {\n302:             reSDLSupplyByChain[sourceChainSelector] -= uint256(-1 * totalRESDLSupplyChange);\n303:         }\n304: \n305:         uint256 mintStartIndex = ISDLPoolPrimary(sdlPool).handleIncomingUpdate(numNewRESDLTokens, totalRESDLSupplyChange);\n306: \n307:         _ccipSendUpdate(sourceChainSelector, mintStartIndex);\n308: \n309:         emit MessageReceived(_message.messageId, sourceChainSelector);\n310:     }\n```\n\nNow the [mintStartIndex is send to the secondary chain code line 307](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol#L307) and the secondary chain [receives the new mintStartIndex](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L161). This entire process helps to keep the information updated between the primary chain and the secondary chain.\n\nOn the other hand, when a secondary chain receive rewards, the secondary chain can call the function [SDLPoolCCIPControllerSecondary::performUpkeep](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66C14-L66C27) since `shouldUpdate` is `true` at [code line 157](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L157):\n\n```solidity\nFile: SDLPoolCCIPControllerSecondary.sol\n147:     function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n148:         if (_message.data.length == 0) {\n149:             uint256 numRewardTokens = _message.destTokenAmounts.length;\n150:             address[] memory rewardTokens = new address[](numRewardTokens);\n151:             if (numRewardTokens != 0) {\n152:                 for (uint256 i = 0; i < numRewardTokens; ++i) {\n153:                     rewardTokens[i] = _message.destTokenAmounts[i].token;\n154:                     IERC20(rewardTokens[i]).safeTransfer(sdlPool, _message.destTokenAmounts[i].amount);\n155:                 }\n156:                 ISDLPoolSecondary(sdlPool).distributeTokens(rewardTokens);\n157:                 if (ISDLPoolSecondary(sdlPool).shouldUpdate()) shouldUpdate = true;\n158:             }\n159:         } else {\n160:             uint256 mintStartIndex = abi.decode(_message.data, (uint256));\n161:             ISDLPoolSecondary(sdlPool).handleIncomingUpdate(mintStartIndex);\n162:         }\n163: \n164:         emit MessageReceived(_message.messageId, _message.sourceChainSelector);\n165:     }\n```\n\nOnce `shouldUpdate` is `true`, the function [SDLPoolCCIPControllerSecondary::performUpkeep](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66C14-L66C27) can be called in order to send the new information (`numNewRESDLTokens` and `totalRESDLSupplyChange`) to the primary chain:\n\n```solidity\n    function performUpkeep(bytes calldata) external {\n        if (!shouldUpdate) revert UpdateConditionsNotMet();\n\n        shouldUpdate = false;\n        _initiateUpdate(primaryChainSelector, primaryChainDestination, extraArgs);\n    }\n```\n\nThe problem is that the `primary chain` needs to send rewards to the `secondary chain` so that `shouldUpdate` is true and the function [SDLPoolCCIPControllerSecondary::performUpkeep](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66C14-L66C27) can be called. However, in certain circumstances it is possible that the `secondary chain` may never be able to send information to the primary chain since there may not be any rewards for the secondary chain. Please consider the next scenario:\n\n1. `UserA` stakes directly in the `secondary chain` and the [queuedRESDLSupplyChange increments](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/SDLPoolSecondary.sol#L373)\n2. The increase in supply CANNOT be reported to the `primary chain` since `shouldUpdate = false` and the function [SDLPoolCCIPControllerSecondary::performUpkeep](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66C14-L66C27) will be reverted.\n3. Rewards are calculated on the primary chain, however because the `secondary chain` has not been able to send the new supply information, [zero rewards reSDLSupplyByChain](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol#L84C39-L84C72) will be calculated for the secondary chain since `reSDLSupplyByChain[chainSelector]` has not been increased with the new information from `step 1`.\n4. Since there are NO rewards assigned for the `secondary chain`, it is not possible to [set `shouldUpdate=True`](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L157), therefore the function [SDLPoolCCIPControllerSecondary::performUpkeep](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66C14-L66C27) will be reverted.\n\nThe following test shows that a user can send `sdl` tokens to the `secondary pool` however [SDLPoolCCIPControllerSecondary::performUpkeep](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66C14-L66C27) cannot be called since there are no rewards assigned to the `secondary pool`:\n\n```js\n// File: test/core/ccip/sdl-pool-ccip-controller-secondary.test.ts\n// $ yarn test --grep \"codehawks performUpkeep reverts\"\n// \n  it('codehawks performUpkeep reverts', async () => {\n    await token1.transfer(tokenPool.address, toEther(1000))\n    let rewardsPool1 = await deploy('RewardsPool', [sdlPool.address, token1.address])\n    await sdlPool.addToken(token1.address, rewardsPool1.address)\n    assert.equal(fromEther(await sdlPool.totalEffectiveBalance()), 400)\n    assert.equal((await controller.checkUpkeep('0x'))[0], false)\n    assert.equal(await controller.shouldUpdate(), false)\n    //\n    // 1. Mint in the secondary pool\n    await sdlToken.transferAndCall(\n      sdlPool.address,\n      toEther(100),\n      ethers.utils.defaultAbiCoder.encode(['uint256', 'uint64'], [0, 0])\n    )\n    //\n    // 2. The secondary pool needs to update data to the primary chain but the `controller.shouldUpdate` is false so `performUpkeep` reverts the transaction\n    assert.equal(await sdlPool.shouldUpdate(), true)\n    assert.equal((await controller.checkUpkeep('0x'))[0], false)\n    assert.equal(await controller.shouldUpdate(), false)\n    await expect(controller.performUpkeep('0x')).to.be.revertedWith('UpdateConditionsNotMet()')\n  })\n```\n\n## Impact\n\n`numNewRESDLTokens` and `totalRESDLSupplyChange` updates from the `secondary pool` to the `primary pool` may not be executed, causing the [rewards calculation](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol#L84C39-L84C72) to be incorrect for each chain.\n\n## Tools used\n\nManual review\n\n## Recommendations\n\nThe [SDLPoolCCIPControllerSecondary::performUpkeep](https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol#L66C14-L66C27) function may check if the `secondary pool` has new information and so do not wait for rewards to be available for the `secondary pool`:\n\n```diff\n    function performUpkeep(bytes calldata) external {\n--      if (!shouldUpdate) revert UpdateConditionsNotMet();\n++      if (!shouldUpdate && !ISDLPoolSecondary(sdlPool).shouldUpdate()) revert UpdateConditionsNotMet();\n\n        shouldUpdate = false;\n        _initiateUpdate(primaryChainSelector, primaryChainDestination, extraArgs);\n    }\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./base/SDLPoolCCIPController.sol\";\n\ninterface ISDLPoolSecondary is ISDLPool {\n    function handleOutgoingUpdate() external returns (uint256, int256);\n\n    function handleIncomingUpdate(uint256 _mintStartIndex) external;\n\n    function shouldUpdate() external view returns (bool);\n}\n\ncontract SDLPoolCCIPControllerSecondary is SDLPoolCCIPController {\n    using SafeERC20 for IERC20;\n\n    uint64 public immutable primaryChainSelector;\n    address public immutable primaryChainDestination;\n    bytes public extraArgs;\n\n    bool public shouldUpdate;\n\n    event SetExtraArgs(bytes extraArgs);\n\n    error UpdateConditionsNotMet();\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _sdlToken address of the SDL token\n     * @param _sdlPool address of the SDL Pool\n     * @param _primaryChainSelector id of the primary chain\n     * @param _primaryChainDestination address to receive messages on primary chain\n     * @param _maxLINKFee max fee to be paid on an outgoing message\n     * @param _extraArgs extra args as defined in CCIP API to be used for outgoing messages\n     **/\n    constructor(\n        address _router,\n        address _linkToken,\n        address _sdlToken,\n        address _sdlPool,\n        uint64 _primaryChainSelector,\n        address _primaryChainDestination,\n        uint256 _maxLINKFee,\n        bytes memory _extraArgs\n    ) SDLPoolCCIPController(_router, _linkToken, _sdlToken, _sdlPool, _maxLINKFee) {\n        primaryChainSelector = _primaryChainSelector;\n        primaryChainDestination = _primaryChainDestination;\n        extraArgs = _extraArgs;\n    }\n\n    /**\n     * @notice Returns whether an update to the primary chain should be initiated\n     * @dev used by Chainlink automation\n     * @return whether an update should be initiated\n     **/\n    function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n        return (shouldUpdate, \"0x\");\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain if update conditions are met\n     * @dev used by Chainlink automation\n     **/\n    function performUpkeep(bytes calldata) external {\n        if (!shouldUpdate) revert UpdateConditionsNotMet();\n\n        shouldUpdate = false;\n        _initiateUpdate(primaryChainSelector, primaryChainDestination, extraArgs);\n    }\n\n    /**\n     * @notice Handles the outgoing transfer of an reSDL token to the primary chain\n     * @param _sender sender of the transfer\n     * @param _tokenId id of token\n     * @return the destination address\n     * @return the token being transferred\n     **/\n    function handleOutgoingRESDL(\n        uint64,\n        address _sender,\n        uint256 _tokenId\n    ) external override onlyBridge returns (address, ISDLPool.RESDLToken memory) {\n        return (primaryChainDestination, ISDLPoolSecondary(sdlPool).handleOutgoingRESDL(_sender, _tokenId, address(this)));\n    }\n\n    /**\n     * @notice Handles the incoming transfer of an reSDL token from the primary chain\n     * @param _receiver receiver of the transfer\n     * @param _tokenId id of reSDL token\n     * @param _reSDLToken reSDL token\n     **/\n    function handleIncomingRESDL(\n        uint64,\n        address _receiver,\n        uint256 _tokenId,\n        ISDLPool.RESDLToken calldata _reSDLToken\n    ) external override onlyBridge {\n        sdlToken.safeTransfer(sdlPool, _reSDLToken.amount);\n        ISDLPoolSecondary(sdlPool).handleIncomingRESDL(_receiver, _tokenId, _reSDLToken);\n    }\n\n    /**\n     * @notice Sets the extra args for sending updates to the primary chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function setExtraArgs(bytes calldata _extraArgs) external onlyOwner {\n        extraArgs = _extraArgs;\n        emit SetExtraArgs(_extraArgs);\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _destination address to receive message on destination chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function _initiateUpdate(\n        uint64 _destinationChainSelector,\n        address _destination,\n        bytes memory _extraArgs\n    ) internal {\n        (uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange) = ISDLPoolSecondary(sdlPool).handleOutgoingUpdate();\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _destination,\n            numNewRESDLTokens,\n            totalRESDLSupplyChange,\n            _extraArgs\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (fees > maxLINKFee) revert FeeExceedsLimit(fees);\n        bytes32 messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n\n        emit MessageSent(messageId, _destinationChainSelector, fees);\n    }\n\n    /**\n     * @notice Processes a received message\n     * @dev handles incoming updates and reward distributions from the primary chain\n     * @param _message CCIP message\n     **/\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        if (_message.data.length == 0) {\n            uint256 numRewardTokens = _message.destTokenAmounts.length;\n            address[] memory rewardTokens = new address[](numRewardTokens);\n            if (numRewardTokens != 0) {\n                for (uint256 i = 0; i < numRewardTokens; ++i) {\n                    rewardTokens[i] = _message.destTokenAmounts[i].token;\n                    IERC20(rewardTokens[i]).safeTransfer(sdlPool, _message.destTokenAmounts[i].amount);\n                }\n                ISDLPoolSecondary(sdlPool).distributeTokens(rewardTokens);\n                if (ISDLPoolSecondary(sdlPool).shouldUpdate()) shouldUpdate = true;\n            }\n        } else {\n            uint256 mintStartIndex = abi.decode(_message.data, (uint256));\n            ISDLPoolSecondary(sdlPool).handleIncomingUpdate(mintStartIndex);\n        }\n\n        emit MessageReceived(_message.messageId, _message.sourceChainSelector);\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @dev builds the message for outgoing updates to the primary chain\n     * @param _destination address of destination contract\n     * @param _numNewRESDLTokens number of new reSDL NFTs to be minted\n     * @param _totalRESDLSupplyChange reSDL supply change since last update\n     * @param _extraArgs encoded args as defined in CCIP API\n     **/\n    function _buildCCIPMessage(\n        address _destination,\n        uint256 _numNewRESDLTokens,\n        int256 _totalRESDLSupplyChange,\n        bytes memory _extraArgs\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_destination),\n            data: abi.encode(_numNewRESDLTokens, _totalRESDLSupplyChange),\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            extraArgs: _extraArgs,\n            feeToken: address(linkToken)\n        });\n\n        return evm2AnyMessage;\n    }\n\n    /**\n     * @notice Verifies the sender of a CCIP message is whitelisted\n     * @param _message CCIP message\n     **/\n    function _verifyCCIPSender(Client.Any2EVMMessage memory _message) internal view override {\n        address sender = abi.decode(_message.sender, (address));\n        uint64 sourceChainSelector = _message.sourceChainSelector;\n        if (sourceChainSelector != primaryChainSelector || sender != primaryChainDestination) revert SenderNotAuthorized();\n    }\n}"
    },
    {
      "filename": "contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./base/SDLPoolCCIPController.sol\";\n\ninterface ISDLPoolSecondary is ISDLPool {\n    function handleOutgoingUpdate() external returns (uint256, int256);\n\n    function handleIncomingUpdate(uint256 _mintStartIndex) external;\n\n    function shouldUpdate() external view returns (bool);\n}\n\ncontract SDLPoolCCIPControllerSecondary is SDLPoolCCIPController {\n    using SafeERC20 for IERC20;\n\n    uint64 public immutable primaryChainSelector;\n    address public immutable primaryChainDestination;\n    bytes public extraArgs;\n\n    bool public shouldUpdate;\n\n    event SetExtraArgs(bytes extraArgs);\n\n    error UpdateConditionsNotMet();\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _sdlToken address of the SDL token\n     * @param _sdlPool address of the SDL Pool\n     * @param _primaryChainSelector id of the primary chain\n     * @param _primaryChainDestination address to receive messages on primary chain\n     * @param _maxLINKFee max fee to be paid on an outgoing message\n     * @param _extraArgs extra args as defined in CCIP API to be used for outgoing messages\n     **/\n    constructor(\n        address _router,\n        address _linkToken,\n        address _sdlToken,\n        address _sdlPool,\n        uint64 _primaryChainSelector,\n        address _primaryChainDestination,\n        uint256 _maxLINKFee,\n        bytes memory _extraArgs\n    ) SDLPoolCCIPController(_router, _linkToken, _sdlToken, _sdlPool, _maxLINKFee) {\n        primaryChainSelector = _primaryChainSelector;\n        primaryChainDestination = _primaryChainDestination;\n        extraArgs = _extraArgs;\n    }\n\n    /**\n     * @notice Returns whether an update to the primary chain should be initiated\n     * @dev used by Chainlink automation\n     * @return whether an update should be initiated\n     **/\n    function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n        return (shouldUpdate, \"0x\");\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain if update conditions are met\n     * @dev used by Chainlink automation\n     **/\n    function performUpkeep(bytes calldata) external {\n        if (!shouldUpdate) revert UpdateConditionsNotMet();\n\n        shouldUpdate = false;\n        _initiateUpdate(primaryChainSelector, primaryChainDestination, extraArgs);\n    }\n\n    /**\n     * @notice Handles the outgoing transfer of an reSDL token to the primary chain\n     * @param _sender sender of the transfer\n     * @param _tokenId id of token\n     * @return the destination address\n     * @return the token being transferred\n     **/\n    function handleOutgoingRESDL(\n        uint64,\n        address _sender,\n        uint256 _tokenId\n    ) external override onlyBridge returns (address, ISDLPool.RESDLToken memory) {\n        return (primaryChainDestination, ISDLPoolSecondary(sdlPool).handleOutgoingRESDL(_sender, _tokenId, address(this)));\n    }\n\n    /**\n     * @notice Handles the incoming transfer of an reSDL token from the primary chain\n     * @param _receiver receiver of the transfer\n     * @param _tokenId id of reSDL token\n     * @param _reSDLToken reSDL token\n     **/\n    function handleIncomingRESDL(\n        uint64,\n        address _receiver,\n        uint256 _tokenId,\n        ISDLPool.RESDLToken calldata _reSDLToken\n    ) external override onlyBridge {\n        sdlToken.safeTransfer(sdlPool, _reSDLToken.amount);\n        ISDLPoolSecondary(sdlPool).handleIncomingRESDL(_receiver, _tokenId, _reSDLToken);\n    }\n\n    /**\n     * @notice Sets the extra args for sending updates to the primary chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function setExtraArgs(bytes calldata _extraArgs) external onlyOwner {\n        extraArgs = _extraArgs;\n        emit SetExtraArgs(_extraArgs);\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _destination address to receive message on destination chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function _initiateUpdate(\n        uint64 _destinationChainSelector,\n        address _destination,\n        bytes memory _extraArgs\n    ) internal {\n        (uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange) = ISDLPoolSecondary(sdlPool).handleOutgoingUpdate();\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _destination,\n            numNewRESDLTokens,\n            totalRESDLSupplyChange,\n            _extraArgs\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (fees > maxLINKFee) revert FeeExceedsLimit(fees);\n        bytes32 messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n\n        emit MessageSent(messageId, _destinationChainSelector, fees);\n    }\n\n    /**\n     * @notice Processes a received message\n     * @dev handles incoming updates and reward distributions from the primary chain\n     * @param _message CCIP message\n     **/\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        if (_message.data.length == 0) {\n            uint256 numRewardTokens = _message.destTokenAmounts.length;\n            address[] memory rewardTokens = new address[](numRewardTokens);\n            if (numRewardTokens != 0) {\n                for (uint256 i = 0; i < numRewardTokens; ++i) {\n                    rewardTokens[i] = _message.destTokenAmounts[i].token;\n                    IERC20(rewardTokens[i]).safeTransfer(sdlPool, _message.destTokenAmounts[i].amount);\n                }\n                ISDLPoolSecondary(sdlPool).distributeTokens(rewardTokens);\n                if (ISDLPoolSecondary(sdlPool).shouldUpdate()) shouldUpdate = true;\n            }\n        } else {\n            uint256 mintStartIndex = abi.decode(_message.data, (uint256));\n            ISDLPoolSecondary(sdlPool).handleIncomingUpdate(mintStartIndex);\n        }\n\n        emit MessageReceived(_message.messageId, _message.sourceChainSelector);\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @dev builds the message for outgoing updates to the primary chain\n     * @param _destination address of destination contract\n     * @param _numNewRESDLTokens number of new reSDL NFTs to be minted\n     * @param _totalRESDLSupplyChange reSDL supply change since last update\n     * @param _extraArgs encoded args as defined in CCIP API\n     **/\n    function _buildCCIPMessage(\n        address _destination,\n        uint256 _numNewRESDLTokens,\n        int256 _totalRESDLSupplyChange,\n        bytes memory _extraArgs\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_destination),\n            data: abi.encode(_numNewRESDLTokens, _totalRESDLSupplyChange),\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            extraArgs: _extraArgs,\n            feeToken: address(linkToken)\n        });\n\n        return evm2AnyMessage;\n    }\n\n    /**\n     * @notice Verifies the sender of a CCIP message is whitelisted\n     * @param _message CCIP message\n     **/\n    function _verifyCCIPSender(Client.Any2EVMMessage memory _message) internal view override {\n        address sender = abi.decode(_message.sender, (address));\n        uint64 sourceChainSelector = _message.sourceChainSelector;\n        if (sourceChainSelector != primaryChainSelector || sender != primaryChainDestination) revert SenderNotAuthorized();\n    }\n}"
    },
    {
      "filename": "contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./base/SDLPoolCCIPController.sol\";\n\ninterface ISDLPoolSecondary is ISDLPool {\n    function handleOutgoingUpdate() external returns (uint256, int256);\n\n    function handleIncomingUpdate(uint256 _mintStartIndex) external;\n\n    function shouldUpdate() external view returns (bool);\n}\n\ncontract SDLPoolCCIPControllerSecondary is SDLPoolCCIPController {\n    using SafeERC20 for IERC20;\n\n    uint64 public immutable primaryChainSelector;\n    address public immutable primaryChainDestination;\n    bytes public extraArgs;\n\n    bool public shouldUpdate;\n\n    event SetExtraArgs(bytes extraArgs);\n\n    error UpdateConditionsNotMet();\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _sdlToken address of the SDL token\n     * @param _sdlPool address of the SDL Pool\n     * @param _primaryChainSelector id of the primary chain\n     * @param _primaryChainDestination address to receive messages on primary chain\n     * @param _maxLINKFee max fee to be paid on an outgoing message\n     * @param _extraArgs extra args as defined in CCIP API to be used for outgoing messages\n     **/\n    constructor(\n        address _router,\n        address _linkToken,\n        address _sdlToken,\n        address _sdlPool,\n        uint64 _primaryChainSelector,\n        address _primaryChainDestination,\n        uint256 _maxLINKFee,\n        bytes memory _extraArgs\n    ) SDLPoolCCIPController(_router, _linkToken, _sdlToken, _sdlPool, _maxLINKFee) {\n        primaryChainSelector = _primaryChainSelector;\n        primaryChainDestination = _primaryChainDestination;\n        extraArgs = _extraArgs;\n    }\n\n    /**\n     * @notice Returns whether an update to the primary chain should be initiated\n     * @dev used by Chainlink automation\n     * @return whether an update should be initiated\n     **/\n    function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n        return (shouldUpdate, \"0x\");\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain if update conditions are met\n     * @dev used by Chainlink automation\n     **/\n    function performUpkeep(bytes calldata) external {\n        if (!shouldUpdate) revert UpdateConditionsNotMet();\n\n        shouldUpdate = false;\n        _initiateUpdate(primaryChainSelector, primaryChainDestination, extraArgs);\n    }\n\n    /**\n     * @notice Handles the outgoing transfer of an reSDL token to the primary chain\n     * @param _sender sender of the transfer\n     * @param _tokenId id of token\n     * @return the destination address\n     * @return the token being transferred\n     **/\n    function handleOutgoingRESDL(\n        uint64,\n        address _sender,\n        uint256 _tokenId\n    ) external override onlyBridge returns (address, ISDLPool.RESDLToken memory) {\n        return (primaryChainDestination, ISDLPoolSecondary(sdlPool).handleOutgoingRESDL(_sender, _tokenId, address(this)));\n    }\n\n    /**\n     * @notice Handles the incoming transfer of an reSDL token from the primary chain\n     * @param _receiver receiver of the transfer\n     * @param _tokenId id of reSDL token\n     * @param _reSDLToken reSDL token\n     **/\n    function handleIncomingRESDL(\n        uint64,\n        address _receiver,\n        uint256 _tokenId,\n        ISDLPool.RESDLToken calldata _reSDLToken\n    ) external override onlyBridge {\n        sdlToken.safeTransfer(sdlPool, _reSDLToken.amount);\n        ISDLPoolSecondary(sdlPool).handleIncomingRESDL(_receiver, _tokenId, _reSDLToken);\n    }\n\n    /**\n     * @notice Sets the extra args for sending updates to the primary chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function setExtraArgs(bytes calldata _extraArgs) external onlyOwner {\n        extraArgs = _extraArgs;\n        emit SetExtraArgs(_extraArgs);\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _destination address to receive message on destination chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function _initiateUpdate(\n        uint64 _destinationChainSelector,\n        address _destination,\n        bytes memory _extraArgs\n    ) internal {\n        (uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange) = ISDLPoolSecondary(sdlPool).handleOutgoingUpdate();\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _destination,\n            numNewRESDLTokens,\n            totalRESDLSupplyChange,\n            _extraArgs\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (fees > maxLINKFee) revert FeeExceedsLimit(fees);\n        bytes32 messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n\n        emit MessageSent(messageId, _destinationChainSelector, fees);\n    }\n\n    /**\n     * @notice Processes a received message\n     * @dev handles incoming updates and reward distributions from the primary chain\n     * @param _message CCIP message\n     **/\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        if (_message.data.length == 0) {\n            uint256 numRewardTokens = _message.destTokenAmounts.length;\n            address[] memory rewardTokens = new address[](numRewardTokens);\n            if (numRewardTokens != 0) {\n                for (uint256 i = 0; i < numRewardTokens; ++i) {\n                    rewardTokens[i] = _message.destTokenAmounts[i].token;\n                    IERC20(rewardTokens[i]).safeTransfer(sdlPool, _message.destTokenAmounts[i].amount);\n                }\n                ISDLPoolSecondary(sdlPool).distributeTokens(rewardTokens);\n                if (ISDLPoolSecondary(sdlPool).shouldUpdate()) shouldUpdate = true;\n            }\n        } else {\n            uint256 mintStartIndex = abi.decode(_message.data, (uint256));\n            ISDLPoolSecondary(sdlPool).handleIncomingUpdate(mintStartIndex);\n        }\n\n        emit MessageReceived(_message.messageId, _message.sourceChainSelector);\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @dev builds the message for outgoing updates to the primary chain\n     * @param _destination address of destination contract\n     * @param _numNewRESDLTokens number of new reSDL NFTs to be minted\n     * @param _totalRESDLSupplyChange reSDL supply change since last update\n     * @param _extraArgs encoded args as defined in CCIP API\n     **/\n    function _buildCCIPMessage(\n        address _destination,\n        uint256 _numNewRESDLTokens,\n        int256 _totalRESDLSupplyChange,\n        bytes memory _extraArgs\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_destination),\n            data: abi.encode(_numNewRESDLTokens, _totalRESDLSupplyChange),\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            extraArgs: _extraArgs,\n            feeToken: address(linkToken)\n        });\n\n        return evm2AnyMessage;\n    }\n\n    /**\n     * @notice Verifies the sender of a CCIP message is whitelisted\n     * @param _message CCIP message\n     **/\n    function _verifyCCIPSender(Client.Any2EVMMessage memory _message) internal view override {\n        address sender = abi.decode(_message.sender, (address));\n        uint64 sourceChainSelector = _message.sourceChainSelector;\n        if (sourceChainSelector != primaryChainSelector || sender != primaryChainDestination) revert SenderNotAuthorized();\n    }\n}"
    },
    {
      "filename": "contracts/core/ccip/SDLPoolCCIPControllerSecondary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./base/SDLPoolCCIPController.sol\";\n\ninterface ISDLPoolSecondary is ISDLPool {\n    function handleOutgoingUpdate() external returns (uint256, int256);\n\n    function handleIncomingUpdate(uint256 _mintStartIndex) external;\n\n    function shouldUpdate() external view returns (bool);\n}\n\ncontract SDLPoolCCIPControllerSecondary is SDLPoolCCIPController {\n    using SafeERC20 for IERC20;\n\n    uint64 public immutable primaryChainSelector;\n    address public immutable primaryChainDestination;\n    bytes public extraArgs;\n\n    bool public shouldUpdate;\n\n    event SetExtraArgs(bytes extraArgs);\n\n    error UpdateConditionsNotMet();\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _sdlToken address of the SDL token\n     * @param _sdlPool address of the SDL Pool\n     * @param _primaryChainSelector id of the primary chain\n     * @param _primaryChainDestination address to receive messages on primary chain\n     * @param _maxLINKFee max fee to be paid on an outgoing message\n     * @param _extraArgs extra args as defined in CCIP API to be used for outgoing messages\n     **/\n    constructor(\n        address _router,\n        address _linkToken,\n        address _sdlToken,\n        address _sdlPool,\n        uint64 _primaryChainSelector,\n        address _primaryChainDestination,\n        uint256 _maxLINKFee,\n        bytes memory _extraArgs\n    ) SDLPoolCCIPController(_router, _linkToken, _sdlToken, _sdlPool, _maxLINKFee) {\n        primaryChainSelector = _primaryChainSelector;\n        primaryChainDestination = _primaryChainDestination;\n        extraArgs = _extraArgs;\n    }\n\n    /**\n     * @notice Returns whether an update to the primary chain should be initiated\n     * @dev used by Chainlink automation\n     * @return whether an update should be initiated\n     **/\n    function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n        return (shouldUpdate, \"0x\");\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain if update conditions are met\n     * @dev used by Chainlink automation\n     **/\n    function performUpkeep(bytes calldata) external {\n        if (!shouldUpdate) revert UpdateConditionsNotMet();\n\n        shouldUpdate = false;\n        _initiateUpdate(primaryChainSelector, primaryChainDestination, extraArgs);\n    }\n\n    /**\n     * @notice Handles the outgoing transfer of an reSDL token to the primary chain\n     * @param _sender sender of the transfer\n     * @param _tokenId id of token\n     * @return the destination address\n     * @return the token being transferred\n     **/\n    function handleOutgoingRESDL(\n        uint64,\n        address _sender,\n        uint256 _tokenId\n    ) external override onlyBridge returns (address, ISDLPool.RESDLToken memory) {\n        return (primaryChainDestination, ISDLPoolSecondary(sdlPool).handleOutgoingRESDL(_sender, _tokenId, address(this)));\n    }\n\n    /**\n     * @notice Handles the incoming transfer of an reSDL token from the primary chain\n     * @param _receiver receiver of the transfer\n     * @param _tokenId id of reSDL token\n     * @param _reSDLToken reSDL token\n     **/\n    function handleIncomingRESDL(\n        uint64,\n        address _receiver,\n        uint256 _tokenId,\n        ISDLPool.RESDLToken calldata _reSDLToken\n    ) external override onlyBridge {\n        sdlToken.safeTransfer(sdlPool, _reSDLToken.amount);\n        ISDLPoolSecondary(sdlPool).handleIncomingRESDL(_receiver, _tokenId, _reSDLToken);\n    }\n\n    /**\n     * @notice Sets the extra args for sending updates to the primary chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function setExtraArgs(bytes calldata _extraArgs) external onlyOwner {\n        extraArgs = _extraArgs;\n        emit SetExtraArgs(_extraArgs);\n    }\n\n    /**\n     * @notice Initiates an update to the primary chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _destination address to receive message on destination chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function _initiateUpdate(\n        uint64 _destinationChainSelector,\n        address _destination,\n        bytes memory _extraArgs\n    ) internal {\n        (uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange) = ISDLPoolSecondary(sdlPool).handleOutgoingUpdate();\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _destination,\n            numNewRESDLTokens,\n            totalRESDLSupplyChange,\n            _extraArgs\n        );\n\n        IRouterClient router = IRouterClient(this.getRouter());\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (fees > maxLINKFee) revert FeeExceedsLimit(fees);\n        bytes32 messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\n\n        emit MessageSent(messageId, _destinationChainSelector, fees);\n    }\n\n    /**\n     * @notice Processes a received message\n     * @dev handles incoming updates and reward distributions from the primary chain\n     * @param _message CCIP message\n     **/\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        if (_message.data.length == 0) {\n            uint256 numRewardTokens = _message.destTokenAmounts.length;\n            address[] memory rewardTokens = new address[](numRewardTokens);\n            if (numRewardTokens != 0) {\n                for (uint256 i = 0; i < numRewardTokens; ++i) {\n                    rewardTokens[i] = _message.destTokenAmounts[i].token;\n                    IERC20(rewardTokens[i]).safeTransfer(sdlPool, _message.destTokenAmounts[i].amount);\n                }\n                ISDLPoolSecondary(sdlPool).distributeTokens(rewardTokens);\n                if (ISDLPoolSecondary(sdlPool).shouldUpdate()) shouldUpdate = true;\n            }\n        } else {\n            uint256 mintStartIndex = abi.decode(_message.data, (uint256));\n            ISDLPoolSecondary(sdlPool).handleIncomingUpdate(mintStartIndex);\n        }\n\n        emit MessageReceived(_message.messageId, _message.sourceChainSelector);\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @dev builds the message for outgoing updates to the primary chain\n     * @param _destination address of destination contract\n     * @param _numNewRESDLTokens number of new reSDL NFTs to be minted\n     * @param _totalRESDLSupplyChange reSDL supply change since last update\n     * @param _extraArgs encoded args as defined in CCIP API\n     **/\n    function _buildCCIPMessage(\n        address _destination,\n        uint256 _numNewRESDLTokens,\n        int256 _totalRESDLSupplyChange,\n        bytes memory _extraArgs\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_destination),\n            data: abi.encode(_numNewRESDLTokens, _totalRESDLSupplyChange),\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            extraArgs: _extraArgs,\n            feeToken: address(linkToken)\n        });\n\n        return evm2AnyMessage;\n    }\n\n    /**\n     * @notice Verifies the sender of a CCIP message is whitelisted\n     * @param _message CCIP message\n     **/\n    function _verifyCCIPSender(Client.Any2EVMMessage memory _message) internal view override {\n        address sender = abi.decode(_message.sender, (address));\n        uint64 sourceChainSelector = _message.sourceChainSelector;\n        if (sourceChainSelector != primaryChainSelector || sender != primaryChainDestination) revert SenderNotAuthorized();\n    }\n}"
    },
    {
      "filename": "contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./base/SDLPoolCCIPController.sol\";\nimport \"../interfaces/IERC677.sol\";\n\ninterface ISDLPoolPrimary is ISDLPool {\n    function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange) external returns (uint256);\n}\n\ncontract SDLPoolCCIPControllerPrimary is SDLPoolCCIPController {\n    using SafeERC20 for IERC20;\n\n    uint64[] internal whitelistedChains;\n    mapping(uint64 => address) public whitelistedDestinations;\n\n    mapping(uint64 => bytes) public updateExtraArgsByChain;\n    mapping(uint64 => bytes) public rewardsExtraArgsByChain;\n    mapping(uint64 => uint256) public reSDLSupplyByChain;\n\n    mapping(address => address) public wrappedRewardTokens;\n\n    address public rewardsInitiator;\n\n    event DistributeRewards(bytes32 indexed messageId, uint64 indexed destinationChainSelector, uint256 fees);\n    event ChainAdded(uint64 indexed chainSelector, address destination, bytes updateExtraArgs, bytes rewardsExtraArgs);\n    event ChainRemoved(uint64 indexed chainSelector, address destination);\n    event SetUpdateExtraArgs(uint64 indexed chainSelector, bytes extraArgs);\n    event SetRewardsExtraArgs(uint64 indexed chainSelector, bytes extraArgs);\n    event SetWrappedRewardToken(address indexed token, address rewardToken);\n\n    /**\n     * @notice Initializes the contract\n     * @param _router address of the CCIP router\n     * @param _linkToken address of the LINK token\n     * @param _sdlToken address of the SDL token\n     * @param _sdlPool address of the SDL Pool\n     * @param _maxLINKFee max fee to"
    }
  ]
}