{
  "Title": "M-8: BPT LP Token could be sold off during re-investment",
  "Content": "# Issue M-8: BPT LP Token could be sold off during re-investment \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/76 \n\n## Found by \nxiaoming90\n## Summary\n\nBPT LP Token could be sold off during the re-investment process. BPT LP Tokens must not be sold to external DEXs under any circumstance because:\n\n- They are used to redeem the underlying assets from the pool when someone exits the vault\n- The BPTs represent the total value of the vault\n\n## Vulnerability Detail\n\nWithin the `ConvexStakingMixin._isInvalidRewardToken` function, the implementation ensures that the LP Token (`CURVE_POOL_TOKEN`) is not intentionally or accidentally sold during the reinvestment process.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/curve/ConvexStakingMixin.sol#L64\n\n```solidity\nFile: ConvexStakingMixin.sol\n60:     function _isInvalidRewardToken(address token) internal override view returns (bool) {\n61:         return (\n62:             token == TOKEN_1 ||\n63:             token == TOKEN_2 ||\n64:             token == address(CURVE_POOL_TOKEN) ||\n65:             token == address(CONVEX_REWARD_POOL) ||\n66:             token == address(CONVEX_BOOSTER) ||\n67:             token == Deployments.ALT_ETH_ADDRESS\n68:         );\n69:     }\n```\n\nHowever, the same control was not implemented for the Balancer/Aura code. As a result, it is possible for LP Token (BPT) to be sold during reinvestment. Note that for non-composable Balancer pools, the pool tokens does not consists of the BPT token. Thus, it needs to be explicitly defined within the `_isInvalidRewardToken` function.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol#L38\n\n```solidity\nFile: AuraStakingMixin.sol\n38:     function _isInvalidRewardToken(address token) internal override view returns (bool) {\n39:         return (\n40:             token == TOKEN_1 ||\n41:             token == TOKEN_2 ||\n42:             token == TOKEN_3 ||\n43:             token == TOKEN_4 ||\n44:             token == TOKEN_5 ||\n45:             token == address(AURA_BOOSTER) ||\n46:             token == address(AURA_REWARD_POOL) ||\n47:             token == address(Deployments.WETH)\n48:         );\n49:     }\n```\n\nPer the sponsor's clarification below, the contracts should protect against the bot doing unintended things (including acting maliciously) due to coding errors, which is one of the main reasons for having the `_isInvalidRewardToken` function. Thus, this issue is a valid bug in the context of this audit contest.\n\nhttps://discord.com/channels/812037309376495636/1175450365395751023/1175781082336067655\n\n![](https://user-images.githubusercontent.com/102820284/285566722-10739ec2-fc8f-43f5-b681-459494d1b6dc.png)\n\n## Impact\n\nLP tokens (BPT) might be accidentally or maliciously sold off by the bots during the re-investment process. BPT LP Tokens must not be sold to external DEXs under any circumstance because:\n\n- They are used to redeem the underlying assets from the pool when someone exits the vault\n- The BPTs represent the total value of the vault\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol#L38\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the LP tokens cannot be sold off during re-investment.\n\n```diff\nfunction _isInvalidRewardToken(address token) internal override view returns (bool) {\n    return (\n        token == TOKEN_1 ||\n        token == TOKEN_2 ||\n        token == TOKEN_3 ||\n        token == TOKEN_4 ||\n        token == TOKEN_5 ||\n+       token == BALANCER_POOL_TOKEN ||\n        token == address(AURA_BOOSTER) ||\n        token == address(AURA_REWARD_POOL) ||\n        token == address(Deployments.WETH)\n    );\n}\n```\n\n\n\n## Discussion\n\n**jeffywu**\n\nValid issue.\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/66\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/ConvexStakingMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {TokenUtils, IERC20} from \"../../utils/TokenUtils.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {IConvexBooster} from \"../../../interfaces/convex/IConvexBooster.sol\";\nimport {IConvexRewardToken} from \"../../../interfaces/convex/IConvexRewardToken.sol\";\nimport {IConvexRewardPool, IConvexRewardPoolArbitrum} from \"../../../interfaces/convex/IConvexRewardPool.sol\";\nimport {Curve2TokenPoolMixin, DeploymentParams} from \"./Curve2TokenPoolMixin.sol\";\n\nstruct ConvexVaultDeploymentParams {\n    address rewardPool;\n    DeploymentParams baseParams;\n}\n\nabstract contract ConvexStakingMixin is Curve2TokenPoolMixin {\n    using TokenUtils for IERC20;\n\n    /// @notice Convex booster contract used for staking BPT\n    address internal immutable CONVEX_BOOSTER;\n    /// @notice Convex reward pool contract used for unstaking and claiming reward tokens\n    address internal immutable CONVEX_REWARD_POOL;\n    uint256 internal immutable CONVEX_POOL_ID;\n\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params) \n        Curve2TokenPoolMixin(notional_, params.baseParams) {\n        CONVEX_REWARD_POOL = params.rewardPool;\n\n        address convexBooster;\n        uint256 poolId;\n\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            IConvexRewardPool rewardPool = IConvexRewardPool(CONVEX_REWARD_POOL);\n\n            convexBooster = rewardPool.operator();\n            poolId = rewardPool.pid();\n\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            IConvexRewardPoolArbitrum rewardPool = IConvexRewardPoolArbitrum(CONVEX_REWARD_POOL);\n\n            convexBooster = rewardPool.convexBooster();\n            poolId = rewardPool.convexPoolId();\n        } else {\n            revert(\"Unsupported chain\");\n        }\n\n        CONVEX_POOL_ID = poolId;\n        CONVEX_BOOSTER = convexBooster;\n    }\n\n    function _initialApproveTokens() internal override {\n        // If either token is Deployments.ETH_ADDRESS the check approve will short circuit\n        IERC20(TOKEN_1).checkApprove(address(CURVE_POOL), type(uint256).max);\n        IERC20(TOKEN_2).checkApprove(address(CURVE_POOL), type(uint256).max);\n        CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n    }\n\n    function _isInvalidRewardToken(address token) internal override view returns (bool) {\n        return (\n            token == TOKEN_1 ||\n            token == TOKEN_2 ||\n            token == address(CURVE_POOL_TOKEN) ||\n            token == address(CONVEX_REWARD_POOL) ||\n            token == address(CONVEX_BOOSTER) ||\n            token == Deployments.ALT_ETH_ADDRESS\n        );\n    }\n\n    function _claimRewardTokens() internal override {\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            require(IConvexRewardPool(CONVEX_REWARD_POOL).getReward(address(this), true));\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            IConvexRewardPoolArbitrum(CONVEX_REWARD_POOL).getReward(address(this));\n        } else {\n            revert();\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {IAuraBooster, IAuraBoosterLite} from \"../../../../interfaces/aura/IAuraBooster.sol\";\nimport {IAuraRewardPool} from \"../../../../interfaces/aura/IAuraRewardPool.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {BalancerPoolMixin, DeploymentParams} from \"./BalancerPoolMixin.sol\";\nimport {TokenUtils} from \"../../../utils/TokenUtils.sol\";\n\n/// @notice Deployment parameters with Aura staking\nstruct AuraVaultDeploymentParams {\n    /// @notice Aura reward pool address\n    IAuraRewardPool rewardPool;\n    /// @notice Base deployment parameters\n    DeploymentParams baseParams;\n}\n\nabstract contract AuraStakingMixin is BalancerPoolMixin {\n    using TokenUtils for IERC20;\n\n    /// @notice Aura booster contract used for staking BPT\n    IAuraBooster internal immutable AURA_BOOSTER;\n    /// @notice Aura reward pool contract used for unstaking and claiming reward tokens\n    IAuraRewardPool internal immutable AURA_REWARD_POOL;\n    /// @notice Aura pool ID used for staking\n    uint256 internal immutable AURA_POOL_ID;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params)\n        BalancerPoolMixin(notional_, params.baseParams) {\n        AURA_REWARD_POOL = params.rewardPool;\n\n        AURA_BOOSTER = IAuraBooster(AURA_REWARD_POOL.operator());\n        AURA_POOL_ID = AURA_REWARD_POOL.pid();\n    }\n\n    function _isInvalidRewardToken(address token) internal override view returns (bool) {\n        return (\n            token == TOKEN_1 ||\n            token == TOKEN_2 ||\n            token == TOKEN_3 ||\n            token == TOKEN_4 ||\n            token == TOKEN_5 ||\n            token == address(AURA_BOOSTER) ||\n            token == address(AURA_REWARD_POOL) ||\n            token == address(Deployments.WETH)\n        );\n    }\n\n    /// @notice Called once on initialization to set token approvals\n    function _initialApproveTokens() internal override {\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            tokens[i].checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        }\n\n        // Approve Aura to transfer pool tokens for staking\n        POOL_TOKEN().checkApprove(address(AURA_BOOSTER), type(uint256).max);\n    }\n\n    /// @notice Claim reward tokens\n    function _claimRewardTokens() internal override {\n        // Claim all reward tokens including extra tokens\n        bool success = AURA_REWARD_POOL.getReward(address(this), true); // claimExtraRewards = true\n        require(success);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {IAuraBooster, IAuraBoosterLite} from \"../../../../interfaces/aura/IAuraBooster.sol\";\nimport {IAuraRewardPool} from \"../../../../interfaces/aura/IAuraRewardPool.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {BalancerPoolMixin, DeploymentParams} from \"./BalancerPoolMixin.sol\";\nimport {TokenUtils} from \"../../../utils/TokenUtils.sol\";\n\n/// @notice Deployment parameters with Aura staking\nstruct AuraVaultDeploymentParams {\n    /// @notice Aura reward pool address\n    IAuraRewardPool rewardPool;\n    /// @notice Base deployment parameters\n    DeploymentParams baseParams;\n}\n\nabstract contract AuraStakingMixin is BalancerPoolMixin {\n    using TokenUtils for IERC20;\n\n    /// @notice Aura booster contract used for staking BPT\n    IAuraBooster internal immutable AURA_BOOSTER;\n    /// @notice Aura reward pool contract used for unstaking and claiming reward tokens\n    IAuraRewardPool internal immutable AURA_REWARD_POOL;\n    /// @notice Aura pool ID used for staking\n    uint256 internal immutable AURA_POOL_ID;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params)\n        BalancerPoolMixin(notional_, params.baseParams) {\n        AURA_REWARD_POOL = params.rewardPool;\n\n        AURA_BOOSTER = IAuraBooster(AURA_REWARD_POOL.operator());\n        AURA_POOL_ID = AURA_REWARD_POOL.pid();\n    }\n\n    function _isInvalidRewardToken(address token) internal override view returns (bool) {\n        return (\n            token == TOKEN_1 ||\n            token == TOKEN_2 ||\n            token == TOKEN_3 ||\n            token == TOKEN_4 ||\n            token == TOKEN_5 ||\n            token == address(AURA_BOOSTER) ||\n            token == address(AURA_REWARD_POOL) ||\n            token == address(Deployments.WETH)\n        );\n    }\n\n    /// @notice Called once on initialization to set token approvals\n    function _initialApproveTokens() internal override {\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            tokens[i].checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        }\n\n        // Approve Aura to transfer pool tokens for staking\n        POOL_TOKEN().checkApprove(address(AURA_BOOSTER), type(uint256).max);\n    }\n\n    /// @notice Claim reward tokens\n    function _claimRewardTokens() internal override {\n        // Claim all reward tokens including extra tokens\n        bool success = AURA_REWARD_POOL.getReward(address(this), true); // claimExtraRewards = true\n        require(success);\n    }\n}"
    }
  ]
}