{
  "Title": "[G-04] Structs can be packed into fewer storage slots",
  "Content": "The EVM works with 32 byte words. Variables less than 32 bytes can be declared next to each other in storage and this will pack the values together into a single 32 byte storage slot (if values combined are <= 32 bytes). If the variables packed together are retrieved together in functions (more likely with structs), we will effectively save ~2000 gas with every subsequent SLOAD for that storage slot. This is due to us incurring a `Gwarmaccess (100 gas)` versus a `Gcoldsload (2100 gas)`.\n\nTotal Instances: `1`\n\nEstimated Gas Saved: `1 (slots) * 2000 = 2000`\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/esLBRBoost.sol#L18-L22\n\n### Reduce `uint` type for `unlockTime` and `duration` and pack into a single storage slot to save 1 SLOT (~2000 gas)\n```solidity\nFile: contracts/lybra/miner/esLBRBoost.sol\n18:    struct LockStatus {\n19:        uint256 unlockTime;\n20:        uint256 duration;\n21:        uint256 miningBoost;\n22:    }\n```\n```diff\ndiff --git a/lybra/miner/esLBRBoost.sol b/lybra/miner/esLBRBoost.sol\nindex c6a4d24..3bc785b 100644\n--- a/lybra/miner/esLBRBoost.sol\n+++ b/lybra/miner/esLBRBoost.sol\n@@ -16,8 +16,8 @@ contract esLBRBoost is Ownable {\n\n     // Define a struct for the user's lock status\n     struct LockStatus {\n-        uint256 unlockTime;\n-        uint256 duration;\n+        uint128 unlockTime;\n+        uint128 duration;\n         uint256 miningBoost;\n     }\n\n@@ -41,7 +41,7 @@ contract esLBRBoost is Ownable {\n         if (userStatus.unlockTime > block.timestamp) {\n             require(userStatus.duration <= _setting.duration, \"Your lock-in period has not ended, and the term can only be extended, not reduced.\");\n         }\n-        userLockStatus[msg.sender] = LockStatus(block.timestamp + _setting.duration, _setting.duration, _setting.miningBoost);\n+        userLockStatus[msg.sender] = LockStatus(uint128(block.timestamp + _setting.duration), uint128(_setting.duration), _setting.miningBoost);\n     }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/esLBRBoost.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract esLBRBoost is Ownable {\n    esLBRLockSetting[] public esLBRLockSettings;\n    mapping(address => LockStatus) public userLockStatus;\n\n    // Define a struct for the lock settings\n    struct esLBRLockSetting {\n        uint256 duration;\n        uint256 miningBoost;\n    }\n\n    // Define a struct for the user's lock status\n    struct LockStatus {\n        uint256 unlockTime;\n        uint256 duration;\n        uint256 miningBoost;\n    }\n\n    // Constructor to initialize the default lock settings\n    constructor() {\n        esLBRLockSettings.push(esLBRLockSetting(30 days, 20 * 1e18));\n        esLBRLockSettings.push(esLBRLockSetting(90 days, 30 * 1e18));\n        esLBRLockSettings.push(esLBRLockSetting(180 days, 50 * 1e18));\n        esLBRLockSettings.push(esLBRLockSetting(365 days, 100 * 1e18));\n    }\n\n    // Function to add a new lock setting\n    function addLockSetting(esLBRLockSetting memory setting) external onlyOwner {\n        esLBRLockSettings.push(setting);\n    }\n\n    // Function to set the user's lock status\n    function setLockStatus(uint256 id) external {\n        esLBRLockSetting memory _setting = esLBRLockSettings[id];\n        LockStatus memory userStatus = userLockStatus[msg.sender];\n        if (userStatus.unlockTime > block.timestamp) {\n            require(userStatus.duration <= _setting.duration, \"Your lock-in period has not ended, and the term can only be extended, not reduced.\");\n        }\n        userLockStatus[msg.sender] = LockStatus(block.timestamp + _setting.duration, _setting.duration, _setting.miningBoost);\n    }\n\n    // Function to get the user's unlock time\n    function getUnlockTime(address user) external view returns (uint256 unlockTime) {\n        unlockTime = userLockStatus[user].unlockTime;\n    }\n\n    /**\n     * @notice calculate the user's mining boost based on their lock status\n     * @dev Based on the user's userUpdatedAt time, finishAt time, and the current time,\n     * there are several scenarios that could occur, including no acceleration, full acceleration, and partial acceleration.\n     */\n    function getUserBoost(address user, uint256 userUpdatedAt, uint256 finishAt) external view returns (uint256) {\n        uint256 boostEndTime = userLockStatus[user].unlockTime;\n        uint256 maxBoost = userLockStatus[user].miningBoost;\n        if (userUpdatedAt >= boostEndTime || userUpdatedAt >= finishAt) {\n            return 0;\n        }\n        if (finishAt <= boostEndTime || block.timestamp <= boostEndTime) {\n            return maxBoost;\n        } else {\n            uint256 time = block.timestamp > finishAt ? finishAt : block.timestamp;\n            return ((boostEndTime - userUpdatedAt) * maxBoost) / (time - userUpdatedAt);\n        }\n    }\n}"
    }
  ]
}