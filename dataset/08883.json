{
  "Title": "[L-07] `_prepareDeadline()`, `_setConfig()`, and `_executeDeadline()` should be `private`",
  "Content": "<h2 id=\"l-07-_preparedeadline-_setconfig-and-_executedeadline-should-be-private\" style=\"position:relative;\"><a href=\"#l-07-_preparedeadline-_setconfig-and-_executedeadline-should-be-private\" aria-label=\"l 07 _preparedeadline _setconfig and _executedeadline should be private permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-07] <code>_prepareDeadline()</code>, <code>_setConfig()</code>, and <code>_executeDeadline()</code> should be <code>private</code></h2>\n<p>I flagged this in the last Backd contest, but it doesnâ€™t seem to have been addressed, so bringing it up again: These functions have the ability to bypass the timelocks of every setting. No contract besides the <code>Preparable</code> contract itself should need to call these functions, and having them available will lead to exploits. The contracts that currently call <code>_setConfig()</code> in their constructors should be given a new function <code>_initConfig()</code> for this purpose. The <code>Vault</code> <a href=\"https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L222\">calls</a> some of these functions as well, and should be changed to manually inspect the deadline rather than mucking with the internals, which is error-prone. The mappings should also be made <code>private</code>, and there should be public getters to read their values</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"45\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">protocol</span><span class=\"mtk1\">/</span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">utils</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Preparable</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">115</span><span class=\"mtk1\">      </span><span class=\"mtk3\">/**</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">116       * </span><span class=\"mtk4\">@notice</span><span class=\"mtk3\"> Execute uint256 config update (with time delay enforced).</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">117       * </span><span class=\"mtk4\">@dev</span><span class=\"mtk3\"> Needs to be called after the update was prepared. Fails if called before time delay is met.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">118       * </span><span class=\"mtk4\">@return</span><span class=\"mtk3\"> New value.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">119       */</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">120</span><span class=\"mtk1\">      </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_executeUInt256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">key</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">121</span><span class=\"mtk1\">          </span><span class=\"mtk11\">_executeDeadline</span><span class=\"mtk1\">(</span><span class=\"mtk12\">key</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">122</span><span class=\"mtk1\">          </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newValue</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">pendingUInts256</span><span class=\"mtk1\">[</span><span class=\"mtk12\">key</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">123</span><span class=\"mtk1\">          </span><span class=\"mtk11\">_setConfig</span><span class=\"mtk1\">(</span><span class=\"mtk12\">key</span><span class=\"mtk1\">, </span><span class=\"mtk12\">newValue</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">124</span><span class=\"mtk1\">          </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newValue</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">125</span><span class=\"mtk1\">      }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">126</span><span class=\"mtk1\">  </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">127</span><span class=\"mtk1\">      </span><span class=\"mtk3\">/**</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">128       * </span><span class=\"mtk4\">@notice</span><span class=\"mtk3\"> Execute address config update (with time delay enforced).</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">129       * </span><span class=\"mtk4\">@dev</span><span class=\"mtk3\"> Needs to be called after the update was prepared. Fails if called before time delay is met.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">130       * </span><span class=\"mtk4\">@return</span><span class=\"mtk3\"> New value.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">131       */</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">132</span><span class=\"mtk1\">      </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_executeAddress</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">key</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">address</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">133</span><span class=\"mtk1\">          </span><span class=\"mtk11\">_executeDeadline</span><span class=\"mtk1\">(</span><span class=\"mtk12\">key</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">134</span><span class=\"mtk1\">          </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newValue</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">pendingAddresses</span><span class=\"mtk1\">[</span><span class=\"mtk12\">key</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">135</span><span class=\"mtk1\">          </span><span class=\"mtk11\">_setConfig</span><span class=\"mtk1\">(</span><span class=\"mtk12\">key</span><span class=\"mtk1\">, </span><span class=\"mtk12\">newValue</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">136</span><span class=\"mtk1\">          </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newValue</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">137</span><span class=\"mtk1\">:     }</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L115-L137\">https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L115-L137</a></p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "backd/contracts/vault/Vault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/IVault.sol\";\nimport \"../../interfaces/IVaultReserve.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IStrategy.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/EnumerableExtensions.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"./VaultStorage.sol\";\nimport \"../utils/Preparable.sol\";\nimport \"../utils/IPausable.sol\";\nimport \"../access/Authorization.sol\";\n\nabstract contract Vault is IVault, Authorization, VaultStorageV1, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using EnumerableMapping for EnumerableMapping.AddressToUintMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;\n    using AddressProviderHelpers for IAddressProvider;\n\n    bytes32 internal constant _STRATEGY_KEY = \"Strategy\";\n    bytes32 internal constant _PERFORMANCE_FEE_KEY = \"PerformanceFee\";\n    bytes32 internal constant _STRATEGIST_FEE_KEY = \"StrategistFee\";\n    bytes32 internal constant _DEBT_LIMIT_KEY = \"DebtLimit\";\n    bytes32 internal constant _TARGET_ALLOCATION_KEY = \"TargetAllocation\";\n    bytes32 internal constant _RESERVE_FEE_KEY = \"ReserveFee\";\n    bytes32 internal constant _BOUND_KEY = \"Bound\";\n\n    uint256 internal constant _INITIAL_RESERVE_FEE = 0.01e18;\n    uint256 internal constant _INITIAL_STRATEGIST_FEE = 0.1e18;\n    uint256 internal constant _INITIAL_PERFORMANCE_FEE = 0;\n\n    uint256 public constant MAX_PERFORMANCE_FEE = 0.5e18;\n    uint256 public constant MAX_DEVIATION_BOUND = 0.5e18;\n    uint256 public constant STRATEGY_DELAY = 5 days;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n    IVaultReserve public immutable reserve;\n\n    modifier onlyPool() {\n        require(msg.sender == pool, Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    modifier onlyPoolOrGovernance() {\n        require(\n            msg.sender == pool || _roleManager().hasRole(Roles.GOVERNANCE, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _;\n    }\n\n    modifier onlyPoolOrMaintenance() {\n        require(\n            msg.sender == pool || _roleManager().hasRole(Roles.MAINTENANCE, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _;\n    }\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        IAddressProvider addressProvider_ = _controller.addressProvider();\n        addressProvider = addressProvider_;\n        reserve = IVaultReserve(addressProvider_.getVaultReserve());\n    }\n\n    function _initialize(\n        address _pool,\n        uint256 _debtLimit,\n        uint256 _targetAllocation,\n        uint256 _bound\n    ) internal {\n        require(_debtLimit <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(_targetAllocation <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(_bound <= MAX_DEVIATION_BOUND, Error.INVALID_AMOUNT);\n\n        pool = _pool;\n\n        _setConfig(_DEBT_LIMIT_KEY, _debtLimit);\n        _setConfig(_TARGET_ALLOCATION_KEY, _targetAllocation);\n        _setConfig(_BOUND_KEY, _bound);\n        _setConfig(_RESERVE_FEE_KEY, _INITIAL_RESERVE_FEE);\n        _setConfig(_STRATEGIST_FEE_KEY, _INITIAL_STRATEGIST_FEE);\n        _setConfig(_PERFORMANCE_FEE_KEY, _INITIAL_PERFORMANCE_FEE);\n    }\n\n    /**\n     * @notice Handles deposits from the liquidity pool\n     */\n    function deposit() external payable override onlyPoolOrMaintenance {\n        // solhint-disable-previous-line ordering\n        _deposit();\n    }\n\n    /**\n     * @notice Withdraws specified amount of underlying from vault.\n     * @dev If the specified amount exceeds idle funds, an amount of funds is withdrawn\n     *      from the strategy such that it will achieve a target allocation for after the\n     *      amount has been withdrawn.\n     * @param amount Amount to withdraw.\n     * @return `true` if successful.\n     */\n    function withdraw(uint256 amount) external override onlyPoolOrGovernance returns (bool) {\n        IStrategy strategy = getStrategy();\n        uint256 availableUnderlying_ = _availableUnderlying();\n\n        if (availableUnderlying_ < amount) {\n            if (address(strategy) == address(0)) return false;\n            uint256 allocated = strategy.balance();\n            uint256 requiredWithdrawal = amount - availableUnderlying_;\n\n            if (requiredWithdrawal > allocated) return false;\n\n            // compute withdrawal amount to sustain target allocation\n            uint256 newTarget = (allocated - requiredWithdrawal).scaledMul(getTargetAllocation());\n            uint256 excessAmount = allocated - newTarget;\n            strategy.withdraw(excessAmount);\n            currentAllocated = _computeNewAllocated(currentAllocated, excessAmount);\n        } else {\n            uint256 allocatedUnderlying = 0;\n            if (address(strategy) != address(0))\n                allocatedUnderlying = IStrategy(strategy).balance();\n            uint256 totalUnderlying = availableUnderlying_ +\n                allocatedUnderlying +\n                waitingForRemovalAllocated;\n            uint256 totalUnderlyingAfterWithdraw = totalUnderlying - amount;\n            _rebalance(totalUnderlyingAfterWithdraw, allocatedUnderlying);\n        }\n\n        _transfer(pool, amount);\n        return true;\n    }\n\n    /**\n     * @notice Withdraws all funds from vault and strategy and transfer them to the pool.\n     */\n    function withdrawAll() external override onlyPoolOrGovernance {\n        _withdrawAllFromStrategy();\n        _transfer(pool, _availableUnderlying());\n    }\n\n    /**\n     * @notice Withdraws specified amount of underlying from reserve to vault.\n     * @dev Withdraws from reserve will cause a spike in pool exchange rate.\n     *  Pool deposits should be paused during this to prevent front running\n     * @param amount Amount to withdraw.\n     */\n    function withdrawFromReserve(uint256 amount) external override onlyGovernance {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(IPausable(pool).isPaused(), Error.POOL_NOT_PAUSED);\n        uint256 reserveBalance_ = reserve.getBalance(address(this), getUnderlying());\n        require(amount <= reserveBalance_, Error.INSUFFICIENT_BALANCE);\n        reserve.withdraw(getUnderlying(), amount);\n    }\n\n    /**\n     * @notice Activate the current strategy set for the vault.\n     * @return `true` if strategy has been activated\n     */\n    function activateStrategy() external onlyGovernance returns (bool) {\n        return _activateStrategy();\n    }\n\n    /**\n     * @notice Deactivates a strategy.\n     * @return `true` if strategy has been deactivated\n     */\n    function deactivateStrategy() external onlyGovernance returns (bool) {\n        return _deactivateStrategy();\n    }\n\n    /**\n     * @notice Initializes the vault's strategy.\n     * @dev Bypasses the time delay, but can only be called if strategy is not set already.\n     * @param strategy_ Address of the strategy.\n     * @return `true` if successful.\n     */\n    function initializeStrategy(address strategy_) external override onlyGovernance returns (bool) {\n        require(currentAddresses[_STRATEGY_KEY] == address(0), Error.ADDRESS_ALREADY_SET);\n        require(strategy_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        _setConfig(_STRATEGY_KEY, strategy_);\n        _activateStrategy();\n        require(IStrategy(strategy_).strategist() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of the vault's strategy (with time delay enforced).\n     * @param newStrategy Address of the new strategy.\n     * @return `true` if successful.\n     */\n    function prepareNewStrategy(address newStrategy)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_STRATEGY_KEY, newStrategy, STRATEGY_DELAY);\n    }\n\n    /**\n     * @notice Execute strategy update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New strategy address.\n     */\n    function executeNewStrategy() external override returns (address) {\n        _executeDeadline(_STRATEGY_KEY);\n        IStrategy strategy = getStrategy();\n        if (address(strategy) != address(0)) {\n            _harvest();\n            strategy.shutdown();\n            strategy.withdrawAll();\n\n            // there might still be some balance left if the strategy did not\n            // manage to withdraw all funds (e.g. due to locking)\n            uint256 remainingStrategyBalance = strategy.balance();\n            if (remainingStrategyBalance > 0) {\n                _strategiesWaitingForRemoval.set(address(strategy), remainingStrategyBalance);\n                waitingForRemovalAllocated += remainingStrategyBalance;\n            }\n        }\n        _deactivateStrategy();\n        currentAllocated = 0;\n        totalDebt = 0;\n        address newStrategy = pendingAddresses[_STRATEGY_KEY];\n        _setConfig(_STRATEGY_KEY, newStrategy);\n\n        if (newStrategy != address(0)) {\n            _activateStrategy();\n        }\n\n        return newStrategy;\n    }\n\n    function resetNewStrategy() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_STRATEGY_KEY);\n    }\n\n    /**\n     * @notice Prepare update of performance fee (with time delay enforced).\n     * @param newPerformanceFee New performance fee value.\n     * @return `true` if successful.\n     */\n    function preparePerformanceFee(uint256 newPerformanceFee)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(newPerformanceFee <= MAX_PERFORMANCE_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_PERFORMANCE_FEE_KEY, newPerformanceFee);\n    }\n\n    /**\n     * @notice Execute update of performance fee (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New performance fee.\n     */\n    function executePerformanceFee() external returns (uint256) {\n        return _executeUInt256(_PERFORMANCE_FEE_KEY);\n    }\n\n    function resetPerformanceFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_PERFORMANCE_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of strategist fee (with time delay enforced).\n     * @param newStrategistFee New strategist fee value.\n     * @return `true` if successful.\n     */\n    function prepareStrategistFee(uint256 newStrategistFee) external onlyGovernance returns (bool) {\n        _checkFeesInvariant(getReserveFee(), newStrategistFee);\n        return _prepare(_STRATEGIST_FEE_KEY, newStrategistFee);\n    }\n\n    /**\n     * @notice Execute update of strategist fee (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New strategist fee.\n     */\n    function executeStrategistFee() external returns (uint256) {\n        uint256 newStrategistFee = _executeUInt256(_STRATEGIST_FEE_KEY);\n        _checkFeesInvariant(getReserveFee(), newStrategistFee);\n        return newStrategistFee;\n    }\n\n    function resetStrategistFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_STRATEGIST_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of debt limit (with time delay enforced).\n     * @param newDebtLimit New debt limit.\n     * @return `true` if successful.\n     */\n    function prepareDebtLimit(uint256 newDebtLimit) external onlyGovernance returns (bool) {\n        return _prepare(_DEBT_LIMIT_KEY, newDebtLimit);\n    }\n\n    /**\n     * @notice Execute update of debt limit (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New debt limit.\n     */\n    function executeDebtLimit() external returns (uint256) {\n        uint256 debtLimit = _executeUInt256(_DEBT_LIMIT_KEY);\n        uint256 debtLimitAllocated = currentAllocated.scaledMul(debtLimit);\n        if (totalDebt >= debtLimitAllocated) {\n            _handleExcessDebt();\n        }\n        return debtLimit;\n    }\n\n    function resetDebtLimit() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_DEBT_LIMIT_KEY);\n    }\n\n    /**\n     * @notice Prepare update of target allocation (with time delay enforced).\n     * @param newTargetAllocation New target allocation.\n     * @return `true` if successful.\n     */\n    function prepareTargetAllocation(uint256 newTargetAllocation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_TARGET_ALLOCATION_KEY, newTargetAllocation);\n    }\n\n    /**\n     * @notice Execute update of target allocation (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New target allocation.\n     */\n    function executeTargetAllocation() external returns (uint256) {\n        uint256 targetAllocation = _executeUInt256(_TARGET_ALLOCATION_KEY);\n        _deposit();\n        return targetAllocation;\n    }\n\n    function resetTargetAllocation() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_TARGET_ALLOCATION_KEY);\n    }\n\n    /**\n     * @notice Prepare update of reserve fee (with time delay enforced).\n     * @param newReserveFee New reserve fee.\n     * @return `true` if successful.\n     */\n    function prepareReserveFee(uint256 newReserveFee) external onlyGovernance returns (bool) {\n        _checkFeesInvariant(newReserveFee, getStrategistFee());\n        return _prepare(_RESERVE_FEE_KEY, newReserveFee);\n    }\n\n    /**\n     * @notice Execute update of reserve fee (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New reserve fee.\n     */\n    function executeReserveFee() external returns (uint256) {\n        uint256 newReserveFee = _executeUInt256(_RESERVE_FEE_KEY);\n        _checkFeesInvariant(newReserveFee, getStrategistFee());\n        return newReserveFee;\n    }\n\n    function resetReserveFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_RESERVE_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of deviation bound for strategy allocation (with time delay enforced).\n     * @param newBound New deviation bound for target allocation.\n     * @return `true` if successful.\n     */\n    function prepareBound(uint256 newBound) external onlyGovernance returns (bool) {\n        require(newBound <= MAX_DEVIATION_BOUND, Error.INVALID_AMOUNT);\n        return _prepare(_BOUND_KEY, newBound);\n    }\n\n    /**\n     * @notice Execute update of deviation bound for strategy allocation (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New deviation bound.\n     */\n    function executeBound() external returns (uint256) {\n        uint256 bound = _executeUInt256(_BOUND_KEY);\n        _deposit();\n        return bound;\n    }\n\n    function resetBound() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_BOUND_KEY);\n    }\n\n    /**\n     * @notice Withdraws an amount of underlying from the strategy to the vault.\n     * @param amount Amount of underlying to withdraw.\n     * @return True if successful withdrawal.\n     */\n    function withdrawFromStrategy(uint256 amount) external onlyGovernance returns (bool) {\n        IStrategy strategy = getStrategy();\n        if (address(strategy) == address(0)) return false;\n        if (strategy.balance() < amount) return false;\n        uint256 oldBalance = _availableUnderlying();\n        strategy.withdraw(amount);\n        uint256 newBalance = _availableUnderlying();\n        currentAllocated -= newBalance - oldBalance;\n        return true;\n    }\n\n    function withdrawFromStrategyWaitingForRemoval(address strategy) external returns (uint256) {\n        (bool exists, uint256 allocated) = _strategiesWaitingForRemoval.tryGet(strategy);\n        require(exists, Error.STRATEGY_DOES_NOT_EXIST);\n\n        IStrategy strategy_ = IStrategy(strategy);\n\n        strategy_.harvest();\n        uint256 withdrawn = strategy_.withdrawAll();\n\n        uint256 _waitingForRemovalAllocated = waitingForRemovalAllocated;\n        if (withdrawn >= _waitingForRemovalAllocated) {\n            waitingForRemovalAllocated = 0;\n        } else {\n            waitingForRemovalAllocated = _waitingForRemovalAllocated - withdrawn;\n        }\n\n        if (withdrawn > allocated) {\n            uint256 profit = withdrawn - allocated;\n            uint256 strategistShare = _shareFees(profit.scaledMul(getPerformanceFee()));\n            if (strategistShare > 0) {\n                _payStrategist(strategistShare, strategy_.strategist());\n            }\n            allocated = 0;\n            emit Harvest(profit, 0);\n        } else {\n            allocated -= withdrawn;\n        }\n\n        if (strategy_.balance() == 0) {\n            _strategiesWaitingForRemoval.remove(address(strategy_));\n        } else {\n            _strategiesWaitingForRemoval.set(address(strategy_), allocated);\n        }\n\n        return withdrawn;\n    }\n\n    function getStrategiesWaitingForRemoval() external view returns (address[] memory) {\n        return _strategiesWaitingForRemoval.keysArray();\n    }\n\n    /**\n     * @notice Computes the total underlying of the vault: idle funds + allocated funds - debt\n     * @return Total amount of underlying.\n     */\n    function getTotalUnderlying() external view override returns (uint256) {\n        uint256 availableUnderlying_ = _availableUnderlying();\n\n        if (address(getStrategy()) == address(0)) {\n            return availableUnderlying_;\n        }\n\n        uint256 netUnderlying = availableUnderlying_ +\n            currentAllocated +\n            waitingForRemovalAllocated;\n        if (totalDebt <= netUnderlying) return netUnderlying - totalDebt;\n        return 0;\n    }\n\n    function getAllocatedToStrategyWaitingForRemoval(address strategy)\n        external\n        view\n        returns (uint256)\n    {\n        return _strategiesWaitingForRemoval.get(strategy);\n    }\n\n    /**\n     * @notice Withdraws all funds from strategy to vault.\n     * @dev Harvests profits before withdrawing. Deactivates strategy after withdrawing.\n     * @return `true` if successful.\n     */\n    function withdrawAllFromStrategy() public onlyPoolOrGovernance returns (bool) {\n        return _withdrawAllFromStrategy();\n    }\n\n    /**\n     * @notice Harvest profits from the vault's strategy.\n     * @dev Harvesting adds profits to the vault's balance and deducts fees.\n     *  No performance fees are charged on profit used to repay debt.\n     * @return `true` if successful.\n     */\n    function harvest() public onlyPoolOrMaintenance returns (bool) {\n        return _harvest();\n    }\n\n    /**\n     * @notice Returns the percentage of the performance fee that goes to the strategist.\n     */\n    function getStrategistFee() public view returns (uint256) {\n        return currentUInts256[_STRATEGIST_FEE_KEY];\n    }\n\n    function getStrategy() public view override returns (IStrategy) {\n        return IStrategy(currentAddresses[_STRATEGY_KEY]);\n    }\n\n    /**\n     * @notice Returns the percentage of the performance fee which is allocated to the vault reserve\n     */\n    function getReserveFee() public view returns (uint256) {\n        return currentUInts256[_RESERVE_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the fee charged on a strategy's generated profits.\n     * @dev The strategist is paid in LP tokens, while the remainder of the profit stays in the vault.\n     *      Default performance fee is set to 5% of harvested profits.\n     */\n    function getPerformanceFee() public view returns (uint256) {\n        return currentUInts256[_PERFORMANCE_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the allowed symmetric bound for target allocation (e.g. +- 5%)\n     */\n    function getBound() public view returns (uint256) {\n        return currentUInts256[_BOUND_KEY];\n    }\n\n    /**\n     * @notice The target percentage of total underlying funds to be allocated towards a strategy.\n     * @dev this is to reduce gas costs. Withdrawals first come from idle funds and can therefore\n     *      avoid unnecessary gas costs.\n     */\n    function getTargetAllocation() public view returns (uint256) {\n        return currentUInts256[_TARGET_ALLOCATION_KEY];\n    }\n\n    /**\n     * @notice The debt limit that the total debt of a strategy may not exceed.\n     */\n    function getDebtLimit() public view returns (uint256) {\n        return currentUInts256[_DEBT_LIMIT_KEY];\n    }\n\n    function getUnderlying() public view virtual override returns (address);\n\n    function _activateStrategy() internal returns (bool) {\n        IStrategy strategy = getStrategy();\n        if (address(strategy) == address(0)) return false;\n\n        strategyActive = true;\n        emit StrategyActivated(address(strategy));\n        _deposit();\n        return true;\n    }\n\n    function _harvest() internal returns (bool) {\n        IStrategy strategy = getStrategy();\n        if (address(strategy) == address(0)) {\n            return false;\n        }\n\n        strategy.harvest();\n\n        uint256 strategistShare = 0;\n\n        uint256 allocatedUnderlying = strategy.balance();\n        uint256 amountAllocated = currentAllocated;\n        uint256 currentDebt = totalDebt;\n\n        if (allocatedUnderlying > amountAllocated) {\n            // we made profits\n            uint256 profit = allocatedUnderlying - amountAllocated;\n\n            if (profit > currentDebt) {\n                if (currentDebt > 0) {\n                    profit -= currentDebt;\n                    currentDebt = 0;\n                }\n                (profit, strategistShare) = _shareProfit(profit);\n            } else {\n                currentDebt -= profit;\n            }\n            emit Harvest(profit, 0);\n        } else if (allocatedUnderlying < amountAllocated) {\n            // we made a loss\n            uint256 loss = amountAllocated - allocatedUnderlying;\n            currentDebt += loss;\n\n            // check debt limit and withdraw funds if exceeded\n            uint256 debtLimit = getDebtLimit();\n            uint256 debtLimitAllocated = amountAllocated.scaledMul(debtLimit);\n            if (currentDebt > debtLimitAllocated) {\n                currentDebt = _handleExcessDebt(currentDebt);\n            }\n            emit Harvest(0, loss);\n        } else {\n            // nothing to declare\n            return true;\n        }\n\n        totalDebt = currentDebt;\n        currentAllocated = strategy.balance();\n\n        if (strategistShare > 0) {\n            _payStrategist(strategistShare);\n        }\n\n        return true;\n    }\n\n    function _withdrawAllFromStrategy() internal returns (bool) {\n        IStrategy strategy = getStrategy();\n        if (address(strategy) == address(0)) return false;\n        _harvest();\n        uint256 oldBalance = _availableUnderlying();\n        strategy.withdrawAll();\n        uint256 newBalance = _availableUnderlying();\n        uint256 withdrawnAmount = newBalance - oldBalance;\n\n        currentAllocated = _computeNewAllocated(currentAllocated, withdrawnAmount);\n        _deactivateStrategy();\n        return true;\n    }\n\n    function _handleExcessDebt(uint256 currentDebt) internal returns (uint256) {\n        uint256 underlyingReserves = reserve.getBalance(address(this), getUnderlying());\n        if (currentDebt > underlyingReserves) {\n            _emergencyStop(underlyingReserves);\n        } else if (reserve.canWithdraw(address(this))) {\n            reserve.withdraw(getUnderlying(), currentDebt);\n            currentDebt = 0;\n            _deposit();\n        }\n        return currentDebt;\n    }\n\n    function _handleExcessDebt() internal {\n        uint256 currentDebt = totalDebt;\n        uint256 newDebt = _handleExcessDebt(totalDebt);\n        if (currentDebt != newDebt) {\n            totalDebt = newDebt;\n        }\n    }\n\n    /**\n     * @notice Invest the underlying money in the vault after a deposit from the pool is made.\n     * @dev After each deposit, the vault checks whether it needs to rebalance underlying funds allocated to strategy.\n     * If no strategy is set then all deposited funds will be idle.\n     */\n    function _deposit() internal {\n        if (!strategyActive) return;\n\n        uint256 allocatedUnderlying = getStrategy().balance();\n        uint256 totalUnderlying = _availableUnderlying() +\n            allocatedUnderlying +\n            waitingForRemovalAllocated;\n\n        if (totalUnderlying == 0) return;\n        _rebalance(totalUnderlying, allocatedUnderlying);\n    }\n\n    function _shareProfit(uint256 profit) internal returns (uint256, uint256) {\n        uint256 totalFeeAmount = profit.scaledMul(getPerformanceFee());\n        if (_availableUnderlying() < totalFeeAmount) {\n            getStrategy().withdraw(totalFeeAmount);\n        }\n        uint256 strategistShare = _shareFees(totalFeeAmount);\n\n        return ((profit - totalFeeAmount), strategistShare);\n    }\n\n    function _shareFees(uint256 totalFeeAmount) internal returns (uint256) {\n        uint256 strategistShare = totalFeeAmount.scaledMul(getStrategistFee());\n\n        uint256 reserveShare = totalFeeAmount.scaledMul(getReserveFee());\n        uint256 treasuryShare = totalFeeAmount - strategistShare - reserveShare;\n\n        _depositToReserve(reserveShare);\n        if (treasuryShare > 0) {\n            _depositToTreasury(treasuryShare);\n        }\n        return strategistShare;\n    }\n\n    function _emergencyStop(uint256 underlyingReserves) internal {\n        // debt limit exceeded: withdraw funds from strategy\n        uint256 withdrawn = getStrategy().withdrawAll();\n\n        uint256 actualDebt = _computeNewAllocated(currentAllocated, withdrawn);\n\n        if (reserve.canWithdraw(address(this))) {\n            // check if debt can be covered with reserve funds\n            if (underlyingReserves >= actualDebt) {\n                reserve.withdraw(getUnderlying(), actualDebt);\n            } else if (underlyingReserves > 0) {\n                // debt can not be covered with reserves\n                reserve.withdraw(getUnderlying(), underlyingReserves);\n            }\n        }\n\n        // too much money lost, stop the strategy\n        _deactivateStrategy();\n    }\n\n    /**\n     * @notice Deactivates a strategy. All positions of the strategy are exited.\n     * @return `true` if strategy has been deactivated\n     */\n    function _deactivateStrategy() internal returns (bool) {\n        if (!strategyActive) return false;\n\n        strategyActive = false;\n        emit StrategyDeactivated(address(getStrategy()));\n        return true;\n    }\n\n    function _payStrategist(uint256 amount) internal {\n        _payStrategist(amount, getStrategy().strategist());\n    }\n\n    function _payStrategist(uint256 amount, address strategist) internal virtual;\n\n    function _transfer(address to, uint256 amount) internal virtual;\n\n    function _depositToReserve(uint256 amount) internal virtual;\n\n    function _depositToTreasury(uint256 amount) internal virtual;\n\n    function _availableUnderlying() internal view virtual returns (uint256);\n\n    function _computeNewAllocated(uint256 allocated, uint256 withdrawn)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (allocated > withdrawn) {\n            return allocated - withdrawn;\n        }\n        return 0;\n    }\n\n    function _checkFeesInvariant(uint256 reserveFee, uint256 strategistFee) internal pure {\n        require(\n            reserveFee + strategistFee <= ScaledMath.ONE,\n            \"sum of strategist fee and reserve fee should be below 1\"\n        );\n    }\n\n    function _rebalance(uint256 totalUnderlying, uint256 allocatedUnderlying)\n        private\n        returns (bool)\n    {\n        if (!strategyActive) return false;\n        uint256 targetAllocation = getTargetAllocation();\n\n        IStrategy strategy = getStrategy();\n        uint256 bound = getBound();\n\n        uint256 target = totalUnderlying.scaledMul(targetAllocation);\n        uint256 upperBound = targetAllocation == 0 ? 0 : targetAllocation + bound;\n        upperBound = upperBound > ScaledMath.ONE ? ScaledMath.ONE : upperBound;\n        uint256 lowerBound = bound > targetAllocation ? 0 : targetAllocation - bound;\n        if (allocatedUnderlying > totalUnderlying.scaledMul(upperBound)) {\n            // withdraw funds from strategy\n            uint256 withdrawAmount = allocatedUnderlying - target;\n            strategy.withdraw(withdrawAmount);\n\n            currentAllocated = _computeNewAllocated(currentAllocated, withdrawAmount);\n        } else if (allocatedUnderlying < totalUnderlying.scaledMul(lowerBound)) {\n            // allocate more funds to strategy\n            uint256 depositAmount = target - allocatedUnderlying;\n            _transfer(address(strategy), depositAmount);\n            currentAllocated += depositAmount;\n            strategy.deposit();\n        }\n        return true;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/utils/Preparable.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"../../interfaces/IPreparable.sol\";\nimport \"../../libraries/Errors.sol\";\n\n/**\n * @notice Implements the base logic for a two-phase commit\n * @dev This does not implements any access-control so publicly exposed\n * callers should make sure to have the proper checks in place\n */\ncontract Preparable is IPreparable {\n    uint256 private constant _MIN_DELAY = 3 days;\n\n    mapping(bytes32 => address) public pendingAddresses;\n    mapping(bytes32 => uint256) public pendingUInts256;\n\n    mapping(bytes32 => address) public currentAddresses;\n    mapping(bytes32 => uint256) public currentUInts256;\n\n    /**\n     * @dev Deadlines shares the same namespace regardless of the type\n     * of the pending variable so this needs to be enforced in the caller\n     */\n    mapping(bytes32 => uint256) public deadlines;\n\n    function _prepareDeadline(bytes32 key, uint256 delay) internal {\n        require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO);\n        require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);\n        deadlines[key] = block.timestamp + delay;\n    }\n\n    /**\n     * @notice Prepares an uint256 that should be committed to the contract\n     * after `_MIN_DELAY` elapsed\n     * @param value The value to prepare\n     * @return `true` if success.\n     */\n    function _prepare(\n        bytes32 key,\n        uint256 value,\n        uint256 delay\n    ) internal returns (bool) {\n        _prepareDeadline(key, delay);\n        pendingUInts256[key] = value;\n        emit ConfigPreparedNumber(key, value, delay);\n        return true;\n    }\n\n    /**\n     * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay\n     */\n    function _prepare(bytes32 key, uint256 value) internal returns (bool) {\n        return _prepare(key, value, _MIN_DELAY);\n    }\n\n    /**\n     * @notice Prepares an address that should be committed to the contract\n     * after `_MIN_DELAY` elapsed\n     * @param value The value to prepare\n     * @return `true` if success.\n     */\n    function _prepare(\n        bytes32 key,\n        address value,\n        uint256 delay\n    ) internal returns (bool) {\n        _prepareDeadline(key, delay);\n        pendingAddresses[key] = value;\n        emit ConfigPreparedAddress(key, value, delay);\n        return true;\n    }\n\n    /**\n     * @notice Same as `_prepare(bytes32,address,uint256)` but uses a default delay\n     */\n    function _prepare(bytes32 key, address value) internal returns (bool) {\n        return _prepare(key, value, _MIN_DELAY);\n    }\n\n    /**\n     * @notice Reset a uint256 key\n     * @return `true` if success.\n     */\n    function _resetUInt256Config(bytes32 key) internal returns (bool) {\n        require(deadlines[key] != 0, Error.NOTHING_PENDING);\n        deadlines[key] = 0;\n        pendingUInts256[key] = 0;\n        emit ConfigReset(key);\n        return true;\n    }\n\n    /**\n     * @notice Reset an address key\n     * @return `true` if success.\n     */\n    function _resetAddressConfig(bytes32 key) internal returns (bool) {\n        require(deadlines[key] != 0, Err"
    }
  ]
}