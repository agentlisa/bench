{
  "Title": "[L06] Lack of input validation",
  "Content": "Although most of the functions throughout the codebase properly validate function inputs, there are some instances of functions that do not. For example:\n\n\n* [`verifyConstructorParams`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L462) is called from [`baseInitialize`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L117) of `RibbonVault`. However, neither function validates the input for the `_managementFee` argument of `baseInitialize`.\n* [`verifyConstructorParams`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L462) does not check that `_vaultParams.minimumSupply` < `_vaultParams.cap`. If this inequality does not hold, there could be states where it would be impossible to deposit asset into the vault.\n* [`setFeeRecipient`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L159) does not check that `newFeeRecipient` is not the same as the existing `feeRecipient`.\n* [`setDelta`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/utils/StrikeSelection.sol#L198) and [`setStep`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/utils/StrikeSelection.sol#L208) do not perform any sort of input validation.\n* `StrikeSelection`‘s [`constructor`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/utils/StrikeSelection.sol#L37) does not check that `_delta` < `10000`, with the value `10000` representing an option delta of `1`. The maximum value for an option’s delta is `1`, so this inequality must always hold.\n\n\nTo avoid the potential for erroneous values to result in unexpected behaviors or wasted gas, consider adding input validation for all user-controlled input, including owner-only functions.\n\n\n***Update:** Fixed in [commit `83584f43ac494092cc744ae6c9b21eb5b23b7453` in PR#92](https://github.com/ribbon-finance/ribbon-v2/pull/92/commits/83584f43ac494092cc744ae6c9b21eb5b23b7453).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/VaultLifecycle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../interfaces/IRibbon.sol\";\nimport {GnosisAuction} from \"./GnosisAuction.sol\";\nimport {\n    IOtokenFactory,\n    IOtoken,\n    IController,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\nimport {\n    SupportsNonCompliantERC20\n} from \"../libraries/SupportsNonCompliantERC20.sol\";\n\nlibrary VaultLifecycle {\n    using SafeMath for uint256;\n    using SupportsNonCompliantERC20 for IERC20;\n\n    struct CloseParams {\n        address OTOKEN_FACTORY;\n        address USDC;\n        address currentOption;\n        uint256 delay;\n        uint16 lastStrikeOverride;\n        uint256 overriddenStrikePrice;\n    }\n\n    function commitAndClose(\n        address strikeSelection,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount,\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry;\n\n        // uninitialized state\n        if (closeParams.currentOption == address(0)) {\n            expiry = getNextFriday(block.timestamp);\n        } else {\n            expiry = getNextFriday(\n                IOtoken(closeParams.currentOption).expiryTimestamp()\n            );\n        }\n\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\n\n        bool isPut = vaultParams.isPut;\n        address underlying = vaultParams.underlying;\n        address asset = vaultParams.asset;\n\n        (strikePrice, delta) = closeParams.lastStrikeOverride ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        otokenAddress = getOrDeployOtoken(\n            closeParams,\n            underlying,\n            asset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        premium = GnosisAuction.getOTokenPremium(\n            otokenAddress,\n            optionsPremiumPricer,\n            premiumDiscount\n        );\n\n        require(premium > 0, \"!premium\");\n    }\n\n    function verifyOtoken(address otokenAddress, uint256 delay) private view {\n        require(otokenAddress != address(0), \"!otokenAddress\");\n\n        IOtoken otoken = IOtoken(otokenAddress);\n        uint256 readyAt = block.timestamp.add(delay);\n        require(otoken.expiryTimestamp() >= readyAt, \"Expiry before delay\");\n    }\n\n    function rollover(\n        uint256 currentSupply,\n        address asset,\n        uint8 decimals,\n        uint256 initialSharePrice,\n        uint256 pendingAmount,\n        uint128 queuedWithdrawShares\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares\n        )\n    {\n        uint256 currentBalance = IERC20(asset).balanceOf(address(this));\n        uint256 roundStartBalance = currentBalance.sub(pendingAmount);\n\n        uint256 singleShare = 10**uint256(decimals);\n\n        newPricePerShare = getPPS(\n            currentSupply,\n            roundStartBalance,\n            singleShare,\n            initialSharePrice\n        );\n\n        // After closing the short, if the options expire in-the-money\n        // vault pricePerShare would go down because vault's asset balance decreased.\n        // This ensures that the newly-minted shares do not take on the loss.\n        uint256 _mintShares =\n            pendingAmount.mul(singleShare).div(newPricePerShare);\n\n        uint256 newSupply = currentSupply.add(_mintShares);\n\n        uint256 queuedWithdrawAmount =\n            newSupply > 0\n                ? uint256(queuedWithdrawShares).mul(currentBalance).div(\n                    newSupply\n                )\n                : 0;\n\n        return (\n            currentBalance.sub(queuedWithdrawAmount),\n            newPricePerShare,\n            _mintShares\n        );\n    }\n\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Otoken.sol#L70\n    uint256 private constant OTOKEN_DECIMALS = 10**8;\n\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID =\n            (controller.getAccountVaultCounter(address(this))).add(1);\n\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals =\n            uint256(IERC20Detailed(collateralAsset).decimals());\n        uint256 mintAmount;\n\n        if (oToken.isPut()) {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount = depositAmount\n                .mul(OTOKEN_DECIMALS)\n                .mul(DSWAD) // we use 10**18 to give extra precision\n                .div(\n                oToken.strikePrice().mul(10**(18 - (8 - collateralDecimals)))\n            );\n        } else {\n            mintAmount = depositAmount;\n            uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\n\n            if (mintAmount > scaleBy && collateralDecimals > 8) {\n                mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\n            }\n        }\n\n        // double approve to fix non-compliant ERC20s\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApprove(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](3);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver -  we need this contract to receive so we can swap at the end\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // deposited asset\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `closeShort` deletes vaults,\n     * this assumption should hold.\n     */\n    function settleShort(address gammaController) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.SettleVault,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(0), // not used\n            vaultID, // vaultId\n            0, // not used\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\n     * It calls the `Redeem` action to claim the payout.\n     */\n    function settleLong(\n        address gammaController,\n        address oldOption,\n        address asset\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\n\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\n            return 0;\n        }\n\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        // If it is after expiry, we need to redeem the profits\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.Redeem,\n            address(0), // not used\n            address(this), // address to send profits to\n            oldOption, // address of otoken\n            0, // not used\n            oldOptionBalance, // otoken balance\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        return endAssetBalance.sub(startAssetBalance);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time.\n     */\n    function burnOtokens(address gammaController, uint256 amount)\n        external\n        returns (uint256)\n    {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // Burning all otokens that are left from the gnosis auction,\n        // then withdrawing the corresponding collateral amount from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](2);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.BurnShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(vault.shortOtokens[0]), // otoken address\n            vaultID, // vaultId\n            amount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.WithdrawCollateral,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(collateralToken), // withdrawn asset\n            vaultID, // vaultId\n            vault.collateralAmounts[0].mul(amount).div(vault.shortAmounts[0]), // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    function getOrDeployOtoken(\n        CloseParams calldata closeParams,\n        address underlying,\n        address collateralAsset,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    ) internal returns (address) {\n        IOtokenFactory factory = IOtokenFactory(closeParams.OTOKEN_FACTORY);\n\n        address otokenFromFactory =\n            factory.getOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        if (otokenFromFactory != address(0)) {\n            return otokenFromFactory;\n        }\n\n        address otoken =\n            factory.createOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        verifyOtoken(otoken, closeParams.delay);\n\n        return otoken;\n    }\n\n    function startAuction(GnosisAuction.AuctionDetails calldata auctionDetails)\n        external\n        returns (uint256)\n    {\n        return GnosisAuction.startAuction(auctionDetails);\n    }\n\n    function placeBid(GnosisAuction.BidDetails calldata bidDetails)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint64\n        )\n    {\n        return GnosisAuction.placeBid(bidDetails);\n    }\n\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) external {\n        GnosisAuction.claimAuctionOtokens(\n            auctionSellOrder,\n            gnosisEasyAuction,\n            counterpartyThetaVault\n        );\n    }\n\n    function verifyConstructorParams(\n        address owner,\n        address feeRecipient,\n        uint256 performanceFee,\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) external pure {\n        require(owner != address(0), \"!owner\");\n        require(feeRecipient != address(0), \"!feeRecipient\");\n        require(performanceFee > 0, \"!performanceFee\");\n        require(performanceFee < 10**8, \"performanceFee >= 100%\");\n        require(bytes(tokenName).length > 0, \"!tokenName\");\n        require(bytes(tokenSymbol).length > 0, \"!tokenSymbol\");\n\n        require(_vaultParams.asset != address(0), \"!asset\");\n        require(_vaultParams.underlying != address(0), \"!underlying\");\n        require(_vaultParams.minimumSupply > 0, \"!minimumSupply\");\n        require(_vaultParams.cap > 0, \"!cap\");\n        require(_vaultParams.initialSharePrice > 0, \"!initialSharePrice\");\n    }\n\n    /**\n     * @notice Gets the next options expiry timestamp\n     * @param currentExpiry is the expiry timestamp of the current option\n     * Reference: https://codereview.stackexchange.com/a/33532\n     * Examples:\n     * getNextFriday(week 1 thursday) -> week 1 friday\n     * getNextFriday(week 1 friday) -> week 2 friday\n     * getNextFriday(week 1 saturday) -> week 2 friday\n     */\n    function getNextFriday(uint256 currentExpiry)\n        internal\n        pure\n        returns (uint256)\n    {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((currentExpiry / 1 days) + 4) % 7;\n        uint256 nextFriday = currentExpiry + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the passed currentExpiry is day=Friday hour>8am, we simply increment it by a week to next Friday\n        if (currentExpiry >= friday8am) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n\n    function getPPS(\n        uint256 currentSupply,\n        uint256 roundStartBalance,\n        uint256 singleShare,\n        uint256 initialSharePrice\n    ) internal pure returns (uint256 newPricePerShare) {\n        newPricePerShare = currentSupply > 0\n            ? singleShare.mul(roundStartBalance).div(currentSupply)\n            : initialSharePrice;\n    }\n\n    /***\n     * DSMath Copy paste\n     */\n\n    uint256 constant DSWAD = 10**18;\n\n    function dsadd(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function dsmul(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function dswdiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        z = dsadd(dsmul(x, DSWAD), y / 2) / y;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/VaultLifecycle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../interfaces/IRibbon.sol\";\nimport {GnosisAuction} from \"./GnosisAuction.sol\";\nimport {\n    IOtokenFactory,\n    IOtoken,\n    IController,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\nimport {\n    SupportsNonCompliantERC20\n} from \"../libraries/SupportsNonCompliantERC20.sol\";\n\nlibrary VaultLifecycle {\n    using SafeMath for uint256;\n    using SupportsNonCompliantERC20 for IERC20;\n\n    struct CloseParams {\n        address OTOKEN_FACTORY;\n        address USDC;\n        address currentOption;\n        uint256 delay;\n        uint16 lastStrikeOverride;\n        uint256 overriddenStrikePrice;\n    }\n\n    function commitAndClose(\n        address strikeSelection,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount,\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry;\n\n        // uninitialized state\n        if (closeParams.currentOption == address(0)) {\n            expiry = getNextFriday(block.timestamp);\n        } else {\n            expiry = getNextFriday(\n                IOtoken(closeParams.currentOption).expiryTimestamp()\n            );\n        }\n\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\n\n        bool isPut = vaultParams.isPut;\n        address underlying = vaultParams.underlying;\n        address asset = vaultParams.asset;\n\n        (strikePrice, delta) = closeParams.lastStrikeOverride ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        otokenAddress = getOrDeployOtoken(\n            closeParams,\n            underlying,\n            asset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        premium = GnosisAuction.getOTokenPremium(\n            otokenAddress,\n            optionsPremiumPricer,\n            premiumDiscount\n        );\n\n        require(premium > 0, \"!premium\");\n    }\n\n    function verifyOtoken(address otokenAddress, uint256 delay) private view {\n        require(otokenAddress != address(0), \"!otokenAddress\");\n\n        IOtoken otoken = IOtoken(otokenAddress);\n        uint256 readyAt = block.timestamp.add(delay);\n        require(otoken.expiryTimestamp() >= readyAt, \"Expiry before delay\");\n    }\n\n    function rollover(\n        uint256 currentSupply,\n        address asset,\n        uint8 decimals,\n        uint256 initialSharePrice,\n        uint256 pendingAmount,\n        uint128 queuedWithdrawShares\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares\n        )\n    {\n        uint256 currentBalance = IERC20(asset).balanceOf(address(this));\n        uint256 roundStartBalance = currentBalance.sub(pendingAmount);\n\n        uint256 singleShare = 10**uint256(decimals);\n\n        newPricePerShare = getPPS(\n            currentSupply,\n            roundStartBalance,\n            singleShare,\n            initialSharePrice\n        );\n\n        // After closing the short, if the options expire in-the-money\n        // vault pricePerShare would go down because vault's asset balance decreased.\n        // This ensures that the newly-minted shares do not take on the loss.\n        uint256 _mintShares =\n            pendingAmount.mul(singleShare).div(newPricePerShare);\n\n        uint256 newSupply = currentSupply.add(_mintShares);\n\n        uint256 queuedWithdrawAmount =\n            newSupply > 0\n                ? uint256(queuedWithdrawShares).mul(currentBalance).div(\n                    newSupply\n                )\n                : 0;\n\n        return (\n            currentBalance.sub(queuedWithdrawAmount),\n            newPricePerShare,\n            _mintShares\n        );\n    }\n\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Otoken.sol#L70\n    uint256 private constant OTOKEN_DECIMALS = 10**8;\n\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID =\n            (controller.getAccountVaultCounter(address(this))).add(1);\n\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals =\n            uint256(IERC20Detailed(collateralAsset).decimals());\n        uint256 mintAmount;\n\n        if (oToken.isPut()) {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount = depositAmount\n                .mul(OTOKEN_DECIMALS)\n                .mul(DSWAD) // we use 10**18 to give extra precision\n                .div(\n                oToken.strikePrice().mul(10**(18 - (8 - collateralDecimals)))\n            );\n        } else {\n            mintAmount = depositAmount;\n            uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\n\n            if (mintAmount > scaleBy && collateralDecimals > 8) {\n                mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\n            }\n        }\n\n        // double approve to fix non-compliant ERC20s\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApprove(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](3);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver -  we need this contract to receive so we can swap at the end\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // deposited asset\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `closeShort` deletes vaults,\n     * this assumption should hold.\n     */\n    function settleShort(address gammaController) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.SettleVault,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(0), // not used\n            vaultID, // vaultId\n            0, // not used\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\n     * It calls the `Redeem` action to claim the payout.\n     */\n    function settleLong(\n        address gammaController,\n        address oldOption,\n        address asset\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\n\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\n            return 0;\n        }\n\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        // If it is after expiry, we need to redeem the profits\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.Redeem,\n            address(0), // not used\n            address(this), // address to send profits to\n            oldOption, // address of otoken\n            0, // not used\n            oldOptionBalance, // otoken balance\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        return endAssetBalance.sub(startAssetBalance);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time.\n     */\n    function burnOtokens(address gammaController, uint256 amount)\n        external\n        returns (uint256)\n    {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // Burning all otokens that are left from the gnosis auction,\n        // then withdrawing the corresponding collateral amount from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](2);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.BurnShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(vault.shortOtokens[0]), // otoken address\n            vaultID, // vaultId\n            amount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.WithdrawCollateral,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(collateralToken), // withdrawn asset\n            vaultID, // vaultId\n            vault.collateralAmounts[0].mul(amount).div(vault.shortAmounts[0]), // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    function getOrDeployOtoken(\n        CloseParams calldata closeParams,\n        address underlying,\n        address collateralAsset,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    ) internal returns (address) {\n        IOtokenFactory factory = IOtokenFactory(closeParams.OTOKEN_FACTORY);\n\n        address otokenFromFactory =\n            factory.getOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        if (otokenFromFactory != address(0)) {\n            return otokenFromFactory;\n        }\n\n        address otoken =\n            factory.createOtoken(\n                underlying,\n                closeParams.USDC,"
    }
  ]
}