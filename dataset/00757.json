{
  "Title": "Whitelist Can Be Bypassed for New Collateral Type",
  "Content": "The [`Whitelist` contract](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Whitelist.sol#L8) validates borrowers against a whitelist for each collateral type using the [`isWhitelistedBorrower` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Whitelist.sol#L51-L59). This function never validates that the input `ilkIndex` is within the expected range of indices and will default to [returning `true`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/Whitelist.sol#L62) for an invalid index. If a new collateral type were added to the `IonPool` contract before updating the whitelist to support it, this would allow anyone to borrow against the new collateral type, bypassing the whitelist.\n\n\nConsider validating that the input `ilkIndex` to the `isWhitelistedBorrower` function is within the expected range for the deployed instance of the `Whitelist` contract.\n\n\n***Update:** Acknowledged, not resolved. Ion Protocol team stated:*\n\n\n\n> *Not fixed as the code works as intended. A new collateral type by default should not have a whitelist. A whitelist should only apply to a new collateral type if explicitly set by the protocol. The fix would alter this behavior to apply whitelist to all new collateral types which is not the intention.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/Whitelist.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\ncontract Whitelist is Ownable2Step {\n    mapping(address => bool) public protocolWhitelist; // peripheral addresses that can bypass the merkle proof check\n\n    mapping(uint8 => bytes32) public borrowersRoot; // root of the merkle tree of borrowers for each ilk\n\n    bytes32 public lendersRoot; // root of the merkle tree of lenders for each ilk\n\n    // --- Errors ---\n\n    error InvalidConstructorArguments();\n    error InvalidWhitelistMerkleProof();\n    error NotWhitelistedBorrower(uint8 ilkIndex, address addr);\n    error NotWhitelistedLender(address addr);\n\n    constructor(bytes32[] memory _borrowersRoots, bytes32 _lendersRoot) Ownable(msg.sender) {\n        for (uint8 i = 0; i < _borrowersRoots.length; i++) {\n            borrowersRoot[i] = _borrowersRoots[i];\n        }\n        lendersRoot = _lendersRoot;\n    }\n\n    function updateBorrowersRoot(uint8 ilkIndex, bytes32 _borrowersRoot) external onlyOwner {\n        borrowersRoot[ilkIndex] = _borrowersRoot;\n    }\n\n    function updateLendersRoot(bytes32 _lendersRoot) external onlyOwner {\n        lendersRoot = _lendersRoot;\n    }\n\n    function approveProtocolWhitelist(address addr) external onlyOwner {\n        protocolWhitelist[addr] = true;\n    }\n\n    function revokeProtocolWhitelist(address addr) external onlyOwner {\n        protocolWhitelist[addr] = false;\n    }\n\n    /**\n     * @notice Called by external modifiers to prove inclusion as a borrower. \n     * @dev If the root is just zero, then the whitelist is effectively turned off as every address\n     * will be allowed. \n     * @return true if the addr is part of the borrower whitelist or the protocol whitelist. False otherwise\n     */\n    function isWhitelistedBorrower(\n        uint8 ilkIndex,\n        address addr,\n        bytes32[] calldata proof\n    )\n        external\n        view\n        returns (bool)\n    {\n        if (protocolWhitelist[addr]) return true;\n        bytes32 root = borrowersRoot[ilkIndex];\n        if (root == 0) return true;\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(addr))));\n        if (MerkleProof.verify(proof, root, leaf)) {\n            return true;\n        } else {\n            revert NotWhitelistedBorrower(ilkIndex, addr);\n        }\n    }\n\n    /**\n     * @notice Called by external modifiers to prove inclusion as a lender. \n     * @dev If the root is just zero, then the whitelist is effectively turned off as every address\n     * will be allowed.\n     * @return true if the addr is part of the lender whitelist or the protocol whitelist. False otherwise\n     */\n    function isWhitelistedLender(address addr, bytes32[] calldata proof) external view returns (bool) {\n        if (protocolWhitelist[addr]) return true;\n        bytes32 root = lendersRoot;\n        if (root == bytes32(0)) return true;\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(addr))));\n        if (MerkleProof.verify(proof, root, leaf)) {\n            return true;\n        } else {\n            revert NotWhitelistedLender(addr);\n        }\n    }\n}"
    }
  ]
}