{
  "Title": "No check for final fee when adding currency to whitelist",
  "Content": "When a [currency is whitelisted and cached](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol#L308) in the [`OptimisticAsserter`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol) contract, it is assumed that the `Store` contract will have a [final fee set for the currency address](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol#L309). If the final fee has not been set, then assertions can be posted [without a bond](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol#L152).\n\n\nPrior to whitelisting a currency, consider adding a check that ensures the final fee from the `Store` contract is non-zero in the [`syncUmaParams`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol#L305) and [`_validateAndCacheCurrency`](https://github.com/UMAprotocol/protocol/blob/fed1c5677b5e764eb0b3e59817941c129e6c26f7/packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol#L460) functions.\n\n\n***Update:** Acknowledged, not resolved. The UMA team stated:*\n\n\n\n> *We’ve decided to not make this change. There should never be collateral currencies added that don’t have a final fee by DVM. If this was to occur, it would not pose too much of an issue within the system as 0 bonded assertions don’t really enable you to do much other than spam the DVM. if you were to spam the DVM with this technique we can delete the requests at the DVM level.*\n> \n> \n> *Added to this (and more importantly) there is a feature of having zero-sized bonds in one important situation: testnets. It is really convenient to not have to force users on testnets to approve and pay collateral currencies when making simple tests as this strictly increases the friction with using the system.*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/OptimisticAsserterCallbackRecipientInterface.sol\";\nimport \"../interfaces/OptimisticAsserterInterface.sol\";\nimport \"../interfaces/EscalationManagerInterface.sol\";\n\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\n\nimport \"../../common/implementation/AddressWhitelist.sol\";\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/MultiCaller.sol\";\n\n/**\n * @title Optimistic Asserter.\n * @notice The OA is used to assert truths about the world which are verified using an optimistic escalation game.\n * @dev Core idea: an asserter makes a statement about a truth, calling \"assertTruth\". If this statement is not\n * challenged, it is taken as the state of the world. If challenged, it is arbitrated using the UMA DVM, or if\n * configured, an escalation manager. Escalation managers enable integrations to define their own security properties and\n * tradeoffs, enabling the notion of \"sovereign security\".\n */\n\ncontract OptimisticAsserter is OptimisticAsserterInterface, Lockable, Ownable, MultiCaller {\n    using SafeERC20 for IERC20;\n\n    FinderInterface public immutable finder; // Finder used to discover other UMA ecosystem contracts.\n\n    // Cached UMA parameters.\n    address public cachedOracle;\n    mapping(address => WhitelistedCurrency) public cachedCurrencies;\n    mapping(bytes32 => bool) public cachedIdentifiers;\n\n    mapping(bytes32 => Assertion) public assertions; // All assertions made by the optimistic asserter.\n\n    uint256 public burnedBondPercentage; // Percentage of the bond that is paid to the UMA store if the assertion is disputed.\n\n    bytes32 public constant defaultIdentifier = \"ASSERT_TRUTH\";\n    IERC20 public defaultCurrency;\n    uint64 public defaultLiveness;\n\n    /**\n     * @notice Construct the OptimisticAsserter contract.\n     * @param _finder keeps track of all contracts within the UMA system based on their interfaceName.\n     * @param _defaultCurrency the default currency to bond asserters in assertTruthWithDefaults.\n     * @param _defaultLiveness the default liveness for assertions in assertTruthWithDefaults.\n     */\n    constructor(\n        FinderInterface _finder,\n        IERC20 _defaultCurrency,\n        uint64 _defaultLiveness\n    ) {\n        finder = _finder;\n        setAdminProperties(_defaultCurrency, _defaultLiveness, 0.5e18);\n    }\n\n    /**\n     * @notice Sets the default currency, liveness, and burned bond percentage.\n     * @dev Only callable by the contract owner (UMA governor).\n     * @param _defaultCurrency the default currency to bond asserters in assertTruthWithDefaults.\n     * @param _defaultLiveness the default liveness for assertions in assertTruthWithDefaults.\n     * @param _burnedBondPercentage the percentage of the bond that is sent as fee to UMA Store contract on disputes.\n     */\n    function setAdminProperties(\n        IERC20 _defaultCurrency,\n        uint64 _defaultLiveness,\n        uint256 _burnedBondPercentage\n    ) public onlyOwner {\n        require(_burnedBondPercentage <= 1e18, \"Burned bond percentage > 100\");\n        require(_burnedBondPercentage > 0, \"Burned bond percentage is 0\");\n        burnedBondPercentage = _burnedBondPercentage;\n        defaultCurrency = _defaultCurrency;\n        defaultLiveness = _defaultLiveness;\n        syncUmaParams(defaultIdentifier, address(_defaultCurrency));\n\n        emit AdminPropertiesSet(_defaultCurrency, _defaultLiveness, _burnedBondPercentage);\n    }\n\n    /**\n     * @notice Asserts a truth about the world, using the default currency and liveness. No callback recipient\n     * or escalation manager is enabled. The caller is the asserter and is expected to provide a bond of the\n     * currencies finalFee/burnedBondPercentage (with burnedBondPercentage set to 50%, the bond is 2x final fee).\n     * @dev The caller must approve this contract to spend at least the result of getMinimumBond(defaultCurrency).\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\n     * @return assertionId unique identifier for this assertion.\n     */\n\n    function assertTruthWithDefaults(bytes calldata claim, address asserter) public returns (bytes32 assertionId) {\n        // Note: re-entrancy guard is done in the inner call.\n        return\n            assertTruth(\n                claim,\n                asserter, // asserter\n                address(0), // callbackRecipient\n                address(0), // escalationManager\n                defaultLiveness,\n                defaultCurrency,\n                getMinimumBond(address(defaultCurrency)),\n                defaultIdentifier,\n                bytes32(0)\n            );\n    }\n\n    /**\n     * @notice Asserts a truth about the world, using a fully custom configuration.\n     * @dev The caller must approve this contract to spend at least bond amount of currency.\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\n     * @param asserter receives bonds back at settlement. This could be msg.sender or\n     * any other account that the caller wants to receive the bond at settlement time.\n     * @param callbackRecipient if configured, this address will receive a function call assertionResolvedCallback and\n     * assertionDisputedCallback at resolution or dispute respectively. Enables dynamic responses to these events. The\n     * recipient _must_ implement these callbacks and not revert or the assertion resolution will be blocked.\n     * @param escalationManager if configured, this address will control escalation properties of the assertion. This\n     * means a) choosing to arbitrate via the UMA DVM, b) choosing to discard assertions on dispute, or choosing to\n     * validate disputes. Combining these, the asserter can define their own security properties the assertion.\n     * escalationManager also _must_ implement the same callbacks as callbackRecipient.\n     * @param liveness time to wait before the assertion can be resolved. Assertion can be disputed in this time.\n     * @param currency bond currency pulled from the caller and held in escrow until the assertion is resolved.\n     * @param bond amount of currency to pull from the caller and hold in escrow until the assertion is resolved. This\n     * must be >= getMinimumBond(address(currency)).\n     * @param identifier UMA DVM identifier to use for price requests in the event of a dispute. Must be a pre-approved.\n     * @param domainId optional domain that can be used to relate this assertion to others in the escalationManager and\n     * can be used by the configured escalationManager to define custom behavior for groups of assertions. This is\n     * typically used for \"escalation games\" by changing bonds or other assertion properties based on the other\n     * assertions that have come before. If not needed this value should be bytes32 to save gas.\n     */\n    function assertTruth(\n        bytes memory claim,\n        address asserter,\n        address callbackRecipient,\n        address escalationManager,\n        uint64 liveness,\n        IERC20 currency,\n        uint256 bond,\n        bytes32 identifier,\n        bytes32 domainId\n    ) public nonReentrant returns (bytes32 assertionId) {\n        uint64 time = uint64(getCurrentTime());\n        assertionId = _getId(claim, bond, time, liveness, currency, callbackRecipient, escalationManager, identifier);\n\n        require(asserter != address(0), \"Asserter cant be 0\");\n        require(assertions[assertionId].asserter == address(0), \"Assertion already exists\");\n        require(_validateAndCacheIdentifier(identifier), \"Unsupported identifier\");\n        require(_validateAndCacheCurrency(address(currency)), \"Unsupported currency\");\n        require(bond >= getMinimumBond(address(currency)), \"Bond amount too low\");\n\n        assertions[assertionId] = Assertion({\n            escalationManagerSettings: EscalationManagerSettings({\n                arbitrateViaEscalationManager: false, // Default behavior: use the DVM as an oracle.\n                discardOracle: false, // Default behavior: respect the Oracle result.\n                validateDisputers: false, // Default behavior: disputer will not be validated.\n                escalationManager: escalationManager,\n                assertingCaller: msg.sender\n            }),\n            asserter: asserter,\n            disputer: address(0),\n            callbackRecipient: callbackRecipient,\n            currency: currency,\n            domainId: domainId,\n            identifier: identifier,\n            bond: bond,\n            settled: false,\n            settlementResolution: false,\n            assertionTime: time,\n            expirationTime: time + liveness\n        });\n\n        {\n            EscalationManagerInterface.AssertionPolicy memory assertionPolicy = _getAssertionPolicy(assertionId);\n            require(!assertionPolicy.blockAssertion, \"Assertion not allowed\"); // Check if the assertion is permitted.\n            EscalationManagerSettings storage emSettings = assertions[assertionId].escalationManagerSettings;\n            (emSettings.arbitrateViaEscalationManager, emSettings.discardOracle, emSettings.validateDisputers) = (\n                // Choose which oracle to arbitrate disputes via. If Set to true then the escalation manager will\n                // arbitrate disputes. Else, the DVM arbitrates disputes. This lets integrations \"unplug\" the DVM.\n                assertionPolicy.arbitrateViaEscalationManager,\n                // Choose whether to discard the Oracle result. If true then \"throw away\" the assertion. To get an\n                // assertion to be true it must be re-asserted and not disputed.\n                assertionPolicy.discardOracle,\n                // Configures if the escalation manager should validate the disputer on assertions. This enables you\n                // to construct setups such as whitelisted disputers.\n                assertionPolicy.validateDisputers\n            );\n        }\n\n        currency.safeTransferFrom(msg.sender, address(this), bond); // Pull the bond from the caller.\n\n        emit AssertionMade(\n            assertionId,\n            domainId,\n            claim,\n            asserter,\n            callbackRecipient,\n            escalationManager,\n            msg.sender,\n            time + liveness,\n            currency,\n            bond\n        );\n\n        return assertionId;\n    }\n\n    /**\n     * @notice Disputes an assertion. Depending on how the assertion was configured, this may either escalate to the UMA\n     * DVM or the configured escalation manager for arbitration.\n     * @dev The caller must approve this contract to spend at least bond amount of currency for the associated assertion.\n     * @param assertionId unique identifier for the assertion to dispute.\n     * @param disputer receives bonds back at settlement.\n     */\n    function disputeAssertion(bytes32 assertionId, address disputer) public nonReentrant {\n        require(disputer != address(0), \"Disputer cant be 0\");\n        Assertion storage assertion = assertions[assertionId];\n        require(assertion.asserter != address(0), \"Assertion does not exist\");\n        require(assertion.disputer == address(0), \"Assertion already disputed\");\n        require(assertion.expirationTime > getCurrentTime(), \"Assertion is expired\");\n        require(_isDisputeAllowed(assertionId), \"Dispute not allowed\");\n\n        assertion.disputer = disputer;\n\n        assertion.currency.safeTransferFrom(msg.sender, address(this), assertion.bond);\n\n        _oracleRequestPrice(assertionId, assertion.identifier, assertion.assertionTime);\n\n        _callbackOnAssertionDispute(assertionId);\n\n        // Send resolve callback if dispute resolution is discarded\n        if (assertion.escalationManagerSettings.discardOracle) _callbackOnAssertionResolve(assertionId, false);\n\n        emit AssertionDisputed(assertionId, disputer);\n    }\n\n    /**\n     * @notice Resolves an assertion. If the assertion has not been disputed, the assertion is resolved as true and the\n     * asserter receives the bond. If the assertion has been disputed, the assertion is resolved depending on the oracle\n     * result. Based on the result, the asserter or disputer receives the bond. If the assertion was disputed then an\n     * amount of the bond is sent to the UMA Store as an oracle fee based on the burnedBondPercentage. The remainder of\n     * the bond is returned to the asserter or disputer.\n     * @param assertionId unique identifier for the assertion to resolve.\n     */\n    function settleAssertion(bytes32 assertionId) public nonReentrant {\n        Assertion storage assertion = assertions[assertionId];\n        require(assertion.asserter != address(0), \"Assertion does not exist\"); // Revert if assertion does not exist.\n        require(!assertion.settled, \"Assertion already settled\"); // Revert if assertion already settled.\n        assertion.settled = true;\n        if (assertion.disputer == address(0)) {\n            // No dispute, settle with the asserter\n            require(assertion.expirationTime <= getCurrentTime(), \"Assertion not expired\"); // Revert if not expired.\n            assertion.settlementResolution = true;\n            assertion.currency.safeTransfer(assertion.asserter, assertion.bond);\n            _callbackOnAssertionResolve(assertionId, true);\n\n            emit AssertionSettled(assertionId, assertion.asserter, false, true, msg.sender);\n        } else {\n            // Dispute, settle with the disputer. Reverts if price not resolved.\n            int256 resolvedPrice = _oracleGetPrice(assertionId, assertion.identifier, assertion.assertionTime);\n\n            // If set to discard settlement resolution then false. Else, use oracle value to find resolution.\n            if (assertion.escalationManagerSettings.discardOracle) assertion.settlementResolution = false;\n            else assertion.settlementResolution = resolvedPrice == 1e18;\n\n            address bondRecipient = resolvedPrice == 1e18 ? assertion.asserter : assertion.disputer;\n\n            // If set to use UMA DVM as oracle then oracleFee must be sent to UMA Store contract. Else, if not using UMA\n            // DVM then the bond is returned to the correct party (asserter or disputer).\n            uint256 oracleFee = (burnedBondPercentage * assertion.bond) / 1e18;\n            if (assertion.escalationManagerSettings.arbitrateViaEscalationManager) oracleFee = 0;\n            uint256 bondRecipientAmount = assertion.bond * 2 - oracleFee;\n\n            // Send tokens. If the DVM is used as an oracle then send the oracleFee to the Store.\n            if (oracleFee > 0) assertion.currency.safeTransfer(address(_getStore()), oracleFee);\n            assertion.currency.safeTransfer(bondRecipient, bondRecipientAmount);\n\n            if (!assertion.escalationManagerSettings.discardOracle)\n                _callbackOnAssertionResolve(assertionId, assertion.settlementResolution);\n\n            emit AssertionSettled(assertionId, bondRecipient, true, assertion.settlementResolution, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Settles an assertion and returns the resolution.\n     * @param assertionId unique identifier for the assertion to resolve and return the resolution for.\n     * @return resolution of the assertion.\n     */\n    function settleAndGetAssertionResult(bytes32 assertionId) public returns (bool resolution) {\n        // Note: re-entrancy guard is done in the inner settleAssertion call.\n        if (!assertions[assertionId].settled) settleAssertion(assertionId);\n        return getAssertionResult(assertionId);\n    }\n\n    /**\n     * @notice Fetches information about a specific identifier & currency from the UMA contracts and stores a local copy\n     * of the information within this contract. This is used to save gas when making assertions as we can avoid an\n     * external call to the UMA contracts to fetch this.\n     * @param identifier identifier to fetch information for and store locally.\n     * @param currency currency to fetch information for and store locally.\n     */\n    function syncUmaParams(bytes32 identifier, address currency) public {\n        cachedOracle = finder.getImplementationAddress(OracleInterfaces.Oracle);\n        cachedIdentifiers[identifier] = _getIdentifierWhitelist().isIdentifierSupported(identifier);\n        cachedCurrencies[currency].isWhitelisted = _getCollateralWhitelist().isOnWhitelist(currency);\n        cachedCurrencies[currency].finalFee = _getStore().computeFinalFee(currency).rawValue;\n    }\n\n    /**\n     * @notice Fetches information about a specific assertion and returns it.\n     * @param assertionId unique identifier for the assertion to fetch information for.\n     * @return assertion information about the assertion.\n     */\n    function getAssertion(bytes32 assertionId) external view returns (Assertion memory assertion) {\n        return assertions[assertionId];\n    }\n\n    /**\n     * @notice Fetches the resolution of a specific assertion and returns it. If the assertion has not been settled then\n     * this will revert. If the assertion was disputed and configured to discard the oracle resolution return false.\n     * @param assertionId unique identifier for the assertion to fetch the resolution for.\n     * @return resolution of the assertion.\n     */\n    function getAssertionResult(bytes32 assertionId) public view returns (bool resolution) {\n        Assertion memory assertion = assertions[assertionId];\n        // Return early if not using answer from resolved dispute.\n        if (assertion.disputer != address(0) && assertion.escalationManagerSettings.discardOracle) return false;\n        require(assertion.settled, \"Assertion not settled\"); // Revert if assertion not settled.\n        return assertion.settlementResolution;\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Appends information onto an assertionId to construct ancillary data used for dispute resolution.\n     * @param assertionId unique identifier for the assertion to construct ancillary data for.\n     * @return ancillaryData stamped assertion information.\n     */\n    function stampAssertion(bytes32 assertionId) public view returns (bytes memory) {\n        return _stampAssertion(assertionId);\n    }\n\n    /**\n     * @notice Returns the minimum bond amount required to make an assertion. This is calculated as the final fee of the\n     * currency divided by the burnedBondPercentage. If burn percentage is 50% then the min bond is 2x the final fee.\n     * @param currency currency to calculate the minimum bond for.\n     * @return minimum bond amount.\n     */\n    function getMinimumBond(address currency) public view returns (uint256) {\n        uint256 finalFee = cachedCurrencies[currency].finalFee;\n        return (finalFee * 1e18) / burnedBondPercentage;\n    }\n\n    function _getId(\n        bytes memory claim,\n        uint256 bond,\n        uint256 time,\n        uint64 liveness,\n        IERC20 currency,\n        address callbackRecipient,\n        address escalationManager,\n        bytes32 identifier\n    ) internal view returns (bytes32) {\n        // Returns the unique ID for this assertion. This ID is used to identify the assertion in the Oracle.\n        return\n            keccak256(\n                abi.encode(\n                    claim,\n                    bond,\n                    time,\n                    liveness,\n                    currency,\n                    callbackRecipient,\n                    escalationManager,\n                    identifier,\n                    msg.sender\n                )\n            );\n    }\n\n    function _stampAssertion(bytes32 assertionId) internal view returns (bytes memory) {\n        // Returns ancillary data for the Oracle request containing assertionId and asserter.\n        return\n            AncillaryData.appendKeyValueAddress(\n                AncillaryData.appendKeyValueBytes32(\"\", \"assertionId\", assertionId),\n                \"oaAsserter\",\n                assertions[assertionId].asserter\n            );\n    }\n\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\n    }\n\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n\n    function _getStore() internal view returns (StoreInterface) {\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\n    }\n\n    function _getOracle(bytes32 assertionId) internal view returns (OracleAncillaryInterface) {\n        if (assertions[assertionId].escalationManagerSettings.arbitrateViaEscalationManager)\n            return OracleAncillaryInterface(address(_getEscalationManager(assertionId)));\n        return OracleAncillaryInterface(cachedOracle);\n    }\n\n    function _oracleRequestPrice(\n        bytes32 assertionId,\n        bytes32 identifier,\n        uint256 time\n    ) internal {\n        _getOracle(assertionId).requestPrice(identifier, time, _stampAssertion(assertionId));\n    }\n\n    function _oracleGetPrice(\n        bytes32 assertionId,\n        bytes32 identifier,\n        uint256 time\n    ) internal view returns (int256) {\n        return _getOracle(assertionId).getPrice(identifier, time, _stampAssertion(assertionId));\n    }\n\n    function _getEscalationManager(bytes32 assertionId) internal view returns (EscalationManagerInterface) {\n        return EscalationManagerInterface(assertions[assertionId].escalationManagerSettings.escalationManager);\n    }\n\n    function _getAssertionPolicy(bytes32 assertionId)\n        internal\n        view\n        returns (EscalationManagerInterface.AssertionPolicy memory)\n    {\n        address em = assertions[assertionId].escalationManagerSettings.escalationManager;\n        if (em == address(0)) return EscalationManagerInterface.AssertionPolicy(false, false, false, false);\n        return EscalationManagerInterface(em).getAssertionPolicy(assertionId);\n    }\n\n    function _isDisputeAllowed(bytes32 assertionId) internal view returns (bool) {\n        address em = assertions[assertionId].escalationManagerSettings.escalationManager;\n        if (!assertions[assertionId].escalationManagerSettings.validateDisputers) return true;\n        return EscalationManagerInterface(em).isDisputeAllowed(assertionId, msg.sender);\n    }\n\n    function _validateAndCacheIdentifier(bytes32 identifier) internal returns (bool) {\n        if (cachedIdentifiers[identifier]) return true;\n        cachedIdentifiers[identifier] = _getIdentifierWhitelist().isIdentifierSupported(identifier);\n        return cachedIdentifiers[identifier];\n    }\n\n    function _validateAndCacheCurrency(address currency) internal returns (bool) {\n        if (cachedCurrencies[currency].isWhitelisted) return true;\n        cachedCurrencies[currency].isWhitelisted = _getCollateralWhitelist().isOnWhitelist(currency);\n        cachedCurrencies[currency].finalFee = _getStore().computeFinalFee(currency).rawValue;\n        return cachedCurrencies[currency].isWhitelisted;\n    }\n\n    function _callbackOnAssertionResolve(bytes32 assertionId, bool assertedTruthfully) internal {\n        if (assertions[assertionId].callbackRecipient != address(0))\n            OptimisticAsserterCallbackRecipientInterface(assertions[assertionId].callbackRecipient)\n                .assertionResolvedCallback(assertionId, assertedTruthfully);\n        if (assertions[assertionId].escalationManagerSettings.escalationManager != address(0))\n            EscalationManagerInterface(assertions[assertionId].escalationManagerSettings.escalationManager)\n                .assertionResolvedCallback(assertionId, assertedTruthfully);\n    }\n\n    function _callbackOnAssertionDispute(bytes32 assertionId) internal {\n        if (assertions[assertionId].callbackRecipient != address(0))\n            OptimisticAsserterCallbackRecipientInterface(assertions[assertionId].callbackRecipient)\n                .assertionDisputedCallback(assertionId);\n        if (assertions[assertionId].escalationManagerSettings.escalationManager != address(0))\n            EscalationManagerInterface(assertions[assertionId].escalationManagerSettings.escalationManager)\n                .assertionDisputedCallback(assertionId);\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/optimistic-asserter/implementation/OptimisticAsserter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/OptimisticAsserterCallbackRecipientInterface.sol\";\nimport \"../interfaces/OptimisticAsserterInterface.sol\";\nimport \"../interfaces/EscalationManagerInterface.sol\";\n\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\n\nimport \"../../common/implementation/AddressWhitelist.sol\";\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/MultiCaller.sol\";\n\n/**\n * @title Optimistic Asserter.\n * @notice The OA is used to assert truths about the world which are verified using an optimistic escalation game.\n * @dev Core idea: an asserter makes a statement about a truth, calling \"assertTruth\". If this statement is not\n * challenged, it is taken as the state of the world. If challenged, it is arbitrated using the UMA DVM, or if\n * configured, an escalation manager. Escalation managers enable integrations to define their own security properties and\n * tradeoffs, enabling the notion of \"sovereign security\".\n */\n\ncontract OptimisticAsserter is OptimisticAsserterInterface, Lockable, Ownable, MultiCaller {\n    using SafeERC20 for IERC20;\n\n    FinderInterface public immutable finder; // Finder used to discover other UMA ecosystem contracts.\n\n    // Cached UMA parameters.\n    address public cachedOracle;\n    mapping(address => WhitelistedCurrency) public cachedCurrencies;\n    mapping(bytes32 => bool) public cachedIdentifiers;\n\n    mapping(bytes32 => Assertion) public assertions; // All assertions made by the optimistic asserter.\n\n    uint256 public burnedBondPercentage; // Percentage of the bond that is paid to the UMA store if the assertion is disputed.\n\n    bytes32 public constant defaultIdentifier = \"ASSERT_TRUTH\";\n    IERC20 public defaultCurrency;\n    uint64 public defaultLiveness;\n\n    /**\n     * @notice Construct the OptimisticAsserter contract.\n     * @param _finder keeps track of all contracts within the UMA system based on their interfaceName.\n     * @param _defaultCurrency the default currency to bond asserters in assertTruthWithDefaults.\n     * @param _defaultLiveness the default liveness for assertions in assertTruthWithDefaults.\n     */\n    constructor(\n        FinderInterface _finder,\n        IERC20 _defaultCurrency,\n        uint64 _defaultLiveness\n    ) {\n        finder = _finder;\n        setAdminProperties(_defaultCurrency, _defaultLiveness, 0.5e18);\n    }\n\n    /**\n     * @notice Sets the default currency, liveness, and burned bond percentage.\n     * @dev Only callable by the contract owner (UMA governor).\n     * @param _defaultCurrency the default currency to bond asserters in assertTruthWithDefaults.\n     * @param _defaultLiveness the default liveness for assertions in assertTruthWithDefaults.\n     * @param _burnedBondPercentage the percentage of the bond that is sent as fee to UMA Store contract on disputes.\n     */\n    function setAdminProperties(\n        IERC20 _defaultCurrency,\n        uint64 _defaultLiveness,\n        uint256 _burnedBondPercentage\n    ) public onlyOwner {\n        require(_burnedBondPercentage <= 1e18, \"Burned bond percentage > 100\");\n        require(_burnedBondPercentage > 0, \"Burned bond percentage is 0\");\n        burnedBondPercentage = _burnedBondPercentage;\n        defaultCurrency = _defaultCurrency;\n        defaultLiveness = _defaultLiveness;\n        syncUmaParams(defaultIdentifier, address(_defaultCurrency));\n\n        emit AdminPropertiesSet(_defaultCurrency, _defaultLiveness, _burnedBondPercentage);\n    }\n\n    /**\n     * @notice Asserts a truth about the world, using the default currency and liveness. No callback recipient\n     * or escalation manager is enabled. The caller is the asserter and is expected to provide a bond of the\n     * currencies finalFee/burnedBondPercentage (with burnedBondPercentage set to 50%, the bond is 2x final fee).\n     * @dev The caller must approve this contract to spend at least the result of getMinimumBond(defaultCurrency).\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\n     * @return assertionId unique identifier for this assertion.\n     */\n\n    function assertTruthWithDefaults(bytes calldata claim, address asserter) public returns (bytes32 assertionId) {\n        // Note: re-entrancy guard is done in the inner call.\n        return\n            assertTruth(\n                claim,\n                asserter, // asserter\n                address(0), // callbackRecipient\n                address(0), // escalationManager\n                defaultLiveness,\n                defaultCurrency,\n                getMinimumBond(address(defaultCurrency)),\n                defaultIdentifier,\n                bytes32(0)\n            );\n    }\n\n    /**\n     * @notice Asserts a truth about the world, using a fully custom configuration.\n     * @dev The caller must approve this contract to spend at least bond amount of currency.\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\n     * @param asserter receives bonds back at settlement. This could be msg.sender or\n     * any other account that the caller wants to receive the bond at settlement time.\n     * @param callbackRecipient if configured, this address will receive a function call assertionResolvedCallback and\n     * assertionDisputedCallback at resolution or dispute respectively. Enables dynamic responses to these events. The\n     * recipient _must_ implement these callbacks and not revert or the assertion resolution will be blocked.\n     * @param escalationManager if configured, this address will control escalation properties of the assertion. This\n     * means a) choosing to arbitrate via the UMA DVM, b) choosing to discard assertions on dispute, or choosing to\n     * validate disputes. Combining these, the asserter can define their own security properties the assertion.\n     * escalationManager also _must_ implement the same callbacks as callbackRecipient.\n     * @param liveness time to wait before the assertion can be resolved. Assertion can be disputed in this time.\n     * @param currency bond currency pulled from the caller and held in escrow until the assertion is resolved.\n     * @param bond amount of currency to pull from the caller and hold in escrow until the assertion is resolved. This\n     * must be >= getMinimumBond(address(currency)).\n     * @param identifier UMA DVM identifier to use for price requests in the event of a dispute. Must be a pre-approved.\n     * @param domainId optional domain that can be used to relate this assertion to others in the escalationManager and\n     * can be used by the configured escalationManager to define custom behavior for groups of assertions. This is\n     * typically used for \"escalation games\" by changing bonds or other assertion properties based on the other\n     * assertions that have come before. If not ne"
    }
  ]
}