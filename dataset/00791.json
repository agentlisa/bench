{
  "Title": "SINGLE STEP OWNERSHIP TRANSFER PROCESS",
  "Content": "# SINGLE STEP OWNERSHIP TRANSFER PROCESS\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/RESDLTokenBridge.sol#L6\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/ccip/RESDLTokenBridge.sol#L6</a>\n\n\n## Summary\nThe ownership of the contracts can be lost as the contracts  inherits from the Ownable contract and their ownership can be transferred\nin a single-step process.  If the nominated EOA account is not a valid account, it is entirely possible that the owner may accidentally transfer ownership to\nan uncontrolled account, losing the access to all functions with the `onlyOwner` modifier. The address the ownership is changed to should be verified to be active or willing to act as the owner\n\nContracts affected:\n\nSDLPoolCCIPController.sol\n\nRESDLTokenBridge.sol\n\nWrappedTokenBridge\n\nLinearBoostController\n\nRewardsInitiator \n\n## Tools Used\nManual Analysis\n## Recommendations\nConsider using the `Ownable2Step` library over the Ownable library or implementing similar two-step ownership transfer logic into the contract",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/ccip/RESDLTokenBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/ISDLPool.sol\";\nimport \"../interfaces/ISDLPoolCCIPController.sol\";\n\n/**\n * @title reSDL Token Bridge\n * @notice Handles CCIP transfers of reSDL NFTs\n */\ncontract RESDLTokenBridge is Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public linkToken;\n\n    IERC20 public sdlToken;\n    ISDLPool public sdlPool;\n    ISDLPoolCCIPController public sdlPoolCCIPController;\n\n    mapping(uint64 => bytes) public extraArgsByChain;\n\n    event TokenTransferred(\n        bytes32 indexed messageId,\n        uint64 indexed destinationChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenId,\n        address feeToken,\n        uint256 fees\n    );\n    event TokenReceived(\n        bytes32 indexed messageId,\n        uint64 indexed sourceChainSelector,\n        address indexed sender,\n        address receiver,\n        uint256 tokenId\n    );\n    event SetExtraArgs(uint64 indexed chainSelector, bytes extraArgs);\n\n    error InsufficientFee();\n    error TransferFailed();\n    error FeeExceedsLimit();\n    error SenderNotAuthorized();\n    error InvalidReceiver();\n    error InvalidMsgValue();\n\n    /**\n     * @notice Initializes the contract\n     * @param _linkToken address of the LINK token\n     * @param _sdlToken address of the SDL token\n     * @param _sdlPool address of the SDL Pool\n     * @param _sdlPoolCCIPController address of the SDL Pool CCIP controller\n     **/\n    constructor(\n        address _linkToken,\n        address _sdlToken,\n        address _sdlPool,\n        address _sdlPoolCCIPController\n    ) {\n        linkToken = IERC20(_linkToken);\n        sdlToken = IERC20(_sdlToken);\n        sdlPool = ISDLPool(_sdlPool);\n        sdlPoolCCIPController = ISDLPoolCCIPController(_sdlPoolCCIPController);\n    }\n\n    modifier onlySDLPoolCCIPController() {\n        if (msg.sender != address(sdlPoolCCIPController)) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice Transfers an reSDL token to a destination chain\n     * @param _destinationChainSelector id of destination chain\n     * @param _receiver address to receive reSDL on destination chain\n     * @param _tokenId id of reSDL token\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @param _maxLINKFee call will revert if LINK fee exceeds this value\n     **/\n    function transferRESDL(\n        uint64 _destinationChainSelector,\n        address _receiver,\n        uint256 _tokenId,\n        bool _payNative,\n        uint256 _maxLINKFee\n    ) external payable returns (bytes32 messageId) {\n        if (msg.sender != sdlPool.ownerOf(_tokenId)) revert SenderNotAuthorized();\n        if (_receiver == address(0)) revert InvalidReceiver();\n        if (_payNative == false && msg.value != 0) revert InvalidMsgValue();\n\n        (address destination, ISDLPool.RESDLToken memory reSDLToken) = sdlPoolCCIPController.handleOutgoingRESDL(\n            _destinationChainSelector,\n            msg.sender,\n            _tokenId\n        );\n        bytes memory extraArgs = extraArgsByChain[_destinationChainSelector];\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            _receiver,\n            _tokenId,\n            reSDLToken,\n            destination,\n            _payNative ? address(0) : address(linkToken),\n            extraArgs\n        );\n\n        uint256 fees = IRouterClient(sdlPoolCCIPController.getRouter()).getFee(_destinationChainSelector, evm2AnyMessage);\n\n        if (_payNative) {\n            if (fees > msg.value) revert InsufficientFee();\n            messageId = sdlPoolCCIPController.ccipSend{value: fees}(_destinationChainSelector, evm2AnyMessage);\n            if (fees < msg.value) {\n                (bool success, ) = msg.sender.call{value: msg.value - fees}(\"\");\n                if (!success) revert TransferFailed();\n            }\n        } else {\n            if (fees > _maxLINKFee) revert FeeExceedsLimit();\n            linkToken.safeTransferFrom(msg.sender, address(sdlPoolCCIPController), fees);\n            messageId = sdlPoolCCIPController.ccipSend(_destinationChainSelector, evm2AnyMessage);\n        }\n\n        emit TokenTransferred(\n            messageId,\n            _destinationChainSelector,\n            msg.sender,\n            _receiver,\n            _tokenId,\n            _payNative ? address(0) : address(linkToken),\n            fees\n        );\n    }\n\n    /**\n     * @notice Returns the current fee for an reSDL transfer\n     * @param _destinationChainSelector id of destination chain\n     * @param _payNative whether fee should be paid natively or with LINK\n     * @return fee current fee\n     **/\n    function getFee(uint64 _destinationChainSelector, bool _payNative) external view returns (uint256) {\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n            address(this),\n            0,\n            ISDLPool.RESDLToken(0, 0, 0, 0, 0),\n            address(this),\n            _payNative ? address(0) : address(linkToken),\n            extraArgsByChain[_destinationChainSelector]\n        );\n\n        return IRouterClient(sdlPoolCCIPController.getRouter()).getFee(_destinationChainSelector, evm2AnyMessage);\n    }\n\n    /**\n     * @notice Sets the extra args used for sending reSDL to a chain\n     * @param _chainSelector id of chain\n     * @param _extraArgs extra args as defined in CCIP API\n     **/\n    function setExtraArgs(uint64 _chainSelector, bytes calldata _extraArgs) external onlyOwner {\n        extraArgsByChain[_chainSelector] = _extraArgs;\n        emit SetExtraArgs(_chainSelector, _extraArgs);\n    }\n\n    /**\n     * @notice Processes a received message\n     * @dev handles incoming reSDL transfers\n     * @param _message CCIP message\n     **/\n    function ccipReceive(Client.Any2EVMMessage memory _message) external onlySDLPoolCCIPController {\n        address sender = abi.decode(_message.sender, (address));\n\n        (\n            address receiver,\n            uint256 tokenId,\n            uint256 amount,\n            uint256 boostAmount,\n            uint64 startTime,\n            uint64 duration,\n            uint64 expiry\n        ) = abi.decode(_message.data, (address, uint256, uint256, uint256, uint64, uint64, uint64));\n\n        sdlPoolCCIPController.handleIncomingRESDL(\n            _message.sourceChainSelector,\n            receiver,\n            tokenId,\n            ISDLPool.RESDLToken(amount, boostAmount, startTime, duration, expiry)\n        );\n\n        emit TokenReceived(_message.messageId, _message.sourceChainSelector, sender, receiver, tokenId);\n    }\n\n    /**\n     * @notice Builds a CCIP message\n     * @dev builds the message for outgoing reSDL transfers\n     * @param _receiver address to receive reSDL token on destination chain\n     * @param _tokenId id of reSDL token\n     * @param _reSDLToken reSDL token\n     * @param _destination address of destination contract\n     * @param _feeTokenAddress address of token that fees will be paid in\n     * @param _extraArgs encoded args as defined in CCIP API\n     **/\n    function _buildCCIPMessage(\n        address _receiver,\n        uint256 _tokenId,\n        ISDLPool.RESDLToken memory _reSDLToken,\n        address _destination,\n        address _feeTokenAddress,\n        bytes memory _extraArgs\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\n            token: address(sdlToken),\n            amount: _reSDLToken.amount\n        });\n        tokenAmounts[0] = tokenAmount;\n\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(_destination),\n            data: abi.encode(\n                _receiver,\n                _tokenId,\n                _reSDLToken.amount,\n                _reSDLToken.boostAmount,\n                _reSDLToken.startTime,\n                _reSDLToken.duration,\n                _reSDLToken.expiry\n            ),\n            tokenAmounts: tokenAmounts,\n            extraArgs: _extraArgs,\n            feeToken: _feeTokenAddress\n        });\n\n        return evm2AnyMessage;\n    }\n}"
    }
  ]
}