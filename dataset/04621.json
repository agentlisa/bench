{
  "Title": "Perform sanity checks on arguments",
  "Content": "The following preconditions and sanity checks are missing.\n\n\n1. `rateChange &gt; 0` and `preferentialRate &gt; 0` in [`constructor`](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/MANACrowdsale.sol#L29)[MANACrowdsale](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/MANACrowdsale.sol#L29).\n2. `rate &gt; 0` in [`setRate`](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/MANACrowdsale.sol#L100).\n3. `value &gt; 0` in [`burn`](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/BurnableToken.sol#L17).\n4. `investorÂ != 0` in [`addToWhitelist`](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/WhitelistedCrowdsale.sol#L17).\n\n\n**EDIT:** fixed in commits [`fd0c0a7574b44adafeffbe6033ef2bb6450921c2`](https://github.com/decentraland/mana/commit/fd0c0a7574b44adafeffbe6033ef2bb6450921c2), [`b78a711a0e4adf0bf68f972d4961cb90a1ec5ca0`](https://github.com/decentraland/mana/commit/b78a711a0e4adf0bf68f972d4961cb90a1ec5ca0), and [`e34c411700fc0869d308249ff9aba08fe8a12eca`](https://github.com/decentraland/mana/commit/e34c411700fc0869d308249ff9aba08fe8a12eca).\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MANACrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/crowdsale/CappedCrowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/Crowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/FinalizableCrowdsale.sol\";\nimport \"./ContinuousCrowdsale.sol\";\nimport \"./WhitelistedCrowdsale.sol\";\nimport \"./MANAToken.sol\";\n\ncontract MANACrowdsale is ContinuousCrowdsale, CappedCrowdsale, WhitelistedCrowdsale, FinalizableCrowdsale {\n\n    uint256 public constant INFLATION = 8; // percent\n\n    uint256 public constant TOTAL_SHARE = 100;\n    uint256 public constant CROWDSALE_SHARE = 40;\n    uint256 public constant FOUNDATION_SHARE = 60;\n\n    // price at which whitelisted buyers will be able to buy tokens\n    uint256 public preferentialRate;\n\n    // customize the rate for each whitelisted buyer\n    mapping (address => uint256) public buyerRate;\n\n    // change of price in every block during the initial coin offering\n    uint256 public rateChange;\n\n    event RateChange(uint256 amount);\n\n    function MANACrowdsale(\n        uint256 _startBlock, uint256 _endBlock,\n        uint256 _rate, uint256 _rateChange,\n        uint256 _preferentialRate,\n        address _wallet\n    )\n        CappedCrowdsale(150000 ether)\n        WhitelistedCrowdsale()\n        FinalizableCrowdsale()\n        Crowdsale(_startBlock, _endBlock, _rate, _wallet)\n    {\n        rateChange = _rateChange;\n        preferentialRate = _preferentialRate;\n    }\n\n    function createTokenContract() internal returns (MintableToken) {\n        return new MANAToken();\n    }\n\n    function setBuyerRate(address buyer, uint256 rate) onlyOwner {\n        require(buyer != 0);\n        require(rate != 0);\n\n        buyerRate[buyer] = rate;\n    }\n\n    function getRate() internal returns(uint256) {\n        // return the current price if we are in continuous sale\n        if (continuousSale) {\n            return rate;\n        }\n\n        // some early buyers are offered a discount on the crowdsale price\n        if (buyerRate[msg.sender] != 0) {\n            return buyerRate[msg.sender];\n        }\n\n        // whitelisted buyers can purchase at preferential price before crowdsale ends\n        if (isWhitelisted(msg.sender) && !hasEnded()) {\n            return preferentialRate;\n        }\n\n        // otherwise compute the price for the auction\n        return rate.sub(rateChange.mul(block.number - startBlock));\n    }\n\n    // low level token purchase function\n    function processPurchase(address beneficiary) internal returns(uint256) {\n        uint256 weiAmount = msg.value;\n        uint256 updatedWeiRaised = weiRaised.add(weiAmount);\n\n        uint256 rate = getRate();\n        // calculate token amount to be created\n        uint256 tokens = weiAmount.mul(rate);\n\n        // update state\n        weiRaised = updatedWeiRaised;\n\n        token.mint(beneficiary, tokens);\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n        forwardFunds();\n\n        return tokens;\n    }\n\n    function setWallet(address _wallet) onlyOwner {\n        require(_wallet != 0x0);\n        wallet = _wallet;\n    }\n\n    function setRate(uint256 _rate) onlyOwner {\n        require(isFinalized);\n        rate = _rate;\n        RateChange(_rate);\n    }\n\n    function startContinuousSale() onlyOwner {\n        require(isFinalized);\n        continuousSale = true;\n    }\n\n    function hasEnded() constant returns(bool) {\n        return isFinalized || super.hasEnded();\n    }\n\n    function finalize() onlyOwner {\n        require(!isFinalized);\n\n        finalization();\n        Finalized();\n\n        isFinalized = true;\n    }\n\n    function finalization() internal {\n        uint256 totalSupply = token.totalSupply();\n        uint256 finalSupply = TOTAL_SHARE.mul(totalSupply).div(CROWDSALE_SHARE);\n\n        // emit tokens for the foundation\n        token.mint(wallet, FOUNDATION_SHARE.mul(finalSupply).div(TOTAL_SHARE));\n\n        // initialize issuance \n        // TODO: possibility of overflow in these operations should be analized\n        uint256 annualIssuance = finalSupply.mul(INFLATION).div(100);\n        issuance = annualIssuance.mul(BUCKET_SIZE).div(1 years);\n\n        // NOTE: cannot call super here because it would finish minting and\n        // the continuous sale would not be able to proceed\n    }\n}"
    },
    {
      "filename": "contracts/MANACrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/crowdsale/CappedCrowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/Crowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/FinalizableCrowdsale.sol\";\nimport \"./ContinuousCrowdsale.sol\";\nimport \"./WhitelistedCrowdsale.sol\";\nimport \"./MANAToken.sol\";\n\ncontract MANACrowdsale is ContinuousCrowdsale, CappedCrowdsale, WhitelistedCrowdsale, FinalizableCrowdsale {\n\n    uint256 public constant INFLATION = 8; // percent\n\n    uint256 public constant TOTAL_SHARE = 100;\n    uint256 public constant CROWDSALE_SHARE = 40;\n    uint256 public constant FOUNDATION_SHARE = 60;\n\n    // price at which whitelisted buyers will be able to buy tokens\n    uint256 public preferentialRate;\n\n    // customize the rate for each whitelisted buyer\n    mapping (address => uint256) public buyerRate;\n\n    // change of price in every block during the initial coin offering\n    uint256 public rateChange;\n\n    event RateChange(uint256 amount);\n\n    function MANACrowdsale(\n        uint256 _startBlock, uint256 _endBlock,\n        uint256 _rate, uint256 _rateChange,\n        uint256 _preferentialRate,\n        address _wallet\n    )\n        CappedCrowdsale(150000 ether)\n        WhitelistedCrowdsale()\n        FinalizableCrowdsale()\n        Crowdsale(_startBlock, _endBlock, _rate, _wallet)\n    {\n        rateChange = _rateChange;\n        preferentialRate = _preferentialRate;\n    }\n\n    function createTokenContract() internal returns (MintableToken) {\n        return new MANAToken();\n    }\n\n    function setBuyerRate(address buyer, uint256 rate) onlyOwner {\n        require(buyer != 0);\n        require(rate != 0);\n\n        buyerRate[buyer] = rate;\n    }\n\n    function getRate() internal returns(uint256) {\n        // return the current price if we are in continuous sale\n        if (continuousSale) {\n            return rate;\n        }\n\n        // some early buyers are offered a discount on the crowdsale price\n        if (buyerRate[msg.sender] != 0) {\n            return buyerRate[msg.sender];\n        }\n\n        // whitelisted buyers can purchase at preferential price before crowdsale ends\n        if (isWhitelisted(msg.sender) && !hasEnded()) {\n            return preferentialRate;\n        }\n\n        // otherwise compute the price for the auction\n        return rate.sub(rateChange.mul(block.number - startBlock));\n    }\n\n    // low level token purchase function\n    function processPurchase(address beneficiary) internal returns(uint256) {\n        uint256 weiAmount = msg.value;\n        uint256 updatedWeiRaised = weiRaised.add(weiAmount);\n\n        uint256 rate = getRate();\n        // calculate token amount to be created\n        uint256 tokens = weiAmount.mul(rate);\n\n        // update state\n        weiRaised = updatedWeiRaised;\n\n        token.mint(beneficiary, tokens);\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n        forwardFunds();\n\n        return tokens;\n    }\n\n    function setWallet(address _wallet) onlyOwner {\n        require(_wallet != 0x0);\n        wallet = _wallet;\n    }\n\n    function setRate(uint256 _rate) onlyOwner {\n        require(isFinalized);\n        rate = _rate;\n        RateChange(_rate);\n    }\n\n    function startContinuousSale() onlyOwner {\n        require(isFinalized);\n        continuousSale = true;\n    }\n\n    function hasEnded() constant returns(bool) {\n        return isFinalized || super.hasEnded();\n    }\n\n    function finalize() onlyOwner {\n        require(!isFinalized);\n\n        finalization();\n        Finalized();\n\n        isFinalized = true;\n    }\n\n    function finalization() internal {\n        uint256 totalSupply = token.totalSupply();\n        uint256 finalSupply = TOTAL_SHARE.mul(totalSupply).div(CROWDSALE_SHARE);\n\n        // emit tokens for the foundation\n        token.mint(wallet, FOUNDATION_SHARE.mul(finalSupply).div(TOTAL_SHARE));\n\n        // initialize issuance \n        // TODO: possibility of overflow in these operations should be analized\n        uint256 annualIssuance = finalSupply.mul(INFLATION).div(100);\n        issuance = annualIssuance.mul(BUCKET_SIZE).div(1 years);\n\n        // NOTE: cannot call super here because it would finish minting and\n        // the continuous sale would not be able to proceed\n    }\n}"
    },
    {
      "filename": "contracts/BurnableToken.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport 'zeppelin-solidity/contracts/token/StandardToken.sol';\n\n/**\n * @title Burnable Token\n * @dev A token that can be irreversibly burned.\n */\ncontract BurnableToken is StandardToken {\n\n    event Burn(address indexed burner, uint256 value);\n\n    /**\n     * @dev Burns a specified amount of tokens.\n     * @param _value The amount of tokens to burn. \n     */\n    function burn(uint256 _value) {\n        address burner = msg.sender;\n        balances[burner] = balances[burner].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        Burn(msg.sender, _value);\n    }\n\n}"
    },
    {
      "filename": "contracts/WhitelistedCrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport 'zeppelin-solidity/contracts/math/SafeMath.sol';\nimport 'zeppelin-solidity/contracts/crowdsale/Crowdsale.sol';\n\n/**\n * @title WhitelistedCrowdsale\n * @dev Extension of Crowsdale where an owner can whitelist addresses\n * which can invest in crowdsale before it opens to the public \n */\ncontract WhitelistedCrowdsale is Crowdsale, Ownable {\n    using SafeMath for uint256;\n\n    // list of addresses that can purchase before crowdsale opens\n    mapping (address => bool) public whitelist;\n\n    function addToWhitelist(address investor) public onlyOwner {\n        whitelist[investor] = true; \n    }\n\n    // @return true if investor is whitelisted\n    function isWhitelisted(address investor) public constant returns (bool) {\n        return whitelist[investor];\n    }\n\n    // overriding Crowdsale#validPurchase to add whitelist logic\n    // @return true if investors can buy at the moment\n    function validPurchase() internal constant returns (bool) {\n        // [TODO] issue with overriding and associativity of logical operators\n        return super.validPurchase() || (!hasEnded() && isWhitelisted(msg.sender)); \n    }\n\n}"
    }
  ]
}