{
  "Title": "Wrong hardcoded PnL factor is used in all GMXVault add liquidity operations",
  "Content": "# Wrong hardcoded PnL factor is used in all GMXVault add liquidity operations\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L90-L101\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L90-L101</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L148\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L148</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L244-L248\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L244-L248</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/gmx-io/gmx-synthetics/blob/3b37cfa213471aac86344c352aa1636c67f41ca8/contracts/market/MarketUtils.sol#L136C14-L136C33\">https://github.com/gmx-io/gmx-synthetics/blob/3b37cfa213471aac86344c352aa1636c67f41ca8/contracts/market/MarketUtils.sol#L136C14-L136C33</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"\"></a>\n\n\n## Summary\nUsing a wrong hash when depositing into GMX Market will potentially stop all the deposits from GMXVaults, based on GMX’s deposit notes.\n\nhttps://github.com/gmx-io/gmx-synthetics#deposit-notes\n\nWhich states:\n\n• Deposits are not allowed above the MAX_PNL_FACTOR_FOR_DEPOSITS\n\n## Vulnerability Details\nThe vulnerability lies in the fact that when either `GMXVault::deposit` and `GMXVault::rebalanceAdd` are called wrong pnlFactor (`MAX_PNL_FACTOR_FOR_WITHDRAWALS`) will be passed to the oracle function `GMXOracle::getLpTokenValue` which is intended to fetch the price of the market token when deposit and withdrawal functions are called. \n## Impact\nAs you can see in every time when the minimum market slippage amount is calculated pnl factor for withdrawals will be used:\n\n```solidity\nsrc: GMXDeposit.sol#L90-L101\n\nif (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false, //@audit when depositing this should be set to true\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n\t}\n```\n\n```solidity\nsrc: GMXOracle.sol#L234-L257\n\nfunction getLpTokenValue(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    bytes32 _pnlFactorType;\n\n    if (isDeposit) {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    } else {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    }\n\n    (int256 _marketTokenPrice,) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      maximize\n    );\n```\n\nProblem occurs when both `MAX_PNL_FACTOR_FOR_DEPOSITS` and `MAX_PNL_FACTOR_FOR_WITHDRAWALS` have different values.\n\nThere are 2 possible scenarios:\n1. `MAX_PNL_FACTOR_FOR_WITHDRAWALS` is less than `MAX_PNL_FACTOR_FOR_DEPOSITS` \n\nIn this case, when the user wants to deposit the maximum allowed amount based on `MAX_PNL_FACTOR_FOR_DEPOSITS` transaction will most likely revert because there will be a different price of lpToken returned from the GMXOracle called with the pnlFactor = `MAX_PNL_FACTOR_FOR_WITHDRAWALS`, instead of the one for **deposits.**\n\n1. `MAX_PNL_FACTOR_FOR_WITHDRAWALS` is more than `MAX_PNL_FACTOR_FOR_DEPOSITS` \n\nIn this case, GMXMarket’s Reader contract will return better price of the market token for the user, allowing him to deposit more than the actual value of `MAX_PNL_FACTOR_FOR_DEPOSIT`.\n## Tools Used\n\n## Recommendations\nChange the isDeposit to **true** argument passed in the following functions: `GMXDeposit::deposit` and `GMXRebalance::rebalanceAdd`\n\n```diff\nif (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n-       false,\n+       true,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n\t}\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenB),\n          address(self.tokenB),\n          slippage\n        );\n      } else {\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenA),\n          address(self.tokenB),\n          slippage\n        );\n      }\n\n      _rlp.executionFee = executionFee;\n\n      // Remove liqudity\n      self.depositCache.withdrawKey = GMXManager.removeLiquidity(\n        self,\n        _rlp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    GMXTypes.RepayParams memory _rp;\n\n    _rp.repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    _rp.repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n\n    // Check if swap between assets are needed for repayment based on previous borrow\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Adjust amount to repay for both tokens due to slight differences\n    // from liqudiity withdrawal and swaps. If the amount to repay based on previous borrow\n    // is more than the available balance vault has, we simply repay what the vault has\n    uint256 _repayTokenAAmt;\n    uint256 _repayTokenBAmt;\n\n    if (self.depositCache.borrowParams.borrowTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      _repayTokenAAmt = self.tokenA.balanceOf(address(this));\n    } else {\n      _repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    }\n\n    if (self.depositCache.borrowParams.borrowTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      _repayTokenBAmt = self.tokenB.balanceOf(address(this));\n    } else {\n      _repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n    }\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      _repayTokenAAmt,\n      _repayTokenBAmt\n    );\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXWorker } from \"./GMXWorker.sol\";\n\n/**\n  * @title GMXManager\n  * @author Steadefi\n  * @notice Re-usable library functions for calculations and operations of borrows, repays, swaps\n  * adding and removal of liquidity to yield source\n*/\nlibrary GMXManager {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Calculate if token swap is needed to ensure enough repayment for both tokenA and tokenB\n    * @notice Assume that after swapping one token for the other, there is still enough to repay both tokens\n    * @param self GMXTypes.Store\n    * @param rp GMXTypes.RepayParams\n    * @return swapNeeded boolean if swap is needed\n    * @return tokenFrom address of token to swap from\n    * @return tokenTo address of token to swap to\n    * @return tokenToAmt amount of tokenFrom to swap in token decimals\n  */\n  function calcSwapForRepay(\n    GMXTypes.Store storage self,\n    GMXTypes.RepayParams memory rp\n  ) external view returns (bool, address, address, uint256) {\n    address _tokenFrom;\n    address _tokenTo;\n    uint256 _tokenToAmt;\n\n    if (rp.repayTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      // If more tokenA is needed for repayment\n      _tokenToAmt = rp.repayTokenAAmt - self.tokenA.balanceOf(address(this));\n      _tokenFrom = address(self.tokenB);\n      _tokenTo = address(self.tokenA);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else if (rp.repayTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      // If more tokenB is needed for repayment\n      _tokenToAmt = rp.repayTokenBAmt - self.tokenB.balanceOf(address(this));\n      _tokenFrom = address(self.tokenA);\n      _tokenTo = address(self.tokenB);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else {\n      // If more there is enough to repay both tokens\n      return (false, address(0), address(0), 0);\n    }\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to borrow\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function calcBorrow(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view returns (uint256, uint256) {\n    // Calculate final position value based on deposit value\n    uint256 _positionValue = depositValue * self.leverage / SAFE_MULTIPLIER;\n\n    // Obtain the value to borrow\n    uint256 _borrowValue = _positionValue - depositValue;\n\n    uint256 _tokenADecimals = IERC20Metadata(address(self.tokenA)).decimals();\n    uint256 _tokenBDecimals = IERC20Metadata(address(self.tokenB)).decimals();\n    uint256 _borrowLongTokenAmt;\n    uint256 _borrowShortTokenAmt;\n\n    // If delta is long, borrow all in short token\n    if (self.delta == GMXTypes.Delta.Long) {\n      _borrowShortTokenAmt = _borrowValue * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    // If delta is neutral, borrow appropriate amount in long token to hedge, and the rest in short token\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      // Get token weights in LP, e.g. 50% = 5e17\n      (uint256 _tokenAWeight,) = GMXReader.tokenWeights(self);\n\n      // Get value of long token (typically tokenA)\n      uint256 _longTokenWeightedValue = _tokenAWeight * _positionValue / SAFE_MULTIPLIER;\n\n      // Borrow appropriate amount in long token to hedge\n      _borrowLongTokenAmt = _longTokenWeightedValue * SAFE_MULTIPLIER\n                            / GMXReader.convertToUsdValue(self, address(self.tokenA), 10**(_tokenADecimals))\n                            / (10 ** (18 - _tokenADecimals));\n\n      // Borrow the shortfall value in short token\n      _borrowShortTokenAmt = (_borrowValue - _longTokenWeightedValue) * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    return (_borrowLongTokenAmt, _borrowShortTokenAmt);\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to repay based on token shares ratio being withdrawn\n    * @param self GMXTypes.Store\n    * @param shareRatio Amount of vault token shares relative to total supply in 1e18\n  */\n  function calcRepay(\n    GMXTypes.Store storage self,\n    uint256 shareRatio\n  ) external view returns (uint256, uint256) {\n    (uint256 tokenADebtAmt, uint256 tokenBDebtAmt) = GMXReader.debtAmt(self);\n\n    uint256 _repayTokenAAmt = shareRatio * tokenADebtAmt / SAFE_MULTIPLIER;\n    uint256 _repayTokenBAmt = shareRatio * tokenBDebtAmt / SAFE_MULTIPLIER;\n\n    return (_repayTokenAAmt, _repayTokenBAmt);\n  }\n\n  /**\n    * @notice Calculate minimum market (GM LP) tokens to receive when adding liquidity\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n    * @param slippage Slippage value in 1e4\n    * @return minMarketTokenAmt in 1e18\n  */\n  function calcMinMarketSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 depositValue,\n    uint256 slippage\n  ) external view returns (uint256) {\n    uint256 _lpTokenValue = self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    );\n\n    return depositValue\n      * SAFE_MULTIPLIER\n      / _lpTokenValue\n      * (10000 - slippage) / 10000;\n  }\n\n  /**\n    * @notice Calculate minimum tokens to receive when removing liquidity\n    * @dev minLongToken and minShortToken should be the token which we want to receive\n    * after liquidity withdrawal and swap\n    * @param self GMXTypes.Store\n    * @param lpAmt Amt of lp tokens to remove liquidity in 1e18\n    * @param minLongToken Address of token to receive longToken in\n    * @param minShortToken Address of token to receive shortToken in\n    * @param slippage Slippage value in 1e4\n    * @return minTokenAAmt in 1e18\n    * @return minTokenBAmt in 1e18\n  */\n  function calcMinTokensSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 lpAmt,\n    address minLongToken,\n    address minShortToken,\n    uint256 slippage\n  ) external view returns (uint256, uint256) {\n    uint256 _withdrawValue = lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    (uint256 _tokenAWeight, uint256 _tokenBWeight) = GMXReader.tokenWeights(self);\n\n    uint256 _minLongTokenAmt = _withdrawValue\n      * _tokenAWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minLongToken,\n        10**(IERC20Metadata(minLongToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minLongToken).decimals()));\n\n    uint256 _minShortTokenAmt = _withdrawValue\n      * _tokenBWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minShortToken,\n        10**(IERC20Metadata(minShortToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minShortToken).decimals()));\n\n    return (\n      _minLongTokenAmt * (10000 - slippage) / 10000,\n      _minShortTokenAmt * (10000 - slippage) / 10000\n    );\n  }\n\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Borrow tokens from lending vaults\n    * @param self GMXTypes.Store\n    * @param borrowTokenAAmt Amount of tokenA to borrow in token decimals\n    * @param borrowTokenBAmt Amount of tokenB to borrow in token decimals\n  */\n  function borrow(\n    GMXTypes.Store storage self,\n    uint256 borrowTokenAAmt,\n    uint256 borrowTokenBAmt\n  ) public {\n    if (borrowTokenAAmt > 0) {\n      self.tokenALendingVault.borrow(borrowTokenAAmt);\n    }\n    if (borrowTokenBAmt > 0) {\n      self.tokenBLendingVault.borrow(borrowTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Repay tokens to lending vaults\n    * @param self GMXTypes.Store\n    * @param repayTokenAAmt Amount of tokenA to repay in token decimals\n    * @param repayTokenBAmt Amount of tokenB to repay in token decimals\n  */\n  function repay(\n    GMXTypes.Store storage self,\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  ) public {\n    if (repayTokenAAmt > 0) {\n      self.tokenALendingVault.repay(repayTokenAAmt);\n    }\n    if (repayTokenBAmt > 0) {\n      self.tokenBLendingVault.repay(repayTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Add liquidity to yield source\n    * @param self GMXTypes.Store\n    * @param alp GMXTypes.AddLiquidityParams\n    * @return depositKey\n  */\n  function addLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.AddLiquidityParams memory alp\n  ) public returns (bytes32) {\n    return GMXWorker.addLiquidity(self, alp);\n  }\n\n  /**\n    * @notice Remove liquidity from yield source\n    * @param self GMXTypes.Store\n    * @param rlp GMXTypes.RemoveLiquidityParams\n    * @return withdrawKey\n  */\n  function removeLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.RemoveLiquidityParams memory rlp\n  ) public returns (bytes32) {\n    return GMXWorker.removeLiquidity(self, rlp);\n  }\n\n  /**\n    * @notice Swap exact amount of tokenIn for as many possible amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountOut in token decimals\n  */\n  function swapExactTokensForTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapExactTokensForTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    * @notice Swap as little posible tokenIn for exact amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountIn in token decimals\n  */\n  function swapTokensForExactTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapTokensForExactTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n}"
    },
    {
      "filename": "contracts/oracles/GMXOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISyntheticReader } from \"../interfaces/protocols/gmx/ISyntheticReader.sol\";\nimport { IChainlinkOracle } from \"../interfaces/oracles/IChainlinkOracle.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\nimport { console } from \"forge-std/console.sol\";\n\ncontract GMXOracle {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMX DataStore\n  address public immutable dataStore;\n  // GMX Synthetic Reader\n  ISyntheticReader public immutable syntheticReader;\n  // Chainlink oracle\n  IChainlinkOracle public immutable chainlinkOracle;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param _DataStore Address of GMX DataStore\n    * @param _syntheticReader Address of GMX Synthetic Reader\n    * @param _chainlinkOracle Address of Chainlink oracle\n  */\n  constructor(\n    address _DataStore,\n    ISyntheticReader _syntheticReader,\n    IChainlinkOracle _chainlinkOracle\n  ) {\n    if (_DataStore == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_syntheticReader) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_chainlinkOracle) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    dataStore = _DataStore;\n    syntheticReader = _syntheticReader;\n    chainlinkOracle = _chainlinkOracle;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get amountsOut of either the long or short token based on the amountsIn\n    * of either long or short token in the market\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenIn TokenIn address\n    * @param amountIn Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsOut(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenIn,\n    uint256 amountIn\n  ) public view returns (uint256) {\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    ISyntheticReader.MarketPrices memory _prices;\n    _prices.indexTokenPrice = _indexTokenPrice;\n    _prices.longTokenPrice = _longTokenPrice;\n    _prices.shortTokenPrice = _shortTokenPrice;\n\n    address _uiFeeReceiver = address(0);\n\n    (uint256 _amountsOut,,) = syntheticReader.getSwapAmountOut(\n      dataStore,\n      _market,\n      _prices,\n      tokenIn,\n      amountIn,\n      _uiFeeReceiver\n    );\n\n    return _amountsOut;\n  }\n\n  /**\n    * @notice Helper function to calculate amountIn of either long or short token for swapping for\n    * desired amountsOut of long or short token\n    * @notice We utilise GMX's getSwapAmountOut() with tokenOut being tokenIn, multiplying\n    * the amountsOut value by 1.0015x to account for fees and normal chainlink price feed differential\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenOut TokenIn address\n    * @param amountsOut Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsIn(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenOut,\n    uint256 amountsOut\n  ) public view returns (uint256) {\n    return getAmountsOut(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      tokenOut,\n      amountsOut\n    ) * (1e18 + 15e14) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice Get LP (market) token info\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param pnlFactorType P&L Factory type in bytes32 hashed string\n    * @param maximize Min/max price boolean\n    * @return (marketTokenPrice, MarketPoolValueInfoProps MarketInfo)\n  */\n  function getMarketTokenInfo(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bytes32 pnlFactorType,\n    bool maximize\n  ) public view returns (int256, ISyntheticReader.MarketPoolValueInfoProps memory) {\n    if (address(marketToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(indexToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(longToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(shortToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    return syntheticReader.getMarketTokenPrice(\n      dataStore,\n      _market,\n      _indexTokenPrice,\n      _longTokenPrice,\n      _shortTokenPrice,\n      pnlFactorType,\n      maximize\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @return (reserveA, reserveB) Reserve amount of longToken and shortToken respectively\n  */\n  function getLpTokenReserves(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken\n  ) public view returns (uint256, uint256) {\n    // _pnlFactorType value does not matter in getting token reserves\n    bytes32 _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n\n    // _maximize value does not matter in getting token reserves\n    bool _maximize = false;\n\n    (, ISyntheticReader.MarketPoolValueInfoProps memory _marketInfo) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      _maximize\n    );\n\n    return (\n      _marketInfo.longTokenAmount,\n      _marketInfo.shortTokenAmount\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return marketTokenPrice in 1e18\n  */\n  function getLpTokenValue(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    bytes32 _pnlFactorType;\n\n    if (isDeposit) {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    } else {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    }\n\n    (int256 _marketTokenPrice,) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      maximize\n    );\n\n    // If LP token value is negative, return 0\n    if (_marketTokenPrice < 0) {\n      return 0;\n    } else {\n      // Price returned in 1e30, we normalize it to 1e18\n      return uint256(_marketTokenPrice) / 1e12;\n    }\n  }\n\n\n  /**\n    * @notice Get token A and token B's LP token amount required for a given value\n    * @param givenValue Given value needed, expressed in 1e30\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return lpTokenAmount Amount of LP tokens; expressed in 1e18\n  */\n  function getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      isDeposit,\n      maximize\n    );\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Get token price formatted for GMX mix/max decimals for 1e30 normalization\n    * @dev E.g. if token decimals is 18, to normalize to 1e30, we need to return 30-18 = 1e12\n    * consult() usually returns asset price in 8 decimals, so 30 - tokenDecimals - priceDecimals\n    * should format the decimals correctly for 1e30\n    * @param token Token address\n    * @return tokenPriceMinMaxFormatted\n  */\n  function _getTokenPriceMinMaxFormatted(address token) internal view ret"
    }
  ]
}