{
  "Title": "Implicit timing assumptions",
  "Content": "To account for the coverage delay, some valid cxTokens [may be excluded](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/cxToken/cxToken.sol#L103) from making claims. Any coverage that will become active [within 14 days](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/cxToken/cxToken.sol#L108) but [before the incident resolution](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/cxToken/cxToken.sol#L111) will be disregarded. This implicitly assumes that no valid cover starts after either of these deadlines (otherwise it should also be excluded). Since the coverage delay and resolution window are configurable parameters, the assumptions may not hold. Consider calculating exclusions based on the specific parameters that are relevant to the incident being processed.\n\n\n**Update:** *Fixed as of commit `e00b4248768c196a2b5047dcc21d91a2503452ab` in [pull request #162](https://github.com/neptune-mutual-blue/protocol/pull/162) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/cxToken/cxToken.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../../interfaces/IStore.sol\";\nimport \"../../interfaces/ICxToken.sol\";\nimport \"../../libraries/GovernanceUtilV1.sol\";\nimport \"../../libraries/PolicyHelperV1.sol\";\nimport \"../Recoverable.sol\";\n\n/**\n * @title cxToken\n *\n * @dev cxTokens are minted when someone purchases a cover.\n *\n * <br /> <br />\n *\n * The cxTokens can be exchanged for a USD stablecoin at a 1:1 exchange rate\n * after a cover incident is successfully resolved (minus platform fees).\n *  <br /> <br />\n *\n * **Restrictions:**\n *\n * - cxTokens cannot be transferred from one person to another.\n * - Only claims can be submitted with cxTokens\n * - There is a lag period before your cxTokens starts its coverage.\n * cxTokens start coverage the next day (or longer) at the UTC EOD timestamp and remain valid until the expiration date.\n * - The lag configuration can be found in [ProtoUtilV1.NS_COVERAGE_LAG](ProtoUtilV1.md)\n * and [PolicyAdmin.getCoverageLag](PolicyAdmin.md#getcoveragelag) function.\n *\n */\n// slither-disable-next-line naming-convention\ncontract cxToken is ICxToken, Recoverable, ERC20 {\n  // solhint-disable-previous-line\n  using CoverUtilV1 for IStore;\n  using GovernanceUtilV1 for IStore;\n  using ProtoUtilV1 for IStore;\n  using PolicyHelperV1 for IStore;\n  using ValidationLibV1 for IStore;\n\n  // slither-disable-next-line naming-convention\n  bytes32 public immutable override COVER_KEY; // solhint-disable-line\n  // slither-disable-next-line naming-convention\n  bytes32 public immutable override PRODUCT_KEY; // solhint-disable-line\n  uint256 public immutable override createdOn = block.timestamp; // solhint-disable-line\n  uint256 public immutable override expiresOn;\n\n  /**\n   * @dev Constructs this contract.\n   *\n   * @param store Provide the store contract instance\n   * @param coverKey Enter the cover key\n   * @param productKey Enter the product key\n   * @param tokenName Enter token name for this ERC-20 contract. The token symbol will be `cxUSD`.\n   * @param expiry Provide the cover expiry timestamp\n   *\n   */\n  constructor(\n    IStore store,\n    bytes32 coverKey,\n    bytes32 productKey,\n    string memory tokenName,\n    uint256 expiry\n  ) ERC20(tokenName, \"cxUSD\") Recoverable(store) {\n    COVER_KEY = coverKey;\n    PRODUCT_KEY = productKey;\n    expiresOn = expiry;\n  }\n\n  /** @dev Account to coverage start date to amount mapping */\n  mapping(address => mapping(uint256 => uint256)) public coverageStartsFrom;\n\n  /**\n   * @dev Returns the value of the `coverageStartsFrom` mapping.\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param account Enter an account to get the `coverageStartsFrom` value.\n   * @param date Enter a date. Ensure that you supply a UTC EOD value.\n   *\n   */\n  function getCoverageStartsFrom(address account, uint256 date) external view override returns (uint256) {\n    return coverageStartsFrom[account][date];\n  }\n\n  /**\n   * @dev Gets sum of the lagged and, therefore, excluded policy of a given account.\n   *\n   * <br /><br />\n   *\n   * Only policies purchased within 24-48 hours (or longer depending on this cover's configuration) are valid.\n   * Given the present codebase, the loop that follows may appear pointless and invalid.\n   *\n   * <br /><br />\n   *\n   * Since the protocol is upgradable but not cxTokens,\n   * erroneous code could be introduced in the future,\n   * which is why we go all the way until the resolution deadline.\n   *\n   * @param account Enter an account.\n   *\n   */\n  function _getExcludedCoverageOf(address account) private view returns (uint256 exclusion) {\n    uint256 incidentDate = s.getActiveIncidentDateInternal(COVER_KEY, PRODUCT_KEY);\n\n    uint256 resolutionEOD = _getEOD(s.getResolutionTimestampInternal(COVER_KEY, PRODUCT_KEY));\n\n    for (uint256 i = 0; i < 14; i++) {\n      uint256 date = _getEOD(incidentDate + (i * 1 days));\n\n      if (date > resolutionEOD) {\n        break;\n      }\n\n      exclusion += coverageStartsFrom[account][date];\n    }\n  }\n\n  /**\n   * @dev Gets the claimable policy of an account.\n   *\n   * Warning: this function does not validate the input arguments.\n   *\n   * @param account Enter an account.\n   *\n   */\n  function getClaimablePolicyOf(address account) external view override returns (uint256) {\n    uint256 exclusion = _getExcludedCoverageOf(account);\n    uint256 balance = super.balanceOf(account);\n\n    if (exclusion > balance) {\n      return 0;\n    }\n\n    return balance - exclusion;\n  }\n\n  /**\n   * @dev Mints cxTokens when a policy is purchased.\n   * This feature can only be accessed by the latest policy smart contract.\n   *\n   * @custom:suppress-acl Can only be called by the latest policy contract\n   *\n   * @param coverKey Enter the cover key for which the cxTokens are being minted\n   * @param to Enter the address where the minted token will be sent\n   * @param amount Specify the amount of cxTokens to mint\n   *\n   */\n  function mint(\n    bytes32 coverKey,\n    bytes32 productKey,\n    address to,\n    uint256 amount\n  ) external override nonReentrant {\n    require(amount > 0, \"Please specify amount\");\n    require(coverKey == COVER_KEY, \"Invalid cover\");\n    require(productKey == PRODUCT_KEY, \"Invalid product\");\n\n    s.mustNotBePaused();\n    s.senderMustBePolicyContract();\n    s.mustBeSupportedProductOrEmpty(coverKey, productKey);\n\n    uint256 effectiveFrom = _getEOD(block.timestamp + s.getCoverageLagInternal(coverKey)); // solhint-disable-line\n    coverageStartsFrom[to][effectiveFrom] += amount;\n\n    super._mint(to, amount);\n  }\n\n  /**\n   * @dev Gets the EOD (End of Day) time\n   */\n  function _getEOD(uint256 date) private pure returns (uint256) {\n    (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(date);\n    return BokkyPooBahsDateTimeLibrary.timestampFromDateTime(year, month, day, 23, 59, 59);\n  }\n\n  /**\n   * @dev Burns the tokens held by the sender.\n   *\n   * @custom:suppress-acl This is a publicly accessible feature\n   *\n   * @param amount Specify the amount of tokens to burn\n   *\n   */\n  function burn(uint256 amount) external override nonReentrant {\n    require(amount > 0, \"Please specify amount\");\n\n    s.mustNotBePaused();\n    super._burn(msg.sender, amount);\n  }\n\n  /**\n   * @dev Overrides Openzeppelin ERC-20 contract's `_beforeTokenTransfer` hook.\n   * This is called during `transfer`, `transferFrom`, `mint`, and `burn` function invocation.\n   *\n   * <br /><br/>\n   *\n   * **cxToken Restrictions:**\n   *\n   * - An expired cxToken can't be transferred.\n   * - cxTokens can only be transferred to the claims processor contract.\n   *\n   * @param from The account sending the cxTokens\n   * @param to The account receiving the cxTokens\n   *\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256\n  ) internal view override {\n    // solhint-disable-next-line\n    if (block.timestamp > expiresOn) {\n      require(to == address(0), \"Expired cxToken\");\n    }\n\n    // cxTokens can only be transferred to the claims processor contract\n    if (from != address(0) && to != address(0)) {\n      s.mustBeExactContract(ProtoUtilV1.CNS_CLAIM_PROCESSOR, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY, to);\n    }\n  }\n}"
    }
  ]
}