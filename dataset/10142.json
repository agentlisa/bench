{
  "Title": "[H-01] Self transfer can lead to unlimited mint",
  "Content": "_Submitted by Omik, also found by gpersoon_\n\nThe implementation of the transfer function in [`nTokenAction.sol`]( https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol) is different from the usual erc20 token transfer function.\n\n This happens because it counts the incentive that the user gets, but with a self-transfer,  it can lead to unlimited mint. In [L278](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#_L278), it makes the amount negative, but in [L279](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279), it returns the value to an amount that is not negative. So, in the [L281-282](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282), it finalizes a positive value, only because the negative value is changed to the positive value.\n\n You can interact with this transfer function through [nTokenERC20Proxy.sol](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol).\n\nRecommend adding `(sender != recipient)`.\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-08-notional",
  "Code": [
    {
      "filename": "contracts/external/actions/nTokenAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../internal/nTokenHandler.sol\";\nimport \"../../internal/markets/AssetRate.sol\";\nimport \"../../internal/balances/BalanceHandler.sol\";\nimport \"../../internal/balances/Incentives.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/StorageLayoutV1.sol\";\nimport \"interfaces/notional/nTokenERC20.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract nTokenAction is StorageLayoutV1, nTokenERC20 {\n    using BalanceHandler for BalanceState;\n    using AssetRate for AssetRateParameters;\n    using AccountContextHandler for AccountContext;\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    /// @notice Total number of tokens in circulation\n    /// @param nTokenAddress The address of the nToken\n    /// @return totalSupply number of tokens held\n    function nTokenTotalSupply(address nTokenAddress)\n        external\n        view\n        override\n        returns (uint256 totalSupply)\n    {\n        // prettier-ignore\n        (\n            totalSupply,\n            /* integralTotalSupply */,\n            /* lastSupplyChangeTime */\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function nTokenBalanceOf(uint16 currencyId, address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // prettier-ignore\n        (\n            /* int cashBalance */,\n            int256 nTokenBalance,\n            /* uint lastClaimTime */,\n            /* uint lastClaimIntegralSupply */\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\n\n        require(nTokenBalance >= 0); // dev: negative nToken balance\n        return uint256(nTokenBalance);\n    }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param owner The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function nTokenTransferAllowance(\n        uint16 currencyId,\n        address owner,\n        address spender\n    ) external view override returns (uint256) {\n        // This whitelist allowance supersedes any specific allowances\n        uint256 allowance = nTokenWhitelist[owner][spender];\n        if (allowance > 0) return allowance;\n\n        return nTokenAllowance[owner][spender][currencyId];\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev Can only be called via the nToken proxy\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApprove(\n        uint16 currencyId,\n        address owner,\n        address spender,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        nTokenAllowance[owner][spender][currencyId] = amount;\n\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param from The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransfer(\n        uint16 currencyId,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        return _transfer(currencyId, from, to, amount);\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev Can only be called via the nToken proxy\n    /// @param currencyId Currency id of the nToken\n    /// @param spender The address of the original caller\n    /// @param from The address of the source account\n    /// @param to The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function nTokenTransferFrom(\n        uint16 currencyId,\n        address spender,\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool, uint256) {\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(msg.sender == nTokenAddress, \"Unauthorized caller\");\n\n        uint256 allowance = nTokenWhitelist[from][spender];\n\n        if (allowance > 0) {\n            // This whitelist allowance supersedes any specific allowances\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenWhitelist[from][spender] = allowance;\n        } else {\n            // This is the specific allowance for the nToken.\n            allowance = nTokenAllowance[from][spender][currencyId];\n            require(allowance >= amount, \"Insufficient allowance\");\n            allowance = allowance.sub(amount);\n            nTokenAllowance[from][spender][currencyId] = allowance;\n        }\n\n        bool success = _transfer(currencyId, from, to, amount);\n        return (success, allowance);\n    }\n\n    /// @notice Will approve all nToken transfers to the specific sender. This is used for simplifying UX, a user can approve\n    /// all token transfers to an external exchange or protocol in a single txn. This must be called directly\n    /// on the Notional contract, not available via the ERC20 proxy.\n    /// @dev emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function nTokenTransferApproveAll(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        nTokenWhitelist[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /// @notice Claims incentives accrued on all nToken balances and transfers them to the msg.sender\n    /// @dev auth:msg.sender\n    /// @return Total amount of incentives claimed\n    function nTokenClaimIncentives() external override returns (uint256) {\n        address account = msg.sender;\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\n        uint256 totalIncentivesClaimed;\n        BalanceState memory balanceState;\n\n        if (accountContext.bitmapCurrencyId != 0) {\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n        }\n\n        bytes18 currencies = accountContext.activeCurrencies;\n        while (currencies != 0) {\n            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));\n\n            balanceState.loadBalanceState(account, currencyId, accountContext);\n            if (balanceState.storedNTokenBalance > 0) {\n                totalIncentivesClaimed = totalIncentivesClaimed.add(\n                    BalanceHandler.claimIncentivesManual(balanceState, account)\n                );\n            }\n\n            currencies = currencies << 16;\n        }\n\n        // NOTE: no need to set account context after claiming incentives\n        return totalIncentivesClaimed;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in asset tokens\n    function nTokenPresentValueAssetDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* portfolio */\n        ) = _getNTokenPV(currencyId);\n\n        return totalAssetPV;\n    }\n\n    /// @notice Returns the present value of the nToken's assets denominated in underlying\n    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)\n        external\n        view\n        override\n        returns (int256)\n    {\n        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);\n\n        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);\n    }\n\n    function _getNTokenPV(uint256 currencyId)\n        private\n        view\n        returns (int256, nTokenPortfolio memory)\n    {\n        uint256 blockTime = block.timestamp;\n        nTokenPortfolio memory nToken;\n        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);\n\n        // prettier-ignore\n        (\n            int256 totalAssetPV,\n            /* ifCashMapping */\n        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);\n\n        return (totalAssetPV, nToken);\n    }\n\n    /// @notice Transferring tokens will also claim incentives at the same time\n    function _transfer(\n        uint256 currencyId,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        {\n            // prettier-ignore\n            (\n                uint256 isNToken,\n                /* incentiveAnnualEmissionRate */,\n                /* lastInitializedTime */,\n                /* parameters */\n            ) = nTokenHandler.getNTokenContext(recipient);\n            // nTokens cannot hold nToken balances\n            require(isNToken == 0, \"Cannot transfer to nToken\");\n        }\n\n        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);\n        BalanceState memory senderBalance;\n        senderBalance.loadBalanceState(sender, currencyId, senderContext);\n\n        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);\n        BalanceState memory recipientBalance;\n        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);\n\n        int256 amountInt = SafeCast.toInt256(amount);\n        senderBalance.netNTokenTransfer = amountInt.neg();\n        recipientBalance.netNTokenTransfer = amountInt;\n\n        senderBalance.finalize(sender, senderContext, false);\n        recipientBalance.finalize(recipient, recipientContext, false);\n        senderContext.setAccountContext(sender);\n        recipientContext.setAccountContext(recipient);\n\n        emit Transfer(sender, recipient, amount);\n\n        return true;\n    }\n}"
    }
  ]
}