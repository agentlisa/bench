{
  "Title": "Possible free tokens on Ledger",
  "Content": "##### Description\nIf someone sends `xcKSM` to Ledger: https://github.com/mixbytes/lido-dot-ksm/blob/76a10efa5f223c4c613f26794802b8fb9bb188e1/contracts/Ledger.sol#L282\n\n##### Recommendation\nWe recommend sendig excess in funds to treasury.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Ledger.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../interfaces/IOracleMaster.sol\";\nimport \"../interfaces/ILido.sol\";\nimport \"../interfaces/IRelayEncoder.sol\";\nimport \"../interfaces/IXcmTransactor.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/Types.sol\";\n\nimport \"./utils/LedgerUtils.sol\";\nimport \"./utils/ReportUtils.sol\";\n\n\n\ncontract Ledger {\n    using LedgerUtils for Types.OracleData;\n    using SafeCast for uint256;\n\n    event DownwardComplete(uint128 amount);\n    event UpwardComplete(uint128 amount);\n    event Rewards(uint128 amount, uint128 balance);\n    event Slash(uint128 amount, uint128 balance);\n\n    // ledger stash account\n    bytes32 public stashAccount;\n\n    // ledger controller account\n    bytes32 public controllerAccount;\n\n    // Stash balance that includes locked (bounded in stake) and free to transfer balance\n    uint128 public totalBalance;\n\n    // Locked, or bonded in stake module, balance\n    uint128 public lockedBalance;\n\n    // last reported active ledger balance\n    uint128 public activeBalance;\n\n    // last reported ledger status\n    Types.LedgerStatus public status;\n\n    // Cached stash balance. Need to calculate rewards between successfull up/down transfers\n    uint128 public cachedTotalBalance;\n\n    // Pending transfers\n    uint128 public transferUpwardBalance;\n    uint128 public transferDownwardBalance;\n\n\n    // vKSM precompile\n    IERC20 internal vKSM;\n\n    IController internal controller;\n\n    // Lido main contract address\n    ILido public LIDO;\n\n    // Minimal allowed balance to being a nominator\n    uint128 public MIN_NOMINATOR_BALANCE;\n\n\n    // Who pay off relay chain transaction fees\n    bytes32 internal constant GARANTOR = 0x00;\n\n\n    modifier onlyLido() {\n        require(msg.sender == address(LIDO), \"LEDGED: NOT_LIDO\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        address oracle = IOracleMaster(ILido(LIDO).ORACLE_MASTER()).getOracle(address(this));\n        require(msg.sender == oracle, \"LEDGED: NOT_ORACLE\");\n        _;\n    }\n\n    /**\n    * @notice Initialize ledger contract.\n    * @param _stashAccount - stash account id\n    * @param _controllerAccount - controller account id\n    * @param _vKSM - vKSM contract address\n    * @param _controller - xcmTransactor(relaychain calls relayer) contract address\n    * @param _minNominatorBalance - minimal allowed nominator balance\n    */\n    function initialize(\n        bytes32 _stashAccount,\n        bytes32 _controllerAccount,\n        address _vKSM,\n        address _controller,\n        uint128 _minNominatorBalance\n    ) external {\n        require(address(vKSM) == address(0), \"LEDGED: ALREADY_INITIALIZED\");\n\n        // The owner of the funds\n        stashAccount = _stashAccount;\n        // The account which handles bounded part of stash funds (unbond, rebond, withdraw, nominate)\n        controllerAccount = _controllerAccount;\n\n        status = Types.LedgerStatus.None;\n\n        LIDO = ILido(msg.sender);\n\n        vKSM = IERC20(_vKSM);\n\n        controller = IController(_controller);\n\n        MIN_NOMINATOR_BALANCE = _minNominatorBalance;\n\n//        vKSM.approve(_controller, type(uint256).max);\n    }\n\n    /**\n    * @notice Set new minimal allowed nominator balance, allowed to call only by lido contract\n    * @dev That method designed to be called by lido contract when relay spec is changed\n    * @param _minNominatorBalance - minimal allowed nominator balance\n    */\n    function setMinNominatorBalance(uint128 _minNominatorBalance) external onlyLido {\n        MIN_NOMINATOR_BALANCE = _minNominatorBalance;\n    }\n\n    function refreshAllowances() external {\n        vKSM.approve(address(controller), type(uint256).max);\n    }\n\n    /**\n    * @notice Return target stake amount for this ledger\n    * @return target stake amount\n    */\n    function ledgerStake() public view returns (uint256) {\n        return LIDO.ledgerStake(address(this));\n    }\n\n    /**\n    * @notice Return true if ledger doesn't have any funds\n    */\n    function isEmpty() external view returns (bool) {\n        return totalBalance == 0 && transferUpwardBalance == 0 && transferDownwardBalance == 0;\n    }\n\n    /**\n    * @notice Nominate on behalf of this ledger, allowed to call only by lido contract\n    * @dev Method spawns xcm call to relaychain.\n    * @param _validators - array of choosen validator to be nominated\n    */\n    function nominate(bytes32[] calldata _validators) external onlyLido {\n        require(activeBalance >= MIN_NOMINATOR_BALANCE, \"LEDGED: NOT_ENOUGH_STAKE\");\n        controller.nominate(_validators);\n    }\n\n    /**\n    * @notice Provide portion of relaychain data about current ledger, allowed to call only by oracle contract\n    * @dev Basically, ledger can obtain data from any source, but for now it allowed to recieve only from oracle.\n           Method perform calculation of current state based on report data and saved state and expose\n           required instructions(relaychain pallet calls) via xcm to adjust bonded amount to required target stake.\n    * @param _eraId - reporting era id\n    * @param _report - data that represent state of ledger on relaychain for `_eraId`\n    */\n    function pushData(uint64 _eraId, Types.OracleData memory _report) external onlyOracle {\n        require(stashAccount == _report.stashAccount, \"LEDGED: STASH_ACCOUNT_MISMATCH\");\n\n        status = _report.stakeStatus;\n        activeBalance = _report.activeBalance;\n\n        (uint128 unlockingBalance, uint128 withdrawableBalance) = _report.getTotalUnlocking(_eraId);\n        uint128 nonWithdrawableBalance = unlockingBalance - withdrawableBalance;\n\n        if (!_processRelayTransfers(_report)) {\n            return;\n        }\n        uint128 _cachedTotalBalance = cachedTotalBalance;\n        if (_cachedTotalBalance < _report.stashBalance) { // if cached balance > real => we have reward\n            uint128 reward = _report.stashBalance - _cachedTotalBalance;\n            LIDO.distributeRewards(reward, _report.stashBalance);\n\n            emit Rewards(reward, _report.stashBalance);\n        }\n        else if (_cachedTotalBalance > _report.stashBalance) {\n            uint128 slash = _cachedTotalBalance - _report.stashBalance;\n            LIDO.distributeLosses(slash, _report.stashBalance);\n\n            emit Slash(slash, _report.stashBalance);\n        }\n\n        uint128 _ledgerStake = ledgerStake().toUint128();\n\n        // relay deficit or bonding\n        if (_report.stashBalance <= _ledgerStake) {\n            //    Staking strategy:\n            //     - upward transfer deficit tokens\n            //     - rebond all unlocking tokens\n            //     - bond_extra all free balance\n\n            uint128 deficit = _ledgerStake - _report.stashBalance;\n\n            // just upward transfer if we have deficit\n            if (deficit > 0) {\n                uint128 lidoBalance = uint128(LIDO.avaliableForStake());\n                uint128 forTransfer = lidoBalance > deficit ? deficit : lidoBalance;\n\n                if (forTransfer > 0) {\n                    vKSM.transferFrom(address(LIDO), address(this), forTransfer);\n                    controller.transferToRelaychain(forTransfer);\n                    transferUpwardBalance += forTransfer;\n                }\n            }\n\n            // rebond all always\n            if (unlockingBalance > 0) {\n                controller.rebond(unlockingBalance);\n            }\n\n            uint128 relayFreeBalance = _report.getFreeBalance();\n\n            if (relayFreeBalance > 0 &&\n                (_report.stakeStatus == Types.LedgerStatus.Nominator || _report.stakeStatus == Types.LedgerStatus.Idle)) {\n                controller.bondExtra(relayFreeBalance);\n            } else if (_report.stakeStatus == Types.LedgerStatus.None && relayFreeBalance >= MIN_NOMINATOR_BALANCE) {\n                controller.bond(controllerAccount, relayFreeBalance);\n            }\n\n        }\n        else if (_report.stashBalance > _ledgerStake) { // parachain deficit\n            //    Unstaking strategy:\n            //     - try to downward transfer already free balance\n            //     - if we still have deficit try to withdraw already unlocked tokens\n            //     - if we still have deficit initiate unbond for remain deficit\n\n            // if ledger is in the deadpool we need to put it to chill\n            if (_ledgerStake < MIN_NOMINATOR_BALANCE && status != Types.LedgerStatus.Idle) {\n                controller.chill();\n            }\n\n            uint128 deficit = _report.stashBalance - _ledgerStake;\n            uint128 relayFreeBalance = _report.getFreeBalance();\n\n            // need to downward transfer if we have some free\n            if (relayFreeBalance > 0) {\n                uint128 forTransfer = relayFreeBalance > deficit ? deficit : relayFreeBalance;\n                controller.transferToParachain(forTransfer);\n                transferDownwardBalance += forTransfer;\n                deficit -= forTransfer;\n                relayFreeBalance -= forTransfer;\n            }\n\n            // withdraw if we have some unlocked\n            if (deficit > 0 && withdrawableBalance > 0) {\n                controller.withdrawUnbonded();\n                deficit -= withdrawableBalance > deficit ? deficit : withdrawableBalance;\n            }\n\n            // need to unbond if we still have deficit\n            if (nonWithdrawableBalance < deficit) {\n                // todo drain stake if remaining balance is less than MIN_NOMINATOR_BALANCE\n                uint128 forUnbond = deficit - nonWithdrawableBalance;\n                controller.unbond(forUnbond);\n                // notice.\n                // deficit -= forUnbond;\n            }\n\n            // bond all remain free balance\n            if (relayFreeBalance > 0) {\n                controller.bondExtra(relayFreeBalance);\n            }\n        }\n\n        cachedTotalBalance = _report.stashBalance;\n    }\n\n    function _processRelayTransfers(Types.OracleData memory _report) internal returns(bool) {\n        // wait for the downward transfer to complete\n        uint128 _transferDownwardBalance = transferDownwardBalance;\n        if (_transferDownwardBalance > 0) {\n            uint128 totalDownwardTransferred = uint128(vKSM.balanceOf(address(this)));\n\n            if (totalDownwardTransferred >= _transferDownwardBalance ) {\n                // take transferred funds into buffered balance\n                vKSM.transfer(address(LIDO), _transferDownwardBalance);\n\n                // Clear transfer flag\n                cachedTotalBalance -= _transferDownwardBalance;\n                transferDownwardBalance = 0;\n\n                emit DownwardComplete(_transferDownwardBalance);\n                _transferDownwardBalance = 0;\n            }\n        }\n\n        // wait for the upward transfer to complete\n        uint128 _transferUpwardBalance = transferUpwardBalance;\n        if (_transferUpwardBalance > 0) {\n            uint128 ledgerFreeBalance = (totalBalance - lockedBalance);\n            uint128 freeBalanceIncrement = _report.getFreeBalance() - ledgerFreeBalance;\n\n            if (freeBalanceIncrement >= _transferUpwardBalance) {\n                cachedTotalBalance += _transferUpwardBalance;\n\n                transferUpwardBalance = 0;\n                emit UpwardComplete(_transferUpwardBalance);\n                _transferUpwardBalance = 0;\n            }\n        }\n\n        if (_transferDownwardBalance == 0 && _transferUpwardBalance == 0) {\n            // update ledger data from oracle report\n            totalBalance = _report.stashBalance;\n            lockedBalance = _report.totalBalance;\n            return true;\n        }\n\n        return false;\n    }\n}"
    }
  ]
}