{
  "Title": "[07] Protocol is susceptible to synchronizing issues cause reverted system contract upgrade batches must stiill be committed between L1 and L2 upgrades due to wrongly assuming just reverting in the bootloader is enough",
  "Content": "\n### Proof of Concept\n\nCurrently, either `upgrade()` function of [BaseZkSyncUpgrade](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L67C1-L88C6) and [BaseZkSyncUpgradeGenesis](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L47C3-L68C6) is called depending on the context of the current upgrade.\n\nConsidering `BaseZkSyncUpgrade` we can see that [`BaseZkSyncUpgrade::upgrade()` eventually calls `_setL2SystemContractUpgrade()`](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L79) to pass on the data for the proposed upgrade\n\n```solidity\n        txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n```\n\nConsidering it's an upgrade transaction, this transaction should be executed on L2 with` _l2ProtocolUpgradeTx.txType = 254`. In the bootloader, i.e https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L594-L612\n\n```yul\n                    case 254 {\n                        // This is an upgrade transaction.\n                        // Protocol upgrade transactions are processed totally in the same manner as the normal L1->L2 transactions,\n                        // the only difference are:\n                        // - They must be the first one in the batch\n                        // - They have a different type to prevent tx hash collisions and preserve the expectation that the\n                        // L1->L2 transactions have priorityTxId inside them.\n                        if transactionIndex {\n                            assertionError(\"Protocol upgrade tx not first\")\n                        }\n\n                        // This is to be called in the event that the L1 Transaction is a protocol upgrade txn.\n                        // Since this is upgrade transactions, we are okay that the gasUsed by the transaction will\n                        // not cover this additional hash computation\n                        let canonicalL1TxHash := getCanonicalL1TxHash(txDataOffset)\n                        sendToL1Native(true, protocolUpgradeTxHashKey(), canonicalL1TxHash)\n                        //@audit\n                        processL1Tx(txDataOffset, resultPtr, transactionIndex, userProvidedPubdataPrice, false)\n                    }\n```\n\nNow during the current execution, [if for any reason this attempt fails, say the execution runs out of gas, the execution reverts](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1010-L1015), which is a direct fix to the **primary issue** from the previous audits, i.e https://github.com/code-423n4/2023-10-zksync-findings/issues/214#issuecomment-1795027489, but this is not enough fix to ensure that the synchronization is always in play.\n\nConsider [these issues](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=label%3Aduplicate-214+is%3Aclosed) that were duplicated to the aforementioned due to having a similar logic, most especially [1](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+No+way+of+preventing+the+upgrade+from+happening+even+if+it+has+a+critical+vulnerability+is%3Aclosed) & [2](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+if+a+batch+committed+with+system+contract+upgrades+is+reverted+via+revertBatches%28%29+to+prevent+execution+of+that+batch%2C+new+batches+intended+to+be+committed+with+no+system+contract+upgrades+will+be+committed+as+batches+with+system+contract+upgrades.+is%3Aclosed).\n\nIn short, for [1](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+No+way+of+preventing+the+upgrade+from+happening+even+if+it+has+a+critical+vulnerability+is%3Aclosed) the bug report is about, whenever an upgrade has a criticial vulnerabilty, current implementation does not provide a possibility of preventing the upgrade to go on, cause the upgrade must be carried out and cannot be changed even if batches get reverted.\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L472-L497\n\n```solidity\n    function revertBatches(uint256 _newLastBatch) external nonReentrant onlyValidatorOrStateTransitionManager {\n        _revertBatches(_newLastBatch);\n    }\n\n\n    /// @inheritdoc IExecutor\n    function revertBatchesSharedBridge(uint256, uint256 _newLastBatch) external nonReentrant onlyValidator {\n        _revertBatches(_newLastBatch);\n    }\n\n\n    function _revertBatches(uint256 _newLastBatch) internal {\n        require(s.totalBatchesCommitted > _newLastBatch, \"v1\"); // The last committed batch is less than new last batch\n        require(_newLastBatch >= s.totalBatchesExecuted, \"v2\"); // Already executed batches cannot be reverted\n\n\n        if (_newLastBatch < s.totalBatchesVerified) {\n            s.totalBatchesVerified = _newLastBatch;\n        }\n        s.totalBatchesCommitted = _newLastBatch;\n\n\n        // Reset the batch number of the executed system contracts upgrade transaction if the batch\n        // where the system contracts upgrade was committed is among the reverted batches.\n        if (s.l2SystemContractsUpgradeBatchNumber > _newLastBatch) {\n            delete s.l2SystemContractsUpgradeBatchNumber;\n        }\n\n\n        emit BlocksRevert(s.totalBatchesCommitted, s.totalBatchesVerified, s.totalBatchesExecuted);\n    }\n```\n\nEvidently, one can see that the suggested fix from the report has not been implemented, i.e while reverting the upgrade tx the `s.l2SystemContractsUpgradeTxHash` is not provided again to prevent the error inorder to increase the robustness of the system, that's to say for cases like this, the team would then not have time to prevent the upgrade from happening, fix the error, and make an upgrade tx again rather than leaving the vulnerable upgrade in the wild and not being implemented.\n\nBug flow should be seen from the [attached report](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+No+way+of+preventing+the+upgrade+from+happening+even+if+it+has+a+critical+vulnerability+is%3Aclosed), now the protocol's plan to solve this is by overriding `s.l2SystemContractsUpgradeTxHash` in order to cancel the buggy upgrade, but this wouldn't work, cause that upgrade [must be carried out in the next batch](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/docs/Smart%20contract%20Section/Handling%20L1%E2%86%92L2%20ops%20on%20zkSync.md?plain=1#L59-L65), so it gives zero time for protocol to code and then even deploy the new upgrader, now within this time frame, an attacker aware of the bugs in the implementation can exploit the system.\n\nFor case [2](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+if+a+batch+committed+with+system+contract+upgrades+is+reverted+via+revertBatches%28%29+to+prevent+execution+of+that+batch%2C+new+batches+intended+to+be+committed+with+no+system+contract+upgrades+will+be+committed+as+batches+with+system+contract+upgrades.+is%3Aclosed), the core of the issue is the same, i.e it lies in the protocol's failure to delete the transaction hash associated with a system contract upgrade when reverting a batch. This leads to a scenario where subsequent batches, even those not intended to include a system contract upgrade, are processed as if they do, due to the presence of the leftover upgrade transaction hash. This misprocessing causes unintended execution of system contract upgrades or reverts due to mismatched expectations about the batch's content.\n\nNow, the protocol's design allows for the reverting of batches to undo changes not yet executed. However as previously highlighted, it inadequately addresses the cleanup of system contract upgrade markers, specifically the transaction hash (`s.l2SystemContractsUpgradeTxHash`). While it resets the batch number indicating an upgrade (`s.l2SystemContractsUpgradeBatchNumber`), it neglects the corresponding transaction hash. This leads to confusion in the `_commitBatches()` function, take a look at this https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L215-L248\n\n```solidity\n    function _commitBatches(\n        StoredBatchInfo memory _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) internal {\n        // check that we have the right protocol version\n        // three comments:\n        // 1. A chain has to keep their protocol version up to date, as processing a block requires the latest or previous protocol version\n        // to solve this we will need to add the feature to create batches with only the protocol upgrade tx, without any other txs.\n        // 2. A chain might become out of sync if it launches while we are in the middle of a protocol upgrade. This would mean they cannot process their genesis upgrade\n        // as thier protocolversion would be outdated, and they also cannot process the protocol upgrade tx as they have a pending upgrade.\n        // 3. The protocol upgrade is increased in the BaseZkSyncUpgrade, in the executor only the systemContractsUpgradeTxHash is checked\n        require(\n            IStateTransitionManager(s.stateTransitionManager).protocolVersion() == s.protocolVersion,\n            \"Executor facet: wrong protocol version\"\n        );\n        // With the new changes for EIP-4844, namely the restriction on number of blobs per block, we only allow for a single batch to be committed at a time.\n        require(_newBatchesData.length == 1, \"e4\");\n        // Check that we commit batches after last committed batch\n        require(s.storedBatchHashes[s.totalBatchesCommitted] == _hashStoredBatchInfo(_lastCommittedBatchData), \"i\"); // incorrect previous batch data\n\n\n        bytes32 systemContractsUpgradeTxHash = s.l2SystemContractsUpgradeTxHash;\n        // Upgrades are rarely done so we optimize a case with no active system contracts upgrade.\n        //@audit\n        if (systemContractsUpgradeTxHash == bytes32(0) || s.l2SystemContractsUpgradeBatchNumber != 0) {\n            _commitBatchesWithoutSystemContractsUpgrade(_lastCommittedBatchData, _newBatchesData);\n        } else {\n            _commitBatchesWithSystemContractsUpgrade(\n                _lastCommittedBatchData,\n                _newBatchesData,\n                systemContractsUpgradeTxHash\n            );\n        }\n\n\n        s.totalBatchesCommitted = s.totalBatchesCommitted + _newBatchesData.length;\n    }\n```\n\nHere we see that the new logic for EIP-4844, requires only one batch to be committed at a time due to restriction of blobs per block, but this doesn't solve the root case, cause regardless, `if (systemContractsUpgradeTxHash == bytes32(0) || s.l2SystemContractsUpgradeBatchNumber != 0)` is `false`, which would be the case for our reverted batch, then the execution **always** routes the logic [to commiting with system contract upgrades](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L239-L245).\n\nTLDR: `revert()` will delete upgrade batch number but not the batch tx thus making reverts of batches with system upgrade **non functional** since the system tx hash may still be executed with new batches.\n\n### Impact\n\nMedium _(reason for submitting as QA attached in the  `### Additional Note` section )_, this is cause for the first case, we show how protocol have timelocked themself from being able to to stop the upgrade to a buggy implementation, that might even have critical bug implementations that an attacker could exploit while they code and attempt deploying a non buggy implementation, and for the second case, similar to the first we can see how if for whatever reason `l2SystemContractsUpgradeTxHash` is to be stopped from executing with a batch, it is not possible to do so, [due to `s.l2SystemContractsUpgradeTxHash` not being reverted in `revertBatches()`](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L490-L494)\n\n### Recommended Mitigation Steps\n\nModify the `revertBatches()` function to ensure comprehensive cleanup after a batch revert. This includes not only resetting the batch number associated with a system contract upgrade but also clearing the related transaction hash (`s.l2SystemContractsUpgradeTxHash`).\nWhile reverting batches both `l2SystemContractsUpgradeBatchNumber` `s.l2SystemContractsUpgradeTxHash` should be provided and deleted.\n\n### Additional Note\n\n> NB: This wasn't intended to be a QA submission, but these lines exist in the readMe:https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/README.md#L35-L38\n\n```markdown\n### Acknowledged issues from the previous audits\n\nAll unfixed issues from the previous audits are considered out of scope.\n- https://era.zksync.io/docs/reference/troubleshooting/audit-bug-bounty.html\n```\n\nNow, whereas navigating to the attached link from the `readMe` we can't see the audit where the idea of this bug has been coined attached, we still assume  that it is part of the _previous_ findings, now we just don't know if this was \"acknowledged\" or \"confirmed\" since we can see that the [team clearly \"confirmed\" the bug case](https://github.com/code-423n4/2023-10-zksync-findings/issues/214#issuecomment-1795027489) and applied a fix to it [in this commit](https://github.com/code-423n4/2024-03-zksync/compare/2023-10-zksync...main) provided for this audit, albeit an insufficient one... due to all these we've decided that this issue somewhat subjective and we'd leave it to the judge if they deem it fit to be be upgraded.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ZkSyncStateTransitionBase} from \"../state-transition/chain-deps/facets/ZkSyncStateTransitionBase.sol\";\nimport {IMailbox} from \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport {VerifierParams} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {IVerifier} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {TransactionValidator} from \"../state-transition/libraries/TransactionValidator.sol\";\nimport {MAX_NEW_FACTORY_DEPS, SYSTEM_UPGRADE_L2_TX_TYPE, MAX_ALLOWED_PROTOCOL_VERSION_DELTA} from \"../common/Config.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\n\n/// @notice The struct that represents the upgrade proposal.\n/// @param l2ProtocolUpgradeTx The system upgrade transaction.\n/// @param factoryDeps The list of factory deps for the l2ProtocolUpgradeTx.\n/// @param bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n/// @param defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n/// @param verifier The address of the new verifier. If zero, the verifier will not be updated.\n/// @param verifierParams The new verifier params. If all of its fields are 0, the params will not be updated.\n/// @param l1ContractsUpgradeCalldata Custom calldata for L1 contracts upgrade, it may be interpreted differently\n/// in each upgrade. Usually empty.\n/// @param postUpgradeCalldata Custom calldata for post upgrade hook, it may be interpreted differently in each\n/// upgrade. Usually empty.\n/// @param upgradeTimestamp The timestamp after which the upgrade can be executed.\n/// @param newProtocolVersion The new version number for the protocol after this upgrade. Should be greater than\n/// the previous protocol version.\nstruct ProposedUpgrade {\n    L2CanonicalTransaction l2ProtocolUpgradeTx;\n    bytes[] factoryDeps;\n    bytes32 bootloaderHash;\n    bytes32 defaultAccountHash;\n    address verifier;\n    VerifierParams verifierParams;\n    bytes l1ContractsUpgradeCalldata;\n    bytes postUpgradeCalldata;\n    uint256 upgradeTimestamp;\n    uint256 newProtocolVersion;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgrade is ZkSyncStateTransitionBase {\n    /// @notice Changes the protocol version\n    event NewProtocolVersion(uint256 indexed previousProtocolVersion, uint256 indexed newProtocolVersion);\n\n    /// @notice 小hanges to the bytecode that is used in L2 as a bootloader (start program)\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice 小hanges to the bytecode that is used in L2 as a default account\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Verifier address changed\n    event NewVerifier(address indexed oldVerifier, address indexed newVerifier);\n\n    /// @notice Verifier parameters changed\n    event NewVerifierParams(VerifierParams oldVerifierParams, VerifierParams newVerifierParams);\n\n    /// @notice Notifies about complete upgrade\n    event UpgradeComplete(uint256 indexed newProtocolVersion, bytes32 indexed l2UpgradeTxHash, ProposedUpgrade upgrade);\n\n    /// @notice The main function that will be provided by the upgrade proxy\n    /// @dev This is a virtual function and should be overridden by custom upgrade implementations.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    /// @return txHash The hash of the L2 system contract upgrade transaction.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual returns (bytes32 txHash) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n\n    /// @notice Change default account bytecode hash, that is used on L2\n    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n    function _setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) private {\n        if (_l2DefaultAccountBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousDefaultAccountBytecodeHash = s.l2DefaultAccountBytecodeHash;\n\n        // Change the default account bytecode hash\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n        emit NewL2DefaultAccountBytecodeHash(previousDefaultAccountBytecodeHash, _l2DefaultAccountBytecodeHash);\n    }\n\n    /// @notice Change bootloader bytecode hash, that is used on L2\n    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n    function _setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) private {\n        if (_l2BootloaderBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousBootloaderBytecodeHash = s.l2BootloaderBytecodeHash;\n\n        // Change the bootloader bytecode hash\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        emit NewL2BootloaderBytecodeHash(previousBootloaderBytecodeHash, _l2BootloaderBytecodeHash);\n    }\n\n    /// @notice Change the address of the verifier smart contract\n    /// @param _newVerifier Verifier smart contract address\n    function _setVerifier(IVerifier _newVerifier) private {\n        // An upgrade to the verifier must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (_newVerifier == IVerifier(address(0))) {\n            return;\n        }\n\n        IVerifier oldVerifier = s.verifier;\n        s.verifier = _newVerifier;\n        emit NewVerifier(address(oldVerifier), address(_newVerifier));\n    }\n\n    /// @notice Change the verifier parameters\n    /// @param _newVerifierParams New parameters for the verifier\n    function _setVerifierParams(VerifierParams calldata _newVerifierParams) private {\n        // An upgrade to the verifier params must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier params will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (\n            _newVerifierParams.recursionNodeLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionLeafLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionCircuitsSetVksHash == bytes32(0)\n        ) {\n            return;\n        }\n\n        VerifierParams memory oldVerifierParams = s.verifierParams;\n        s.verifierParams = _newVerifierParams;\n        emit NewVerifierParams(oldVerifierParams, _newVerifierParams);\n    }\n\n    /// @notice Updates the verifier and the verifier params\n    /// @param _newVerifier The address of the new verifier. If 0, the verifier will not be updated.\n    /// @param _verifierParams The new verifier params. If all of the fields are 0, the params will not be updated.\n    function _upgradeVerifier(address _newVerifier, VerifierParams calldata _verifierParams) internal {\n        _setVerifier(IVerifier(_newVerifier));\n        _setVerifierParams(_verifierParams);\n    }\n\n    /// @notice Updates the bootloader hash and the hash of the default account\n    /// @param _bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n    /// @param _defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n    function _setBaseSystemContracts(bytes32 _bootloaderHash, bytes32 _defaultAccountHash) internal {\n        _setL2BootloaderBytecodeHash(_bootloaderHash);\n        _setL2DefaultAccountBytecodeHash(_defaultAccountHash);\n    }\n\n    /// @notice Sets the hash of the L2 system contract upgrade transaction for the next batch to be committed\n    /// @dev If the transaction is noop (i.e. its type is 0) it does nothing and returns 0.\n    /// @param _l2ProtocolUpgradeTx The L2 system contract upgrade transaction.\n    /// @return System contracts upgrade transaction hash. Zero if no upgrade transaction is set.\n    function _setL2SystemContractUpgrade(\n        L2CanonicalTransaction calldata _l2ProtocolUpgradeTx,\n        bytes[] calldata _factoryDeps,\n        uint256 _newProtocolVersion\n    ) internal returns (bytes32) {\n        // If the type is 0, it is considered as noop and so will not be required to be executed.\n        if (_l2ProtocolUpgradeTx.txType == 0) {\n            return bytes32(0);\n        }\n\n        require(_l2ProtocolUpgradeTx.txType == SYSTEM_UPGRADE_L2_TX_TYPE, \"L2 system upgrade tx type is wrong\");\n\n        bytes memory encodedTransaction = abi.encode(_l2ProtocolUpgradeTx);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            _l2ProtocolUpgradeTx,\n            encodedTransaction,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        TransactionValidator.validateUpgradeTransaction(_l2ProtocolUpgradeTx);\n\n        // We want the hashes of l2 system upgrade transactions to be unique.\n        // This is why we require that the `nonce` field is unique to each upgrade.\n        require(\n            _l2ProtocolUpgradeTx.nonce == _newProtocolVersion,\n            \"The new protocol version should be included in the L2 system upgrade tx\"\n        );\n\n        _verifyFactoryDeps(_factoryDeps, _l2ProtocolUpgradeTx.factoryDeps);\n\n        bytes32 l2ProtocolUpgradeTxHash = keccak256(encodedTransaction);\n\n        s.l2SystemContractsUpgradeTxHash = l2ProtocolUpgradeTxHash;\n\n        return l2ProtocolUpgradeTxHash;\n    }\n\n    /// @notice Verifies that the factory deps correspond to the proper hashes\n    /// @param _factoryDeps The list of factory deps\n    /// @param _expectedHashes The list of expected bytecode hashes\n    function _verifyFactoryDeps(bytes[] calldata _factoryDeps, uint256[] calldata _expectedHashes) private pure {\n        require(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");\n\n        for (uint256 i = 0; i < _factoryDeps.length; ++i) {\n            require(\n                L2ContractHelper.hashL2Bytecode(_factoryDeps[i]) == bytes32(_expectedHashes[i]),\n                \"Wrong factory dep hash\"\n            );\n        }\n    }\n\n    /// @notice Changes the protocol version\n    /// @param _newProtocolVersion The new protocol version\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal virtual {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            _newProtocolVersion > previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        // Note it is important to keep this check, as otherwise hyperchains might skip upgrades by overwriting\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n\n    /// @notice Placeholder function for custom logic for upgrading L1 contract.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _upgradeL1Contract(bytes calldata _customCallDataForUpgrade) internal virtual {}\n\n    /// @notice placeholder function for custom logic for post-upgrade logic.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _postUpgrade(bytes calldata _customCallDataForUpgrade) internal virtual {}\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ZkSyncStateTransitionBase} from \"../state-transition/chain-deps/facets/ZkSyncStateTransitionBase.sol\";\nimport {IMailbox} from \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport {VerifierParams} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {IVerifier} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {TransactionValidator} from \"../state-transition/libraries/TransactionValidator.sol\";\nimport {MAX_NEW_FACTORY_DEPS, SYSTEM_UPGRADE_L2_TX_TYPE, MAX_ALLOWED_PROTOCOL_VERSION_DELTA} from \"../common/Config.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\n\n/// @notice The struct that represents the upgrade proposal.\n/// @param l2ProtocolUpgradeTx The system upgrade transaction.\n/// @param factoryDeps The list of factory deps for the l2ProtocolUpgradeTx.\n/// @param bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n/// @param defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n/// @param verifier The address of the new verifier. If zero, the verifier will not be updated.\n/// @param verifierParams The new verifier params. If all of its fields are 0, the params will not be updated.\n/// @param l1ContractsUpgradeCalldata Custom calldata for L1 contracts upgrade, it may be interpreted differently\n/// in each upgrade. Usually empty.\n/// @param postUpgradeCalldata Custom calldata for post upgrade hook, it may be interpreted differently in each\n/// upgrade. Usually empty.\n/// @param upgradeTimestamp The timestamp after which the upgrade can be executed.\n/// @param newProtocolVersion The new version number for the protocol after this upgrade. Should be greater than\n/// the previous protocol version.\nstruct ProposedUpgrade {\n    L2CanonicalTransaction l2ProtocolUpgradeTx;\n    bytes[] factoryDeps;\n    bytes32 bootloaderHash;\n    bytes32 defaultAccountHash;\n    address verifier;\n    VerifierParams verifierParams;\n    bytes l1ContractsUpgradeCalldata;\n    bytes postUpgradeCalldata;\n    uint256 upgradeTimestamp;\n    uint256 newProtocolVersion;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgrade is ZkSyncStateTransitionBase {\n    /// @notice Changes the protocol version\n    event NewProtocolVersion(uint256 indexed previousProtocolVersion, uint256 indexed newProtocolVersion);\n\n    /// @notice 小hanges to the bytecode that is used in L2 as a bootloader (start program)\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice 小hanges to the bytecode that is used in L2 as a default account\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Verifier address changed\n    event NewVerifier(address indexed oldVerifier, address indexed newVerifier);\n\n    /// @notice Verifier parameters changed\n    event NewVerifierParams(VerifierParams oldVerifierParams, VerifierParams newVerifierParams);\n\n    /// @notice Notifies about complete upgrade\n    event UpgradeComplete(uint256 indexed newProtocolVersion, bytes32 indexed l2UpgradeTxHash, ProposedUpgrade upgrade);\n\n    /// @notice The main function that will be provided by the upgrade proxy\n    /// @dev This is a virtual function and should be overridden by custom upgrade implementations.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    /// @return txHash The hash of the L2 system contract upgrade transaction.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual returns (bytes32 txHash) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n\n    /// @notice Change default account bytecode hash, that is used on L2\n    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n    function _setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) private {\n        if (_l2DefaultAccountBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousDefaultAccountBytecodeHash = s.l2DefaultAccountBytecodeHash;\n\n        // Change the default account bytecode hash\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n        emit NewL2DefaultAccountBytecodeHash(previousDefaultAccountBytecodeHash, _l2DefaultAccountBytecodeHash);\n    }\n\n    /// @notice Change bootloader bytecode hash, that is used on L2\n    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n    function _setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) private {\n        if (_l2BootloaderBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousBootloaderBytecodeHash = s.l2BootloaderBytecodeHash;\n\n        // Change the bootloader bytecode hash\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        emit NewL2BootloaderBytecodeHash(previousBootloaderBytecodeHash, _l2BootloaderBytecodeHash);\n    }\n\n    /// @notice Change the address of the verifier smart contract\n    /// @param _newVerifier Verifier smart contract address\n    function _setVerifier(IVerifier _newVerifier) private {\n        // An upgrade to the verifier must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (_newVerifier == IVerifier(address(0))) {\n            return;\n        }\n\n        IVerifier oldVerifier = s.verifier;\n        s.verifier = _newVerifier;\n        emit NewVerifier(address(oldVerifier), address(_newVerifier));\n    }\n\n    /// @notice Change the verifier parameters\n    /// @param _newVerifierParams New parameters for the verifier\n    function _setVerifierParams(VerifierParams calldata _newVerifierParams) private {\n        // An upgrade to the verifier params must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier params will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (\n            _newVerifierParams.recursionNodeLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionLeafLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionCircuitsSetVksHash == bytes32(0)\n        ) {\n            return;\n        }\n\n        VerifierParams memory oldVerifierParams = s.verifierParams;\n        s.verifierParams = _newVerifierParams;\n        emit NewVerifierParams(oldVerifierParams, _newVerifierParams);\n    }\n\n    /// @notice Updates the verifier and the verifier params\n    /// @param _newVerifier The address of the new verifier. If 0, the verifier will not be updated.\n    /// @param _verifierParams The new verifier params. If all of the fields are 0, the params will not be updated.\n    function _upgradeVerifier(address _newVerifier, VerifierParams calldata _verifierParams) internal {\n        _setVerifier(IVerifier(_newVerifier));\n        _setVerifierParams(_verifierParams);\n    }\n\n    /// @notice Updates the bootloader hash and the hash of the default account\n    /// @param _bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n    /// @param _defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n    function _setBaseSystemContracts(bytes32 _bootloaderHash, bytes32 _defaultAccountHash) internal {\n        _setL2BootloaderBytecodeHash(_bootloaderHash);\n        _setL2DefaultAccountBytecodeHash(_defaultAccountHash);\n    }\n\n    /// @notice Sets the hash of the L2 system contract upgrade transaction for the next batch to be committed\n    /// @dev If the transaction is noop (i.e. its type is 0) it does nothing and returns 0.\n    /// @param _l2ProtocolUpgradeTx The L2 system contract upgrade transaction.\n    /// @return System contracts upgrade transaction hash. Zero if no upgrade transaction is set.\n    function _setL2SystemContractUpgrade(\n        L2CanonicalTransaction calldata _l2ProtocolUpgradeTx,\n        bytes[] calldata _factoryDeps,\n        uint256 _newProtocolVersion\n    ) internal returns (bytes32) {\n        // If the type is 0, it is considered as noop and so will not be required to be executed.\n        if (_l2ProtocolUpgradeTx.txType == 0) {\n            return bytes32(0);\n        }\n\n        require(_l2ProtocolUpgradeTx.txType == SYSTEM_UPGRADE_L2_TX_TYPE, \"L2 system upgrade tx type is wrong\");\n\n        bytes memory encodedTransaction = abi.encode(_l2ProtocolUpgradeTx);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            _l2ProtocolUpgradeTx,\n            encodedTransaction,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        TransactionValidator.validateUpgradeTransaction(_l2ProtocolUpgradeTx);\n\n        // We want the hashes of l2 system upgrade transactions to be unique.\n        // This is why we require that the `nonce` field is unique to each upgrade.\n        require(\n            _l2ProtocolUpgradeTx.nonce == _newProtocolVersion,\n            \"The new protocol version should be included in the L2 system upgrade tx\"\n        );\n\n        _verifyFactoryDeps(_factoryDeps, _l2ProtocolUpgradeTx.factoryDeps);\n\n        bytes32 l2ProtocolUpgradeTxHash = keccak256(encodedTransaction);\n\n        s.l2SystemContractsUpgradeTxHash = l2ProtocolUpgradeTxHash;\n\n        return l2ProtocolUpgradeTxHash;\n    }\n\n    /// @notice Verifies that the factory deps correspond to the proper hashes\n    /// @param _factoryDeps The list of factory deps\n    /// @param _expectedHashes The list of expected bytecode hashes\n    function _verifyFactoryDeps(bytes[] calldata _factoryDeps, uint256[] calldata _expectedHashes) private pure {\n        require(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");\n\n        for (uint256 i = 0; i < _factoryDeps.length; ++i) {\n            require(\n                L2ContractHelper.hashL2Bytecode(_factoryDeps[i]) == bytes32(_expectedHashes[i]),\n                \"Wrong factory dep hash\"\n            );\n        }\n    }\n\n    /// @notice Changes the protocol version\n    /// @param _newProtocolVersion The new protocol version\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal virtual {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            _newProtocolVersion > previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        // Note it is important to keep this check, as otherwise hyperchains might skip upgrades by overwriting\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n\n    /// @notice Placeholder function for custom logic for upgrading L1 contract.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _upgradeL1Contract(bytes calldata _customCallDataForUpgrade) internal virtual {}\n\n    /// @notice placeholder function for custom logic for post-upgrade logic.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _postUpgrade(bytes calldata _customCallDataForUpgrade) internal virtual {}\n}"
    },
    {
      "filename": "code/system-contracts/bootloader/bootloader.yul",
      "content": "object \"Bootloader\" {\n    code {\n    }\n    object \"Bootloader_deployed\" {\n        code {\n            {{CODE_START_PLACEHOLDER}}\n\n            ////////////////////////////////////////////////////////////////////////////\n            //                      Function Declarations\n            ////////////////////////////////////////////////////////////////////////////\n\n            // While we definitely cannot control the pubdata price on L1,\n            // we need to check the operator does not provide any absurd numbers there\n            function MAX_ALLOWED_FAIR_PUBDATA_PRICE() -> ret {\n                // 1M gwei\n                ret := 1000000000000000\n            }\n\n            function MAX_ALLOWED_FAIR_L2_GAS_PRICE() -> ret {\n                // 10k gwei\n                ret := 10000000000000\n            }\n\n            /// @dev This method ensures that the prices provided by the operator\n            /// are not absurdly high\n            function validateOperatorProvidedPrices(fairL2GasPrice, pubdataPrice) {\n                // The limit is the same for pubdata price and L1 gas price\n                if gt(pubdataPrice, MAX_ALLOWED_FAIR_PUBDATA_PRICE()) {\n                    assertionError(\"Fair pubdata price too high\")\n                }\n\n                if gt(fairL2GasPrice, MAX_ALLOWED_FAIR_L2_GAS_PRICE()) {\n                    assertionError(\"L2 fair gas price too high\")\n                }\n            }\n\n            /// @dev The overhead for a transaction slot in L2 gas. \n            /// It is roughly equal to 80kk/MAX_TRANSACTIONS_IN_BATCH, i.e. how many gas would an L1->L2 transaction\n            /// need to pay to compensate for the batch being closed.\n            /// @dev It is expected of the operator to set the \"fair L2 gas price\" appropriately to ensure that it is \n            /// compensated enough in case the batch might be prematurely sealed because of the transaction slots being filled up.\n            function TX_SLOT_OVERHEAD_GAS() -> ret {\n                ret := 10000\n            }\n\n            /// @dev The overhead for each byte of the bootloader memory that the encoding of the transaction.\n            /// It is roughly equal to 80kk/BOOTLOADER_MEMORY_FOR_TXS, i.e. how many gas would an L1->L2 transaction\n            /// need to pay to compensate for the batch being closed.\n            /// @dev It is expected of the operator to set the \"fair L2 gas price\" appropriately to ensure that it is\n            /// compensated enough in case the batch might be prematurely sealed because of the memory being filled up.\n            function MEMORY_OVERHEAD_GAS() -> ret {\n                ret := 10\n            }\n\n            /// @dev Returns the base fee and gas per pubdata based on the fair pubdata price and L2 gas price provided by the operator\n            /// @param pubdataPrice The price of a single byte of pubdata in Wei\n            /// @param fairL2GasPrice The price of an L2 gas in Wei\n            /// @return baseFee and gasPerPubdata The base fee and the gas per pubdata to be used by L2 transactions in this batch.\n            function getFeeParams(\n                fairPubdataPrice,\n                fairL2GasPrice,\n            ) -> baseFee, gasPerPubdata {\n                baseFee := max(\n                    fairL2GasPrice,\n                    ceilDiv(fairPubdataPrice, MAX_L2_GAS_PER_PUBDATA())\n                )\n\n                gasPerPubdata := gasPerPubdataFromBaseFee(baseFee, fairPubdataPrice)\n            }\n\n            /// @dev Calculates the gas per pubdata based on the pubdata price provided by the operator\n            /// as well the the fixed baseFee.\n            function gasPerPubdataFromBaseFee(baseFee, pubdataPrice) -> ret {\n                ret := ceilDiv(pubdataPrice, baseFee)\n            }\n\n            /// @dev It should be always possible to submit a transaction \n            /// that consumes such amount of public data.\n            function GUARANTEED_PUBDATA_PER_TX() -> ret {\n                ret := {{GUARANTEED_PUBDATA_BYTES}}\n            }\n\n            /// @dev The maximal allowed gasPerPubdata, we want it multiplied by the u32::MAX \n            /// (i.e. the maximal possible value of the pubdata counter) to be a safe JS integer with a good enough margin.\n            function MAX_L2_GAS_PER_PUBDATA() -> ret {"
    }
  ]
}