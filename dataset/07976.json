{
  "Title": "[05]  `requestId` is always zero",
  "Content": "Chainlink suggests to have a unique `requestId` for every separate randomness request. By always using the same value, it's not possible to tell whether Chainlink returned data for a valid request, or if there was some Chainlink bug that triggered a callback for a request that was never made\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /src/utils/rand/ChainlinkV1RandProvider.sol\n\n62       function requestRandomBytes() external returns (bytes32 requestId) {\n63           // The caller must be the ArtGobblers contract, revert otherwise.\n64           if (msg.sender != address(artGobblers)) revert NotGobblers();\n65   \n66:          emit RandomBytesRequested(requestId);\n\n```\nhttps://github.com/code-423n4/2022-09-artgobblers/blob/d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe/src/utils/rand/ChainlinkV1RandProvider.sol#L62-L66\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-09-artgobblers",
  "Code": [
    {
      "filename": "src/utils/rand/ChainlinkV1RandProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {VRFConsumerBase} from \"chainlink/v0.8/VRFConsumerBase.sol\";\n\nimport {ArtGobblers} from \"../../ArtGobblers.sol\";\n\nimport {RandProvider} from \"./RandProvider.sol\";\n\n/// @title Chainlink V1 Randomness Provider.\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice RandProvider wrapper around Chainlink VRF v1.\ncontract ChainlinkV1RandProvider is RandProvider, VRFConsumerBase {\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Art Gobblers contract.\n    ArtGobblers public immutable artGobblers;\n\n    /*//////////////////////////////////////////////////////////////\n                            VRF CONFIGURATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Public key to generate randomness against.\n    bytes32 internal immutable chainlinkKeyHash;\n\n    /// @dev Fee required to fulfill a VRF request.\n    uint256 internal immutable chainlinkFee;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error NotGobblers();\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets relevant addresses and VRF parameters.\n    /// @param _artGobblers Address of the ArtGobblers contract.\n    /// @param _vrfCoordinator Address of the VRF coordinator.\n    /// @param _linkToken Address of the LINK token contract.\n    /// @param _chainlinkKeyHash Public key to generate randomness against.\n    /// @param _chainlinkFee Fee required to fulfill a VRF request.\n    constructor(\n        ArtGobblers _artGobblers,\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _chainlinkKeyHash,\n        uint256 _chainlinkFee\n    ) VRFConsumerBase(_vrfCoordinator, _linkToken) {\n        artGobblers = _artGobblers;\n\n        chainlinkKeyHash = _chainlinkKeyHash;\n        chainlinkFee = _chainlinkFee;\n    }\n\n    /// @notice Request random bytes from Chainlink VRF. Can only by called by the ArtGobblers contract.\n    function requestRandomBytes() external returns (bytes32 requestId) {\n        // The caller must be the ArtGobblers contract, revert otherwise.\n        if (msg.sender != address(artGobblers)) revert NotGobblers();\n\n        emit RandomBytesRequested(requestId);\n\n        // Will revert if we don't have enough LINK to afford the request.\n        return requestRandomness(chainlinkKeyHash, chainlinkFee);\n    }\n\n    /// @dev Handles VRF response by calling back into the ArtGobblers contract.\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        emit RandomBytesReturned(requestId, randomness);\n\n        artGobblers.acceptRandomSeed(requestId, randomness);\n    }\n}"
    }
  ]
}