{
  "Title": "[H-08] DOS by Frontrunning NoteERC20 `initialize()` Function",
  "Content": "_Submitted by leastwood_\n\nThe `scripts/` folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilize the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic.\n\nWhen users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. `NoteERC20.sol` and `Router.sol` both implement an `initialize()` function which aims to replace the role of the `constructor()` when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious front-running.\n\nHowever, `scripts/deployment.py` does not follow this pattern when deploying `NoteERC20.sol`'s proxy contract. As a result, a malicious attacker could monitor the Ethereum blockchain for bytecode that matches the `NoteERC20` contract and front-run the `initialize()` transaction to gain ownership of the contract. This can be repeated as a Denial Of Service (DOS) type of attack, effectively preventing Notional's contract deployment, leading to unrecoverable gas expenses. See [`deployment.py` L44-L60](https://github.com/code-423n4/2021-08-notional/blob/main/scripts/deployment.py#L44-L60), and [`deploy_governance.py` L71-L105](https://github.com/code-423n4/2021-08-notional/blob/main/scripts/mainnet/deploy_governance.py#L71-L105).\n\nAs the `GovernanceAlpha.sol` and `NoteERC20.sol` are co-dependent contracts in terms of deployment, it won't be possible to deploy the governance contract before deploying and initializing the token contract. Therefore, it would be worthwhile to ensure the `NoteERC20.sol` proxy contract is deployed and initialized in the same transaction, or ensure the `initialize()` function is callable only by the deployer of the `NoteERC20.sol` contract. This could be set in the proxy contracts `constructor()`.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/7)**\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-08-notional",
  "Code": [
    {
      "filename": "scripts/deployment.py",
      "content": "import json\nfrom copy import copy\n\nfrom brownie import (\n    AccountAction,\n    BatchAction,\n    ERC1155Action,\n    FreeCollateralExternal,\n    GovernanceAction,\n    GovernorAlpha,\n    InitializeMarketsAction,\n    LiquidateCurrencyAction,\n    LiquidatefCashAction,\n    MockAggregator,\n    MockERC20,\n    NoteERC20,\n    PauseRouter,\n    Router,\n    SettleAssetsExternal,\n    TradingAction,\n    Views,\n    accounts,\n    cTokenAggregator,\n    network,\n    nProxy,\n    nProxyAdmin,\n    nTokenAction,\n    nTokenERC20Proxy,\n    nTokenMintAction,\n    nTokenRedeemAction,\n)\nfrom brownie.convert.datatypes import HexString\nfrom brownie.network import web3\nfrom brownie.network.contract import Contract\nfrom brownie.network.state import Chain\nfrom brownie.project import ContractsVProject\nfrom scripts.config import CompoundConfig, CurrencyDefaults, GovernanceConfig, TokenConfig\n\nchain = Chain()\n\nTokenType = {\"UnderlyingToken\": 0, \"cToken\": 1, \"cETH\": 2, \"Ether\": 3, \"NonMintable\": 4}\n\n\ndef deployNoteERC20(deployer):\n    # These two lines ensure that the note token is deployed to the correct address\n    # every time.\n    if network.show_active() == \"sandbox\":\n        deployer = accounts.load(\"DEVELOPMENT_DEPLOYER\")\n        accounts[0].transfer(deployer, 100e18)\n    elif network.show_active() == \"development\":\n        deployer = \"0x8B64fA5Fd129df9c755eB82dB1e16D6D0Bdf5Bc3\"\n\n    # Deploy governance contracts\n    noteERC20Implementation = NoteERC20.deploy({\"from\": deployer})\n    # This is a proxied ERC20\n    noteERC20Proxy = nProxy.deploy(noteERC20Implementation.address, bytes(), {\"from\": deployer})\n\n    noteERC20 = Contract.from_abi(\"NoteERC20\", noteERC20Proxy.address, abi=NoteERC20.abi)\n\n    return (noteERC20Proxy, noteERC20)\n\n\ndef deployGovernance(deployer, noteERC20, guardian, governorConfig):\n    return GovernorAlpha.deploy(\n        governorConfig[\"quorumVotes\"],\n        governorConfig[\"proposalThreshold\"],\n        governorConfig[\"votingDelayBlocks\"],\n        governorConfig[\"votingPeriodBlocks\"],\n        noteERC20.address,\n        guardian,\n        governorConfig[\"minDelay\"],\n        {\"from\": deployer},\n    )\n\n\ndef deployNotionalContracts(deployer, cETHAddress):\n    contracts = {}\n    # Deploy Libraries\n    contracts[\"SettleAssetsExternal\"] = SettleAssetsExternal.deploy({\"from\": deployer})\n    contracts[\"FreeCollateralExternal\"] = FreeCollateralExternal.deploy({\"from\": deployer})\n    contracts[\"TradingAction\"] = TradingAction.deploy({\"from\": deployer})\n    contracts[\"nTokenMintAction\"] = nTokenMintAction.deploy({\"from\": deployer})\n\n    # Deploy logic contracts\n    contracts[\"Governance\"] = GovernanceAction.deploy({\"from\": deployer})\n    contracts[\"Views\"] = Views.deploy({\"from\": deployer})\n    contracts[\"InitializeMarketsAction\"] = InitializeMarketsAction.deploy({\"from\": deployer})\n    contracts[\"nTokenRedeemAction\"] = nTokenRedeemAction.deploy({\"from\": deployer})\n    contracts[\"nTokenAction\"] = nTokenAction.deploy({\"from\": deployer})\n    contracts[\"BatchAction\"] = BatchAction.deploy({\"from\": deployer})\n    contracts[\"AccountAction\"] = AccountAction.deploy({\"from\": deployer})\n    contracts[\"ERC1155Action\"] = ERC1155Action.deploy({\"from\": deployer})\n    contracts[\"LiquidateCurrencyAction\"] = LiquidateCurrencyAction.deploy({\"from\": deployer})\n    contracts[\"LiquidatefCashAction\"] = LiquidatefCashAction.deploy({\"from\": deployer})\n\n    # Deploy Pause Router\n    pauseRouter = PauseRouter.deploy(contracts[\"Views\"].address, {\"from\": deployer})\n\n    # Deploy router\n    router = Router.deploy(\n        contracts[\"Governance\"].address,\n        contracts[\"Views\"].address,\n        contracts[\"InitializeMarketsAction\"].address,\n        contracts[\"nTokenAction\"].address,\n        contracts[\"nTokenRedeemAction\"].address,\n        contracts[\"BatchAction\"].address,\n        contracts[\"AccountAction\"].address,\n        contracts[\"ERC1155Action\"].address,\n        contracts[\"LiquidateCurrencyAction\"].address,\n        contracts[\"LiquidatefCashAction\"].address,\n        cETHAddress,\n        {\"from\": deployer},\n    )\n\n    return (router, pauseRouter, contracts)\n\n\ndef deployNotional(deployer, cETHAddress, guardianAddress):\n    (router, pauseRouter, contracts) = deployNotionalContracts(deployer, cETHAddress)\n\n    initializeData = web3.eth.contract(abi=Router.abi).encodeABI(\n        fn_name=\"initialize\", args=[deployer.address, pauseRouter.address, guardianAddress]\n    )\n\n    proxy = nProxy.deploy(\n        router.address, initializeData, {\"from\": deployer}  # Deployer is set to owner\n    )\n\n    notionalInterfaceABI = ContractsVProject._build.get(\"NotionalProxy\")[\"abi\"]\n    notional = Contract.from_abi(\n        \"Notional\", proxy.address, abi=notionalInterfaceABI, owner=deployer\n    )\n\n    return (pauseRouter, router, proxy, notional, contracts)\n\n\ndef deployArtifact(path, constructorArgs, deployer, name):\n    with open(path, \"r\") as a:\n        artifact = json.load(a)\n\n    createdContract = network.web3.eth.contract(abi=artifact[\"abi\"], bytecode=artifact[\"bytecode\"])\n    txn = createdContract.constructor(*constructorArgs).buildTransaction(\n        {\"from\": deployer.address, \"nonce\": deployer.nonce}\n    )\n    # This does a manual deployment of a contract\n    tx_receipt = deployer.transfer(data=txn[\"data\"])\n\n    return Contract.from_abi(name, tx_receipt.contract_address, abi=artifact[\"abi\"], owner=deployer)\n\n\nclass TestEnvironment:\n    def __init__(self, deployer, withGovernance=False, multisig=None):\n        self.deployer = deployer\n        # Proxy Admin is just used for testing V1 contracts\n        self.proxyAdmin = nProxyAdmin.deploy({\"from\": self.deployer})\n\n        self.compPriceOracle = deployArtifact(\n            \"scripts/compound_artifacts/nPriceOracle.json\", [], self.deployer, \"nPriceOracle\"\n        )\n        self.comptroller = deployArtifact(\n            \"scripts/compound_artifacts/nComptroller.json\", [], self.deployer, \"nComptroller\"\n        )\n        self.comptroller._setMaxAssets(20)\n        self.comptroller._setPriceOracle(self.compPriceOracle.address)\n        self.currencyId = {}\n        self.token = {}\n        self.ethOracle = {}\n        self.cToken = {}\n        self.cTokenAggregator = {}\n        self.nToken = {}\n        self.router = {}\n        self.multisig = multisig\n\n        if withGovernance:\n            self._deployGovernance()\n        else:\n            self._deployNoteERC20()\n\n        # First deploy tokens to ensure they are available\n        self._deployMockCurrency(\"ETH\")\n        for symbol in TokenConfig.keys():\n            self._deployMockCurrency(symbol)\n\n        self._deployNotional()\n\n        if withGovernance:\n            self.notional.transferOwnership(self.governor.address)\n            self.proxyAdmin.transferOwnership(self.governor.address)\n            self.noteERC20.initialize(\n                [self.governor.address, self.multisig.address, self.notional.address],\n                [\n                    GovernanceConfig[\"initialBalances\"][\"DAO\"],\n                    GovernanceConfig[\"initialBalances\"][\"MULTISIG\"],\n                    GovernanceConfig[\"initialBalances\"][\"NOTIONAL\"],\n                ],\n                self.deployer.address,\n                {\"from\": self.deployer},\n            )\n            self.noteERC20.activateNotional(self.notional.address, {\"from\": self.deployer})\n            self.noteERC20.transferOwnership(self.governor.address, {\"from\": self.deployer})\n        else:\n            self.noteERC20.initialize(\n                [self.deployer, self.notional.address],\n                [99_000_000e8, GovernanceConfig[\"initialBalances\"][\"NOTIONAL\"]],\n                self.deployer.address,\n                {\"from\": self.deployer},\n            )\n            self.noteERC20.activateNotional(self.notional.address, {\"from\": self.deployer})\n\n        self.startTime = chain.time()\n\n    def _deployNoteERC20(self):\n        (self.noteERC20Proxy, self.noteERC20) = deployNoteERC20(self.deployer)\n\n    def _deployGovernance(self):\n        self._deployNoteERC20()\n\n        # This is not a proxy but can be upgraded by deploying a new contract and changing ownership\n        self.governor = deployGovernance(\n            self.deployer, self.noteERC20, self.multisig, GovernanceConfig[\"governorConfig\"]\n        )\n\n    def _deployCToken(self, symbol, underlyingToken, rate):\n        cToken = None\n        config = CompoundConfig[symbol]\n        # Deploy interest rate model\n        interestRateModel = None\n        if config[\"interestRateModel\"][\"name\"] == \"whitepaper\":\n            interestRateModel = deployArtifact(\n                \"scripts/compound_artifacts/nWhitePaperInterestRateModel.json\",\n                [\n                    config[\"interestRateModel\"][\"baseRate\"],\n                    config[\"interestRateModel\"][\"multiplier\"],\n                ],\n                self.deployer,\n                \"InterestRateModel\",\n            )\n        elif config[\"interestRateModel\"][\"name\"] == \"jump\":\n            interestRateModel = deployArtifact(\n                \"scripts/compound_artifacts/nJumpRateModel.json\",\n                [\n                    config[\"interestRateModel\"][\"baseRate\"],\n                    config[\"interestRateModel\"][\"multiplier\"],\n                    config[\"interestRateModel\"][\"jumpMultiplierPerYear\"],\n                    config[\"interestRateModel\"][\"kink\"],\n                ],\n                self.deployer,\n                \"JumpRateModel\",\n            )\n\n        if symbol == \"ETH\":\n            cToken = deployArtifact(\n                \"scripts/compound_artifacts/nCEther.json\",\n                [\n                    self.comptroller.address,\n                    interestRateModel.address,\n                    config[\"initialExchangeRate\"],\n                    \"Compound Ether\",\n                    \"cETH\",\n                    8,\n                    self.deployer.address,\n                ],\n                self.deployer,\n                \"cETH\",\n            )\n        else:\n            cToken = deployArtifact(\n                \"scripts/compound_artifacts/nCErc20.json\",\n                [\n                    underlyingToken.address,\n                    self.comptroller.address,\n                    interestRateModel.address,\n                    config[\"initialExchangeRate\"],\n                    \"Compound \" + symbol,  # This is not exactly correct but whatever\n                    \"c\" + symbol,\n                    8,\n                    self.deployer.address,\n                ],\n                self.deployer,\n                \"cErc20\",\n            )\n\n        self.comptroller._supportMarket(cToken.address, {\"from\": self.deployer})\n        self.comptroller._setCollateralFactor(\n            cToken.address, 750000000000000000, {\"from\": self.deployer}\n        )\n        if symbol != \"ETH\":\n            self.compPriceOracle.setUnderlyingPrice(cToken.address, rate)\n\n        self.cToken[symbol] = cToken\n        # TODO: can we simplify the deployment of cTokenAggregator to one overall?\n        self.cTokenAggregator[symbol] = cTokenAggregator.deploy(\n            cToken.address, {\"from\": self.deployer}\n        )\n\n    def _deployMockCurrency(self, symbol):\n        if symbol == \"ETH\":\n            # This is required to initialize ETH\n            self._deployCToken(\"ETH\", None, None)\n        else:\n            config = TokenConfig[symbol]\n            token = MockERC20.deploy(\n                config[\"name\"], symbol, config[\"decimals\"], config[\"fee\"], {\"from\": self.deployer}\n            )\n            self.ethOracle[symbol] = MockAggregator.deploy(18, {\"from\": self.deployer})\n            self.ethOracle[symbol].setAnswer(config[\"rate\"])\n\n            if symbol != \"NOMINT\":\n                self._deployCToken(symbol, token, config[\"rate\"])\n            self.token[symbol] = token\n\n    def _deployNotional(self):\n        (self.pauseRouter, self.router, self.proxy, self.notional, _) = deployNotional(\n            self.deployer, self.cToken[\"ETH\"].address, accounts[8].address\n        )\n        self.enableCurrency(\"ETH\", CurrencyDefaults)\n\n    def enableCurrency(self, symbol, config):\n        currencyId = 1\n        if symbol == \"NOMINT\":\n            zeroAddress = HexString(0, \"bytes20\")\n            txn = self.notional.listCurrency(\n                (self.token[symbol].address, symbol == \"USDT\", TokenType[\"NonMintable\"]),\n                (zeroAddress, False, 0),\n                self.ethOracle[symbol].address,\n                False,\n                config[\"buffer\"],\n                config[\"haircut\"],\n                config[\"liquidationDiscount\"],\n            )\n            currencyId = txn.events[\"ListCurrency\"][\"newCurrencyId\"]\n\n        elif symbol != \"ETH\":\n            txn = self.notional.listCurrency(\n                (self.cToken[symbol].address, symbol == \"USDT\", TokenType[\"cToken\"]),\n                (self.token[symbol].address, symbol == \"USDT\", TokenType[\"UnderlyingToken\"]),\n                self.ethOracle[symbol].address,\n                False,\n                config[\"buffer\"],\n                config[\"haircut\"],\n                config[\"liquidationDiscount\"],\n            )\n            currencyId = txn.events[\"ListCurrency\"][\"newCurrencyId\"]\n\n        if symbol == \"NOMINT\":\n            assetRateAddress = HexString(0, \"bytes20\")\n        else:\n            assetRateAddress = self.cTokenAggregator[symbol].address\n\n        self.notional.enableCashGroup(\n            currencyId,\n            assetRateAddress,\n            (\n                config[\"maxMarketIndex\"],\n                config[\"rateOracleTimeWindow\"],\n                config[\"totalFee\"],\n                config[\"reserveFeeShare\"],\n                config[\"debtBuffer\"],\n                config[\"fCashHaircut\"],\n                config[\"settlementPenalty\"],\n                config[\"liquidationfCashDiscount\"],\n                config[\"liquidationDebtBuffer\"],\n                config[\"tokenHaircut\"][0 : config[\"maxMarketIndex\"]],\n                config[\"rateScalar\"][0 : config[\"maxMarketIndex\"]],\n            ),\n            self.token[symbol].name() if symbol != \"ETH\" else \"Ether\",\n            symbol,\n        )\n\n        self.currencyId[symbol] = currencyId\n        nTokenAddress = self.notional.nTokenAddress(currencyId)\n        self.nToken[currencyId] = Contract.from_abi(\n            \"nToken\", nTokenAddress, abi=nTokenERC20Proxy.abi, owner=self.deployer\n        )\n\n\ndef main():\n    env = TestEnvironment(accounts[0])\n    for symbol in TokenConfig.keys():\n        config = copy(CurrencyDefaults)\n        if symbol == \"USDT\":\n            config[\"haircut\"] = 0\n\n        env.enableCurrency(symbol, config)\n\n    return env"
    }
  ]
}