{
  "Title": "`BaseConicPool._setWeightToZero()` does not update `Controller.lastWeightUpdate` leading to excessive minting of rewards",
  "Content": "##### Description\n\nRewards for pool rebalancing when calling `BaseConicPool.depositFor()` grow proportionally to `Controller.lastWeightUpdate`:\n```\nfunction computeRebalancingRewards\n    ...\n    uint256 lastWeightUpdate = \n        controller.lastWeightUpdate(conicPool);\n    uint256 elapsedSinceUpdate = \n        uint256(block.timestamp) - lastWeightUpdate;\n    return\n        (elapsedSinceUpdate * \n            cncRebalancingRewardPerDollarPerSecond).mulDown(\n            deviationDelta.convertScale(decimals, 18)\n        );\n```\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/CNCMintingRebalancingRewardsHandler.sol#L128\n\nThe value of `lastWeightUpdate` is updated when calling `Controller.updateWeights()`. However, in case of a depeg of one of the curve pools, the weight of the respective curve pool is directly zeroed through the `BaseConicPool._setWeightToZero()` call inside `handleDepeggedCurvePool()`, which also triggers the rebalancing reward distribution process:\n```\nfunction handleDepeggedCurvePool(address curvePool_) external override\n    ...\n    _setWeightToZero(curvePool_);\n    rebalancingRewardActive = true;\n```\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/BaseConicPool.sol#L575-L577\n\nThe `_setWeightToZero()` function doesn't update `Controller.lastWeightUpdate`, so the `elapsedSinceUpdate` multiplier when calculating rewards isn't reset.\n\nThe `_setWeightToZero()` function zeros out the weight of one curve pool and proportionally increases the weights of all other pools, creating an immediate imbalance between the target and actual volume of funds in each of the pools. However, there's no actual relative imbalance between the pools since all weights have increased proportionally.\n```\nfunction _setWeightToZero(address zeroedPool) internal\n    ...\n    for (uint256 i; i < curvePoolLength_; i++)\n        ...\n        uint256 newWeight_ = pool_ == zeroedPool ? 0 : \n            weights.get(pool_).mulDown(scaleUp_);\n        weights.set(pool_, newWeight_);\n```\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/BaseConicPool.sol#L589-L590\n\nNevertheless, right after this event, large rewards will be minted for any new depositors because the `elapsedSinceUpdate` multiplier remains large, and the `deviationDelta` value is calculated in absolute, not relative numbers.\n\n##### Recommendation\n\nWe recommended that you update the `Controller.lastWeightUpdate` when calling `BaseConicPool._setWeightToZero()`.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/tokenomics/CNCMintingRebalancingRewardsHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/tokenomics/ICNCMintingRebalancingRewardsHandler.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\nimport \"../../interfaces/pools/IConicPool.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\ncontract CNCMintingRebalancingRewardsHandler is\n    ICNCMintingRebalancingRewardsHandler,\n    Ownable,\n    Initializable\n{\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev the maximum amount of CNC that can be minted for rebalancing rewards\n    uint256 internal constant _MAX_REBALANCING_REWARDS = 1_900_000e18; // 19% of total supply\n\n    /// @dev gives out 5 dollars per 1 hour (assuming 1 CNC = 6 USD) for every 10,000 USD in TVL that needs to be shifted\n    uint256 internal constant _INITIAL_REBALANCING_REWARD_PER_DOLLAR_PER_SECOND =\n        5e18 / uint256(3600 * 1 * 10_000 * 6);\n\n    IController public immutable override controller;\n\n    ICNCToken public immutable cnc;\n\n    ICNCMintingRebalancingRewardsHandler public immutable previousRewardsHandler;\n    uint256 public override totalCncMinted;\n    uint256 public override cncRebalancingRewardPerDollarPerSecond;\n\n    bool internal _isInternal;\n\n    modifier onlyInflationManager() {\n        require(\n            msg.sender == address(controller.inflationManager()),\n            \"only InflationManager can call this function\"\n        );\n        _;\n    }\n\n    constructor(\n        IController _controller,\n        ICNCToken _cnc,\n        ICNCMintingRebalancingRewardsHandler _previousRewardsHandler\n    ) {\n        cncRebalancingRewardPerDollarPerSecond = _INITIAL_REBALANCING_REWARD_PER_DOLLAR_PER_SECOND;\n        controller = _controller;\n        previousRewardsHandler = _previousRewardsHandler;\n        cnc = _cnc;\n    }\n\n    function initialize() external onlyOwner initializer {\n        totalCncMinted = previousRewardsHandler.totalCncMinted();\n    }\n\n    function setCncRebalancingRewardPerDollarPerSecond(\n        uint256 _cncRebalancingRewardPerDollarPerSecond\n    ) external override onlyOwner {\n        cncRebalancingRewardPerDollarPerSecond = _cncRebalancingRewardPerDollarPerSecond;\n        emit SetCncRebalancingRewardPerDollarPerSecond(_cncRebalancingRewardPerDollarPerSecond);\n    }\n\n    function _distributeRebalancingRewards(address pool, address account, uint256 amount) internal {\n        if (totalCncMinted + amount > _MAX_REBALANCING_REWARDS) {\n            amount = _MAX_REBALANCING_REWARDS - totalCncMinted;\n        }\n        if (amount == 0) return;\n        uint256 mintedAmount = cnc.mint(account, amount);\n        if (mintedAmount > 0) {\n            totalCncMinted += mintedAmount;\n            emit RebalancingRewardDistributed(pool, account, address(cnc), mintedAmount);\n        }\n    }\n\n    function handleRebalancingRewards(\n        IConicPool conicPool,\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) external onlyInflationManager {\n        _handleRebalancingRewards(conicPool, account, deviationBefore, deviationAfter);\n    }\n\n    function _handleRebalancingRewards(\n        IConicPool conicPool,\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) internal {\n        if (_isInternal) return;\n        uint256 cncRewardAmount = computeRebalancingRewards(\n            address(conicPool),\n            deviationBefore,\n            deviationAfter\n        );\n        _distributeRebalancingRewards(address(conicPool), account, cncRewardAmount);\n    }\n\n    /// @dev this computes how much CNC a user should get when depositing\n    /// this does not check whether the rewards should still be distributed\n    /// amount CNC = t * CNC/s * (1 - (Δdeviation / initialDeviation))\n    /// where\n    /// CNC/s: the amount of CNC per second to distributed for rebalancing\n    /// t: the time elapsed since the weight update\n    /// Δdeviation: the deviation difference caused by this deposit\n    /// initialDeviation: the deviation after updating weights\n    /// @return the amount of CNC to give to the user as reward\n    function computeRebalancingRewards(\n        address conicPool,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) public view override returns (uint256) {\n        if (deviationBefore < deviationAfter) return 0;\n        uint8 decimals = IConicPool(conicPool).underlying().decimals();\n        uint256 deviationDelta = deviationBefore - deviationAfter;\n        uint256 lastWeightUpdate = controller.lastWeightUpdate(conicPool);\n        uint256 elapsedSinceUpdate = uint256(block.timestamp) - lastWeightUpdate;\n        return\n            (elapsedSinceUpdate * cncRebalancingRewardPerDollarPerSecond).mulDown(\n                deviationDelta.convertScale(decimals, 18)\n            );\n    }\n\n    function rebalance(\n        address conicPool,\n        uint256 underlyingAmount,\n        uint256 minUnderlyingReceived,\n        uint256 minCNCReceived\n    ) external override returns (uint256 underlyingReceived, uint256 cncReceived) {\n        require(controller.isPool(conicPool), \"not a pool\");\n        IConicPool conicPool_ = IConicPool(conicPool);\n        bool rebalancingRewardActive = conicPool_.rebalancingRewardActive();\n        IERC20 underlying = conicPool_.underlying();\n        require(underlying.balanceOf(msg.sender) >= underlyingAmount, \"insufficient underlying\");\n        uint256 deviationBefore = conicPool_.computeTotalDeviation();\n        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);\n        underlying.safeApprove(conicPool, underlyingAmount);\n        _isInternal = true;\n        uint256 lpTokenAmount = conicPool_.deposit(underlyingAmount, 0, false);\n        _isInternal = false;\n        underlyingReceived = conicPool_.withdraw(lpTokenAmount, 0);\n        require(underlyingReceived >= minUnderlyingReceived, \"insufficient underlying received\");\n        uint256 cncBefore = cnc.balanceOf(msg.sender);\n\n        // Only distribute rebalancing rewards if active\n        if (rebalancingRewardActive) {\n            uint256 deviationAfter = conicPool_.computeTotalDeviation();\n            _handleRebalancingRewards(conicPool_, msg.sender, deviationBefore, deviationAfter);\n        }\n\n        cncReceived = cnc.balanceOf(msg.sender) - cncBefore;\n        require(cncReceived >= minCNCReceived, \"insufficient CNC received\");\n        underlying.safeTransfer(msg.sender, underlyingReceived);\n    }\n\n    /// @notice switches the minting rebalancing reward handler by granting the new one minting rights\n    /// and renouncing his own\n    /// `InflationManager.removePoolRebalancingRewardHandler` should be called on every pool before this is called\n    /// this should typically be done as a single batched governance action\n    /// The same governance action should also call `InflationManager.addPoolRebalancingRewardHandler` for each pool\n    /// passing in `newRebalancingRewardsHandler` so that the whole operation is atomic\n    /// @param newRebalancingRewardsHandler the address of the new rebalancing rewards handler\n    function switchMintingRebalancingRewardsHandler(\n        address newRebalancingRewardsHandler\n    ) external onlyOwner {\n        address[] memory pools = controller.listPools();\n        for (uint256 i; i < pools.length; i++) {\n            require(\n                !controller.inflationManager().hasPoolRebalancingRewardHandlers(\n                    pools[i],\n                    address(this)\n                ),\n                \"handler is still registered for a pool\"\n            );\n        }\n        cnc.addMinter(newRebalancingRewardsHandler);\n        cnc.renounceMinterRights();\n    }\n}"
    },
    {
      "filename": "contracts/BaseConicPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../interfaces/pools/IConicPool.sol\";\nimport \"../interfaces/pools/IRewardManager.sol\";\nimport \"../interfaces/pools/IWithdrawalProcessor.sol\";\nimport \"../interfaces/ICurveRegistryCache.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../interfaces/tokenomics/ILpTokenStaker.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/vendor/IBaseRewardPool.sol\";\n\nimport \"./LpToken.sol\";\nimport \"./Pausable.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/ArrayExtensions.sol\";\n\nabstract contract BaseConicPool is IConicPool, Pausable {\n    using ArrayExtensions for uint256[];\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IERC20Metadata;\n    using SafeERC20 for ILpToken;\n    using ScaledMath for uint256;\n    using Address for address;\n    using ERC165Checker for address;\n\n    // Avoid stack depth errors\n    struct DepositVars {\n        uint256 exchangeRate;\n        uint256 underlyingBalanceIncrease;\n        uint256 mintableUnderlyingAmount;\n        uint256 lpReceived;\n        uint256 underlyingBalanceBefore;\n        uint256 allocatedBalanceBefore;\n        uint256[] allocatedPerPoolBefore;\n        uint256 underlyingBalanceAfter;\n        uint256 allocatedBalanceAfter;\n        uint256[] allocatedPerPoolAfter;\n    }\n\n    uint256 internal constant _IDLE_RATIO_UPPER_BOUND = 0.2e18;\n    uint256 internal constant _MIN_DEPEG_THRESHOLD = 0.01e18;\n    uint256 internal constant _MAX_DEPEG_THRESHOLD = 0.1e18;\n    uint256 internal constant _MAX_DEVIATION_UPPER_BOUND = 0.2e18;\n    uint256 internal constant _TOTAL_UNDERLYING_CACHE_EXPIRY = 3 days;\n    uint256 internal constant _MAX_USD_VALUE_FOR_REMOVING_POOL = 100e18;\n\n    IERC20 internal immutable CVX;\n    IERC20 internal immutable CRV;\n    IERC20 internal constant CNC = IERC20(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);\n    address internal constant _WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    IERC20Metadata public immutable override underlying;\n    ILpToken public immutable override lpToken;\n\n    IRewardManager public immutable rewardManager;\n\n    /// @dev once the deviation gets under this threshold, the reward distribution will be paused\n    /// until the next rebalancing. This is expressed as a ratio, scaled with 18 decimals\n    uint256 public maxDeviation = 0.02e18; // 2%\n    uint256 public maxIdleCurveLpRatio = 0.05e18; // triggers Convex staking when exceeded\n    bool public isShutdown;\n    uint256 public depegThreshold = 0.03e18; // 3%\n    uint256 internal _cacheUpdatedTimestamp;\n    uint256 internal _cachedTotalUnderlying;\n\n    /// @dev `true` while the reward distribution is active\n    bool public rebalancingRewardActive;\n\n    EnumerableSet.AddressSet internal _pools;\n    EnumerableMap.AddressToUintMap internal weights; // liquidity allocation weights\n\n    /// @dev the absolute value in terms of USD of the total deviation after\n    /// the weights have been updated\n    uint256 public totalDeviationAfterWeightUpdate;\n\n    mapping(address => uint256) _cachedPrices;\n\n    modifier onlyController() {\n        require(msg.sender == address(controller), \"not authorized\");\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        IRewardManager _rewardManager,\n        address _controller,\n        string memory _lpTokenName,\n        string memory _symbol,\n        address _cvx,\n        address _crv\n    ) Pausable(IController(_controller)) {\n        require(\n            _underlying != _cvx && _underlying != _crv && _underlying != address(CNC),\n            \"invalid underlying\"\n        );\n        underlying = IERC20Metadata(_underlying);\n        uint8 decimals = IERC20Metadata(_underlying).decimals();\n        lpToken = new LpToken(_controller, address(this), decimals, _lpTokenName, _symbol);\n        rewardManager = _rewardManager;\n\n        CVX = IERC20(_cvx);\n        CRV = IERC20(_crv);\n        CVX.safeApprove(address(_rewardManager), type(uint256).max);\n        CRV.safeApprove(address(_rewardManager), type(uint256).max);\n        CNC.safeApprove(address(_rewardManager), type(uint256).max);\n    }\n\n    /// @dev We always delegate-call to the Curve handler, which means\n    /// that we need to be able to receive the ETH to unwrap it and\n    /// send it to the Curve pool, as well as to receive it back from\n    /// the Curve pool when withdrawing\n    receive() external payable {\n        require(address(underlying) == _WETH_ADDRESS, \"not WETH pool\");\n    }\n\n    /// @notice Deposit underlying on behalf of someone\n    /// @param underlyingAmount Amount of underlying to deposit\n    /// @param minLpReceived The minimum amount of LP to accept from the deposit\n    /// @return lpReceived The amount of LP received\n    function depositFor(\n        address account,\n        uint256 underlyingAmount,\n        uint256 minLpReceived,\n        bool stake\n    ) public override notPaused returns (uint256) {\n        _sanityChecks();\n\n        DepositVars memory vars;\n\n        // Preparing deposit\n        require(!isShutdown, \"pool is shutdown\");\n        require(underlyingAmount > 0, \"deposit amount cannot be zero\");\n        uint256 underlyingPrice_ = controller.priceOracle().getUSDPrice(address(underlying));\n        (\n            vars.underlyingBalanceBefore,\n            vars.allocatedBalanceBefore,\n            vars.allocatedPerPoolBefore\n        ) = _getTotalAndPerPoolUnderlying(underlyingPrice_);\n        vars.exchangeRate = _exchangeRate(vars.underlyingBalanceBefore);\n\n        // Executing deposit\n        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);\n        _depositToCurve(\n            vars.allocatedBalanceBefore,\n            vars.allocatedPerPoolBefore,\n            underlying.balanceOf(address(this))\n        );\n\n        // Minting LP Tokens\n        (\n            vars.underlyingBalanceAfter,\n            vars.allocatedBalanceAfter,\n            vars.allocatedPerPoolAfter\n        ) = _getTotalAndPerPoolUnderlying(underlyingPrice_);\n        vars.underlyingBalanceIncrease = vars.underlyingBalanceAfter - vars.underlyingBalanceBefore;\n        vars.mintableUnderlyingAmount = _min(underlyingAmount, vars.underlyingBalanceIncrease);\n        vars.lpReceived = vars.mintableUnderlyingAmount.divDown(vars.exchangeRate);\n        require(vars.lpReceived >= minLpReceived, \"too much slippage\");\n\n        if (stake) {\n            lpToken.mint(address(this), vars.lpReceived, account);\n            ILpTokenStaker lpTokenStaker = controller.lpTokenStaker();\n            lpToken.safeApprove(address(lpTokenStaker), vars.lpReceived);\n            lpTokenStaker.stakeFor(vars.lpReceived, address(this), account);\n        } else {\n            lpToken.mint(account, vars.lpReceived, account);\n        }\n\n        _handleRebalancingRewards(\n            account,\n            vars.allocatedBalanceBefore,\n            vars.allocatedPerPoolBefore,\n            vars.allocatedBalanceAfter,\n            vars.allocatedPerPoolAfter\n        );\n\n        _cachedTotalUnderlying = vars.underlyingBalanceAfter;\n        _cacheUpdatedTimestamp = block.timestamp;\n\n        emit Deposit(msg.sender, account, underlyingAmount, vars.lpReceived);\n        return vars.lpReceived;\n    }\n\n    /// @notice Deposit underlying\n    /// @param underlyingAmount Amount of underlying to deposit\n    /// @param minLpReceived The minimum amoun of LP to accept from the deposit\n    /// @return lpReceived The amount of LP received\n    function deposit(\n        uint256 underlyingAmount,\n        uint256 minLpReceived\n    ) external override returns (uint256) {\n        return depositFor(msg.sender, underlyingAmount, minLpReceived, true);\n    }\n\n    /// @notice Deposit underlying\n    /// @param underlyingAmount Amount of underlying to deposit\n    /// @param minLpReceived The minimum amoun of LP to accept from the deposit\n    /// @param stake Whether or not to stake in the LpTokenStaker\n    /// @return lpReceived The amount of LP received\n    function deposit(\n        uint256 underlyingAmount,\n        uint256 minLpReceived,\n        bool stake\n    ) external override returns (uint256) {\n        return depositFor(msg.sender, underlyingAmount, minLpReceived, stake);\n    }\n\n    function _depositToCurve(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool,\n        uint256 underlyingAmount_\n    ) internal {\n        uint256 depositsRemaining_ = underlyingAmount_;\n        uint256 totalAfterDeposit_ = totalUnderlying_ + underlyingAmount_;\n\n        // NOTE: avoid modifying `allocatedPerPool`\n        uint256[] memory allocatedPerPoolCopy = allocatedPerPool.copy();\n\n        while (depositsRemaining_ > 0) {\n            (uint256 poolIndex_, uint256 maxDeposit_) = _getDepositPool(\n                totalAfterDeposit_,\n                allocatedPerPoolCopy\n            );\n            // account for rounding errors\n            if (depositsRemaining_ < maxDeposit_ + 1e2) {\n                maxDeposit_ = depositsRemaining_;\n            }\n\n            address pool_ = _pools.at(poolIndex_);\n\n            // Depositing into least balanced pool\n            uint256 toDeposit_ = _min(depositsRemaining_, maxDeposit_);\n            address poolAdapter = address(controller.poolAdapterFor(pool_));\n            poolAdapter.functionDelegateCall(\n                abi.encodeWithSignature(\n                    \"deposit(address,address,uint256)\",\n                    pool_,\n                    address(underlying),\n                    toDeposit_\n                )\n            );\n\n            depositsRemaining_ -= toDeposit_;\n            allocatedPerPoolCopy[poolIndex_] += toDeposit_;\n        }\n    }\n\n    function _getDepositPool(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool\n    ) internal view returns (uint256 poolIndex, uint256 maxDepositAmount) {\n        uint256 poolsCount_ = allocatedPerPool.length;\n        int256 iPoolIndex = -1;\n        for (uint256 i; i < poolsCount_; i++) {\n            address pool_ = _pools.at(i);\n            uint256 allocatedUnderlying_ = allocatedPerPool[i];\n            uint256 targetAllocation_ = totalUnderlying_.mulDown(weights.get(pool_));\n            if (allocatedUnderlying_ >= targetAllocation_) continue;\n            uint256 maxBalance_ = targetAllocation_ + targetAllocation_.mulDown(_getMaxDeviation());\n            uint256 maxDepositAmount_ = maxBalance_ - allocatedUnderlying_;\n            if (maxDepositAmount_ <= maxDepositAmount) continue;\n            maxDepositAmount = maxDepositAmount_;\n            iPoolIndex = int256(i);\n        }\n        require(iPoolIndex > -1, \"error retrieving deposit pool\");\n        poolIndex = uint256(iPoolIndex);\n    }\n\n    /// @notice Get current underlying balance of pool\n    function totalUnderlying() public view virtual returns (uint256) {\n        (uint256 totalUnderlying_, , ) = getTotalAndPerPoolUnderlying();\n\n        return totalUnderlying_;\n    }\n\n    function _exchangeRate(uint256 totalUnderlying_) internal view returns (uint256) {\n        uint256 lpSupply = lpToken.totalSupply();\n        if (lpSupply == 0 || totalUnderlying_ == 0) return ScaledMath.ONE;\n\n        return totalUnderlying_.divDown(lpSupply);\n    }\n\n    /// @notice Get current exchange rate for the pool's LP token to the underlying\n    function exchangeRate() public view virtual override returns (uint256) {\n        return _exchangeRate(totalUnderlying());\n    }\n\n    /// @notice Get current exchange rate for the pool's LP token to USD\n    /// @dev This is using the cached total underlying value, so is not precisely accurate.\n    function usdExchangeRate() external view virtual override returns (uint256) {\n        uint256 underlyingPrice = controller.priceOracle().getUSDPrice(address(underlying));\n        return _exchangeRate(_cachedTotalUnderlying).mulDown(underlyingPrice);\n    }\n\n    /// @notice Unstake LP Tokens and withdraw underlying\n    /// @param conicLpAmount Amount of LP tokens to burn\n    /// @param minUnderlyingReceived Minimum amount of underlying to redeem\n    /// This should always be set to a reasonable value (e.g. 2%), otherwise\n    /// the user withdrawing could be forced into paying a withdrawal penalty fee\n    /// by another user\n    /// @return uint256 Total underlying withdrawn\n    function unstakeAndWithdraw(\n        uint256 conicLpAmount,\n        uint256 minUnderlyingReceived,\n        address to\n    ) public override returns (uint256) {\n        controller.lpTokenStaker().unstakeFrom(conicLpAmount, msg.sender);\n        return withdraw(conicLpAmount, minUnderlyingReceived, to);\n    }\n\n    function unstakeAndWithdraw(\n        uint256 conicLpAmount,\n        uint256 minUnderlyingReceived\n    ) external returns (uint256) {\n        return unstakeAndWithdraw(conicLpAmount, minUnderlyingReceived, msg.sender);\n    }\n\n    function withdraw(\n        uint256 conicLpAmount,\n        uint256 minUnderlyingReceived\n    ) public override returns (uint256) {\n        return withdraw(conicLpAmount, minUnderlyingReceived, msg.sender);\n    }\n\n    /// @notice Withdraw underlying\n    /// @param conicLpAmount Amount of LP tokens to burn\n    /// @param minUnderlyingReceived Minimum amount of underlying to redeem\n    /// This should always be set to a reasonable value (e.g. 2%), otherwise\n    /// the user withdrawing could be forced into paying a withdrawal penalty fee\n    /// by another user\n    /// @return uint256 Total underlying withdrawn\n    function withdraw(\n        uint256 conicLpAmount,\n        uint256 minUnderlyingReceived,\n        address to\n    ) public override returns (uint256) {\n        _sanityChecks();\n\n        // Preparing Withdrawals\n        require(lpToken.balanceOf(msg.sender) >= conicLpAmount, \"insufficient balance\");\n        uint256 underlyingBalanceBefore_ = underlying.balanceOf(address(this));\n\n        // Processing Withdrawals\n        (\n            uint256 totalUnderlying_,\n            uint256 allocatedUnderlying_,\n            uint256[] memory allocatedPerPool\n        ) = getTotalAndPerPoolUnderlying();\n        uint256 underlyingToReceive_ = conicLpAmount.mulDown(_exchangeRate(totalUnderlying_));\n        {\n            if (underlyingBalanceBefore_ < underlyingToReceive_) {\n                uint256 underlyingToWithdraw_ = underlyingToReceive_ - underlyingBalanceBefore_;\n                _withdrawFromCurve(allocatedUnderlying_, allocatedPerPool, underlyingToWithdraw_);\n            }\n        }\n\n        // Sending Underlying and burning LP Tokens\n        uint256 underlyingWithdrawn_ = _min(\n            underlying.balanceOf(address(this)),\n            underlyingToReceive_\n        );\n        require(underlyingWithdrawn_ >= minUnderlyingReceived, \"too much slippage\");\n        lpToken.burn(msg.sender, conicLpAmount, msg.sender);\n        underlying.safeTransfer(to, underlyingWithdrawn_);\n\n        _cachedTotalUnderlying = totalUnderlying_ - underlyingWithdrawn_;\n        _cacheUpdatedTimestamp = block.timestamp;\n\n        // state has already been updated, so no need to worry about re-entrancy\n        if (to.supportsInterface(type(IWithdrawalProcessor).interfaceId)) {\n            IWithdrawalProcessor(to).processWithdrawal(msg.sender, underlyingWithdrawn_);\n        }\n\n        emit Withdraw(msg.sender, underlyingWithdrawn_);\n        return underlyingWithdrawn_;\n    }\n\n    function _withdrawFromCurve(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool,\n        uint256 amount_\n    ) internal {\n        uint256 withdrawalsRemaining_ = amount_;\n        uint256 totalAfterWithdrawal_ = totalUnderlying_ - amount_;\n\n        // NOTE: avoid modifying `allocatedPerPool`\n        uint256[] memory allocatedPerPoolCopy = allocatedPerPool.copy();\n\n        while (withdrawalsRemaining_ > 0) {\n            (uint256 poolIndex_, uint256 maxWithdrawal_) = _getWithdrawPool(\n                totalAfterWithdrawal_,\n                allocatedPerPoolCopy\n            );\n            address pool_ = _pools.at(poolIndex_);\n\n            // Withdrawing from least balanced pool\n            uint256 toWithdraw_ = _min(withdrawalsRemaining_, maxWithdrawal_);\n\n            address poolAdapter = address(controller.poolAdapterFor(pool_));\n            poolAdapter.functionDelegateCall(\n                abi.encodeWithSignature(\n                    \"withdraw(address,address,uint256)\",\n                    pool_,\n                    underlying,\n                    toWithdraw_\n                )\n            );\n            withdrawalsRemaining_ -= toWithdraw_;\n            allocatedPerPoolCopy[poolIndex_] -= toWithdraw_;\n        }\n    }\n\n    function _getWithdrawPool(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool\n    ) internal view returns (uint256 withdrawPoolIndex, uint256 maxWithdrawalAmount) {\n        uint256 poolsCount_ = allocatedPerPool.length;\n        int256 iWithdrawPoolIndex = -1;\n        for (uint256 i; i < poolsCount_; i++) {\n            address curvePool_ = _pools.at(i);\n            uint256 weight_ = weights.get(curvePool_);\n            uint256 allocatedUnderlying_ = allocatedPerPool[i];\n\n            // If a pool has a weight of 0,\n            // withdraw from it if it has more than the max lp value\n            if (weight_ == 0) {\n                uint256 price_ = controller.priceOracle().getUSDPrice(address(underlying));\n                uint256 allocatedUsd = (price_ * allocatedUnderlying_) /\n                    10 ** underlying.decimals();\n                if (allocatedUsd >= _MAX_USD_VALUE_FOR_REMOVING_POOL / 2) {\n                    return (uint256(i), allocatedUnderlying_);\n                }\n            }\n\n            uint256 targetAllocation_ = totalUnderlying_.mulDown(weight_);\n            if (allocatedUnderlying_ <= targetAllocation_) continue;\n            uint256 minBalance_ = targetAllocation_ - targetAllocation_.mulDown(_getMaxDeviation());\n            uint256 maxWithdrawalAmount_ = allocatedUnderlying_ - minBalance_;\n            if (maxWithdrawalAmount_ <= maxWithdrawalAmount) continue;\n            maxWithdrawalAmount = maxWithdrawalAmount_;\n            iWithdrawPoolIndex = int256(i);\n        }\n        require(iWithdrawPoolIndex > -1, \"error retrieving withdraw pool\");\n        withdrawPoolIndex = uint256(iWithdrawPoolIndex);\n    }\n\n    function allPools() external view override returns (address[] memory) {\n        return _pools.values();\n    }\n\n    function poolsCount() external view override returns (uint256) {\n        return _pools.length();\n    }\n\n    function getPoolAtIndex(uint256 _index) external view returns (address) {\n        return _pools.at(_index);\n    }\n\n    function isRegisteredPool(address _pool) public view returns (bool) {\n        return _pools.contains(_pool);\n    }\n\n    function getPoolWeight(address _pool) external view returns (uint256) {\n        (, uint256 _weight) = weights.tryGet(_pool);\n        return _weight;\n    }\n\n    // Controller and Admin functions\n\n    function addPool(address _pool) external override onlyOwner {\n        require(!_pools.contains(_pool), \"pool already added\");\n        IPoolAdapter poolAdapter = controller.poolAdapterFor(_pool);\n        bool supported_ = poolAdapter.supportsAsset(_pool, address(underlying));\n        require(supported_, \"coin not in pool\");\n        address lpToken_ = poolAdapter.lpToken(_pool);\n        require(controller.priceOracle().isTokenSupported(lpToken_), \"cannot price LP Token\");\n\n        address booster = controller.convexBooster();\n        IERC20(lpToken_).safeApprove(booster, type(uint256).max);\n\n        if (!weights.contains(_pool)) weights.set(_pool, 0);\n        require(_pools.add(_pool), \"failed to add pool\");\n        emit CurvePoolAdded(_pool);\n    }\n\n    // This requires that the weight of the pool is first set to 0\n    function removePool(address _pool) external override onlyOwner {\n        require(_pools.contains(_pool), \"pool not added\");\n        require(_pools.length() > 1, \"cannot remove last pool\");\n        IPoolAdapter poolAdapter = controller.poolAdapterFor(_pool);\n        address lpToken_ = poolAdapter.lpToken(_pool);\n        uint256 usdValue = poolAdapter.computePoolValueInUSD(address(this), _pool);\n        require(usdValue < _MAX_USD_VALUE_FOR_REMOVING_POOL, \"pool has allocated funds\");\n        uint256 weight = weights.get(_pool);\n        IERC20(lpToken_).safeApprove(controller.convexBooster(), 0);\n        require(weight == 0, \"pool has weight set\");\n        require(_pools.remove(_pool), \"pool not removed\");\n        require(weights.remove(_pool), \"weight not removed\");\n        emit CurvePoolRemoved(_pool);\n    }\n\n    function updateWeights(PoolWeight[] memory poolWeights) external onlyController {\n        require(poolWeights.length == _pools.length(), \"invalid pool weights\");\n        uint256 total;\n        for (uint256 i; i < poolWeights.length; i++) {\n            address pool = poolWeights[i].poolAddress;\n            require(isRegisteredPool(pool), \"pool is not registered\");\n            uint256 newWeight = poolWeights[i].weight;\n            weights.set(pool, newWeight);\n            emit NewWeight(pool, newWeight);\n            total += newWeight;\n        }\n\n        require(total == ScaledMath.ONE, \"weights do not sum to 1\");\n\n        (\n            uint256 totalUnderlying_,\n            uint256 totalAllocated,\n            uint256[] memory allocatedPerPool\n        ) = getTotalAndPerPoolUnderlying();\n\n        uint256 totalDeviation = _computeTotalDeviation(totalUnderlying_, allocatedPerPool);\n        totalDeviationAfterWeightUpdate = totalDeviation;\n        rebalancingRewardActive = !_isBalanced(allocatedPerPool, totalAllocated);\n\n        // Updating price cache for all pools\n        // Used for seeing if a pool has depegged\n        _updatePriceCache();\n    }\n\n    function shutdownPool() external override onlyController {\n        require(!isShutdown, \"pool already shutdown\");\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    function updateDepegThreshold(uint256 newDepegThreshold_) external onlyOwner {\n        require(newDepegThreshold_ >= _MIN_DEPEG_THRESHOLD, \"invalid depeg threshold\");\n        require(newDepegThreshold_ <= _MAX_DEPEG_THRESHOLD, \"invalid depeg threshold\");\n        depegThreshold = newDepegThreshold_;\n        emit DepegThresholdUpdated(newDepegThreshold_);\n    }\n\n    /// @notice Called when an underlying of a Curve Pool has depegged and we want to exit the pool.\n    /// Will check if a coin has depegged, and will revert if not.\n    /// Sets the weight of the Curve Pool to 0, and re-enables CNC rewards for deposits.\n    /// @dev Cannot be called if the underlying of this pool itself has depegged.\n    /// @param curvePool_ The Curve Pool to handle.\n    function handleDepeggedCurvePool(address curvePool_) external override {\n        _sanityChecks();\n\n        // Validation\n        require(isRegisteredPool(curvePool_), \"pool is not registered\");\n        require(weights.get(curvePool_) != 0, \"pool weight already 0\");\n        require(!_isDepegged(address(underlying)), \"underlying is depegged\");\n        address lpToken_ = controller.poolAdapterFor(curvePool_).lpToken(curvePool_);\n        require(_isDepegged(lpToken_), \"pool is not depegged\");\n\n        // Set target curve pool weight to 0\n        // Scale up other weights to compensate\n        _setWeightToZero(curvePool_);\n        rebalancingRewardActive = true;\n\n        emit HandledDepeggedCurvePool(curvePool_);\n    }\n\n    function _setWeightToZero(address zeroedPool) internal {\n        uint256 weight_ = weights.get(zeroedPool);\n        if (weight_ == 0) return;\n        require(weight_ != ScaledMath.ONE, \"can't remove last pool\");\n        uint256 scaleUp_ = ScaledMath.ONE.divDown(ScaledMath.ONE - weights.get(zeroedPool));\n        uint256 curvePoolLength_ = _pools.length();\n        for (uint256 i; i < curvePoolLength_; i++) {\n            ad"
    }
  ]
}