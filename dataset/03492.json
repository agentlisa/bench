{
  "Title": "[L04] Merkle tree elements are overwritten",
  "Content": "The [`getMerkleRoot` function](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L22) of the `Lib_MerkleTree` library accepts an array of elements and computes the corresponding Merkle root. In the process, it unexpectedly [overwrites up to half of the elements](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L88), thereby corrupting the original array. The current code base has [one instance](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol#L340), within the `appendStateBatch` function of the `OVM_StateCommitmentChain` contract, where the array is used after it is passed to the `getMerkleRoot` function, but fortunately it only reads the length, which is unchanged. This function calculates the Merkle root of its [`_batch` parameter](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol#L127), which means that the caller may attempt to reuse the (now corrupted) array.\n\n\nConsider including warning documentation on the `getMerkleRoot` and `appendStateBatch` functions stating that the input may be modified.\n\n\n***Update**: This issue was identified in the first audited commit. It was fixed in the latest audited commit by adding relevant documentation.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_MerkleTree\n * @author River Keefer\n */\nlibrary Lib_MerkleTree {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\n     * If you do not know the original length of elements for the tree you are verifying,\n     * then this may allow empty leaves past _elements.length to pass a verification check down the line.\n     * @param _elements Array of hashes from which to generate a merkle root.\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\n     */\n    function getMerkleRoot(\n        bytes32[] memory _elements\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        require(\n            _elements.length > 0,\n            \"Lib_MerkleTree: Must provide at least one leaf hash.\"\n        );\n\n        if (_elements.length == 0) {\n            return _elements[0];\n        }\n\n        uint256[16] memory defaults = [\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\n        ];\n\n        // Reserve memory space for our hashes.\n        bytes memory buf = new bytes(64);\n\n        // We'll need to keep track of left and right siblings.\n        bytes32 leftSibling;\n        bytes32 rightSibling;\n\n        // Number of non-empty nodes at the current depth.\n        uint256 rowSize = _elements.length;\n\n        // Current depth, counting from 0 at the leaves\n        uint256 depth = 0;\n\n        // Common sub-expressions\n        uint256 halfRowSize;         // rowSize / 2\n        bool rowSizeIsOdd;           // rowSize % 2 == 1\n\n        while (rowSize > 1) {\n            halfRowSize = rowSize / 2;\n            rowSizeIsOdd = rowSize % 2 == 1;\n\n            for (uint256 i = 0; i < halfRowSize; i++) {\n                leftSibling  = _elements[(2 * i)    ];\n                rightSibling = _elements[(2 * i) + 1];\n                assembly {\n                    mstore(add(buf, 32), leftSibling )\n                    mstore(add(buf, 64), rightSibling)\n                }\n\n                _elements[i] = keccak256(buf);\n            }\n\n            if (rowSizeIsOdd) {\n                leftSibling  = _elements[rowSize - 1];\n                rightSibling = bytes32(defaults[depth]);\n                assembly {\n                    mstore(add(buf, 32), leftSibling)\n                    mstore(add(buf, 64), rightSibling)\n                }\n\n                _elements[halfRowSize] = keccak256(buf);\n            }\n\n            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\n            depth++;\n        }\n\n        return _elements[0];\n    }\n\n    /**\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\n     * of leaves generated is a known, correct input, and does not return true for indices \n     * extending past that index (even if _siblings would be otherwise valid.)\n     * @param _root The Merkle root to verify against.\n     * @param _leaf The leaf hash to verify inclusion of.\n     * @param _index The index in the tree of this leaf.\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0 (bottom of the tree). \n     * @param _totalLeaves The total number of leaves originally passed into.\n     * @return Whether or not the merkle branch and leaf passes verification.\n     */\n    function verify(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32[] memory _siblings,\n        uint256 _totalLeaves\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        require(\n            _totalLeaves > 0,\n            \"Lib_MerkleTree: Total leaves must be greater than zero.\"\n        );\n\n        require(\n            _index < _totalLeaves,\n            \"Lib_MerkleTree: Index out of bounds.\"\n        );\n\n        require(\n            _siblings.length == _ceilLog2(_totalLeaves),\n            \"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\"\n        );\n\n        bytes32 computedRoot = _leaf;\n\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            if ((_index & 1) == 1) {\n                computedRoot = keccak256(\n                    abi.encodePacked(\n                        _siblings[i],\n                        computedRoot\n                    )\n                );\n            } else {\n                computedRoot = keccak256(\n                    abi.encodePacked(\n                        computedRoot,\n                        _siblings[i]\n                    )\n                );\n            }\n\n            _index >>= 1;\n        }\n\n        return _root == computedRoot;\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Calculates the integer ceiling of the log base 2 of an input.\n     * @param _in Unsigned input to calculate the log.\n     * @return ceil(log_base_2(_in))\n     */\n    function _ceilLog2(\n        uint256 _in\n    )\n        private\n        pure\n        returns (\n            uint256\n        )\n    {   \n        require(\n            _in > 0,\n            \"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\"\n        );\n\n        if (_in == 1) {\n            return 0;\n        }\n\n        // Find the highest set bit (will be floor(log_2)).\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\n        uint256 val = _in;\n        uint256 highest = 0;\n        for (uint8 i = 128; i >= 1; i >>= 1) {\n            if (val & (uint(1) << i) - 1 << i != 0) {\n                highest += i;\n                val >>= i;\n            }\n        }\n\n        // Increment by one if this is not a perfect logarithm.\n        if ((uint(1) << highest) != _in) {\n            highest += 1;\n        }\n\n        return highest;\n    }\n}"
    }
  ]
}