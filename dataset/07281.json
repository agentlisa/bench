{
  "Title": "[M-25] Vault can be created for not-yet-existing ERC20 tokens, which allows attackers to set traps to steal NFTs from Borrowers",
  "Content": "\nThere is a subtle difference between the implementation of solmate’s SafeTransferLib and OZ’s SafeERC20: OZ’s SafeERC20 checks if the token is a contract or not, solmate’s SafeTransferLib does not.<br>\nSee: <https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9><br>\nNote that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.<br>\nAs a result, when the token’s address has no code, the transaction will just succeed with no error.<br>\nThis attack vector was made well-known by the qBridge hack back in Jan 2022.\n\nIn AstariaRouter, Vault, PublicVault, VaultImplementation, ClearingHouse, TransferProxy, and WithdrawProxy, the `safetransfer` and `safetransferfrom` don't check the existence of code at the token address. This is a known issue while using solmate’s libraries.\n\nHence this can lead to miscalculation of funds and also loss of funds , because if safetransfer() and safetransferfrom() are called on a token address that doesn’t have contract in it, it will always return success. Due to this protocol will think that funds has been transferred and successful , and records will be accordingly calculated, but in reality funds were never transferred.\n\nSo this will lead to miscalculation and loss of funds.\n\n### Attack scenario (example):\n\nIt’s becoming popular for protocols to deploy their token across multiple networks and when they do so, a common practice is to deploy the token contract from the same deployer address and with the same nonce so that the token address can be the same for all the networks.\n\nA sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the borrowers. For example: 1INCH is using the same token address for both Ethereum and BSC; Gelato's `$GEL` token is using the same token address for Ethereum, Fantom and Polygon.\n\n*   ProjectA has TokenA on another network;\n*   ProjectB has TokenB on another network;\n*   ProjectC has TokenC on another network;\n*   A malicious strategist (Bob) can create new PublicVaults with amounts of 10000E18 for TokenA, TokenB, and TokenC.\n*   A few months later, ProjectB lunched TokenB on the local network at the same address;\n*   Alice as a liquidator deposited 11000e18 TokenB into the vault;\n*   The attacker (Bob) can withdraw to receive most of Alice's added TokenB.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L490><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L795><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/Vault.sol#L66><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/Vault.sol#L72><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L384><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L394><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L406><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L143><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L161><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/TransferProxy.sol#L34><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L269><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L281><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L298>\n\n### Recommended Mitigation Steps\n\nThis issue won’t exist if OpenZeppelin’s SafeERC20 is used instead.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/158#issuecomment-1404011644):**\n > The protocol has no enforcement of the assets that can be listed, only tokens that are known should be interacted with by users and UI implementations.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/158)**\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/158#issuecomment-1443332368):**\n > Keeping this report as medium due to the credibility of the attack path described.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/utils/SafeTransferLib.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}"
    },
    {
      "filename": "src/AstariaRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IVaultImplementation} from \"core/interfaces/IVaultImplementation.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {IStrategyValidator} from \"core/interfaces/IStrategyValidator.sol\";\n\nimport {MerkleProofLib} from \"core/utils/MerkleProofLib.sol\";\nimport {Pausable} from \"core/utils/Pausable.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {ERC4626Router} from \"gpl/ERC4626Router.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title AstariaRouter\n * @notice This contract manages the deployment of Vaults and universal Astaria actions.\n */\ncontract AstariaRouter is\n  AuthInitializable,\n  Initializable,\n  ERC4626Router,\n  Pausable,\n  IAstariaRouter\n{\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  uint256 private constant ROUTER_SLOT =\n    uint256(keccak256(\"xyz.astaria.AstariaRouter.storage.location\")) - 1;\n\n  // cast --to-bytes32 $(cast sig \"OutOfBoundError()\")\n  uint256 private constant OUTOFBOUND_ERROR_SELECTOR =\n    0x571e08d100000000000000000000000000000000000000000000000000000000;\n  uint256 private constant ONE_WORD = 0x20;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Setup transfer authority and set up addresses for deployed CollateralToken, LienToken, TransferProxy contracts, as well as PublicVault and SoloVault implementations to clone.\n   * @param _AUTHORITY The authority manager.\n   * @param _COLLATERAL_TOKEN The address of the deployed CollateralToken contract.\n   * @param _LIEN_TOKEN The address of the deployed LienToken contract.\n   * @param _TRANSFER_PROXY The address of the deployed TransferProxy contract.\n   * @param _VAULT_IMPL The address of a base implementation of VaultImplementation for cloning.\n   * @param _SOLO_IMPL The address of a base implementation of a PrivateVault for cloning.\n   */\n  function initialize(\n    Authority _AUTHORITY,\n    ICollateralToken _COLLATERAL_TOKEN,\n    ILienToken _LIEN_TOKEN,\n    ITransferProxy _TRANSFER_PROXY,\n    address _VAULT_IMPL,\n    address _SOLO_IMPL,\n    address _WITHDRAW_IMPL,\n    address _BEACON_PROXY_IMPL,\n    address _CLEARING_HOUSE_IMPL\n  ) external initializer {\n    __initAuth(msg.sender, address(_AUTHORITY));\n    RouterStorage storage s = _loadRouterSlot();\n\n    s.COLLATERAL_TOKEN = _COLLATERAL_TOKEN;\n    s.LIEN_TOKEN = _LIEN_TOKEN;\n    s.TRANSFER_PROXY = _TRANSFER_PROXY;\n    s.implementations[uint8(ImplementationType.PrivateVault)] = _SOLO_IMPL;\n    s.implementations[uint8(ImplementationType.PublicVault)] = _VAULT_IMPL;\n    s.implementations[uint8(ImplementationType.WithdrawProxy)] = _WITHDRAW_IMPL;\n    s.implementations[\n      uint8(ImplementationType.ClearingHouse)\n    ] = _CLEARING_HOUSE_IMPL;\n    s.BEACON_PROXY_IMPLEMENTATION = _BEACON_PROXY_IMPL;\n    s.auctionWindow = uint32(2 days);\n    s.auctionWindowBuffer = uint32(1 days);\n\n    s.liquidationFeeNumerator = uint32(130);\n    s.liquidationFeeDenominator = uint32(1000);\n    s.minInterestBPS = uint32((uint256(1e15) * 5) / (365 days));\n    s.minEpochLength = uint32(7 days);\n    s.maxEpochLength = uint32(45 days);\n    s.maxInterestRate = ((uint256(1e16) * 200) / (365 days)).safeCastTo88();\n    //63419583966; // 200% apy / second\n    s.buyoutFeeNumerator = uint32(100);\n    s.buyoutFeeDenominator = uint32(1000);\n    s.minDurationIncrease = uint32(5 days);\n    s.guardian = msg.sender;\n  }\n\n  function mint(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 maxAmountIn\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 amountIn)\n  {\n    return super.mint(vault, to, shares, maxAmountIn);\n  }\n\n  function deposit(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 minSharesOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 sharesOut)\n  {\n    return super.deposit(vault, to, amount, minSharesOut);\n  }\n\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 maxSharesOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 sharesOut)\n  {\n    return super.withdraw(vault, to, amount, maxSharesOut);\n  }\n\n  function redeem(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 minAmountOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 amountOut)\n  {\n    return super.redeem(vault, to, shares, minAmountOut);\n  }\n\n  function redeemFutureEpoch(\n    IPublicVault vault,\n    uint256 shares,\n    address receiver,\n    uint64 epoch\n  ) public virtual validVault(address(vault)) returns (uint256 assets) {\n    return vault.redeemFutureEpoch(shares, receiver, msg.sender, epoch);\n  }\n\n  modifier validVault(address targetVault) {\n    if (!isValidVault(targetVault)) {\n      revert InvalidVault(targetVault);\n    }\n    _;\n  }\n\n  function pullToken(\n    address token,\n    uint256 amount,\n    address recipient\n  ) public payable override {\n    RouterStorage storage s = _loadRouterSlot();\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      address(token),\n      msg.sender,\n      recipient,\n      amount\n    );\n  }\n\n  function _loadRouterSlot() internal pure returns (RouterStorage storage rs) {\n    uint256 slot = ROUTER_SLOT;\n    assembly {\n      rs.slot := slot\n    }\n  }\n\n  function feeTo() public view returns (address) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.feeTo;\n  }\n\n  function BEACON_PROXY_IMPLEMENTATION() public view returns (address) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.BEACON_PROXY_IMPLEMENTATION;\n  }\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.LIEN_TOKEN;\n  }\n\n  function TRANSFER_PROXY() public view returns (ITransferProxy) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.TRANSFER_PROXY;\n  }\n\n  function COLLATERAL_TOKEN() public view returns (ICollateralToken) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.COLLATERAL_TOKEN;\n  }\n\n  /**\n   * @dev Enables _pause, freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyPause() external requiresAuth whenNotPaused {\n    _pause();\n  }\n\n  /**\n   * @dev Disables _pause, un-freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyUnpause() external requiresAuth whenPaused {\n    _unpause();\n  }\n\n  function fileBatch(File[] calldata files) external requiresAuth {\n    uint256 i;\n    for (; i < files.length; ) {\n      _file(files[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    RouterStorage storage s = _loadRouterSlot();\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AuctionWindow) {\n      (uint256 window, uint256 windowBuffer) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      s.auctionWindow = window.safeCastTo32();\n      s.auctionWindowBuffer = windowBuffer.safeCastTo32();\n    } else if (what == FileType.LiquidationFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.liquidationFeeNumerator = numerator.safeCastTo32();\n      s.liquidationFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.ProtocolFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.protocolFeeNumerator = numerator.safeCastTo32();\n      s.protocolFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.BuyoutFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.buyoutFeeNumerator = numerator.safeCastTo32();\n      s.buyoutFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.MinInterestBPS) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minInterestBPS = value.safeCastTo32();\n    } else if (what == FileType.MinDurationIncrease) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minDurationIncrease = value.safeCastTo32();\n    } else if (what == FileType.MinEpochLength) {\n      s.minEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxEpochLength) {\n      s.maxEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxInterestRate) {\n      s.maxInterestRate = abi.decode(data, (uint256)).safeCastTo88();\n    } else if (what == FileType.FeeTo) {\n      address addr = abi.decode(data, (address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.feeTo = addr;\n    } else if (what == FileType.StrategyValidator) {\n      (uint8 TYPE, address addr) = abi.decode(data, (uint8, address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.strategyValidators[TYPE] = addr;\n    } else {\n      revert UnsupportedFile();\n    }\n\n    emit FileUpdated(what, data);\n  }\n\n  function setNewGuardian(address _guardian) external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == s.guardian);\n    s.newGuardian = _guardian;\n  }\n\n  function __renounceGuardian() external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == s.guardian);\n    s.guardian = address(0);\n    s.newGuardian = address(0);\n  }\n\n  function __acceptGuardian() external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == s.newGuardian);\n    s.guardian = s.newGuardian;\n    delete s.newGuardian;\n  }\n\n  function fileGuardian(File[] calldata file) external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == address(s.guardian));\n\n    uint256 i;\n    for (; i < file.length; ) {\n      FileType what = file[i].what;\n      bytes memory data = file[i].data;\n      if (what == FileType.Implementation) {\n        (uint8 implType, address addr) = abi.decode(data, (uint8, address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.implementations[implType] = addr;\n      } else if (what == FileType.CollateralToken) {\n        address addr = abi.decode(data, (address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.COLLATERAL_TOKEN = ICollateralToken(addr);\n      } else if (what == FileType.LienToken) {\n        address addr = abi.decode(data, (address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.LIEN_TOKEN = ILienToken(addr);\n      } else if (what == FileType.TransferProxy) {\n        address addr = abi.decode(data, (address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.TRANSFER_PROXY = ITransferProxy(addr);\n      } else {\n        revert UnsupportedFile();\n      }\n      emit FileUpdated(what, data);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  //PUBLIC\n\n  function getImpl(uint8 implType) external view returns (address impl) {\n    impl = _loadRouterSlot().implementations[implType];\n    if (impl == address(0)) {\n      revert(\"unsupported/impl\");\n    }\n  }\n\n  function getAuctionWindow(bool includeBuffer) public view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.auctionWindow + (includeBuffer ? s.auctionWindowBuffer : 0);\n  }\n\n  function _sliceUint(bytes memory bs, uint256 start)\n    internal\n    pure\n    returns (uint256 x)\n  {\n    uint256 length = bs.length;\n\n    assembly {\n      let end := add(ONE_WORD, start)\n\n      if lt(length, end) {\n        mstore(0, OUTOFBOUND_ERROR_SELECTOR)\n        revert(0, ONE_WORD)\n      }\n\n      x := mload(add(bs, end))\n    }\n  }\n\n  function validateCommitment(\n    IAstariaRouter.Commitment calldata commitment,\n    uint256 timeToSecondEpochEnd\n  ) public view returns (ILienToken.Lien memory lien) {\n    return\n      _validateCommitment(_loadRouterSlot(), commitment, timeToSecondEpochEnd);\n  }\n\n  function _validateCommitment(\n    RouterStorage storage s,\n    IAstariaRouter.Commitment calldata commitment,\n    uint256 timeToSecondEpochEnd\n  ) internal view returns (ILienToken.Lien memory lien) {\n    if (block.timestamp > commitment.lienRequest.strategy.deadline) {\n      revert InvalidCommitmentState(CommitmentState.EXPIRED);\n    }\n    uint8 nlrType = uint8(_sliceUint(commitment.lienRequest.nlrDetails, 0));\n    address strategyValidator = s.strategyValidators[nlrType];\n    if (strategyValidator == address(0)) {\n      revert InvalidStrategy(nlrType);\n    }\n    (bytes32 leaf, ILienToken.Details memory details) = IStrategyValidator(\n      strategyValidator\n    ).validateAndParse(\n        commitment.lienRequest,\n        s.COLLATERAL_TOKEN.ownerOf(\n          commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n      );\n\n    if (details.rate == uint256(0) || details.rate > s.maxInterestRate) {\n      revert InvalidCommitmentState(CommitmentState.INVALID_RATE);\n    }\n\n    if (details.maxAmount < commitment.lienRequest.amount) {\n      revert InvalidCommitmentState(CommitmentState.INVALID_AMOUNT);\n    }\n\n    if (\n      !MerkleProofLib.verify(\n        commitment.lienRequest.merkle.proof,\n        commitment.lienRequest.merkle.root,\n        leaf\n      )\n    ) {\n      revert InvalidCommitmentState(CommitmentState.INVALID);\n    }\n\n    if (timeToSecondEpochEnd > 0 && details.duration > timeToSecondEpochEnd) {\n      details.duration = timeToSecondEpochEnd;\n    }\n\n    lien = ILienToken.Lien({\n      collateralType: nlrType,\n      details: details,\n      strategyRoot: commitment.lienRequest.merkle.root,\n      collateralId: commitment.tokenContract.computeId(commitment.tokenId),\n      vault: commitment.lienRequest.strategy.vault,\n      token: IAstariaVaultBase(commitment.lienRequest.strategy.vault).asset()\n    });\n  }\n\n  function commitToLiens(IAstariaRouter.Commitment[] memory commitments)\n    public\n    whenNotPaused\n    returns (uint256[] memory lienIds, ILienToken.Stack[] memory stack)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n\n    uint256 totalBorrowed;\n    lienIds = new uint256[](commitments.length);\n    _transferAndDepositAssetIfAble(\n      s,\n      commitments[0].tokenContract,\n      commitments[0].tokenId\n    );\n\n    uint256 i;\n    for (; i < commitments.length; ) {\n      if (i != 0) {\n        commitments[i].lienRequest.stack = stack;\n      }\n      uint256 payout;\n      (lienIds[i], stack, payout) = _executeCommitment(s, commitments[i]);\n      totalBorrowed += payout;\n      unchecked {\n        ++i;\n      }\n    }\n\n    ERC20(IAstariaVaultBase(commitments[0].lienRequest.strategy.vault).asset())\n      .safeTransfer(msg.sender, totalBorrowed);\n  }\n\n  function newVault(address delegate, address underlying)\n    external\n    whenNotPaused\n    returns (address)\n  {\n    address[] memory allowList = new address[](1);\n    allowList[0] = msg.sender;\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      _newVault(\n        s,\n        underlying,\n        uint256(0),\n        delegate,\n        uint256(0),\n        true,\n        allowList,\n        uint256(0)\n      );\n  }\n\n  function newPublicVault(\n    uint256 epochLength,\n    address delegate,\n    address underlying,\n    uint256 vaultFee,\n    bool allowListEnabled,\n    address[] calldata allowList,\n    uint256 depositCap\n  ) public whenNotPaused returns (address) {\n    RouterStorage storage s = _loadRouterSlot();\n    if (s.minEpochLength > epochLength) {\n      revert IPublicVault.InvalidState(\n        IPublicVault.InvalidStates.EPOCH_TOO_LOW\n      );\n    }\n    if (s.maxEpochLength < epochLength) {\n      revert IPublicVault.InvalidState(\n        IPublicVault.InvalidStates.EPOCH_TOO_HIGH\n      );\n    }\n    return\n      _newVault(\n        s,\n        underlying,\n        epochLength,\n        delegate,\n        vaultFee,\n        allowListEnabled,\n        allowList,\n        depositCap\n      );\n  }\n\n  function requestLienPosition(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    validVault(msg.sender)\n    returns (\n      uint256,\n      ILienToken.Stack[] memory,\n      uint256\n    )\n  {\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      s.LIEN_TOKEN.createLien(\n        ILienToken.LienActionEncumber({\n          lien: _validateCommitment({\n            s: s,\n            commitment: params,\n            timeToSecondEpochEnd: IPublicVault(msg.sender).supportsInterface(\n              type(IPublicVault).interfaceId\n            )\n              ? IPublicVault(msg.sender).timeToSecondEpochEnd()\n              : 0\n          }),\n          amount: params.lienRequest.amount,\n          stack: params.lienRequest.stack,\n          receiver: receiver\n        })\n      );\n  }\n\n  function canLiquidate(ILienToken.Stack memory stack)\n    public\n    view\n    returns (bool)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n    return (stack.point.end <= block.timestamp ||\n      msg.sender == s.COLLATERAL_TOKEN.ownerOf(stack.lien.collateralId));\n  }\n\n  function liquidate(ILienToken.Stack[] memory stack, uint8 position)\n    public\n    returns (OrderParameters memory listedOrder)\n  {\n    if (!canLiquidate(stack[position])) {\n      revert InvalidLienState(LienState.HEALTHY);\n    }\n\n    RouterStorage storage s = _loadRouterSlot();\n    uint256 auctionWindowMax = s.auctionWindow + s.auctionWindowBuffer;\n\n    s.LIEN_TOKEN.stopLiens(\n      stack[position].lien.collateralId,\n      auctionWindowMax,\n      stack,\n      msg.sender\n    );\n    emit Liquidation(stack[position].lien.collateralId, position);\n    listedOrder = s.COLLATERAL_TOKEN.auctionVault(\n      ICollateralToken.AuctionVaultParams({\n        settlementToken: stack[position].lien.token,\n        collateralId: stack[position].lien.collateralId,\n        maxDuration: auctionWindowMax,\n        startingPrice: stack[0].lien.details.liquidationInitialAsk,\n        endingPrice: 1_000 wei\n      })\n    );\n  }\n\n  function getProtocolFee(uint256 amountIn) external view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      amountIn.mulDivDown(s.protocolFeeNumerator, s.protocolFeeDenominator);\n  }\n\n  function getLiquidatorFee(uint256 amountIn) external view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      amountIn.mulDivDown(\n        s.liquidationFeeNumerator,\n        s.liquidationFeeDenominator\n      );\n  }\n\n  function getBuyoutFee(uint256 remainingInterestIn)\n    external\n    view\n    returns (uint256)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n    return\n      remainingInterestIn.mulDivDown(\n        s.buyoutFeeNumerator,\n        s.buyoutFeeDenominator\n      );\n  }\n\n  function isValidVault(address vault) public view returns (bool) {\n    return _loadRouterSlot().vaults[vault];\n  }\n\n  function isValidRefinance(\n    ILienToken.Lien calldata newLien,\n    uint8 position,\n    ILienToken.Stack[] calldata stack\n  ) public view returns (bool) {\n    RouterStorage storage s = _loadRouterSlot();\n    uint256 maxNewRate = uint256(stack[position].lien.details.rate) -\n      s.minInterestBPS;\n\n    if (newLien.collateralId != stack[0].lien.collateralId) {\n      revert InvalidRefinanceCollateral(newLien.collateralId);\n    }\n    return\n      (newLien.details.rate <= maxNewRate &&\n        newLien.details.duration + block.timestamp >=\n        stack[position].point.end) ||\n      (block.timestamp + newLien.details.duration - stack[position].point.end >=\n        s.minDurationIncrease &&\n        newLien.details.rate <= stack[position].lien.details.rate);\n  }\n\n  /**\n   * @dev Deploys a new Vault.\n   * @param epochLength The length of each epoch for a new PublicVault. If 0, deploys a PrivateVault.\n   * @param delegate The address of the Vault delegate.\n   * @param allowListEnabled Whether or not the Vault has an LP whitelist.\n   * @return vaultAddr The address for the new Vault.\n   */\n  function _newVault(\n    RouterStorage storage s,\n    address underlying,\n    uint256 epochLength,\n    address delegate,\n    uint256 vaultFee,\n    bool allowListEnabled,\n    address[] memory allowList,\n    uint256 depositCap\n  ) internal returns (address vaultAddr) {\n    uint8 vaultType;\n\n    if (epochLength > uint256(0)) {\n      vaultType = uint8(ImplementationType.PublicVault);\n    } else {\n      vaultType = uint8(ImplementationType.PrivateVault);\n    }\n\n    //immutable data\n    vaultAddr = ClonesWithImmutableArgs.clone(\n      s.BEACON_PROXY_IMPLEMENTATION,\n      abi.encodePacked(\n        address(this),\n        vaultType,\n        msg.sender,\n        underlying,\n        block.timestamp,\n        epochLength,\n        vaultFee\n      )\n    );\n\n    //mutable data\n    IVaultImplementation(vaultAddr).init(\n      IVaultImplementation.InitParams({\n        delegate: delegate,\n        allowListEnabled: allowListEnabled,\n        allowList: allowList,\n        depositCap: depositCap\n      })\n    );\n\n    s.vaults[vaultAddr] = true;\n\n    emit NewVault(msg.sender, delegate, vaultAddr, vaultType);\n\n    return vaultAddr;\n  }\n\n  function _executeCommitment(\n    RouterStorage storage s,\n    IAstariaRouter.Commitment memory c\n  )\n    internal\n    returns (\n      uint256,\n      ILienToken.Stack[] memory stack,\n      uint256 payout\n    )\n  {\n    uint256 collateralId = c.tokenContract.computeId(c.tokenId);\n\n    if (msg.sender != s.COLLATERAL_TOKEN.ownerOf(collateralId)) {\n      revert InvalidSenderForCollateral(msg.sender, collateralId);\n    }\n    if (!s.vaults[c.lienRequest.strategy.vault]) {\n      revert InvalidVault(c.lienRequest.strategy.vault);\n    }\n    //router must be approved for the collateral to take a loan,\n    return\n      IVaultImplementation(c.lienRequest.strategy.vault).commitToLien(\n        c,\n        address(this)\n      );\n  }\n\n  function _transferAndDepositAssetIfAble(\n    RouterStorage storage s,\n    address tokenContract,\n    uint256 tokenId\n  ) internal {\n    ERC721 token = ERC721(tokenContract);\n    if (token.ownerOf(tokenId) == msg.sender) {\n      token.safeTransferFrom(\n        msg.sender,\n        address(s.COLLATERAL_TOKEN),\n        tokenId,\n        \"\"\n      );\n    }\n  }\n}"
    },
    {
      "filename": "src/AstariaRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IVaultImplementation} from \"core/interfaces/IVaultImplementation.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {IStrategyValidator} from \"core/interfaces/IStrategyValidator.sol\";\n\nimport {MerkleProofLib} from \"core/utils/MerkleProofLib.sol\";\nimport {Pausable} from \"core/utils/Pausable.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {ERC4626Router} from \"gpl/ERC4626Router.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title AstariaRouter\n * @notice This contract manages the deployment of Vaults and universal Astaria actions.\n */\ncontract AstariaRouter is\n  AuthInitializable,\n  Initializable,\n  ERC4626Router,\n  Pausable,\n  IAstariaRouter\n{\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  uint256 private constant ROUTER_SLOT =\n    uint256(keccak256(\"xyz.astaria.AstariaRouter.storage.location\")) - 1;\n\n  // cast --to-bytes32 $(cast sig \"O"
    }
  ]
}