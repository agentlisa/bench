{
  "Title": "M-5: Exponential and logarithmic price adapters will return incorrect pricing when moving from higher dp token to lower dp token",
  "Content": "# Issue M-5: Exponential and logarithmic price adapters will return incorrect pricing when moving from higher dp token to lower dp token \n\nSource: https://github.com/sherlock-audit/2023-06-Index-judging/issues/42 \n\n## Found by \n0x52\n## Summary\n\nThe exponential and logarithmic price adapters do not work correctly when used with token pricing of different decimal places. This is because the resolution of the underlying expWad and lnWad functions is not fit for tokens that aren't 18 dp.\n\n## Vulnerability Detail\n\n[AuctionRebalanceModuleV1.sol#L856-L858](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L856-L858)\n\n    function _calculateQuoteAssetQuantity(bool isSellAuction, uint256 _componentQuantity, uint256 _componentPrice) private pure returns (uint256) {\n        return isSellAuction ? _componentQuantity.preciseMulCeil(_componentPrice) : _componentQuantity.preciseMul(_componentPrice);\n    }\n\nThe price returned by the adapter is used directly to call _calculateQuoteAssetQuantity which uses preciseMul/preciseMulCeil to convert from component amount to quote amount. Assume we wish to sell 1 WETH for 2,000 USDT. WETH is 18dp while USDT is 6dp giving us the following price:\n\n    1e18 * price / 1e18 = 2000e6\n\nSolving for price gives:\n\n    price = 2000e6\n\nThis establishes that the price must be scaled to:\n\n    price dp = 18 - component dp + quote dp\n\nPlugging in our values we see that our scaling of 6 dp makes sense.\n\n[BoundedStepwiseExponentialPriceAdapter.sol#L67-L80](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L67-L80)\n\n        uint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\n        // Protect against priceChange overflow\n        if (scalingFactor > type(uint256).max / expExpression) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = scalingFactor * expExpression - WAD;\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n\nGiven the pricing code and notably the simple scalingFactor it also means that priceChange must be in the same order of magnitude as the price which in this case is 6 dp. The issue is that on such small scales, both lnWad and expWad do not behave as expected and instead yield a linear behavior. This is problematic as the curve will produce unexpected behaviors under these circumstances selling the tokens at the wrong price. Since both functions are written in assembly it is very difficult to determine exactly what is going on or why this occurs but testing in remix gives the following values:\n\n    expWad(1e6) - WAD = 1e6\n    expWad(5e6) - WAD = 5e6\n    expWad(10e6) - WAD = 10e6\n    expWad(1000e6) - WAD = 1000e6\n\nAs seen above these value create a perfect linear scaling and don't exhibit any exponential qualities. Given the range of this linearity it means that these adapters can never work when selling from higher to lower dp tokens. \n\n## Impact\n\nExponential and logarithmic pricing is wrong when tokens have mismatched dp\n\n## Code Snippet\n\n[BoundedStepwiseExponentialPriceAdapter.sol#L28-L88](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L28-L88)\n\n[BoundedStepwiseLogarithmicPriceAdapter.sol#L28-L88](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseLogarithmicPriceAdapter.sol#L28-L88)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nscalingFactor should be scaled to 18 dp then applied via preciseMul instead of simple multiplication. This allows lnWad and expWad to execute in 18 dp then be scaled down to the correct dp.\n\n\n\n## Discussion\n\n**pblivin0x**\n\nAgree that scalingFactor should be 18 decimals and applied with preciseMul, will fix. \n\n**Oot2k**\n\nNot a duplicate \n\n**bizzyvinci**\n\nEscalate\n\nThis is invalid\n\n`FixedPointMathLib.expWad` and `FixedPointMathLib.lnWad` uses WAD as input and WAD as output. This is mentioned in [docs](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol#L120) and you can test it out on remix. Therefore, `exp(1) = FixedPointMathLib.expWad(WAD) / WAD` and `exp(5) = FixedPointMathLib.expWad(5*WAD) / WAD`.\n\n`expWad(1e6) - WAD = 1e6` is equal to `exp(1e-12) - 1 = 1e-12` which is absolutely correct.\n\nFor the formula to work, timeCoefficient has to be in WAD. @pblivin0x  should look at our DM around this time.\n\n<img width=\"840\" alt=\"Screenshot 2023-08-01 at 09 46 44\" src=\"https://github.com/sherlock-audit/2023-06-Index-judging/assets/22333930/1b224171-5a20-4836-95f6-3ed78078dda0\">\n\n\nHis comment: `scalingFactor should be 18 decimals and applied with preciseMul` is on a different matter. It's a plan for the future to allow decimal scalingFactor e.g 0.5, 2.5 rather than just integers like 1, 2, 3 etc.\n\nTo recap: \n`block.timestamp` is in seconds, therefore `timeBucket`, `_timeElapsed` and `bucketSize` are in seconds.\n`_componentPrice`, `initialPrice`, `minPrice`, `maxPrice`, `priceChange` and `FixedPointMathLib` are in WAD.\nTherefore, `expExpression`, `expArgument` and `timeCoefficient` has to also be in WAD.\n`scalingFactor` is just a scaler unit which the team plan to turn into WAD in the future for more precision with scaling.\n\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is invalid\n> \n> `FixedPointMathLib.expWad` and `FixedPointMathLib.lnWad` uses WAD as input and WAD as output. This is mentioned in [docs](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol#L120) and you can test it out on remix. Therefore, `exp(1) = FixedPointMathLib.expWad(WAD) / WAD` and `exp(5) = FixedPointMathLib.expWad(5*WAD) / WAD`.\n> \n> `expWad(1e6) - WAD = 1e6` is equal to `exp(1e-12) - 1 = 1e-12` which is absolutely correct.\n> \n> For the formula to work, timeCoefficient has to be in WAD. @pblivin0x  should look at our DM around this time.\n> \n> <img width=\"840\" alt=\"Screenshot 2023-08-01 at 09 46 44\" src=\"https://github.com/sherlock-audit/2023-06-Index-judging/assets/22333930/1b224171-5a20-4836-95f6-3ed78078dda0\">\n> \n> \n> His comment: `scalingFactor should be 18 decimals and applied with preciseMul` is on a different matter. It's a plan for the future to allow decimal scalingFactor e.g 0.5, 2.5 rather than just integers like 1, 2, 3 etc.\n> \n> To recap: \n> `block.timestamp` is in seconds, therefore `timeBucket`, `_timeElapsed` and `bucketSize` are in seconds.\n> `_componentPrice`, `initialPrice`, `minPrice`, `maxPrice`, `priceChange` and `FixedPointMathLib` are in WAD.\n> Therefore, `expExpression`, `expArgument` and `timeCoefficient` has to also be in WAD.\n> `scalingFactor` is just a scaler unit which the team plan to turn into WAD in the future for more precision with scaling.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nSince scaling factor is not applied via precise mul in the current implementation, in order to work as the code is written it has to be have the same number of decimals as price and therefore can't be WAD, regardless of what sponsor has said in the discord comments. As I've shown in my issue these smaller values are not compatible with expWAD and lnWAD and will produce incorrect values, negatively affecting auction pricing. \n\n**bizzyvinci**\n\nThe [getPrice function](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L28-L88) can be broken down to the following after removing `boundary price` and type conversions.\n\n1. timeBucket = _timeElapsed / bucketSize\n2. expArgument = timeCoefficient * timeBucket\n3. expExpression = FixedPointMathLib.expWad(expArgument)\n4. priceChange = scalingFactor * expExpression - WAD\n5. price = initialPrice + priceChange (or minus)\n\nTo know what unit should be WAD or not, we need to look elsewhere.\n1. `_timeElapsed = block.timestamp - rebalanceInfo[_setToken].rebalanceStartTime` [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L806) and `rebalanceInfo[_setToken].rebalanceStartTime` is set to `block.timestamp` when startRebalance is called [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L275). Therefore `_timeElapsed`, `bucketSize` and `timeBucket` has to be seconds.\n2. `_componentPrice` is in precise unit or WAD based on calculation [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L857). Therefore `price`, `initialPrice` and `priceChange` have to also be in WAD.\n3. Formula 4 is wrong as pointed out in #39 therefore let's just focus on the multiplication part and assume `priceChange = scalingFactor * expExpression`. If `priceChange` is `WAD`, then `scalingFactor * expExpression` has to be WAD. Either `scalingFactor is WAD` or `expExpression` is WAD.\n4. FixedPointMathLib.expWad returns WAD, so `expExpression` is indeed WAD. So `scalingFactor` is basic unit.\n5. Furthermore, `FixedPointMathLib.expWad` takes WAD as input, and that input is `timeCoefficient * timeBucket`. We've established that `timeBucket` is seconds in 1, so therefore `timeCoefficient` has to be WAD.\n\nThe sponsor's message was referenced because \n* I was the one who decided that his initial statement `timeCoefficient and bucketSize are not in WAD` is wrong. So he might want to cross-check things again.\n* We had some discussions about scalingFactor and converting it to WAD around that time.\n\nIf scalingFactor is changed to WAD, then priceChange would be `WAD^2`. Therefore, we must use preciseMul to keep things balanced again. P.S: -WAD is ignored again.\n```solidity\n+ priceChange = scalingFactorWAD.preciseMul(expExpression)\n- priceChange = scalingFactorBasic * expExpression\n```\n\nThe 2 formula are the same thing because `preciseMul(a, b) = a * b / WAD` [code](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol#L94-L96)\n```solidity\nfunction preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a.mul(b).div(PRECISE_UNIT);\n}\n```\n\n**IAm0x52**\n\n> _componentPrice is in precise unit or WAD based on calculation [here](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L857). Therefore price, initialPrice and priceChange have to also be in WAD.\n\nThis is incorrect. I've proven in my submission above that when going from an 18 dp token to 6 dp that price has to be 6 dp. Since scalingFactor is applied as a scaler and not via preciseMul then expArgument and expExpression have to also be in 6 dp as well. If you used a WAD expression for them the pricing would be completely wrong as it would return an 18 dp price. As I've shown expWAD returns incorrectly when inputting a 6 dp number.\n\n**IAm0x52**\n\nThe point of this issue is to prove that scaling factor must be applied via preciseMul or else the price cannot work as expect. To just say \"scaling factor should be applied via preciseMul\" is not a valid issue unless you can show why it's incorrect that it's not applied that way and the damages that it causes. \n\n**bizzyvinci**\n\nprecise unit is used for precision in calculation because the numbers could be very small and solidity does automatic rounding. When multiplying or dividing, preciseMul or preciseDiv is used to finally get rid of that precision. You can view the [PreciseUnitMath library](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol) and the key take away are\n1. `PRECISE_UNIT = PRECISE_UNIT_INT = WAD = 1e18`\n2. `preciseMul(a, b) = a * b / WAD` and that only makes sense if a or b is WAD\n3. `preciseDiv(a, b) = a * WAD / b` and that only makes sense if b is WAD\n\nNow, why is `_componentPrice` in WAD? \nBecause `_componentQuantity` and the returned `quoteAssetQuantity` are not in WAD and preciseMul needs `b` to be WAD. `_componentQuantity` and `quoteAssetQuantity` are the raw quantity amount that would be transferred with `token.transfer`.\n\nhttps://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L856-858\n```solidity\nfunction _calculateQuoteAssetQuantity(bool isSellAuction, uint256 _componentQuantity, uint256 _componentPrice) private pure returns (uint256) {\n      return isSellAuction ? _componentQuantity.preciseMulCeil(_componentPrice) : _componentQuantity.preciseMul(_componentPrice);\n  }\n```\n\n\n**pblivin0x**\n\nI believe this is a valid medium\n\n**Oot2k**\n\nI agree that this is valid medium\n\n**bizzyvinci**\n\nI still stand by my escalation and I think my proof is sufficient cause it proves the following\n* _componentPrice in WAD\n* Right now, scalingFactor is not WAD cause that would be mathematically wrong. It must be a normal integer.\n* The unit of each parameters (e.g which one is seconds, WAD or int) to show that price does work correctly.\n* The team plans to make scalingFactor WAD and use preciseMul. They **must** use preciseMul to make sure priceChange remains a WAD (rather than WAD^2)\n* The migration of scalingFactor from integer scalar to WAD scalar **would not** change price nor priceChange because `preciseMul(a,b) = a * b / WAD`\n* The only effect the migration has is precision. scalingFactor could then be represented as decimals instead of just integers. \n\n\nIf anyone disagrees it would be nice if they state why. Or if there's a point that wasn't clear, I'm here to clarify.\n\n**bizzyvinci**\n\nI understand the proof might be daunting to comprehend so I'll recommend using pen and paper (and maybe remix with calculator) to make things easier.\n\n**bizzyvinci**\n\nI do agree that my escalation be rejected\n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this a valid medium based on the above comments. \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [bizzyvinci](https://github.com/sherlock-audit/2023-06-Index-judging/issues/42/#issuecomment-1659888928): rejected\n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe changes are to update to 18 decimal `scalingFactor` in both the exponential and logarithmic adapter\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73\n+ https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseLogarithmicPriceAdapter.sol#L73\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/91",
  "Code": [
    {
      "filename": "index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol",
      "content": "/*\n    Copyright 2023 Index Coop\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental \"ABIEncoderV2\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/math/Math.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport { AddressArrayUtils } from \"../../../lib/AddressArrayUtils.sol\";\nimport { IAuctionPriceAdapterV1 } from \"../../../interfaces/IAuctionPriceAdapterV1.sol\";\nimport { IController } from \"../../../interfaces/IController.sol\";\nimport { Invoke } from \"../../lib/Invoke.sol\";\nimport { ISetToken } from \"../../../interfaces/ISetToken.sol\";\nimport { ModuleBase } from \"../../lib/ModuleBase.sol\";\nimport { Position } from \"../../lib/Position.sol\";\nimport { PreciseUnitMath } from \"../../../lib/PreciseUnitMath.sol\";\n\n/**\n * @title AuctionRebalanceModuleV1\n * @author Index Coop\n * @notice Facilitates rebalances for index sets via single-asset auctions. Managers initiate\n * rebalances specifying target allocations in precise units (scaled by 10^18), quote asset\n * (e.g., WETH, USDC), auction parameters per component, and rebalance duration through\n * startRebalance(). Bidders can participate via bid() for individual components. Excess\n * quote asset can be managed by proportionally increasing the targets using raiseAssetTargets().\n *\n * @dev Compatible with StreamingFeeModule and BasicIssuanceModule. Review compatibility if used\n * with additional modules.\n */\ncontract AuctionRebalanceModuleV1 is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n\n    /* ============ Structs ============ */\n\n    struct AuctionExecutionParams {\n        uint256 targetUnit;                      // Target quantity of the component in Set, in precise units (10 ** 18).\n        string priceAdapterName;                 // Identifier for the price adapter to be used.\n        bytes priceAdapterConfigData;            // Encoded data for configuring the chosen price adapter.\n    }\n\n    struct BidPermissionInfo {\n        bool isAnyoneAllowedToBid;               // Flag indicating if bids are open to anyone (true) or restricted (false).\n        address[] biddersHistory;                // List of addresses that have been permissioned to bid.\n        mapping(address => bool) bidAllowList;   // Mapping of addresses to a boolean indicating if they are allowed to bid.\n    }\n\n    struct RebalanceInfo {\n        IERC20 quoteAsset;                       // Reference to the ERC20 token used to quote auctions.\n        uint256 rebalanceStartTime;              // Unix timestamp marking the start of the rebalance.\n        uint256 rebalanceDuration;               // Duration of the rebalance in seconds.\n        uint256 positionMultiplier;              // Position multiplier when target units were calculated.\n        uint256 raiseTargetPercentage;           // Optional percentage to increase all target units if allowed, in precise units.\n        address[] rebalanceComponents;           // List of component tokens involved in the rebalance.\n    }\n\n    struct BidInfo {\n        ISetToken setToken;                      // Instance of the SetToken contract that is being rebalanced.\n        IERC20 sendToken;                        // The ERC20 token being sent in this bid.\n        IERC20 receiveToken;                     // The ERC20 token being received in this bid.\n        IAuctionPriceAdapterV1 priceAdapter;     // Instance of the price adapter contract used for this bid.\n        bytes priceAdapterConfigData;            // Data for configuring the price adapter.\n        bool isSellAuction;                      // Indicates if this is a sell auction (true) or a buy auction (false).\n        uint256 auctionQuantity;                 // The quantity of the component being auctioned.\n        uint256 componentPrice;                  // The price of the component as quoted by the price adapter.\n        uint256 quantitySentBySet;               // Quantity of tokens sent by SetToken in this bid.\n        uint256 quantityReceivedBySet;           // Quantity of tokens received by SetToken in this bid.\n        uint256 preBidTokenSentBalance;          // Balance of tokens being sent by SetToken before the bid.\n        uint256 preBidTokenReceivedBalance;      // Balance of tokens being received by SetToken before the bid.\n        uint256 setTotalSupply;                  // Total supply of the SetToken at the time of the bid.\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @dev Emitted when the target percentage increase is modified via setRaiseTargetPercentage()\n     * @param setToken                   Reference to the SetToken undergoing rebalancing\n     * @param newRaiseTargetPercentage   Updated percentage for potential target unit increases, in precise units (10 ** 18)\n     */\n    event RaiseTargetPercentageUpdated(\n        ISetToken indexed setToken, \n        uint256 newRaiseTargetPercentage\n    );\n\n    /**\n     * @dev Emitted upon calling raiseAssetTargets()\n     * @param setToken                Reference to the SetToken undergoing rebalancing\n     * @param newPositionMultiplier   Updated position multiplier for the SetToken rebalance\n     */\n    event AssetTargetsRaised(\n        ISetToken indexed setToken, \n        uint256 newPositionMultiplier\n    );\n\n    /**\n     * @dev Emitted upon toggling the bid permission setting via setAnyoneBid()\n     * @param setToken               Reference to the SetToken undergoing rebalancing\n     * @param isAnyoneAllowedToBid   Flag indicating if bids are open to all (true) or restricted (false)\n     */\n    event AnyoneBidUpdated(\n        ISetToken indexed setToken, \n        bool isAnyoneAllowedToBid\n    );\n\n    /**\n     * @dev Emitted when the bidding status of an address is changed via setBidderStatus()\n     * @param setToken          Reference to the SetToken undergoing rebalancing\n     * @param bidder            Address whose bidding permission status is toggled\n     * @param isBidderAllowed   Flag indicating if the address is allowed (true) or not allowed (false) to bid\n     */\n    event BidderStatusUpdated(\n        ISetToken indexed setToken, \n        address indexed bidder, \n        bool isBidderAllowed\n    );\n\n    /**\n     * @dev Emitted when a rebalance is initiated using the startRebalance() function.\n     * @param setToken                    Instance of the SetToken contract that is undergoing rebalancing.\n     * @param quoteAsset                  The ERC20 token that is used as a quote currency for the auctions.\n     * @param isSetTokenLocked            Indicates if the rebalance process locks the SetToken (true) or not (false).\n     * @param rebalanceDuration           Duration of the rebalance process in seconds.\n     * @param initialPositionMultiplier   Position multiplier when target units were calculated.\n     * @param componentsInvolved          Array of addresses of the component tokens involved in the rebalance.\n     * @param auctionParameters           Array of AuctionExecutionParams structs, containing auction parameters for each component token.\n     */\n    event RebalanceStarted(\n        ISetToken indexed setToken,\n        IERC20 indexed quoteAsset,\n        bool isSetTokenLocked,\n        uint256 rebalanceDuration,\n        uint256 initialPositionMultiplier,\n        address[] componentsInvolved,\n        AuctionExecutionParams[] auctionParameters\n    );\n\n    /**\n     * @dev Emitted upon execution of a bid via the bid() function.\n     * @param setToken                   Instance of the SetToken contract that is being rebalanced.\n     * @param sendToken                  The ERC20 token that is being sent by the bidder.\n     * @param receiveToken               The ERC20 token that is being received by the bidder.\n     * @param bidder                     The address of the bidder.\n     * @param priceAdapter               Instance of the price adapter contract used for this bid.\n     * @param isSellAuction              Indicates if this is a sell auction (true) or a buy auction (false).\n     * @param price                      The price of the component in precise units (10 ** 18).\n     * @param netQuantitySentBySet       The net amount of tokens sent by the SetToken in the bid.\n     * @param netQuantityReceivedBySet   The net amount of tokens received by the SetToken in the bid.\n     * @param protocolFee                The amount of the received token allocated as a protocol fee.\n     * @param setTotalSupply             The total supply of the SetToken at the time of the bid.\n     */\n    event BidExecuted(\n        ISetToken indexed setToken,\n        address indexed sendToken,\n        address indexed receiveToken,\n        address bidder,\n        IAuctionPriceAdapterV1 priceAdapter,\n        bool isSellAuction,\n        uint256 price,\n        uint256 netQuantitySentBySet,\n        uint256 netQuantityReceivedBySet,\n        uint256 protocolFee,\n        uint256 setTotalSupply\n    );\n\n    /**\n     * @dev Emitted when a locked rebalance is concluded early via the unlock() function.\n     * @param setToken            Instance of the SetToken contract that is being rebalanced.\n     */\n    event LockedRebalanceEndedEarly(\n        ISetToken indexed setToken\n    );\n\n\n    /* ============ Constants ============ */\n\n    uint256 private constant AUCTION_MODULE_V1_PROTOCOL_FEE_INDEX = 0;   // Index of the protocol fee percentage assigned to this module in the Controller.\n\n    /* ============ State Variables ============ */\n\n    mapping(ISetToken => mapping(IERC20 => AuctionExecutionParams)) public executionInfo;   // Maps SetToken to component tokens and their respective auction execution parameters.\n    mapping(ISetToken => BidPermissionInfo) public permissionInfo;                          // Maps SetToken to information regarding bid permissions during a rebalance.\n    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Maps SetToken to data relevant to the most recent rebalance.\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyAllowedBidder(ISetToken _setToken) {\n        _validateOnlyAllowedBidder(_setToken);\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    constructor(IController _controller) public ModuleBase(_controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev MANAGER ONLY: Initiates the rebalance process by setting target allocations for the SetToken. Opens auctions\n     * for filling by the Set's designated bidders. The function takes in new components to be added with their target units\n     * and existing components with updated target units (set to 0 if removing). A positionMultiplier is supplied to adjust\n     * target units, e.g., in cases where fee accrual affects the positionMultiplier of the SetToken, ensuring proportional\n     * allocation among components. If target allocations are not met within the specified duration, the rebalance concludes\n     * with the allocations achieved.\n     *\n     * @param _setToken                     The SetToken to be rebalanced.\n     * @param _quoteAsset                   ERC20 token used as the quote asset in auctions.\n     * @param _newComponents                Addresses of new components to be added.\n     * @param _newComponentsAuctionParams   AuctionExecutionParams for new components, indexed corresponding to _newComponents.\n     * @param _oldComponentsAuctionParams   AuctionExecutionParams for existing components, indexed corresponding to\n     *                                      the current component positions. Set to 0 for components being removed.\n     * @param _shouldLockSetToken           Indicates if the rebalance should lock the SetToken.\n     * @param _rebalanceDuration            Duration of the rebalance in seconds.\n     * @param _initialPositionMultiplier    Position multiplier at the start of the rebalance.\n     */\n    function startRebalance(\n        ISetToken _setToken,\n        IERC20 _quoteAsset,\n        address[] calldata _newComponents,\n        AuctionExecutionParams[] memory _newComponentsAuctionParams,\n        AuctionExecutionParams[] memory _oldComponentsAuctionParams,\n        bool _shouldLockSetToken,\n        uint256 _rebalanceDuration,\n        uint256 _initialPositionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Lock the SetToken if the _shouldLockSetToken flag is true and the SetToken is not already locked by this module\n        if (_shouldLockSetToken && _setToken.locker() != address(this)) {\n            _setToken.lock();\n        }\n\n        // Aggregate components and auction parameters\n        (address[] memory allComponents, AuctionExecutionParams[] memory allAuctionParams) = _aggregateComponentsAndAuctionParams(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsAuctionParams,\n            _oldComponentsAuctionParams\n        );\n\n        // Set the execution information\n        for (uint256 i = 0; i < allComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(allComponents[i]), \"External positions not allowed\");\n            executionInfo[_setToken][IERC20(allComponents[i])] = allAuctionParams[i];\n        }\n\n        // Set the rebalance information\n        rebalanceInfo[_setToken].quoteAsset = _quoteAsset;\n        rebalanceInfo[_setToken].rebalanceStartTime = block.timestamp;\n        rebalanceInfo[_setToken].rebalanceDuration = _rebalanceDuration;\n        rebalanceInfo[_setToken].positionMultiplier = _initialPositionMultiplier;\n        rebalanceInfo[_setToken].rebalanceComponents = allComponents;\n\n        // Emit the RebalanceStarted event\n        emit RebalanceStarted(_setToken, _quoteAsset, _shouldLockSetToken, _rebalanceDuration, _initialPositionMultiplier, allComponents, allAuctionParams);\n    }\n\n   /**\n     * @dev ACCESS LIMITED: Only approved addresses can call this function unless isAnyoneAllowedToBid is enabled. This function\n     * is used to push the current component units closer to the target units defined in startRebalance().\n     *\n     * Bidders specify the amount of the component they intend to buy or sell, and also specify the maximum/minimum amount \n     * of the quote asset they are willing to spend/receive.\n     *\n     * The auction parameters, which are set by the manager, are used to determine the price of the component. Any bids that \n     * either don't move the component units towards the target, or overshoot the target, will be reverted.\n     *\n     * If protocol fees are enabled, they are collected in the token received in a bid.\n     * \n     * SELL AUCTIONS:\n     * At the start of the rebalance, sell auctions are available to be filled in their full size.\n     * \n     * BUY AUCTIONS:\n     * Buy auctions can be filled up to the amount of quote asset available in the SetToken. This means that if the SetToken \n     * does not contain the quote asset as a component, buy auctions cannot be bid on until sell auctions have been executed \n     * and there is quote asset available in the SetToken.\n     *\n     * @param _setToken          The SetToken to be rebalanced.\n     * @param _component         The component for which the auction is to be bid on.\n     * @param _componentAmount   The amount of component in the bid.\n     * @param _quoteAssetLimit   The maximum or minimum amount of quote asset that can be spent or received during the bid.\n     */\n    function bid(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _componentAmount,\n        uint256 _quoteAssetLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedBidder(_setToken)\n    {\n        // Validate whether the bid targets are legitimate\n        _validateBidTargets(_setToken, _component);\n\n        // Create the bid information structure\n        BidInfo memory bidInfo = _createBidInfo(_setToken, _component, _componentAmount, _quoteAssetLimit);\n\n        // Execute the token transfer specified in the bid information\n        _executeBid(bidInfo);\n\n        // Accrue protocol fee and store the amount\n        uint256 protocolFeeAmount = _accrueProtocolFee(bidInfo);\n\n        // Update the position state and store the net amounts\n        (uint256 netAmountSent, uint256 netAmountReceived) = _updatePositionState(bidInfo);\n\n        // Emit the BidExecuted event\n        emit BidExecuted(\n            bidInfo.setToken,\n            address(bidInfo.sendToken),\n            address(bidInfo.receiveToken),\n            msg.sender,\n            bidInfo.priceAdapter,\n            bidInfo.isSellAuction,\n            bidInfo.componentPrice,\n            netAmountSent,\n            netAmountReceived,\n            protocolFeeAmount,\n            bidInfo.setTotalSupply\n        );\n    }\n\n    /**\n     * @dev ACCESS LIMITED: Increases asset targets uniformly when all target units have been met but there is remaining quote asset.\n     * Can be called multiple times if necessary. Targets are increased by the percentage specified by raiseAssetTargetsPercentage set by the manager.\n     * This helps in reducing tracking error and providing greater granularity in reaching an equilibrium between the excess quote asset\n     * and the components to be purchased. However, excessively raising targets may result in under-allocating to the quote asset as more of\n     * it is spent buying components to meet the new targets.\n     *\n     * @param _setToken   The SetToken to be rebalanced.\n     */\n    function raiseAssetTargets(ISetToken _setToken)\n        external\n        onlyAllowedBidder(_setToken)\n        virtual\n    {\n        // Ensure the rebalance is in progress\n        require(!_isRebalanceDurationElapsed(_setToken), \"Rebalance must be in progress\");\n\n        // Ensure that all targets are met and there is excess quote asset\n        require(_canRaiseAssetTargets(_setToken), \"Targets not met or quote asset =~ 0\");\n\n        // Calculate the new positionMultiplier\n        uint256 newPositionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n\n        // Update the positionMultiplier in the RebalanceInfo struct\n        rebalanceInfo[_setToken].positionMultiplier = newPositionMultiplier;\n\n        // Emit the AssetTargetsRaised event\n        emit AssetTargetsRaised(_setToken, newPositionMultiplier);\n    }\n\n    /**\n     * @dev Unlocks the SetToken after rebalancing. Can be called once the rebalance duration has elapsed.\n     * Can only be called before the rebalance duration has elapsed if all targets are met, there is excess\n     * or at-target quote asset, and raiseTargetPercentage is zero.\n     *\n     * @param _setToken The SetToken to be unlocked.\n     */\n    function unlock(ISetToken _setToken) external {\n        bool isRebalanceDurationElapsed = _isRebalanceDurationElapsed(_setToken);\n        bool canUnlockEarly = _canUnlockEarly(_setToken);\n\n        // Ensure that either the rebalance duration has elapsed or the conditions for early unlock are met\n        require(isRebalanceDurationElapsed || canUnlockEarly, \"Cannot unlock early unless all targets are met and raiseTargetPercentage is zero\");\n\n        // If unlocking early, update the state\n        if (canUnlockEarly) {\n            delete rebalanceInfo[_setToken].rebalanceDuration;\n            emit LockedRebalanceEndedEarly(_setToken);\n        }\n\n        // Unlock the SetToken\n        _setToken.unlock();\n    }\n\n    /**\n     * @dev MANAGER ONLY: Sets the percentage by which the target units for all components can be increased.\n     * Can be called at any time by the manager.\n     *\n     * @param _setToken               The SetToken to be rebalanced.\n     * @param _raiseTargetPercentage  The percentage (in precise units) by which the target units can be increased.\n     */\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Ensure the raise target percentage is greater than 0\n        require(_raiseTargetPercentage > 0, \"Target percentage must be greater than 0\");\n\n        // Update the raise target percentage in the RebalanceInfo struct\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n\n        // Emit an event to log the updated raise target percentage\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n\n    /**\n     * @dev MANAGER ONLY: Toggles the permission status of specified addresses to call the `bid()` function.\n     * The manager can call this function at any time.\n     *\n     * @param _setToken  The SetToken being rebalanced.\n     * @param _bidders   An array of addresses whose bidding permission status is to be toggled.\n     * @param _statuses  An array of booleans indicating the new bidding permission status for each corresponding address in `_bidders`.\n     */\n    function setBidderStatus(\n        ISetToken _setToken,\n        address[] memory _bidders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Validate that the input arrays have the same length\n        _bidders.validatePairsWithArray(_statuses);\n\n        // Iterate through the input arrays and update the permission status for each bidder\n        for (uint256 i = 0; i < _bidders.length; i++) {\n            _updateBiddersHistory(_setToken, _bidders[i], _statuses[i]);\n            permissionInfo[_setToken].bidAllowList[_bidders[i]] = _statuses[i];\n\n            // Emit an event to log the updated permission status\n            emit BidderStatusUpdated(_setToken, _bidders[i], _statuses[i]);\n        }\n    }\n\n    /**\n     * @dev MANAGER ONLY: Toggles whether or not anyone is allowed to call the `bid()` function.\n     * If set to true, it bypasses the bidAllowList, allowing any address to call the `bid()` function.\n     * The manager can call this function at any time.\n     *\n     * @param _setToken  The SetToken instance.\n     * @param _status    A boolean indicating if anyone can bid.\n     */\n    function setAnyoneBid(\n        ISetToken _setToken,\n        bool _status\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Update the anyoneBid status in the PermissionInfo struct\n        permissionInfo[_setToken].isAnyoneAllowedToBid = _status;\n\n        // Emit an event to log the updated anyoneBid status\n        emit AnyoneBidUpdated(_setToken, _status);\n    }\n\n\n    /**\n     * @dev MANAGER ONLY: Initializes the module for a SetToken, enabling access to AuctionModuleV1 for rebalances.\n     * Retrieves the current units for each asset in the Set and sets the targetUnit to match the current unit, effectively\n     * preventing any bidding until `startRebalance()` is explicitly called. The position multiplier is also logged to ensure that\n     * any changes to the position multiplier do not unintentionally open the Set for rebalancing.\n     *\n     * @param _setToken   Address of the Set Token\n     */\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n\n        for (uint256 i = 0; i < positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, \"External positions not allowed\");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n        }\n\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n\n\n    /**\n     * @dev Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the `rebalanceInfo` and `permissionsInfo` of the calling SetToken.\n     * IMPORTANT: The auction execution settings of the SetToken, including auction parameters,\n     * are NOT DELETED. Restoring a previously removed module requires careful initialization of\n     * the execution settings.\n     */\n    function removeModule() external override {\n        BidPermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n\n        for (uint256 i = 0; i < tokenPermissionInfo.biddersHistory.length; i++) {\n            tokenPermissionInfo.bidAllowList[tokenPermissionInfo.biddersHistory[i]] = false;\n        }\n\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n\n\n    /* ============ External View Functions ============ */\n\n    /**\n     * @dev Checks externally if the rebalance duration has elapsed for the given SetToken.\n     *\n     * @param _setToken The SetToken whose rebalance duration is being checked.\n     * @return bool True if the rebalance duration has elapsed; false otherwise.\n     */\n    function isRebalanceDurationElapsed(ISetToken _setToken) external view returns (bool) {\n        return _isRebalanceDurationElapsed(_setToken);\n    }\n\n    /**\n     * @dev Retrieves the array of components that are involved in the rebalancing of the given SetToken.\n     *\n     * @param _setToken    Instance of the SetToken.\n     *\n     * @return address[]   Array of component addresses involved in the rebalance.\n     */\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n\n    /**\n     * @dev Calculates the quantity of a component involved in the rebalancing of the given SetToken,\n     * and determines if the component is being bought or sold.\n     *\n     * @param _setToken    Instance of the SetToken being rebalanced.\n     * @param _component   Instance of the IERC20 component to bid on.\n     *\n     * @return isSellAuction       Indicates if this is a sell auction (true) or a buy auction (false).\n     * @return componentQuantity   Quantity of the component involved in the bid.\n     */\n    function getAuctionSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool isSellAuction, uint256 componentQuantity)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            \"Component not part of rebalance\"\n        );\n        \n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateAuctionSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n    /**\n     * @dev Retrieves the balance of the quote asset for a given SetToken.\n     *\n     * @param _setToken The SetToken whose quote asset balance is being retrieved.\n     * @return uint256 The balance of the quote asset.\n     */\n    function getQuoteAssetBalance(ISetToken _setToken) external view returns (uint256) {\n        RebalanceInfo storage rebalance = rebalanceInfo[_setToken];\n        return IERC20(rebalance.quoteAsset).balanceOf(address(_setToken));\n    }\n\n    /**\n     * @dev Generates a preview of the bid for a given component in the rebalancing of the SetToken.\n     * It calculates the quantity of the component that will be exchanged and the direction of exchange.\n     *\n     * @param _setToken             Instance of the SetToken being rebalanced.\n     * @param _component            Instance of the component auction to bid on.\n     * @param _componentQuantity    Quantity of the component involved in the bid.\n     * @param _quoteQuantityLimit   Maximum or minimum amount of quote asset spent or received during the bid.\n     *\n     * @return BidInfo              Struct containing data for the bid.\n     */\n    function getBidPreview(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _componentQuantity,\n        uint256 _quoteQuantityLimit\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (BidInfo memory)\n    {\n        _validateBidTargets(_setToken, _component);\n        BidInfo memory bidInfo = _createBidInfo(_setToken, _component, _componentQuantity, _quoteQuantityLimit);\n        \n        return bidInfo;\n    }\n\n    /**\n     * @dev Checks externally if the conditions for early unlock are met.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if early unlock conditions are met; false otherwise.\n     */\n    function canUnlockEarly(ISetToken _setToken) external view returns (bool) {\n        return _canUnlockEarly(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if the conditions to raise asset targets are met.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if conditions to raise asset targets are met; false otherwise.\n     */\n    function canRaiseAssetTargets(ISetToken _setToken) external view returns (bool) {\n        return _canRaiseAssetTargets(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if all target units for components have been met.\n     *\n     * @param _setToken Instance of the SetToken to be rebalanced.\n     * @return bool True if all component's target units have been met; false otherwise.\n     */\n    function allTargetsMet(ISetToken _setToken) external view returns (bool) {\n        return _allTargetsMet(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if the quote asset is in excess or at target.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if the quote asset is in excess or at target; false otherwise.\n     */\n    function isQuoteAssetExcessOrAtTarget(ISetToken _setToken) external view returns (bool) {\n        return _isQuoteAssetExcessOrAtTarget(_setToken);\n    }\n\n    /**\n     * @dev Determines whether the given bidder address is allowed to participate in the auction.\n     *\n     * @param _setToken   Instance of the SetToken for which the bid is being placed.\n     * @param _bidder     Address of the bidder.\n     *\n     * @return bool       True if the given `_bidder` is permitted to bid, false otherwise.\n     */\n    function isAllowedBidder(ISetToken _setToken, address _bidder)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedBidder(_setToken, _bidder);\n    }\n\n    /**\n     * @dev Retrieves the list of addresses that are permitted to participate in the auction by calling `bid()`.\n     *\n     * @param _setToken           Instance of the SetToken for which to retrieve the list of allowed bidders.\n     *\n     * @return address[]          Array of addresses representing the allowed bidders.\n     */\n    function getAllowedBidders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].biddersHistory;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev Aggregates the current SetToken components with the new components and validates their auction parameters.\n     * Ensures that the sizes of the new components and new auction parameters arrays are the same, and that the number of current component auction parameters\n     * matches the number of current components. Additionally, it validates that the price adapter exists, the price adapter configuration data is valid for the adapter,\n     * and the target unit is greater than zero for new components. T"
    }
  ]
}