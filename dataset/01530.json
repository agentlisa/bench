{
  "Title": "M-5: CrosschainDistributor: Not paying relayer fee when calling xcall to claim tokens to other domains",
  "Content": "# Issue M-5: CrosschainDistributor: Not paying relayer fee when calling xcall to claim tokens to other domains \n\nSource: https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/143 \n\n## Found by \n0xhacksmithh, AkshaySrivastav, Czar102, GREY-HAWK-REACH, Vagner, jkoppel, kutugu, n33k, pengun, pep7siup, qbs, r0bert, tsvetanovv\n## Summary\n\nCrosschainDistributor is not paying relayer fee when calling xcall to claim tokens to other domains. The transaction will not be relayed on target chain to finnalize the claim. User will not receive the claimed tokens unless they bump the transaction fee themself.\n\n## Vulnerability Detail\n\nIn `_settleClaim`, the CrosschainDistributor is using xcall to claim tokens to another domain. But relayer fee is not payed.\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/CrosschainDistributor.sol#L78\n```solidity\n      id = connext.xcall(            // <------ relayer fee should be payed here\n        _recipientDomain, // destination domain\n        _recipient, // to\n        address(token), // asset\n        _recipient, // delegate, only required for self-execution + slippage\n        _amount, // amount\n        0, // slippage -- assumes no pools on connext\n        bytes('') // calldata\n      );\n```\n\nWithout the relayer fee, the transaction will not be relayed. The user will need to bump the relayer fee to finnally settle the claim by following [the instructions here in the connext doc](https://docs.connext.network/integrations/guides/estimating-fees#bumping-relayer-fees).\n\n## Impact\n\nUser will not receive their claimed tokens on target chain.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/CrosschainDistributor.sol#L78\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nHelp user bump the transaction fee in Satellite.\n\n\n\n## Discussion\n\n**cr-walker**\n\nHmm, this would be a valid issue in general but Connext is paying for relayer fees in this case, i.e. a zero fee cross-chain transaction is valid in this case (and on https://docs.connext.network/developers/guides/estimating-fees). @LayneHaber any thoughts on validity?\n\n**cr-walker**\n\nI am marking this as valid since auditors would not know the plan to have Connext pay this fee in this case and we'll change this anyway (it seems strictly better to make the function payable and pass along message value like this:\n\n```\nfunction _settleClaim(\n    address _beneficiary,\n    address _recipient,\n    uint32 _recipientDomain,\n    uint256 _amount\n  ) internal virtual {\n    bytes32 id;\n    if (_recipientDomain == 0 || _recipientDomain == domain) {\n      token.safeTransfer(_recipient, _amount);\n    } else {\n      id = connext.xcall{value: msg.value}(\n        _recipientDomain, // destination domain\n        _recipient, // to\n        address(token), // asset\n        _recipient, // delegate, only required for self-execution + slippage\n        _amount, // amount\n        0, // slippage -- assumes no pools on connext\n        bytes('') // calldata\n      );\n    }\n    emit CrosschainClaim(id, _beneficiary, _recipient, _recipientDomain, _amount);\n  }\n  ```\n\n**LayneHaber**\n\nAgree that it is strictly better to have the fees be an option on the contract itself. We can always pass in `0` and the `xcall` will not fail, which works for our distribution but likely not for others.\n\n**Shogoki**\n\nIs there a hint to this behaviour in the connext docs to this behaviour?\n\n**LayneHaber**\n\ndocs on the relayer fee behavior can be found [here](https://docs.connext.network/developers/guides/estimating-fees#bumping-relayer-fees) -- this specifically outlines bumping fees, but that implies if the fee is low enough the `xcall` goes through, it's just not processed on the destination chain.\n\nthere is no documentation on fee-sponsoring though, and agree that we should make this payable!\n\n**LayneHaber**\n\nFixed: https://github.com/SoftDAO/contracts/pull/8\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/100",
  "Code": [
    {
      "filename": "contracts/contracts/claim/abstract/CrosschainDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { AdvancedDistributor, IERC20 } from './AdvancedDistributor.sol';\nimport { Distributor } from './Distributor.sol';\nimport { IConnext } from '../../interfaces/IConnext.sol';\nimport { ICrosschain } from '../../interfaces/ICrosschain.sol';\n\nabstract contract CrosschainDistributor is AdvancedDistributor, ICrosschain {\n  using SafeERC20 for IERC20;\n\n  IConnext public immutable connext;\n  uint32 public immutable domain;\n\n  /**\n   * @notice Throws if the msg.sender is not connext\n   */\n  modifier onlyConnext() {\n    require(msg.sender == address(connext), '!connext');\n    _;\n  }\n\n  constructor(IConnext _connext, uint256 _total) {\n    connext = _connext;\n    domain = uint32(_connext.domain());\n    _allowConnext(_total);\n  }\n\n  /**\n  @dev allows Connext to withdraw tokens for cross-chain settlement. Connext may withdraw up to\n  the remaining quantity of tokens that can be claimed - the allowance must be set for cross-chain claims.\n  */\n  function _allowConnext(uint256 amount) internal {\n    token.safeApprove(address(connext), amount);\n  }\n\n  /** Reset Connext allowance when total is updated */\n  function _setTotal(uint256 _total) internal virtual override onlyOwner {\n    // effects\n    super._setTotal(_total);\n    // interactions\n    _allowConnext(total - claimed);\n  }\n\n  /** Reset Connext allowance when token is updated */\n  function _setToken(IERC20 _token) internal virtual override nonReentrant onlyOwner {\n    // interaction before effect!\n    // decrease allowance on old token\n    _allowConnext(0);\n\n    // effect\n    super._setToken(_token);\n\n    // interactions\n    // increase allowance on new token\n    _allowConnext(total - claimed);\n  }\n\n  /**\n   * @notice Settles claimed tokens to any valid Connext domain.\n   * @dev permissions are not checked: call only after a valid claim is executed\n   * @param _recipient: the address that will receive tokens\n   * @param _recipientDomain: the domain of the address that will receive tokens\n   * @param _amount: the amount of claims to settle\n   */\n  function _settleClaim(\n    address _beneficiary,\n    address _recipient,\n    uint32 _recipientDomain,\n    uint256 _amount\n  ) internal virtual {\n    bytes32 id;\n    if (_recipientDomain == 0 || _recipientDomain == domain) {\n      token.safeTransfer(_recipient, _amount);\n    } else {\n      id = connext.xcall(\n        _recipientDomain, // destination domain\n        _recipient, // to\n        address(token), // asset\n        _recipient, // delegate, only required for self-execution + slippage\n        _amount, // amount\n        0, // slippage -- assumes no pools on connext\n        bytes('') // calldata\n      );\n    }\n    emit CrosschainClaim(id, _beneficiary, _recipient, _recipientDomain, _amount);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/abstract/CrosschainDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { AdvancedDistributor, IERC20 } from './AdvancedDistributor.sol';\nimport { Distributor } from './Distributor.sol';\nimport { IConnext } from '../../interfaces/IConnext.sol';\nimport { ICrosschain } from '../../interfaces/ICrosschain.sol';\n\nabstract contract CrosschainDistributor is AdvancedDistributor, ICrosschain {\n  using SafeERC20 for IERC20;\n\n  IConnext public immutable connext;\n  uint32 public immutable domain;\n\n  /**\n   * @notice Throws if the msg.sender is not connext\n   */\n  modifier onlyConnext() {\n    require(msg.sender == address(connext), '!connext');\n    _;\n  }\n\n  constructor(IConnext _connext, uint256 _total) {\n    connext = _connext;\n    domain = uint32(_connext.domain());\n    _allowConnext(_total);\n  }\n\n  /**\n  @dev allows Connext to withdraw tokens for cross-chain settlement. Connext may withdraw up to\n  the remaining quantity of tokens that can be claimed - the allowance must be set for cross-chain claims.\n  */\n  function _allowConnext(uint256 amount) internal {\n    token.safeApprove(address(connext), amount);\n  }\n\n  /** Reset Connext allowance when total is updated */\n  function _setTotal(uint256 _total) internal virtual override onlyOwner {\n    // effects\n    super._setTotal(_total);\n    // interactions\n    _allowConnext(total - claimed);\n  }\n\n  /** Reset Connext allowance when token is updated */\n  function _setToken(IERC20 _token) internal virtual override nonReentrant onlyOwner {\n    // interaction before effect!\n    // decrease allowance on old token\n    _allowConnext(0);\n\n    // effect\n    super._setToken(_token);\n\n    // interactions\n    // increase allowance on new token\n    _allowConnext(total - claimed);\n  }\n\n  /**\n   * @notice Settles claimed tokens to any valid Connext domain.\n   * @dev permissions are not checked: call only after a valid claim is executed\n   * @param _recipient: the address that will receive tokens\n   * @param _recipientDomain: the domain of the address that will receive tokens\n   * @param _amount: the amount of claims to settle\n   */\n  function _settleClaim(\n    address _beneficiary,\n    address _recipient,\n    uint32 _recipientDomain,\n    uint256 _amount\n  ) internal virtual {\n    bytes32 id;\n    if (_recipientDomain == 0 || _recipientDomain == domain) {\n      token.safeTransfer(_recipient, _amount);\n    } else {\n      id = connext.xcall(\n        _recipientDomain, // destination domain\n        _recipient, // to\n        address(token), // asset\n        _recipient, // delegate, only required for self-execution + slippage\n        _amount, // amount\n        0, // slippage -- assumes no pools on connext\n        bytes('') // calldata\n      );\n    }\n    emit CrosschainClaim(id, _beneficiary, _recipient, _recipientDomain, _amount);\n  }\n}"
    }
  ]
}