{
  "Title": "HubPool Might Stop Executing Bundles if Deposit Limits Are Enabled for ZkSync",
  "Content": "If zkSync enables [deposit limit](https://github.com/across-protocol/contracts-v2/blob/2f649b1fecb0b32aa500373a8b8b0804e0c98cd2/contracts/chain-adapters/ZkSync_Adapter.sol#L150-L151) and the HubPool contract hits the limit then the Across protocol will partially stop working [because the root bundle could not be executed](https://github.com/across-protocol/contracts-v2/blob/2f649b1fecb0b32aa500373a8b8b0804e0c98cd2/contracts/chain-adapters/ZkSync_Adapter.sol#L153-L157). The Across protocol assumes that [the limit can be bypassed by splitting a deposit into multiple chunks](https://github.com/across-protocol/contracts-v2/blob/2f649b1fecb0b32aa500373a8b8b0804e0c98cd2/contracts/chain-adapters/ZkSync_Adapter.sol#L152-L153).\n\n\nHowever, this is not the case as [the limit specifies the total amount of tokens bridged](https://github.com/matter-labs/era-contracts/blob/3a4506522aaef81485d8abb96f5a6394bd2ba69e/ethereum/contracts/bridge/L1ERC20Bridge.sol#L353) but not the per-deposit amount. Thus if the limit is hit it will not be possible to bypass it by splitting the deposit into smaller chunks. Furthermore, the attacker can trigger this scenario by increasing the total amount deposited from Across to zkSync by choosing zkSync as the repayment chain.\n\n\nConsider changing how the limit hit is handled by the Across protocol.\n\n\n***Update:** Resolved in [pull request #328](https://github.com/across-protocol/contracts-v2/pull/328) at commit [fd6c17b](https://github.com/across-protocol/contracts-v2/pull/176/commits/fd6c17ba712966ba73cdd999651535f99da6df22).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/chain-adapters/ZkSync_Adapter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"../external/interfaces/WETH9Interface.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface ZkSyncInterface {\n    // _contractL2: L2 address of the contract to be called.\n    // _l2Value: Amount of ETH to pass with the call to L2; used as msg.value for the transaction.\n    // _calldata: Calldata of the transaction call; encoded the same way as in Ethereum.\n    // _l2GasLimit: Gas limit of the L2 transaction call.\n    // _l2GasPerPubdataByteLimit: A constant representing how much gas is required to publish a byte of data from\n    //  L1 to L2. https://era.zksync.io/docs/api/js/utils.html#gas\n    // _factoryDeps: Bytecodes array containing the bytecode of the contract being deployed.\n    //  If the contract is a factory contract, the array contains the bytecodes of the contracts it can deploy.\n    // _refundRecipient: Address that receives the rest of the fee after the transaction execution.\n    //  If refundRecipient == 0, L2 msg.sender is used. Note: If the _refundRecipient is a smart contract,\n    //  then during the L1 to L2 transaction its address is aliased.\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash);\n\n    // @notice Estimates the cost in Ether of requesting execution of an L2 transaction from L1\n    // @param _l1GasPrice Effective gas price on L1 (priority fee + base fee)\n    // @param _l2GasLimit Gas limit for the L2 transaction\n    // @param _l2GasPerPubdataByteLimit Gas limit for the L2 transaction per byte of pubdata\n    // @return The estimated L2 gas for the transaction to be paid\n    function l2TransactionBaseCost(\n        uint256 _l1GasPrice,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit\n    ) external view returns (uint256);\n}\n\ninterface ZkBridgeLike {\n    // @dev: Use ZkSyncInterface.requestL2Transaction to bridge WETH as ETH to L2.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable returns (bytes32 txHash);\n}\n\n/**\n * @notice Contract containing logic to send messages from L1 to ZkSync.\n * @dev Public functions calling external contracts do not guard against reentrancy because they are expected to be\n * called via delegatecall, which will execute this contract's logic within the context of the originating contract.\n * For example, the HubPool will delegatecall these functions, therefore its only necessary that the HubPool's methods\n * that call this contract's logic guard against reentrancy.\n */\n\n// solhint-disable-next-line contract-name-camelcase\ncontract ZkSync_Adapter is AdapterInterface {\n    using SafeERC20 for IERC20;\n\n    // We need to pay a base fee to the operator to include our L1 --> L2 transaction.\n    // https://era.zksync.io/docs/dev/developer-guides/bridging/l1-l2.html#getting-the-base-cost\n\n    // Generally, the following params are a bit hard to set and may change in the future once ZkSync\n    // goes live. For now, we'll hardcode these and use aggressive values to ensure inclusion.\n\n    // Limit on L2 gas to spend.\n    uint256 public constant l2GasLimit = 300_000;\n\n    // How much gas is required to publish a byte of data from L1 to L2. 800 is the required value\n    // as set here https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L226\n    // Note, this value can change and will require an updated adapter.\n    uint256 public constant l1GasToL2GasPerPubDataLimit = 800;\n\n    // This address receives any remaining fee after an L1 to L2 transaction completes.\n    // If refund recipient = address(0) then L2 msg.sender is used, unelss msg.sender is a contract then its address\n    // gets aliased.\n    address public constant l2RefundAddress = 0x428AB2BA90Eba0a4Be7aF34C9Ac451ab061AC010;\n\n    // Hardcode the following ZkSync system contract addresses to save gas on construction. This adapter can be\n    // redeployed in the event that the following addresses change.\n\n    // Main contract used to send L1 --> L2 messages. Fetchable via `zks_getMainContract` method on JSON RPC.\n    ZkSyncInterface public constant zkSync = ZkSyncInterface(0x32400084C286CF3E17e7B677ea9583e60a000324);\n    // Bridges to send ERC20 and ETH to L2. Fetchable via `zks_getBridgeContracts` method on JSON RPC.\n    ZkBridgeLike public constant zkErc20Bridge = ZkBridgeLike(0x57891966931Eb4Bb6FB81430E6cE0A03AAbDe063);\n\n    // Set l1Weth at construction time to make testing easier. TODO: Think of some way to be able to hardcode this\n    // while keeping unit tests easy to write with custom WETH that we can mint/transfer.\n    WETH9Interface public immutable l1Weth;\n\n    event ZkSyncMessageRelayed(bytes32 canonicalTxHash);\n\n    /**\n     * @notice Constructs new Adapter.\n     * @param _l1Weth WETH address on L1.\n     */\n    constructor(WETH9Interface _l1Weth) {\n        l1Weth = _l1Weth;\n    }\n\n    /**\n     * @notice Send cross-chain message to target on ZkSync.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message, or the message\n     * will revert.\n     * @param target Contract on L2 that will receive message.\n     * @param message Data to send to target.\n     */\n    function relayMessage(address target, bytes memory message) external payable override {\n        uint256 txBaseCost = _contractHasSufficientEthBalance();\n\n        // Returns the hash of the requested L2 transaction. This hash can be used to follow the transaction status.\n        bytes32 canonicalTxHash = zkSync.requestL2Transaction{ value: txBaseCost }(\n            target,\n            // We pass no ETH with the call, otherwise we'd need to add to the txBaseCost this value.\n            0,\n            message,\n            l2GasLimit,\n            l1GasToL2GasPerPubDataLimit,\n            new bytes[](0),\n            l2RefundAddress\n        );\n\n        emit MessageRelayed(target, message);\n        emit ZkSyncMessageRelayed(canonicalTxHash);\n    }\n\n    /**\n     * @notice Bridge tokens to ZkSync.\n     * @notice This contract must hold at least getL1CallValue() amount of ETH to send a message\n     * or the message will revert.\n     * @param l1Token L1 token to deposit.\n     * @param l2Token L2 token to receive.\n     * @param amount Amount of L1 tokens to deposit and L2 tokens to receive.\n     * @param to Bridge recipient.\n     */\n    function relayTokens(\n        address l1Token,\n        address l2Token, // l2Token is unused.\n        uint256 amount,\n        address to\n    ) external payable override {\n        // This could revert if the relay amount is over the ZkSync deposit\n        // limit: https://github.com/matter-labs/era-contracts/blob/main/ethereum/contracts/common/AllowList.sol#L150\n        // We should make sure that the limit is either set very high or we need to do logic\n        // that splits the amount to deposit into multiple chunks. We can't have\n        // this function revert or the HubPool will not be able to proceed to the\n        // next bundle. See more here:\n        // https://github.com/matter-labs/era-contracts/blob/main/docs/Overview.md#deposit-limitation\n        // https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L230\n        uint256 txBaseCost = _contractHasSufficientEthBalance();\n\n        // If the l1Token is WETH then unwrap it to ETH then send the ETH to the standard bridge along with the base\n        // cost. I've tried sending WETH over the erc20Bridge directly but we receive the wrong WETH\n        // on the L2 side. So, we need to unwrap the WETH into ETH and then send.\n        bytes32 txHash;\n        if (l1Token == address(l1Weth)) {\n            l1Weth.withdraw(amount);\n            // We cannot call the standard ERC20 bridge because it disallows ETH deposits.\n            txHash = zkSync.requestL2Transaction{ value: txBaseCost + amount }(\n                to,\n                amount,\n                \"\",\n                l2GasLimit,\n                l1GasToL2GasPerPubDataLimit,\n                new bytes[](0),\n                l2RefundAddress\n            );\n        } else {\n            IERC20(l1Token).safeIncreaseAllowance(address(zkErc20Bridge), amount);\n            txHash = zkErc20Bridge.deposit{ value: txBaseCost }(\n                to,\n                l1Token,\n                amount,\n                l2GasLimit,\n                l1GasToL2GasPerPubDataLimit,\n                l2RefundAddress\n            );\n        }\n\n        emit TokensRelayed(l1Token, l2Token, amount, to);\n        emit ZkSyncMessageRelayed(txHash);\n    }\n\n    /**\n     * @notice Returns required amount of ETH to send a message.\n     * @return amount of ETH that this contract needs to hold in order for relayMessage to succeed.\n     */\n    function getL1CallValue() public view returns (uint256) {\n        // - tx.gasprice returns effective_gas_price. It's also used by Mailbox contract to estimate L2GasPrice\n        // so using tx.gasprice should always pass this check that msg.value >= baseCost + _l2Value\n        // https://github.com/matter-labs/era-contracts/blob/6391c0d7bf6184d7f6718060e3991ba6f0efe4a7/ethereum/contracts/zksync/facets/Mailbox.sol#L273\n        // - priority_fee_per_gas = min(transaction.max_priority_fee_per_gas, transaction.max_fee_per_gas - block.base_fee_per_gas)\n        // - effective_gas_price = priority_fee_per_gas + block.base_fee_per_gas\n        return zkSync.l2TransactionBaseCost(tx.gasprice, l2GasLimit, l1GasToL2GasPerPubDataLimit);\n    }\n\n    function _contractHasSufficientEthBalance() internal view returns (uint256 requiredL1CallValue) {\n        requiredL1CallValue = getL1CallValue();\n        require(address(this).balance >= requiredL1CallValue, \"Insufficient ETH balance\");\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/bridge/L1ERC20Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IL1BridgeLegacy.sol\";\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IL2ERC20Bridge.sol\";\n\nimport \"./libraries/BridgeInitializationHelper.sol\";\n\nimport \"../zksync/interfaces/IZkSync.sol\";\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/libraries/L2ContractHelper.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../vendor/AddressAliasHelper.sol\";\n\n/// @author Matter Labs\n/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to zkSync Era\n/// @dev It is standard implementation of ERC20 Bridge that can be used as a reference\n/// for any other custom token bridges.\ncontract L1ERC20Bridge is IL1Bridge, IL1BridgeLegacy, AllowListed, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList internal immutable allowList;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IZkSync internal immutable zkSync;\n\n    /// @dev A mapping L2 block number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address => mapping(address => mapping(bytes32 => uint256))) internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) public __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) public __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) public totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IZkSync _zkSync, IAllowList _allowList) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), \"nf\");\n        require(_governor != address(0), \"nh\");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, \"mk\");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, \"fee\");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[2]);\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            \"\", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            new bytes[](0) // No factory deps are needed for L2 bridge proxy, because it is already passed in previous step\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn't use `nonreentrant` and `senderCanCallFunction` modifiers, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds are controllable through the Mailbox,\n    /// since the Mailbox applies address aliasing to the from address for the L2 tx if the L1 msg.sender is a contract.\n    /// Without address aliasing for L1 contracts as refund recipients they would not be able to make proper L2 tx requests\n    /// through the Mailbox to use or withdraw the funds from L2, and the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 l2TxHash) {\n        require(_amount != 0, \"2T\"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, \"1T\"); // The token has non-standard transfer logic\n        // verify the deposit amount is allowed\n        _verifyDepositLimit(_l1Token, msg.sender, _amount, false);\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n\n        emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(\n        address _from,\n        IERC20 _token,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n        );\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BlockNumber The L2 block number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BlockNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBlock,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, \"yn\");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, \"y1\");\n\n        // Change the total deposited amount by the user\n        _verifyDepositLimit(_l1Token, _depositSender, amount, true);\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BlockNumber The L2 block number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex], \"pw\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BlockNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, \"nq\");\n        }\n\n        isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _l2ToL1message)\n        internal\n        pure\n        returns (\n            address l1Receiver,\n            address l1Token,\n            uint256 amount\n        )\n    {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 = 76 (bytes).\n        require(_l2ToL1message.length == 76, \"kk\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, \"nt\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @dev Verify the deposit limit is reached to its cap or not\n    function _verifyDepositLimit(\n        address _l1Token,\n        address _depositor,\n        uint256 _amount,\n        bool _claiming\n    ) internal {\n        IAllowList.Deposit memory limitData = IAllowList(allowList).getTokenDepositLimitData(_l1Token);\n        if (!limitData.depositLimitation) return; // no deposit limitation is placed for this token\n\n        if (_claiming) {\n            totalDepositedAmountPerUser[_l1Token][_depositor] -= _amount;\n        } else {\n            require(totalDepositedAmountPerUser[_l1Token][_depositor] + _amount <= limitData.depositCap, \"d1\");\n            totalDepositedAmountPerUser[_l1Token][_depositor] += _amount;\n        }\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}"
    }
  ]
}