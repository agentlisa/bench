{
  "Title": "[G-15] ``>=`` costs less gas than ``>``",
  "Content": "\nThe compiler uses opcodes GT and ISZERO for solidity code that uses >, but only requires LT for >=, which saves 3 gas\n\n4 results - 2 files:\n\n```solidity\npackages\\v2-library\\src\\Math.sol:\n  89:         return value1 < value2 ? value1 : value2;\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Math.sol#L89\n\n```solidity\npackages\\v2-library\\src\\StrikeConversion.sol:\n  27:         return strike > type(uint128).max ? (toOne ? convert(amount, strike, true, roundUp) : amount) : (toOne ? amount : convert(amount, strike, false, roundUp));\n\n  36:         return strike > type(uint128).max ? amount0 + convert(amount1, strike, false, roundUp) : amount1 + convert(amount0, strike, true, roundUp);\n\n  48:             strike > type(uint128).max\n  49                 ? (zeroToOne ? convert(base - amount, strike, true, roundUp) : base - convert(amount, strike, false, !roundUp))\n  50                 : (zeroToOne ? base - convert(amount, strike, true, !roundUp) : convert(base - amount, strike, false, roundUp));\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/StrikeConversion.sol#L27\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-library/src/Math.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nlibrary Math {\n    /// @dev Reverts when divide by zero.\n    error DivideByZero();\n    error Overflow();\n\n    /// @dev Add two uint256.\n    /// @notice May overflow.\n    /// @param addend1 The first addend.\n    /// @param addend2 The second addend.\n    /// @return sum The sum.\n    function unsafeAdd(uint256 addend1, uint256 addend2) internal pure returns (uint256 sum) {\n        unchecked {\n            sum = addend1 + addend2;\n        }\n    }\n\n    /// @dev Subtract two uint256.\n    /// @notice May underflow.\n    /// @param minuend The minuend.\n    /// @param subtrahend The subtrahend.\n    /// @return difference The difference.\n    function unsafeSub(uint256 minuend, uint256 subtrahend) internal pure returns (uint256 difference) {\n        unchecked {\n            difference = minuend - subtrahend;\n        }\n    }\n\n    /// @dev Multiply two uint256.\n    /// @notice May overflow.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @return product The product.\n    function unsafeMul(uint256 multiplicand, uint256 multiplier) internal pure returns (uint256 product) {\n        unchecked {\n            product = multiplicand * multiplier;\n        }\n    }\n\n    /// @dev Divide two uint256.\n    /// @notice Reverts when divide by zero.\n    /// @param dividend The dividend.\n    /// @param divisor The divisor.\n    //// @param roundUp Round up the result when true. Round down if false.\n    /// @return quotient The quotient.\n    function div(uint256 dividend, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient) {\n        quotient = dividend / divisor;\n\n        if (roundUp && dividend % divisor != 0) quotient++;\n    }\n\n    /// @dev Shift right a uint256 number.\n    /// @param dividend The dividend.\n    /// @param divisorBit The divisor in bits.\n    /// @param roundUp True if ceiling the result. False if floor the result.\n    /// @return quotient The quotient.\n    function shr(uint256 dividend, uint8 divisorBit, bool roundUp) internal pure returns (uint256 quotient) {\n        quotient = dividend >> divisorBit;\n\n        if (roundUp && dividend % (1 << divisorBit) != 0) quotient++;\n    }\n\n    /// @dev Gets the square root of a value.\n    /// @param value The value being square rooted.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @return result The resulting value of the square root.\n    function sqrt(uint256 value, bool roundUp) internal pure returns (uint256 result) {\n        if (value == type(uint256).max) return result = type(uint128).max;\n        if (value == 0) return 0;\n        unchecked {\n            uint256 estimate = (value + 1) >> 1;\n            result = value;\n            while (estimate < result) {\n                result = estimate;\n                estimate = (value / estimate + estimate) >> 1;\n            }\n        }\n\n        if (roundUp && value % result != 0) result++;\n    }\n\n    /// @dev Gets the min of two uint256 number.\n    /// @param value1 The first value to be compared.\n    /// @param value2 The second value to be compared.\n    /// @return result The min result.\n    function min(uint256 value1, uint256 value2) internal pure returns (uint256 result) {\n        return value1 < value2 ? value1 : value2;\n    }\n}"
    },
    {
      "filename": "packages/v2-library/src/StrikeConversion.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {FullMath} from \"./FullMath.sol\";\n\n/// @dev library for converting strike prices.\n/// @dev When strike is greater than uint128, the base token is denominated as token0 (which is the smaller address token).\n/// @dev When strike is uint128, the base token is denominated as token1 (which is the larger address).\nlibrary StrikeConversion {\n    /// @dev When zeroToOne, converts a number in multiple of strike.\n    /// @dev When oneToZero, converts a number in multiple of 1 / strike.\n    /// @param amount The amount to be converted.\n    /// @param strike The strike multiple conversion.\n    /// @param zeroToOne ZeroToOne if it is true. OneToZero if it is false.\n    /// @param roundUp Round up the result when true. Round down if false.\n    function convert(uint256 amount, uint256 strike, bool zeroToOne, bool roundUp) internal pure returns (uint256) {\n        return zeroToOne ? FullMath.mulDiv(amount, strike, uint256(1) << 128, roundUp) : FullMath.mulDiv(amount, uint256(1) << 128, strike, roundUp);\n    }\n\n    /// @dev When toOne, converts a base denomination to token1 denomination.\n    /// @dev When toZero, converts a base denomination to token0 denomination.\n    /// @param amount The amount ot be converted. Token0 amount when zeroToOne. Token1 amount when oneToZero.\n    /// @param strike The strike multiple conversion.\n    /// @param toOne ToOne if it is true, ToZero if it is false.\n    /// @param roundUp Round up the result when true. Round down if false.\n    function turn(uint256 amount, uint256 strike, bool toOne, bool roundUp) internal pure returns (uint256) {\n        return strike > type(uint128).max ? (toOne ? convert(amount, strike, true, roundUp) : amount) : (toOne ? amount : convert(amount, strike, false, roundUp));\n    }\n\n    /// @dev Combine and add token0Amount and token1Amount into base token amount.\n    /// @param amount0 The token0 amount to be combined.\n    /// @param amount1 The token1 amount to be combined.\n    /// @param strike The strike multiple conversion.\n    /// @param roundUp Round up the result when true. Round down if false.\n    function combine(uint256 amount0, uint256 amount1, uint256 strike, bool roundUp) internal pure returns (uint256) {\n        return strike > type(uint128).max ? amount0 + convert(amount1, strike, false, roundUp) : amount1 + convert(amount0, strike, true, roundUp);\n    }\n\n    /// @dev When zeroToOne, given a larger base amount, and token0 amount, get the difference token1 amount.\n    /// @dev When oneToZero, given a larger base amount, and toekn1 amount, get the difference token0 amount.\n    /// @param base The larger base amount.\n    /// @param amount The token0 amount when zeroToOne, the token1 amount when oneToZero.\n    /// @param strike The strike multiple conversion.\n    /// @param zeroToOne ZeroToOne if it is true. OneToZero if it is false.\n    /// @param roundUp Round up the result when true. Round down if false.\n    function dif(uint256 base, uint256 amount, uint256 strike, bool zeroToOne, bool roundUp) internal pure returns (uint256) {\n        return\n            strike > type(uint128).max\n                ? (zeroToOne ? convert(base - amount, strike, true, roundUp) : base - convert(amount, strike, false, !roundUp))\n                : (zeroToOne ? base - convert(amount, strike, true, !roundUp) : convert(base - amount, strike, false, roundUp));\n    }\n}"
    }
  ]
}