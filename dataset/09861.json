{
  "Title": "[M-03] S2S Transfer from the origin schain to another schain with automatic deploy disabled can cause funds to be frozen",
  "Content": "_Submitted by WatchPug_\n\nWhen moving tokens that are native on the origin schain, to another schain, `TokenManagerERC20.sol#transferToSchainERC20()` will be called, which calls `_exit()` -> `_receiveERC20()`:\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L289-L301>\n\n```solidity\nif (isMainChainToken) {\n    data = _receiveERC20(\n        chainHash,\n        address(contractOnSchain),\n        msg.sender,\n        amount\n    );\n    _saveTransferredAmount(chainHash, address(contractOnSchain), amount);\n    require(\n        contractOnSchain.transferFrom(msg.sender, address(this), amount),\n        \"Transfer was failed\"\n    );\n}\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L351-L361>\n\n```solidity\nbool isERC20AddedToSchain = _schainToERC20[chainHash].contains(erc20OnMainChain);\nif (!isERC20AddedToSchain) {\n    _addERC20ForSchain(chainHash, erc20OnMainChain);\n    data = Messages.encodeTransferErc20AndTokenInfoMessage(\n        erc20OnMainChain,\n        to,\n        amount,\n        _getErc20TotalSupply(erc20),\n        _getErc20TokenInfo(erc20)\n    );\n}\n```\n\nHowever, on the target schain, while handling the inbound message with `postMessage()` -> `_sendERC20()`, when `contractOnSchain` is `false`, The transaction will fail with `\"Automatic deploy is disabled\"` when `automaticDeploy == false`:\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L227-L235>\n\n```solidity\n contractOnSchain = clonesErc20[fromChainHash][token];\n\nif (address(contractOnSchain) == address(0)) {\n    require(automaticDeploy, \"Automatic deploy is disabled\");\n    contractOnSchain = new ERC20OnChain(message.tokenInfo.name, message.tokenInfo.symbol);\n    clonesErc20[fromChainHash][token] = contractOnSchain;\n    addedClones[contractOnSchain] = true;\n    emit ERC20TokenCreated(fromChainHash, token, address(contractOnSchain));\n}\n```\n\nAs a result, any tokens that are locked in the origin schain by the user will be frozen in the contract.\n\n### Recommendation\n\nConsider adding a `mapping` storage to cache whether `automaticDeploy` is enabled on a certain schain, the cache should be updated once the `automaticDeploy` is updated.\n\nAnd only allows S2S transfer when `automaticDeploy` is enabled on the target schain.\n\nTo further avoid the edge case of: right after the user submitted the S2S transfer tx on the from schain, the target schain disabled `automaticDeploy` and the user's tokens can be frozen in the from schain. We can introduce a 24 hrs timelock for disabling `automaticDeploy`.\n\n**[cstrangedk (SKALE) disputed and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/59#issuecomment-1061273352):**\n> Issue raised is acknowledged and work is assigned on the roadmap.  SKALE Chain owners must ensure any mapped assets, either through manual or automatic mapping are compatible with their dApp(s). Manual mapping mode is the default mode for bridge operation. \n\n\n**[GalloDaSballo (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/59#issuecomment-1143799500):**\n > I agree with both sides of the argument, and because this is contingent on configuration and admin privilege, believe Medium Severity to be more appropriate\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-skale-contest",
  "Code": [
    {
      "filename": "contracts/schain/TokenManagers/TokenManagerERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC20.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../tokens/ERC20OnChain.sol\";\nimport \"../TokenManager.sol\";\n\n\n/**\n * @title TokenManagerERC20\n * @dev Runs on SKALE Chains,\n * accepts messages from mainnet,\n * and creates ERC20 clones.\n * TokenManagerERC20 mints tokens. When a user exits a SKALE chain, it burns them.\n */\ncontract TokenManagerERC20 is TokenManager, ITokenManagerERC20 {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // address of ERC20 on Mainnet => ERC20 on Schain\n    mapping(address => ERC20OnChain) public deprecatedClonesErc20;\n    \n    // address of clone on schain => totalSupplyOnMainnet\n    mapping(IERC20Upgradeable => uint) public totalSupplyOnMainnet;\n\n    // address clone on schain => added or not\n    mapping(ERC20OnChain => bool) public addedClones;\n\n    mapping(bytes32 => mapping(address => ERC20OnChain)) public clonesErc20;\n\n    mapping(bytes32 => mapping(address => uint256)) public transferredAmount;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC20;\n\n    /**\n     * @dev Emitted when schain owner register new ERC20 clone.\n     */\n    event ERC20TokenAdded(bytes32 indexed chainHash, address indexed erc20OnMainChain, address indexed erc20OnSchain);\n\n    /**\n     * @dev Emitted when TokenManagerERC20 automatically deploys new ERC20 clone.\n     */\n    event ERC20TokenCreated(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain\n    );\n\n    /**\n     * @dev Emitted when someone sends tokens from mainnet to schain.\n     */\n    event ERC20TokenReceived(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when token is received by TokenManager and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC20TokenReady(bytes32 indexed chainHash, address indexed contractOnMainnet, uint256 amount);\n\n    /**\n     * @dev Move tokens from schain to mainnet.\n     * \n     * {contractOnMainnet} tokens are burned on schain and unlocked on mainnet for {msg.sender} address.\n     */\n    function exitToMainERC20(\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(msg.sender);\n        _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Move tokens from schain to schain.\n     * \n     * {contractOnMainnet} tokens are burned on origin schain\n     * and are minted on {targetSchainName} schain for {msg.sender} address.\n     */\n    function transferToSchainERC20(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n        rightTransaction(targetSchainName, msg.sender)\n    {\n        bytes32 targetSchainHash = keccak256(abi.encodePacked(targetSchainName));\n        _exit(targetSchainHash, tokenManagers[targetSchainHash], contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the sender.\n     * - `fromChainHash` must exist in TokenManager addresses.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        checkReceiverChain(fromChainHash, sender)\n        returns (address)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        address receiver = address(0);\n        if (\n            operation == Messages.MessageType.TRANSFER_ERC20 ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOKEN_INFO ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY\n        ) {\n            receiver = _sendERC20(fromChainHash, data);\n        } else {\n            revert(\"MessageType is unknown\");\n        }\n        return receiver;\n    }\n\n    /**\n     * @dev Allows Schain owner to register an ERC20 token clone in the TokenManager.\n     */\n    function addERC20TokenByOwner(\n        string calldata targetChainName,\n        address erc20OnMainChain,\n        address erc20OnSchain\n     )\n        external\n        override\n        onlyTokenRegistrar\n    {\n        require(messageProxy.isConnectedChain(targetChainName), \"Chain is not connected\");\n        require(erc20OnSchain.isContract(), \"Given address is not a contract\");\n        require(ERC20OnChain(erc20OnSchain).totalSupply() == 0, \"TotalSupply is not zero\");\n        bytes32 targetChainHash = keccak256(abi.encodePacked(targetChainName));\n        require(address(clonesErc20[targetChainHash][erc20OnMainChain]) == address(0), \"Could not relink clone\");\n        require(!addedClones[ERC20OnChain(erc20OnSchain)], \"Clone was already added\");\n        clonesErc20[targetChainHash][erc20OnMainChain] = ERC20OnChain(erc20OnSchain);\n        addedClones[ERC20OnChain(erc20OnSchain)] = true;\n        emit ERC20TokenAdded(targetChainHash, erc20OnMainChain, erc20OnSchain);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox\n    )\n        external\n        override        \n    {\n        TokenManager.initializeTokenManager(\n            newChainName,\n            newMessageProxy,\n            newIMALinker,\n            newCommunityLocker,\n            newDepositBox\n        );\n    }\n\n    // private\n\n    /**\n     * @dev Allows TokenManager to send ERC20 tokens.\n     *  \n     * Emits a {ERC20TokenCreated} event if token did not exist and was automatically deployed.\n     * Emits a {ERC20TokenReceived} event on success.\n     */\n    function _sendERC20(bytes32 fromChainHash, bytes calldata data) private returns (address) {        \n        Messages.MessageType messageType = Messages.getMessageType(data);\n        (address receiver, address token, uint256 amount) = _decodeErc20Message(data);\n        ERC20OnChain contractOnSchain;\n        if (messageType != Messages.MessageType.TRANSFER_ERC20) {\n            uint256 totalSupply;\n            if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n                Messages.TransferErc20AndTotalSupplyMessage memory message =\n                    Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n            } else {\n                Messages.TransferErc20AndTokenInfoMessage memory message =\n                    Messages.decodeTransferErc20AndTokenInfoMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n\n                if (address(contractOnSchain) == address(0)) {\n                    require(automaticDeploy, \"Automatic deploy is disabled\");\n                    contractOnSchain = new ERC20OnChain(message.tokenInfo.name, message.tokenInfo.symbol);\n                    clonesErc20[fromChainHash][token] = contractOnSchain;\n                    addedClones[contractOnSchain] = true;\n                    emit ERC20TokenCreated(fromChainHash, token, address(contractOnSchain));\n                }\n            }\n            if (totalSupply != totalSupplyOnMainnet[contractOnSchain]) {\n                totalSupplyOnMainnet[contractOnSchain] = totalSupply;\n            }\n            bool noOverflow;\n            uint updatedTotalSupply;\n            (noOverflow, updatedTotalSupply) = SafeMathUpgradeable.tryAdd(contractOnSchain.totalSupply(), amount);\n            require(\n                noOverflow && updatedTotalSupply <= totalSupplyOnMainnet[contractOnSchain],\n                \"Total supply exceeded\"\n            );\n            contractOnSchain.mint(receiver, amount);\n        } else {\n            require(token.isContract() && _schainToERC20[fromChainHash].contains(token), \"Incorrect main chain token\");\n            require(ERC20Upgradeable(token).balanceOf(address(this)) >= amount, \"Not enough money\");\n            _removeTransferredAmount(fromChainHash, token, amount);\n            require(\n                ERC20Upgradeable(token).transfer(receiver, amount),\n                \"Transfer was failed\"\n            );\n        }\n        emit ERC20TokenReceived(fromChainHash, token, address(contractOnSchain), amount);\n        return receiver;\n    }\n\n    /**\n     * @dev Burn tokens on schain and send message to unlock them on target chain.\n     */\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n    {\n        bool isMainChainToken;\n        ERC20BurnableUpgradeable contractOnSchain = clonesErc20[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC20BurnableUpgradeable(contractOnMainChain);\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.balanceOf(msg.sender) >= amount, \"Insufficient funds\");\n        require(\n            contractOnSchain.allowance(\n                msg.sender,\n                address(this)\n            ) >= amount,\n            \"Transfer is not approved by token holder\"\n        );\n        bytes memory data = Messages.encodeTransferErc20Message(address(contractOnMainChain), to, amount);\n        if (isMainChainToken) {\n            data = _receiveERC20(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                amount\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), amount);\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n        } else {\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n            contractOnSchain.burn(amount);\n        }\n        messageProxy.postOutgoingMessage(\n            chainHash,\n            messageReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] += amount;\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] -= amount;\n    }\n\n    /**\n     * @dev Allows DepositBoxERC20 to receive ERC20 tokens.\n     * \n     * Emits an {ERC20TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Amount must be less than or equal to the total supply of the ERC20 contract.\n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC20.\n     */\n    function _receiveERC20(\n        bytes32 chainHash,\n        address erc20OnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        ERC20BurnableUpgradeable erc20 = ERC20BurnableUpgradeable(erc20OnMainChain);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[chainHash].contains(erc20OnMainChain);\n        if (!isERC20AddedToSchain) {\n            _addERC20ForSchain(chainHash, erc20OnMainChain);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(chainHash, erc20OnMainChain, amount);\n    }\n\n    /**\n     * @dev Adds an ERC20 token to DepositBoxERC20.\n     * \n     * Emits an {ERC20TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC20ForSchain(bytes32 chainHash, address erc20OnMainChain) private {\n        require(erc20OnMainChain.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC20[chainHash].contains(erc20OnMainChain), \"ERC20 Token was already added\");\n        _schainToERC20[chainHash].add(erc20OnMainChain);\n        emit ERC20TokenAdded(chainHash, erc20OnMainChain, address(0));\n    }\n\n    /**\n     * @dev Returns total supply of ERC20 token.\n     */\n    function _getErc20TotalSupply(ERC20Upgradeable erc20Token) private view returns (uint256) {\n        return erc20Token.totalSupply();\n    }\n\n    /**\n     * @dev Returns info about ERC20 token such as token name, decimals, symbol.\n     */\n    function _getErc20TokenInfo(ERC20Upgradeable erc20Token) private view returns (Messages.Erc20TokenInfo memory) {\n        return Messages.Erc20TokenInfo({\n            name: erc20Token.name(),\n            decimals: erc20Token.decimals(),\n            symbol: erc20Token.symbol()\n        });\n    }\n\n    /**\n     * @dev Decodes ERC20 transfer message depending on type of message.\n     */\n    function _decodeErc20Message(bytes calldata data)\n        private\n        pure\n        returns (address, address, uint256)\n    {\n        Messages.MessageType messageType = Messages.getMessageType(data);\n        if (messageType == Messages.MessageType.TRANSFER_ERC20) {\n            Messages.TransferErc20Message memory message =\n                Messages.decodeTransferErc20Message(data);\n            return (\n                message.receiver,\n                message.token,\n                message.amount\n            );\n        } else if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n            Messages.TransferErc20AndTotalSupplyMessage memory messageTotalSupply =\n                Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n            return (\n                messageTotalSupply.baseErc20transfer.receiver,\n                messageTotalSupply.baseErc20transfer.token,\n                messageTotalSupply.baseErc20transfer.amount\n            );\n        } else {\n            Messages.TransferErc20AndTokenInfoMessage memory messageTokenInfo =\n                Messages.decodeTransferErc20AndTokenInfoMessage(data);\n            return (\n                messageTokenInfo.baseErc20transfer.receiver,\n                messageTokenInfo.baseErc20transfer.token,\n                messageTokenInfo.baseErc20transfer.amount\n            );\n        }\n    }\n}"
    },
    {
      "filename": "contracts/schain/TokenManagers/TokenManagerERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC20.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../tokens/ERC20OnChain.sol\";\nimport \"../TokenManager.sol\";\n\n\n/**\n * @title TokenManagerERC20\n * @dev Runs on SKALE Chains,\n * accepts messages from mainnet,\n * and creates ERC20 clones.\n * TokenManagerERC20 mints tokens. When a user exits a SKALE chain, it burns them.\n */\ncontract TokenManagerERC20 is TokenManager, ITokenManagerERC20 {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // address of ERC20 on Mainnet => ERC20 on Schain\n    mapping(address => ERC20OnChain) public deprecatedClonesErc20;\n    \n    // address of clone on schain => totalSupplyOnMainnet\n    mapping(IERC20Upgradeable => uint) public totalSupplyOnMainnet;\n\n    // address clone on schain => added or not\n    mapping(ERC20OnChain => bool) public addedClones;\n\n    mapping(bytes32 => mapping(address => ERC20OnChain)) public clonesErc20;\n\n    mapping(bytes32 => mapping(address => uint256)) public transferredAmount;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC20;\n\n    /**\n     * @dev Emitted when schain owner register new ERC20 clone.\n     */\n    event ERC20TokenAdded(bytes32 indexed chainHash, address indexed erc20OnMainChain, address indexed erc20OnSchain);\n\n    /**\n     * @dev Emitted when TokenManagerERC20 automatically deploys new ERC20 clone.\n     */\n    event ERC20TokenCreated(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain\n    );\n\n    /**\n     * @dev Emitted when someone sends tokens from mainnet to schain.\n     */\n    event ERC20TokenReceived(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when token is received by TokenManager and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC20TokenReady(bytes32 indexed chainHash, address indexed contractOnMainnet, uint256 amount);\n\n    /**\n     * @dev Move tokens from schain to mainnet.\n     * \n     * {contractOnMainnet} tokens are burned on schain and unlocked on mainnet for {msg.sender} address.\n     */\n    function exitToMainERC20(\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(msg.sender);\n        _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Move tokens from schain to schain.\n     * \n     * {contractOnMainnet} tokens are burned on origin schain\n     * and are minted on {targetSchainName} schain for {msg.sender} address.\n     */\n    function transferToSchainERC20(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n        rightTransaction(targetSchainName, msg.sender)\n    {\n        bytes32 targetSchainHash = keccak256(abi.encodePacked(targetSchainName));\n        _exit(targetSchainHash, tokenManagers[targetSchainHash], contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the sender.\n     * - `fromChainHash` must exist in TokenManager addresses.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        checkReceiverChain(fromChainHash, sender)\n        returns (address)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        address receiver = address(0);\n        if (\n            operation == Messages.MessageType.TRANSFER_ERC20 ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOKEN_INFO ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY\n        ) {\n            receiver = _sendERC20(fromChainHash, data);\n        } else {\n            revert(\"MessageType is unknown\");\n        }\n        return receiver;\n    }\n\n    /**\n     * @dev Allows Schain owner to register an ERC20 token clone in the TokenManager.\n     */\n    function addERC20TokenByOwner(\n        string calldata targetChainName,\n        address erc20OnMainChain,\n        address erc20OnSchain\n     )\n        external\n        override\n        onlyTokenRegistrar\n    {\n        require(messageProxy.isConnectedChain(targetChainName), \"Chain is not connected\");\n        require(erc20OnSchain.isContract(), \"Given address is not a contract\");\n        require(ERC20OnChain(erc20OnSchain).totalSupply() == 0, \"TotalSupply is not zero\");\n        bytes32 targetChainHash = keccak256(abi.encodePacked(targetChainName));\n        require(address(clonesErc20[targetChainHash][erc20OnMainChain]) == address(0), \"Could not relink clone\");\n        require(!addedClones[ERC20OnChain(erc20OnSchain)], \"Clone was already added\");\n        clonesErc20[targetChainHash][erc20OnMainChain] = ERC20OnChain(erc20OnSchain);\n        addedClones[ERC20OnChain(erc20OnSchain)] = true;\n        emit ERC20TokenAdded(targetChainHash, erc20OnMainChain, erc20OnSchain);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox\n    )\n        external\n        override        \n    {\n        TokenManager.initializeTokenManager(\n            newChainName,\n            newMessageProxy,\n            newIMALinker,\n            newCommunityLocker,\n            newDepositBox\n        );\n    }\n\n    // private\n\n    /**\n     * @dev Allows TokenManager to send ERC20 tokens.\n     *  \n     * Emits a {ERC20TokenCreated} event if token did not exist and was automatically deployed.\n     * Emits a {ERC20TokenReceived} event on success.\n     */\n    function _sendERC20(bytes32 fromChainHash, bytes calldata data) private returns (address) {        \n        Messages.MessageType messageType = Messages.getMessageType(data);\n        (address receiver, address token, uint256 amount) = _decodeErc20Message(data);\n        ERC20OnChain contractOnSchain;\n        if (messageType != Messages.MessageType.TRANSFER_ERC20) {\n            uint256 totalSupply;\n            if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n                Messages.TransferErc20AndTotalSupplyMessage memory message =\n                    Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n            } else {\n                Messages.TransferErc20AndTokenInfoMessage memory message =\n                    Messages.decodeTransferErc20AndTokenInfoMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n\n                if (address(contractOnSchain) == address(0)) {\n                    require(automaticDeploy, \"Automatic deploy is disabled\");\n                    contractOnSchain = new ERC20OnChain(message.tokenInfo.name, message.tokenInfo.symbol);\n                    clonesErc20[fromChainHash][token] = contractOnSchain;\n                    addedClones[contractOnSchain] = true;\n                    emit ERC20TokenCreated(fromChainHash, token, address(contractOnSchain));\n                }\n            }\n            if (totalSupply != totalSupplyOnMainnet[contractOnSchain]) {\n                totalSupplyOnMainnet[contractOnSchain] = totalSupply;\n            }\n            bool noOverflow;\n            uint updatedTotalSupply;\n            (noOverflow, updatedTotalSupply) = SafeMathUpgradeable.tryAdd(contractOnSchain.totalSupply(), amount);\n            require(\n                noOverflow && updatedTotalSupply <= totalSupplyOnMainnet[contractOnSchain],\n                \"Total supply exceeded\"\n            );\n            contractOnSchain.mint(receiver, amount);\n        } else {\n            require(token.isContract() && _schainToERC20[fromChainHash].contains(token), \"Incorrect main chain token\");\n            require(ERC20Upgradeable(token).balanceOf(address(this)) >= amount, \"Not enough money\");\n            _removeTransferredAmount(fromChainHash, token, amount);\n            require(\n                ERC20Upgradeable(token).transfer(receiver, amount),\n                \"Transfer was failed\"\n            );\n        }\n        emit ERC20TokenReceived(fromChainHash, token, address(contractOnSchain), amount);\n        return receiver;\n    }\n\n    /**\n     * @dev Burn tokens on schain and send message to unlock them on target chain.\n     */\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n    {\n        bool isMainChainToken;\n        ERC20BurnableUpgradeable contractOnSchain = clonesErc20[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC20BurnableUpgradeable(contractOnMainChain);\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.balanceOf(msg.sender) >= amount, \"Insufficient funds\");\n        require(\n            contractOnSchain.allowance(\n                msg.sender,\n                address(this)\n            ) >= amount,\n            \"Transfer is not approved by token holder\"\n        );\n        bytes memory data = Messages.encodeTransferErc20Message(address(contractOnMainChain), to, amount);\n        if (isMainChainToken) {\n            data = _receiveERC20(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                amount\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), amount);\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n        } else {\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n            contractOnSchain.burn(amount);\n        }\n        messageProxy.postOutgoingMessage(\n            chainHash,\n            messageReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] += amount;\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] -= amount;\n    }\n\n    /**\n     * @dev Allows DepositBoxERC20 to receive ERC20 tokens.\n     * \n     * Emits an {ERC20TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Amount must be less than or equal to the total supply of the ERC20 contract.\n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC20.\n     */\n    function _receiveERC20(\n        bytes32 chainHash,\n        address erc20OnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        ERC20BurnableUpgradeable erc20 = ERC20BurnableUpgradeable(erc20OnMainChain);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[chainHash].contains(erc20OnMainChain);\n        if (!isERC20AddedToSchain) {\n            _addERC20ForSchain(chainHash, erc20OnMainChain);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(chainHash, erc20OnMainChain, amount);\n    }\n\n    /**\n     * @dev Adds an ERC20 token to DepositBoxERC20.\n     * \n     * Emits an {ERC20TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC20ForSchain(bytes32 chainHash, address erc20OnMainChain) private {\n        require(erc20OnMainChain.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC20[chainHash].contains(erc20OnMainChain), \"ERC20 Token was already added\");\n        _schainToERC20[chainHash].add(erc20OnMainChain);\n        emit ERC20TokenAdded(chainHash, erc20OnMainChain, address(0));\n    }\n\n    /**\n     * @dev Returns total supply of ERC20 token.\n     */\n    function _getErc20TotalSupply(ERC20Upgradeable erc20Token) private view returns (uint256) {\n        return erc20Token.totalSupply();\n    }\n\n    /**\n     * @dev Returns info about ERC20 token such as token name, decimals, symbol.\n     */\n    function _getErc20TokenInfo(ERC20Upgradeable erc20Token) private view returns (Messages.Erc20TokenInfo memory) {\n        return Messages.Erc20TokenInfo({\n            name: erc20Token.name(),\n            decimals: erc20Token.decimals(),\n            symbol: erc20Token.symbol()\n        });\n    }\n\n    /**\n     * @dev Decodes ERC20 transfer message depending on type of message.\n     */\n    function _decodeErc20Message(bytes calldata data)\n        private\n        pure\n        returns (address, address, uint256)\n    {\n        Messages.MessageType messageType = Messages.getMessageType(data);\n        if (messageType == Messages.MessageType.TRANSFER_ERC20) {\n            Messages.TransferErc20Message memory message =\n                Messages.decodeTransferErc20Message(data);\n            return (\n                message.receiver,\n                message.token,\n                message.amount\n            );\n        } else if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n            Messages.TransferErc20AndTotalSupplyMessage memory messageTotalSupply =\n                Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n            return (\n                messageTotalSupply.baseErc20transfer.receiver,\n                messageTotalSupply.baseErc20transfer.token,\n                messageTotalSupply.baseErc20transfer.amount\n            );\n        }"
    }
  ]
}