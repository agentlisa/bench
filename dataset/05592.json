{
  "Title": "[G-01] Using immutable on variables that are only set in the constructor and never after (Save 14.7K Gas)",
  "Content": "\nUse immutable if you want to assign a permanent value at construction. Use constants if you already know the permanent value. Both get directly embedded in bytecode, saving SLOAD.\n\n**Note: These were not found by the bot**\n\n**Total Instances: 7**<br>\n**Gas Per Instance: 2.1 K**<br>\n**Total Gas Saved: 14.7K gas**\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/AccountingEngine.sol#L58\n```solidity\nFile: /src/contracts/AccountingEngine.sol\n58:  AccountingEngineParams public _params;\n```\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/oracles/UniV3Relayer.sol#L23\n```solidity\nFile: /src/contracts/oracles/UniV3Relayer.sol\n23:  address public baseToken;\n\n25:  address public quoteToken;\n\n33:  uint128 public baseAmount;\n\n35:  uint256 public multiplier;\n\n37:  uint32 public quotePeriod;\n```\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L26\n```solidity\nFile: /src/contracts/proxies/ODSafeManager.sol\n26:  address public safeEngine;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/AccountingEngine.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {IAccountingEngine} from '@interfaces/IAccountingEngine.sol';\nimport {IDebtAuctionHouse} from '@interfaces/IDebtAuctionHouse.sol';\nimport {ISurplusAuctionHouse} from '@interfaces/ISurplusAuctionHouse.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\n\nimport {Authorizable, IAuthorizable} from '@contracts/utils/Authorizable.sol';\nimport {Disableable} from '@contracts/utils/Disableable.sol';\nimport {Modifiable} from '@contracts/utils/Modifiable.sol';\n\nimport {Encoding} from '@libraries/Encoding.sol';\nimport {Math, WAD} from '@libraries/Math.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\n/**\n * @title  AccountingEngine\n * @notice This contract is responsible for handling protocol surplus and debt\n * @notice It allows the system to auction surplus and debt, as well as transfer surplus\n * @dev    This is a system contract, therefore it is not meant to be used by users directly\n */\ncontract AccountingEngine is Authorizable, Modifiable, Disableable, IAccountingEngine {\n  using Encoding for bytes;\n  using Assertions for address;\n  using Math for uint256;\n\n  uint256 internal constant ONE_HUNDRED_WAD = 100 * WAD;\n\n  // --- Auth ---\n\n  /**\n   * @notice Overriding method allows new authorizations only if the contract is enabled\n   * @param  _account The account to authorize\n   * @inheritdoc IAuthorizable\n   */\n  function addAuthorization(address _account) external override(Authorizable, IAuthorizable) isAuthorized whenEnabled {\n    _addAuthorization(_account);\n  }\n\n  // --- Registry ---\n\n  /// @inheritdoc IAccountingEngine\n  ISAFEEngine public safeEngine;\n  /// @inheritdoc IAccountingEngine\n  ISurplusAuctionHouse public surplusAuctionHouse;\n  /// @inheritdoc IAccountingEngine\n  IDebtAuctionHouse public debtAuctionHouse;\n  /// @inheritdoc IAccountingEngine\n  address public postSettlementSurplusDrain;\n  /// @inheritdoc IAccountingEngine\n  address public extraSurplusReceiver;\n\n  // --- Params ---\n\n  /// @inheritdoc IAccountingEngine\n  // solhint-disable-next-line private-vars-leading-underscore\n  AccountingEngineParams public _params;\n\n  /// @inheritdoc IAccountingEngine\n  function params() external view returns (AccountingEngineParams memory _accEngineParams) {\n    return _params;\n  }\n\n  // --- Data ---\n\n  /// @inheritdoc IAccountingEngine\n  mapping(uint256 _timestamp => uint256 _rad) public debtQueue;\n  /// @inheritdoc IAccountingEngine\n  uint256 public /* RAD */ totalOnAuctionDebt;\n  /// @inheritdoc IAccountingEngine\n  uint256 public /* RAD */ totalQueuedDebt;\n  /// @inheritdoc IAccountingEngine\n  uint256 public lastSurplusTime;\n  /// @inheritdoc IAccountingEngine\n  uint256 public disableTimestamp;\n\n  // --- Init ---\n\n  /**\n   * @param  _safeEngine Address of the SAFEEngine\n   * @param  _surplusAuctionHouse Address of the SurplusAuctionHouse\n   * @param  _debtAuctionHouse Address of the DebtAuctionHouse\n   * @param  _accEngineParams Initial valid AccountingEngine parameters struct\n   */\n  constructor(\n    address _safeEngine,\n    address _surplusAuctionHouse,\n    address _debtAuctionHouse,\n    AccountingEngineParams memory _accEngineParams\n  ) Authorizable(msg.sender) validParams {\n    safeEngine = ISAFEEngine(_safeEngine.assertNonNull());\n    _setSurplusAuctionHouse(_surplusAuctionHouse);\n    debtAuctionHouse = IDebtAuctionHouse(_debtAuctionHouse);\n\n    lastSurplusTime = block.timestamp;\n\n    _params = _accEngineParams;\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IAccountingEngine\n  function unqueuedUnauctionedDebt() external view returns (uint256 __unqueuedUnauctionedDebt) {\n    return _unqueuedUnauctionedDebt(safeEngine.debtBalance(address(this)));\n  }\n\n  function _unqueuedUnauctionedDebt(uint256 _debtBalance) internal view returns (uint256 __unqueuedUnauctionedDebt) {\n    return (_debtBalance - totalQueuedDebt) - totalOnAuctionDebt;\n  }\n\n  // --- Debt Queueing ---\n\n  /// @inheritdoc IAccountingEngine\n  function pushDebtToQueue(uint256 _debtBlock) external isAuthorized {\n    debtQueue[block.timestamp] = debtQueue[block.timestamp] + _debtBlock;\n    totalQueuedDebt = totalQueuedDebt + _debtBlock;\n\n    emit PushDebtToQueue(block.timestamp, _debtBlock);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function popDebtFromQueue(uint256 _debtBlockTimestamp) external {\n    if (block.timestamp < _debtBlockTimestamp + _params.popDebtDelay) revert AccEng_PopDebtCooldown();\n\n    uint256 _debtBlock = debtQueue[_debtBlockTimestamp];\n\n    if (_debtBlock == 0) revert AccEng_NullAmount();\n\n    totalQueuedDebt = totalQueuedDebt - _debtBlock;\n    debtQueue[_debtBlockTimestamp] = 0;\n\n    emit PopDebtFromQueue(_debtBlockTimestamp, _debtBlock);\n  }\n\n  // Debt settlement\n\n  /// @inheritdoc IAccountingEngine\n  function settleDebt(uint256 _rad) external {\n    _settleDebt(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)), _rad);\n  }\n\n  function _settleDebt(\n    uint256 _coinBalance,\n    uint256 _debtBalance,\n    uint256 _rad\n  ) internal returns (uint256 _newCoinBalance, uint256 _newDebtBalance) {\n    if (_rad > _coinBalance) revert AccEng_InsufficientSurplus();\n    if (_rad > _unqueuedUnauctionedDebt(_debtBalance)) revert AccEng_InsufficientDebt();\n\n    safeEngine.settleDebt(_rad);\n    _newCoinBalance = _coinBalance - _rad;\n    _newDebtBalance = _debtBalance - _rad;\n\n    emit SettleDebt(_rad, _newCoinBalance, _newDebtBalance);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function cancelAuctionedDebtWithSurplus(uint256 _rad) external {\n    if (_rad > totalOnAuctionDebt) revert AccEng_InsufficientDebt();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n\n    if (_rad > _coinBalance) revert AccEng_InsufficientSurplus();\n\n    safeEngine.settleDebt(_rad);\n    totalOnAuctionDebt -= _rad;\n\n    emit CancelDebt(_rad, _coinBalance - _rad, safeEngine.debtBalance(address(this)));\n  }\n\n  // Debt auction\n\n  /// @inheritdoc IAccountingEngine\n  function auctionDebt() external returns (uint256 _id) {\n    if (_params.debtAuctionBidSize == 0) revert AccEng_DebtAuctionDisabled();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n\n    if (_params.debtAuctionBidSize > _unqueuedUnauctionedDebt(_debtBalance)) revert AccEng_InsufficientDebt();\n\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _coinBalance);\n    totalOnAuctionDebt += _params.debtAuctionBidSize;\n\n    _id = debtAuctionHouse.startAuction({\n      _incomeReceiver: address(this),\n      _amountToSell: _params.debtAuctionMintedTokens,\n      _initialBid: _params.debtAuctionBidSize\n    });\n\n    emit AuctionDebt(_id, _params.debtAuctionMintedTokens, _params.debtAuctionBidSize);\n  }\n\n  // Surplus auction\n\n  /// @inheritdoc IAccountingEngine\n  function auctionSurplus() external returns (uint256 _id) {\n    if(_params.surplusTransferPercentage > WAD) revert AccEng_surplusTransferPercentOverLimit();\n    if (_params.surplusAmount == 0) revert AccEng_NullAmount();\n    if (extraSurplusReceiver == address(0)) revert AccEng_NullSurplusReceiver();\n    if (block.timestamp < lastSurplusTime + _params.surplusDelay) revert AccEng_SurplusCooldown();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    (_coinBalance, _debtBalance) = _settleDebt(_coinBalance, _debtBalance, _unqueuedUnauctionedDebt(_debtBalance));\n\n    if (_coinBalance < _debtBalance + _params.surplusAmount + _params.surplusBuffer) {\n      revert AccEng_InsufficientSurplus();\n    }\n\n    // auction surplus percentage\n    if (_params.surplusTransferPercentage < ONE_HUNDRED_WAD) {\n      _id = surplusAuctionHouse.startAuction({\n        _amountToSell: _params.surplusAmount.wmul(ONE_HUNDRED_WAD - _params.surplusTransferPercentage),\n        _initialBid: 0\n      });\n\n      lastSurplusTime = block.timestamp;\n      emit AuctionSurplus(_id, 0, _params.surplusAmount.wmul(ONE_HUNDRED_WAD - _params.surplusTransferPercentage));\n    }\n\n    // transfer surplus percentage\n    if (_params.surplusTransferPercentage > 0) {\n      if (extraSurplusReceiver == address(0)) revert AccEng_NullSurplusReceiver();\n\n      safeEngine.transferInternalCoins({\n        _source: address(this),\n        _destination: extraSurplusReceiver,\n        _rad: _params.surplusAmount.wmul(_params.surplusTransferPercentage)\n      });\n\n      lastSurplusTime = block.timestamp;\n      emit TransferSurplus(extraSurplusReceiver, _params.surplusAmount.wmul(_params.surplusTransferPercentage));\n    }\n  }\n\n  // --- Shutdown ---\n\n  /**\n   * @notice Runtime to be run when the contract is disabled (normally triggered by GlobalSettlement)\n   * @dev When it's being disabled, the contract will record the current timestamp. Afterwards,\n   *      the contract tries to settle as much debt as possible (if there's any) with any surplus that's\n   *      left in the AccountingEngine\n   * @inheritdoc Disableable\n   */\n  function _onContractDisable() internal override {\n    totalQueuedDebt = 0;\n    totalOnAuctionDebt = 0;\n    disableTimestamp = block.timestamp;\n\n    surplusAuctionHouse.disableContract();\n    debtAuctionHouse.disableContract();\n\n    uint256 _debtToSettle = Math.min(safeEngine.coinBalance(address(this)), safeEngine.debtBalance(address(this)));\n    safeEngine.settleDebt(_debtToSettle);\n  }\n\n  /// @inheritdoc IAccountingEngine\n  function transferPostSettlementSurplus() external whenDisabled {\n    if (address(postSettlementSurplusDrain) == address(0)) revert AccEng_NullSurplusReceiver();\n    if (block.timestamp < disableTimestamp + _params.disableCooldown) revert AccEng_PostSettlementCooldown();\n\n    uint256 _coinBalance = safeEngine.coinBalance(address(this));\n    uint256 _debtBalance = safeEngine.debtBalance(address(this));\n    uint256 _debtToSettle = Math.min(_coinBalance, _debtBalance);\n    (_coinBalance,) = _settleDebt(_coinBalance, _debtBalance, _debtToSettle);\n\n    if (_coinBalance > 0) {\n      safeEngine.transferInternalCoins({\n        _source: address(this),\n        _destination: postSettlementSurplusDrain,\n        _rad: _coinBalance\n      });\n\n      emit TransferSurplus(postSettlementSurplusDrain, _coinBalance);\n    }\n  }\n\n  // --- Administration ---\n\n  /// @inheritdoc Modifiable\n  function _modifyParameters(bytes32 _param, bytes memory _data) internal override {\n    uint256 _uint256 = _data.toUint256();\n    address _address = _data.toAddress();\n\n    // params\n    if (_param == 'surplusTransferPercentage') _params.surplusTransferPercentage = _uint256;\n    else if (_param == 'surplusDelay') _params.surplusDelay = _uint256;\n    else if (_param == 'popDebtDelay') _params.popDebtDelay = _uint256;\n    else if (_param == 'disableCooldown') _params.disableCooldown = _uint256;\n    else if (_param == 'surplusAmount') _params.surplusAmount = _uint256;\n    else if (_param == 'debtAuctionBidSize') _params.debtAuctionBidSize = _uint256;\n    else if (_param == 'debtAuctionMintedTokens') _params.debtAuctionMintedTokens = _uint256;\n    else if (_param == 'surplusBuffer') _params.surplusBuffer = _uint256;\n    // registry\n    else if (_param == 'surplusAuctionHouse') _setSurplusAuctionHouse(_address);\n    else if (_param == 'debtAuctionHouse') debtAuctionHouse = IDebtAuctionHouse(_address);\n    else if (_param == 'postSettlementSurplusDrain') postSettlementSurplusDrain = _address;\n    else if (_param == 'extraSurplusReceiver') extraSurplusReceiver = _address;\n    else revert UnrecognizedParam();\n  }\n\n  /// @dev Set the surplus auction house, deny permissions on the old one and approve on the new one\n  function _setSurplusAuctionHouse(address _surplusAuctionHouse) internal {\n    if (address(surplusAuctionHouse) != address(0)) {\n      safeEngine.denySAFEModification(address(surplusAuctionHouse));\n    }\n    surplusAuctionHouse = ISurplusAuctionHouse(_surplusAuctionHouse);\n    safeEngine.approveSAFEModification(_surplusAuctionHouse);\n  }\n\n  /// @inheritdoc Modifiable\n  function _validateParameters() internal view override {\n    address(surplusAuctionHouse).assertNonNull();\n    address(debtAuctionHouse).assertNonNull();\n  }\n}"
    },
    {
      "filename": "src/contracts/oracles/UniV3Relayer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {IBaseOracle} from '@interfaces/oracles/IBaseOracle.sol';\nimport {IUniV3Relayer} from '@interfaces/oracles/IUniV3Relayer.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IUniswapV3Factory} from '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport {OracleLibrary, IUniswapV3Pool} from '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport {UNISWAP_V3_FACTORY, GOERLI_UNISWAP_V3_FACTORY} from '@script/Registry.s.sol';\n\n/**\n * @title  UniV3Relayer\n * @notice This contracts consults a UniswapV3Pool TWAP and transforms the result into a standard IBaseOracle feed\n * @dev    The quote obtained from the pool query is transformed into an 18 decimals format\n */\ncontract UniV3Relayer is IBaseOracle, IUniV3Relayer {\n  // --- Registry ---\n  address internal constant _UNI_V3_FACTORY = GOERLI_UNISWAP_V3_FACTORY;\n\n  /// @inheritdoc IUniV3Relayer\n  address public uniV3Pool;\n  /// @inheritdoc IUniV3Relayer\n  address public baseToken;\n  /// @inheritdoc IUniV3Relayer\n  address public quoteToken;\n\n  // --- Data ---\n\n  /// @inheritdoc IBaseOracle\n  string public symbol;\n\n  /// @inheritdoc IUniV3Relayer\n  uint128 public baseAmount;\n  /// @inheritdoc IUniV3Relayer\n  uint256 public multiplier;\n  /// @inheritdoc IUniV3Relayer\n  uint32 public quotePeriod;\n\n  // --- Init ---\n\n  /**\n   * @param  _baseToken Address of the base token used to consult the quote\n   * @param  _quoteToken Address of the token used as a quote reference\n   * @param  _feeTier Fee tier of the pool used to consult the quote\n   * @param  _quotePeriod Length in seconds of the TWAP used to consult the pool\n   */\n  constructor(address _baseToken, address _quoteToken, uint24 _feeTier, uint32 _quotePeriod) {\n    uniV3Pool = IUniswapV3Factory(_UNI_V3_FACTORY).getPool(_baseToken, _quoteToken, _feeTier);\n    if (uniV3Pool == address(0)) revert UniV3Relayer_InvalidPool();\n\n    address _token0 = IUniswapV3Pool(uniV3Pool).token0();\n    address _token1 = IUniswapV3Pool(uniV3Pool).token1();\n\n    // The factory validates that both token0 and token1 are desired baseToken and quoteTokens\n    if (_token0 == _baseToken) {\n      baseToken = _token0;\n      quoteToken = _token1;\n    } else {\n      baseToken = _token1;\n      quoteToken = _token0;\n    }\n\n    baseAmount = uint128(10 ** IERC20Metadata(_baseToken).decimals());\n    multiplier = 18 - IERC20Metadata(_quoteToken).decimals();\n    quotePeriod = _quotePeriod;\n\n    symbol = string(abi.encodePacked(IERC20Metadata(_baseToken).symbol(), ' / ', IERC20Metadata(_quoteToken).symbol()));\n  }\n\n  /**\n   * @dev    Method will return invalid if the pool doesn't have enough history\n   * @inheritdoc IBaseOracle\n   */\n  function getResultWithValidity() external view returns (uint256 _result, bool _validity) {\n    // If the pool doesn't have enough history return false\n    if (OracleLibrary.getOldestObservationSecondsAgo(uniV3Pool) < quotePeriod) {\n      return (0, false);\n    }\n    // Consult the query with a TWAP period of quotePeriod\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(uniV3Pool, quotePeriod);\n    // Calculate the quote amount\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    // Process the quote result to 18 decimal quote\n    _result = _parseResult(_quoteAmount);\n    _validity = true;\n  }\n\n  /**\n   * @dev    This method may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n   * @inheritdoc IBaseOracle\n   */\n  function read() external view returns (uint256 _result) {\n    // This call may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(uniV3Pool, quotePeriod);\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    _result = _parseResult(_quoteAmount);\n  }\n\n  /// @notice Parses the result from the aggregator into 18 decimals format\n  function _parseResult(uint256 _quoteResult) internal view returns (uint256 _result) {\n    return _quoteResult * 10 ** multiplier;\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/ODSafeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {SAFEHandler} from '@contracts/proxies/SAFEHandler.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ILiquidationEngine} from '@interfaces/ILiquidationEngine.sol';\nimport {IVault721} from '@interfaces/proxies/IVault721.sol';\n\nimport {Math} from '@libraries/Math.sol';\nimport {EnumerableSet} from '@openzeppelin/utils/structs/EnumerableSet.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n\n/**\n * @title  ODSafeManager\n * @notice This contract acts as interface to the SAFEEngine, facilitating the management of SAFEs\n * @dev    This contract is meant to be used by users that interact with the protocol through a proxy contract\n */\ncontract ODSafeManager is IODSafeManager {\n  using Math for uint256;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using Assertions for address;\n\n  /// @inheritdoc IODSafeManager\n  address public safeEngine;\n\n  // --- ERC721 ---\n  IVault721 public vault721;\n\n  uint256 internal _safeId; // Auto incremental\n  mapping(address _safeOwner => EnumerableSet.UintSet) private _usrSafes;\n  /// @notice Mapping of user addresses to their enumerable set of safes per collateral type\n  mapping(address _safeOwner => mapping(bytes32 _cType => EnumerableSet.UintSet)) private _usrSafesPerCollat;\n  /// @notice Mapping of safe ids to their data\n  mapping(uint256 _safeId => SAFEData) internal _safeData;\n\n  /// @inheritdoc IODSafeManager\n  mapping(address _owner => mapping(uint256 _safeId => mapping(address _caller => uint256 _ok))) public safeCan;\n  /// @inheritdoc IODSafeManager\n  mapping(address _safeHandler => mapping(address _caller => uint256 _ok)) public handlerCan;\n\n  // --- Modifiers ---\n\n  /**\n   * @notice Checks if the sender is the owner of the safe or the safe has permissions to call the function\n   * @param  _safe Id of the safe to check if msg.sender has permissions for\n   */\n  modifier safeAllowed(uint256 _safe) {\n    address _owner = _safeData[_safe].owner;\n    if (msg.sender != _owner && safeCan[_owner][_safe][msg.sender] == 0) revert SafeNotAllowed();\n    _;\n  }\n\n  /**\n   * @notice Checks if the sender is the safe handler has permissions to call the function\n   * @param  _handler Address of the handler to check if msg.sender has permissions for\n   */\n  modifier handlerAllowed(address _handler) {\n    if (msg.sender != _handler && handlerCan[_handler][msg.sender] == 0) revert HandlerNotAllowed();\n    _;\n  }\n\n  constructor(address _safeEngine, address _vault721) {\n    safeEngine = _safeEngine.assertNonNull();\n    vault721 = IVault721(_vault721);\n    vault721.initializeManager();\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafes[_usr].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr, bytes32 _cType) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafesPerCollat[_usr][_cType].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafesData(address _usr)\n    external\n    view\n    returns (uint256[] memory _safes, address[] memory _safeHandlers, bytes32[] memory _cTypes)\n  {\n    _safes = _usrSafes[_usr].values();\n    _safeHandlers = new address[](_safes.length);\n    _cTypes = new bytes32[](_safes.length);\n    for (uint256 _i; _i < _safes.length; _i++) {\n      _safeHandlers[_i] = _safeData[_safes[_i]].safeHandler;\n      _cTypes[_i] = _safeData[_safes[_i]].collateralType;\n    }\n  }\n\n  /// @inheritdoc IODSafeManager\n  function safeData(uint256 _safe) external view returns (SAFEData memory _sData) {\n    _sData = _safeData[_safe];\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IODSafeManager\n  function allowSAFE(uint256 _safe, address _usr, uint256 _ok) external safeAllowed(_safe) {\n    address _owner = _safeData[_safe].owner;\n    safeCan[_owner][_safe][_usr] = _ok;\n    emit AllowSAFE(msg.sender, _safe, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function allowHandler(address _usr, uint256 _ok) external {\n    handlerCan[msg.sender][_usr] = _ok;\n    emit AllowHandler(msg.sender, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function openSAFE(bytes32 _cType, address _usr) external returns (uint256 _id) {\n    if (_usr == address(0)) revert ZeroAddress();\n\n    ++_safeId;\n    address _safeHandler = address(new SAFEHandler(safeEngine));\n\n    _safeData[_safeId] = SAFEData({owner: _usr, safeHandler: _safeHandler, collateralType: _cType});\n\n    _usrSafes[_usr].add(_safeId);\n    _usrSafesPerCollat[_usr][_cType].add(_safeId);\n\n    vault721.mint(_usr, _safeId);\n\n    emit OpenSAFE(msg.sender, _usr, _safeId);\n    return _safeId;\n  }\n\n  // Give the safe ownership to a dst address.\n  function transferSAFEOwnership(uint256 _safe, address _dst) external {\n    require(msg.sender == address(vault721), 'SafeMngr: Only Vault721');\n\n    if (_dst == address(0)) revert ZeroAddress();\n    SAFEData memory _sData = _safeData[_safe];\n    if (_dst == _sData.owner) revert AlreadySafeOwner();\n\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n\n    _usrSafes[_dst].add(_safe);\n    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n\n    _safeData[_safe].owner = _dst;\n\n    emit TransferSAFEOwnership(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function modifySAFECollateralization(\n    uint256 _safe,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).modifySAFECollateralization(\n      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(bytes32 _cType, uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_cType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _cType, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferInternalCoins(uint256 _safe, address _dst, uint256 _rad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferInternalCoins(_sData.safeHandler, _dst, _rad);\n    emit TransferInternalCoins(msg.sender, _safe, _dst, _rad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n    emit QuitSystem(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit EnterSystem(msg.sender, _src, _safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n    SAFEData memory _srcData = _safeData[_safeSrc];\n    SAFEData memory _dstData = _safeData[_safeDst];\n    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_srcData.owner].remove(_safeSrc);\n    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n    emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function addSAFE(uint256 _safe) external {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[msg.sender].add(_safe);\n    _usrSafesPerCollat[msg.sender][_sData.collateralType].add(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n    emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n  }\n}"
    }
  ]
}