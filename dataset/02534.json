{
  "Title": "H-3: Fully repaying a loan will result in debt payment being lost",
  "Content": "# Issue H-3: Fully repaying a loan will result in debt payment being lost \n\nSource: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/33 \n\n## Found by \n0x52, wagmi, serial-coder, HonorLt, stent, Avci, libratus, Bahurum, ElKu, berndartmueller\n\n## Summary\n\nWhen a `loan` is fully repaid the `loan` storage is deleted. Since `loan` is a `storage` reference to the loan, `loan.lender` will return `address(0)` after the `loan` has been deleted. This will result in the `debt` being transferred to `address(0)` instead of the lender. Some ERC20 tokens will revert when being sent to `address(0)` but a large number will simply be sent there and lost forever.\n\n## Vulnerability Detail\n\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n        \n        uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n        if (repaid == loan.amount) delete loans[loanID];\n        else {\n            loan.amount -= repaid;\n            loan.collateral -= decollateralized;\n        }\n\n        debt.transferFrom(msg.sender, loan.lender, repaid);\n        collateral.transfer(owner, decollateralized);\n    }\n\nIn `Cooler#repay` the loan storage associated with the loanID being repaid is deleted. `loan` is a storage reference so when `loans[loanID]` is deleted so is `loan`. The result is that `loan.lender` is now `address(0)` and the loan payment will be sent there instead.\n\n## Impact\n\nLender's funds are sent to `address(0)`\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L108-L124\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSend collateral/debt then delete:\n\n    -   if (repaid == loan.amount) delete loans[loanID];\n    +   if (repaid == loan.amount) {\n    +       debt.transferFrom(msg.sender, loan.lender, loan.amount);\n    +       collateral.transfer(owner, loan.collateral);\n    +       delete loans[loanID];\n    +       return;\n    +   }\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Great spot, embarassing oversight.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/36",
  "Code": [
    {
      "filename": "src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./lib/mininterfaces.sol\";\nimport \"./Factory.sol\";\n\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration loans\n///         for a specific user and debt-collateral pair.\ncontract Cooler {\n    // Errors\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n\n    // Data Structures\n\n    Request[] public requests;\n    struct Request { // A loan begins with a borrow request. It specifies:\n        uint256 amount; // the amount they want to borrow,\n        uint256 interest; // the annualized percentage they will pay as interest,\n        uint256 loanToCollateral; // the loan-to-collateral ratio they want,\n        uint256 duration; // and the length of time until the loan defaults.\n        bool active; // Any lender can clear an active loan request.\n    } \n\n    Loan[] public loans;\n    struct Loan { // A request is converted to a loan when a lender clears it.\n        Request request; // The terms of the loan are saved, along with:\n        uint256 amount; // the amount of debt owed,\n        uint256 collateral; // the amount of collateral pledged,\n        uint256 expiry; // the time when the loan defaults,\n        bool rollable; // whether the loan can be rolled over,\n        address lender; // and the lender's address.\n    }\n\n    // Facilitates transfer of lender ownership to new address\n    mapping(uint256 => address) public approvals;\n\n    // Immutables\n\n    // This address owns the collateral in escrow.\n    address private immutable owner;\n    // This token is borrowed against.\n    ERC20 public immutable collateral;\n    // This token is lent.\n    ERC20 public immutable debt;\n    // This contract created the Cooler\n    CoolerFactory public immutable factory;\n\n    // This makes the code look prettier.\n    uint256 private constant decimals = 1e18;\n\n    // Initialization\n\n    constructor (address o, ERC20 c, ERC20 d) {\n        owner = o;\n        collateral = c;\n        debt = d;\n        factory = CoolerFactory(msg.sender);\n    }\n\n    // Borrower\n\n    /// @notice request a loan with given parameters\n    /// @notice collateral is taken at time of request\n    /// @param amount of debt tokens to borrow\n    /// @param interest to pay (annualized % of 'amount')\n    /// @param loanToCollateral debt tokens per collateral token pledged\n    /// @param duration of loan tenure in seconds\n    /// @param reqID index of request in requests[]\n    function request (\n        uint256 amount,\n        uint256 interest,\n        uint256 loanToCollateral,\n        uint256 duration\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        factory.newEvent(reqID, CoolerFactory.Events.Request);\n        requests.push(\n            Request(amount, interest, loanToCollateral, duration, true)\n        );\n        collateral.transferFrom(msg.sender, address(this), collateralFor(amount, loanToCollateral));\n    }\n\n    /// @notice cancel a loan request and return collateral\n    /// @param reqID index of request in requests[]\n    function rescind (uint256 reqID) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n\n        factory.newEvent(reqID, CoolerFactory.Events.Rescind);\n\n        Request storage req = requests[reqID];\n\n        if (!req.active)\n            revert Deactivated();\n        \n        req.active = false;\n        collateral.transfer(owner, collateralFor(req.amount, req.loanToCollateral));\n    }\n\n    /// @notice repay a loan to recoup collateral\n    /// @param loanID index of loan in loans[]\n    /// @param repaid debt tokens to repay\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n        \n        uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n        if (repaid == loan.amount) delete loans[loanID];\n        else {\n            loan.amount -= repaid;\n            loan.collateral -= decollateralized;\n        }\n\n        debt.transferFrom(msg.sender, loan.lender, repaid);\n        collateral.transfer(owner, decollateralized);\n    }\n\n    /// @notice roll a loan over\n    /// @notice uses terms from request\n    /// @param loanID index of loan in loans[]\n    function roll (uint256 loanID) external {\n        Loan storage loan = loans[loanID];\n        Request memory req = loan.request;\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n\n        if (!loan.rollable)\n            revert NotRollable();\n\n        uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n        uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n        loan.amount += newDebt;\n        loan.expiry += req.duration;\n        loan.collateral += newCollateral;\n        \n        collateral.transferFrom(msg.sender, address(this), newCollateral);\n    }\n\n    /// @notice delegate voting power on collateral\n    /// @param to address to delegate\n    function delegate (address to) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n        IDelegateERC20(address(collateral)).delegate(to);\n    }\n\n    // Lender\n\n    /// @notice fill a requested loan as a lender\n    /// @param reqID index of request in requests[]\n    /// @param loanID index of loan in loans[]\n    function clear (uint256 reqID) external returns (uint256 loanID) {\n        Request storage req = requests[reqID];\n\n        factory.newEvent(reqID, CoolerFactory.Events.Clear);\n\n        if (!req.active) \n            revert Deactivated();\n        else req.active = false;\n\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n\n        loanID = loans.length;\n        loans.push(\n            Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n        );\n        debt.transferFrom(msg.sender, owner, req.amount);\n    }\n\n    /// @notice change 'rollable' status of loan\n    /// @param loanID index of loan in loans[]\n    /// @return bool new 'rollable' status\n    function toggleRoll(uint256 loanID) external returns (bool) {\n        Loan storage loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        loan.rollable = !loan.rollable;\n        return loan.rollable;\n    }\n\n    /// @notice send collateral to lender upon default\n    /// @param loanID index of loan in loans[]\n    /// @return uint256 collateral amount\n    function defaulted (uint256 loanID) external returns (uint256) {\n        Loan memory loan = loans[loanID];\n        delete loans[loanID];\n\n        if (block.timestamp <= loan.expiry) \n            revert NoDefault();\n\n        collateral.transfer(loan.lender, loan.collateral);\n        return loan.collateral;\n    }\n\n    /// @notice approve transfer of loan ownership to new address\n    /// @param to address to approve\n    /// @param loanID index of loan in loans[]\n    function approve (address to, uint256 loanID) external {\n        Loan memory loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        approvals[loanID] = to;\n    }\n\n    /// @notice execute approved transfer of loan ownership\n    /// @param loanID index of loan in loans[]\n    function transfer (uint256 loanID) external {\n        if (msg.sender != approvals[loanID])\n            revert OnlyApproved();\n\n        approvals[loanID] = address(0);\n        loans[loanID].lender = msg.sender;\n    }\n\n    // Views\n\n    /// @notice compute collateral needed for loan amount at given loan to collateral ratio\n    /// @param amount of collateral tokens\n    /// @param loanToCollateral ratio for loan\n    function collateralFor(uint256 amount, uint256 loanToCollateral) public pure returns (uint256) {\n        return amount * decimals / loanToCollateral;\n    }\n\n    /// @notice compute interest cost on amount for duration at given annualized rate\n    /// @param amount of debt tokens\n    /// @param rate of interest (annualized)\n    /// @param duration of loan in seconds\n    /// @return interest as a number of debt tokens\n    function interestFor(uint256 amount, uint256 rate, uint256 duration) public pure returns (uint256) {\n        uint256 interest = rate * duration / 365 days;\n        return amount * interest / decimals;\n    }\n\n    /// @notice check if given loan is in default\n    /// @param loanID index of loan in loans[]\n    /// @return defaulted status\n    function isDefaulted(uint256 loanID) external view returns (bool) {\n        return block.timestamp > loans[loanID].expiry;\n    }\n\n    /// @notice check if given request is active\n    /// @param reqID index of request in requests[]\n    /// @return active status\n    function isActive(uint256 reqID) external view returns (bool) {\n        return requests[reqID].active;\n    }\n}"
    }
  ]
}