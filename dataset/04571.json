{
  "Title": "ERC20 compliance",
  "Content": "ERC20 specifies `decimals` to be a value of type `uint8`. It is [declared](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L15)as a `uint256` variable in `RCNCrowdsale`. Consider changing it to `uint8`. If so, it will be necessary to cast to `uint256` when using the variable for arithmetic such as when expressing token amounts as [`400 * 10**decimals`](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L29). Consider defining a state variable `TOKEN_UNIT = 10 ** uint256(decimals)` to write `400 * TOKEN_UNIT` in these cases.\n\n\nAdditionally, [treat transfers of zero tokens normally](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer), by returning `true` and emitting the `Transfer` event in both [`transfer`](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/StandardToken.sol#L18)and [`transferFrom`](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/StandardToken.sol#L29).\n\n\n***Update:** Fixed in [`0daf25a`](https://github.com/ripio/rcn-token/commit/0daf25a7aa83eda7da4d423793ee2cdabfa18d66)*.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RCNCrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"./StandardToken.sol\";\nimport \"./zeppelin/SafeMath.sol\";\nimport \"./Crowdsale.sol\";\nimport \"./CapWhitelist.sol\";\nimport \"./MintableToken.sol\";\n\ncontract RCNCrowdsale is Crowdsale {\n    using SafeMath for uint256;\n\n    // metadata\n    string public constant name = \"Ripio Credit Network Token\";\n    string public constant symbol = \"RCN\";\n    uint256 public constant decimals = 18;\n    string public version = \"1.0\";\n\n    // contracts\n    address public ethFundDeposit;      // deposit address for ETH for Ripio\n    address public rcnFundDeposit;      // deposit address for Ripio use and RCN User Fund\n\n    // crowdsale parameters\n    bool public isFinalized;              // switched to true in operational state\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n    uint256 public constant rcnFund = 490 * (10**6) * 10**decimals;   // 490m RCN reserved for Ripio use\n    uint256 public constant tokenExchangeRate = 4000; // 4000 RCN tokens per 1 ETH\n    uint256 public constant tokenCreationCap =  1000 * (10**6) * 10**decimals;\n    uint256 public constant minBuyTokens = 400 * 10**decimals; // 0.1 ETH\n\n    // events\n    event LogRefund(address indexed _to, uint256 _value);\n    event CreateRCN(address indexed _to, uint256 _value);\n\n    mapping (address => uint256) bought; // cap map\n\n    uint256 public raised;\n\n    CapWhitelist public whiteList;\n    MintableToken public token;\n\n    // constructor\n    function RCNCrowdsale(address _ethFundDeposit,\n          address _rcnFundDeposit,\n          uint256 _fundingStartBlock,\n          uint256 _fundingEndBlock) {\n      token = new MintableToken();\n      whiteList = new CapWhitelist();\n      isFinalized = false;                   //controls pre through crowdsale state\n      ethFundDeposit = _ethFundDeposit;\n      rcnFundDeposit = _rcnFundDeposit;\n      fundingStartBlock = _fundingStartBlock;\n      fundingEndBlock = _fundingEndBlock;\n      token.mint(rcnFundDeposit, rcnFund);\n      raised = rcnFund;\n      CreateRCN(rcnFundDeposit, rcnFund);  // logs Ripio Intl fund\n    }\n\n    /// @dev Accepts ether and creates new RCN tokens.\n    function createTokens() payable external {\n      buyTokens(msg.sender);\n    }\n\n    // low level token purchase function\n    function buyTokens(address beneficiary) payable {\n      if (isFinalized) throw;\n      if (block.number < fundingStartBlock) throw;\n      if (block.number > fundingEndBlock) throw;\n      if (msg.value == 0) throw;\n      if (beneficiary == 0x0) throw;\n\n      uint256 tokens = msg.value.mul(tokenExchangeRate); // check that we're not over totals\n      uint256 checkedSupply = raised.add(tokens);\n\n      // if sender is not whitelisted and exceeds the cap, cancel the transaction\n      if (bought[msg.sender] + tokens > whiteList.whitelist(msg.sender)) throw;\n\n      // return money if something goes wrong\n      if (tokenCreationCap < checkedSupply) throw;  // odd fractions won't be found\n\n      // return money if tokens is less than the min amount and the token is not finalizing\n      // the min amount does not apply if the availables tokens are less than the min amount.\n      if (tokens < minBuyTokens && (tokenCreationCap - raised) > minBuyTokens) throw;\n\n      raised = checkedSupply;\n      token.mint(beneficiary, tokens);\n      bought[msg.sender] += tokens;\n      CreateRCN(beneficiary, tokens);  // logs token creation\n\n      forwardFunds();\n    }\n\n    function finalize() {\n      if (isFinalized) throw;\n      if (block.number <= fundingEndBlock && raised != tokenCreationCap) throw;\n      if (msg.sender != ethFundDeposit) throw;\n      isFinalized = true;\n      token.finishMinting();\n      whiteList.destruct();\n    }\n\n    // send ether to the fund collection wallet\n    function forwardFunds() internal {\n      ethFundDeposit.transfer(msg.value);\n    }\n\n    function setWhitelist(address _address, uint256 _amount) {\n      if (msg.sender != ethFundDeposit) throw;\n      whiteList.setWhitelisted(_address, _amount);\n    }\n}"
    }
  ]
}