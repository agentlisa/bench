{
  "Title": "M-2: `CREATE2` address collision against an Account will allow complete draining of lending pools",
  "Content": "# Issue M-2: `CREATE2` address collision against an Account will allow complete draining of lending pools \n\nSource: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/59 \n\n## Found by \nPUSH0\n## Summary\n\nThe factory function `createAccount()` creates a new account contract for the user using `CREATE2`. We show that a meet-in-the-middle attack at finding an address collision against an undeployed account is possible. Furthermore, such an attack allows draining of all funds from the lending pool.\n\n## Vulnerability Detail\n\nThe attack consists of two parts: Finding a collision, and actually draining the lending pool. We describe both here:\n\n### PoC: Finding a collision\n\nNote that in `createAccount`, `CREATE2` salt is user-supplied, and `tx.origin` is technically also user-supplied:\n\n```solidity\naccount = address(\n    new Proxy{ salt: keccak256(abi.encodePacked(salt, tx.origin)) }(\n        versionInformation[accountVersion].implementation\n    )\n);\n```\n\nThe address collision an attacker will need to find are:\n- One undeployed Arcadia account address (1).\n- Arbitrary attacker-controlled wallet contract (2).\n\nBoth sets of addresses can be brute-force searched because:\n- As shown above, `salt` is a user-supplied parameter. By brute-forcing many `salt` values, we have obtained many different (undeployed) wallet accounts for (1).\n- (2) can be searched the same way. The contract just has to be deployed using `CREATE2`, and the salt is in the attacker's control by definition.\n\nAn attacker can find any single address collision between (1) and (2) with high probability of success using the following meet-in-the-middle technique, a classic brute-force-based attack in cryptography:\n- Brute-force a sufficient number of values of salt ($2^{80}$), pre-compute the resulting account addresses, and efficiently store them e.g. in a Bloom filter data structure.\n- Brute-force contract pre-computation to find a collision with any address within the stored set in step 1.\n\nThe feasibility, as well as detailed technique and hardware requirements of finding a collision, are sufficiently described in multiple references: \n- [1](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/90): A past issue on Sherlock describing this attack.\n- [2](https://eips.ethereum.org/EIPS/eip-3607): EIP-3607, which rationale is this exact attack. The EIP is in final state.\n- [3](https://mystenlabs.com/blog/ambush-attacks-on-160bit-objectids-addresses): A blog post discussing the cost (money and time) of this exact attack.\n\nThe [hashrate of the BTC network](https://www.blockchain.com/explorer/charts/hash-rate) has reached $6 \\times 10^{20}$ hashes per second as of time of writing, taking only just $33$ minutes to achieve $2^{80}$ hashes. A fraction of this computing power will still easily find a collision in a reasonably short timeline. \n\n### PoC: Draining the lending pool\n\nEven given EIP-3607 which disables an EOA if a contract is already deployed on top, we show that it's still possible to drain the lending pool entirely given a contract collision.\n\nAssuming the attacker has already found an address collision against an undeployed account, let's say `0xCOLLIDED`. The steps for complete draining of a lending pool are as follow:\n\nFirst tx:\n- Deploy the attack contract onto address `0xCOLLIDED`.\n- Set infinite allowance for {`0xCOLLIDED` ---> attacker wallet} for any token they want.\n- Destroy the contract using `selfdestruct`.\n    - Post Dencun hardfork, [`selfdestruct` is still possible if the contract was created in the same transaction](https://eips.ethereum.org/EIPS/eip-6780). The only catch is that all 3 of these steps must be done in one tx.\n\nThe attacker now has complete control of any funds sent to `0xCOLLIDED`. \n\nSecond tx:\n- Deploy an account to `0xCOLLIDED`. \n- Deposit an asset, collateralize it, then drain the collateral using the allowance set in tx1.\n- Repeat step 2 for as long as they need to (i.e. collateralize the same asset multiple times).\n    - The account at `0xCOLLIDED` is now infinitely collateralized.\n    - Funds for step 2 and 3 can be obtained through external flash loan. Simply return the funds when this step is finished.\n- An infinitely collateralized account has infinite borrow power. Simply borrow all the funds from the lending pool and run away with it, leaving an infinity collateral account that actually holds no funds.\n\nThe attacker has stolen all funds from the lending pool.\n\n### Coded unit-PoC\n\nWhile we cannot provide an actual hash collision due to infrastructural constraints, we are able to provide a coded PoC to prove the following two properties of the EVM that would enable this attack:\n- A contract can be deployed on top of an address that already had a contract before.\n- By deploying a contract and self-destruct in the same tx, we are able to set allowance for an address that has no bytecode.\n\nHere is the PoC, as well as detailed steps to recreate it:\n1. Paste the following file onto Remix (or a developing environment of choice): https://gist.github.com/midori-fuse/087aa3248da114a0712757348fcce814\n2. Deploy the contract `Test`.\n3. Run the function `Test.test()` with a salt of your choice, and record the returned address. The result will be:\n    - `Test.getAllowance()` for that address will return exactly `APPROVE_AMOUNT`.\n    - `Test.getCodeSize()` for that address will return exactly zero.\n    - This proves the second property.\n4. Using the same salt in step 3, run `Test.test()` again. The tx will go through, and the result will be:\n    - `Test.test()` returns the same address as with the first run.\n    - `Test.getAllowance()` for that address will return twice of `APPROVE_AMOUNT`.\n    - `Test.getCodeSize()` for that address will still return zero.\n    - This proves the first property.\n\nThe provided PoC has been tested on Remix IDE, on the Remix VM - Mainnet fork environment, as well as testing locally on the Holesky testnet fork, which as of time of writing, has been upgraded with the Dencun hardfork.\n\n## Impact\n\nComplete draining of a lending pool if an address collision is found.\n\nWith the advancement of computing hardware, the cost of an attack has been shown to be [just a few million dollars](https://mystenlabs.com/blog/ambush-attacks-on-160bit-objectids-addresses), and that the current Bitcoin network hashrate allows about $2^{80}$ in about half an hour. The cost of the attack may be offsetted with longer brute force time.\n\nFor a DeFi lending pool, it is normal for a pool TVL to reach tens or hundreds of millions in USD value (top protocols' TVL are well above the billions). It is then easy to show that such an attack is massively profitable.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/Factory.sol#L96-L100\n\n## Tool used\n\nManual Review, Remix IDE\n\n## Recommendation\n\nThe mitigation method is to prevent controlling over the deployed account address (or at least severely limit that). Some techniques may be:\n- Do not allow a user-supplied `salt`, as well as do not use the user address as a determining factor for the salt.\n- Use the vanilla contract creation with `CREATE`, as opposed to `CREATE2`. The contract's address is determined by `msg.sender` (the factory), and the internal `nonce` of the factory (for a contract, this is just \"how many other contracts it has deployed\" plus one).\n\nThis will prevent brute-forcing of one side of the collision, disabling the $O(2^{81})$ search technique.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(5)\n\n\n\n**nevillehuang**\n\nRequest PoC to facilitate discussion between sponsor and watson.\n\nI believe this is low severity given the extreme unlikeliness of it occuring, with the addition that a insanely huge amount of funds is required to perform this attack without guarantee\n\n**sherlock-admin**\n\nPoC requested from @PUSH0\n\nRequests remaining: **8**\n\n**midori-fuse**\n\nHello, thanks for asking.\n\nThe reason we believe this is a valid HM is the following:\n- The impact is undoubtedly high because a pool can be drained completely. \n  - Although only one pool can be drained per collision found, that itself is high impact. Furthermore the protocol will be deployed on several EVM chains, so the attacker can simultaneously drain one pool per chain.\n- We are re-citing [a past issue on Sherlock](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/90) discussing the same root cause of CREATE2 collision, as the issue discussion sufficiently describes:\n  - The attack cost *at the time of the Kyber contest*.\n  - The probability of a successful attack was shown to increase to 86% using $2^{81}$ hashes, and 99.96% using twice that power. This is not a low probability by any chance.\n    - Furthermore one may also find multiple collisions using this technique, which will allow draining of more than one pool.\n- Hardware advancements can only increase the computing power, not decrease it. Since the Kyber contest, BTC hashrate has already increased sigfinicantly (almost doubled), and it has been just 6 months since.\n- The more protocols with this issue there are, the more profit there is to finding a collision.\n\nTherefore the likelihood of this attack can only increase as time passes. Complete draining of a pool also cannot be low severity. \n\nEssentially by identifying this attack, we have proven the existence of a time bomb, that will allow complete draining of a certain pool from any given chain. We understand that past decisions are not considered a source of truth, however the issue discussion and the external resources should still provide an objective reference to determine this issue's validity. Furthermore let's consider the impact if it were to happen as well.\n\n**nevillehuang**\n\n@Czar102 I am interested in hearing your opinion here with regards to the previous issue [here as well](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/90). \n\n**Thomas-Smets**\n\nDon't think it is a high, requires a very big upfront cost with no certainty on pay out as attacker.\nAnd while our factory is immutable, we can pause indefinitely the creation of new accounts.\n\nIf at some point the attack becomes a possibility, we can still block it.\n\nTo make it even harder, we are thinking to add the block.timestamp and block.number to the hash.\nThen the attacker, after they successfully found a hash collision, already has to execute the attack at a fixed block and probably conspire with the sequencer to ensure that also the time is fixed.\n\n**midori-fuse**\n\nAgree that it's not a high, the attack cost makes a strong external condition.\n\nRe: mitigations. I don't think pausing the contract or blocking the attack makes sense, the attack would sort of finish in a flash before you know it (and in a shorter duration than a pausing multisig can react).\n\nRegarding the fix, adding `block.timestamp` and `block.number` technically works, but doesn't really make sense as opposed to just using the vanilla creation. The main purpose of `CREATE2` is that contract addresses are deterministic and pre-computable, you can do a handful of things with this information e.g. funds can be sent there in advance before contract creation, or crafting a customized address without deploying. By adding block number and timestamp, the purpose is essentially defeated.\n\nBut since it technically works, there's not really a point in opposing it I suppose. A full fix would involve reworking the account's accounting, which I think is quite complex and may open up more problems.\n\nA fix that would still (partially, but should be sufficient) retain the mentioned functionalities could be just using a `uint64` salt, or the last 64 bits of the address only, or anything that doesn't let the user determine more than 64 bits of the input. Then the other side of the brute force has to achieve $2^{15} = 32768$ times the mentioned hashing power in the attack to achieve a sizeable collision probability (and such probability is still less than a balanced $2^{80}$ brute force anyway).\n\n**Thomas-Smets**\n\n> I don't think pausing the contract or blocking the attack makes sense\n\nMeant it in the sense that if such an attack occurs we can pause it, assuming we would not be the first victim.\nNot that we can frontrun a particular attack with a pause.\n\n> Regarding the fix, adding block.timestamp and block.number technically works, but doesn't really make sense as opposed to just using the vanilla creation.\n\nFair point.\n\n> A fix that would still (partially, but should be sufficient) retain the mentioned functionalities could be just using a uint64 salt, or the last 64 bits of the address only, or anything that doesn't let the user determine more than 64 bits of the input.\n\nI do like this idea thanks! We can use 32 bits from the tx.origin and 32 bits from a salt.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/arcadia-finance/accounts-v2/pull/176.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/137",
  "Code": [
    {
      "filename": "accounts-v2/src/Factory.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { Proxy } from \"./Proxy.sol\";\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { IFactory } from \"./interfaces/IFactory.sol\";\nimport { IRegistry } from \"./interfaces/IRegistry.sol\";\nimport { ERC721, ERC721TokenReceiver } from \"../lib/solmate/src/tokens/ERC721.sol\";\nimport { Strings } from \"./libraries/Strings.sol\";\nimport { MerkleProofLib } from \"../lib/solmate/src/utils/MerkleProofLib.sol\";\nimport { FactoryGuardian } from \"./guardians/FactoryGuardian.sol\";\nimport { FactoryErrors } from \"./libraries/Errors.sol\";\n\n/**\n * @title Factory\n * @author Pragma Labs\n * @notice The Factory manages the deployment, upgrades and transfers of Arcadia Accounts.\n * @dev The Factory is an ERC721 contract that maps each id to an Arcadia Account.\n */\ncontract Factory is IFactory, ERC721, FactoryGuardian {\n    using Strings for uint256;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The latest Account version, newly deployed Account use the latest version by default.\n    uint88 public latestAccountVersion;\n    // The baseURI of the ERC721 tokens.\n    string public baseURI;\n\n    // The Merkle root of the Merkle tree of all the compatible Account versions.\n    bytes32 public versionRoot;\n\n    // Array of all Arcadia Account contract addresses.\n    address[] public allAccounts;\n\n    // Map accountVersion => blocked status.\n    mapping(uint256 => bool) public accountVersionBlocked;\n    // Map accountAddress => accountIndex.\n    mapping(address => uint256) public accountIndex;\n    // Map accountVersion => version information.\n    mapping(uint256 => VersionInformation) public versionInformation;\n\n    // Struct with additional information for a specific Account version.\n    struct VersionInformation {\n        // The contract address of the Registry.\n        address registry;\n        // The contract address of the Account implementation.\n        address implementation;\n        // Arbitrary data, can contain instructions to execute when updating Account to new implementation.\n        bytes data;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AccountUpgraded(address indexed accountAddress, uint88 indexed newVersion);\n    event AccountVersionAdded(uint88 indexed version, address indexed registry, address indexed implementation);\n    event AccountVersionBlocked(uint88 version);\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    constructor() ERC721(\"Arcadia Account\", \"ARCADIA\") { }\n\n    /*///////////////////////////////////////////////////////////////\n                          ACCOUNT MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to create a new Account.\n     * @param salt A salt to be used to generate the hash.\n     * @param accountVersion The Account version.\n     * @param creditor The contract address of the creditor.\n     * @return account The contract address of the proxy contract of the newly deployed Account.\n     * @dev If accountVersion == 0, the newest version will be used.\n     */\n    function createAccount(uint256 salt, uint256 accountVersion, address creditor)\n        external\n        whenCreateNotPaused\n        returns (address account)\n    {\n        accountVersion = accountVersion == 0 ? latestAccountVersion : accountVersion;\n\n        if (accountVersion > latestAccountVersion) revert FactoryErrors.InvalidAccountVersion();\n        if (accountVersionBlocked[accountVersion]) revert FactoryErrors.AccountVersionBlocked();\n\n        // Hash tx.origin with the user provided salt to avoid front-running Account deployment with an identical salt.\n        // We use tx.origin instead of msg.sender so that deployments through a third party contract are not vulnerable to front-running.\n        account = address(\n            new Proxy{ salt: keccak256(abi.encodePacked(salt, tx.origin)) }(\n                versionInformation[accountVersion].implementation\n            )\n        );\n\n        allAccounts.push(account);\n        accountIndex[account] = allAccounts.length;\n\n        _mint(msg.sender, allAccounts.length);\n\n        IAccount(account).initialize(msg.sender, versionInformation[accountVersion].registry, creditor);\n\n        // unsafe cast: accountVersion <= latestAccountVersion, which is a uint88.\n        emit AccountUpgraded(account, uint88(accountVersion));\n    }\n\n    /**\n     * @notice View function returning if an address is an Account.\n     * @param account The address to be checked.\n     * @return bool Whether the address is an Account or not.\n     */\n    function isAccount(address account) public view returns (bool) {\n        return accountIndex[account] > 0;\n    }\n\n    /**\n     * @notice Returns the owner of an Account.\n     * @param account The Account address.\n     * @return owner_ The Account owner.\n     * @dev Function does not revert when a non-existing Account is passed, but returns zero-address as owner.\n     */\n    function ownerOfAccount(address account) external view returns (address owner_) {\n        owner_ = _ownerOf[accountIndex[account]];\n    }\n\n    /**\n     * @notice This function allows Account owners to upgrade the implementation of the Account.\n     * @param account Account that needs to be upgraded.\n     * @param version The accountVersion to upgrade to.\n     * @param proofs The Merkle proofs that prove the compatibility of the upgrade from current to new account version.\n     * @dev As each Account is a proxy, the implementation of the proxy can be changed by the owner of the Account.\n     * Checks are done such that only compatible versions can be upgraded to.\n     * Merkle proofs and their leaves can be found on https://www.github.com/arcadia-finance.\n     */\n    function upgradeAccountVersion(address account, uint256 version, bytes32[] calldata proofs) external {\n        if (_ownerOf[accountIndex[account]] != msg.sender) revert FactoryErrors.OnlyAccountOwner();\n        if (accountVersionBlocked[version]) revert FactoryErrors.AccountVersionBlocked();\n\n        uint256 currentVersion = IAccount(account).ACCOUNT_VERSION();\n        bool canUpgrade =\n            MerkleProofLib.verify(proofs, versionRoot, keccak256(abi.encodePacked(currentVersion, version)));\n\n        if (!canUpgrade) revert FactoryErrors.InvalidUpgrade();\n\n        IAccount(account).upgradeAccount(\n            versionInformation[version].implementation,\n            versionInformation[version].registry,\n            version,\n            versionInformation[version].data\n        );\n\n        // unsafe cast: accountVersion <= latestAccountVersion, which is a uint88.\n        emit AccountUpgraded(account, uint88(version));\n    }\n\n    /**\n     * @notice Function used to transfer an Account between users based on Account address.\n     * @param from The sender.\n     * @param to The target.\n     * @param account The address of the Account that is transferred.\n     * @dev This method transfers an Account on Account address instead of id and\n     * also transfers the Account proxy contract to the new owner.\n     */\n    function safeTransferFrom(address from, address to, address account) public {\n        uint256 id = accountIndex[account];\n        IAccount(allAccounts[id - 1]).transferOwnership(to);\n        super.safeTransferFrom(from, to, id);\n    }\n\n    /**\n     * @notice Function used to transfer an Account between users based on Account id.\n     * @param from The sender.\n     * @param to The target.\n     * @param id The id of the Account that is about to be transferred.\n     * @dev This method overwrites the safeTransferFrom function in ERC721.sol to\n     * also transfer the Account proxy contract to the new owner.\n     */\n    function safeTransferFrom(address from, address to, uint256 id) public override {\n        IAccount(allAccounts[id - 1]).transferOwnership(to);\n        super.safeTransferFrom(from, to, id);\n    }\n\n    /**\n     * @notice Function used to transfer an Account between users based on Account id.\n     * @param from The sender.\n     * @param to The target.\n     * @param id The id of the Account that is about to be transferred.\n     * @param data additional data, only used for onERC721Received.\n     * @dev This method overwrites the safeTransferFrom function in ERC721.sol to\n     * also transfer the Account proxy contract to the new owner.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public override {\n        IAccount(allAccounts[id - 1]).transferOwnership(to);\n        super.safeTransferFrom(from, to, id, data);\n    }\n\n    /**\n     * @notice Function used to transfer an Account between users based on Account id.\n     * @param from The sender.\n     * @param to The target.\n     * @param id The id of the Account that is about to be transferred.\n     * @dev This method overwrites the transferFrom function in ERC721.sol to\n     * also transfer the Account proxy contract to the new owner.\n     */\n    function transferFrom(address from, address to, uint256 id) public override {\n        IAccount(allAccounts[id - 1]).transferOwnership(to);\n        super.transferFrom(from, to, id);\n    }\n\n    /**\n     * @notice Function used to transfer an Account, called by the Account itself.\n     * @param to The target.\n     * @dev Adaptation of safeTransferFrom from the ERC-721 standard, where the Account itself triggers the transfer.\n     * @dev The Account must do the transferOwnership() before calling this function.\n     */\n    function safeTransferAccount(address to) public {\n        if (to == address(0)) revert FactoryErrors.InvalidRecipient();\n\n        uint256 id = accountIndex[msg.sender];\n        if (id == 0) revert FactoryErrors.OnlyAccount();\n\n        address from = _ownerOf[id];\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        if (\n            to.code.length != 0\n                && ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\")\n                    != ERC721TokenReceiver.onERC721Received.selector\n        ) revert FactoryErrors.UnsafeRecipient();\n\n        emit Transfer(from, to, id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ACCOUNT VERSION MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to set a new Account version with the contracts to be used for new deployed Accounts.\n     * @param registry The contract address of the Registry.\n     * @param implementation The contract address of the Account implementation.\n     * @param versionRoot_ The Merkle root of the Merkle tree of all the compatible Account versions.\n     * @param data Arbitrary data, can contain instructions to execute when updating Account to new implementation.\n     * @dev Changing any of the contracts does NOT change the contracts for existing deployed Accounts,\n     * unless the Account owner explicitly chooses to upgrade their Account to a newer version.\n     */\n    function setNewAccountInfo(address registry, address implementation, bytes32 versionRoot_, bytes calldata data)\n        external\n        onlyOwner\n    {\n        if (versionRoot_ == bytes32(0)) revert FactoryErrors.VersionRootIsZero();\n        if (implementation == address(0)) revert FactoryErrors.ImplIsZero();\n\n        uint256 latestAccountVersion_;\n        unchecked {\n            // Update and cache the new latestAccountVersion.\n            latestAccountVersion_ = ++latestAccountVersion;\n        }\n\n        versionRoot = versionRoot_;\n        versionInformation[latestAccountVersion_] =\n            VersionInformation({ registry: registry, implementation: implementation, data: data });\n\n        if (IAccount(implementation).ACCOUNT_VERSION() != latestAccountVersion) revert FactoryErrors.VersionMismatch();\n        if (IAccount(implementation).FACTORY() != address(this)) revert FactoryErrors.FactoryMismatch();\n        if (IRegistry(registry).FACTORY() != address(this)) revert FactoryErrors.FactoryMismatch();\n\n        emit AccountVersionAdded(uint88(latestAccountVersion_), registry, implementation);\n    }\n\n    /**\n     * @notice Function to block a certain Account implementation version from being created as a new Account.\n     * @param version The Account version to be phased out.\n     * @dev Should any Account implementation version be phased out,\n     * this function can be used to block it from being created for new Accounts.\n     * @dev Although possible to block an Account version through the versionRoot,\n     * that would require verifying the Merkle tree on account creation, which is expensive.\n     */\n    function blockAccountVersion(uint256 version) external onlyOwner {\n        if (version == 0 || version > latestAccountVersion) revert FactoryErrors.InvalidAccountVersion();\n        accountVersionBlocked[version] = true;\n\n        // unsafe cast: accountVersion <= latestAccountVersion, which is a uint88.\n        emit AccountVersionBlocked(uint88(version));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        HELPER FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function returns the total number of Accounts.\n     * @return numberOfAccounts The total number of Accounts.\n     */\n    function allAccountsLength() external view returns (uint256 numberOfAccounts) {\n        numberOfAccounts = allAccounts.length;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ERC-721 LOGIC\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function that stores a new base URI.\n     * @param newBaseURI The new base URI to store.\n     * @dev tokenURIs of Arcadia Accounts are not meant to be immutable\n     * and might be updated later to allow users to choose/create their own Account art,\n     * as such no URI freeze is added.\n     */\n    function setBaseURI(string calldata newBaseURI) external onlyOwner {\n        baseURI = newBaseURI;\n    }\n\n    /**\n     * @notice Function that returns the token URI as defined in the ERC721 standard.\n     * @param tokenId The id of the Account.\n     * @return uri The token URI.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n}"
    }
  ]
}