{
  "Title": "TODOs and comments implying unfinished code",
  "Content": "There are “TODO” comments and other comments implying unfinished codes in the codebase. These should be tracked in the project’s issues backlog. In particular:\n\n\n* [Line 38 of `AgentRegistryCore.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L38).\n* [Line 54 of `AgentRegistryCore.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L54).\n* [Line 35 of `Router.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L35), which seems to imply the development effort here is unfinished.\n\n\nDuring development, having well described “TODO” comments will make the process of tracking and solving them easier. Without that information, these comments might tend to rot and important information for the security of the system might be forgotten by the time it is released to production.\n\n\nThese TODO comments should at least have a brief description of the task pending to do, and a link to the corresponding issue in the project repository.\n\n\nConsider updating these comments to add this information. For completeness and traceability, a signature and a timestamp can be added.\n\n\n***Update:** Fixed on [commit `d02065f071cd94d1361e00ff2b5208f71d76d014` in pull request 73](https://github.com/forta-protocol/forta-token/pull/73/commits/d02065f071cd94d1361e00ff2b5208f71d76d014) and on [commit `1f19717cc711522afb05299c8c3e05238484de0d` in pull request 75](https://github.com/forta-protocol/forta-token/pull/75/commits/1f19717cc711522afb05299c8c3e05238484de0d). However, now the `AGENT_ADMIN_ROLE` role can ban any creation by frontrunning the sender’s transaction and changing the `frontRunningDelay` variable.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/components/agents/AgentRegistryCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n\nimport \"../BaseComponentUpgradeable.sol\";\nimport \"../../tools/FrontRunningProtection.sol\";\n\nabstract contract AgentRegistryCore is\n    BaseComponentUpgradeable,\n    FrontRunningProtection,\n    ERC721Upgradeable\n{\n    event AgentCommitted(bytes32 indexed commit);\n    event AgentUpdated(uint256 indexed agentId, address indexed by, string metadata, uint256[] chainIds);\n\n    modifier onlyOwnerOf(uint256 agentId) {\n        require(_msgSender() == ownerOf(agentId), \"AgentRegistryCore: Restricted to agent owner\");\n        _;\n    }\n\n    modifier onlySorted(uint256[] memory array) {\n        require(array.length > 0, \"AgentRegistryCore: At least one chain id required\");\n        for (uint256 i = 1; i < array.length; ++i ) {\n            require(array[i] > array[i-1], \"AgentRegistryCore: Values must be sorted\");\n        }\n        _;\n    }\n\n    function prepareAgent(bytes32 commit) public {\n        _frontrunCommit(commit);\n        emit AgentCommitted(commit);\n    }\n\n    function createAgent(uint256 agentId, address owner, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, owner, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _mint(owner, agentId);\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    function isCreated(uint256 agentId) public view returns(bool) {\n        return _exists(agentId);\n    }\n\n    function updateAgent(uint256 agentId, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlyOwnerOf(agentId)\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    /**\n     * Hook: Agent metadata change (create/update)\n     */\n    function _beforeAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n    }\n\n    function _agentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        emit AgentUpdated(agentId, _msgSender(), newMetadata, newChainIds);\n    }\n\n    function _afterAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        _emitHook(abi.encodeWithSignature(\"hook_afterAgentUpdate(uint256)\", agentId));\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "contracts/components/agents/AgentRegistryCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n\nimport \"../BaseComponentUpgradeable.sol\";\nimport \"../../tools/FrontRunningProtection.sol\";\n\nabstract contract AgentRegistryCore is\n    BaseComponentUpgradeable,\n    FrontRunningProtection,\n    ERC721Upgradeable\n{\n    event AgentCommitted(bytes32 indexed commit);\n    event AgentUpdated(uint256 indexed agentId, address indexed by, string metadata, uint256[] chainIds);\n\n    modifier onlyOwnerOf(uint256 agentId) {\n        require(_msgSender() == ownerOf(agentId), \"AgentRegistryCore: Restricted to agent owner\");\n        _;\n    }\n\n    modifier onlySorted(uint256[] memory array) {\n        require(array.length > 0, \"AgentRegistryCore: At least one chain id required\");\n        for (uint256 i = 1; i < array.length; ++i ) {\n            require(array[i] > array[i-1], \"AgentRegistryCore: Values must be sorted\");\n        }\n        _;\n    }\n\n    function prepareAgent(bytes32 commit) public {\n        _frontrunCommit(commit);\n        emit AgentCommitted(commit);\n    }\n\n    function createAgent(uint256 agentId, address owner, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, owner, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _mint(owner, agentId);\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    function isCreated(uint256 agentId) public view returns(bool) {\n        return _exists(agentId);\n    }\n\n    function updateAgent(uint256 agentId, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlyOwnerOf(agentId)\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    /**\n     * Hook: Agent metadata change (create/update)\n     */\n    function _beforeAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n    }\n\n    function _agentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        emit AgentUpdated(agentId, _msgSender(), newMetadata, newChainIds);\n    }\n\n    function _afterAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        _emitHook(abi.encodeWithSignature(\"hook_afterAgentUpdate(uint256)\", agentId));\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "contracts/components/router/Router.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"../Roles.sol\";\nimport \"../utils/AccessManaged.sol\";\nimport \"../utils/ForwardedContext.sol\";\nimport \"../../tools/ENSReverseRegistration.sol\";\nimport \"./IRouter.sol\";\n\n// This should be BaseComponentUpgradeable, because BaseComponentUpgradeable is Routed\ncontract Router is IRouter, ForwardedContext, AccessManagedUpgradeable, UUPSUpgradeable, Multicall {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes4 => EnumerableSet.AddressSet) private _routingTable;\n\n    string public constant version = \"0.1.0\";\n    \n    event RoutingUpdated(bytes4 indexed sig, address indexed target, bool enable);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address forwarder) initializer ForwardedContext(forwarder) {}\n\n    function initialize(address __manager) public initializer {\n        __AccessManaged_init(__manager);\n        __UUPSUpgradeable_init();\n    }\n\n    function hookHandler(bytes calldata payload) external override {\n        bytes4 sig = bytes4(payload[:4]);\n        uint256 length = _routingTable[sig].length();\n        for (uint256 i = 0; i < length; ++i) {\n            // Lazy, don't worry about calls failing here\n            (bool success, bytes memory returndata) = _routingTable[sig].at(i).call(payload);\n            success;\n            returndata;\n        }\n    }\n\n    function setRoutingTable(bytes4 sig, address target, bool enable) external onlyRole(ROUTER_ADMIN_ROLE) {\n        if (enable) {\n            _routingTable[sig].add(target);\n        } else {\n            _routingTable[sig].remove(target);\n        }\n        emit RoutingUpdated(sig, target, enable);\n    }\n\n\n    // Access control for the upgrade process\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyRole(UPGRADER_ROLE) {\n    }\n\n    // Allow the upgrader to set ENS reverse registration\n    function setName(address ensRegistry, string calldata ensName) public onlyRole(ENS_MANAGER_ROLE) {\n        ENSReverseRegistration.setName(ensRegistry, ensName);\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, ForwardedContext) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, ForwardedContext) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[49] private __gap;\n}"
    }
  ]
}