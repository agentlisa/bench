{
  "Title": "Negative rebase of stETH could prevent a round from ending",
  "Content": "When a round ends, the amount of underlying assets currently in the vault is [subtracted](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/STETHVault.sol#L97) from the amount of assets the vault contained in the previous round. This calculation assumes a positive yield, but the underlying asset stETH is able to rebase in both a positive and negative direction due to the potential for slashing. In the case where Lido is slashed, `totalAssets` can be less than `lastRoundAssets`. Consequently, the subtraction would cause an underflow, which would prevent the controller from being able to end the round until `totalAssets` is greater than `lastRoundAssets`.\n\n\nConsider placing the logic that [calculates and transfers](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/STETHVault.sol#L97-L103) any investment yield generated by the vault in an `if` statement that only occurs when `totalAssets` is greater than `lastRoundAssets`. This allows any yield generated from the options strategy to still be transferred to the vault and prevents the accrued interest arithmetic from reverting.\n\n\n**Update:** *Resolved in [PR#100](https://github.com/pods-finance/yield-contracts/pull/100), with commit `a756b4d8ead7fce109e9daf51c218eb952454487` being the last one added.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { BaseVault } from \"./BaseVault.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\n\n/**\n * @title STETHVault\n * @notice A Vault that use variable weekly yields to buy strangles\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    /**\n     * @dev INVESTOR_RATIO is the proportion that the weekly yield will be split\n     * The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n     */\n    uint256 public constant INVESTOR_RATIO = 5000;\n    address public immutable investor;\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    Fractional public lastSharePrice;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    )\n        BaseVault(\n            _configuration,\n            _asset,\n            string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\")),\n            string(abi.encodePacked(_asset.symbol(), \"vv\"))\n        )\n    {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view override(ERC4626, IERC4626) returns (uint256) {\n        return IERC20Metadata(asset()).balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @notice Return the stETH price per share\n     * @dev Each share is considered to be 10^(assets.decimals())\n     */\n    function sharePrice() external view returns (uint256) {\n        return totalAssets().mulDiv(10**sharePriceDecimals, totalSupply(), Math.Rounding.Down);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundStart() internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 currentSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n        emit StartRoundData(vaultState.currentRoundId, lastRoundAssets, currentSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = IERC20Metadata(asset()).balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * INVESTOR_RATIO) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                IERC20Metadata(asset()).safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                IERC20Metadata(asset()).safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDiv(10**sharePriceDecimals, supply, Math.Rounding.Down);\n        }\n\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n\n        emit EndRoundData(vaultState.currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(vaultState.currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        assets = _stETHTransferFrom(caller, address(this), assets);\n        shares = previewDeposit(assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        lastRoundAssets -= shares.mulDiv(lastSharePrice.numerator, lastSharePrice.denominator, Math.Rounding.Down);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        receiverAssets = _stETHTransferFrom(address(this), receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _stETHTransferFrom(address(this), controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC20Metadata(asset()).balanceOf(to);\n        if (from == address(this)) {\n            IERC20Metadata(asset()).safeTransfer(to, amount);\n        } else {\n            IERC20Metadata(asset()).safeTransferFrom(from, to, amount);\n        }\n        return IERC20Metadata(asset()).balanceOf(to) - balanceBefore;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { BaseVault } from \"./BaseVault.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\n\n/**\n * @title STETHVault\n * @notice A Vault that use variable weekly yields to buy strangles\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    /**\n     * @dev INVESTOR_RATIO is the proportion that the weekly yield will be split\n     * The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n     */\n    uint256 public constant INVESTOR_RATIO = 5000;\n    address public immutable investor;\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    Fractional public lastSharePrice;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    )\n        BaseVault(\n            _configuration,\n            _asset,\n            string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\")),\n            string(abi.encodePacked(_asset.symbol(), \"vv\"))\n        )\n    {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view override(ERC4626, IERC4626) returns (uint256) {\n        return IERC20Metadata(asset()).balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @notice Return the stETH price per share\n     * @dev Each share is considered to be 10^(assets.decimals())\n     */\n    function sharePrice() external view returns (uint256) {\n        return totalAssets().mulDiv(10**sharePriceDecimals, totalSupply(), Math.Rounding.Down);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundStart() internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 currentSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n        emit StartRoundData(vaultState.currentRoundId, lastRoundAssets, currentSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = IERC20Metadata(asset()).balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * INVESTOR_RATIO) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                IERC20Metadata(asset()).safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                IERC20Metadata(asset()).safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDiv(10**sharePriceDecimals, supply, Math.Rounding.Down);\n        }\n\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n\n        emit EndRoundData(vaultState.currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(vaultState.currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        assets = _stETHTransferFrom(caller, address(this), assets);\n        shares = previewDeposit(assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        lastRoundAssets -= shares.mulDiv(lastSharePrice.numerator, lastSharePrice.denominator, Math.Rounding.Down);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        receiverAssets = _stETHTransferFrom(address(this), receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _stETHTransferFrom(address(this), controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC20Metadata(asset()).balanceOf(to);\n        if (from == address(this)) {\n            IERC20Metadata(asset()).safeTransfer(to, amount);\n        } else {\n            IERC20Metadata(asset()).safeTransferFrom(from, to, amount);\n        }\n        return IERC20Metadata(asset()).balanceOf(to) - balanceBefore;\n    }\n}"
    }
  ]
}