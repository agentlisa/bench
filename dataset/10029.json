{
  "Title": "[M-05] [WP-M1] `BURNER_ROLE` can burn any amount of L2LivepeerToken from an arbitrary address",
  "Content": "_Submitted by WatchPug, also found by cccz_.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L36-L43>\n\n```solidity\nfunction burn(address _from, uint256 _amount)\n    external\n    override\n    onlyRole(BURNER_ROLE)\n{\n    _burn(_from, _amount);\n    emit Burn(_from, _amount);\n}\n```\n\nUsing the `burn()` function of `L2LivepeerToken`, an address with `BURNER_ROLE` can burn an arbitrary amount of tokens from any address.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\nA malicious or compromised `BURNER_ROLE` address can take advantage of this, burn the balance of a Uniswap pool and effectively steal almost all the funds from the liquidity pool (eg, Uniswap LPT-WETH Pool).\n\n#### Recommendation\n\nConsider removing the `BURNER_ROLE` and change `burn()` function to:\n\n```solidity\nfunction burn(uint256 _amount)\n    external\n    override\n{\n    _burn(msg.sender, _amount);\n    emit Burn(msg.sender, _amount);\n}\n```\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/49cf5401b0514511675d781a1e29d6b0325cfe88/contracts/L2/gateway/L2LPTGateway.sol#L34-L45>\n\n`Mintable(l2Lpt).burn(from, _amount);` in `L2LPTGateway.sol#outboundTransfer()` should also be replaced with:\n\n```solidity\nMintable(l2Lpt).transferFrom(from, _amount);\nMintable(l2Lpt).burn(_amount);\n```\n\n**[yondonfu (Livepeer) confirmed and resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/194#issuecomment-1021377760):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/52\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-livepeer",
  "Code": [
    {
      "filename": "contracts/L2/token/LivepeerToken.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20, ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ILivepeerToken} from \"./ILivepeerToken.sol\";\n\ncontract LivepeerToken is ILivepeerToken, AccessControl, ERC20Permit {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    constructor() ERC20(\"Livepeer Token\", \"LPT\") ERC20Permit(\"Livepeer Token\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE);\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        override\n        onlyRole(MINTER_ROLE)\n    {\n        _mint(_to, _amount);\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @dev Burns a specific amount of the sender's tokens\n     * @param _amount The amount of tokens to be burned\n     */\n    function burn(address _from, uint256 _amount)\n        external\n        override\n        onlyRole(BURNER_ROLE)\n    {\n        _burn(_from, _amount);\n        emit Burn(_from, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/L2/gateway/L2LPTGateway.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ControlledGateway} from \"../../ControlledGateway.sol\";\nimport {L2ArbitrumMessenger} from \"./L2ArbitrumMessenger.sol\";\nimport {IL2LPTGateway} from \"./IL2LPTGateway.sol\";\nimport {IL1LPTGateway} from \"../../L1/gateway/IL1LPTGateway.sol\";\n\ninterface Mintable {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n}\n\ncontract L2LPTGateway is IL2LPTGateway, ControlledGateway, L2ArbitrumMessenger {\n    address public immutable l2Router;\n    address public l1Counterpart;\n\n    constructor(\n        address _l2Router,\n        address _l1Lpt,\n        address _l2Lpt\n    ) ControlledGateway(_l1Lpt, _l2Lpt) {\n        l2Router = _l2Router;\n    }\n\n    function setCounterpart(address _l1Counterpart)\n        external\n        onlyRole(GOVERNOR_ROLE)\n    {\n        l1Counterpart = _l1Counterpart;\n    }\n\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override whenNotPaused returns (bytes memory res) {\n        require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n        (address from, bytes memory extraData) = parseOutboundData(_data);\n        require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n        Mintable(l2Lpt).burn(from, _amount);\n\n        uint256 id = sendTxToL1(\n            from,\n            l1Counterpart,\n            getOutboundCalldata(_l1Token, from, _to, _amount, extraData)\n        );\n\n        // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n        emit WithdrawalInitiated(_l1Token, from, _to, id, 0, _amount);\n\n        return abi.encode(id);\n    }\n\n    function finalizeInboundTransfer(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata // data -- unused\n    ) external override onlyL1Counterpart(l1Counterpart) {\n        require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n        Mintable(l2Lpt).mint(_to, _amount);\n\n        emit DepositFinalized(_l1Token, _from, _to, _amount);\n    }\n\n    function parseOutboundData(bytes memory data)\n        internal\n        view\n        returns (address from, bytes memory extraData)\n    {\n        if (msg.sender == l2Router) {\n            (from, extraData) = abi.decode(data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = data;\n        }\n    }\n\n    function counterpartGateway() external view override returns (address) {\n        return l1Counterpart;\n    }\n\n    function calculateL2TokenAddress(address l1Token)\n        external\n        view\n        override\n        returns (address)\n    {\n        if (l1Token != l1Lpt) {\n            return address(0);\n        }\n\n        return l2Lpt;\n    }\n\n    function getOutboundCalldata(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data\n    ) public pure returns (bytes memory outboundCalldata) {\n        outboundCalldata = abi.encodeWithSelector(\n            IL1LPTGateway.finalizeInboundTransfer.selector,\n            token,\n            from,\n            to,\n            amount,\n            abi.encode(0, data) // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n        );\n\n        return outboundCalldata;\n    }\n}"
    }
  ]
}