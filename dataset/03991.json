{
  "Title": "[L09] Whitelist setters do not emit events",
  "Content": "The [`TransferWhitelist` contract](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L11) is used to whitelist addresses.  \n\nAddresses and contract identifiers can be added individually by calling the [`addAddress`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L29) and the [`addRegisteredContract`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L38) functions. Or lists of addresses and contract identifiers can be set by calling the [`setWhitelist`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L59) and the [`setRegisteredContracts`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L67) functions.\n\n\nWhen the items are added individually to the whitelist, the events [`WhitelistedAddress`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L31) and [`WhitelistedRegistryId`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/common/TransferWhitelist.sol#L44) are emitted. However, when the lists are set, these events are not emitted. This could cause the event log to be misleading.\n\n\nConsider also emitting events when lists are added to the whitelist. Ideally, when a list is set overwriting the previously whitelisted items, a removal event should be emitted for each of the items that is no longer in the whitelist. Then, a whitelisted event should be emitted for each of the new items added. Alternatively, one single event can be emitted when a list of items is set. But this can be ambiguous because looking at the log it will not be clear if the previous whitelisted items were kept or overwritten. In this case, consider thoroughly documenting the events and the functions to make the behavior clear.\n\n\n***Update:** Fixed in pull request #3134](https://github.com/celo-org/celo-monorepo/pull/3134). `setWhitelist` now [emits the `WhitelistedAddressRemoved` event](https://github.com/celo-org/celo-monorepo/pull/3134/files#diff-fd4bb91e94cd8fd225f723d2719bb7f2R77) for all the previous addresses. It [calls the `addAddress` function](https://github.com/celo-org/celo-monorepo/pull/3134/files#diff-fd4bb91e94cd8fd225f723d2719bb7f2R81) to add all the new ones, which [emits the `WhitelistedAddress` event](https://github.com/celo-org/celo-monorepo/pull/3134/files#diff-fd4bb91e94cd8fd225f723d2719bb7f2R32).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] public whitelist;\n  bytes32[] public registeredContracts;\n\n  event WhitelistedAddress(address addr);\n  event WhitelistedRegistryId(bytes32 registryId);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function addAddress(address newAddress) external onlyOwner {\n    whitelist.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param registryId The id of the contract to be added.\n   */\n  function addRegisteredContract(bytes32 registryId) external onlyOwner {\n    require(\n      registry.getAddressFor(registryId) != address(0),\n      \"registryId does not corespond to a registered address\"\n    );\n    registeredContracts.push(registryId);\n    emit WhitelistedRegistryId(registryId);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of registeredContracts\n   */\n  function getRegisteredContractsLength() external view returns (uint256 length) {\n    return registeredContracts.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setWhitelist(address[] calldata _whitelist) external onlyOwner {\n    whitelist = _whitelist;\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setRegisteredContracts(bytes32[] calldata _registeredContracts) external onlyOwner {\n    registeredContracts = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = whitelist.length.add(registeredContracts.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < whitelist.length) {\n      _whitelist[i] = whitelist[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < registeredContracts.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(registeredContracts[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] public whitelist;\n  bytes32[] public registeredContracts;\n\n  event WhitelistedAddress(address addr);\n  event WhitelistedRegistryId(bytes32 registryId);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function addAddress(address newAddress) external onlyOwner {\n    whitelist.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param registryId The id of the contract to be added.\n   */\n  function addRegisteredContract(bytes32 registryId) external onlyOwner {\n    require(\n      registry.getAddressFor(registryId) != address(0),\n      \"registryId does not corespond to a registered address\"\n    );\n    registeredContracts.push(registryId);\n    emit WhitelistedRegistryId(registryId);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of registeredContracts\n   */\n  function getRegisteredContractsLength() external view returns (uint256 length) {\n    return registeredContracts.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setWhitelist(address[] calldata _whitelist) external onlyOwner {\n    whitelist = _whitelist;\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setRegisteredContracts(bytes32[] calldata _registeredContracts) external onlyOwner {\n    registeredContracts = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = whitelist.length.add(registeredContracts.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < whitelist.length) {\n      _whitelist[i] = whitelist[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < registeredContracts.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(registeredContracts[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] public whitelist;\n  bytes32[] public registeredContracts;\n\n  event WhitelistedAddress(address addr);\n  event WhitelistedRegistryId(bytes32 registryId);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function addAddress(address newAddress) external onlyOwner {\n    whitelist.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param registryId The id of the contract to be added.\n   */\n  function addRegisteredContract(bytes32 registryId) external onlyOwner {\n    require(\n      registry.getAddressFor(registryId) != address(0),\n      \"registryId does not corespond to a registered address\"\n    );\n    registeredContracts.push(registryId);\n    emit WhitelistedRegistryId(registryId);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of registeredContracts\n   */\n  function getRegisteredContractsLength() external view returns (uint256 length) {\n    return registeredContracts.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setWhitelist(address[] calldata _whitelist) external onlyOwner {\n    whitelist = _whitelist;\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setRegisteredContracts(bytes32[] calldata _registeredContracts) external onlyOwner {\n    registeredContracts = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = whitelist.length.add(registeredContracts.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < whitelist.length) {\n      _whitelist[i] = whitelist[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < registeredContracts.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(registeredContracts[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    }
  ]
}