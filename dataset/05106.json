{
  "Title": "[M-17] User's attempt to deposit & withdraw reverts due to the calculation style inside `_calculateShares()`",
  "Content": "\n**Scenario 1:**\n\nThe following flow of events (one among many) causes a revert:\n\n1. Alice calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) to deposit `1 ether`. This executes successfully, as expected.\n2. Bob calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) to deposit `1.5 ether` (or `0.5 ether` or `1 ether` or `2 ether` or any other value). This reverts unexpectedly.\n\nIn case Bob was attempting to make this deposit to rescue his soon-to-become or already bad debt and to avoid liquidation, this revert will delay his attempt which could well be enough for him to be liquidated by any liquidator, causing loss of funds for Bob. Here's a concrete example with numbers:\n\n1. Bob calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) to deposit `1 ether`. This executes successfully, as expected.\n2. Bob calls [`borrowExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L975) to borrow `0.7 ether`. This executes successfully, as expected.\n3. Bob can see that price is soon going to spiral downward and cause a bad debt. He plans to deposit some additional collateral to safeguard himself. He calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) again to deposit `0.5 ether`. This reverts unexpectedly.\n4. Prices go down and he is liquidated.\n\n**Scenario 2:**\n\nA similar revert occurs when the following flow of events occur:\n\n1. Alice calls [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L388) to deposit `10 ether`. This executes successfully, as expected.\n2. Bob calls [`withdrawExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L636) to withdraw `10 ether` (or `10 ether - 1` or `10 ether - 1000` or `9.5 ether` or `9.1 ether`). This reverts unexpectedly.\n\nBob is not able to withdraw his entire deposit. If he leaves behind `1 ether` and withdraws only `9 ether`, then he does not face a revert.\n\nIn both of the above cases, eventually the revert is caused by the validation failure on [L234-L237](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L234-L237) due to the check inside `_validateParameter()`:\n\n```js\n  File: contracts/WiseLending.sol\n\n  210:              function _compareSharePrices(\n  211:                  address _poolToken,\n  212:                  uint256 _lendSharePriceBefore,\n  213:                  uint256 _borrowSharePriceBefore\n  214:              )\n  215:                  private\n  216:                  view\n  217:              {\n  218:                  (\n  219:                      uint256 lendSharePriceAfter,\n  220:                      uint256 borrowSharePriceAfter\n  221:                  ) = _getSharePrice(\n  222:                      _poolToken\n  223:                  );\n  224:\n  225:                  uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n  226:                      _poolToken\n  227:                  );\n  228:\n  229:                  _validateParameter(\n  230:                      _lendSharePriceBefore,\n  231:                      lendSharePriceAfter\n  232:                  );\n  233:\n  234: @--->            _validateParameter(\n  235: @--->                lendSharePriceAfter,\n  236: @--->                currentSharePriceMax\n  237:                  );\n  238:\n  239:                  _validateParameter(\n  240:                      _borrowSharePriceBefore,\n  241:                      currentSharePriceMax\n  242:                  );\n  243:\n  244:                  _validateParameter(\n  245:                      borrowSharePriceAfter,\n  246:                      _borrowSharePriceBefore\n  247:                  );\n  248:              }\n```\n\n### Root Cause\n\n1. [`_compareSharePrices()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L219) is called by [`_syncPoolAfterCodeExecution()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L319) which is executed due to the [`syncPool`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L109) modifier attached to [`depositExactAmountETH()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L393).\n2. Before `_syncPoolAfterCodeExecution()` in the above step is executed, the following internal calls are made by `depositExactAmountETH()`:\n    - The [`_handleDeposit()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseCore.sol#L106) function is called on [L407](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L407) which in-turn calls `calculateLendingShares()` on [L115](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L115).\n    - The `calculateLendingShares()` function now calls `_calculateShares()` on [L26](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L26).\n    - [`_calculateShares()` decreases the calculated shares](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L44) by `1` which is represented by the variable `lendingPoolData[_poolToken].totalDepositShares` inside [`_getSharePrice()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L187).\n    - The `_getSharePrice()` functions uses this `lendingPoolData[_poolToken].totalDepositShares` variable in the denominator on [L185-187](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L185-L187) and in many cases, returns an increased value (in this case it evaluates to `1000000000000000001`) which is captured in the variable `lendSharePriceAfter` inside [`_compareSharePrices()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L219).\n3. Circling back to our first step, this causes the validation to fail on [L234-L237](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L234-L237) inside `_compareSharePrices()` since the `lendSharePriceAfter` is now greater than `currentSharePriceMax` i.e. `1000000000000000001 > 1000000000000000000`. Hence, the transaction reverts.\n\nThe [reduction by 1 inside `_calculateShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L44) is done by the protocol in its own favour to safeguard itself. The `lendingPoolData[_poolToken].pseudoTotalPool`; however, is never modified. This mismatch eventually reaches a significant divergence, and is the root cause of these reverts.\n\nSee:\n- The last comment inside the `Proof of Concept-2 (Withdraw scenario)` section later in the report.\n- `Option1` inside the `Recommended Mitigation Steps` section later in the report.\n\n<details>\n\n```js\n  File: contracts/WiseLending.sol\n\n  97:               modifier syncPool(\n  98:                   address _poolToken\n  99:               ) {\n  100:                  (\n  101:                      uint256 lendSharePrice,\n  102:                      uint256 borrowSharePrice\n  103:                  ) = _syncPoolBeforeCodeExecution(\n  104:                      _poolToken\n  105:                  );\n  106:          \n  107:                  _;\n  108:          \n  109: @--->            _syncPoolAfterCodeExecution(\n  110:                      _poolToken,\n  111:                      lendSharePrice,\n  112:                      borrowSharePrice\n  113:                  );\n  114:              }\n```\n\n```js\n  File: contracts/WiseLending.sol\n\n  308:              function _syncPoolAfterCodeExecution(\n  309:                  address _poolToken,\n  310:                  uint256 _lendSharePriceBefore,\n  311:                  uint256 _borrowSharePriceBefore\n  312:              )\n  313:                  private\n  314:              {\n  315:                  _newBorrowRate(\n  316:                      _poolToken\n  317:                  );\n  318:          \n  319: @--->            _compareSharePrices(\n  320:                      _poolToken,\n  321:                      _lendSharePriceBefore,\n  322:                      _borrowSharePriceBefore\n  323:                  );\n  324:              }\n```\n\n```js\n  File: contracts/WiseLending.sol\n\n  388:              function depositExactAmountETH(\n  389:                  uint256 _nftId\n  390:              )\n  391:                  external\n  392:                  payable\n  393:                  syncPool(WETH_ADDRESS)\n  394:                  returns (uint256)\n  395:              {\n  396: @--->            return _depositExactAmountETH(\n  397:                      _nftId\n  398:                  );\n  399:              }\n  400:          \n  401:              function _depositExactAmountETH(\n  402:                  uint256 _nftId\n  403:              )\n  404:                  private\n  405:                  returns (uint256)\n  406:              {\n  407: @--->            uint256 shareAmount = _handleDeposit(\n  408:                      msg.sender,\n  409:                      _nftId,\n  410:                      WETH_ADDRESS,\n  411:                      msg.value\n  412:                  );\n  413:          \n  414:                  _wrapETH(\n  415:                      msg.value\n  416:                  );\n  417:          \n  418:                  return shareAmount;\n  419:              }\n```\n\n```js\n  File: contracts/WiseCore.sol\n\n  106:              function _handleDeposit(\n  107:                  address _caller,\n  108:                  uint256 _nftId,\n  109:                  address _poolToken,\n  110:                  uint256 _amount\n  111:              )\n  112:                  internal\n  113:                  returns (uint256)\n  114:              {\n  115: @--->            uint256 shareAmount = calculateLendingShares(\n  116:                      {\n  117:                          _poolToken: _poolToken,\n  118:                          _amount: _amount,\n  119: @--->                    _maxSharePrice: false\n  120:                      }\n  121:                  );\n  122:          \n```\n\n```js\n  File: contracts/MainHelper.sol\n\n  17:               function calculateLendingShares(\n  18:                   address _poolToken,\n  19:                   uint256 _amount,\n  20:                   bool _maxSharePrice\n  21:               )\n  22:                   public\n  23:                   view\n  24:                   returns (uint256)\n  25:               {\n  26:  @--->            return _calculateShares(\n  27:                       lendingPoolData[_poolToken].totalDepositShares * _amount,\n  28:                       lendingPoolData[_poolToken].pseudoTotalPool,\n  29:                       _maxSharePrice\n  30:                   );\n  31:               }\n  32:           \n  33:               function _calculateShares(\n  34:                   uint256 _product,\n  35:                   uint256 _pseudo,\n  36:                   bool _maxSharePrice\n  37:               )\n  38:                   private\n  39:                   pure\n  40:                   returns (uint256)\n  41:               {\n  42:                   return _maxSharePrice == true\n  43:                       ? _product / _pseudo + 1\n  44:  @--->                : _product / _pseudo - 1;\n  45:               }\n```\n\n```js\n  File: contracts/WiseLending.sol\n\n  210:              function _compareSharePrices(\n  211:                  address _poolToken,\n  212:                  uint256 _lendSharePriceBefore,\n  213:                  uint256 _borrowSharePriceBefore\n  214:              )\n  215:                  private\n  216:                  view\n  217:              {\n  218:                  (\n  219: @--->                uint256 lendSharePriceAfter,\n  220:                      uint256 borrowSharePriceAfter\n  221: @--->            ) = _getSharePrice(\n  222:                      _poolToken\n  223:                  );\n  224:          \n  225:                  uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n  226:                      _poolToken\n  227:                  );\n  228:          \n  229:                  _validateParameter(\n  230:                      _lendSharePriceBefore,\n  231:                      lendSharePriceAfter\n  232:                  );\n  233:          \n  234:                  _validateParameter(\n  235: @--->                lendSharePriceAfter,\n  236:                      currentSharePriceMax\n  237:                  );\n  238:          \n  239:                  _validateParameter(\n  240:                      _borrowSharePriceBefore,\n  241:                      currentSharePriceMax\n  242:                  );\n  243:          \n  244:                  _validateParameter(\n  245:                      borrowSharePriceAfter,\n  246:                      _borrowSharePriceBefore\n  247:                  );\n  248:              }\n```\n\n```js\n  File: contracts/WiseLending.sol\n\n  165:              function _getSharePrice(\n  166:                  address _poolToken\n  167:              )\n  168:                  private\n  169:                  view\n  170:                  returns (\n  171:                      uint256,\n  172:                      uint256\n  173:                  )\n  174:              {\n  175:                  uint256 borrowSharePrice = borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n  176:                      * PRECISION_FACTOR_E18\n  177:                      / borrowPoolData[_poolToken].totalBorrowShares;\n  178:          \n  179:                  _validateParameter(\n  180:                      MIN_BORROW_SHARE_PRICE,\n  181:                      borrowSharePrice\n  182:                  );\n  183:          \n  184:                  return (\n  185:                      lendingPoolData[_poolToken].pseudoTotalPool\n  186:                          * PRECISION_FACTOR_E18\n  187: @--->                    / lendingPoolData[_poolToken].totalDepositShares,\n  188:                      borrowSharePrice\n  189:                  );\n  190:              }\n```\n\n</details>\n\n### Proof of Concept \n\n**Deposit scenario:**\n\nAdd the following tests inside `contracts/WisenLendingShutdown.t.sol` and run via `forge test --fork-url mainnet -vvvv --mt test_t0x1c_DepositsRevert` to see the tests fail.\n\n```js\n    function test_t0x1c_DepositsRevert_Simple() \n        public\n    {\n        uint256 nftId;\n        nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n        LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId); // @audit-info : If you want to make the test pass, change this to `2 ether`\n\n        address bob = makeAddr(\"Bob\");\n        vm.deal(bob, 10 ether); // give some ETH to Bob\n        vm.startPrank(bob);\n\n        uint256 nftId_bob = POSITION_NFTS_INSTANCE.mintPosition(); \n        LENDING_INSTANCE.depositExactAmountETH{value: 1.5 ether}(nftId_bob); // @audit : REVERTS incorrectly (reverts for numerous values like `0.5 ether`, `1 ether`, `2 ether`, etc.)\n    }\n\n    function test_t0x1c_DepositsRevert_With_Borrow() \n        public\n    {\n        address bob = makeAddr(\"Bob\");\n        vm.deal(bob, 10 ether); // give some ETH to Bob\n        vm.startPrank(bob);\n\n        uint256 nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n        LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId); // @audit-info : If you want to make the test pass, change this to `2 ether`\n\n        LENDING_INSTANCE.borrowExactAmountETH(nftId, 0.7 ether);\n\n        LENDING_INSTANCE.depositExactAmountETH{value: 0.5 ether}(nftId); // @audit : REVERTS incorrectly; Bob can't deposit additional collateral to save himself\n    }\n```\n\nIf you want to check with values which make the test pass, change the following line in both the tests and run again:\n\n```diff\n-     LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId); // @audit-info : If you want to make the test pass, change this to `2 ether`\n+     LENDING_INSTANCE.depositExactAmountETH{value: 2 ether}(nftId); // @audit-info : If you want to make the test pass, change this to `2 ether`\n```\n\nThere are numerous combinations which will cause such a \"revert\" scenario to occur. Just to provide another example:\n\nFour initial deposits are made in either Style1 or Style2:\n\n```\n    - Style1:\n        - Alice makes 4 deposits of `2.5 ether` each. Total deposits made by Alice = 4 /ast 2.5 ether = 10 ether.\n    - Style2:\n        - Alice makes a deposit of `2.5 ether`\n        - Bob makes a deposit of `2.5 ether`\n        - Carol makes a deposit of `2.5 ether`\n        - Dan makes a deposit of `2.5 ether`. Total deposits made by 4 users = 4 /ast 2.5 ether = 10 ether.\n```\n\nNow, Emily tries to make a deposit of `2.5 ether`. This reverts.\n\n**Withdraw scenario:**\n\nAdd the following test inside `contracts/WisenLendingShutdown.t.sol` and run via `forge test --fork-url mainnet -vvvv --mt test_t0x1c_WithdrawRevert` to see the test fail.\n\n```js\n    function test_t0x1c_WithdrawRevert() \n        public\n    {\n        address bob = makeAddr(\"Bob\");\n        vm.deal(bob, 100 ether); // give some ETH to Bob\n        vm.startPrank(bob);\n\n        uint256 nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n        LENDING_INSTANCE.depositExactAmountETH{value: 10 ether}(nftId); \n        \n        LENDING_INSTANCE.withdrawExactAmountETH(nftId, 9.1 ether); // @audit : Reverts incorrectly for all values greater than `9 ether`.\n    }\n```\n\nIf you want to check with values which make the test pass, change the following line of the test case like shown below and run again:\n\n```diff\n-     LENDING_INSTANCE.withdrawExactAmountETH(nftId, 9.1 ether); // @audit : Reverts incorrectly for all values greater than `9 ether`.\n+     LENDING_INSTANCE.withdrawExactAmountETH(nftId, 9 ether); // @audit : Reverts incorrectly for all values greater than `9 ether`.\n```\n\nThis failure happened because the moment `lendingPoolData[_poolToken].pseudoTotalPool` and `lendingPoolData[_poolToken].totalDepositShares` go below `1 ether`, their divergence is significant enough to result in `lendSharePrice` being calculated as greater than `1000000000000000000` or `1 ether`:\n\n```js\n  lendSharePrice = lendingPoolData[_poolToken].pseudoTotalPool * 1e18 / lendingPoolData[_poolToken].totalDepositShares\n```\n\nWhich in this case, evaluates to `1000000000000000001`. This brings us back to our root cause of failure. Due to the divergence, `lendSharePrice` of `1000000000000000001` has become greater than `currentSharePriceMax` of `1000000000000000000` and fails the validation on [L234-L237](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L234-L237) inside `_compareSharePrices()`.\n\nHigh likelihood, as it's possible for a huge number of value combinations, as shown above.\n\nIf user is trying to save his collateral, this is High severity. Otherwise he can try later with modified values making it a Medium severity.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nSince the [reduction by 1 inside `_calculateShares()`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/MainHelper.sol#L44) is being done to round-down in favour of the protocol, removing that without a deeper analysis could prove to be risky as it may open up other attack vectors. Still, two points come to mind which can be explored:\n\n- **Option1:** Reducing `lendingPoolData[_poolToken].pseudoTotalPool` too would keep it in sync with `lendingPoolData[_poolToken].totalDepositShares` and will avoid the current issue.\n\n- **Option2:** Not reducing it by 1 seems to solve the immediate problem at hand (needs further impact analysis):\n\n```diff\n  File: contracts/MainHelper.sol\n\n  33:               function _calculateShares(\n  34:                   uint256 _product,\n  35:                   uint256 _pseudo,\n  36:                   bool _maxSharePrice\n  37:               )\n  38:                   private\n  39:                   pure\n  40:                   returns (uint256)\n  41:               {\n  42:                   return _maxSharePrice == true\n  43:                       ? _product / _pseudo + 1\n- 44:                       : _product / _pseudo - 1;\n+ 44:                       : _product / _pseudo;\n  45:               }\n```\n\n### Assessed type\n\nMath\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2002526153):**\n > If you remove `-1` then it opens other attacks, so it is not justified suggestion. To qualify this for a finding I will let @vonMangoldt give his opinion for these details.\n\n**[Trust (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2021156001):**\n > High quality submission. Likelihood is Low/Med, Impact is Med/High, so Medium is appropriate.\n\n**[t0x1c (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2026692264):**\n> > Likelihood is Low/Med\n> \n> @Trust - Could you please expand on your reasoning behind this? As I mentioned in the report, the frequency/likelihood at which this happens currently is very high which I supported by various random examples.\n>\n> To strengthen my case, here are additional example flows of events which cause a revert for Bob when he tries to save his collateral by depositing additional amount. I have even added more actors so that it can mimic a real world scenario even more closely than before.\n>\n> I am also supplementing Scenario 1 and Scenario 2 (below) of the table with coded PoCs (very similar to the one I already provided in my report), just in case it helps to run it and see the scenario in action. Due to these reasons, I believe the vulnerability should qualify as a `High`. Requesting you to re-assess.\n> \n> | #   | Action1 | Action2 | Action3 | Action4 | Action5 |\n> |:-----:|:-------:|:-------:|:-------:|:-------:|:-------:|\n> | Scenario 1 | Alice deposits 2 ether | Bob deposits 2 ether | Carol deposits 1 ether | Bob borrows 1 ether | Bob deposits 0.5 ether (reverts) |\n> | Scenario 2 | Alice deposits 2 ether | Bob deposits 3 ether | Carol deposits 2.5 ether | Bob borrows 2 ether | Bob deposits 1 ether (reverts) |\n> \n> <details>\n> \n> ```js\n>     function test_t0x1c_MultipleDepositsCombinations_Revert_With_Borrow_Scenario1() \n>         public\n>     {\n>         address alice = makeAddr(\"Alice\");\n>         address bob = makeAddr(\"Bob\");\n>         address carol = makeAddr(\"Carol\");\n>         vm.deal(alice, 10 ether); \n>         vm.deal(bob, 10 ether); \n>         vm.deal(carol, 10 ether); \n> \n>         console.log(\"Action1\");\n>         vm.prank(alice);\n>         uint256 nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(alice);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 2 ether}(nftId); \n> \n>         console.log(\"Action2\");\n>         vm.prank(bob);\n>         uint256 nftId_Bob = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(bob);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 2 ether}(nftId_Bob); \n>         \n>         console.log(\"Action3\");\n>         vm.prank(carol);\n>         nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(carol);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId); \n>         \n>         console.log(\"Action4\");\n>         vm.prank(bob);\n>         LENDING_INSTANCE.borrowExactAmountETH(nftId_Bob, 1 ether);\n> \n>         console.log(\"Action5\");\n>         vm.prank(bob);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 0.5 ether}(nftId_Bob); // @audit : REVERTS incorrectly; Bob can't deposit additional collateral to save himself\n>     }\n> ```\n> \n> and\n> \n> ```js\n>     function test_t0x1c_MultipleDepositsCombinations_Revert_With_Borrow_Scenario2() \n>         public\n>     {\n>         address alice = makeAddr(\"Alice\");\n>         address bob = makeAddr(\"Bob\");\n>         address carol = makeAddr(\"Carol\");\n>         vm.deal(alice, 10 ether); \n>         vm.deal(bob, 20 ether); \n>         vm.deal(carol, 10 ether); \n> \n>         console.log(\"Action1\");\n>         vm.prank(alice);\n>         uint256 nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(alice);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 2 ether}(nftId); \n> \n>         console.log(\"Action2\");\n>         vm.prank(bob);\n>         uint256 nftId_Bob = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(bob);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 3 ether}(nftId_Bob); \n>         \n>         console.log(\"Action3\");\n>         vm.prank(carol);\n>         nftId = POSITION_NFTS_INSTANCE.mintPosition(); \n>         vm.prank(carol);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 2.5 ether}(nftId); \n> \n>         console.log(\"Action4\");\n>         vm.prank(bob);\n>         LENDING_INSTANCE.borrowExactAmountETH(nftId_Bob, 2 ether);\n> \n>         console.log(\"Action5\");\n>         vm.prank(bob);\n>         LENDING_INSTANCE.depositExactAmountETH{value: 1 ether}(nftId_Bob); // @audit : REVERTS incorrectly; Bob can't deposit additional collateral to save himself\n>     }\n> ```\n> \n> </details>\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2026835367):**\n > There is a huge number of combinations which would cause a revert, but considering the vast space of uint256 that number is actually small. Eventually, the issue is called by a rounding which is off by one, and is easily fixed in a repeat transaction. High would be an overstatement.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/27#issuecomment-2082925714):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseLending.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author Ren√© Hochmuth\n * @author Christoph Krpoun\n * @author Vitally Marinchenko\n */\n\nimport \"./PoolManager.sol\";\n\n/**\n * @dev WISE lending is an automated lending platform on which users can collateralize\n * their assets and borrow tokens against them.\n *\n * Users need to pay borrow rates for debt tokens, which are reflected in a borrow APY for\n * each asset type (pool). This borrow rate is variable over time and determined through the\n * utilization of the pool. The bounding curve is a family of different bonding curves adjusted\n * automatically by LASA (Lending Automated Scaling Algorithm). For more information, see:\n * [https://wisesoft.gitbook.io/wise/wise-lending-protocol/lasa-ai]\n *\n * In addition to normal deposit, withdraw, borrow, and payback functions, there are other\n * interacting modes:\n *\n * - Solely deposit and withdraw allows the user to keep their funds private, enabling\n *    them to withdraw even when the pools are borrowed empty.\n *\n * - Aave pools  allow for maximal capital efficiency by earning aave supply APY for not\n *   borrowed funds.\n *\n * - Special curve pools nside beefy farms can be used as collateral, opening up new usage\n *   possibilities for these asset types.\n *\n * - Users can pay back their borrow with lending shares of the same asset type, making it\n *   easier to manage their positions.\n *\n * - Users save their collaterals and borrows inside a position NFT, making it possible\n *   to trade their whole positions or use them in second-layer contracts\n *   (e.g., spot trading with PTP NFT trading platforms).\n */\n\ncontract WiseLending is PoolManager {\n\n    /**\n     * @dev Standard receive functions forwarding\n     * directly send ETH to the master address.\n     */\n    receive()\n        external\n        payable\n    {\n        if (msg.sender == WETH_ADDRESS) {\n            return;\n        }\n\n        _sendValue(\n            master,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Checks if position is healthy\n     * after all state changes are done.\n     */\n    modifier healthStateCheck(\n        uint256 _nftId\n    ) {\n        _;\n\n        _healthStateCheck(\n            _nftId\n        );\n    }\n\n    function _healthStateCheck(\n        uint256 _nftId\n    )\n        private\n    {\n        _checkHealthState(\n            _nftId,\n            powerFarmCheck\n        );\n\n        if (powerFarmCheck == true) {\n            powerFarmCheck = false;\n        }\n    }\n\n    /**\n     * @dev Runs the LASA algorithm known as\n     * Lending Automated Scaling Algorithm\n     * and updates pool data based on token\n     */\n    modifier syncPool(\n        address _poolToken\n    ) {\n        (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        ) = _syncPoolBeforeCodeExecution(\n            _poolToken\n        );\n\n        _;\n\n        _syncPoolAfterCodeExecution(\n            _poolToken,\n            lendSharePrice,\n            borrowSharePrice\n        );\n    }\n\n    constructor(\n        address _master,\n        address _wiseOracleHubAddress,\n        address _nftContract\n    )\n        WiseLendingDeclaration(\n            _master,\n            _wiseOracleHubAddress,\n            _nftContract\n        )\n    {}\n\n    function _emitFundsSolelyWithdrawn(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyWithdrawn(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    function _emitFundsSolelyDeposited(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyDeposited(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Fetches share price of lending shares.\n     */\n    function _getSharePrice(\n        address _poolToken\n    )\n        private\n        view\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        uint256 borrowSharePrice = borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n            * PRECISION_FACTOR_E18\n            / borrowPoolData[_poolToken].totalBorrowShares;\n\n        _validateParameter(\n            MIN_BORROW_SHARE_PRICE,\n            borrowSharePrice\n        );\n\n        return (\n            lendingPoolData[_poolToken].pseudoTotalPool\n                * PRECISION_FACTOR_E18\n                / lendingPoolData[_poolToken].totalDepositShares,\n            borrowSharePrice\n        );\n    }\n\n    function _checkHealthState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n    {\n        WISE_SECURITY.checkHealthState(\n            _nftId,\n            _powerFarm\n        );\n    }\n\n    /**\n     * @dev Compares share prices before and after\n     * execution. If borrow share price increased\n     * or lending share price decreased, revert.\n     */\n    function _compareSharePrices(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n        view\n    {\n        (\n            uint256 lendSharePriceAfter,\n            uint256 borrowSharePriceAfter\n        ) = _getSharePrice(\n            _poolToken\n        );\n\n        uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n            _poolToken\n        );\n\n        _validateParameter(\n            _lendSharePriceBefore,\n            lendSharePriceAfter\n        );\n\n        _validateParameter(\n            lendSharePriceAfter,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            _borrowSharePriceBefore,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            borrowSharePriceAfter,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n    * @dev Since pool inception share price\n    * increase for both lending and borrow shares\n    * is capped at 500% apr max in between a transaction.\n    */\n    function _getCurrentSharePriceMax(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 timeDifference = block.timestamp\n            - timestampsPoolData[_poolToken].initialTimeStamp;\n\n        return timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n    }\n\n    /**\n     * @dev First part of pool sync updating pseudo\n     * amounts. Is skipped when powerFarms or aaveHub\n     * is calling the function.\n     */\n    function _syncPoolBeforeCodeExecution(\n        address _poolToken\n    )\n        private\n        returns (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        )\n    {\n        _checkReentrancy();\n\n        _preparePool(\n            _poolToken\n        );\n\n        if (_aboveThreshold(_poolToken) == true) {\n            _scalingAlgorithm(\n                _poolToken\n            );\n        }\n\n        (\n            lendSharePrice,\n            borrowSharePrice\n        ) = _getSharePrice(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Second part of pool sync updating\n     * the borrow pool rate and share price.\n     */\n    function _syncPoolAfterCodeExecution(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n    {\n        _newBorrowRate(\n            _poolToken\n        );\n\n        _compareSharePrices(\n            _poolToken,\n            _lendSharePriceBefore,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n     * @dev Enables _poolToken to be used as a collateral.\n     */\n    function collateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        WISE_SECURITY.checksCollateralizeDeposit(\n            _nftId,\n            msg.sender,\n            _poolToken\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = false;\n    }\n\n    /**\n     * @dev Disables _poolToken to be used as a collateral.\n     */\n    function unCollateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = true;\n\n        WISE_SECURITY.checkUncollateralizedDeposit(\n            _nftId,\n            _poolToken\n        );\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    // --------------- Deposit Functions -------------\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly.\n     */\n    function depositExactAmountETH(\n        uint256 _nftId\n    )\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _nftId\n        );\n    }\n\n    function _depositExactAmountETH(\n        uint256 _nftId\n    )\n        private\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountETHMint()\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        returns (uint256)\n    {\n        return depositExactAmount(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized.\n     */\n    function depositExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositETHMint()\n        external\n        payable\n    {\n        solelyDepositETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDepositETH(\n        uint256 _nftId\n    )\n        public\n        payable\n        syncPool(WETH_ADDRESS)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Core function combining\n     * supply logic with security\n     * checks for solely deposit.\n     */\n    function _handleSolelyDeposit(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n\n        _increaseMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _increaseTotalBareToken(\n            _poolToken,\n            _amount\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n    {\n        solelyDeposit(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDeposit(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n    }\n\n    // --------------- Withdraw Functions -------------\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact amount.\n     */\n    function withdrawExactAmountETH(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _amount: _amount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _unwrapETH(\n            _amount\n        );\n\n        _sendValue(\n            msg.sender,\n            _amount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact shares.\n     */\n    function withdrawExactSharesETH(\n        uint256 _nftId,\n        uint256 _shares\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _shares: _shares,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawAmount\n        );\n\n        _unwrapETH(\n            withdrawAmount\n        );\n\n        _sendValue(\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ERC20 funds using exact amount.\n     */\n    function withdrawExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ETH funds using input amount.\n     */\n    function solelyWithdrawETH(\n        uint256 _nftId,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n    {\n        _handleSolelyWithdraw(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            _withdrawAmount\n        );\n\n        _unwrapETH(\n            _withdrawAmount\n        );\n\n        _sendValue(\n            msg.sender,\n            _withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ERC20 funds using input amount.\n     */\n    function solelyWithdraw(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n    {\n        _handleSolelyWithdraw(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _withdrawAmount\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Core function combining\n     * withdraw logic for solely\n     * withdraw with security checks.\n     */\n    function _coreSolelyWithdraw(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksSolelyWithdraw(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _decreasePositionMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _decreaseTotalBareToken(\n            _poolToken,\n            _amount\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ERC20 on behalf of owner.\n     * Requires approval by _nftId owner.\n     */\n    function withdrawOnBehalfExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _maxSharePrice: true\n            }\n        );\n\n        _coreWithdrawToken(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _shares: withdrawShares,\n                _onBehalf: true\n            }\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw ERC20\n     * funds using shares as input value\n     */\n    function withdrawExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _shares: _shares,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawAmount\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev Withdraws ERC20 funds on behalf\n     * of _nftId owner, requires approval.\n     */\n    function withdrawOnBehalfExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _shares: _shares,\n                _onBehalf: true\n            }\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    // --------------- Borrow Functions -------------\n\n    /**\n     * @dev Allows to borrow ETH funds\n     * Requires user to have collateral.\n     */\n    function borrowExactAmountETH(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: WETH_ADDRESS,\n            _amount: _amount,\n            _onBehalf: false\n        });\n\n        _validateNonZero(\n            shares\n        );\n\n        _unwrapETH(\n            _amount\n        );\n\n        _sendValue(\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    /**\n     * @dev Allows to borrow ERC20 funds\n     * Requires user to have collateral.\n     */\n    function borrowExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _amount: _amount,\n            _onBehalf: false\n        });\n\n        _validateNonZero(\n            shares\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    /**\n     * @dev Allows to borrow ERC20 funds\n     * on behalf of _nftId owner, if approved.\n     */\n    function borrowOnBehalfExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _amount: _amount,\n            _onBehalf: true\n        });\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    // --------------- Payback Functions ------------\n\n    /**\n     * @dev Ability to payback ETH loans\n     * by providing exact payback amount.\n     */\n    function paybackExactAmountETH(\n        uint256 _nftId\n    )\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        uint256 maxBorrowShares = userBorrowShares[_nftId][WETH_ADDRESS];\n\n        _validateNonZero(\n            maxBorrowShares\n        );\n\n        uint256 maxPaybackAmount = paybackAmount(\n            WETH_ADDRESS,\n            maxBorrowShares\n        );\n\n        uint256 paybackShares = calculateBorrowShares(\n            {\n                _poolToken: WETH_ADDRESS,\n                _amount: msg.value,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            paybackShares\n        );\n\n        uint256 refundAmount;\n        uint256 requiredAmount = msg.value;\n\n        if (msg.value > maxPaybackAmount) {\n\n            unchecked {\n                refundAmount = msg.value\n                    - maxPaybackAmount;\n            }\n\n            requiredAmount = requiredAmount\n                - refundAmount;\n\n            paybackShares = maxBorrowShares;\n        }\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            requiredAmount,\n            paybackShares\n        );\n\n        _wrapETH(\n            requiredAmount\n        );\n\n        if (refundAmount > 0) {\n            _sendValue(\n                msg.sender,\n                refundAmount\n            );\n        }\n\n        return paybackShares;\n    }\n\n    /**\n     * @dev Ability to payback ERC20 loans\n     * by providing exact payback amount.\n     */\n    function paybackExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 paybackShares = calculateBorrowShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _amount,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            paybackShares\n        );\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount,\n            paybackShares\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return paybackShares;\n    }\n\n    /**\n     * @dev Ability to payback ERC20 loans\n     * by providing exact payback shares.\n     */\n    function paybackExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 repaymentAmount = paybackAmount(\n            _poolToken,\n            _shares\n        );\n\n        _validateNonZero(\n            repaymentAmount\n        );\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            repaymentAmount,\n            _shares\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            repaymentAmount\n        );\n\n        return repaymentAmount;\n    }\n\n    // --------------- Liquidation Functions ------------\n\n    /**\n     * @dev Function to liquidate a postion which reaches\n     * a debt ratio greater than 100%. The liquidator can choose\n     * token to payback and receive. (Both can differ!). The\n     * amount is in shares of the payback token. The liquidator\n     * gets an incentive which is calculated inside the liquidation\n     * logic.\n     */\n    function liquidatePartiallyFromTokens(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _paybackToken,\n        address _receiveToken,\n        uint256 _shareAmountToPay\n    )\n        external\n        syncPool(_paybackToken)\n        syncPool(_receiveToken)\n        returns (uint256)\n    {\n        CoreLiquidationStruct memory data;\n\n        data.nftId = _nftId;\n        data.nftIdLiquidator = _nftIdLiquidator;\n\n        data.caller = msg.sender;\n\n        data.tokenToPayback = _paybackToken;\n        data.tokenToRecieve = _receiveToken;\n        data.shareAmountToPay = _shareAmountToPay;\n\n        data.maxFeeETH = WISE_SECURITY.maxFeeETH();\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidation();\n\n        (\n            data.lendTokens,\n            data.borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _receiveToken,\n            _paybackToken\n        );\n\n        data.paybackAmount = paybackAmount(\n            _paybackToken,\n            _shareAmountToPay\n        );\n\n        _checkPositionLocked(\n            _nftId,\n            msg.sender\n        );\n\n        _checkLiquidatorNft(\n            _nftId,\n            _nftIdLiquidator\n        );\n\n        WISE_SECURITY.checksLiquidation(\n            _nftId,\n            _paybackToken,\n            _shareAmountToPay\n        );\n\n        return _coreLiquidation(\n            data\n        );\n    }\n\n    /**\n     * @dev Wrapper function for liqudaiton flow\n     */\n    function coreLiquidationIsolationPools(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _caller,\n        address _paybackToken,\n        address _receiveToken,\n        uint256 _paybackAmount,\n        uint256 _shareAmountToPay\n    )\n        external\n        syncPool(_paybackToken)\n        syncPool(_receiveToken)\n        returns (uint256)\n    {\n        CoreLiquidationStruct memory data;\n\n        data.nftId = _nftId;\n        data.nftIdLiquidator = _nftIdLiquidator;\n\n        data.caller = _caller;\n\n        data.paybackAmount = _paybackAmount;\n        data.tokenToPayback = _paybackToken;\n        data.tokenToRecieve = _receiveToken;\n        data.shareAmountToPay = _shareAmountToPay;\n\n        data.maxFeeETH = WISE_SECURITY.maxFeeFarmETH();\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidationFarm();\n\n        _validateIsolationPoolLiquidation(\n            msg.sender,\n            data.nftId,\n            data.nftIdLiquidator\n        );\n\n        (\n            data.lendTokens,\n            data.borrowTokens\n        ) = _prepareAssociatedTokens(\n            data.nftId,\n            data.tokenToRecieve,\n            data.tokenToPayback\n        );\n\n        return _coreLiquidation(\n            data\n        );\n    }\n\n    /**\n     * @dev Allows to sync pool manually\n     * so that the pool is up to date.\n     */\n    function syncManually(\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        address[] memory tokens = new address[](1);\n        tokens[0] = _poolToken;\n\n        _curveSecurityChecks(\n            new address[](0),\n            tokens\n        );\n    }\n\n    /**\n     * @dev Registers position _nftId\n     * for isolation pool functionality\n     */\n    function setRegistrationIsolationPool(\n        uint256 _nftId,\n        bool _registerState\n    )\n        external\n    {\n        _onlyIsolationPool(\n            msg.sender\n        );\n\n        _validateZero(\n            WISE_SECURITY.overallETHCollateralsBare(_nftId)\n        );\n\n        _validateZero(\n            WISE_SECURITY.overallETHBorrowBare(_nftId)\n        );\n\n        positionLocked[_nftId] = _registerState;\n    }\n\n    /**\n    * @dev External wrapper for\n    * {_corePayback} logic callable\n    * by feeMananger.\n    */\n    function corePaybackFeeManager(\n        address _poolToken,\n        uint256 _nftId,\n        uint256 _amount,\n        uint256 _shares\n    )\n        external\n        onlyFeeManager\n        syncPool(_poolToken)\n    {\n        _corePayback(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n    }\n\n    /**\n     * @dev Internal function combining payback\n     * logic and emit of an event.\n     */\n    function _handlePayback(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        private\n    {\n        _corePayback(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n\n        emit FundsReturned(\n            _caller,\n            _poolToken,\n            _nftId,\n            _amount,\n            _shares,\n            block.timestamp\n        );\n    }\n\n    function _handleWithdrawAmount(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        bool _onBehalf\n    )"
    }
  ]
}