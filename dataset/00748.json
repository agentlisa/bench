{
  "Title": "Lack of Validation of Treasury Address Could Halt Contract",
  "Content": "The [`updateTreasury` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/reward/RewardModule.sol#L223) of the `RewardModule` contract changes the address of the treasury that receives a portion of accrued interest from the `IonPool`. This function lacks input validation that prevents setting the treasury to the zero address. If the treasury were to be set to the zero address, a majority of the functionality of the `IonPool` contract (`accrueInterest`, `withdraw`, `supply`, `borrow`, `repay`, and `confiscateVault`) would revert as the [`_mintNormalized` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/reward/RewardModule.sol#L183) in the `RewardModule` contract would revert when attempting to mint to the treasury in the [`_accrueInterest`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L410) and [`_accrueInterestForIlk`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L431) functions in the `IonPool` contract.\n\n\nConsider validating that the treasury address is not the zero address in both the `_initialize` and `updateTreasury` functions in the `RewardModule` contract.\n\n\n***Update:** Resolved in [pull request #29](https://github.com/Ion-Protocol/ion-protocol/pull/29).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/reward/RewardModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport { WadRayMath, RAY } from \"src/libraries/math/WadRayMath.sol\";\n\nimport { ContextUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport { AccessControlDefaultAdminRulesUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlDefaultAdminRulesUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title RewardModule\n */\nabstract contract RewardModule is ContextUpgradeable, AccessControlDefaultAdminRulesUpgradeable {\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev Cannot burn amount whose normalized value is less than zero.\n     */\n    error InvalidBurnAmount();\n\n    /**\n     * @dev Cannot mint amount whose normalized value is less than zero.\n     */\n    error InvalidMintAmount();\n\n    error InvalidUnderlyingAddress();\n    error InvalidTreasuryAddress();\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event MintToTreasury(address indexed treasury, uint256 amount, uint256 supplyFactor);\n\n    event TreasuryUpdate(address treasury);\n\n    struct RewardModuleStorage {\n        IERC20 underlying;\n        uint8 decimals;\n        // A user's true balance at any point will be the value in this mapping times the supplyFactor\n        string name;\n        string symbol;\n        address treasury;\n        uint256 normalizedTotalSupply; // [WAD]\n        uint256 supplyFactor; // [RAY]\n        mapping(address account => uint256) _normalizedBalances; // [WAD]\n    }\n\n    bytes32 public constant ION = keccak256(\"ION\");\n\n    // keccak256(abi.encode(uint256(keccak256(\"ion.storage.RewardModule\")) - 1)) & ~bytes32(uint256(0xff))\n    // solhint-disable-next-line\n    bytes32 private constant RewardModuleStorageLocation =\n        0xdb3a0d63a7808d7d0422c40bb62354f42bff7602a547c329c1453dbcbeef4900;\n\n    function _getRewardModuleStorage() private pure returns (RewardModuleStorage storage $) {\n        assembly {\n            $.slot := RewardModuleStorageLocation\n        }\n    }\n\n    function _initialize(\n        address _underlying,\n        address _treasury,\n        uint8 decimals_,\n        string memory name_,\n        string memory symbol_\n    )\n        internal\n        onlyInitializing\n    {\n        if (_underlying == address(0)) revert InvalidUnderlyingAddress();\n        if (_treasury == address(0)) revert InvalidTreasuryAddress();\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        $.underlying = IERC20(_underlying);\n        $.treasury = _treasury;\n        $.decimals = decimals_;\n        $.name = name_;\n        $.symbol = symbol_;\n        $.supplyFactor = RAY;\n\n        emit TreasuryUpdate(_treasury);\n    }\n\n    /**\n     *\n     * @param user to burn tokens from\n     * @param receiverOfUnderlying to send underlying tokens to\n     * @param amount to burn\n     */\n    function _burn(address user, address receiverOfUnderlying, uint256 amount) internal returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        uint256 amountScaled = amount.rayDivUp(_supplyFactor);\n\n        if (amountScaled == 0) revert InvalidBurnAmount();\n        _burnNormalized(user, amountScaled);\n\n        $.underlying.safeTransfer(receiverOfUnderlying, amount);\n\n        emit Transfer(user, address(0), amount);\n\n        return _supplyFactor;\n    }\n\n    /**\n     *\n     * @param account to decrease balance of\n     * @param amount of normalized tokens to burn\n     */\n    function _burnNormalized(address account, uint256 amount) private {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        if (account == address(0)) revert InvalidSender(address(0));\n\n        uint256 oldAccountBalance = $._normalizedBalances[account];\n        if (oldAccountBalance < amount) revert InsufficientBalance(account, oldAccountBalance, amount);\n        // Underflow impossible\n        unchecked {\n            $._normalizedBalances[account] = oldAccountBalance - amount;\n        }\n\n        $.normalizedTotalSupply -= amount;\n    }\n\n    /**\n     *\n     * @param user to mint tokens to\n     * @param senderOfUnderlying address to transfer underlying tokens from\n     * @param amount of reward tokens to mint\n     */\n    function _mint(address user, address senderOfUnderlying, uint256 amount) internal returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        uint256 amountScaled = amount.rayDivDown(_supplyFactor); // [WAD] * [RAY] / [RAY] = [WAD]\n        if (amountScaled == 0) revert InvalidMintAmount();\n        _mintNormalized(user, amountScaled);\n\n        $.underlying.safeTransferFrom(senderOfUnderlying, address(this), amount);\n\n        emit Transfer(address(0), user, amount);\n\n        return _supplyFactor;\n    }\n\n    /**\n     *\n     * @param account to increase balance of\n     * @param amount of normalized tokens to mint\n     */\n    function _mintNormalized(address account, uint256 amount) private {\n        if (account == address(0)) revert InvalidReceiver(address(0));\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        $.normalizedTotalSupply += amount;\n\n        $._normalizedBalances[account] += amount;\n    }\n\n    /**\n     * @dev This function does not perform any rounding checks.\n     * @param amount of tokens to mint to treasury\n     */\n    function _mintToTreasury(uint256 amount) internal {\n        if (amount == 0) return;\n\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _supplyFactor = $.supplyFactor;\n        address _treasury = $.treasury;\n\n        // Compared to the normal mint, we don't check for rounding errors.\n        // The amount to mint can easily be very small since it is a fraction of the interest accrued.\n        // In that case, the treasury will experience a (very small) loss, but it\n        // wont cause potentially valid transactions to fail.\n        _mintNormalized(_treasury, amount.rayDivDown(_supplyFactor));\n\n        emit Transfer(address(0), _treasury, amount);\n        emit MintToTreasury(_treasury, amount, _supplyFactor);\n    }\n\n    function _setSupplyFactor(uint256 newSupplyFactor) internal {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        $.supplyFactor = newSupplyFactor;\n    }\n\n    /**\n     * @dev Updates the treasury address\n     * @param newTreasury address of new treasury\n     */\n    function updateTreasury(address newTreasury) external onlyRole(ION) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        $.treasury = newTreasury;\n\n        emit TreasuryUpdate(newTreasury);\n    }\n\n    // --- Getters ---\n\n    /**\n     * @dev Address of underlying asset\n     */\n    function underlying() public view returns (IERC20) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.underlying;\n    }\n\n    /**\n     * @dev Decimals of the position asset\n     */\n    function decimals() public view returns (uint8) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.decimals;\n    }\n\n    /**\n     * @dev Current token balance\n     * @param user to get balance of\n     */\n    function balanceOf(address user) public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $._normalizedBalances[user].rayMulDown($.supplyFactor);\n    }\n\n    /**\n     * @dev Accounting is done in normalized balances\n     * @param user to get normalized balance of\n     */\n    function normalizedBalanceOf(address user) external view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $._normalizedBalances[user];\n    }\n\n    /**\n     * @dev Name of the position asset\n     */\n    function name() public view returns (string memory) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.name;\n    }\n\n    /**\n     * @dev Symbol of the position asset\n     */\n    function symbol() public view returns (string memory) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.symbol;\n    }\n\n    /**\n     * @dev Current treasury address\n     */\n    function treasury() public view returns (address) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.treasury;\n    }\n\n    /**\n     * @dev Current total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n\n        uint256 _normalizedTotalSupply = $.normalizedTotalSupply;\n\n        if (_normalizedTotalSupply == 0) {\n            return 0;\n        }\n\n        return _normalizedTotalSupply.rayMulDown($.supplyFactor);\n    }\n\n    /**\n     * @dev Current normalized total supply\n     */\n    function normalizedTotalSupply() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.normalizedTotalSupply;\n    }\n\n    /**\n     * @dev Current supply factor\n     */\n    function supplyFactor() public view returns (uint256) {\n        RewardModuleStorage storage $ = _getRewardModuleStorage();\n        return $.supplyFactor;\n    }\n}"
    }
  ]
}