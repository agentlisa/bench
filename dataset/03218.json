{
  "Title": "Security and sanity check bypass in `MultiCallOptimizedSwapper`",
  "Content": "##### Description\nAs well as similar functions, [`execute`](https://github.com/yearn/hardhat-monorepo/blob/ecc0b5147992b34c315e08af170ceb4a5fe071ee/packages/yswaps/contracts/TradeFactory/TradeFactoryExecutor.sol#L126) performs several sanity and security checks:\n- provided swapper is required to be in `_swappers` enumerable set\n- exchange path `tokenIn` and `tokenOut` is required to be enabled for given `strategy`\n- output token amount is required to be greater or equal to provided `minAmountOut`.\n\nHowever, the actual code executed by [`_executeSwap`](https://github.com/yearn/hardhat-monorepo/blob/ecc0b5147992b34c315e08af170ceb4a5fe071ee/packages/yswaps/contracts/swappers/async/MultiCallOptimizedSwapper.sol#L27) is arbitrary and can accidentally or intentionally bypass these checks. Although `MultiCallOptimizedSwapper` can be only invoked by the trusted actor `onlyMechanics`, arbitrary code execution can probably lead to loss of funds in case of accidental bug at off-chain bot. Also, single compromised `Mechanic` account key can lead to \"rug pull\" from all connected strategies.\n##### Recommendation\nWe recommend to disallow execution of arbitrary code and keep the best practice of white-listing of allowed actions and calls, similar to other swappers at `contracts/swappers/async` directory.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/yswaps/contracts/TradeFactory/TradeFactoryExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\nimport '@yearn/contract-utils/contracts/utils/Machinery.sol';\n\nimport '../swappers/async/AsyncSwapper.sol';\nimport '../swappers/async/MultipleAsyncSwapper.sol';\nimport '../swappers/sync/SyncSwapper.sol';\n\nimport './TradeFactoryPositionsHandler.sol';\n\ninterface ITradeFactoryExecutor {\n  event SyncTradeExecuted(address indexed _strategy, uint256 _receivedAmount, address indexed _swapper);\n\n  event AsyncTradeExecuted(uint256 _receivedAmount, address _swapper);\n\n  event MultipleAsyncTradeExecuted(uint256[] _receivedAmount, address _swapper);\n\n  error InvalidAmountOut();\n\n  struct SyncTradeExecutionDetails {\n    address _tokenIn;\n    address _tokenOut;\n    uint256 _amountIn;\n    uint256 _maxSlippage;\n  }\n\n  struct AsyncTradeExecutionDetails {\n    address _strategy;\n    address _tokenIn;\n    address _tokenOut;\n    uint256 _amount;\n    uint256 _minAmountOut;\n  }\n\n  // Sync execution\n  function execute(SyncTradeExecutionDetails calldata _tradeExecutionDetails, bytes calldata _data) external returns (uint256 _receivedAmount);\n\n  // Async execution\n  function execute(\n    AsyncTradeExecutionDetails calldata _tradeExecutionDetails,\n    address _swapper,\n    bytes calldata _data\n  ) external returns (uint256 _receivedAmount);\n\n  // Multiple async execution\n  function execute(\n    AsyncTradeExecutionDetails[] calldata _tradesExecutionDetails,\n    address _swapper,\n    bytes calldata _data\n  ) external;\n}\n\nabstract contract TradeFactoryExecutor is ITradeFactoryExecutor, TradeFactoryPositionsHandler, Machinery {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  constructor(address _mechanicsRegistry) Machinery(_mechanicsRegistry) {}\n\n  // Machinery\n  function setMechanicsRegistry(address __mechanicsRegistry) external virtual override onlyRole(MASTER_ADMIN) {\n    _setMechanicsRegistry(__mechanicsRegistry);\n  }\n\n  // Execute via sync swapper\n  function execute(SyncTradeExecutionDetails calldata _tradeExecutionDetails, bytes calldata _data)\n    external\n    override\n    onlyRole(STRATEGY)\n    returns (uint256 _receivedAmount)\n  {\n    address _swapper = strategySyncSwapper[msg.sender];\n    if (_tradeExecutionDetails._tokenIn == address(0) || _tradeExecutionDetails._tokenOut == address(0)) revert CommonErrors.ZeroAddress();\n    if (_tradeExecutionDetails._amountIn == 0) revert CommonErrors.ZeroAmount();\n    if (_tradeExecutionDetails._maxSlippage == 0) revert CommonErrors.ZeroSlippage();\n    IERC20(_tradeExecutionDetails._tokenIn).safeTransferFrom(msg.sender, _swapper, _tradeExecutionDetails._amountIn);\n    uint256 _preSwapBalanceOut = IERC20(_tradeExecutionDetails._tokenOut).balanceOf(msg.sender);\n    ISyncSwapper(_swapper).swap(\n      msg.sender,\n      _tradeExecutionDetails._tokenIn,\n      _tradeExecutionDetails._tokenOut,\n      _tradeExecutionDetails._amountIn,\n      _tradeExecutionDetails._maxSlippage,\n      _data\n    );\n    _receivedAmount = IERC20(_tradeExecutionDetails._tokenOut).balanceOf(msg.sender) - _preSwapBalanceOut;\n    emit SyncTradeExecuted(msg.sender, _receivedAmount, _swapper);\n  }\n\n  // Execute via async swapper\n  function execute(\n    AsyncTradeExecutionDetails calldata _tradeExecutionDetails,\n    address _swapper,\n    bytes calldata _data\n  ) external override onlyMechanic returns (uint256 _receivedAmount) {\n    if (\n      !_tokensOutByStrategyAndTokenIn[_tradeExecutionDetails._strategy][_tradeExecutionDetails._tokenIn].contains(\n        _tradeExecutionDetails._tokenOut\n      )\n    ) revert InvalidTrade();\n    if (!_swappers.contains(_swapper)) revert InvalidSwapper();\n    uint256 _amount = _tradeExecutionDetails._amount != 0\n      ? _tradeExecutionDetails._amount\n      : IERC20(_tradeExecutionDetails._tokenIn).balanceOf(_tradeExecutionDetails._strategy);\n    IERC20(_tradeExecutionDetails._tokenIn).safeTransferFrom(_tradeExecutionDetails._strategy, _swapper, _amount);\n    uint256 _preSwapBalanceOut = IERC20(_tradeExecutionDetails._tokenOut).balanceOf(_tradeExecutionDetails._strategy);\n    IAsyncSwapper(_swapper).swap(\n      _tradeExecutionDetails._strategy,\n      _tradeExecutionDetails._tokenIn,\n      _tradeExecutionDetails._tokenOut,\n      _amount,\n      _tradeExecutionDetails._minAmountOut,\n      _data\n    );\n    _receivedAmount = IERC20(_tradeExecutionDetails._tokenOut).balanceOf(_tradeExecutionDetails._strategy) - _preSwapBalanceOut;\n    if (_receivedAmount < _tradeExecutionDetails._minAmountOut) revert InvalidAmountOut();\n    emit AsyncTradeExecuted(_receivedAmount, _swapper);\n  }\n\n  function execute(\n    AsyncTradeExecutionDetails[] calldata _tradesExecutionDetails,\n    address _swapper,\n    bytes calldata _data\n  ) external override onlyMechanic {\n    // Balance out holder will firstly have the pre swap balance out of each strategy\n    uint256[] memory _balanceOutHolder = new uint256[](_tradesExecutionDetails.length);\n    if (!_swappers.contains(_swapper)) revert InvalidSwapper();\n    for (uint256 i; i < _tradesExecutionDetails.length; i++) {\n      if (\n        !_tokensOutByStrategyAndTokenIn[_tradesExecutionDetails[i]._strategy][_tradesExecutionDetails[i]._tokenIn].contains(\n          _tradesExecutionDetails[i]._tokenOut\n        )\n      ) revert InvalidTrade();\n      uint256 _amount = _tradesExecutionDetails[i]._amount != 0\n        ? _tradesExecutionDetails[i]._amount\n        : IERC20(_tradesExecutionDetails[i]._tokenIn).balanceOf(_tradesExecutionDetails[i]._strategy);\n      IERC20(_tradesExecutionDetails[i]._tokenIn).safeTransferFrom(_tradesExecutionDetails[i]._strategy, _swapper, _amount);\n      _balanceOutHolder[i] = IERC20(_tradesExecutionDetails[i]._tokenOut).balanceOf(_tradesExecutionDetails[i]._strategy);\n    }\n    IMultipleAsyncSwapper(_swapper).swapMultiple(_data);\n    for (uint256 i; i < _tradesExecutionDetails.length; i++) {\n      // Balance out holder will now store the total received amount of token out per strat\n      _balanceOutHolder[i] = IERC20(_tradesExecutionDetails[i]._tokenOut).balanceOf(_tradesExecutionDetails[i]._strategy) - _balanceOutHolder[i];\n      if (_tradesExecutionDetails[i]._minAmountOut < _balanceOutHolder[i]) revert InvalidAmountOut();\n    }\n    emit MultipleAsyncTradeExecuted(_balanceOutHolder, _swapper);\n  }\n}"
    },
    {
      "filename": "packages/yswaps/contracts/swappers/async/MultiCallOptimizedSwapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport './MultipleAsyncSwapper.sol';\n\ninterface IMultiCallOptimizedSwapper is IMultipleAsyncSwapper {\n  error MultiCallRevert();\n  error CallOnlyOptimizationRequired();\n  enum MulticallOptimization {\n    None, // 0\n    CallOnly, // 1\n    SameTo, // 2\n    CallOnlySameTo, // 3\n    NoValue, // 4\n    CallOnlyNoValue, // 5\n    _6, // filler\n    CallOnlySameToNoValue // 7\n  }\n}\n\ncontract MultiCallOptimizedSwapper is IMultiCallOptimizedSwapper, MultipleAsyncSwapper {\n  using SafeERC20 for IERC20;\n\n  constructor(address _governor, address _tradeFactory) MultipleAsyncSwapper(_governor, _tradeFactory) {}\n\n  function _executeSwap(\n    address,\n    address,\n    address,\n    uint256,\n    bytes calldata _data\n  ) internal override {\n    uint8 multicallOptimization = _getMultiCallOptimization(_data);\n\n    bool _success;\n    if (multicallOptimization == uint8(MulticallOptimization.CallOnly)) {\n      _success = _multiSendCallOnly(_data); // OptimizedCall;\n    } else if (multicallOptimization == uint8(MulticallOptimization.CallOnlySameTo)) {\n      _success = _multiSendCallOnlySameTo(_data); // OptimizedCallSameTo;\n    } else if (multicallOptimization == uint8(MulticallOptimization.CallOnlyNoValue)) {\n      _success = _multiSendCallOnlyNoValue(_data); // OptimizedCallNoValue;\n    } else if (multicallOptimization == uint8(MulticallOptimization.CallOnlySameToNoValue)) {\n      _success = _multiSendCallOnlySameToNoValue(_data); // OptimizedCallSameToNoValue;\n    } else {\n      revert CallOnlyOptimizationRequired();\n    }\n\n    if (!_success) revert MultiCallRevert();\n  }\n\n  function swapMultiple(bytes calldata _data) external override onlyTradeFactory {\n    uint8 multicallOptimization = _getMultiCallOptimization(_data);\n\n    bool _success;\n\n    if (multicallOptimization == uint8(MulticallOptimization.CallOnly)) {\n      _success = _multiSendCallOnly(_data); // OptimizedCall;\n    } else if (multicallOptimization == uint8(MulticallOptimization.CallOnlySameTo)) {\n      _success = _multiSendCallOnlySameTo(_data); // OptimizedCallSameTo;\n    } else if (multicallOptimization == uint8(MulticallOptimization.CallOnlyNoValue)) {\n      _success = _multiSendCallOnlyNoValue(_data); // OptimizedCallNoValue;\n    } else if (multicallOptimization == uint8(MulticallOptimization.CallOnlySameToNoValue)) {\n      _success = _multiSendCallOnlySameToNoValue(_data); // OptimizedCallSameToNoValue;\n    } else {\n      revert CallOnlyOptimizationRequired();\n    }\n\n    if (!_success) revert MultiCallRevert();\n  }\n\n  function _getMultiCallOptimization(bytes memory _data) internal pure returns (uint8 multicallOptimization) {\n    assembly {\n      multicallOptimization := shr(0xf8, shl(0x0, mload(add(_data, 0x20))))\n    }\n  }\n\n  function _multiSendCallOnly(bytes memory transactions) internal returns (bool _success) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let length := mload(transactions)\n      // starts at + 32 bytes + 1 multicallOptimization byte\n      let i := 0x21\n      for {\n        // Pre block is not used in \"while mode\"\n      } lt(i, length) {\n        // Post block is not used in \"while mode\"\n      } {\n        // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n        let to := shr(0x60, mload(add(transactions, i)))\n        // We offset the load address by 20 byte (20 address bytes)\n        let value := mload(add(transactions, add(i, 0x14)))\n        // We offset the load address by 52 byte (20 address bytes + 32 value bytes)\n        let dataLength := mload(add(transactions, add(i, 0x34)))\n        // We offset the load address by 84 byte (20 address bytes + 32 value bytes + 32 data length bytes)\n        let data := add(transactions, add(i, 0x54))\n        _success := call(gas(), to, value, data, dataLength, 0, 0)\n        if eq(_success, 0) {\n          break\n        }\n\n        // Next entry starts at 84 byte + data length\n        i := add(i, add(0x54, dataLength))\n      }\n    }\n  }\n\n  function _multiSendCallOnlySameTo(bytes memory transactions) internal returns (bool _success) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let length := mload(transactions)\n      // starts at + 32 bytes + 1 operation byte\n      let i := 0x21\n      // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n      let to := shr(0x60, mload(add(transactions, i)))\n      // We offset the load address by 20 byte (20 address bytes)\n      i := add(i, 0x14)\n      for {\n        // Pre block is not used in \"while mode\"\n      } lt(i, length) {\n        // Post block is not used in \"while mode\"\n      } {\n        let value := mload(add(transactions, add(i, 0x14)))\n        // We offset the load address by 52 byte (20 address bytes + 32 value bytes)\n        let dataLength := mload(add(transactions, add(i, 0x34)))\n        // We offset the load address by 84 byte (20 address bytes + 32 value bytes + 32 data length bytes)\n        let data := add(transactions, add(i, 0x54))\n        _success := call(gas(), to, value, data, dataLength, 0, 0)\n        if eq(_success, 0) {\n          break\n        }\n\n        // Next entry starts at 84 byte + data length\n        i := add(i, add(0x54, dataLength))\n      }\n    }\n  }\n\n  function _multiSendCallOnlyNoValue(bytes memory transactions) internal returns (bool _success) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let length := mload(transactions)\n      // starts at + 32 bytes + 1 operation byte\n      let i := 0x21\n      for {\n        // Pre block is not used in \"while mode\"\n      } lt(i, length) {\n        // Post block is not used in \"while mode\"\n      } {\n        // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n        let to := shr(0x60, mload(add(transactions, i)))\n        // We offset the load address by 20 byte (20 address bytes)\n        let dataLength := mload(add(transactions, add(i, 0x14)))\n        // We offset the load address by 52 byte (20 address bytes + 32 data length bytes)\n        let data := add(transactions, add(i, 0x34))\n        _success := call(gas(), to, 0, data, dataLength, 0, 0)\n        if eq(_success, 0) {\n          break\n        }\n\n        // Next entry starts at 52 byte + data length\n        i := add(i, add(0x34, dataLength))\n      }\n    }\n  }\n\n  function _multiSendCallOnlySameToNoValue(bytes memory transactions) internal returns (bool _success) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let length := mload(transactions)\n      // starts at + 32 bytes + 1 operation byte\n      let i := 0x21\n      // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n      let to := shr(0x60, mload(add(transactions, i)))\n      // We offset the load address by 20 byte (20 address bytes)\n      i := add(i, 0x14)\n      for {\n        // Pre block is not used in \"while mode\"\n      } lt(i, length) {\n        // Post block is not used in \"while mode\"\n      } {\n        let dataLength := mload(add(transactions, i))\n        // We offset the load address by 32 byte (32 data length bytes)\n        let data := add(transactions, add(i, 0x20))\n        _success := call(gas(), to, 0, data, dataLength, 0, 0)\n        if eq(_success, 0) {\n          break\n        }\n        // Next entry starts at 32 bytes + data length\n        i := add(i, add(0x20, dataLength))\n      }\n    }\n  }\n}"
    }
  ]
}