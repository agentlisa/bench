{
  "Title": "GenericOracle public frontrun for `initialize()`",
  "Content": "##### Description\n\nThe first call of `GenericOracle.initialize()` can be made by anyone.\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/oracles/GenericOracle.sol#L20-L24\n\nAs a result, anyone can frontrun the official initialize() call and set malicious oracles, which is extremely dangerous for the whole project.\n\n##### Recommendation\n\nWe recommend implementing an onlyOwner modifier, the same way as for `initialize()` functions in `Conroller` and`RewardManager`.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracles/GenericOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../interfaces/IGenericOracle.sol\";\n\ncontract GenericOracle is IGenericOracle, Ownable {\n    using ScaledMath for uint256;\n\n    event CustomOracleAdded(address token, address oracle);\n\n    mapping(address => IOracle) public customOracles;\n\n    IOracle internal _chainlinkOracle;\n    IOracle internal _curveLpOracle;\n\n    function initialize(address curveLpOracle, address chainlinkOracle) external {\n        require(address(_curveLpOracle) == address(0), \"already initialized\");\n        _chainlinkOracle = IOracle(chainlinkOracle);\n        _curveLpOracle = IOracle(curveLpOracle);\n    }\n\n    function isTokenSupported(address token) external view override returns (bool) {\n        return\n            address(customOracles[token]) != address(0) ||\n            _chainlinkOracle.isTokenSupported(token) ||\n            _curveLpOracle.isTokenSupported(token);\n    }\n\n    function getUSDPrice(address token) public view virtual returns (uint256) {\n        if (_chainlinkOracle.isTokenSupported(token)) {\n            return _chainlinkOracle.getUSDPrice(token);\n        }\n        if (address(customOracles[token]) != address(0)) {\n            return customOracles[token].getUSDPrice(token);\n        }\n        return _curveLpOracle.getUSDPrice(token);\n    }\n\n    function setCustomOracle(address token, address oracle) external onlyOwner {\n        customOracles[token] = IOracle(oracle);\n        emit CustomOracleAdded(token, oracle);\n    }\n\n    function curveLpToUnderlying(\n        address curveLpToken,\n        address underlying,\n        uint256 curveLpAmount\n    ) external view returns (uint256) {\n        return\n            curveLpToUnderlying(curveLpToken, underlying, curveLpAmount, getUSDPrice(underlying));\n    }\n\n    function curveLpToUnderlying(\n        address curveLpToken,\n        address underlying,\n        uint256 curveLpAmount,\n        uint256 underlyingPrice\n    ) public view returns (uint256) {\n        return\n            curveLpAmount.mulDown(getUSDPrice(curveLpToken)).divDown(underlyingPrice).convertScale(\n                18,\n                IERC20Metadata(underlying).decimals()\n            );\n    }\n\n    function underlyingToCurveLp(\n        address underlying,\n        address curveLpToken,\n        uint256 underlyingAmount\n    ) external view returns (uint256) {\n        return\n            underlyingAmount\n                .mulDown(getUSDPrice(address(underlying)))\n                .divDown(getUSDPrice(curveLpToken))\n                .convertScale(IERC20Metadata(underlying).decimals(), 18);\n    }\n}"
    }
  ]
}