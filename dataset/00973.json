{
  "Title": "All functions that burn or mint shares for user's should mintFee for protocol before",
  "Content": "# All functions that burn or mint shares for user's should mintFee for protocol before\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXDeposit.sol#L172\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXDeposit.sol#L172</a>\n\n\n## Summary\nIn case if GMXVault mints/burns shares for users, then it should call `mintFee` before in order to get correct portion of fee.\n## Vulnerability Details\nSteadefi protocol takes management fee from stakers. This fee accrues each second and is some percentage of totalSupply. In order to mint fees, [GMXVault.mintFee should be called](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXVault.sol#L334-L337). Once, it's done, then `_store.lastFeeCollected` is updated up to date.\n\nCurrently `mintFee` is called only in 2 places in the code. Once in the deposit and once in the withdraw function. However, minting and burning is not done in any of them. For example, minting of shares is done [in the `processDeposit` function](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXDeposit.sol#L172) and this function is called after some time, when `deposit` is called. As result some time already has passed and fees should be accrued. But in  current implementation, new shares will be added to the totalSupply and fees will be taken out of them for the time when this shares were not even minted.\n\nSame for the withdraw. When withdraw is called, then shares are not burnt. They are burnt [inside `processWithdraw` function](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXWithdraw.sol#L197). So in case if burn is done before `feeMint` is called, then this removed shares doesn't pay management fee.\n\nAnd last place is `GMXEmergency.emergencyWithdraw`. This function [also burns shares](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXEmergency.sol#L182), which means that `mintFee` should be called before it.\n## Impact\nIncorrect fee payment is done, depending on the situation users or protocol will suffer.\n## Tools Used\nVsCode\n## Recommendations\nConsider call `mintFee` for all these cases that i have described.",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenB),\n          address(self.tokenB),\n          slippage\n        );\n      } else {\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenA),\n          address(self.tokenB),\n          slippage\n        );\n      }\n\n      _rlp.executionFee = executionFee;\n\n      // Remove liqudity\n      self.depositCache.withdrawKey = GMXManager.removeLiquidity(\n        self,\n        _rlp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    GMXTypes.RepayParams memory _rp;\n\n    _rp.repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    _rp.repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n\n    // Check if swap between assets are needed for repayment based on previous borrow\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Adjust amount to repay for both tokens due to slight differences\n    // from liqudiity withdrawal and swaps. If the amount to repay based on previous borrow\n    // is more than the available balance vault has, we simply repay what the vault has\n    uint256 _repayTokenAAmt;\n    uint256 _repayTokenBAmt;\n\n    if (self.depositCache.borrowParams.borrowTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      _repayTokenAAmt = self.tokenA.balanceOf(address(this));\n    } else {\n      _repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    }\n\n    if (self.depositCache.borrowParams.borrowTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      _repayTokenBAmt = self.tokenB.balanceOf(address(this));\n    } else {\n      _repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n    }\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      _repayTokenAAmt,\n      _repayTokenBAmt\n    );\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { IWNT } from  \"../../interfaces/tokens/IWNT.sol\";\nimport { IGMXVault } from  \"../../interfaces/strategy/gmx/IGMXVault.sol\";\nimport { IGMXVaultEvents } from  \"../../interfaces/strategy/gmx/IGMXVaultEvents.sol\";\nimport { ILendingVault } from  \"../../interfaces/lending/ILendingVault.sol\";\nimport { IChainlinkOracle } from  \"../../interfaces/oracles/IChainlinkOracle.sol\";\nimport { IGMXOracle } from  \"../../interfaces/oracles/IGMXOracle.sol\";\nimport { IExchangeRouter } from \"../../interfaces/protocols/gmx/IExchangeRouter.sol\";\nimport { ISwap } from \"../../interfaces/swap/ISwap.sol\";\nimport { Errors } from  \"../../utils/Errors.sol\";\nimport { GMXTypes } from  \"./GMXTypes.sol\";\nimport { GMXDeposit } from  \"./GMXDeposit.sol\";\nimport { GMXWithdraw } from  \"./GMXWithdraw.sol\";\nimport { GMXRebalance } from  \"./GMXRebalance.sol\";\nimport { GMXCompound } from  \"./GMXCompound.sol\";\nimport { GMXEmergency } from  \"./GMXEmergency.sol\";\nimport { GMXReader } from  \"./GMXReader.sol\";\n\n/**\n  * @title GMXVault\n  * @author Steadefi\n  * @notice Main point of interaction with a Steadefi leveraged strategy vault\n*/\ncontract GMXVault is ERC20, Ownable2Step, ReentrancyGuard, IGMXVault, IGMXVaultEvents {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMXTypes.Store\n  GMXTypes.Store internal _store;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Approved keepers\n  mapping(address => bool) public keepers;\n  // Approved tokens for deposit and withdraw\n  mapping(address => bool) public tokens;\n\n  /* ======================= MODIFIERS ======================= */\n\n  // Allow only vault modifier\n  modifier onlyVault() {\n    _onlyVault();\n    _;\n  }\n\n  // Allow only keeper modifier\n  modifier onlyKeeper() {\n    _onlyKeeper();\n    _;\n  }\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @notice Initialize and configure vault's store, token approvals and whitelists\n    * @param name Name of vault\n    * @param symbol Symbol for vault token\n    * @param store_ GMXTypes.Store\n  */\n  constructor (\n    string memory name,\n    string memory symbol,\n    GMXTypes.Store memory store_\n  ) ERC20(name, symbol) Ownable(msg.sender) {\n    _store.leverage = uint256(store_.leverage);\n    _store.delta = store_.delta;\n    _store.feePerSecond = uint256(store_.feePerSecond);\n    _store.treasury = address(store_.treasury);\n\n    _store.debtRatioStepThreshold = uint256(store_.debtRatioStepThreshold);\n    _store.debtRatioUpperLimit = uint256(store_.debtRatioUpperLimit);\n    _store.debtRatioLowerLimit = uint256(store_.debtRatioLowerLimit);\n    _store.deltaUpperLimit = int256(store_.deltaUpperLimit);\n    _store.deltaLowerLimit = int256(store_.deltaLowerLimit);\n    _store.minSlippage = store_.minSlippage;\n    _store.minExecutionFee = store_.minExecutionFee;\n\n    _store.tokenA = IERC20(store_.tokenA);\n    _store.tokenB = IERC20(store_.tokenB);\n    _store.lpToken = IERC20(store_.lpToken);\n    _store.WNT = IWNT(store_.WNT);\n\n    _store.tokenALendingVault = ILendingVault(store_.tokenALendingVault);\n    _store.tokenBLendingVault = ILendingVault(store_.tokenBLendingVault);\n\n    _store.vault = IGMXVault(address(this));\n    _store.trove = store_.trove;\n    _store.callback = store_.callback;\n\n    _store.chainlinkOracle = IChainlinkOracle(store_.chainlinkOracle);\n    _store.gmxOracle = IGMXOracle(store_.gmxOracle);\n\n    _store.exchangeRouter = IExchangeRouter(store_.exchangeRouter);\n    _store.router = store_.router;\n    _store.depositVault = store_.depositVault;\n    _store.withdrawalVault = store_.withdrawalVault;\n    _store.roleStore = store_.roleStore;\n\n    _store.swapRouter = ISwap(store_.swapRouter);\n\n    _store.status = GMXTypes.Status.Open;\n\n    _store.lastFeeCollected = block.timestamp;\n\n    // Set token whitelist for this vault\n    tokens[address(_store.tokenA)] = true;\n    tokens[address(_store.tokenB)] = true;\n    tokens[address(_store.lpToken)] = true;\n\n    // Set token approvals for this vault\n    _store.tokenA.approve(address(_store.router), type(uint256).max);\n    _store.tokenB.approve(address(_store.router), type(uint256).max);\n    _store.lpToken.approve(address(_store.router), type(uint256).max);\n\n    _store.tokenA.approve(address(_store.depositVault), type(uint256).max);\n    _store.tokenB.approve(address(_store.depositVault), type(uint256).max);\n\n    _store.lpToken.approve(address(_store.withdrawalVault), type(uint256).max);\n\n    _store.tokenA.approve(address(_store.tokenALendingVault), type(uint256).max);\n    _store.tokenB.approve(address(_store.tokenBLendingVault), type(uint256).max);\n\n    // Set callback contract as keeper\n    keepers[_store.callback] = true;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice View vault store data\n    * @return GMXTypes.Store\n  */\n  function store() public view returns (GMXTypes.Store memory) {\n    return _store;\n  }\n\n  /**\n    * @notice Check if token is whitelisted for deposit/withdraw for this vault\n    * @param token Address of token to check\n    * @return Boolean of whether token is whitelisted\n  */\n  function isTokenWhitelisted(address token) public view returns (bool) {\n    return tokens[token];\n  }\n\n  /**\n    * @notice Returns the value of each strategy vault share token; equityValue / totalSupply()\n    * @return svTokenValue  USD value of each share token in 1e18\n  */\n  function svTokenValue() public view returns (uint256) {\n    return GMXReader.svTokenValue(_store);\n  }\n\n  /**\n    * @notice Amount of share pending for minting as a form of management fee\n    * @return pendingFee in 1e18\n  */\n  function pendingFee() public view returns (uint256) {\n    return GMXReader.pendingFee(_store);\n  }\n\n  /**\n    * @notice Conversion of equity value to svToken shares\n    * @param value Equity value change after deposit in 1e18\n    * @param currentEquity Current equity value of vault in 1e18\n    * @return sharesAmt in 1e18\n  */\n  function valueToShares(uint256 value, uint256 currentEquity) public view returns (uint256) {\n    return GMXReader.valueToShares(_store, value, currentEquity);\n  }\n\n  /**\n    * @notice Convert token amount to USD value using price from oracle\n    * @param token Token address\n    * @param amt Amount in token decimals\n    @ @return tokenValue USD value in 1e18\n  */\n  function convertToUsdValue(address token, uint256 amt) public view returns (uint256) {\n    return GMXReader.convertToUsdValue(_store, token, amt);\n  }\n\n  /**\n    * @notice Return token weights (%) in LP\n    @ @return tokenAWeight in 1e18; e.g. 50% = 5e17\n    @ @return tokenBWeight in 1e18; e.g. 50% = 5e17\n  */\n  function tokenWeights() public view returns (uint256, uint256) {\n    return GMXReader.tokenWeights(_store);\n  }\n\n  /**\n    * @notice Returns the total USD value of tokenA & tokenB assets held by the vault\n    * @notice Asset = Debt + Equity\n    * @return assetValue USD value of total assets in 1e18\n  */\n  function assetValue() public view returns (uint256) {\n    return GMXReader.assetValue(_store);\n  }\n\n  /**\n    * @notice Returns the USD value of tokenA & tokenB debt held by the vault\n    * @notice Asset = Debt + Equity\n    * @return tokenADebtValue USD value of tokenA debt in 1e18\n    * @return tokenBDebtValue USD value of tokenB debt in 1e18\n  */\n  function debtValue() public view returns (uint256, uint256) {\n    return GMXReader.debtValue(_store);\n  }\n\n  /**\n    * @notice Returns the USD value of tokenA & tokenB equity held by the vault;\n    * @notice Asset = Debt + Equity\n    * @return equityValue USD value of total equity in 1e18\n  */\n  function equityValue() public view returns (uint256) {\n    return GMXReader.equityValue(_store);\n  }\n\n  /**\n    * @notice Returns the amt of tokenA & tokenB assets held by vault\n    * @return tokenAAssetAmt in tokenA decimals\n    * @return tokenBAssetAmt in tokenB decimals\n  */\n  function assetAmt() public view returns (uint256, uint256) {\n    return GMXReader.assetAmt(_store);\n  }\n\n  /**\n    * @notice Returns the amt of tokenA & tokenB debt held by vault\n    * @return tokenADebtAmt in tokenA decimals\n    * @return tokenBDebtAmt in tokenB decimals\n  */\n  function debtAmt() public view returns (uint256, uint256) {\n    return GMXReader.debtAmt(_store);\n  }\n\n  /**\n    * @notice Returns the amt of LP tokens held by vault\n    * @return lpAmt in 1e18\n  */\n  function lpAmt() public view returns (uint256) {\n    return GMXReader.lpAmt(_store);\n  }\n\n  /**\n    * @notice Returns the current leverage (asset / equity)\n    * @return leverage Current leverage in 1e18\n  */\n  function leverage() public view returns (uint256) {\n    return GMXReader.leverage(_store);\n  }\n\n  /**\n    * @notice Returns the current delta (tokenA equityValue / vault equityValue)\n    * @notice Delta refers to the position exposure of this vault's strategy to the\n    * underlying volatile asset. Delta can be a negative value\n    * @return delta in 1e18 (0 = Neutral, > 0 = Long, < 0 = Short)\n  */\n  function delta() public view returns (int256) {\n    return GMXReader.delta(_store);\n  }\n\n  /**\n    * @notice Returns the debt ratio (tokenA and tokenB debtValue) / (total assetValue)\n    * @notice When assetValue is 0, we assume the debt ratio to also be 0\n    * @return debtRatio % in 1e18\n  */\n  function debtRatio() public view returns (uint256) {\n    return GMXReader.debtRatio(_store);\n  }\n\n  /**\n    * @notice Additional capacity vault that can be deposited to vault based on available lending liquidity\n    @ @return additionalCapacity USD value in 1e18\n  */\n  function additionalCapacity() public view returns (uint256) {\n    return GMXReader.additionalCapacity(_store);\n  }\n\n  /**\n    * @notice Total capacity of vault; additionalCapacity + equityValue\n    @ @return capacity USD value in 1e18\n  */\n  function capacity() public view returns (uint256) {\n    return GMXReader.capacity(_store);\n  }\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Deposit a whitelisted asset into vault and mint strategy vault share tokens to user\n    * @param dp GMXTypes.DepositParams\n  */\n  function deposit(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, false);\n  }\n\n  /**\n    * @notice Deposit native asset (e.g. ETH) into vault and mint strategy vault share tokens to user\n    * @notice This function is only function if vault accepts native token\n    * @param dp GMXTypes.DepositParams\n  */\n  function depositNative(GMXTypes.DepositParams memory dp) external payable nonReentrant {\n    GMXDeposit.deposit(_store, dp, true);\n  }\n\n  /**\n    * @notice Withdraws a whitelisted asset from vault and burns strategy vault share tokens from user\n    * @param wp GMXTypes.WithdrawParams\n  */\n  function withdraw(GMXTypes.WithdrawParams memory wp) external payable nonReentrant {\n    GMXWithdraw.withdraw(_store, wp);\n  }\n\n  /**\n    * @notice Emergency withdraw function, enabled only when vault status is Closed, burns\n    svToken from user while withdrawing assets from vault to user\n    * @param shareAmt Amount of vault token shares to withdraw in 1e18\n  */\n  function emergencyWithdraw(uint256 shareAmt) external nonReentrant {\n    GMXEmergency.emergencyWithdraw(_store, shareAmt);\n  }\n\n  /**\n    * @notice Mint vault token shares as management fees to protocol treasury\n  */\n  function mintFee() public {\n    _mint(_store.treasury, GMXReader.pendingFee(_store));\n    _store.lastFeeCollected = block.timestamp;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Allow only vault\n  */\n  function _onlyVault() internal view {\n    if (msg.sender != address(_store.vault)) revert Errors.OnlyVaultAllowed();\n  }\n\n  /**\n    * @notice Allow only keeper\n  */\n  function _onlyKeeper() internal view {\n    if (!keepers[msg.sender]) revert Errors.OnlyKeeperAllowed();\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Post deposit operations if adding liquidity is successful to GMX\n    * @dev Should be called only after deposit() / depositNative() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDeposit() external onlyKeeper {\n    GMXDeposit.processDeposit(_store);\n  }\n\n  /**\n    * @notice Post deposit operations if adding liquidity has been cancelled by GMX\n    * @dev To be called only after deposit()/depositNative() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDepositCancellation() external onlyKeeper {\n    GMXDeposit.processDepositCancellation(_store);\n  }\n\n  /**\n    * @notice Post deposit operations if after deposit checks failed by GMXChecks.afterDepositChecks()\n    * @dev Should be called by approved Keeper after error event is picked up\n    * @param slippage Slippage for liquidity removal\n    * @param executionFee Execution fee passed in to remove liquidity\n  */\n  function processDepositFailure(\n    uint256 slippage,\n    uint256 executionFee\n  ) external payable onlyKeeper {\n    GMXDeposit.processDepositFailure(_store, slippage, executionFee);\n  }\n\n  /**\n    * @notice Post deposit failure operations\n    * @dev To be called after processDepositFailure()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processDepositFailureLiquidityWithdrawal() external onlyKeeper {\n    GMXDeposit.processDepositFailureLiquidityWithdrawal(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if removing liquidity is successful from GMX\n    * @dev Should be called only after withdraw() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdraw() external onlyKeeper {\n    GMXWithdraw.processWithdraw(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if removing liquidity has been cancelled by GMX\n    * @dev To be called only after withdraw() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdrawCancellation() external onlyKeeper {\n    GMXWithdraw.processWithdrawCancellation(_store);\n  }\n\n  /**\n    * @notice Post withdraw operations if after withdraw checks failed by GMXChecks.afterWithdrawChecks()\n    * @dev Should be called by approved Keeper after error event is picked up\n    * @param slippage Slippage for liquidity removal\n    * @param executionFee Execution fee passed in to remove liquidity\n  */\n  function processWithdrawFailure(\n    uint256 slippage,\n    uint256 executionFee\n  ) external payable onlyKeeper {\n    GMXWithdraw.processWithdrawFailure(_store, slippage, executionFee);\n  }\n\n  /**\n    * @notice Post withdraw failure operations\n    * @dev To be called after processWithdrawFailure()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processWithdrawFailureLiquidityAdded() external onlyKeeper {\n    GMXWithdraw.processWithdrawFailureLiquidityAdded(_store);\n  }\n\n  /**\n    * @notice Rebalance vault's delta and/or debt ratio by adding liquidity\n    * @dev Should be called by approved Keeper\n    * @param rap GMXTypes.RebalanceAddParams\n  */\n  function rebalanceAdd(\n    GMXTypes.RebalanceAddParams memory rap\n  ) external payable nonReentrant onlyKeeper {\n    GMXRebalance.rebalanceAdd(_store, rap);\n  }\n\n  /**\n    * @notice Post rebalance add operations if adding liquidity is successful to GMX\n    * @dev To be called after rebalanceAdd()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceAdd() external nonReentrant onlyKeeper {\n    GMXRebalance.processRebalanceAdd(_store);\n  }\n\n  /**\n    * @notice Post rebalance add operations if adding liquidity has been cancelled by GMX\n    * @dev To be called only after rebalanceAdd() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceAddCancellation() external nonReentrant onlyKeeper {\n    GMXRebalance.processRebalanceAddCancellation(_store);\n  }\n\n  /**\n    * @notice Rebalance vault's delta and/or debt ratio by removing liquidity\n    * @dev Should be called by approved Keeper\n    * @param rrp GMXTypes.RebalanceRemoveParams\n  */\n  function rebalanceRemove(\n    GMXTypes.RebalanceRemoveParams memory rrp\n  ) external payable nonReentrant onlyKeeper {\n    GMXRebalance.rebalanceRemove(_store, rrp);\n  }\n\n  /**\n    * @notice Post rebalance remove operations if removing liquidity is successful to GMX\n    * @dev To be called after rebalanceRemove()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceRemove() external onlyKeeper {\n    GMXRebalance.processRebalanceRemove(_store);\n  }\n\n  /**\n    * @notice Post rebalance remove operations if removing liquidity has been cancelled by GMX\n    * @dev To be called only after rebalanceRemove() is called\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processRebalanceRemoveCancellation() external nonReentrant onlyKeeper {\n    GMXRebalance.processRebalanceRemoveCancellation(_store);\n  }\n\n  /**\n    * @notice Compounds ERC20 token rewards and convert to more LP\n    * @dev Assumes that reward tokens are already in vault\n    * @dev Should be called by approved Keeper\n    * @param cp GMXTypes.CompoundParams\n  */\n  function compound(GMXTypes.CompoundParams memory cp) external payable onlyKeeper {\n    GMXCompound.compound(_store, cp);\n  }\n\n  /**\n    * @notice Post compound operations if adding liquidity is successful to GMX\n    * @dev To be called after processCompound()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processCompound() external onlyKeeper {\n    GMXCompound.processCompound(_store);\n  }\n\n  /**\n    * @notice Post compound operations if adding liquidity has been cancelled by GMX\n    * @dev To be called after processCompound()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processCompoundCancellation() external onlyKeeper {\n    GMXCompound.processCompoundCancellation(_store);\n  }\n\n  /**\n    * @notice Withdraws LP for all underlying assets to vault and set vault status to Paused\n    * @dev To be called only in an emergency situation. Can be called in ANY vault status\n    * @dev Should be called by approved Keeper\n  */\n  function emergencyPause() external payable onlyKeeper {\n    GMXEmergency.emergencyPause(_store);\n  }\n\n  /**\n    * @notice Re-add all assets for liquidity for LP in anticipation of vault resuming\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n  */\n  function emergencyResume() external payable onlyOwner {\n    GMXEmergency.emergencyResume(_store);\n  }\n\n  /**\n    * @notice Post emergency resume operations if re-adding liquidity is successful\n    * @dev To be called after emergencyResume()\n    * @dev Should be called by approved vault's Callback or approved Keeper\n  */\n  function processEmergencyResume() external payable onlyKeeper {\n    GMXEmergency.processEmergencyResume(_store);\n  }\n\n  /**\n    * @notice Repays all debt owed by vault and shut down vault, allowing emergency withdrawals\n    * @dev Note that this is a one-way irreversible action\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param deadline Timestamp of swap deadline\n  */\n  function emergencyClose(uint256 deadline) external onlyOwner {\n    GMXEmergency.emergencyClose(_store, deadline);\n  }\n\n  /**\n    * @notice Approve or revoke address to be a keeper for this vault\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param keeper Keeper address\n    * @param approval Boolean to approve keeper or not\n  */\n  function updateKeeper(address keeper, bool approval) external onlyOwner {\n    keepers[keeper] = approval;\n    emit KeeperUpdated(keeper, approval);\n  }\n\n  /**\n    * @notice Update treasury address\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param treasury Treasury address\n  */\n  function updateTreasury(address treasury) external onlyOwner {\n    _store.treasury = treasury;\n    emit TreasuryUpdated(treasury);\n  }\n\n  /**\n    * @notice Update swap router address\n    * @dev Should be called by approved Owner (Timelock + MultiSig)\n    * @param swapRouter Swap router address\n  */\n  function updateSwapRouter(address swapRouter) external onlyOwner {\n    _store.swapRouter = ISwap(swapRouter);\n    emit SwapRouterUpdated(swapRouter);\n  }\n\n  /**\n    * @notice Update trove address\n    * @dev Should only be called once on vault initialization\n    * @param trove Trove address\n  */\n  function updateTrove(address trove) external onlyOwner {\n    _store.trove = trove;\n    emit TroveUpdated(trove);\n  }\n\n  /**\n    * @notice Update callback address\n    * @dev Sho"
    }
  ]
}