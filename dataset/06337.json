{
  "Title": "[M-02] Unsafe cast in `getCollateralRatio()`",
  "Content": "\n`LibGetters.getCollateralRatio()` might return the incorrect ratio due to the unsafe cast.\n\n### Proof of Concept\n\n`getCollateralRatio()` outputs the collateral ratio using the total collaterals and issued agTokens.\n\n```solidity\n    // The `stablecoinsIssued` value need to be rounded up because it is then used as a divizer when computing\n    // the amount of stablecoins issued\n    stablecoinsIssued = uint256(ts.normalizedStables).mulDiv(ts.normalizer, BASE_27, Math.Rounding.Up);\n    if (stablecoinsIssued > 0)\n        collatRatio = uint64(totalCollateralization.mulDiv(BASE_9, stablecoinsIssued, Math.Rounding.Up)); //@audit unsafe cast\n    else collatRatio = type(uint64).max;\n```\n\nTypically, the `collatRatio` should be around `BASE_9` but the ratio might be larger than `type(uint64).max` during the initial stage.\n\nFurthermore, `totalCollateralization` is calculated using the [raw balance of collaterals](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibGetters.sol#L73) and it might be manipulated when [stablecoinsIssued](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibGetters.sol#L85) is not large.\n\nThen [collatRatio](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibGetters.sol#L87) might be cast to the wrong value.\n\nAfter all, `getCollateralRatio()` will return the wrong ratio and it will affect the protocol seriously.\n\n### Recommended Mitigation Steps\n\nI think we should use the [SafeCast](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/facets/Swapper.sol#L9) library in [getCollateralRatio()](https://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibGetters.sol#L87).\n\n**[Picodes (Angle) disagreed with severity and commented](https://github.com/code-423n4/2023-06-angle-findings/issues/31#issuecomment-1628530718):**\n > This seems hardly doable. Assuming there is 1 stablecoin issued (1e18), you'd need 1e28 collateral. Furthermore no impact is described: this would just break this view function. Overall I think Low severity is more appropriate\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/31#issuecomment-1628794945):**\n > @Picodes - Although it's an edge case, it's likely to happen and `getCollateralRatio()` plays an important role in the protocol.\n> Will keep as Medium.\n\n**[GuillaumeNervoXS (Angle) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/31#issuecomment-1629161117):**\n > To overflow the protocol would need to be  1 billion % over collateralise so it is not likely to happen. \n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/31#issuecomment-1629185996):**\n > As #9 shows, 1 USD is enough when `stablecoinsIssued = 1 wei`. I think it should be mitigated for safety.\n\n**[Angle mitigated](https://github.com/code-423n4/2023-07-angle-mitigation/blob/main/README.md#mitigations-to-be-reviewed):**\n> PR: https://github.com/AngleProtocol/angle-transmuter/commit/6f2ffcb1e89e3bba05c9aa2133ef94347aa42c28<br>\n> Adds safeCast.\n\n**Status:** Mitigation error. Full details in reports from [Lambda](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/2), [auditor0517](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/26), and [Jeiwan](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/17) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/transmuter/libraries/LibGetters.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\n\nimport { LibHelpers } from \"./LibHelpers.sol\";\nimport { LibManager } from \"./LibManager.sol\";\nimport { LibOracle } from \"./LibOracle.sol\";\nimport { LibStorage as s } from \"./LibStorage.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../Storage.sol\";\n\n/// @title LibGetters\n/// @author Angle Labs, Inc.\nlibrary LibGetters {\n    using Math for uint256;\n\n    /// @notice Internal version of the `getCollateralRatio` function with additional return values like `tokens` that\n    /// is the list of tokens supported by the system, or `balances` which is the amount of each token in `tokens`\n    /// controlled by the protocol\n    /// @dev In case some collaterals support external strategies (`isManaged>0`), this list may be bigger\n    /// than the `collateralList`\n    /// @dev `subCollateralsTracker` is an array which gives for each collateral asset in the collateral list an\n    /// accumulator helping to recompute the amount of sub-collateral for each collateral. If the array is:\n    /// [1,4,5], this means that the collateral with index 1 in the `collateralsList` has 4-1=3 sub-collaterals.\n    function getCollateralRatio()\n        internal\n        view\n        returns (\n            uint64 collatRatio,\n            uint256 stablecoinsIssued,\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256[] memory subCollateralsTracker\n        )\n    {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 totalCollateralization;\n        address[] memory collateralList = ts.collateralList;\n        uint256 collateralListLength = collateralList.length;\n        uint256 subCollateralsAmount;\n        // Building the `subCollateralsTracker` array which is useful when later sending the tokens as part of the\n        // redemption\n        subCollateralsTracker = new uint256[](collateralListLength);\n        for (uint256 i; i < collateralListLength; ++i) {\n            if (ts.collaterals[collateralList[i]].isManaged == 0) ++subCollateralsAmount;\n            else subCollateralsAmount += ts.collaterals[collateralList[i]].managerData.subCollaterals.length;\n            subCollateralsTracker[i] = subCollateralsAmount;\n        }\n        balances = new uint256[](subCollateralsAmount);\n        tokens = new address[](subCollateralsAmount);\n\n        {\n            uint256 countCollat;\n            for (uint256 i; i < collateralListLength; ++i) {\n                Collateral storage collateral = ts.collaterals[collateralList[i]];\n                uint256 collateralBalance; // Will be either the balance or the value of assets managed\n                if (collateral.isManaged > 0) {\n                    // If a collateral is managed, the balances of the sub-collaterals cannot be directly obtained by\n                    // calling `balanceOf` of the sub-collaterals\n                    uint256[] memory subCollateralsBalances;\n                    (subCollateralsBalances, collateralBalance) = LibManager.totalAssets(collateral.managerData.config);\n                    uint256 numSubCollats = subCollateralsBalances.length;\n                    for (uint256 k; k < numSubCollats; ++k) {\n                        tokens[countCollat + k] = address(collateral.managerData.subCollaterals[k]);\n                        balances[countCollat + k] = subCollateralsBalances[k];\n                    }\n                    countCollat += numSubCollats;\n                } else {\n                    collateralBalance = IERC20(collateralList[i]).balanceOf(address(this));\n                    tokens[countCollat] = collateralList[i];\n                    balances[countCollat++] = collateralBalance;\n                }\n                uint256 oracleValue = LibOracle.readRedemption(collateral.oracleConfig);\n                totalCollateralization +=\n                    (oracleValue * LibHelpers.convertDecimalTo(collateralBalance, collateral.decimals, 18)) /\n                    BASE_18;\n            }\n        }\n        // The `stablecoinsIssued` value need to be rounded up because it is then used as a divizer when computing\n        // the amount of stablecoins issued\n        stablecoinsIssued = uint256(ts.normalizedStables).mulDiv(ts.normalizer, BASE_27, Math.Rounding.Up);\n        if (stablecoinsIssued > 0)\n            collatRatio = uint64(totalCollateralization.mulDiv(BASE_9, stablecoinsIssued, Math.Rounding.Up));\n        else collatRatio = type(uint64).max;\n    }\n}"
    },
    {
      "filename": "contracts/transmuter/libraries/LibGetters.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\n\nimport { LibHelpers } from \"./LibHelpers.sol\";\nimport { LibManager } from \"./LibManager.sol\";\nimport { LibOracle } from \"./LibOracle.sol\";\nimport { LibStorage as s } from \"./LibStorage.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../Storage.sol\";\n\n/// @title LibGetters\n/// @author Angle Labs, Inc.\nlibrary LibGetters {\n    using Math for uint256;\n\n    /// @notice Internal version of the `getCollateralRatio` function with additional return values like `tokens` that\n    /// is the list of tokens supported by the system, or `balances` which is the amount of each token in `tokens`\n    /// controlled by the protocol\n    /// @dev In case some collaterals support external strategies (`isManaged>0`), this list may be bigger\n    /// than the `collateralList`\n    /// @dev `subCollateralsTracker` is an array which gives for each collateral asset in the collateral list an\n    /// accumulator helping to recompute the amount of sub-collateral for each collateral. If the array is:\n    /// [1,4,5], this means that the collateral with index 1 in the `collateralsList` has 4-1=3 sub-collaterals.\n    function getCollateralRatio()\n        internal\n        view\n        returns (\n            uint64 collatRatio,\n            uint256 stablecoinsIssued,\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256[] memory subCollateralsTracker\n        )\n    {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 totalCollateralization;\n        address[] memory collateralList = ts.collateralList;\n        uint256 collateralListLength = collateralList.length;\n        uint256 subCollateralsAmount;\n        // Building the `subCollateralsTracker` array which is useful when later sending the tokens as part of the\n        // redemption\n        subCollateralsTracker = new uint256[](collateralListLength);\n        for (uint256 i; i < collateralListLength; ++i) {\n            if (ts.collaterals[collateralList[i]].isManaged == 0) ++subCollateralsAmount;\n            else subCollateralsAmount += ts.collaterals[collateralList[i]].managerData.subCollaterals.length;\n            subCollateralsTracker[i] = subCollateralsAmount;\n        }\n        balances = new uint256[](subCollateralsAmount);\n        tokens = new address[](subCollateralsAmount);\n\n        {\n            uint256 countCollat;\n            for (uint256 i; i < collateralListLength; ++i) {\n                Collateral storage collateral = ts.collaterals[collateralList[i]];\n                uint256 collateralBalance; // Will be either the balance or the value of assets managed\n                if (collateral.isManaged > 0) {\n                    // If a collateral is managed, the balances of the sub-collaterals cannot be directly obtained by\n                    // calling `balanceOf` of the sub-collaterals\n                    uint256[] memory subCollateralsBalances;\n                    (subCollateralsBalances, collateralBalance) = LibManager.totalAssets(collateral.managerData.config);\n                    uint256 numSubCollats = subCollateralsBalances.length;\n                    for (uint256 k; k < numSubCollats; ++k) {\n                        tokens[countCollat + k] = address(collateral.managerData.subCollaterals[k]);\n                        balances[countCollat + k] = subCollateralsBalances[k];\n                    }\n                    countCollat += numSubCollats;\n                } else {\n                    collateralBalance = IERC20(collateralList[i]).balanceOf(address(this));\n                    tokens[countCollat] = collateralList[i];\n                    balances[countCollat++] = collateralBalance;\n                }\n                uint256 oracleValue = LibOracle.readRedemption(collateral.oracleConfig);\n                totalCollateralization +=\n                    (oracleValue * LibHelpers.convertDecimalTo(collateralBalance, collateral.decimals, 18)) /\n                    BASE_18;\n            }\n        }\n        // The `stablecoinsIssued` value need to be rounded up because it is then used as a divizer when computing\n        // the amount of stablecoins issued\n        stablecoinsIssued = uint256(ts.normalizedStables).mulDiv(ts.normalizer, BASE_27, Math.Rounding.Up);\n        if (stablecoinsIssued > 0)\n            collatRatio = uint64(totalCollateralization.mulDiv(BASE_9, stablecoinsIssued, Math.Rounding.Up));\n        else collatRatio = type(uint64).max;\n    }\n}"
    },
    {
      "filename": "contracts/transmuter/facets/Swapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { Address } from \"oz/utils/Address.sol\";\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\nimport { SafeCast } from \"oz/utils/math/SafeCast.sol\";\n\nimport { IAgToken } from \"interfaces/IAgToken.sol\";\nimport { ISwapper } from \"interfaces/ISwapper.sol\";\nimport { IPermit2, PermitTransferFrom } from \"interfaces/external/permit2/IPermit2.sol\";\nimport { SignatureTransferDetails, TokenPermissions } from \"interfaces/external/permit2/IPermit2.sol\";\n\nimport { LibHelpers } from \"../libraries/LibHelpers.sol\";\nimport { LibManager } from \"../libraries/LibManager.sol\";\nimport { LibOracle } from \"../libraries/LibOracle.sol\";\nimport { LibStorage as s } from \"../libraries/LibStorage.sol\";\nimport { LibWhitelist } from \"../libraries/LibWhitelist.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n// Struct to help storing local variables to avoid stack too deep issues\nstruct LocalVariables {\n    bool isMint;\n    bool isExact;\n    uint256 lowerExposure;\n    uint256 upperExposure;\n    int256 lowerFees;\n    int256 upperFees;\n    uint256 amountToNextBreakPoint;\n    uint256 stablecoinsIssued;\n    uint256 otherStablecoinSupply;\n}\n\n/// @title Swapper\n/// @author Angle Labs, Inc.\n/// @dev In all the functions of this contract, one of `tokenIn` or `tokenOut` must be the stablecoin, and\n/// one of `tokenOut` or `tokenIn` must be an accepted collateral. Depending on the `tokenIn` or `tokenOut` given,\n/// the functions will either handle a mint or a burn operation\n/// @dev In case of a burn, they will also revert if the system does not have enough of `amountOut` for `tokenOut`.\n/// This balance must be available either directly on the contract or, when applicable, through the underlying\n/// strategies that manage the collateral\n/// @dev Functions here may be paused for some collateral assets (for either mint or burn), in which case they'll revert\n/// @dev In case of a burn again, the swap functions will revert if the call concerns a collateral that requires a\n/// whitelist but the `to` address does not have it. The quote functions will not revert in this case.\n/// @dev Calling one of the swap functions in a burn case does not require any prior token approval\ncontract Swapper is ISwapper {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using Address for address;\n    using Math for uint256;\n\n    // The `to` address is not indexed as there cannot be 4 indexed addresses in an event.\n    event Swap(\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        address indexed from,\n        address to\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                               EXTERNAL ACTION FUNCTIONS                                            \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    // For the four functions below, a value of `0` for the `deadline` parameters means that there will be no timestamp\n    // check for when the swap is actually executed.\n\n    /// @inheritdoc ISwapper\n    /// @dev `msg.sender` must have approved this contract for at least `amountIn` for `tokenIn` for mint transactions\n    function swapExactInput(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address tokenIn,\n        address tokenOut,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut) {\n        (bool mint, Collateral storage collatInfo) = _getMintBurn(tokenIn, tokenOut, deadline);\n        amountOut = mint\n            ? _quoteMintExactInput(collatInfo, amountIn)\n            : _quoteBurnExactInput(tokenOut, collatInfo, amountIn);\n        if (amountOut < amountOutMin) revert TooSmallAmountOut();\n        _swap(amountIn, amountOut, tokenIn, tokenOut, to, mint, collatInfo, \"\");\n    }\n\n    /// @inheritdoc ISwapper\n    function swapExactInputWithPermit(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address tokenIn,\n        address to,\n        uint256 deadline,\n        bytes memory permitData\n    ) external returns (uint256 amountOut) {\n        (address tokenOut, Collateral storage collatInfo) = _getMint(tokenIn, deadline);\n        amountOut = _quoteMintExactInput(collatInfo, amountIn);\n        if (amountOut < amountOutMin) revert TooSmallAmountOut();\n        permitData = _buildPermitTransferPayload(amountIn, amountIn, tokenIn, deadline, permitData, collatInfo);\n        _swap(amountIn, amountOut, tokenIn, tokenOut, to, true, collatInfo, permitData);\n    }\n\n    /// @inheritdoc ISwapper\n    /// @dev `msg.sender` must have approved this contract for an amount bigger than what `amountIn` will\n    /// be before calling this function for a mint. Approving the contract for `tokenIn` with `amountInMax`\n    /// will always be enough in this case\n    function swapExactOutput(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address tokenIn,\n        address tokenOut,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountIn) {\n        (bool mint, Collateral storage collatInfo) = _getMintBurn(tokenIn, tokenOut, deadline);\n        amountIn = mint\n            ? _quoteMintExactOutput(collatInfo, amountOut)\n            : _quoteBurnExactOutput(tokenOut, collatInfo, amountOut);\n        if (amountIn > amountInMax) revert TooBigAmountIn();\n        _swap(amountIn, amountOut, tokenIn, tokenOut, to, mint, collatInfo, \"\");\n    }\n\n    /// @inheritdoc ISwapper\n    function swapExactOutputWithPermit(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address tokenIn,\n        address to,\n        uint256 deadline,\n        bytes memory permitData\n    ) public returns (uint256 amountIn) {\n        (address tokenOut, Collateral storage collatInfo) = _getMint(tokenIn, deadline);\n        amountIn = _quoteMintExactOutput(collatInfo, amountOut);\n        if (amountIn > amountInMax) revert TooBigAmountIn();\n        permitData = _buildPermitTransferPayload(amountIn, amountInMax, tokenIn, deadline, permitData, collatInfo);\n        _swap(amountIn, amountOut, tokenIn, tokenOut, to, true, collatInfo, permitData);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                     VIEW HELPERS                                                   \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    // If these functions return a 0 `amountOut` or `amountIn` value, then calling one of the swap functions above\n    // will not do anything.\n\n    /// @inheritdoc ISwapper\n    function quoteIn(uint256 amountIn, address tokenIn, address tokenOut) external view returns (uint256 amountOut) {\n        (bool mint, Collateral storage collatInfo) = _getMintBurn(tokenIn, tokenOut, 0);\n        if (mint) return _quoteMintExactInput(collatInfo, amountIn);\n        else {\n            amountOut = _quoteBurnExactInput(tokenOut, collatInfo, amountIn);\n            _checkAmounts(collatInfo, amountOut);\n        }\n    }\n\n    /// @inheritdoc ISwapper\n    function quoteOut(uint256 amountOut, address tokenIn, address tokenOut) external view returns (uint256 amountIn) {\n        (bool mint, Collateral storage collatInfo) = _getMintBurn(tokenIn, tokenOut, 0);\n        if (mint) return _quoteMintExactOutput(collatInfo, amountOut);\n        else {\n            _checkAmounts(collatInfo, amountOut);\n            return _quoteBurnExactOutput(tokenOut, collatInfo, amountOut);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   INTERNAL ACTIONS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Processes the internal metric updates and the transfers following mint or burn operations\n    function _swap(\n        uint256 amountIn,\n        uint256 amountOut,\n        address tokenIn,\n        address tokenOut,\n        address to,\n        bool mint,\n        Collateral storage collatInfo,\n        bytes memory permitData\n    ) internal {\n        if (amountIn > 0 && amountOut > 0) {\n            TransmuterStorage storage ts = s.transmuterStorage();\n            if (mint) {\n                uint128 changeAmount = (amountOut.mulDiv(BASE_27, ts.normalizer, Math.Rounding.Up)).toUint128();\n                // The amount of stablecoins issued from a collateral are not stored as absolute variables, but\n                // as variables normalized by a `normalizer`\n                collatInfo.normalizedStables += uint216(changeAmount);\n                ts.normalizedStables += changeAmount;\n                if (permitData.length > 0) {\n                    PERMIT_2.functionCall(permitData);\n                } else if (collatInfo.isManaged > 0)\n                    IERC20(tokenIn).safeTransferFrom(\n                        msg.sender,\n                        LibManager.transferRecipient(collatInfo.managerData.config),\n                        amountIn\n                    );\n                else IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n                if (collatInfo.isManaged > 0) {\n                    LibManager.invest(amountIn, collatInfo.managerData.config);\n                }\n                IAgToken(tokenOut).mint(to, amountOut);\n            } else {\n                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))\n                    revert NotWhitelisted();\n                uint128 changeAmount = ((amountIn * BASE_27) / ts.normalizer).toUint128();\n                // This will underflow when the system is trying to burn more stablecoins than what has been issued\n                // from this collateral\n                collatInfo.normalizedStables -= uint216(changeAmount);\n                ts.normalizedStables -= changeAmount;\n                IAgToken(tokenIn).burnSelf(amountIn, msg.sender);\n                if (collatInfo.isManaged > 0)\n                    LibManager.release(tokenOut, to, amountOut, collatInfo.managerData.config);\n                else IERC20(tokenOut).safeTransfer(to, amountOut);\n            }\n            emit Swap(tokenIn, tokenOut, amountIn, amountOut, msg.sender, to);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                     INTERNAL VIEW                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Computes the `amountOut` of stablecoins to mint from `tokenIn` of a collateral with data `collatInfo`\n    function _quoteMintExactInput(\n        Collateral storage collatInfo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        uint256 oracleValue = LibOracle.readMint(collatInfo.oracleConfig);\n        amountOut = LibHelpers.convertDecimalTo(oracleValue * amountIn, 18 + collatInfo.decimals, 18);\n        amountOut = _quoteFees(collatInfo, QuoteType.MintExactInput, amountOut);\n    }\n\n    /// @notice Computes the `amountIn` of collateral to get during a mint of `amountOut` of stablecoins\n    function _quoteMintExactOutput(\n        Collateral storage collatInfo,\n        uint256 amountOut\n    ) internal view returns (uint256 amountIn) {\n        uint256 oracleValue = LibOracle.readMint(collatInfo.oracleConfig);\n        amountIn = _quoteFees(collatInfo, QuoteType.MintExactOutput, amountOut);\n        amountIn = LibHelpers.convertDecimalTo((amountIn * BASE_18) / oracleValue, 18, collatInfo.decimals);\n    }\n\n    /// @notice Computes the `amountIn` of stablecoins to burn to release `amountOut` of `collateral`\n    function _quoteBurnExactOutput(\n        address collateral,\n        Collateral storage collatInfo,\n        uint256 amountOut\n    ) internal view returns (uint256 amountIn) {\n        (uint256 ratio, uint256 oracleValue) = LibOracle.getBurnOracle(collateral, collatInfo.oracleConfig);\n        amountIn = Math.mulDiv(LibHelpers.convertDecimalTo(amountOut, collatInfo.decimals, 18), oracleValue, ratio);\n        amountIn = _quoteFees(collatInfo, QuoteType.BurnExactOutput, amountIn);\n    }\n\n    /// @notice Computes the `amountOut` of `collateral` to give during a burn operation of `amountIn` of stablecoins\n    function _quoteBurnExactInput(\n        address collateral,\n        Collateral storage collatInfo,\n        uint256 amountIn\n    ) internal view returns (uint256 amountOut) {\n        (uint256 ratio, uint256 oracleValue) = LibOracle.getBurnOracle(collateral, collatInfo.oracleConfig);\n        amountOut = _quoteFees(collatInfo, QuoteType.BurnExactInput, amountIn);\n        amountOut = LibHelpers.convertDecimalTo((amountOut * ratio) / oracleValue, 18, collatInfo.decimals);\n    }\n\n    /// @notice Computes the fees to apply during a mint or burn operation\n    /// @dev This function leverages the mathematical computations of the appendix of the Transmuter whitepaper\n    /// @dev Cost of the function is linear in the length of the `xFeeMint` or `xFeeBurn` array\n    function _quoteFees(\n        Collateral storage collatInfo,\n        QuoteType quoteType,\n        uint256 amountStable\n    ) internal view returns (uint256) {\n        LocalVariables memory v;\n        v.isMint = _isMint(quoteType);\n        v.isExact = _isExact(quoteType);\n        uint256 n = v.isMint ? collatInfo.xFeeMint.length : collatInfo.xFeeBurn.length;\n\n        uint256 currentExposure;\n        {\n            TransmuterStorage storage ts = s.transmuterStorage();\n            uint256 normalizedStablesMem = ts.normalizedStables;\n            // Handling the initialisation and constant fees\n            if (normalizedStablesMem == 0 || n == 1)\n                return _computeFee(quoteType, amountStable, v.isMint ? collatInfo.yFeeMint[0] : collatInfo.yFeeBurn[0]);\n            // Increasing precision for `currentExposure` because otherwise if there is a factor 1e9 between total\n            // stablecoin supply and one specific collateral, exposure can be null\n            currentExposure = uint64((collatInfo.normalizedStables * BASE_18) / normalizedStablesMem);\n\n            uint256 normalizerMem = ts.normalizer;\n            // Store the current amount of stablecoins issued from this collateral\n            v.stablecoinsIssued = (uint256(collatInfo.normalizedStables) * normalizerMem) / BASE_27;\n            v.otherStablecoinSupply = (normalizerMem * normalizedStablesMem) / BASE_27 - v.stablecoinsIssued;\n        }\n\n        uint256 amount;\n        // Finding in which segment the current exposure to the collateral is\n        uint256 i = LibHelpers.findLowerBound(\n            v.isMint,\n            v.isMint ? collatInfo.xFeeMint : collatInfo.xFeeBurn,\n            uint64(BASE_9),\n            uint64(currentExposure)\n        );\n\n        while (i < n - 1) {\n            // We compute a linear by part function on the amount swapped\n            // The `amountToNextBreakPoint` variable is the `b_{i+1}` value from the whitepaper\n            if (v.isMint) {\n                v.lowerExposure = collatInfo.xFeeMint[i];\n                v.upperExposure = collatInfo.xFeeMint[i + 1];\n                v.lowerFees = collatInfo.yFeeMint[i];\n                v.upperFees = collatInfo.yFeeMint[i + 1];\n                v.amountToNextBreakPoint =\n                    (v.otherStablecoinSupply * v.upperExposure) /\n                    (BASE_9 - v.upperExposure) -\n                    v.stablecoinsIssued;\n            } else {\n                // The exposures in the burn case are decreasing\n                v.lowerExposure = collatInfo.xFeeBurn[i];\n                v.upperExposure = collatInfo.xFeeBurn[i + 1];\n                v.lowerFees = collatInfo.yFeeBurn[i];\n                v.upperFees = collatInfo.yFeeBurn[i + 1];\n                // The `b_{i+1}` value in the burn case is the opposite value of the mint case\n                v.amountToNextBreakPoint =\n                    v.stablecoinsIssued -\n                    (v.otherStablecoinSupply * v.upperExposure) /\n                    (BASE_9 - v.upperExposure);\n            }\n            // Computing the `g_i(0)` value from the whitepaper\n            int256 currentFees;\n            // We can only enter the else in the first iteration of the loop as otherwise we will\n            // always be at the beginning of the new segment\n            if (v.lowerExposure * BASE_9 == currentExposure) currentFees = v.lowerFees;\n            else if (v.lowerFees == v.upperFees) currentFees = v.lowerFees;\n            else {\n                // This is the opposite of the `b_i` value from the whitepaper.\n                uint256 amountFromPrevBreakPoint = v.isMint\n                    ? v.stablecoinsIssued - (v.otherStablecoinSupply * v.lowerExposure) / (BASE_9 - v.lowerExposure)\n                    : (v.otherStablecoinSupply * v.lowerExposure) / (BASE_9 - v.lowerExposure) - v.stablecoinsIssued;\n\n                //  slope = (upperFees - lowerFees) / (amountToNextBreakPoint + amountFromPrevBreakPoint)\n                // `currentFees` is the `g(0)` value from the whitepaper\n                currentFees =\n                    v.lowerFees +\n                    int256(\n                        (uint256(v.upperFees - v.lowerFees) * amountFromPrevBreakPoint) /\n                            (v.amountToNextBreakPoint + amountFromPrevBreakPoint)\n                    );\n            }\n            {\n                // In the mint case, when `!v.isExact`: = `b_{i+1} * (1+(g_i(0)+f_{i+1})/2)`\n                uint256 amountToNextBreakPointNormalizer = v.isExact ? v.amountToNextBreakPoint : v.isMint\n                    ? _invertFeeMint(v.amountToNextBreakPoint, int64(v.upperFees + currentFees) / 2)\n                    : _applyFeeBurn(v.amountToNextBreakPoint, int64(v.upperFees + currentFees) / 2);\n\n                if (amountToNextBreakPointNormalizer >= amountStable) {\n                    int64 midFee;\n                    if (v.isExact) {\n                        // `(g_i(0) + g_i(M)) / 2 = g(0) + (f_{i+1} - g(0)) * M / (2 * b_{i+1})`\n                        midFee = int64(\n                            currentFees +\n                                int256(\n                                    amountStable.mulDiv(\n                                        uint256((v.upperFees - currentFees)),\n                                        2 * amountToNextBreakPointNormalizer,\n                                        Math.Rounding.Up\n                                    )\n                                )\n                        );\n                    } else {\n                        // Here instead of computing the closed form expression for `m_t` derived in the whitepaper,\n                        // we are computing: `(g(0)+g_i(m_t))/2 = g(0)+(f_{i+1}-f_i)/(b_{i+1}-b_i)m_t/2\n\n                        // ac4 is the value of `2M(f_{i+1}-f_i)/(b_{i+1}-b_i) = 2M(f_{i+1}-g(0))/b_{i+1}` used\n                        // in the computation of `m_t` in both the mint and burn case\n                        uint256 ac4 = BASE_9.mulDiv(\n                            2 * amountStable * uint256(v.upperFees - currentFees),\n                            v.amountToNextBreakPoint,\n                            Math.Rounding.Up\n                        );\n\n                        if (v.isMint) {\n                            // In the mint case:\n                            // `m_t = (-1-g(0)+sqrt[(1+g(0))**2+2M(f_{i+1}-g(0))/b_{i+1})]/((f_{i+1}-g(0))/b_{i+1})`\n                            // And so: g(0)+(f_{i+1}-f_i)/(b_{i+1}-b_i)m_t/2\n                            //                      = (g(0)-1+sqrt[(1+g(0))**2+2M(f_{i+1}-g(0))/b_{i+1})])\n                            midFee = int64(\n                                (int256(\n                                    Math.sqrt((uint256(int256(BASE_9) + currentFees)) ** 2 + ac4, Math.Rounding.Up)\n                                ) +\n                                    currentFees -\n                                    int256(BASE_9)) / 2\n                            );\n                        } else {\n                            // In the burn case:\n                            // `m_t = (1-g(0)+sqrt[(1-g(0))**2-2M(f_{i+1}-g(0))/b_{i+1})]/((f_{i+1}-g(0))/b_{i+1})`\n                            // And so: g(0)+(f_{i+1}-f_i)/(b_{i+1}-b_i)m_t/2\n                            //                      = (g(0)+1-sqrt[(1-g(0))**2-2M(f_{i+1}-g(0))/b_{i+1})])\n\n                            uint256 baseMinusCurrentSquared = (uint256(int256(BASE_9) - currentFees)) ** 2;\n                            // Mathematically, this condition is always verified, but rounding errors may make this\n                            // mathematical invariant break, in which case we consider that the square root is null\n                            if (baseMinusCurrentSquared < ac4) midFee = int64((currentFees + int256(BASE_9)) / 2);\n                            else\n                                midFee = int64(\n                                    int256(\n                                        Math.mulDiv(\n                                            uint256(\n                                                currentFees +\n                                                    int256(BASE_9) -\n                                                    int256(Math.sqrt(baseMinusCurrentSquared - ac4, Math.Rounding.Down))\n                                            ),\n                                            1,\n                                            2,\n                                            Math.Rounding.Up\n                                        )\n                                    )\n                                );\n                        }\n                    }\n                    return amount + _computeFee(quoteType, amountStable, midFee);\n                } else {\n                    amountStable -= amountToNextBreakPointNormalizer;\n                    amount += !v.isExact ? v.amountToNextBreakPoint : v.isMint\n                        ? _invertFeeMint(v.amountToNextBreakPoint, int64(v.upperFees + currentFees) / 2)\n                        : _applyFeeBurn(v.amountToNextBreakPoint, int64(v.upperFees + currentFees) / 2);\n                    currentExposure = v.upperExposure * BASE_9;\n                    ++i;\n                    // Update for the rest of the swaps the stablecoins issued from the asset\n                    v.stablecoinsIssued = v.isMint\n                        ? v.stablecoinsIssued + v.amountToNextBreakPoint\n                        : v.stablecoinsIssued - v.amountToNextBreakPoint;\n                }\n            }\n        }\n        // If `i == n-1`, we are in an area where fees are constant\n        return\n            amount +\n            _computeFee(quoteType, amountStable, v.isMint ? collatInfo.yFeeMint[n - 1] : collatInfo.yFeeBurn[n - 1]);\n    }\n\n    /// @notice Checks whether a manage"
    }
  ]
}