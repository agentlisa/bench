{
  "Title": "[M-03] KnightingRound tokenOutPrice changes",
  "Content": "_Submitted by reassor, also found by cccz and cmichel_\n\n`Function.buy` buys the tokens for whatever price is set as `tokenOutPrice`. This might lead to accidental collisions or front-running attacks when user is trying to buy the tokens and his transaction is being included after the transaction of changing the price of the token via `setTokenOutPrice`.\n\nScenario:\n\n1.  User wants to `buy` tokens and can see price `tokenOutPrice`\n2.  User likes the price and issues a transaction to `buy` tokens\n3.  At the same time `CONTRACT_GOVERNANCE_ROLE` account is increasing `tokenOutPrice` through `setTokenOutPrice`\n4.  `setTokenOutPrice` transaction is included before user's `buy` transaction\n5.  User buys tokens with the price he was not aware of\n\nAnother variation of this attack can be performed using front-running.\n\n### Proof of Concept\n\n*   <https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L162-L204>\n\n### Tools Used\n\nManual Review / VSCode\n\n### Recommended Mitigation Steps\n\nIt is recommended to add additional parameter `uint256 believedPrice` to `KnightingRound.buy` function and check if `believedPrice` is equal to `tokenOutPrice`.\n\n**[GalloDaSballo (BadgerDAO) confirmed](https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/73)** \n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-badger-citadel-contest",
  "Code": [
    {
      "filename": "src/KnightingRound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./interfaces/badger/IBadgerVipGuestlist.sol\";\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\n * @title Citadel Knighting Round\n * @notice Sells citadel at a predetermined price to whitelisted buyers. Citadel tokens are not distributed until the finalize event.\n * TODO: Better revert strings\n */\ncontract KnightingRound is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for ERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant TREASURY_GOVERNANCE_ROLE =\n        keccak256(\"TREASURY_GOVERNANCE_ROLE\");\n\n    bytes32 public constant TECH_OPERATIONS_ROLE =\n        keccak256(\"TECH_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE =\n        keccak256(\"TREASURY_OPERATIONS_ROLE\");\n\n    /// token to give out (CTDL)\n    ERC20Upgradeable public tokenOut;\n    /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n    ERC20Upgradeable public tokenIn;\n    /// time when tokens can be first purchased\n    uint256 public saleStart;\n    /// duration of the token sale, cannot purchase afterwards\n    uint256 public saleDuration;\n    /// address receiving the proceeds of the sale - will be citadel multisig\n    address public saleRecipient;\n    /// whether the sale has been finalized\n    bool public finalized;\n\n    /// tokenIn per tokenOut price\n    /// eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public tokenOutPrice;\n\n    /// Amounts bought by accounts\n    mapping(address => uint256) public boughtAmounts;\n    /// Whether an account has claimed tokens\n    /// NOTE: can reset boughtAmounts after a claim to optimize gas\n    ///       but we need to persist boughtAmounts\n    mapping(address => bool) public hasClaimed;\n\n    /// Amount of `tokenIn` taken in\n    uint256 public totalTokenIn;\n    /// Amount of `tokenOut` sold\n    uint256 public totalTokenOutBought;\n    /// Amount of `tokenOut` claimed\n    uint256 public totalTokenOutClaimed;\n\n    /// Max tokenIn that can be taken by the contract (defines the cap for tokenOut sold)\n    uint256 public tokenInLimit;\n\n    uint256 public tokenInNormalizationValue;\n\n    /// Whitelist\n    IBadgerVipGuestlist public guestlist;\n\n    /// Amount vote for each DAO\n    mapping(uint8 => uint256) public daoCommitments;\n    mapping(address => uint8) public daoVotedFor;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event Claim(address indexed claimer, uint256 amount);\n    event Finalized();\n\n    event SaleStartUpdated(uint256 saleStart);\n    event SaleDurationUpdated(uint256 saleDuration);\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n    event SaleRecipientUpdated(address indexed recipient);\n    event GuestlistUpdated(address indexed guestlist);\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    event Sweep(address indexed token, uint256 amount);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade (citadel)\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenOut per tokenIn price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _globalAccessControl,\n        address _tokenOut,\n        address _tokenIn,\n        uint256 _saleStart,\n        uint256 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        __GlobalAccessControlManaged_init(_globalAccessControl);\n\n        tokenOut = ERC20Upgradeable(_tokenOut);\n        tokenIn = ERC20Upgradeable(_tokenIn);\n        saleStart = _saleStart;\n        saleDuration = _saleDuration;\n        tokenOutPrice = _tokenOutPrice;\n        saleRecipient = _saleRecipient;\n        guestlist = IBadgerVipGuestlist(_guestlist);\n        tokenInLimit = _tokenInLimit;\n\n        tokenInNormalizationValue = 10**tokenIn.decimals();\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_tokenInAmount` of `tokenIn` for `tokenOut`\n     * @param _tokenInAmount Amount of `tokenIn` to give\n     * @param _daoId ID of DAO to vote for\n     * @param _proof Merkle proof for the guestlist. Use `new bytes32[](0)` if there's no guestlist\n     * @return tokenOutAmount_ Amount of `tokenOut` bought\n     */\n    function buy(\n        uint256 _tokenInAmount,\n        uint8 _daoId,\n        bytes32[] calldata _proof\n    ) external gacPausable returns (uint256 tokenOutAmount_) {\n        require(saleStart <= block.timestamp, \"KnightingRound: not started\");\n        require(\n            block.timestamp < saleStart + saleDuration,\n            \"KnightingRound: already ended\"\n        );\n        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");\n        require(\n            totalTokenIn + _tokenInAmount <= tokenInLimit,\n            \"total amount exceeded\"\n        );\n\n        if (address(guestlist) != address(0)) {\n            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");\n        }\n\n        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];\n\n        if (boughtAmountTillNow > 0) {\n            require(\n                _daoId == daoVotedFor[msg.sender],\n                \"can't vote for multiple daos\"\n            );\n        } else {\n            daoVotedFor[msg.sender] = _daoId;\n        }\n\n        tokenOutAmount_ = getAmountOut(_tokenInAmount);\n\n        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;\n        daoCommitments[_daoId] = daoCommitments[_daoId] + tokenOutAmount_;\n\n        totalTokenIn = totalTokenIn + _tokenInAmount;\n        totalTokenOutBought = totalTokenOutBought + tokenOutAmount_;\n\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);\n    }\n\n    /**\n     * @notice Claim bought tokens after sale has been finalized\n     */\n    function claim() external gacPausable returns (uint256 tokenOutAmount_) {\n        require(finalized, \"sale not finalized\");\n        require(!hasClaimed[msg.sender], \"already claimed\");\n\n        tokenOutAmount_ = boughtAmounts[msg.sender];\n\n        require(tokenOutAmount_ > 0, \"nothing to claim\");\n\n        hasClaimed[msg.sender] = true;\n        totalTokenOutClaimed = totalTokenOutClaimed + tokenOutAmount_;\n\n        tokenOut.safeTransfer(msg.sender, tokenOutAmount_);\n\n        emit Claim(msg.sender, tokenOutAmount_);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `tokenIn`\n     * @param _tokenInAmount Amount of `tokenIn` to exchange\n     * @return tokenOutAmount_ Amount of `tokenOut` received\n     */\n    function getAmountOut(uint256 _tokenInAmount)\n        public\n        view\n        returns (uint256 tokenOutAmount_)\n    {\n        tokenOutAmount_ =\n            (_tokenInAmount * tokenOutPrice) /\n            tokenInNormalizationValue;\n    }\n\n    /**\n     * @notice Check how much `tokenIn` can still be taken in\n     * @return limitLeft_ Amount of `tokenIn` that can still be exchanged\n     */\n    function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {\n        if (totalTokenIn < tokenInLimit) {\n            limitLeft_ = tokenInLimit - totalTokenIn;\n        }\n    }\n\n    /**\n     * @notice Check if the sale has ended\n     * @return hasEnded_ True if the sale has ended\n     */\n    function saleEnded() public view returns (bool hasEnded_) {\n        hasEnded_ =\n            (block.timestamp >= saleStart + saleDuration) ||\n            (totalTokenIn >= tokenInLimit);\n    }\n\n    /// ====================================\n    /// ===== Permissioned: governance =====\n    /// ====================================\n\n    /**\n     * @notice Finalize the sale after sale duration. Can only be called by owner\n       @dev Ensure contract has enough `tokenOut` before calling\n     */\n    function finalize() external onlyRole(CONTRACT_GOVERNANCE_ROLE) {\n        require(!finalized, \"KnightingRound: already finalized\");\n        require(saleEnded(), \"KnightingRound: not finished\");\n        require(\n            tokenOut.balanceOf(address(this)) >= totalTokenOutBought,\n            \"KnightingRound: not enough balance\"\n        );\n\n        finalized = true;\n\n        emit Finalized();\n    }\n\n    /**\n     * @notice Update the sale start time. Can only be called by owner\n     * @param _saleStart New start time\n     */\n    function setSaleStart(uint256 _saleStart)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleStart = _saleStart;\n\n        emit SaleStartUpdated(_saleStart);\n    }\n\n    /**\n     * @notice Update sale duration. Can only be called by owner\n     * @param _saleDuration New duration\n     */\n    function setSaleDuration(uint256 _saleDuration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleDuration = _saleDuration;\n\n        emit SaleDurationUpdated(_saleDuration);\n    }\n\n    /**\n     * @notice Modify the tokenOut price in. Can only be called by owner\n     * @param _tokenOutPrice New tokenOut price\n     */\n    function setTokenOutPrice(uint256 _tokenOutPrice)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n\n        tokenOutPrice = _tokenOutPrice;\n\n        emit TokenOutPriceUpdated(_tokenOutPrice);\n    }\n\n    /**\n     * @notice Update the `tokenIn` receipient address. Can only be called by owner\n     * @param _saleRecipient New recipient address\n     */\n    function setSaleRecipient(address _saleRecipient)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    /// ============================\n    /// ===== Tech ops actions =====\n    /// ============================\n\n    /**\n     * @notice Update the guestlist address. Can only be called by owner\n     * @param _guestlist New guestlist address\n     */\n    function setGuestlist(address _guestlist)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        guestlist = IBadgerVipGuestlist(_guestlist);\n\n        emit GuestlistUpdated(_guestlist);\n    }\n\n    /**\n     * @notice Modify the max tokenIn that this contract can take. Can only be called by owner\n     * @param _tokenInLimit New max amountIn\n     */\n    function setTokenInLimit(uint256 _tokenInLimit)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        tokenInLimit = _tokenInLimit;\n\n        emit TokenInLimitUpdated(_tokenInLimit);\n    }\n\n    /// ================================\n    /// ===== Treasury Ops actions =====\n    /// ================================\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `tokenIn` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `tokenIn`. For `tokenOut`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token) external gacPausable nonReentrant onlyRole(TREASURY_OPERATIONS_ROLE) {\n        uint256 amount = ERC20Upgradeable(_token).balanceOf(address(this));\n\n        if (_token == address(tokenOut)) {\n            uint256 amountLeftToBeClaimed = totalTokenOutBought -\n                totalTokenOutClaimed;\n            amount = amount - amountLeftToBeClaimed;\n        }\n\n        require(amount > 0, \"nothing to sweep\");\n\n        emit Sweep(_token, amount);\n        ERC20Upgradeable(_token).safeTransfer(saleRecipient, amount);\n    }\n}"
    }
  ]
}