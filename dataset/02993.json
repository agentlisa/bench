{
  "Title": "M-16: Corruptible Upgradability Pattern",
  "Content": "# Issue M-16: Corruptible Upgradability Pattern \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/64 \n\n## Found by \nxiaoming90, supernova\n\n## Summary\n\nStorage of Boosted3TokenAuraVault and MetaStable2TokenAuraVault vaults might be corrupted during an upgrade.\n\n## Vulnerability Detail\n\nFollowing are the inheritance of the Boosted3TokenAuraVault and MetaStable2TokenAuraVault vaults.\n\nNote: The contracts highlighted in Orange mean that there are no gap slots defined. The contracts highlighted in Green mean that gap slots have been defined\n\n**Inheritance of the MetaStable2TokenAuraVault vault**\n\n\n\n```mermaid\ngraph BT;\n\tclassDef nogap fill:#f96;\n\tclassDef hasgap fill:#99cc00;\n    MetaStable2TokenAuraVault-->MetaStable2TokenVaultMixin:::nogap\n    MetaStable2TokenVaultMixin:::nogap-->TwoTokenPoolMixin:::nogap\n    MetaStable2TokenVaultMixin:::nogap-->BalancerOracleMixin:::nogap\n    TwoTokenPoolMixin:::nogap-->PoolMixin:::nogap\n    PoolMixin:::nogap-->AuraStakingMixin:::nogap\n    PoolMixin:::nogap-->BalancerStrategyBase;\n    BalancerStrategyBase:::hasgap-->BaseStrategyVault:::hasgap\n    BalancerStrategyBase:::hasgap-->UUPSUpgradeable\n```\n\n**Inheritance of the Boosted3TokenAuraVault vault**\n\n```mermaid\ngraph BT;\n\tclassDef nogap fill:#f96;\n\tclassDef hasgap fill:#99cc00;\n    Boosted3TokenAuraVault-->Boosted3TokenPoolMixin:::nogap\n    Boosted3TokenPoolMixin:::nogap-->PoolMixin:::nogap\n    PoolMixin:::nogap-->BalancerStrategyBase\n    PoolMixin:::nogap-->AuraStakingMixin:::nogap\n    BalancerStrategyBase:::hasgap-->BaseStrategyVault:::hasgap\n    BalancerStrategyBase:::hasgap-->UUPSUpgradeable\n```\n\nThe Boosted3TokenAuraVault and MetaStable2TokenAuraVault vaults are meant to be upgradeable. However, it inherits contracts that are not upgrade-safe. \n\nThe gap storage has been implemented on the `BaseStrategyVault` and `BalancerStrategyBase` contracts inherited by the Boosted3TokenAuraVault and MetaStable2TokenAuraVault vaults.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/BaseStrategyVault.sol#L14\n\n```solidity\nabstract contract BaseStrategyVault is Initializable, IStrategyVault {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n    ..SNIP..\n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n}\n```\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerStrategyBase.sol#L9\n\n```solidity\nabstract contract BalancerStrategyBase is BaseStrategyVault, UUPSUpgradeable {\n    /** Immutables */\n    uint32 internal immutable SETTLEMENT_PERIOD_IN_SECONDS;\n    ..SNIP..\n    // Storage gap for future potential upgrades\n    uint256[100] private __gap;\n}\n```\n\nHowever, no gap storage is implemented on the `Boosted3TokenPoolMixin`, `MetaStable2TokenVaultMixin`, `TwoTokenPoolMixin`, `PoolMixin`, `AuraStakingMixin` and `BalancerOracleMixin` contracts inherited by the Boosted3TokenAuraVault and MetaStable2TokenAuraVault vaults. \n\nThus, adding new storage variables to any of these inherited contracts can potentially overwrite the beginning of the storage layout of the child contract. causing critical misbehaviors in the system.\n\n## Impact\n\nStorage of Boosted3TokenAuraVault and MetaStable2TokenAuraVault vaults might be corrupted during upgrading, thus causing the vaults to be broken and assets to be stuck.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/BaseStrategyVault.sol#L14\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerStrategyBase.sol#L9\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider defining an appropriate storage gap in each upgradeable parent contract at the end of all the storage variable definitions as follows:\n\n```solidity\nuint256[50] __gap; // gap to reserve storage in the contract for future variable additions\n```\n\n#### Reference\n\nA similar issue was found in the past audit report:\n\n- https://blog.openzeppelin.com/notional-audit/ - [M02] Adding new variables to multi-level inherited upgradeable contracts may break storage layout\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000 \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/BaseStrategyVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {Token, TokenType} from \"../global/Types.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IStrategyVault} from \"../../interfaces/notional/IStrategyVault.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\nimport {nProxy} from \"../proxy/nProxy.sol\";\n\nabstract contract BaseStrategyVault is Initializable, IStrategyVault {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    /// @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n\n    // Borrowing Currency ID the vault is configured with\n    uint16 private _BORROW_CURRENCY_ID;\n    // True if the underlying is ETH\n    bool private _UNDERLYING_IS_ETH;\n    // Address of the underlying token\n    IERC20 private _UNDERLYING_TOKEN;\n    // NOTE: end of first storage slot here\n\n    // Name of the vault\n    string private _NAME;\n\n\n    /**************************************************************************/\n    /* Global Modifiers, Constructor and Initializer                          */\n    /**************************************************************************/\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL));\n        _;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == address(NOTIONAL.owner()));\n        _;\n    }\n    \n    /// @notice Set the NOTIONAL address on deployment\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_) initializer {\n        NOTIONAL = notional_;\n        TRADING_MODULE = tradingModule_;\n    }\n\n    /// @notice Override this method and revert if the contract should not receive ETH.\n    /// Upgradeable proxies must have this implemented on the proxy for transfer calls\n    /// succeed (use nProxy for this).\n    receive() external virtual payable {\n        // Allow ETH transfers to succeed\n    }\n\n    /// @notice All strategy vaults MUST implement 8 decimal precision\n    function decimals() public override view returns (uint8) {\n        return INTERNAL_TOKEN_DECIMALS;\n    }\n\n    function name() external override view returns (string memory) {\n        return _NAME;\n    }\n\n    function strategy() external virtual view returns (bytes4);\n\n    function _borrowCurrencyId() internal view returns (uint16) {\n        return _BORROW_CURRENCY_ID;\n    }\n\n    function _underlyingToken() internal view returns (IERC20) {\n        return _UNDERLYING_TOKEN;\n    }\n\n    function _isUnderlyingETH() internal view returns (bool) {\n        return _UNDERLYING_IS_ETH;\n    }\n\n    /// @notice Can only be called once during initialization\n    function __INIT_VAULT(\n        string memory name_,\n        uint16 borrowCurrencyId_\n    ) internal onlyInitializing {\n        _NAME = name_;\n        _BORROW_CURRENCY_ID = borrowCurrencyId_;\n\n        address underlyingAddress = _getNotionalUnderlyingToken(borrowCurrencyId_);\n        _UNDERLYING_TOKEN = IERC20(underlyingAddress);\n        _UNDERLYING_IS_ETH = underlyingAddress == address(0);\n    }\n\n    function _getNotionalUnderlyingToken(uint16 currencyId) internal view returns (address) {\n        (Token memory assetToken, Token memory underlyingToken) = NOTIONAL.getCurrency(currencyId);\n\n        return assetToken.tokenType == TokenType.NonMintable ?\n            assetToken.tokenAddress : underlyingToken.tokenAddress;\n    }\n\n    /// @notice Can be used to delegate call to the TradingModule's implementation in order to execute\n    /// a trade.\n    function _executeTrade(\n        uint16 dexId,\n        Trade memory trade\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        return trade._executeTrade(dexId, TRADING_MODULE);\n    }\n\n    /**************************************************************************/\n    /* Virtual Methods Requiring Implementation                               */\n    /**************************************************************************/\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity\n    ) public view virtual returns (int256 underlyingValue);\n    \n    // Vaults need to implement these two methods\n    function _depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 strategyTokensMinted);\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 tokensFromRedeem);\n\n    // This can be overridden if the vault borrows in a secondary currency, but reverts by default.\n    function _repaySecondaryBorrowCallback(\n        address token,  uint256 underlyingRequired, bytes calldata data\n    ) internal virtual returns (bytes memory returnData) {\n        revert();\n    }\n\n    /**************************************************************************/\n    /* Default External Method Implementations                                */\n    /**************************************************************************/\n    function depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) external payable onlyNotional returns (uint256 strategyTokensMinted) {\n        return _depositFromNotional(account, deposit, maturity, data);\n    }\n\n    function redeemFromNotional(\n        address account,\n        address receiver,\n        uint256 strategyTokens,\n        uint256 maturity,\n        uint256 underlyingToRepayDebt,\n        bytes calldata data\n    ) external onlyNotional returns (uint256 transferToReceiver) {\n        uint256 borrowedCurrencyAmount = _redeemFromNotional(account, strategyTokens, maturity, data);\n\n        uint256 transferToNotional;\n        if (account == address(this) || borrowedCurrencyAmount <= underlyingToRepayDebt) {\n            // It may be the case that insufficient tokens were redeemed to repay the debt. If this\n            // happens the Notional will attempt to recover the shortfall from the account directly.\n            // This can happen if an account wants to reduce their leverage by paying off debt but\n            // does not want to sell strategy tokens to do so.\n            // The other situation would be that the vault is calling redemption to deleverage or\n            // settle. In that case all tokens go back to Notional.\n            transferToNotional = borrowedCurrencyAmount;\n        } else {\n            transferToNotional = underlyingToRepayDebt;\n            unchecked { transferToReceiver = borrowedCurrencyAmount - underlyingToRepayDebt; }\n        }\n\n        if (_UNDERLYING_IS_ETH) {\n            if (transferToReceiver > 0) payable(receiver).transfer(transferToReceiver);\n            if (transferToNotional > 0) payable(address(NOTIONAL)).transfer(transferToNotional);\n        } else {\n            if (transferToReceiver > 0) _UNDERLYING_TOKEN.checkTransfer(receiver, transferToReceiver);\n            if (transferToNotional > 0) _UNDERLYING_TOKEN.checkTransfer(address(NOTIONAL), transferToNotional);\n        }\n    }\n\n    function repaySecondaryBorrowCallback(\n        address token, uint256 underlyingRequired, bytes calldata data\n    ) external onlyNotional returns (bytes memory returnData) {\n        return _repaySecondaryBorrowCallback(token, underlyingRequired, data);\n    }\n\n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/BalancerStrategyBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {BaseStrategyVault} from \"../BaseStrategyVault.sol\";\nimport {DeploymentParams} from \"./BalancerVaultTypes.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nabstract contract BalancerStrategyBase is BaseStrategyVault, UUPSUpgradeable {\n\n    /** Immutables */\n    uint32 internal immutable SETTLEMENT_PERIOD_IN_SECONDS;\n\n    constructor(NotionalProxy notional_, DeploymentParams memory params) \n        BaseStrategyVault(notional_, params.tradingModule)\n    {\n        SETTLEMENT_PERIOD_IN_SECONDS = params.settlementPeriodInSeconds;\n    }\n\n    function _revertInSettlementWindow(uint256 maturity) internal view {\n        if (maturity - SETTLEMENT_PERIOD_IN_SECONDS <= block.timestamp) {\n            revert();\n        }\n    }\n\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n    \n    // Storage gap for future potential upgrades\n    uint256[100] private __gap;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/BaseStrategyVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {Token, TokenType} from \"../global/Types.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IStrategyVault} from \"../../interfaces/notional/IStrategyVault.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\nimport {nProxy} from \"../proxy/nProxy.sol\";\n\nabstract contract BaseStrategyVault is Initializable, IStrategyVault {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    /// @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n\n    // Borrowing Currency ID the vault is configured with\n    uint16 private _BORROW_CURRENCY_ID;\n    // True if the underlying is ETH\n    bool private _UNDERLYING_IS_ETH;\n    // Address of the underlying token\n    IERC20 private _UNDERLYING_TOKEN;\n    // NOTE: end of first storage slot here\n\n    // Name of the vault\n    string private _NAME;\n\n\n    /**************************************************************************/\n    /* Global Modifiers, Constructor and Initializer                          */\n    /**************************************************************************/\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL));\n        _;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == address(NOTIONAL.owner()));\n        _;\n    }\n    \n    /// @notice Set the NOTIONAL address on deployment\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_) initializer {\n        NOTIONAL = notional_;\n        TRADING_MODULE = tradingModule_;\n    }\n\n    /// @notice Override this method and revert if the contract should not receive ETH.\n    /// Upgradeable proxies must have this implemented on the proxy for transfer calls\n    /// succeed (use nProxy for this).\n    receive() external virtual payable {\n        // Allow ETH transfers to succeed\n    }\n\n    /// @notice All strategy vaults MUST implement 8 decimal precision\n    function decimals() public override view returns (uint8) {\n        return INTERNAL_TOKEN_DECIMALS;\n    }\n\n    function name() external override view returns (string memory) {\n        return _NAME;\n    }\n\n    function strategy() external virtual view returns (bytes4);\n\n    function _borrowCurrencyId() internal view returns (uint16) {\n        return _BORROW_CURRENCY_ID;\n    }\n\n    function _underlyingToken() internal view returns (IERC20) {\n        return _UNDERLYING_TOKEN;\n    }\n\n    function _isUnderlyingETH() internal view returns (bool) {\n        return _UNDERLYING_IS_ETH;\n    }\n\n    /// @notice Can only be called once during initialization\n    function __INIT_VAULT(\n        string memory name_,\n        uint16 borrowCurrencyId_\n    ) internal onlyInitializing {\n        _NAME = name_;\n        _BORROW_CURRENCY_ID = borrowCurrencyId_;\n\n        address underlyingAddress = _getNotionalUnderlyingToken(borrowCurrencyId_);\n        _UNDERLYING_TOKEN = IERC20(underlyingAddress);\n        _UNDERLYING_IS_ETH = underlyingAddress == address(0);\n    }\n\n    function _getNotionalUnderlyingToken(uint16 currencyId) internal view returns (address) {\n        (Token memory assetToken, Token memory underlyingToken) = NOTIONAL.getCurrency(currencyId);\n\n        return assetToken.tokenType == TokenType.NonMintable ?\n            assetToken.tokenAddress : underlyingToken.tokenAddress;\n    }\n\n    /// @notice Can be used to delegate call to the TradingModule's implementation in order to execute\n    /// a trade.\n    function _executeTrade(\n        uint16 dexId,\n        Trade memory trade\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        return trade._executeTrade(dexId, TRADING_MODULE);\n    }\n\n    /**************************************************************************/\n    /* Virtual Methods Requiring Implementation                               */\n    /**************************************************************************/\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity\n    ) public view virtual returns (int256 underlyingValue);\n    \n    // Vaults need to implement these two methods\n    function _depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 strategyTokensMinted);\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 tokensFromRedeem);\n\n    // This can be overridden if the vault borrows in a secondary currency, but reverts by default.\n    function _repaySecondaryBorrowCallback(\n        address token,  uint256 underlyingRequired, bytes calldata data\n    ) internal virtual returns (bytes memory returnData) {\n        revert();\n    }\n\n    /**************************************************************************/\n    /* Default External Method Implementations                                */\n    /**************************************************************************/\n    function depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) external payable onlyNotional returns (uint256 strategyTokensMinted) {\n        return _depositFromNotional(account, deposit, maturity, data);\n    }\n\n    function redeemFromNotional(\n        address account,\n        address receiver,\n        uint256 strategyTokens,\n        uint256 maturity,\n        uint256 underlyingToRepayDebt,\n        bytes calldata data\n    ) external onlyNotional returns (uint256 transferToReceiver) {\n        uint256 borrowedCurrencyAmount = _redeemFromNotional(account, strategyTokens, maturity, data);\n\n        uint256 transferToNotional;\n        if (account == address(this) || borrowedCurrencyAmount <= underlyingToRepayDebt) {\n            // It may be the case that insufficient tokens were redeemed to repay the debt. If this\n            // happens the Notional will attempt to recover the shortfall from the account directly.\n            // This can happen if an account wants to reduce their leverage by paying off debt but\n            // does not want to sell strategy tokens to do so.\n            // The other situation would be that the vault is calling redemption to deleverage or\n            // settle. In that case all tokens go back to Notional.\n            transferToNotional = borrowedCurrencyAmount;\n        } else {\n            transferToNotional = underlyingToRepayDebt;\n            unchecked { transferToReceiver = borrowedCurrencyAmount - underlyingToRepayDebt; }\n        }\n\n        if (_UNDERLYING_IS_ETH) {\n            if (transferToReceiver > 0) payable(receiver).transfer(transferToReceiver);\n            if (transferToNotional > 0) payable(address(NOTIONAL)).transfer(transferToNotional);\n        } else {\n            if (transferToReceiver > 0) _UNDERLYING_TOKEN.checkTransfer(receiver, transferToReceiver);\n            if (transferToNotional > 0) _UNDERLYING_TOKEN.checkTransfer(address(NOTIONAL), transferToNotional);\n        }\n    }\n\n    function repaySecondaryBorrowCallback(\n        address token, uint256 underlyingRequired, bytes calldata data\n    ) external onlyNotional returns (bytes memory returnData) {\n        return _repaySecondaryBorrowCallback(token, underlyingRequired, data);\n    }\n\n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/BalancerStrategyBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {BaseStrategyVault} from \"../BaseStrategyVault.sol\";\nimport {DeploymentParams} from \"./BalancerVaultTypes.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nabstract contract BalancerStrategyBase is BaseStrategyVault, UUPSUpgradeable {\n\n    /** Immutables */\n    uint32 internal immutable SETTLEMENT_PERIOD_IN_SECONDS;\n\n    constructor(NotionalProxy notional_, DeploymentParams memory params) \n        BaseStrategyVault(notional_, params.tradingModule)\n    {\n        SETTLEMENT_PERIOD_IN_SECONDS = params.settlementPeriodInSeconds;\n    }\n\n    function _revertInSettlementWindow(uint256 maturity) internal view {\n        if (maturity - SETTLEMENT_PERIOD_IN_SECONDS <= block.timestamp) {\n            revert();\n        }\n    }\n\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n    \n    // Storage gap for future potential upgrades\n    uint256[100] private __gap;\n}"
    }
  ]
}