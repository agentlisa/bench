{
  "Title": "Ability to Generate Valid Exclusion Proofs of Keys Which Are Present in the Trie",
  "Content": "The MerkleDB allows for the creation of inclusion and exclusion proofs. An inclusion proof verifies the presence of a particular key-value pair in the trie under a specified root, whereas an exclusion proof confirms the absence of a particular key-value pair from the trie under the same root. Both proofs are constructed in a similar manner utilizing the [`Proof` struct](https://github.com/ava-labs/avalanchego/blob/73c4c0ff9817cb13fdb8b205939596af0c416f1f/x/merkledb/proof.go#L120-L132). For exclusion proofs, this structure's `Key` field is assigned the key intended to be demonstrated as absent from the trie, and the `Value` field is left blank. The `Path` represents a sequence of nodes leading from the trie's root to (the parent of) the position where the node would have been located if it were part of the trie.\n\n\nDuring [verification](https://github.com/ava-labs/avalanchego/blob/73c4c0ff9817cb13fdb8b205939596af0c416f1f/x/merkledb/proof.go#L136-L192) of the exclusion proof, the verifier constructs an empty trie and [populates it with all the nodes in the `Path`](https://github.com/ava-labs/avalanchego/blob/73c4c0ff9817cb13fdb8b205939596af0c416f1f/x/merkledb/proof.go#L179). If the root ID of this constructed trie matches the expected root ID, the verifier can be sure that all the nodes in the `Path` are correct, confirming the absence of the specified key-value pair from the trie.\n\n\nHowever, a malicious prover could forge a valid exclusion proof for a key-value pair that actually exists in the trie. This is done by removing the `Value` from the proof and reducing the length of the proof path by not including the parent of the node where the key-value pair would have been located. Given that the ID represents the [hash of a node](https://github.com/ava-labs/avalanchego/blob/73c4c0ff9817cb13fdb8b205939596af0c416f1f/x/merkledb/node.go#L71-L76), and each node [keeps the IDs of its children](https://github.com/ava-labs/avalanchego/blob/73c4c0ff9817cb13fdb8b205939596af0c416f1f/x/merkledb/proof.go#L60), the proof path does not actually have to reach this node as long as one of its parents is included in the proof path. Because of this, the trie created by the verifier will be identical to the upper half of the original trie and yield an identical root ID, and mistakenly pass the verification process.\n\n\nConsider reviewing the proof verification mechanism to prevent the acceptance of falsified exclusion proofs for existing key-value pairs.\n\n\n***Update:** Resolved in [pull request #2789](https://github.com/ava-labs/avalanchego/pull/2789).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "x/merkledb/proof.go",
      "content": "// Copyright (C) 2019-2024, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\npackage merkledb\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\n\t\"github.com/ava-labs/avalanchego/database\"\n\t\"github.com/ava-labs/avalanchego/database/memdb\"\n\t\"github.com/ava-labs/avalanchego/ids\"\n\t\"github.com/ava-labs/avalanchego/trace\"\n\t\"github.com/ava-labs/avalanchego/utils/hashing\"\n\t\"github.com/ava-labs/avalanchego/utils/maybe\"\n\n\tpb \"github.com/ava-labs/avalanchego/proto/pb/sync\"\n)\n\nconst verificationCacheSize = math.MaxUint16\n\nvar (\n\tErrInvalidProof                = errors.New(\"proof obtained an invalid root ID\")\n\tErrInvalidMaxLength            = errors.New(\"expected max length to be > 0\")\n\tErrNonIncreasingValues         = errors.New(\"keys sent are not in increasing order\")\n\tErrStateFromOutsideOfRange     = errors.New(\"state key falls outside of the start->end range\")\n\tErrNonIncreasingProofNodes     = errors.New(\"each proof node key must be a strict prefix of the next\")\n\tErrExtraProofNodes             = errors.New(\"extra proof nodes in path\")\n\tErrDataInMissingRootProof      = errors.New(\"there should be no state or deleted keys in a change proof that had a missing root\")\n\tErrEmptyProof                  = errors.New(\"proof is empty\")\n\tErrNoMerkleProof               = errors.New(\"empty key response must include merkle proof\")\n\tErrShouldJustBeRoot            = errors.New(\"end proof should only contain root\")\n\tErrNoStartProof                = errors.New(\"no start proof\")\n\tErrNoEndProof                  = errors.New(\"no end proof\")\n\tErrProofNodeNotForKey          = errors.New(\"the provided node has a key that is not a prefix of the specified key\")\n\tErrProofValueDoesntMatch       = errors.New(\"the provided value does not match the proof node for the provided key's value\")\n\tErrProofNodeHasUnincludedValue = errors.New(\"the provided proof has a value for a key within the range that is not present in the provided key/values\")\n\tErrInvalidMaybe                = errors.New(\"maybe is nothing but has value\")\n\tErrNilProofNode                = errors.New(\"proof node is nil\")\n\tErrNilValueOrHash              = errors.New(\"proof node's valueOrHash field is nil\")\n\tErrNilKey                      = errors.New(\"key is nil\")\n\tErrInvalidKeyLength            = errors.New(\"key length doesn't match bytes length, check specified branchFactor\")\n\tErrNilRangeProof               = errors.New(\"range proof is nil\")\n\tErrNilChangeProof              = errors.New(\"change proof is nil\")\n\tErrNilMaybeBytes               = errors.New(\"maybe bytes is nil\")\n\tErrNilProof                    = errors.New(\"proof is nil\")\n\tErrNilValue                    = errors.New(\"value is nil\")\n\tErrUnexpectedEndProof          = errors.New(\"end proof should be empty\")\n)\n\ntype ProofNode struct {\n\tKey Key\n\t// Nothing if this is an intermediate node.\n\t// The value in this node if its length < [HashLen].\n\t// The hash of the value in this node otherwise.\n\tValueOrHash maybe.Maybe[[]byte]\n\tChildren    map[byte]ids.ID\n}\n\n// ToProto converts the ProofNode into the protobuf version of a proof node\n// Assumes [node.Key.Key.length] <= math.MaxUint64.\nfunc (node *ProofNode) ToProto() *pb.ProofNode {\n\tpbNode := &pb.ProofNode{\n\t\tKey: &pb.Key{\n\t\t\tLength: uint64(node.Key.length),\n\t\t\tValue:  node.Key.Bytes(),\n\t\t},\n\t\tValueOrHash: &pb.MaybeBytes{\n\t\t\tValue:     node.ValueOrHash.Value(),\n\t\t\tIsNothing: node.ValueOrHash.IsNothing(),\n\t\t},\n\t\tChildren: make(map[uint32][]byte, len(node.Children)),\n\t}\n\n\tfor childIndex, childID := range node.Children {\n\t\tchildID := childID\n\t\tpbNode.Children[uint32(childIndex)] = childID[:]\n\t}\n\n\treturn pbNode\n}\n\nfunc (node *ProofNode) UnmarshalProto(pbNode *pb.ProofNode) error {\n\tswitch {\n\tcase pbNode == nil:\n\t\treturn ErrNilProofNode\n\tcase pbNode.ValueOrHash == nil:\n\t\treturn ErrNilValueOrHash\n\tcase pbNode.ValueOrHash.IsNothing && len(pbNode.ValueOrHash.Value) != 0:\n\t\treturn ErrInvalidMaybe\n\tcase pbNode.Key == nil:\n\t\treturn ErrNilKey\n\tcase len(pbNode.Key.Value) != bytesNeeded(int(pbNode.Key.Length)):\n\t\treturn ErrInvalidKeyLength\n\t}\n\tnode.Key = ToKey(pbNode.Key.Value).Take(int(pbNode.Key.Length))\n\tnode.Children = make(map[byte]ids.ID, len(pbNode.Children))\n\tfor childIndex, childIDBytes := range pbNode.Children {\n\t\tif childIndex > math.MaxUint8 {\n\t\t\treturn errChildIndexTooLarge\n\t\t}\n\t\tchildID, err := ids.ToID(childIDBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnode.Children[byte(childIndex)] = childID\n\t}\n\n\tif !pbNode.ValueOrHash.IsNothing {\n\t\tnode.ValueOrHash = maybe.Some(pbNode.ValueOrHash.Value)\n\t}\n\n\treturn nil\n}\n\n// Proof represents an inclusion/exclusion proof of a key.\ntype Proof struct {\n\t// Nodes in the proof path from root --> target key\n\t// (or node that would be where key is if it doesn't exist).\n\t// Always contains at least the root.\n\tPath []ProofNode\n\t// This is a proof that [key] exists/doesn't exist.\n\tKey Key\n\n\t// Nothing if [Key] isn't in the trie.\n\t// Otherwise, the value corresponding to [Key].\n\tValue maybe.Maybe[[]byte]\n}\n\n// Verify returns nil if the trie given in [proof] has root [expectedRootID].\n// That is, this is a valid proof that [proof.Key] exists/doesn't exist\n// in the trie with root [expectedRootID].\nfunc (proof *Proof) Verify(ctx context.Context, expectedRootID ids.ID, tokenSize int) error {\n\t// Make sure the proof is well-formed.\n\tif len(proof.Path) == 0 {\n\t\treturn ErrEmptyProof\n\t}\n\n\tif err := verifyProofPath(proof.Path, maybe.Some(proof.Key)); err != nil {\n\t\treturn err\n\t}\n\n\t// Confirm that the last proof node's value matches the claimed proof value\n\tlastNode := proof.Path[len(proof.Path)-1]\n\n\t// If the last proof node's key is [proof.Key] (i.e. this is an inclusion proof)\n\t// then the value of the last proof node must match [proof.Value].\n\t// Note partial byte length keys can never match the [proof.Key] since it's bytes,\n\t// and thus has a whole number of bytes\n\tif !lastNode.Key.hasPartialByte() &&\n\t\tproof.Key == lastNode.Key &&\n\t\t!valueOrHashMatches(proof.Value, lastNode.ValueOrHash) {\n\t\treturn ErrProofValueDoesntMatch\n\t}\n\n\t// If the last proof node has a length not evenly divisible into bytes or a different key than [proof.Key]\n\t// then this is an exclusion proof and should prove that [proof.Key] isn't in the trie.\n\t// Note length not evenly divisible into bytes can never match the [proof.Key] since it's bytes,\n\t// and thus an exact number of bytes.\n\tif (lastNode.Key.hasPartialByte() || proof.Key != lastNode.Key) &&\n\t\tproof.Value.HasValue() {\n\t\treturn ErrProofValueDoesntMatch\n\t}\n\n\t// Don't bother locking [view] -- nobody else has a reference to it.\n\tview, err := getStandaloneView(ctx, nil, tokenSize)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Insert all proof nodes.\n\t// [provenKey] is the key that we are proving exists, or the key\n\t// that is the next key along the node path, proving that [proof.Key] doesn't exist in the trie.\n\tprovenKey := maybe.Some(proof.Path[len(proof.Path)-1].Key)\n\n\tif err = addPathInfo(view, proof.Path, provenKey, provenKey); err != nil {\n\t\treturn err\n\t}\n\n\tgotRootID, err := view.GetMerkleRoot(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif expectedRootID != gotRootID {\n\t\treturn fmt.Errorf(\"%w:[%s], expected:[%s]\", ErrInvalidProof, gotRootID, expectedRootID)\n\t}\n\treturn nil\n}\n\nfunc (proof *Proof) ToProto() *pb.Proof {\n\tvalue := &pb.MaybeBytes{\n\t\tValue:     proof.Value.Value(),\n\t\tIsNothing: proof.Value.IsNothing(),\n\t}\n\n\tpbProof := &pb.Proof{\n\t\tKey:   proof.Key.Bytes(),\n\t\tValue: value,\n\t}\n\n\tpbProof.Proof = make([]*pb.ProofNode, len(proof.Path))\n\tfor i, node := range proof.Path {\n\t\tpbProof.Proof[i] = node.ToProto()\n\t}\n\n\treturn pbProof\n}\n\nfunc (proof *Proof) UnmarshalProto(pbProof *pb.Proof) error {\n\tswitch {\n\tcase pbProof == nil:\n\t\treturn ErrNilProof\n\tcase pbProof.Value == nil:\n\t\treturn ErrNilValue\n\tcase pbProof.Value.IsNothing && len(pbProof.Value.Value) != 0:\n\t\treturn ErrInvalidMaybe\n\t}\n\n\tproof.Key = ToKey(pbProof.Key)\n\n\tif !pbProof.Value.IsNothing {\n\t\tproof.Value = maybe.Some(pbProof.Value.Value)\n\t}\n\n\tproof.Path = make([]ProofNode, len(pbProof.Proof))\n\tfor i, pbNode := range pbProof.Proof {\n\t\tif err := proof.Path[i].UnmarshalProto(pbNode); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype KeyValue struct {\n\tKey   []byte\n\tValue []byte\n}\n\n// RangeProof is a proof that a given set of key-value pairs are in a trie.\ntype RangeProof struct {\n\t// Invariant: At least one of [StartProof], [EndProof], [KeyValues] is non-empty.\n\n\t// A proof that the smallest key in the requested range does/doesn't exist.\n\t// Note that this may not be an entire proof -- nodes are omitted if\n\t// they are also in [EndProof].\n\tStartProof []ProofNode\n\n\t// If no upper range bound was given and [KeyValues] is empty, this is empty.\n\t//\n\t// If no upper range bound was given and [KeyValues] is non-empty, this is\n\t// a proof for the largest key in [KeyValues].\n\t//\n\t// Otherwise this is a proof for the upper range bound.\n\tEndProof []ProofNode\n\n\t// This proof proves that the key-value pairs in [KeyValues] are in the trie.\n\t// Sorted by increasing key.\n\tKeyValues []KeyValue\n}\n\n// Verify returns nil iff all the following hold:\n//   - The invariants of RangeProof hold.\n//   - [start] <= [end].\n//   - [proof] proves the key-value pairs in [proof.KeyValues] are in the trie\n//     whose root is [expectedRootID].\n//\n// All keys in [proof.KeyValues] are in the range [start, end].\n//\n//\tIf [start] is Nothing, all keys are considered > [start].\n//\tIf [end] is Nothing, all keys are considered < [end].\nfunc (proof *RangeProof) Verify(\n\tctx context.Context,\n\tstart maybe.Maybe[[]byte],\n\tend maybe.Maybe[[]byte],\n\texpectedRootID ids.ID,\n\ttokenSize int,\n) error {\n\tswitch {\n\tcase start.HasValue() && end.HasValue() && bytes.Compare(start.Value(), end.Value()) > 0:\n\t\treturn ErrStartAfterEnd\n\tcase len(proof.KeyValues) == 0 && len(proof.StartProof) == 0 && len(proof.EndProof) == 0:\n\t\treturn ErrEmptyProof\n\tcase end.IsNothing() && len(proof.KeyValues) == 0 && len(proof.EndProof) != 0:\n\t\treturn ErrUnexpectedEndProof\n\tcase len(proof.EndProof) == 0 && (end.HasValue() || len(proof.KeyValues) > 0):\n\t\treturn ErrNoEndProof\n\t}\n\n\t// Make sure the key-value pairs are sorted and in [start, end].\n\tif err := verifyKeyValues(proof.KeyValues, start, end); err != nil {\n\t\treturn err\n\t}\n\n\t// [proof] allegedly provides and proves all key-value\n\t// pairs in [smallestProvenKey, largestProvenKey].\n\t// If [smallestProvenKey] is Nothing, [proof] should\n\t// provide and prove all keys < [largestProvenKey].\n\t// If [largestProvenKey] is Nothing, [proof] should\n\t// provide and prove all keys > [smallestProvenKey].\n\t// If both are Nothing, [proof] should prove the entire trie.\n\tsmallestProvenKey := maybe.Bind(start, ToKey)\n\n\tlargestProvenKey := maybe.Bind(end, ToKey)\n\n\tif len(proof.KeyValues) > 0 {\n\t\t// If [proof] has key-value pairs, we should insert children\n\t\t// greater than [largestProvenKey] to ancestors of the node containing\n\t\t// [largestProvenKey] so that we get the expected root ID.\n\t\tlargestProvenKey = maybe.Some(ToKey(proof.KeyValues[len(proof.KeyValues)-1].Key))\n\t}\n\n\t// The key-value pairs (allegedly) proven by [proof].\n\tkeyValues := make(map[Key][]byte, len(proof.KeyValues))\n\tfor _, keyValue := range proof.KeyValues {\n\t\tkeyValues[ToKey(keyValue.Key)] = keyValue.Value\n\t}\n\n\t// Ensure that the start proof is valid and contains values that\n\t// match the key/values that were sent.\n\tif err := verifyProofPath(proof.StartProof, smallestProvenKey); err != nil {\n\t\treturn err\n\t}\n\tif err := verifyAllRangeProofKeyValuesPresent(\n\t\tproof.StartProof,\n\t\tsmallestProvenKey,\n\t\tlargestProvenKey,\n\t\tkeyValues,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\t// Ensure that the end proof is valid and contains values that\n\t// match the key/values that were sent.\n\tif err := verifyProofPath(proof.EndProof, largestProvenKey); err != nil {\n\t\treturn err\n\t}\n\tif err := verifyAllRangeProofKeyValuesPresent(\n\t\tproof.EndProof,\n\t\tsmallestProvenKey,\n\t\tlargestProvenKey,\n\t\tkeyValues,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\t// Insert all key-value pairs into the trie.\n\tops := make([]database.BatchOp, len(proof.KeyValues))\n\tfor i, kv := range proof.KeyValues {\n\t\tops[i] = database.BatchOp{\n\t\t\tKey:   kv.Key,\n\t\t\tValue: kv.Value,\n\t\t}\n\t}\n\n\t// Don't need to lock [view] because nobody else has a reference to it.\n\tview, err := getStandaloneView(ctx, ops, tokenSize)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// For all the nodes along the edges of the proof, insert children\n\t// < [smallestProvenKey] and > [largestProvenKey]\n\t// into the trie so that we get the expected root ID (if this proof is valid).\n\t// By inserting all children < [smallestProvenKey], we prove that there are no keys\n\t// > [smallestProvenKey] but less than the first key given.\n\t// That is, the peer who gave us this proof is not omitting nodes.\n\tif err := addPathInfo(\n\t\tview,\n\t\tproof.StartProof,\n\t\tsmallestProvenKey,\n\t\tlargestProvenKey,\n\t); err != nil {\n\t\treturn err\n\t}\n\tif err := addPathInfo(\n\t\tview,\n\t\tproof.EndProof,\n\t\tsmallestProvenKey,\n\t\tlargestProvenKey,\n\t); err != nil {\n\t\treturn err\n\t}\n\n\tcalculatedRoot, err := view.GetMerkleRoot(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif expectedRootID != calculatedRoot {\n\t\treturn fmt.Errorf(\"%w:[%s], expected:[%s]\", ErrInvalidProof, calculatedRoot, expectedRootID)\n\t}\n\treturn nil\n}\n\nfunc (proof *RangeProof) ToProto() *pb.RangeProof {\n\tstartProof := make([]*pb.ProofNode, len(proof.StartProof))\n\tfor i, node := range proof.StartProof {\n\t\tstartProof[i] = node.ToProto()\n\t}\n\n\tendProof := make([]*pb.ProofNode, len(proof.EndProof))\n\tfor i, node := range proof.EndProof {\n\t\tendProof[i] = node.ToProto()\n\t}\n\n\tkeyValues := make([]*pb.KeyValue, len(proof.KeyValues))\n\tfor i, kv := range proof.KeyValues {\n\t\tkeyValues[i] = &pb.KeyValue{\n\t\t\tKey:   kv.Key,\n\t\t\tValue: kv.Value,\n\t\t}\n\t}\n\n\treturn &pb.RangeProof{\n\t\tStartProof: startProof,\n\t\tEndProof:   endProof,\n\t\tKeyValues:  keyValues,\n\t}\n}\n\nfunc (proof *RangeProof) UnmarshalProto(pbProof *pb.RangeProof) error {\n\tif pbProof == nil {\n\t\treturn ErrNilRangeProof\n\t}\n\n\tproof.StartProof = make([]ProofNode, len(pbProof.StartProof))\n\tfor i, protoNode := range pbProof.StartProof {\n\t\tif err := proof.StartProof[i].UnmarshalProto(protoNode); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tproof.EndProof = make([]ProofNode, len(pbProof.EndProof))\n\tfor i, protoNode := range pbProof.EndProof {\n\t\tif err := proof.EndProof[i].UnmarshalProto(protoNode); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tproof.KeyValues = make([]KeyValue, len(pbProof.KeyValues))\n\tfor i, kv := range pbProof.KeyValues {\n\t\tproof.KeyValues[i] = KeyValue{\n\t\t\tKey:   kv.Key,\n\t\t\tValue: kv.Value,\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Verify that all non-intermediate nodes in [proof] which have keys\n// in [[start], [end]] have the value given for that key in [keysValues].\nfunc verifyAllRangeProofKeyValuesPresent(proof []ProofNode, start maybe.Maybe[Key], end maybe.Maybe[Key], keysValues map[Key][]byte) error {\n\tfor i := 0; i < len(proof); i++ {\n\t\tvar (\n\t\t\tnode    = proof[i]\n\t\t\tnodeKey = node.Key\n\t\t)\n\n\t\t// Skip keys that cannot have a value (enforced by [verifyProofPath]).\n\t\tif !nodeKey.hasPartialByte() && (start.IsNothing() || !nodeKey.Less(start.Value())) && (end.IsNothing() || !nodeKey.Greater(end.Value())) {\n\t\t\tvalue, ok := keysValues[nodeKey]\n\t\t\tif !ok && node.ValueOrHash.HasValue() {\n\t\t\t\t// We didn't get a key-value pair for this key, but the proof node has a value.\n\t\t\t\treturn ErrProofNodeHasUnincludedValue\n\t\t\t}\n\t\t\tif ok && !valueOrHashMatches(maybe.Some(value), node.ValueOrHash) {\n\t\t\t\t// We got a key-value pair for this key, but the value in the proof\n\t\t\t\t// node doesn't match the value we got for this key.\n\t\t\t\treturn ErrProofValueDoesntMatch\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\ntype KeyChange struct {\n\tKey   []byte\n\tValue maybe.Maybe[[]byte]\n}\n\n// ChangeProof proves that a set of key-value changes occurred\n// between two trie roots, where each key-value pair's key is\n// between some lower and upper bound (inclusive).\ntype ChangeProof struct {\n\t// Invariant: At least one of [StartProof], [EndProof], or\n\t// [KeyChanges] is non-empty.\n\n\t// A proof that the smallest key in the requested range does/doesn't\n\t// exist in the trie with the requested start root.\n\t// Empty if no lower bound on the requested range was given.\n\t// Note that this may not be an entire proof -- nodes are omitted if\n\t// they are also in [EndProof].\n\tStartProof []ProofNode\n\n\t// If [KeyChanges] is non-empty, this is a proof of the largest key\n\t// in [KeyChanges].\n\t//\n\t// If [KeyChanges] is empty and an upper range bound was given,\n\t// this is a proof of the upper range bound.\n\t//\n\t// If [KeyChanges] is empty and no upper range bound was given,\n\t// this is empty.\n\tEndProof []ProofNode\n\n\t// A subset of key-values that were added, removed, or had their values\n\t// modified between the requested start root (exclusive) and the requested\n\t// end root (inclusive).\n\t// Each key is in the requested range (inclusive).\n\t// The first key-value is the first key-value at/after the range start.\n\t// The key-value pairs are consecutive. That is, if keys k1 and k2 are\n\t// in [KeyChanges] then there is no k3 that was modified between the start and\n\t// end roots such that k1 < k3 < k2.\n\t// This is a subset of the requested key-value range, rather than the entire\n\t// range, because otherwise the proof may be too large.\n\t// Sorted by increasing key and with no duplicate keys.\n\t//\n\t// Example: Suppose that between the start root and the end root, the following\n\t// key-value pairs were added, removed, or modified:\n\t//\n\t// [kv1, kv2, kv3, kv4, kv5]\n\t// where start <= kv1 < ... < kv5 <= end.\n\t//\n\t// The following are possible values of [KeyChanges]:\n\t//\n\t// []\n\t// [kv1]\n\t// [kv1, kv2]\n\t// [kv1, kv2, kv3]\n\t// [kv1, kv2, kv3, kv4]\n\t// [kv1, kv2, kv3, kv4, kv5]\n\t//\n\t// The following values of [KeyChanges] are always invalid, for example:\n\t//\n\t// [kv2] (Doesn't include kv1, the first key-value at/after the range start)\n\t// [kv1, kv3] (Doesn't include kv2, the key-value between kv1 and kv3)\n\t// [kv1, kv3, kv2] (Not sorted by increasing key)\n\t// [kv1, kv1] (Duplicate key-value pairs)\n\t// [kv0, kv1] (For some kv1 < start)\n\t// [kv1, kv2, kv3, kv4, kv5, kv6] (For some kv6 > end)\n\tKeyChanges []KeyChange\n}\n\nfunc (proof *ChangeProof) ToProto() *pb.ChangeProof {\n\tstartProof := make([]*pb.ProofNode, len(proof.StartProof))\n\tfor i, node := range proof.StartProof {\n\t\tstartProof[i] = node.ToProto()\n\t}\n\n\tendProof := make([]*pb.ProofNode, len(proof.EndProof))\n\tfor i, node := range proof.EndProof {\n\t\tendProof[i] = node.ToProto()\n\t}\n\n\tkeyChanges := make([]*pb.KeyChange, len(proof.KeyChanges))\n\tfor i, kv := range proof.KeyChanges {\n\t\tkeyChanges[i] = &pb.KeyChange{\n\t\t\tKey: kv.Key,\n\t\t\tValue: &pb.MaybeBytes{\n\t\t\t\tValue:     kv.Value.Value(),\n\t\t\t\tIsNothing: kv.Value.IsNothing(),\n\t\t\t},\n\t\t}\n\t}\n\n\treturn &pb.ChangeProof{\n\t\tStartProof: startProof,\n\t\tEndProof:   endProof,\n\t\tKeyChanges: keyChanges,\n\t}\n}\n\nfunc (proof *ChangeProof) UnmarshalProto(pbProof *pb.ChangeProof) error {\n\tif pbProof == nil {\n\t\treturn ErrNilChangeProof\n\t}\n\n\tproof.StartProof = make([]ProofNode, len(pbProof.StartProof))\n\tfor i, protoNode := range pbProof.StartProof {\n\t\tif err := proof.StartProof[i].UnmarshalProto(protoNode); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tproof.EndProof = make([]ProofNode, len(pbProof.EndProof))\n\tfor i, protoNode := range pbProof.EndProof {\n\t\tif err := proof.EndProof[i].UnmarshalProto(protoNode); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tproof.KeyChanges = make([]KeyChange, len(pbProof.KeyChanges))\n\tfor i, kv := range pbProof.KeyChanges {\n\t\tif kv.Value == nil {\n\t\t\treturn ErrNilMaybeBytes\n\t\t}\n\n\t\tif kv.Value.IsNothing && len(kv.Value.Value) != 0 {\n\t\t\treturn ErrInvalidMaybe\n\t\t}\n\n\t\tvalue := maybe.Nothing[[]byte]()\n\t\tif !kv.Value.IsNothing {\n\t\t\tvalue = maybe.Some(kv.Value.Value)\n\t\t}\n\t\tproof.KeyChanges[i] = KeyChange{\n\t\t\tKey:   kv.Key,\n\t\t\tValue: value,\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Verifies that all values present in the [proof]:\n// - Are nothing when deleted, not in the db, or the node has key partial byte length\n// - if the node's key is within the key range, that has a value that matches the value passed in the change list or in the db\nfunc verifyAllChangeProofKeyValuesPresent(\n\tctx context.Context,\n\tdb MerkleDB,\n\tproof []ProofNode,\n\tstart maybe.Maybe[Key],\n\tend maybe.Maybe[Key],\n\tkeysValues map[Key]maybe.Maybe[[]byte],\n) error {\n\tfor i := 0; i < len(proof); i++ {\n\t\tvar (\n\t\t\tnode    = proof[i]\n\t\t\tnodeKey = node.Key\n\t\t)\n\n\t\t// Check the value of any node with a key that is within the range.\n\t\t// Skip keys that cannot have a value (enforced by [verifyProofPath]).\n\t\tif !nodeKey.hasPartialByte() && (start.IsNothing() || !nodeKey.Less(start.Value())) && (end.IsNothing() || !nodeKey.Greater(end.Value())) {\n\t\t\tvalue, ok := keysValues[nodeKey]\n\t\t\tif !ok {\n\t\t\t\t// This value isn't in the list of key-value pairs we got.\n\t\t\t\tdbValue, err := db.GetValue(ctx, nodeKey.Bytes())\n\t\t\t\tif err != nil {\n\t\t\t\t\tif !errors.Is(err, database.ErrNotFound) {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\t// This key isn't in the database so proof node should have Nothing.\n\t\t\t\t\tvalue = maybe.Nothing[[]byte]()\n\t\t\t\t} else {\n\t\t\t\t\t// This key is in the database so proof node should have matching value.\n\t\t\t\t\tvalue = maybe.Some(dbValue)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !valueOrHashMatches(value, node.ValueOrHash) {\n\t\t\t\treturn ErrProofValueDoesntMatch\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (proof *ChangeProof) Empty() bool {\n\treturn len(proof.KeyChanges) == 0 &&\n\t\tlen(proof.StartProof) == 0 && len(proof.EndProof) == 0\n}\n\n// ChangeOrRangeProof has exactly one of [ChangeProof] or [RangeProof] is non-nil.\ntype ChangeOrRangeProof struct {\n\tChangeProof *ChangeProof\n\tRangeProof  *RangeProof\n}\n\n// Returns nil iff both hold:\n// 1. [kvs] is sorted by key in increasing order.\n// 2. All keys in [kvs] are in the range [start, end].\n// If [start] is Nothing, there is no lower bound on acceptable keys.\n// If [end] is Nothing, there is no upper bound on acceptable keys.\n// If [kvs] is empty, returns nil.\nfunc verifyKeyChanges(kvs []KeyChange, start maybe.Maybe[[]byte], end maybe.Maybe[[]byte]) error {\n\tif len(kvs) == 0 {\n\t\treturn nil\n\t}\n\n\t// ensure that the keys are in increasing order\n\tfor i := 0; i < len(kvs)-1; i++ {\n\t\tif bytes.Compare(kvs[i].Key, kvs[i+1].Key) >= 0 {\n\t\t\treturn ErrNonIncreasingValues\n\t\t}\n\t}\n\n\t// ensure that the keys are within the range [start, end]\n\tif (start.HasValue() && bytes.Compare(kvs[0].Key, start.Value()) < 0) ||\n\t\t(end.HasValue() && bytes.Compare(kvs[len(kvs)-1].Key, end.Value()) > 0) {\n\t\treturn ErrStateFromOutsideOfRange\n\t}\n\n\treturn nil\n}\n\n// Returns nil iff both hold:\n// 1. [kvs] is sorted by key in increasing order.\n// 2. All keys in [kvs] are in the range [start, end].\n// If [start] is nil, there is no lower bound on acceptable keys.\n// If [end] is nothing, there is no upper bound on acceptable keys.\n// If [kvs] is empty, returns nil.\nfunc verifyKeyValues(kvs []KeyValue, start maybe.Maybe[[]byte], end maybe.Maybe[[]byte]) error {\n\thasLowerBound := start.HasValue()\n\thasUpperBound := end.HasValue()\n\tfor i := 0; i < len(kvs); i++ {\n\t\tif i < len(kvs)-1 && bytes.Compare(kvs[i].Key, kvs[i+1].Key) >= 0 {\n\t\t\treturn ErrNonIncreasingValues\n\t\t}\n\t\tif (hasLowerBound && bytes.Compare(kvs[i].Key, start.Value()) < 0) ||\n\t\t\t(hasUpperBound && bytes.Compare(kvs[i].Key, end.Value()) > 0) {\n\t\t\treturn ErrStateFromOutsideOfRange\n\t\t}\n\t}\n\treturn nil\n}\n\n// Returns nil iff all the following hold:\n//   - Any node with a partial byte length, should not have a value associated with it\n//     since all keys with values are written in complete bytes([]byte).\n//   - Each key in [proof] is a strict prefix of the following key.\n//   - Each key in [proof] is a strict prefix of [keyBytes], except possibly the last.\n//   - If the last element in [proof] is [Key], this is an inclusion proof.\n//     Otherwise, this is an exclusion proof and [keyBytes] must not be in [proof].\nfunc verifyProofPath(proof []ProofNode, key maybe.Maybe[Key]) error {\n\tif len(proof) == 0 {\n\t\treturn nil\n\t}\n\n\t// loop over all but the last node since it will not have the prefix in exclusion proofs\n\tfor i := 0; i < len(proof)-1; i++ {\n\t\tcurrentProofNode := proof[i]\n\t\tnodeKey := currentProofNode.Key\n\n\t\t// Because the interface only support []byte keys,\n\t\t// a key with a partial byte should store a value\n\t\tif nodeKey.hasPartialByte() && proof[i].ValueOrHash.HasValue() {\n\t\t\treturn ErrPartialByteLengthWithValue\n\t\t}\n\n\t\t// each node should have a key that has the proven key as a prefix\n\t\tif key.HasValue() && !key.Value().HasStrictPrefix(nodeKey) {\n\t\t\treturn ErrProofNodeNotForKey\n\t\t}\n\n\t\t// each node should have a key that has a matching TokenConfig and is a prefix of the next node's key\n\t\tnextKey := proof[i+1].Key\n\t\tif !nextKey.HasStrictPrefix(nodeKey) {\n\t\t\treturn ErrNonIncreasingProofNodes\n\t\t}\n\t}\n\n\t// check the last node for a value since the above loop doesn't check the last node\n\tif len(proof) > 0 {\n\t\tlastNode := proof[len(proof)-1]\n\t\tif lastNode.Key.hasPartialByte() && !lastNode.ValueOrHash.IsNothing() {\n\t\t\treturn ErrPartialByteLengthWithValue\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Returns true if [value] and [valueDigest] match.\n// [valueOrHash] should be the [ValueOrHash] field of a [ProofNode].\nfunc valueOrHashMatches(value maybe.Maybe[[]byte], valueOrHash maybe.Maybe[[]byte]) bool {\n\tvar (\n\t\tvalueIsNothing  = value.IsNothing()\n\t\tdigestIsNothing = valueOrHash.IsNothing()\n\t)\n\n\tswitch {\n\tcase valueIsNothing != digestIsNothing:\n\t\t// One is nothing and the other isn't -- no match.\n\t\treturn false\n\tcase valueIsNothing:\n\t\t// Both are nothing -- match.\n\t\treturn true\n\tcase len(value.Value()) < HashLength:\n\t\treturn bytes.Equal(value.Value(), valueOrHash.Value())\n\tdefault:\n\t\tvalueHash := hashing.ComputeHash256(value.Value())\n\t\treturn bytes.Equal(valueHash, valueOrHash.Value())\n\t}\n}\n\n// Adds each key/value pair in [proofPath] to [t].\n// For each proof node, adds the children that are\n// < [insertChildrenLessThan] or > [insertChildrenGreaterThan].\n// If [insertChildrenLessThan] is Nothing, no children are < [insertChildrenLessThan].\n// If [insertChildrenGreaterThan] is Nothing, no children are > [insertChildrenGreaterThan].\n// Assumes [v.lock] is held.\nfunc addPathInfo(\n\tv *view,\n\tproofPath []ProofNode,\n\tinsertChildrenLessThan maybe.Maybe[Key],\n\tinsertChildrenGreaterThan maybe.Maybe[Key],\n) error {\n\tvar (\n\t\tshouldInsertLeftChildren  = insertChildrenLessThan.HasValue()\n\t\tshouldInsertRightChildren = insertChildrenGreaterThan.HasValue()\n\t)\n\n\tfor i := len(proofPath) - 1; i >= 0; i-- {\n\t\tproofNode := proofPath[i]\n\t\tkey := proofNode.Key\n\n\t\tif key.hasPartialByte() && !proofNode.ValueOrHash.IsNothing() {\n\t\t\treturn ErrPartialByteLengthWithValue\n\t\t}\n\n\t\t// load the node associated with the key or create a new one\n\t\t// pass nothing because we are going to overwrite the value digest below\n\t\tn, err := v.insert(key, maybe.Nothing[[]byte]())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// We overwrite the valueDigest to be the hash provided in the proof\n\t\t// node because we may not know the pre-image of the valueDigest.\n\t\tn.valueDigest = proofNode.ValueOrHash\n\n\t\tif !shouldInsertLeftChildren && !shouldInsertRightChildren {\n\t\t\t// No children of proof nodes are outside the range.\n\t\t\t// No need to add any children to [n].\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add [proofNode]'s children which are outside the range\n\t\t// [insertChildrenLessThan, insertChildrenGreaterThan].\n\t\tcompressedKey := Key{}\n\t\tfor index, childID := range proofNode.Children {\n\t\t\tif existingChild, ok := n.children[index]; ok {\n\t\t\t\tcompressedKey = existingChild.compressedKey\n\t\t\t}\n\t\t\tchildKey := key.Extend(ToToken(index, v.tokenSize), compressedKey)\n\t\t\tif (shouldInsertLeftChildren && childKey.Less(insertChildrenLessThan.Value())) ||\n\t\t\t\t(shouldInsertRightChildren && childKey.Greater(insertChildrenGreaterThan.Value())) {\n\t\t\t\t// We didn't set the other values on the child entry, but it doesn't matter.\n\t\t\t\t// We only need the IDs to be correct so that the calculated hash is correct.\n\t\t\t\tn.setChildEntry(\n\t\t\t\t\tindex,\n\t\t\t\t\t&child{\n\t\t\t\t\t\tid:            childID,\n\t\t\t\t\t\tcompressedKey: compressedKey,\n\t\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// getStandaloneView returns a new view that has nothing in it besides the changes due to [ops]\nfunc getStandaloneView(ctx context.Context, ops []database.BatchOp, size int) (*view, error) {\n\tdb, err := newDatabase(\n\t\tctx,\n\t\tmemdb.New(),\n\t\tConfig{\n\t\t\tBranchFactor:                tokenSizeToBranchFactor[size],\n\t\t\tTracer:                      trace.Noop,\n\t\t\tValueNodeCacheSize:          verificationCacheSize,\n\t\t\tIntermediateNodeCacheSize:   verificationCacheSize,\n\t\t\tIntermediateWriteBufferSize: verificationCacheSize,\n\t\t\tIntermediateWriteBatchSize:  verificationCacheSize,\n\t\t},\n\t\t&mockMetrics{},\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newView(db, db, ViewChanges{BatchOps: ops, ConsumeBytes: true})\n}"
    },
    {
      "filename": "x/merkledb/proof.go",
      "content": "// Copyright (C) 2019-2024, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\npackage merkledb\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\n\t\"github.com/ava-labs/avalanchego/database\"\n\t\"github.com/ava-labs/avalanchego/database/memdb\"\n\t\"github.com/ava-labs/avalanchego/ids\"\n\t\"github.com/ava-labs/avalanchego/trace\"\n\t\"github.com/ava-labs/avalanchego/utils/hashing\"\n\t\"github.com/ava-labs/avalanchego/utils/maybe\"\n\n\tpb \"github.com/ava-labs/avalanchego/proto/pb/sync\"\n)\n\nconst verificationCacheSize = math.MaxUint16\n\nvar (\n\tErrInvalidProof                = errors.New(\"proof obtained an invalid root ID\")\n\tErrInvalidMaxLength            = errors.New(\"expected max length to be > 0\")\n\tErrNonIncreasingValues         = errors.New(\"keys sent are not in increasing order\")\n\tErrStateFromOutsideOfRange     = errors.New(\"state key falls outside of the start->end range\")\n\tErrNonIncreasingProofNodes     = errors.New(\"each proof node key must be a strict prefix of the next\")\n\tErrExtraProofNodes             = errors.New(\"extra proof nodes in path\")\n\tErrDataInMissingRootProof      = errors.New(\"there should be no state or deleted keys in a change proof that had a missing root\")\n\tErrEmptyProof                  = errors.New(\"proof is empty\")\n\tErrNoMerkleProof               = errors.New(\"empty key response must include merkle proof\")\n\tErrShouldJustBeRoot            = errors.New(\"end proof should only contain root\")\n\tErrNoStartProof                = errors.New(\"no start proof\")\n\tErrNoEndProof                  = errors.New(\"no end proof\")\n\tErrProofNodeNotForKey          = errors.New(\"the provided node has a key that is not a prefix of the specified key\")\n\tErrProofValueDoesntMatch       = errors.New(\"the provided value does not match the proof node for the provided key's value\")\n\tErrProofNodeHasUnincludedValue = errors.New(\"the provided proof has a value for a key within the range that is not present in the provided key/values\")\n\tErrInvalidMaybe                = errors.New(\"maybe is nothing but has value\")\n\tErrNilProofNode                = errors.New(\"proof node is nil\")\n\tErrNilValueOrHash              = errors.New(\"proof node's valueOrHash field is nil\")\n\tErrNilKey                      = errors.New(\"key is nil\")\n\tErrInvalidKeyLength            = errors.New(\"key length doesn't match bytes length, check specified branchFactor\")\n\tErrNilRangeProof               = errors.New(\"range proof is nil\")\n\tErrNilChangeProof              = errors.New(\"change proof is nil\")\n\tErrNilMaybeBytes               = errors.New(\"maybe bytes is nil\")\n\tErrNilProof                    = errors.New(\"proof is nil\")\n\tErrNilValue                    = errors.New(\"value is nil\")\n\tErrUnexpectedEndProof          = errors.New(\"end proof should be empty\")\n)\n\ntype ProofNode struct {\n\tKey Key\n\t// Nothing if this is an intermediate node.\n\t// The value in this node if its length < [HashLen].\n\t// The hash of the value in this node otherwise.\n\tValueOrHash maybe.Maybe[[]byte]\n\tChildren    map[byte]ids.ID\n}\n\n// ToProto converts the ProofNode into the protobuf version of a proof node\n// Assumes [node.Key.Key.length] <= math.MaxUint64.\nfunc (node *ProofNode) ToProto() *pb.ProofNode {\n\tpbNode := &pb.ProofNode{\n\t\tKey: &pb.Key{\n\t\t\tLength: uint64(node.Key.length),\n\t\t\tValue:  node.Key.Bytes(),\n\t\t},\n\t\tValueOrHash: &pb.MaybeBytes{\n\t\t\tValue:     node.ValueOrHash.Value(),\n\t\t\tIsNothing: node.ValueOrHash.IsNothing(),\n\t\t},\n\t\tChildren: make(map[uint32][]byte, len(node.Children)),\n\t}\n\n\tfor childIndex, childID := range node.Children {\n\t\tchildID := childID\n\t\tpbNode.Children[uint32(childIndex)] = childID[:]\n\t}\n\n\treturn pbNode\n}\n\nfunc (node *ProofNode) UnmarshalProto(pbNode *pb.ProofNode) error {\n\tswitch {\n\tcase pbNode == nil:\n\t\treturn ErrNilProofNode\n\tcase pbNode.ValueOrHash == nil:\n\t\treturn ErrNilValueOrHash\n\tcase pbNode.ValueOrHash.IsNothing && len(pbNode.ValueOrHash.Value) != 0:\n\t\treturn ErrInvalidMaybe\n\tcase pbNode.Key == nil:\n\t\treturn ErrNilKey\n\tcase len(pbNode.Key.Value) != bytesNeeded(int(pbNode.Key.Length)):\n\t\treturn ErrInvalidKeyLength\n\t}\n\tnode.Key = ToKey("
    }
  ]
}