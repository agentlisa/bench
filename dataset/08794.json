{
  "Title": "[H-06] Malicious Relayer can Replay Execute Calldata on Different Chains Causing Double-Spend Issue",
  "Content": "_Submitted by xiaoming90_\n\n[BridgeFacet.sol#L411](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411)<br>\n\n> This issue is only applicable for fast-transfer. Slow transfer would not have this issue because of the built-in fraud-proof mechanism in Nomad.\n\nFirst, the attacker will attempt to use Connext to send `1000 USDC` from Ethereum domain to Optimism domain.\n\nAssume that the attacker happens to be a relayer on the relayer network utilised by Connext, and the attacker's relayer happens to be tasked to relay the above execute calldata to the Optimism's Connext [`BridgeFacet.execute`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function.\n\nOptimism's Connext `BridgeFacet.execute` received the execute calldata and observed within the calldata that it is a fast-transfer and Router A is responsible for providing the liquidity. It will then check that the router signature is valid, and proceed to transfer `1000 oUSDC` to attacker wallet (0x123456) in Optimism.\n\nNext, attacker will update the `ExecuteArgs.local` within the execute calldata to a valid local representation of canonical token (USDC) used within Polygon. Attacker will then send the modified execute calldata to Polygon's Connext `BridgeFacet.execute` function. Assume that the same Router A is also providing liquidity in Polygon. The `BridgeFacet.execute` function checks that the router signature is valid, and proceed to transfer `1000 POS-USDC` to atttack wallet (0x123456) in Polygon.\n\nAt this point, the attacker has `1000 oUSDC` and `1000 POS-USDC` in his wallets. When the nomad message arrives at Optimism, Router A can claim the `1000 oUSDC` back from Connext. However, Router A is not able to claim back any fund in Polygon.\n\nNote that same wallet address exists on different chains. For instance, the wallet address on Etherum and Polygon is the same.\n\n#### Why changing the `ExecuteArgs.local` does not affect the router signature verification?\n\nThis is because the router signature is generated from the `transferId` + `pathLength` only, and these data are stored within the `CallParams params` within the `ExecuteArgs` struct.\n\n[LibConnextStorage.sol#L77](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77)<br>\n\n```solidity\nstruct ExecuteArgs {\n  CallParams params;\n  address local; // local representation of canonical token\n  address[] routers;\n  bytes[] routerSignatures;\n  uint256 amount;\n  uint256 nonce;\n  address originSender;\n}\n```\n\nWithin the [`BridgeFacet._executeSanityChecks`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function, it will attempt to rebuild to `transferId` by calling the following code:\n\n```solidity\n// Derive transfer ID based on given arguments.\nbytes32 transferId = _getTransferId(_args);\n```\n\nWithin the [`BridgeFacet._getTransferId`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719) function, we can see that the `s.tokenRegistry.getTokenId(_args.local)` will always return the canonical `tokenDomain` and `tokenId`. In our example, it will be `Ethereum` and  `USDC`. Therefore, as long as the attacker specify a valid local representation of canonical token on a chain, the `transferId` returned by `s.tokenRegistry.getTokenId(_args.local)` will always be the same across all domains. Thus, this allows the attacker to modify the `ExecuteArgs.local` and yet he could pass the router signature check.\n\n  [BridgeFacet.sol#L719](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719)<br>\n\n```solidity\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n```\n\n### Impact\n\nRouter liquidity would be drained by attacker, and affected router owner could not claim back their liquidity.\n\n### Recommended Mitigation Steps\n\nThe security of the current Connext design depends on how secure or reliable the relayer is. If the relayer turns rouge or acts against Connext, many serious consequences can happen.\n\nThe root cause is that the current design places enormous trust on the relayers to accurately and reliably to deliver calldata to the bridge in various domains. For instance, delivering of execute call data to `execute` function. There is an attempt to prevent message replay on a single domain, however, it does not prevent message replay across multiple domains. Most importantly, the Connext's bridge appears to have full trust on the calldata delivered by the relayer. However, the fact is that the calldata can always be altered by the relayer.\n\nConsider a classic 0x off-chain ordering book protocol. A user will sign his order with his private key, and attach the signature to the order, and send the order (with signature) to the relayer network. If the relayer attempts to tamper the order message or signature, the decoded address will be different from the signer's address and this will be detected by 0x's Smart contract on-chain when processing the order. This ensures that the integrity of the message and signer can be enforced.\n\nPer good security practice, relayer network should always be considered as a hostile environment/network. Therefore, it is recommended that similar approach could be taken with regards to passing execute calldata across domains/chains.\n\nFor instance, at a high level, the sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. This will ensure the intergrity of the execute calldata and prevent any issue that arise due to unauthorised modification of calldata.\n\nAdditionally, the execute calldata should also have a field that correspond to the destination domain. The bridge that receives the execute calldata must verify that the execute calldata is intended for its domain, otherwise reject the calldata if it belongs to other domains. This also helps to prevent the attack mentioned earlier where same execute calldata can be accepted in different domains.\n\n**[LayneHaber (Connext) confirmed and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1166344934):**\n > Agree that this is an issue, but disagree with the framing and mitigation.\n> \n> The `calldata` is included in the generation of the `transferId` via the `CallParams`, so it cannot be easily manipulated by the relayer network once signed by routers. However, because you are not validating the `s.domain` against the `CallParams.destinationDomain` you can use the same transfer data across multiple chains, which is a big problem.\n\n**[LayneHaber (Connext) resolved](https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1167499043):**\n > [connext/nxtp@bc241f8](https://github.com/connext/nxtp/pull/1450/commits/bc241f8d9ca5ca7d9598c7b40affa9a416580cc6)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1214813364):**\n > This seems like the most severe finding of the entire contest. Kudos to the warden on a great find!\n> \n> Because transfer data is replicated across multiple chains, relayers are also able to execute data on each chain. If `_executeSanityChecks` does not check that the message's destination chain matches `s.domain`, then transfers could be spent on all available chains.\n>\n > Interestingly, because the remote router is included in the message, only the correct destination chain will be able to reconcile the transfer and reimburse routers for providing liquidity. Hence, the issue is only prevalent on other chains if routers readily bid on incoming transfers, which seems possible because signatures can be replayed on other chains. So if the same set of routers have sufficient liquidity on another chain, the relayer can execute this message again to create a double spend issue.\n>\n > Another point to add, this issue would only be prevalent on chains which have its local asset pointing to the same address as this is what the bridge will attempt to transfer to the recipient. Additionally, in order for the relayer to replay a router's signature, the `transferId` must exactly match the `transferId` on the intended destination chain. This is only possible if `TokenRegistry.getTokenId` returns the same canonical domain and ID values.\n>\n > It would be good to confirm this. Is it possible for a local asset to be registered to the same canonical domain and ID on multiple chains?\n\n**[LayneHaber (Connext) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1218305324):**\n > > Is it possible for a local asset to be registered to the same canonical domain and ID on multiple chains?\n> \n> Yes, that is actually the purpose of the `canonicalId` and `canonicalDomain` -- there should only be one canonical (locked) token that maps to any number of local (minted) instances.\n> \n> This issue is valid, and enforcing in `_executeSanityChecks` it is only executed on the destination domain should prevent this attack, correct?\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/144#issuecomment-1218349487):**\n> Okay great! Because local assets map to the same canonical domain and ID on each chain, I think this issue is most definitely valid. `_args.local` is not used to calculate `transferId`, hence the representation for each asset may differ on each chain but the `TokenRegistry.getTokenId` should return the correct information.\n> \n> I can confirm that the enforcing check in `_executeSanityChecks` should ensure that transfer data is only executed on the intended destination domain.\n\n\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/facets/BridgeFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TypedMemView} from \"../../../nomad-core/libs/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../nomad-core/contracts/XAppConnectionManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {XCallArgs, ExecuteArgs, CallParams} from \"../libraries/LibConnextStorage.sol\";\nimport {LibCrossDomainProperty} from \"../libraries/LibCrossDomainProperty.sol\";\n\nimport {PromiseRouter} from \"../../promise/PromiseRouter.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\nimport {IExecutor} from \"../interfaces/IExecutor.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {ISponsorVault} from \"../interfaces/ISponsorVault.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using ConnextMessage for bytes29;\n\n  // ========== Structs ===========\n\n  struct XCalledEventArgs {\n    address transactingAssetId;\n    uint256 amount;\n    uint256 bridgedAmt;\n    address bridged;\n  }\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n  error BridgeFacet__setExecutor_invalidExecutor();\n  error BridgeFacet__setSponsorVault_invalidSponsorVault();\n  error BridgeFacet__xcall_wrongDomain();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_notSupportedAsset();\n  error BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n  error BridgeFacet__xcall_callbackNotAContract();\n  error BridgeFacet__reconcile_invalidAction();\n  error BridgeFacet__reconcile_alreadyReconciled();\n  error BridgeFacet__reconcile_noPortalRouter();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_alreadyExecuted();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_alreadyReconciled();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__forceReceiveLocal_invalidSender();\n\n  // ============ Properties ============\n\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    XCallArgs xcallArgs,\n    XCalledEventArgs args,\n    uint256 nonce,\n    bytes message,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param origin - The origin domain of the transfer\n   * @param routers - The CallParams.recipient provided, created as indexed parameter\n   * @param asset - The asset that was provided by the bridge\n   * @param amount - The amount that was provided by the bridge\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed origin,\n    address[] routers,\n    address asset,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `execute` is called on the destination chain\n   * @dev `execute` may be called when providing fast liquidity *or* when processing a reconciled transfer\n   * @param transferId - The unique identifier of the crosschain transfer\n   * @param to - The CallParams.to provided, created as indexed parameter\n   * @param args - The ExecuteArgs provided to the function\n   * @param transactingAsset - The asset the to gets or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param transactingAmount - The amount of transferring asset the to address receives or the external call is\n   * executed with\n   * @param caller - The account that called the function\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    ExecuteArgs args,\n    address transactingAsset,\n    uint256 transactingAmount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `bumpTransfer` is called by an user on the origin domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param relayerFee - The updated amount of relayer fee in native asset\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesUpdated(bytes32 indexed transferId, uint256 relayerFee, address caller);\n\n  /**\n   * @notice Emitted when a transfer will accept the local asset instead of the\n   * previously specified adopted asset.\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param canonicalId - The canonical identifier for the local asset\n   * @param canonicalDomain - The canonical domain for the local asset\n   * @param amount - The amount for the transfer\n   */\n  event ForcedReceiveLocal(\n    bytes32 indexed transferId,\n    bytes32 indexed canonicalId,\n    uint32 canonicalDomain,\n    uint256 amount\n  );\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when executed a Portal repayment\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when there is no enough assets to repay or the repayment failed\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param asset - The asset that in which the debt is nominated\n   * @param amount - The amount that is pending to be repaid\n   * @param fee - The fee amount that is pending to be repaid\n   */\n  event AavePortalRepaymentDebt(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Emitted when the sponsorVault variable is updated\n   * @param oldSponsorVault - The sponsorVault old value\n   * @param newSponsorVault - The sponsorVault new value\n   * @param caller - The account that called the function\n   */\n  event SponsorVaultUpdated(address oldSponsorVault, address newSponsorVault, address caller);\n\n  /**\n   * @notice Emitted when the promiseRouter variable is updated\n   * @param oldRouter - The promiseRouter old value\n   * @param newRouter - The promiseRouter new value\n   * @param caller - The account that called the function\n   */\n  event PromiseRouterUpdated(address oldRouter, address newRouter, address caller);\n\n  /**\n   * @notice Emitted when the executor variable is updated\n   * @param oldExecutor - The executor old value\n   * @param newExecutor - The executor new value\n   * @param caller - The account that called the function\n   */\n  event ExecutorUpdated(address oldExecutor, address newExecutor, address caller);\n\n  // ============ Getters ============\n\n  function relayerFees(bytes32 _transferId) public view returns (uint256) {\n    return s.relayerFees[_transferId];\n  }\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function reconciledTransfers(bytes32 _transferId) public view returns (bool) {\n    return s.reconciledTransfers[_transferId];\n  }\n\n  function domain() public view returns (uint256) {\n    return s.domain;\n  }\n\n  function executor() public view returns (IExecutor) {\n    return s.executor;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function sponsorVault() public view returns (ISponsorVault) {\n    return s.sponsorVault;\n  }\n\n  function promiseRouter() external view returns (PromiseRouter) {\n    return s.promiseRouter;\n  }\n\n  // ============ Admin methods ==============\n\n  function setPromiseRouter(address payable _promiseRouter) external onlyOwner {\n    address old = address(s.promiseRouter);\n    if (old == _promiseRouter || !Address.isContract(_promiseRouter))\n      revert BridgeFacet__setPromiseRouter_invalidPromiseRouter();\n\n    s.promiseRouter = PromiseRouter(_promiseRouter);\n    emit PromiseRouterUpdated(old, _promiseRouter, msg.sender);\n  }\n\n  function setExecutor(address _executor) external onlyOwner {\n    address old = address(s.executor);\n    if (old == _executor || !Address.isContract(_executor)) revert BridgeFacet__setExecutor_invalidExecutor();\n\n    s.executor = IExecutor(_executor);\n    emit ExecutorUpdated(old, _executor, msg.sender);\n  }\n\n  function setSponsorVault(address _sponsorVault) external onlyOwner {\n    address old = address(s.sponsorVault);\n    if (old == _sponsorVault) revert BridgeFacet__setSponsorVault_invalidSponsorVault();\n\n    s.sponsorVault = ISponsorVault(_sponsorVault);\n    emit SponsorVaultUpdated(old, _sponsorVault, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds, calldata, and/or various named properties using the nomad\n   * network.\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local nomad asset counterparts (i.e. bridgable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local nomad assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * For native transfers, the native asset will be wrapped by depositing them to the configured Wrapper contract. Next,\n   * the wrapper tokens (e.g. WETH) are swapped for their local nomad asset counterparts via the configured AMM.\n   * Those local tokens will then be sent via the bridge router. Since the local assets would always be canonical in this\n   * case, custody of the local assets will be kept here.\n   *\n   * @param _args - The XCallArgs arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {\n    // Sanity checks.\n    {\n      // Correct origin domain.\n      if (_args.params.originDomain != s.domain) {\n        revert BridgeFacet__xcall_wrongDomain();\n      }\n\n      // Recipient is defined.\n      if (_args.params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      // If callback address is not set, callback fee should be 0.\n      if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {\n        revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();\n      }\n\n      // Callback is contract if supplied.\n      if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {\n        revert BridgeFacet__xcall_callbackNotAContract();\n      }\n    }\n\n    bytes32 transferId;\n    bytes memory message;\n    XCalledEventArgs memory eventArgs;\n    {\n      // Get the remote BridgeRouter address; revert if not found.\n      bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);\n\n      // Get the true transacting asset ID (using wrapper instead of native, if applicable).\n      address transactingAssetId = _args.transactingAssetId == address(0)\n        ? address(s.wrapper)\n        : _args.transactingAssetId;\n\n      // Check that the asset is supported -- can be either adopted or local.\n      ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];\n      if (canonical.id == bytes32(0)) {\n        // Here, the asset is *not* the adopted asset. The only other valid option\n        // is for this asset to be the local asset (i.e. transferring madEth on optimism)\n        // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on\n        // the canonical domain, where it is *also* the adopted asset.\n        if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {\n          // revert, using a token of local origin that is not registered as adopted\n          revert BridgeFacet__xcall_notSupportedAsset();\n        }\n\n        (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);\n        canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);\n      }\n\n      transferId = _getTransferId(_args, canonical);\n      s.nonce += 1;\n\n      // Store the relayer fee\n      s.relayerFees[transferId] = _args.params.relayerFee;\n\n      // Transfer funds of transacting asset to the contract from the user.\n      // NOTE: Will wrap any native asset transferred to wrapped-native automatically.\n      (, uint256 amount) = AssetLogic.handleIncomingAsset(\n        _args.transactingAssetId,\n        _args.amount,\n        _args.params.relayerFee + _args.params.callbackFee\n      );\n\n      // Swap to the local asset from adopted if applicable.\n      (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(\n        canonical,\n        transactingAssetId,\n        amount,\n        _args.params.slippageTol\n      );\n\n      // Transfer callback fee to PromiseRouter if set\n      if (_args.params.callbackFee != 0) {\n        s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);\n      }\n\n      message = _formatMessage(_args, bridged, transferId, bridgedAmt);\n      s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);\n\n      // Format arguments for XCalled event that will be emitted below.\n      eventArgs = XCalledEventArgs({\n        transactingAssetId: transactingAssetId,\n        amount: amount,\n        bridgedAmt: bridgedAmt,\n        bridged: bridged\n      });\n    }\n\n    // emit event\n    emit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice The interface-compliant entrypoint for nomad relayers. Handles an incoming nomad router message that has\n   * been verified optimistically. Wraps `_reconcile`, which contains the business logic involved in completing the\n   * xchain update.\n   *\n   * @dev Since this method will be called by nomad relayers, it should not consume arbitrary amounts of gas under\n   * any circumstances.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _nonce - The unique numeric identifier for the message from origin to destination.\n   * @param _sender - The sender identifier.\n   * @param _message - The message bytes.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteRouter(_origin, _sender) {\n    _reconcile(_origin, _message);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external whenNotPaused nonReentrant returns (bytes32) {\n    (bytes32 transferId, bool reconciled) = _executeSanityChecks(_args);\n\n    // Set the relayer for this transaction to allow for future claim\n    s.transferRelayer[transferId] = msg.sender;\n\n    // execute router liquidity when this is a fast transfer\n    // asset will be adopted unless specified to be local in params\n    (uint256 amount, address asset) = _handleExecuteLiquidity(transferId, !reconciled, _args);\n\n    // execute the transaction\n    uint256 amountWithSponsors = _handleExecuteTransaction(_args, amount, asset, transferId, reconciled);\n\n    // emit event\n    emit Executed(transferId, _args.params.to, _args, asset, amountWithSponsors, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n\n    s.relayerFees[_transferId] += msg.value;\n\n    emit TransferRelayerFeesUpdated(_transferId, s.relayerFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice A user-specified agent can call this to accept the local asset instead of the\n   * previously specified adopted asset.\n   * @dev Should be called in situations where transfers are facing unfavorable slippage\n   * conditions for extended periods\n   * @param _params - The call params for the transaction\n   * @param _amount - The amount of transferring asset the tx called xcall with\n   * @param _nonce - The nonce for the transfer\n   * @param _canonicalId - The identifier of the canonical asseted associated with the transfer\n   * @param _canonicalDomain - The domain of the canonical asseted associated with the transfer\n   * @param _originSender - The msg.sender of the origin call\n   */\n  function forceReceiveLocal(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) external {\n    // Enforce caller\n    if (msg.sender != _params.agent) revert BridgeFacet__forceReceiveLocal_invalidSender();\n\n    // Calculate transfer id\n    bytes32 transferId = _calculateTransferId(_params, _amount, _nonce, _canonicalId, _canonicalDomain, _originSender);\n\n    // Store receive local\n    s.receiveLocalOverrides[transferId] = true;\n\n    // Emit event\n    emit ForcedReceiveLocal(transferId, _canonicalId, _canonicalDomain, _amount);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Formats a nomad message generated by `xcall`\n   * @dev Need this to prevent stack too deep\n   */\n  function _formatMessage(\n    XCallArgs calldata _args,\n    address _asset,\n    bytes32 _transferId,\n    uint256 _amount\n  ) internal returns (bytes memory) {\n    // Cast asset to bridge token interface.\n    IBridgeToken token = IBridgeToken(_asset);\n\n    bytes32 detailsHash;\n    if (s.tokenRegistry.isLocalOrigin(_asset)) {\n      // TODO: do we want to store a mapping of custodied token balances here?\n\n      // Token is local for this domain. We should custody the token here.\n      // Query token contract for details and calculate detailsHash.\n      detailsHash = ConnextMessage.formatDetailsHash(token.name(), token.symbol(), token.decimals());\n    } else {\n      // If the token originates on a remote chain, burn the representation tokens on this chain.\n      if (_amount > 0) {\n        token.burn(address(this), _amount);\n      }\n      detailsHash = token.detailsHash();\n    }\n\n    // Format the message action.\n    // The action is the part of the message that represents what has to happen for the transfer.\n    // It includes the `detailsHash` in case a new token must be deployed, the transfer recipient,\n    // the amount, and the transfer ID. The `amount` here is used by reconcile, once the message is\n    // confirmed, to potentially mint more tokens\n    bytes29 action = ConnextMessage.formatTransfer(\n      TypeCasts.addressToBytes32(_args.params.to),\n      _amount,\n      detailsHash,\n      _transferId\n    );\n\n    // Get the token's canonical domain and ID.\n    (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_asset);\n\n    // Format the token's ID for messaging.\n    bytes29 tokenId = ConnextMessage.formatTokenId(canonicalDomain, canonicalId);\n\n    return ConnextMessage.formatMessage(tokenId, action);\n  }\n\n  /**\n   * @notice Called via `handle`. Will either (a) credit the router(s) if fast liquidity was provided (i.e. `execute`\n   * has already occurred) or (b) make funds available for execution, updating state to mark the transfer as having\n   * been reconciled (i.e. verified).\n   *\n   * @dev The output asset will be the one registered under the canonical token ID in the TokenRegistry. If the output\n   * asset is an adopted token, the bridged nomad counterpart (i.e. the local asset) will be minted then swapped via\n   * the configured AMM to the adopted token. If the target output is the canonical token (i.e. this domain is the\n   * canonical domain for the token), then we will release custody of the appropriate amount of that canonical token\n   * (tokens which were previously deposited into this bridge via outgoing `xcall`s). If the target adopted token\n   * is also the local nomad asset (which would be minted here), then no swap is necessary.\n   *\n   * @param _origin - The origin domain's numeric ID.\n   * @param _message - The bridged message bytes.\n   */\n  function _reconcile(uint32 _origin, bytes memory _message) internal {\n    // Parse tokenId and action from the message.\n    bytes29 msg_ = _message.ref(0).mustBeMessage();\n    bytes29 tokenId = msg_.tokenId();\n    bytes29 action = msg_.action();\n\n    // Assert that the action is valid.\n    if (!action.isTransfer()) {\n      revert BridgeFacet__reconcile_invalidAction();\n    }\n\n    // Load the transferId.\n    bytes32 transferId = action.transferId();\n\n    // Ensure the transaction has not already been handled (i.e. previously reconciled).\n    if (s.reconciledTransfers[transferId]) {\n      revert BridgeFacet__reconcile_alreadyReconciled();\n    }\n\n    // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by\n    // `handle`. They are both used in the generation of the `transferId` so routers must provide them\n    // correctly to be reimbursed.\n\n    // Get the appropriate local token contract for the given tokenId on this chain.\n    // NOTE: If the token is of remote origin and there is no existing representation token contract,\n    // the TokenRegistry will deploy a new one.\n    address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());\n\n    // Load amount once.\n    uint256 amount = action.amnt();\n\n    // Mint tokens if the asset is of remote origin (i.e. is representational).\n    // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held\n    // in escrow in this contract (from previous `xcall`s).\n    if (!s.tokenRegistry.isLocalOrigin(token)) {\n      IBridgeToken(token).mint(address(this), amount);\n\n      // Update the recorded `detailsHash` for the token (name, symbol, decimals).\n      // TODO: do we need to keep this\n      bytes32 details = action.detailsHash();\n      IBridgeToken(token).setDetailsHash(details);\n    }\n\n    // Mark the transfer as reconciled.\n    s.reconciledTransfers[transferId] = true;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[transferId];\n\n    // If fast transfer was made using portal liquidity, we need to repay\n    // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly\n    uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];\n\n    uint256 toDistribute = amount;\n    uint256 pathLen = routers.length;\n    if (portalTransferAmount != 0) {\n      // ensure a router took on credit risk\n      if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();\n      toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);\n    }\n\n    if (pathLen != 0) {\n      // fast liquidity path\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmt = toDistribute / pathLen;\n      for (uint256 i; i < pathLen; ) {\n        s.routerBalances[routers[i]][token] += routerAmt;\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed\n   * @param _sig The signature you are recovering the signer from\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, bool) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.agent) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Make sure number of routers is below the configured maximum.\n    if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _getTransferId(_args);\n\n    // Retrieve the reconciled record. If the transfer is `forceSlow` then it must be reconciled first\n    // before it's executed.\n    bool reconciled = s.reconciledTransfers[transferId];\n    if (_args.params.forceSlow && !reconciled) revert BridgeFacet__execute_notReconciled();\n\n    // Hash the payload for which each router should have produced a signature.\n    // Each router should have signed the `transferId` (which implicitly signs call params,\n    // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n    // they are splitting liquidity provision.\n    bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n    // check the reconciled status is correct\n    // (i.e. if there are routers provided, the transfer must *not* be reconciled)\n    if (pathLength > 0) // make sure routers are all approved if needed\n    {\n      if (reconciled) revert BridgeFacet__execute_alreadyReconciled();\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router whitelist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterOwnershipRenounced() && !s.routerPermissionInfo.approvedRouters[_args.routers[i]]) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          i++;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (!reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    // Require that this transfer has not already been executed. If it were executed, the `transferRelayer`\n    // would have been set in the previous call (to enable the caller to claim relayer fees).\n    if (s.transferRelayer[transferId] != address(0)) {\n      revert BridgeFacet__execute_alreadyExecuted();\n    }\n\n    return (transferId, reconciled);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(XCallArgs calldata _args, ConnextMessage.TokenId memory _canonical)\n    private\n    view\n    returns (bytes32)\n  {\n    // return keccak256(abi.encode(s.nonce, _args.params, msg.sender, _canonical.id, _canonical.domain, _args.amount));\n    return _calculateTransferId(_args.params, _args.amount, s.nonce, _canonical.id, _canonical.domain, msg.sender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `execute` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {\n    (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);\n    return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);\n  }\n\n  /**\n   * @notice Calculates a transferId based on `xcall` arguments\n   * @dev Need this to prevent stack too deep\n   */\n  function _calculateTransferId(\n    CallParams calldata _params,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes32 _canonicalId,\n    uint32 _canonicalDomain,\n    address _originSender\n  ) private pure returns (bytes32) {\n    return keccak256(abi.encode(_nonce, _params, _originSender, _canonicalId, _canonicalDomain, _amount));\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _liquidityFeeNum Liquidity fee numerator\n   * @param _liquidityFeeDen Liquidity fee denominator\n   */\n  function _getFastTransferAmount(\n    uint256 _amount,\n    uint256 _liquidityFeeNum,\n    uint256 _liquidityFeeDen\n  ) private pure returns (uint256) {\n    return (_amount * _liquidityFeeNum) / _liquidityFeeDen;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  ) private returns (uint256, address) {\n    uint256 toSwap = _args.amount;\n\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);\n\n      // Save the addressess of all routers providing liquidity for this transfer.\n      s.routedTransfers[_transferId] = _args.routers;\n\n      // If router does not have enough liquidity, try to use Aave Portals.\n      // only one router should be responsible for taking on this credit risk, and it should only"
    }
  ]
}