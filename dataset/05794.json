{
  "Title": "[N-01] Missing event emission for critical state changes",
  "Content": "\n*There are 21 instances of this issue:*\n\n<details>\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/token/ERC20hTokenRoot.sol#L39C6-L44C44\n\nMissing event emission for state variables `localChainId` and `factoryAddress`:\n\n```solidity\nFile: ERC20hTokenRoot.sol\n31:     constructor(\n32:         uint16 _localChainId,\n33:         address _factoryAddress,\n34:         address _rootPortAddress,\n35:         string memory _name,\n36:         string memory _symbol,\n37:         uint8 _decimals\n38:     ) ERC20(string(string.concat(_name)), string(string.concat(_symbol)), _decimals) {\n39:         require(_rootPortAddress != address(0), \"Root Port Address cannot be 0\");\n40:         require(_factoryAddress != address(0), \"Factory Address cannot be 0\");\n41:        \n42:         localChainId = _localChainId;\n43:         factoryAddress = _factoryAddress;\n44:         _initializeOwner(_rootPortAddress);\n45:         //@audit NC - missing event emission\n46:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/factories/ERC20hTokenRootFactory.sol#L34C4-L40C1\n\nMissing event emission for state variables `localChainId` and `rootPortAddress`:\n\n```solidity\nFile: ERC20hTokenRootFactory.sol\n34:     constructor(uint16 _localChainId, address _rootPortAddress) {\n35:         require(_rootPortAddress != address(0), \"Root Port Address cannot be 0\");\n36:         localChainId = _localChainId;\n37:         rootPortAddress = _rootPortAddress;\n38:         _initializeOwner(msg.sender);\n39:         //@audit NC - missing event emission\n40:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/factories/ERC20hTokenRootFactory.sol#L49C5-L54C1\n\nMissing event emission for state variable `coreRootRouterAddress`:\n\n```solidity\nFile: ERC20hTokenRootFactory.sol\n50:     function initialize(address _coreRouter) external onlyOwner {\n51:         require(_coreRouter != address(0), \"CoreRouter address cannot be 0\");\n52:         coreRootRouterAddress = _coreRouter; //@audit NC - missing event emission\n53:         renounceOwnership();\n54:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/factories/ERC20hTokenBranchFactory.sol#L42C5-L49C6\n\nMissing event emission for state variables from Line 44 to 47:\n\n```solidity\nFile: ERC20hTokenBranchFactory.sol\n42:     constructor(uint16 _localChainId, address _localPortAddress, string memory _chainName, string memory _chainSymbol) {\n43:         require(_localPortAddress != address(0), \"Port address cannot be 0\");\n44:         chainName = string.concat(_chainName, \" Ulysses\");\n45:         chainSymbol = string.concat(_chainSymbol, \"-u\");\n46:         localChainId = _localChainId;\n47:         localPortAddress = _localPortAddress;\n48:         _initializeOwner(msg.sender);\n49:         //@audit NC - missing event emission\n50:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/factories/ERC20hTokenBranchFactory.sol#L60C1-L77C6\n\nMissing event emission for state changes on Line 73 and 75:\n\n```solidity\nFile: ERC20hTokenBranchFactory.sol\n61:     function initialize(address _wrappedNativeTokenAddress, address _coreRouter) external onlyOwner {\n62:         require(_coreRouter != address(0), \"CoreRouter address cannot be 0\");\n63: \n64:         ERC20hTokenBranch newToken = new ERC20hTokenBranch(\n65:             chainName,\n66:             chainSymbol,\n67:             ERC20(_wrappedNativeTokenAddress).name(),\n68:             ERC20(_wrappedNativeTokenAddress).symbol(),\n69:             ERC20(_wrappedNativeTokenAddress).decimals(),\n70:             localPortAddress\n71:         );\n72: \n73:         hTokens.push(newToken);\n74: \n75:         localCoreRouterAddress = _coreRouter;\n76: \n77:         renounceOwnership();\n78:         //@audit NC - missing event emission\n79:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/factories/BranchBridgeAgentFactory.sol#L52C1-L77C6\n\nMissing event emission for state variables from Line 70 to 75:\n\n```solidity\nFile: BranchBridgeAgentFactory.sol\n52:     constructor(\n53:         uint16 _localChainId,\n54:         uint16 _rootChainId,\n55:         address _rootBridgeAgentFactoryAddress,\n56:         address _lzEndpointAddress,\n57:         address _localCoreBranchRouterAddress,\n58:         address _localPortAddress,\n59:         address _owner\n60:     ) {\n61:         require(_rootBridgeAgentFactoryAddress != address(0), \"Root Bridge Agent Factory Address cannot be 0\");\n62:         require(\n63:             _lzEndpointAddress != address(0) || _rootChainId == _localChainId,\n64:             \"Layerzero Endpoint Address cannot be the zero address.\"\n65:         );\n66:         require(_localCoreBranchRouterAddress != address(0), \"Core Branch Router Address cannot be 0\");\n67:         require(_localPortAddress != address(0), \"Port Address cannot be 0\");\n68:         require(_owner != address(0), \"Owner cannot be 0\");\n69: \n70:         localChainId = _localChainId;\n71:         rootChainId = _rootChainId;\n72:         rootBridgeAgentFactoryAddress = _rootBridgeAgentFactoryAddress;\n73:         lzEndpointAddress = _lzEndpointAddress;\n74:         localCoreBranchRouterAddress = _localCoreBranchRouterAddress;\n75:         localPortAddress = _localPortAddress;\n76:         _initializeOwner(_owner);\n77:         //@audit NC - missing event emission\n78:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L35C1-L38C6\n\nMissing event emission for state variables `userAddress` and `localPortAddress`:\n\n```solidity\nFile: VirtualAccount.sol\n35:     constructor(address _userAddress, address _localPortAddress) {\n36:         userAddress = _userAddress;\n37:         localPortAddress = _localPortAddress;\n38:         //@audit NC - missing event emission\n39:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L111C1-L118C6\n\nMissing event emission for state variables on Lines 114, 115, 118 and 119:\n\n```solidity\nFile: RootPort.sol\n113:     constructor(uint256 _localChainId) {\n114:         localChainId = _localChainId;\n115:         isChainId[_localChainId] = true;\n116: \n117:         _initializeOwner(msg.sender);\n118:         _setup = true;\n119:         _setupCore = true;\n120:         //@audit NC - missing event emission\n121:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L129C1-L139C6\n\nMissing event emission for state changes from Line 136 to 141:\n\n```solidity\nFile: RootPort.sol\n132:     function initialize(address _bridgeAgentFactory, address _coreRootRouter) external onlyOwner {\n133:         require(_bridgeAgentFactory != address(0), \"Bridge Agent Factory cannot be 0 address.\");\n134:         require(_coreRootRouter != address(0), \"Core Root Router cannot be 0 address.\");\n135:         require(_setup, \"Setup ended.\");\n136:         _setup = false; \n137:      \n138:         isBridgeAgentFactory[_bridgeAgentFactory] = true;\n139:         bridgeAgentFactories.push(_bridgeAgentFactory);\n140: \n141:         coreRootRouterAddress = _coreRootRouter;\n142:         //@audit NC - missing event emission\n143:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L147C1-L163C6\n\nMissing event emission for state changes from Line 161 to 166:\n\n```solidity\nFile: RootPort.sol\n151:     function initializeCore(\n152:         address _coreRootBridgeAgent,\n153:         address _coreLocalBranchBridgeAgent,\n154:         address _localBranchPortAddress\n155:     ) external onlyOwner {\n156:         require(_coreRootBridgeAgent != address(0), \"Core Root Bridge Agent cannot be 0 address.\");\n157:         require(_coreLocalBranchBridgeAgent != address(0), \"Core Local Branch Bridge Agent cannot be 0 address.\");\n158:         require(_localBranchPortAddress != address(0), \"Local Branch Port Address cannot be 0 address.\");\n159:         require(isBridgeAgent[_coreRootBridgeAgent], \"Core Bridge Agent doesn't exist.\");\n160:         require(_setupCore, \"Core Setup ended.\");\n161:         _setupCore = false;\n162:     \n163:         coreRootBridgeAgentAddress = _coreRootBridgeAgent;\n164:         localBranchPortAddress = _localBranchPortAddress;\n165:         IBridgeAgent(_coreRootBridgeAgent).syncBranchBridgeAgent(_coreLocalBranchBridgeAgent, localChainId);\n166:         getBridgeAgentManager[_coreRootBridgeAgent] = owner();\n167:         //@audit NC - missing event emission\n168:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootBridgeAgent.sol#L105C1-L122C6\n\nMissing event emission for state changes from Line 118 to 124:\n\n```solidity\nFile: RootBridgeAgent.sol\n108:     constructor(\n109:         uint16 _localChainId,\n110:         address _lzEndpointAddress,\n111:         address _localPortAddress,\n112:         address _localRouterAddress\n113:     ) {\n114:         require(_lzEndpointAddress != address(0), \"Layerzero Enpoint Address cannot be zero address\");\n115:         require(_localPortAddress != address(0), \"Port Address cannot be zero address\");\n116:         require(_localRouterAddress != address(0), \"Router Address cannot be zero address\");\n117: \n118:         factoryAddress = msg.sender;\n119:         localChainId = _localChainId;\n120:         lzEndpointAddress = _lzEndpointAddress;\n121:         localPortAddress = _localPortAddress;\n122:         localRouterAddress = _localRouterAddress;\n123:         bridgeAgentExecutorAddress = DeployRootBridgeAgentExecutor.deploy(address(this));\n124:         settlementNonce = 1;\n125:         //@audit NC - missing event emission\n126:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/MulticallRootRouter.sol#L92C1-L100C6\n\nMissing event emission for state variables from Line 96 to 98:\n\n```solidity\nFile: MulticallRootRouter.sol\n092:     constructor(uint256 _localChainId, address _localPortAddress, address _multicallAddress) {\n093:         require(_localPortAddress != address(0), \"Local Port Address cannot be 0\");\n094:         require(_multicallAddress != address(0), \"Multicall Address cannot be 0\");\n095: \n096:         localChainId = _localChainId;\n097:         localPortAddress = _localPortAddress;\n098:         multicallAddress = _multicallAddress;\n099:         _initializeOwner(msg.sender);\n100:         //@audit NC - missing event emission\n101:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/MulticallRootRouter.sol#L109C1-L115C6\n\nMissing event emission for state variables on Lines 113 and 114:\n\n```solidity\nFile: MulticallRootRouter.sol\n110:     function initialize(address _bridgeAgentAddress) external onlyOwner {\n111:         require(_bridgeAgentAddress != address(0), \"Bridge Agent Address cannot be 0\");\n112: \n113:         bridgeAgentAddress = payable(_bridgeAgentAddress);\n114:         bridgeAgentExecutorAddress = IBridgeAgent(_bridgeAgentAddress).bridgeAgentExecutorAddress();\n115:         renounceOwnership();\n116:         //@audit NC - missing event emission\n117:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreRootRouter.sol#L71C1-L77C6\n\nMissing event emission for state variables on Lines 72, 73 and 76: \n\n```solidity\nFile: CoreRootRouter.sol\n71:     constructor(uint256 _rootChainId, address _rootPortAddress) {\n72:         rootChainId = _rootChainId;\n73:         rootPortAddress = _rootPortAddress;\n74: \n75:         _initializeOwner(msg.sender);\n76:         _setup = true;\n77:         //@audit NC - missing event emission\n78:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/CoreBranchRouter.sol#L30C1-L32C6\n\nMissing event emission for `hTokenFactoryAddress` state variable:\n\n```solidity\nFile: CoreBranchRouter.sol\n30:     constructor(address _hTokenFactoryAddress) BaseBranchRouter() {\n31:         hTokenFactoryAddress = _hTokenFactoryAddress;//@audit NC - missing event emission\n32:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L122C1-L132C6\n\nMissing event emission for state variables from Line 129 to 131:\n\n```solidity\nFile: BranchPort.sol\n122:     function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner {\n123:         require(coreBranchRouterAddress == address(0), \"Contract already initialized\");\n124:         require(!isBridgeAgentFactory[_bridgeAgentFactory], \"Contract already initialized\");\n125: \n126:         require(_coreBranchRouter != address(0), \"CoreBranchRouter is zero address\");\n127:         require(_bridgeAgentFactory != address(0), \"BridgeAgentFactory is zero address\");\n128: \n129:         coreBranchRouterAddress = _coreBranchRouter;\n130:         isBridgeAgentFactory[_bridgeAgentFactory] = true;\n131:         bridgeAgentFactories.push(_bridgeAgentFactory);\n132:         //@audit NC - missing event emission\n133:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L319C1-L324C6\n\nMissing event emission for state changes on lines 323 and 324: \n\n```solidity\nFile: BranchPort.sol\n320:     function addBridgeAgent(address _bridgeAgent) external override requiresBridgeAgentFactory {\n321:         if (isBridgeAgent[_bridgeAgent]) revert AlreadyAddedBridgeAgent();\n322: \n323:         isBridgeAgent[_bridgeAgent] = true;\n324:         bridgeAgents.push(_bridgeAgent); \n325:         //@audit NC - missing event emission\n326:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L331C1-L335C6\n\nMissing event emission for state variable on Line 336:\n\n```solidity\nFile: BranchPort.sol\n333:     function setCoreRouter(address _newCoreRouter) external override requiresCoreRouter {\n334:         require(coreBranchRouterAddress != address(0), \"CoreRouter address is zero\");\n335:         require(_newCoreRouter != address(0), \"New CoreRouter address is zero\");\n336:         coreBranchRouterAddress = _newCoreRouter;\n337:         //@audit NC - missing event emission\n338:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L117C1-L143C6\n\nMissing event emission for state variables from Lines 134 to 143:\n\n```solidity\nFile: BranchBridgeAgent.sol\n117:      */\n118:     constructor(\n119:         uint16 _rootChainId,\n120:         uint16 _localChainId,\n121:         address _rootBridgeAgentAddress,\n122:         address _lzEndpointAddress,\n123:         address _localRouterAddress,\n124:         address _localPortAddress\n125:     ) {\n126:         require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n127:         require(\n128:             _lzEndpointAddress != address(0) || _rootChainId == _localChainId,\n129:             \"Layerzero Endpoint Address cannot be the zero address.\"\n130:         );\n131:         require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n132:         require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n133: \n134:         localChainId = _localChainId;\n135:         rootChainId = _rootChainId;\n136:         rootBridgeAgentAddress = _rootBridgeAgentAddress;\n137:         lzEndpointAddress = _lzEndpointAddress;\n138:         localRouterAddress = _localRouterAddress;\n139:         localPortAddress = _localPortAddress;\n140:         bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n141:         depositNonce = 1;\n142: \n143:         rootBridgeAgentPath = abi.encodePacked(_rootBridgeAgentAddress, address(this));\n144:         //@audit NC - missing event emission\n145:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BaseBranchRouter.sol#L60C1-L67C6\n\nMissing event emission for state variables from Lines 62 to 64:\n\n```solidity\nFile: BaseBranchRouter.sol\n60:     function initialize(address _localBridgeAgentAddress) external onlyOwner {\n61:         require(_localBridgeAgentAddress != address(0), \"Bridge Agent address cannot be 0\");\n62:         localBridgeAgentAddress = _localBridgeAgentAddress;\n63:         localPortAddress = IBridgeAgent(_localBridgeAgentAddress).localPortAddress();\n64:         bridgeAgentExecutorAddress = IBridgeAgent(_localBridgeAgentAddress).bridgeAgentExecutorAddress();\n65:         //@audit NC - missing event emission\n66:         renounceOwnership();\n67:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/ArbitrumBranchPort.sol#L38C1-L43C6\n\nMissing event emission for state variables on Lines 41 and 42:\n\n```solidity\nFile: ArbitrumBranchPort.sol\n38:     constructor(uint16 _localChainId, address _rootPortAddress, address _owner) BranchPort(_owner) {\n39:         require(_rootPortAddress != address(0), \"Root Port Address cannot be 0\");\n40: \n41:         localChainId = _localChainId;\n42:         rootPortAddress = _rootPortAddress;\n43:         //@audit NC - missing event emission\n44:     }\n```\n\n</details>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/token/ERC20hTokenRoot.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC20hTokenRoot} from \"../interfaces/IERC20hTokenRoot.sol\";\n\n/// @title ERC20 hToken Contract\n/// @author MaiaDAO\ncontract ERC20hTokenRoot is ERC20, Ownable, IERC20hTokenRoot {\n    /// @inheritdoc IERC20hTokenRoot\n    uint16 public immutable override localChainId;\n\n    /// @inheritdoc IERC20hTokenRoot\n    address public immutable override factoryAddress;\n\n    /// @inheritdoc IERC20hTokenRoot\n    mapping(uint256 chainId => uint256 balance) public override getTokenBalance;\n\n    /**\n     * @notice Constructor for the ERC20hTokenRoot Contract.\n     *     @param _localChainId Local Network Identifier.\n     *     @param _factoryAddress Address of the Factory Contract.\n     *     @param _rootPortAddress Address of the Root Port Contract.\n     *     @param _name Name of the Token.\n     *     @param _symbol Symbol of the Token.\n     *     @param _decimals Decimals of the Token.\n     */\n    constructor(\n        uint16 _localChainId,\n        address _factoryAddress,\n        address _rootPortAddress,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(string(string.concat(_name)), string(string.concat(_symbol)), _decimals) {\n        require(_rootPortAddress != address(0), \"Root Port Address cannot be 0\");\n        require(_factoryAddress != address(0), \"Factory Address cannot be 0\");\n\n        localChainId = _localChainId;\n        factoryAddress = _factoryAddress;\n        _initializeOwner(_rootPortAddress);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new tokens and updates the total supply for the given chain.\n     * @param to Address to mint tokens to.\n     * @param amount Amount of tokens to mint.\n     * @param chainId Chain Id of the chain to mint tokens to.\n     */\n    function mint(address to, uint256 amount, uint256 chainId) external onlyOwner returns (bool) {\n        getTokenBalance[chainId] += amount;\n        _mint(to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Burns new tokens and updates the total supply for the given chain.\n     * @param from Address to burn tokens from.\n     * @param amount Amount of tokens to burn.\n     * @param chainId Chain Id of the chain to burn tokens to.\n     */\n    function burn(address from, uint256 amount, uint256 chainId) external onlyOwner {\n        getTokenBalance[chainId] -= amount;\n        _burn(from, amount);\n    }\n}"
    },
    {
      "filename": "src/factories/ERC20hTokenRootFactory.sol",
      "content": "// // SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC20hTokenRootFactory, ERC20hTokenRoot} from \"../interfaces/IERC20hTokenRootFactory.sol\";\n\n/// @title ERC20 hToken Root Factory Contract\n/// @author MaiaDAO\ncontract ERC20hTokenRootFactory is Ownable, IERC20hTokenRootFactory {\n    /// @notice Local Network Identifier.\n    uint16 public immutable localChainId;\n\n    /// @notice Root Port Address.\n    address public immutable rootPortAddress;\n\n    /// @notice Root Core Router Address, in charge of the addition of new tokens to the system.\n    address public coreRootRouterAddress;\n\n    /// @notice Array of all hTokens created.\n    ERC20hTokenRoot[] public hTokens;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for ERC20 hToken Root Factory Contract\n     *     @param _localChainId Local Network Layer Zerio Identifier.\n     *     @param _rootPortAddress Root Port Address.\n     */\n    constructor(uint16 _localChainId, address _rootPortAddress) {\n        require(_rootPortAddress != address(0), \"Root Port Address cannot be 0\");\n        localChainId = _localChainId;\n        rootPortAddress = _rootPortAddress;\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to initialize the contract.\n     * @param _coreRouter Address of the Root Chain's Core Router.\n     */\n    function initialize(address _coreRouter) external onlyOwner {\n        require(_coreRouter != address(0), \"CoreRouter address cannot be 0\");\n        coreRootRouterAddress = _coreRouter;\n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to get the array of hTokens.\n     * @return Array of hTokens.\n     */\n    function getHTokens() external view returns (ERC20hTokenRoot[] memory) {\n        return hTokens;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    hTOKEN FACTORY EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Function to create a new hToken.\n     * @param _name Name of the Token.\n     * @param _symbol Symbol of the Token.\n     * @param _decimals Decimals of the Token.\n     */\n    function createToken(string memory _name, string memory _symbol, uint8 _decimals)\n        external\n        requiresCoreRouterOrPort\n        returns (ERC20hTokenRoot newToken)\n    {\n        newToken = new ERC20hTokenRoot(\n            localChainId,\n            address(this),\n            rootPortAddress,\n            _name,\n            _symbol,\n            _decimals\n        );\n        hTokens.push(newToken);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Modifier that verifies msg sender is the RootInterface Contract from Root Chain.\n    modifier requiresCoreRouterOrPort() {\n        if (msg.sender != coreRootRouterAddress) {\n            if (msg.sender != rootPortAddress) {\n                revert UnrecognizedCoreRouterOrPort();\n            }\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/factories/ERC20hTokenRootFactory.sol",
      "content": "// // SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC20hTokenRootFactory, ERC20hTokenRoot} from \"../interfaces/IERC20hTokenRootFactory.sol\";\n\n/// @title ERC20 hToken Root Factory Contract\n/// @author MaiaDAO\ncontract ERC20hTokenRootFactory is Ownable, IERC20hTokenRootFactory {\n    /// @notice Local Network Identifier.\n    uint16 public immutable localChainId;\n\n    /// @notice Root Port Address.\n    address public immutable rootPortAddress;\n\n    /// @notice Root Core Router Address, in charge of the addition of new tokens to the system.\n    address public coreRootRouterAddress;\n\n    /// @notice Array of all hTokens created.\n    ERC20hTokenRoot[] public hTokens;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for ERC20 hToken Root Factory Contract\n     *     @param _localChainId Local Network Layer Zerio Identifier.\n     *     @param _rootPortAddress Root Port Address.\n     */\n    constructor(uint16 _localChainId, address _rootPortAddress) {\n        require(_rootPortAddress != address(0), \"Root Port Address cannot be 0\");\n        localChainId = _localChainId;\n        rootPortAddress = _rootPortAddress;\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to initialize the contract.\n     * @param _coreRouter Address of the Root Chain's Core Router.\n     */\n    function initialize(address _coreRouter) external onlyOwner {\n        require(_coreRouter != address(0), \"CoreRouter address cannot be 0\");\n        coreRootRouterAddress = _coreRouter;\n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to get the array of hTokens.\n     * @return Array of hTokens.\n     */\n    function getHTokens() external view returns (ERC20hTokenRoot[] memory) {\n        return hTokens;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    hTOKEN FACTORY EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Function to create a new hToken.\n     * @param _name Name of the Token.\n     * @param _symbol Symbol of the Token.\n     * @param _decimals Decimals of the Token.\n     */\n    function createToken(string memory _name, string memory _symbol, uint8 _decimals)\n        external\n        requiresCoreRouterOrPort\n        returns (ERC20hTokenRoot newToken)\n    {\n        newToken = new ERC20hTokenRoot(\n            localChainId,\n            address(this),\n            rootPortAddress,\n            _name,\n            _symbol,\n            _decimals\n        );\n        hTokens.push(newToken);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Modifier that verifies msg sender is the RootInterface Contract from Root Chain.\n    modifier requiresCoreRouterOrPort() {\n        if (msg.sender != coreRootRouterAddress) {\n            if (msg.sender != rootPortAddress) {\n                revert UnrecognizedCoreRouterOrPort();\n            }\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/factories/ERC20hTokenBranchFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"../token/ERC20hTokenBranch.sol\";\n\nimport {IERC20hTokenBranchFactory, ERC20hTokenBranch} from \"../interfaces/IERC20hTokenBranchFactory.sol\";\n\n/// @title ERC20hTokenBranch Factory Contract\n/// @author MaiaDAO\ncontract ERC20hTokenBranchFactory is Ownable, IERC20hTokenBranchFactory {\n    /// @notice Local Network Identifier.\n    uint24 public immutable localChainId;\n\n    /// @notice Local Port Address\n    address public immutable localPortAddress;\n\n    /// @notice Local Branch Core Router Address responsible for the addition of new tokens to the system.\n    address public localCoreRouterAddress;\n\n    /// @notice Local hTokens deployed in the current chain.\n    ERC20hTokenBranch[] public hTokens;\n\n    /// @notice Name of the chain for token name prefix.\n    string public chainName;\n\n    /// @notice Symbol of the chain for token symbol prefix.\n    string public chainSymbol;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for ERC20 hToken Branch Factory Contract\n     *     @param _localChainId Local Network layer Zero Identifier.\n     *     @param _localPortAddress Local Chain Port Address.\n     *     @param _chainName Name of the chain for token name prefix.\n     *     @param _chainSymbol Symbol of the chain for token symbol prefix.\n     */\n    constructor(uint16 _localChainId, address _localPortAddress, string memory _chainName, string memory _chainSymbol) {\n        require(_localPortAddress != address(0), \"Port address cannot be 0\");\n        chainName = string.concat(_chainName, \" Ulysses\");\n        chainSymbol = string.concat(_chainSymbol, \"-u\");\n        localChainId = _localChainId;\n        localPortAddress = _localPortAddress;\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to initialize the contract.\n     * @param _wrappedNativeTokenAddress Address of the Local Chain's wrapped native token.\n     * @param _coreRouter Address of the Local Chain's Core Router.\n     */\n    function initialize(address _wrappedNativeTokenAddress, address _coreRouter) external onlyOwner {\n        require(_coreRouter != address(0), \"CoreRouter address cannot be 0\");\n\n        ERC20hTokenBranch newToken = new ERC20hTokenBranch(\n            chainName,\n            chainSymbol,\n            ERC20(_wrappedNativeTokenAddress).name(),\n            ERC20(_wrappedNativeTokenAddress).symbol(),\n            ERC20(_wrappedNativeTokenAddress).decimals(),\n            localPortAddress\n        );\n\n        hTokens.push(newToken);\n\n        localCoreRouterAddress = _coreRouter;\n\n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to get the array of hTokens.\n     * @return Array of hTokens.\n     */\n    function getHTokens() external view returns (ERC20hTokenBranch[] memory) {\n        return hTokens;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    hTOKEN FACTORY EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    \n    /// @inheritdoc IERC20hTokenBranchFactory\n    function createToken(string memory _name, string memory _symbol, uint8 _decimals, bool _addPrefix)\n        external\n        requiresCoreRouter\n        returns (ERC20hTokenBranch newToken)\n    {\n        newToken = _addPrefix\n            ? new ERC20hTokenBranch(chainName, chainSymbol, _name, _symbol, _decimals, localPortAddress)\n            : new ERC20hTokenBranch(\"\", \"\", _name, _symbol, _decimals, localPortAddress);\n        hTokens.push(newToken);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the RootInterface Contract from Root Chain.\n    modifier requiresCoreRouter() {\n        if (msg.sender != localCoreRouterAddress) revert UnrecognizedCoreRouter();\n        _;\n    }\n}"
    },
    {
      "filename": "src/factories/ERC20hTokenBranchFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"../token/ERC20hTokenBranch.sol\";\n\nimport {IERC20hTokenBranchFactory, ERC20hTokenBranch} from \"../interfaces/IERC20hTokenBranchFactory.sol\";\n\n/// @title ERC20hTokenBranch Factory Contract\n/// @author MaiaDAO\ncontract ERC20hTokenBranchFactory is Ownable, IERC20hTokenBranchFactory {\n    /// @notice Local Network Identifier.\n    uint24 public immutable localChainId;\n\n    /// @notice Local Port Address\n    address public immutable localPortAddress;\n\n    /// @notice Local Branch Core Router Address responsible for the addition of new tokens to the system.\n    address public localCoreRouterAddress;\n\n    /// @notice Local hTokens deployed in the current chain.\n    ERC20hTokenBranch[] public hTokens;\n\n    /// @notice Name of the chain for token name prefix.\n    string public chainName;\n\n    /// @notice Symbol of the chain for token symbol prefix.\n    string public chainSymbol;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for ERC20 hToken Branch Factory Contract\n     *     @param _localChainId Local Network layer Zero Identifier.\n     *     @param _localPortAddress Local Chain Port Address.\n     *     @param _chainName Name of the chain for token name prefix.\n     *     @param _chainSymbol Symbol of the chain for token symbol prefix.\n     */\n    constructor(uint16 _localChainId, address _localPortAddress, string memory _chainName, string memory _chainSymbol) {\n        require(_localPortAddress != address(0), \"Port address cannot be 0\");\n        chainName = string.concat(_chainName, \" Ulysses\");\n        chainSymbol = string.concat(_chainSymbol, \"-u\");\n        localChainId = _localChainId;\n        localPortAddress = _localPortAddress;\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to initialize the contract.\n     * @param _wrappedNativeTokenAddress Address of the Local Chain's wrapped native token.\n     * @param _coreRouter Address of the Local Chain's Core Router.\n     */\n    function initialize(address _wrappedNativeTokenAddress, address _coreRouter) external onlyOwner {\n        require(_coreRouter != address(0), \"CoreRouter address cannot be 0\");\n\n        ERC20hTokenBranch newToken = new ERC20hTokenBranch(\n            chainName,\n            chainSymbol,\n            ERC20(_wrappedNativeTokenAddress).name(),\n            ERC20(_wrappedNativeTokenAddress).symbol(),\n            ERC20(_wrappedNativeTokenAddress).decimals(),\n            localPortAddress\n        );\n\n        hTokens.push(newToken);\n\n        localCoreRouterAddress = _coreRouter;\n\n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to get the array of hTokens.\n     * @return Array of hTokens.\n     */\n    function getHTokens() external view returns (ERC20hTokenBranch[] memory) {\n        return hTokens;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    hTOKEN FACTORY EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    \n    /// @inheritdoc IERC20hTokenBranchFactory\n    function createToken(string memory _name, string memory _symbol, uint8 _decimals, bool _addPrefix)\n        external\n        requiresCoreRouter\n        returns (ERC20hTokenBranch newToken)\n    {\n        newToken = _addPrefix\n            ? new ERC20hTokenBranch(chainName, chainSymbol, _name, _symbol, _decimals, localPortAddress)\n            : new ERC20hTokenBranch(\"\", \"\", _name, _symbol, _decimals, localPortAddress);\n        hTokens.push(newToken);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the RootInterface Contract from Root Chain.\n    modifier requiresCoreRouter() {\n        if (msg.sender != localCoreRouterAddress) revert UnrecognizedCoreRouter();\n        _;\n    }\n}"
    },
    {
      "filename": "src/factories/BranchBridgeAgentFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {DeployBranchBridgeAgent} from \"../BranchBridgeAgent.sol\";\n\nimport {IBranchPort as IPort} from \"../interfaces/IBranchPort.sol\";\nimport {IBranchBridgeAgentFactory} from \"../interfaces/IBranchBridgeAgentFactory.sol\";\n\n/**\n * @title Branch Bridge Agent Factory Contract\n * @author MaiaDAO\n * @notice Factory contract for allowing permissionless deployment of\n *         new Branch Bridge Agents which are in charge of\n *         managing the deposit and withdrawal of assets between the\n *         branch chains and the omnichain environment.\n */\ncontract BranchBridgeAgentFactory is Ownable, IBranchBridgeAgentFactory {\n    /// @notice Local Chain Id.\n    uint16 public immutable localChainId;\n\n    /// @notice Root Chain Id.\n    uint16 public immutable rootChainId;\n\n    /// @notice Root Bridge Agent Factory Address.\n    address public immutable rootBridgeAgentFactoryAddress;\n\n    /// @notice Local Core Branch Router Address.\n    address public immutable localCoreBranchRouterAddress;\n\n    /// @notice Root Port Address.\n    address public immutable localPortAddress;\n\n    /// @notice Local Layer Zero Endpoint for cross-chain communication.\n    address public immutable lzEndpointAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _localChainId Local Chain Layer Zero Id.\n     *     @param _rootChainId Root Chain Layer Zero Id.\n     *     @param _rootBridgeAgentFactoryAddress Root Bridge Agent Factory Address.\n     *     @param _lzEndpointAddress Layer Zero Endpoint for cross-chain communication.\n     *     @param _localCoreBranchRouterAddress Local Core Branch Router Address.\n     *     @param _localPortAddress Local Branch Port Address.\n     *     @param _owner Owner of the contract.\n     */\n    constructor(\n        uint16 _localChainId,\n        uint16 _rootChainId,\n        address _rootBridgeAgentFactoryAddress,\n        address _lzEndpointAddress,\n        address _localCoreBranchRouterAddress,\n        address _localPortAddress,\n        address _owner\n    ) {\n        require(_rootBridgeAgentFactoryAddress != address(0), \"Root Bridge Agent Factory Address cannot be 0\");\n        require(\n            _lzEndpointAddress != address(0) || _rootChainId == _localChainId,\n            \"Layerzero Endpoint Address cannot be the zero address.\"\n        );\n        require(_localCoreBranchRouterAddress != address(0), \"Core Branch Router Address cannot be 0\");\n        require(_localPortAddress != address(0), \"Port Address cannot be 0\");\n        require(_owner != address(0), \"Owner cannot be 0\");\n\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentFactoryAddress = _rootBridgeAgentFactoryAddress;\n        lzEndpointAddress = _lzEndpointAddress;\n        localCoreBranchRouterAddress = _localCoreBranchRouterAddress;\n        localPortAddress = _localPortAddress;\n        _initializeOwner(_owner);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to initialize the contract.\n     * @param _coreRootBridgeAgent Address of the Root Chain's Core Root Bridge Agent.\n     */\n    function initialize(address _coreRootBridgeAgent) external virtual onlyOwner {\n        require(_coreRootBridgeAgent != address(0), \"Core Root Bridge Agent cannot be 0\");\n\n        address newCoreBridgeAgent = address(\n            DeployBranchBridgeAgent.deploy(\n                rootChainId,\n                localChainId,\n                _coreRootBridgeAgent,\n                lzEndpointAddress,\n                localCoreBranchRouterAddress,\n                localPortAddress\n            )\n        );\n\n        IPort(localPortAddress).addBridgeAgent(newCoreBridgeAgent);\n\n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                BRIDGE AGENT FACTORY EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Creates a new bridge agent for a new branch chain.\n     * @param _newBranchRouterAddress Address of the new branch router.\n     * @param _rootBridgeAgentAddress Address of the root bridge agent to connect to.\n     */\n    function createBridgeAgent(\n        address _newBranchRouterAddress,\n        address _rootBridgeAgentAddress,\n        address _rootBridgeAgentFactoryAddress\n    ) external virtual returns (address newBridgeAgent) {\n        require(\n            msg.sender == localCoreBranchRouterAddress, \"Only the Core Branch Router can create a new Bridge Agent.\"\n        );\n        require(\n            _rootBridgeAgentFactoryAddress == rootBridgeAgentFactoryAddress,\n            \"Root Bridge Agent Factory Address does not match.\"\n        );\n\n        newBridgeAgent = address(\n            DeployBranchBridgeAgent.deploy(\n                rootChainId,\n                localChainId,\n                _rootBridgeAgentAddress,\n                lzEndpointAddress,\n                _newBranchRouterAddress,\n                localPortAddress\n            )\n        );\n\n        IPort(localPortAddress).addBridgeAgent(newBridgeAgent);\n    }\n}"
    },
    {
      "filename": "src/VirtualAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\nimport {ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IVirtualAccount, Call, PayableCall} from \"./interfaces/IVirtualAccount.sol\";\nimport {IRootPort} from \"./interfaces/IRootPort.sol\";\n\n/// @title VirtualAccount - Contract for managing a virtual user account on the Root Chain\ncontract VirtualAccount is IVirtualAccount, ERC1155Receiver {\n    using SafeTransferLib for address;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override userAddress;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override localPortAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Virtual Account.\n     * @param _userAddress Address of the user account.\n     * @param _localPortAddress Address of the root port contract.\n     */\n    constructor(address _userAddress, address _localPortAddress) {\n        userAddress = _userAddress;\n        localPortAddress = _localPortAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawNative(uint256 _amount) external override requiresApprovedCaller {\n        msg.sender.safeTransferETH(_amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC20(address _token, uint256 _amount) external override requiresApprovedCaller {\n        _token.safeTransfer(msg.sender, _amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC721(address _token, uint256 _tokenId) external override requiresApprovedCaller {\n        ERC721(_token).transferFrom(address(this), msg.sender, _tokenId);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function call(Call[] calldata calls) external override requiresApprovedCaller returns (bytes[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n\n        for (uint256 i = 0; i < length;) {\n            bool success;\n            Call calldata _call = calls[i];\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        PayableCall calldata _call;\n        for (uint256 i = 0; i < length;) {\n            _call = calls[i];\n            uint256 val = _call.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n\n            bool success;\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call{value: val}(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        if (msg.value != valAccumulator) revert CallFailed();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the approved to use the virtual account. Either the owner or an approved router.\n    modifier requiresApprovedCaller() {\n        if (!IRootPort(localPortAddress).isRouterApproved(this, msg.sender)) {\n            if (msg.sender != userAddress) {\n                revert UnauthorizedCaller();\n            }\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/RootPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {IERC20hTokenRootFactory} from \"./interfaces/IERC20hTokenRootFactory.sol\";\nimport {IRootBridgeAgent as IBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IRootPort, ICoreRootRouter, GasParams, VirtualAccount} from \"./interfaces/IRootPort.sol\";\n\nimport {ERC20hTokenRoot} from \"./token/ERC20hTokenRoot.sol\";\n\n/// @title Root Port - Omnichain Token Management Contract\n/// @author MaiaDAO\ncontract RootPort is Ownable, IRootPort {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETUP STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice True if setup is still ongoing, false otherwise.\n    bool internal _setup;\n\n    /// @notice True if core setup is still ongoing, false otherwise.\n    bool internal _setupCore;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT PORT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint256 public immutable localChainId;\n\n    /// @notice The address of local branch port responsible for handling local transactions.\n    address public localBranchPortAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootRouterAddress;\n\n    /// @notice The address of the core router in charge of adding new tokens to the system.\n    address public coreRootBridgeAgentAddress;\n\n    /*//////////////////////////////////////////////////////////////"
    }
  ]
}