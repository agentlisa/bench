{
  "Title": "M-13: First ERC4626 deposit can break share calculation",
  "Content": "# Issue M-13: First ERC4626 deposit can break share calculation \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/143 \n\n## Found by \npashov, ctf\\_sec, neila, rvierdiiev, \\_\\_141345\\_\\_, ak1, 0xNazgul, Jeiwan, joestakey\n\n## Summary\nThe first depositor of an ERC4626 vault can maliciously manipulate the share price by depositing the lowest possible amount (1 wei) of liquidity and then artificially inflating ERC4626.totalAssets.\n\nThis can inflate the base share price as high as 1:1e18 early on, which force all subsequence deposit to use this share price as a base and worst case, due to rounding down, if this malicious initial deposit front-run someone else depositing, this depositor will receive 0 shares and lost his deposited assets.\n\n## Vulnerability Detail\nGiven a vault with DAI as the underlying asset:\n\nAlice (attacker) deposits initial liquidity of 1 wei DAI via `deposit()`\nAlice receives 1e18 (1 wei) vault shares\nAlice transfers 1 ether of DAI via transfer() to the vault to artificially inflate the asset balance without minting new shares. The asset balance is now 1 ether + 1 wei DAI -> vault share price is now very high (= 1000000000000000000001 wei ~ 1000 * 1e18)\nBob (victim) deposits 100 ether DAI\nBob receives 0 shares\nBob receives 0 shares due to a precision issue. His deposited funds are lost.\n\nThe shares are calculated as following \n`return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());`\nIn case of a very high share price, due to totalAssets() > assets * supply, shares will be 0.\n## Impact\n`ERC4626` vault share price can be maliciously inflated on the initial deposit, leading to the next depositor losing assets due to precision issues.\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L392\n## Tool used\n\nManual Review\n\n## Recommendation\nThis is a well-known issue, Uniswap and other protocols had similar issues when supply == 0.\n\nFor the first deposit, mint a fixed amount of shares, e.g. 10**decimals()\n```jsx\nif (supply == 0) {\n    return 10**decimals; \n} else {\n    return assets.mulDivDown(supply, totalAssets());\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "lib/astaria-gpl/src/ERC4626-Cloned.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.16;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n// owner (20) -> underlying (ERC20 address) ,\n\ninterface ITokenBase {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n}\n\ninterface IERC4646Base is ITokenBase {\n  function underlying() external view returns (address);\n}\n\ninterface IAstariaVaultBase is IERC4646Base {\n  function owner() external view returns (address);\n\n  function COLLATERAL_TOKEN() external view returns (address);\n\n  function ROUTER() external view returns (address);\n\n  function AUCTION_HOUSE() external view returns (address);\n\n  function START() external view returns (uint256);\n\n  function EPOCH_LENGTH() external view returns (uint256);\n\n  function VAULT_TYPE() external view returns (uint8);\n\n  function VAULT_FEE() external view returns (uint256);\n}\n\nabstract contract ERC4626Base is Clone, IERC4646Base {\n  function underlying() public view virtual returns (address);\n}\n\n//abstract contract TokenBase is Clone, ITokenCloneBase {\n//    function name() external virtual view returns (string memory);\n//\n//    function symbol() external virtual view returns (string memory);\n//}\nabstract contract WithdrawVaultBase is ERC4626Base {\n  function name() public view virtual returns (string memory);\n\n  function symbol() public view virtual returns (string memory);\n\n  function owner() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function underlying()\n    public\n    view\n    virtual\n    override(ERC4626Base)\n    returns (address)\n  {\n    return _getArgAddress(20);\n  }\n}\n\nabstract contract AstariaVaultBase is ERC4626Base, IAstariaVaultBase {\n  function name() public view virtual returns (string memory);\n\n  function symbol() public view virtual returns (string memory);\n\n  function owner() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function underlying()\n    public\n    view\n    virtual\n    override(IERC4646Base, ERC4626Base)\n    returns (address)\n  {\n    return _getArgAddress(20);\n  }\n\n  function COLLATERAL_TOKEN() public view returns (address) {\n    return _getArgAddress(40);\n  }\n\n  function ROUTER() public view returns (address) {\n    return _getArgAddress(60);\n  }\n\n  function AUCTION_HOUSE() public view returns (address) {\n    return _getArgAddress(80);\n  }\n\n  function START() public view returns (uint256) {\n    return _getArgUint256(100);\n  }\n\n  function EPOCH_LENGTH() public view returns (uint256) {\n    return _getArgUint256(132);\n  }\n\n  function VAULT_TYPE() public view returns (uint8) {\n    return _getArgUint8(164);\n  }\n\n  function VAULT_FEE() public view returns (uint256) {\n    return _getArgUint256(172);\n  }\n}\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\n\nabstract contract ERC20Cloned is ITokenBase {\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n\n  uint256 _totalSupply;\n\n  mapping(address => uint256) public balanceOf;\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  mapping(address => uint256) public nonces;\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    returns (bool)\n  {\n    allowance[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) public virtual returns (bool) {\n    balanceOf[msg.sender] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(msg.sender, to, amount);\n\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual returns (bool) {\n    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n    if (allowed != type(uint256).max) {\n      allowance[from][msg.sender] = allowed - amount;\n    }\n\n    balanceOf[from] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual {\n    require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n    // Unchecked because the only math done is incrementing\n    // the owner's nonce which cannot realistically overflow.\n    unchecked {\n      address recoveredAddress = ecrecover(\n        keccak256(\n          abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR(),\n            keccak256(\n              abi.encode(\n                keccak256(\n                  \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                ),\n                owner,\n                spender,\n                value,\n                nonces[owner]++,\n                deadline\n              )\n            )\n          )\n        ),\n        v,\n        r,\n        s\n      );\n\n      require(\n        recoveredAddress != address(0) && recoveredAddress == owner,\n        \"INVALID_SIGNER\"\n      );\n\n      allowance[recoveredAddress][spender] = value;\n    }\n\n    emit Approval(owner, spender, value);\n  }\n\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n    return computeDomainSeparator();\n  }\n\n  function computeDomainSeparator() internal view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\n            \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n          ),\n          keccak256(\"1\"),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  function _mint(address to, uint256 amount) internal virtual {\n    _totalSupply += amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal virtual {\n    balanceOf[from] -= amount;\n\n    // Cannot underflow because a user's balance\n    // will never be larger than the total supply.\n    unchecked {\n      _totalSupply -= amount;\n    }\n\n    emit Transfer(from, address(0), amount);\n  }\n}\n\ninterface IVault {\n  function deposit(uint256, address) external returns (uint256);\n}\n\nabstract contract ERC4626Cloned is ERC20Cloned, ERC4626Base, IVault {\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    override(IVault)\n    returns (uint256 shares)\n  {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function mint(uint256 shares, address receiver)\n    public\n    virtual\n    returns (uint256 assets)\n  {\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual returns (uint256 shares) {\n    shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    ERC20(underlying()).safeTransfer(receiver, assets);\n  }\n\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual returns (uint256 assets) {\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    // Check for rounding error since we round down in previewRedeem.\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    ERC20(underlying()).safeTransfer(receiver, assets);\n  }\n\n  function totalAssets() public view virtual returns (uint256);\n\n  function convertToShares(uint256 assets)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n  }\n\n  function convertToAssets(uint256 shares)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n  }\n\n  function previewDeposit(uint256 assets)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    return convertToShares(assets);\n  }\n\n  function previewMint(uint256 shares) public view virtual returns (uint256) {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n  }\n\n  function previewWithdraw(uint256 assets)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n  }\n\n  function totalSupply() public view virtual returns (uint256) {\n    return _totalSupply;\n  }\n\n  function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n    return convertToAssets(shares);\n  }\n\n  function maxDeposit(address) public view virtual returns (uint256) {\n    return type(uint256).max;\n  }\n\n  function maxMint(address) public view virtual returns (uint256) {\n    return type(uint256).max;\n  }\n\n  function maxWithdraw(address owner) public view virtual returns (uint256) {\n    return convertToAssets(balanceOf[owner]);\n  }\n\n  function maxRedeem(address owner) public view virtual returns (uint256) {\n    return balanceOf[owner];\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n  function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    }
  ]
}