{
  "Title": "TypeScript Inconsistency",
  "Content": "The codebase makes extensive use of TypeScript types to validate consistency and improve code clarity. Here are some instances that could benefit from more consistent types:\n\n\n* [`renderCommonData`](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/common/src/codegen/render-solidity/common.ts#L32) and [`fieldPortionData`](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/store/ts/codegen/field.ts#L255) could return a named type instead of an arbitrary object.\n* The argument type for [`renderCommonData`](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/common/src/codegen/render-solidity/common.ts#L32) and [`renderTypeHelpers`](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/common/src/codegen/render-solidity/renderTypeHelpers.ts#L3) could [`Pick`](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys) from `RenderTableOptions`.\n* [`renderTightCoderDecode`](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/store/ts/codegen/tightcoder/renderFunctions.ts#L3) and [`renderTightCoderEncode`](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/store/ts/codegen/tightcoder/renderFunctions.ts#L28) could `Pick` from `RenderType`.\n\n\n***Update:** Partially resolved in [pull request #2121](https://github.com/latticexyz/mud/pull/2121) and [pull request #2185](https://github.com/latticexyz/mud/pull/2185). The Lattice Labs team stated:*\n\n\n\n> *`RenderTableOptions` is a store package concept and importing that into the common package for reuse would create a circular dependency and the codegen utils in the common package have no real knowledge of tables. Going to punt on this change.*\n> \n> \n> *Also going to punt on notes for `renderCommonData` and `fieldPortionData` as they are more stylistic suggestions and do not seem entirely necessary. Will save any cleanup of this for a larger refactor of the codegen utils.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/common/src/codegen/render-solidity/common.ts",
      "content": "import path from \"path\";\nimport {\n  AbsoluteImportDatum,\n  RelativeImportDatum,\n  ImportDatum,\n  StaticResourceData,\n  RenderKeyTuple,\n  RenderType,\n} from \"./types\";\nimport { posixPath } from \"../utils\";\n\nexport const renderedSolidityHeader = `// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */`;\n\n/**\n * Renders a list of lines\n */\nexport function renderList<T>(list: T[], renderItem: (item: T, index: number) => string): string {\n  return internalRenderList(\"\", list, renderItem);\n}\n\n/**\n * Renders a comma-separated list of arguments for solidity functions, ignoring empty and undefined ones\n */\nexport function renderArguments(args: (string | undefined)[]): string {\n  const filteredArgs = args.filter((arg) => arg !== undefined && arg !== \"\") as string[];\n  return internalRenderList(\",\", filteredArgs, (arg) => arg);\n}\n\nexport function renderCommonData({\n  staticResourceData,\n  keyTuple,\n}: {\n  staticResourceData?: StaticResourceData;\n  keyTuple: RenderKeyTuple[];\n}): {\n  _tableId: string;\n  _typedTableId: string;\n  _keyArgs: string;\n  _typedKeyArgs: string;\n  _keyTupleDefinition: string;\n} {\n  // static resource means static tableId as well, and no tableId arguments\n  const _tableId = staticResourceData ? \"\" : \"_tableId\";\n  const _typedTableId = staticResourceData ? \"\" : \"ResourceId _tableId\";\n\n  const _keyArgs = renderArguments(keyTuple.map(({ name }) => name));\n  const _typedKeyArgs = renderArguments(keyTuple.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n\n  const _keyTupleDefinition = `\n    bytes32[] memory _keyTuple = new bytes32[](${keyTuple.length});\n    ${renderList(keyTuple, (key, index) => `_keyTuple[${index}] = ${renderValueTypeToBytes32(key.name, key)};`)}\n  `;\n\n  return {\n    _tableId,\n    _typedTableId,\n    _keyArgs,\n    _typedKeyArgs,\n    _keyTupleDefinition,\n  };\n}\n\n/** For 2 paths which are relative to a common root, create a relative import path from one to another */\nexport function solidityRelativeImportPath(fromPath: string, usedInPath: string): string {\n  // 1st \"./\" must be added because path strips it,\n  // but solidity expects it unless there's \"../\" (\"./../\" is fine).\n  // 2nd and 3rd \"./\" forcefully avoid absolute paths (everything is relative to `src`).\n  return posixPath(\"./\" + path.relative(\"./\" + usedInPath, \"./\" + fromPath));\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderImports(imports: ImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map((importDatum) => {\n      if (\"path\" in importDatum) {\n        return importDatum;\n      } else {\n        return {\n          symbol: importDatum.symbol,\n          path: solidityRelativeImportPath(importDatum.fromPath, importDatum.usedInPath),\n        };\n      }\n    })\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderRelativeImports(imports: RelativeImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map(({ symbol, fromPath, usedInPath }) => ({\n      symbol,\n      path: solidityRelativeImportPath(fromPath, usedInPath),\n    }))\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderAbsoluteImports(imports: AbsoluteImportDatum[]): string {\n  // Aggregate symbols by import path, also deduplicating them\n  const aggregatedImports = new Map<string, Set<string>>();\n  for (const { symbol, path } of imports) {\n    if (!aggregatedImports.has(path)) {\n      aggregatedImports.set(path, new Set());\n    }\n    aggregatedImports.get(path)?.add(symbol);\n  }\n  // Render imports\n  const renderedImports = [];\n  for (const [path, symbols] of aggregatedImports) {\n    const renderedSymbols = [...symbols].join(\", \");\n    renderedImports.push(`import { ${renderedSymbols} } from \"${posixPath(path)}\";`);\n  }\n  return renderedImports.join(\"\\n\");\n}\n\nexport function renderWithStore(\n  storeArgument: boolean,\n  callback: (\n    _typedStore: string | undefined,\n    _store: string,\n    _commentSuffix: string,\n    _untypedStore: string | undefined,\n    _methodPrefix: string,\n    _internal?: boolean\n  ) => string\n): string {\n  let result = \"\";\n  result += callback(undefined, \"StoreSwitch\", \"\", undefined, \"\");\n  result += callback(undefined, \"StoreCore\", \"\", undefined, \"_\", true);\n\n  if (storeArgument) {\n    result += \"\\n\" + callback(\"IStore _store\", \"_store\", \" (using the specified store)\", \"_store\", \"\");\n  }\n\n  return result;\n}\n\nexport function renderWithFieldSuffix(\n  withSuffixlessFieldMethods: boolean,\n  fieldName: string,\n  callback: (_methodNameSuffix: string) => string\n): string {\n  const methodNameSuffix = `${fieldName[0].toUpperCase()}${fieldName.slice(1)}`;\n  let result = \"\";\n  result += callback(methodNameSuffix);\n\n  if (withSuffixlessFieldMethods) {\n    result += \"\\n\" + callback(\"\");\n  }\n\n  return result;\n}\n\nexport function renderTableId({ namespace, name, offchainOnly, tableIdName }: StaticResourceData): {\n  hardcodedTableId: string;\n  tableIdDefinition: string;\n} {\n  const hardcodedTableId = `\n    ResourceId.wrap(\n      bytes32(\n        abi.encodePacked(\n          ${offchainOnly ? \"RESOURCE_OFFCHAIN_TABLE\" : \"RESOURCE_TABLE\"},\n          bytes14(\"${namespace}\"),\n          bytes16(\"${name}\")\n        )\n      )\n    )\n  `;\n\n  const tableIdDefinition = `\n    ResourceId constant _tableId = ${hardcodedTableId};\n    ResourceId constant ${tableIdName} = _tableId;\n  `;\n  return {\n    hardcodedTableId,\n    tableIdDefinition,\n  };\n}\n\nexport function renderValueTypeToBytes32(name: string, { typeUnwrap, internalTypeId }: RenderType): string {\n  const innerText = typeUnwrap.length ? `${typeUnwrap}(${name})` : name;\n\n  if (internalTypeId === \"bytes32\") {\n    return innerText;\n  } else if (internalTypeId.match(/^bytes\\d{1,2}$/)) {\n    return `bytes32(${innerText})`;\n  } else if (internalTypeId.match(/^uint\\d{1,3}$/)) {\n    return `bytes32(uint256(${innerText}))`;\n  } else if (internalTypeId.match(/^int\\d{1,3}$/)) {\n    return `bytes32(uint256(int256(${innerText})))`;\n  } else if (internalTypeId === \"address\") {\n    return `bytes32(uint256(uint160(${innerText})))`;\n  } else if (internalTypeId === \"bool\") {\n    return `_boolToBytes32(${innerText})`;\n  } else {\n    throw new Error(`Unknown value type id ${internalTypeId}`);\n  }\n}\n\nexport function isLeftAligned(field: Pick<RenderType, \"internalTypeId\">): boolean {\n  return field.internalTypeId.match(/^bytes\\d{1,2}$/) !== null;\n}\n\nexport function getLeftPaddingBits(field: Pick<RenderType, \"internalTypeId\" | \"staticByteLength\">): number {\n  if (isLeftAligned(field)) {\n    return 0;\n  } else {\n    return 256 - field.staticByteLength * 8;\n  }\n}\n\nfunction internalRenderList<T>(\n  lineTerminator: string,\n  list: T[],\n  renderItem: (item: T, index: number) => string\n): string {\n  return list\n    .map((item, index) => renderItem(item, index) + (index === list.length - 1 ? \"\" : lineTerminator))\n    .join(\"\\n\");\n}"
    },
    {
      "filename": "packages/common/src/codegen/render-solidity/common.ts",
      "content": "import path from \"path\";\nimport {\n  AbsoluteImportDatum,\n  RelativeImportDatum,\n  ImportDatum,\n  StaticResourceData,\n  RenderKeyTuple,\n  RenderType,\n} from \"./types\";\nimport { posixPath } from \"../utils\";\n\nexport const renderedSolidityHeader = `// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */`;\n\n/**\n * Renders a list of lines\n */\nexport function renderList<T>(list: T[], renderItem: (item: T, index: number) => string): string {\n  return internalRenderList(\"\", list, renderItem);\n}\n\n/**\n * Renders a comma-separated list of arguments for solidity functions, ignoring empty and undefined ones\n */\nexport function renderArguments(args: (string | undefined)[]): string {\n  const filteredArgs = args.filter((arg) => arg !== undefined && arg !== \"\") as string[];\n  return internalRenderList(\",\", filteredArgs, (arg) => arg);\n}\n\nexport function renderCommonData({\n  staticResourceData,\n  keyTuple,\n}: {\n  staticResourceData?: StaticResourceData;\n  keyTuple: RenderKeyTuple[];\n}): {\n  _tableId: string;\n  _typedTableId: string;\n  _keyArgs: string;\n  _typedKeyArgs: string;\n  _keyTupleDefinition: string;\n} {\n  // static resource means static tableId as well, and no tableId arguments\n  const _tableId = staticResourceData ? \"\" : \"_tableId\";\n  const _typedTableId = staticResourceData ? \"\" : \"ResourceId _tableId\";\n\n  const _keyArgs = renderArguments(keyTuple.map(({ name }) => name));\n  const _typedKeyArgs = renderArguments(keyTuple.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n\n  const _keyTupleDefinition = `\n    bytes32[] memory _keyTuple = new bytes32[](${keyTuple.length});\n    ${renderList(keyTuple, (key, index) => `_keyTuple[${index}] = ${renderValueTypeToBytes32(key.name, key)};`)}\n  `;\n\n  return {\n    _tableId,\n    _typedTableId,\n    _keyArgs,\n    _typedKeyArgs,\n    _keyTupleDefinition,\n  };\n}\n\n/** For 2 paths which are relative to a common root, create a relative import path from one to another */\nexport function solidityRelativeImportPath(fromPath: string, usedInPath: string): string {\n  // 1st \"./\" must be added because path strips it,\n  // but solidity expects it unless there's \"../\" (\"./../\" is fine).\n  // 2nd and 3rd \"./\" forcefully avoid absolute paths (everything is relative to `src`).\n  return posixPath(\"./\" + path.relative(\"./\" + usedInPath, \"./\" + fromPath));\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderImports(imports: ImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map((importDatum) => {\n      if (\"path\" in importDatum) {\n        return importDatum;\n      } else {\n        return {\n          symbol: importDatum.symbol,\n          path: solidityRelativeImportPath(importDatum.fromPath, importDatum.usedInPath),\n        };\n      }\n    })\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderRelativeImports(imports: RelativeImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map(({ symbol, fromPath, usedInPath }) => ({\n      symbol,\n      path: solidityRelativeImportPath(fromPath, usedInPath),\n    }))\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderAbsoluteImports(imports: AbsoluteImportDatum[]): string {\n  // Aggregate symbols by import path, also deduplicating them\n  const aggregatedImports = new Map<string, Set<string>>();\n  for (const { symbol, path } of imports) {\n    if (!aggregatedImports.has(path)) {\n      aggregatedImports.set(path, new Set());\n    }\n    aggregatedImports.get(path)?.add(symbol);\n  }\n  // Render imports\n  const renderedImports = [];\n  for (const [path, symbols] of aggregatedImports) {\n    const renderedSymbols = [...symbols].join(\", \");\n    renderedImports.push(`import { ${renderedSymbols} } from \"${posixPath(path)}\";`);\n  }\n  return renderedImports.join(\"\\n\");\n}\n\nexport function renderWithStore(\n  storeArgument: boolean,\n  callback: (\n    _typedStore: string | undefined,\n    _store: string,\n    _commentSuffix: string,\n    _untypedStore: string | undefined,\n    _methodPrefix: string,\n    _internal?: boolean\n  ) => string\n): string {\n  let result = \"\";\n  result += callback(undefined, \"StoreSwitch\", \"\", undefined, \"\");\n  result += callback(undefined, \"StoreCore\", \"\", undefined, \"_\", true);\n\n  if (storeArgument) {\n    result += \"\\n\" + callback(\"IStore _store\", \"_store\", \" (using the specified store)\", \"_store\", \"\");\n  }\n\n  return result;\n}\n\nexport function renderWithFieldSuffix(\n  withSuffixlessFieldMethods: boolean,\n  fieldName: string,\n  callback: (_methodNameSuffix: string) => string\n): string {\n  const methodNameSuffix = `${fieldName[0].toUpperCase()}${fieldName.slice(1)}`;\n  let result = \"\";\n  result += callback(methodNameSuffix);\n\n  if (withSuffixlessFieldMethods) {\n    result += \"\\n\" + callback(\"\");\n  }\n\n  return result;\n}\n\nexport function renderTableId({ namespace, name, offchainOnly, tableIdName }: StaticResourceData): {\n  hardcodedTableId: string;\n  tableIdDefinition: string;\n} {\n  const hardcodedTableId = `\n    ResourceId.wrap(\n      bytes32(\n        abi.encodePacked(\n          ${offchainOnly ? \"RESOURCE_OFFCHAIN_TABLE\" : \"RESOURCE_TABLE\"},\n          bytes14(\"${namespace}\"),\n          bytes16(\"${name}\")\n        )\n      )\n    )\n  `;\n\n  const tableIdDefinition = `\n    ResourceId constant _tableId = ${hardcodedTableId};\n    ResourceId constant ${tableIdName} = _tableId;\n  `;\n  return {\n    hardcodedTableId,\n    tableIdDefinition,\n  };\n}\n\nexport function renderValueTypeToBytes32(name: string, { typeUnwrap, internalTypeId }: RenderType): string {\n  const innerText = typeUnwrap.length ? `${typeUnwrap}(${name})` : name;\n\n  if (internalTypeId === \"bytes32\") {\n    return innerText;\n  } else if (internalTypeId.match(/^bytes\\d{1,2}$/)) {\n    return `bytes32(${innerText})`;\n  } else if (internalTypeId.match(/^uint\\d{1,3}$/)) {\n    return `bytes32(uint256(${innerText}))`;\n  } else if (internalTypeId.match(/^int\\d{1,3}$/)) {\n    return `bytes32(uint256(int256(${innerText})))`;\n  } else if (internalTypeId === \"address\") {\n    return `bytes32(uint256(uint160(${innerText})))`;\n  } else if (internalTypeId === \"bool\") {\n    return `_boolToBytes32(${innerText})`;\n  } else {\n    throw new Error(`Unknown value type id ${internalTypeId}`);\n  }\n}\n\nexport function isLeftAligned(field: Pick<RenderType, \"internalTypeId\">): boolean {\n  return field.internalTypeId.match(/^bytes\\d{1,2}$/) !== null;\n}\n\nexport function getLeftPaddingBits(field: Pick<RenderType, \"internalTypeId\" | \"staticByteLength\">): number {\n  if (isLeftAligned(field)) {\n    return 0;\n  } else {\n    return 256 - field.staticByteLength * 8;\n  }\n}\n\nfunction internalRenderList<T>(\n  lineTerminator: string,\n  list: T[],\n  renderItem: (item: T, index: number) => string\n): string {\n  return list\n    .map((item, index) => renderItem(item, index) + (index === list.length - 1 ? \"\" : lineTerminator))\n    .join(\"\\n\");\n}"
    },
    {
      "filename": "packages/store/ts/codegen/tightcoder/renderFunctions.ts",
      "content": "import { getLeftPaddingBits } from \"@latticexyz/common/codegen\";\n\nexport function renderTightCoderDecode(element: { internalTypeId: string; staticByteLength: number }) {\n  return `\n    /**\n     * @notice Decodes a slice into an array of ${element.internalTypeId}.\n     * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.\n     * @param _input The slice to decode.\n     * @return _output The decoded array of ${element.internalTypeId}.\n     */\n    function decodeArray_${element.internalTypeId}(\n      Slice _input\n    ) internal pure returns (\n      ${element.internalTypeId}[] memory _output\n    ) {\n      bytes32[] memory _genericArray = TightCoder.decode(\n        _input,\n        ${element.staticByteLength},\n        ${getLeftPaddingBits(element)}\n      );\n      assembly {\n        _output := _genericArray\n      }\n    }\n  `;\n}\n\nexport function renderTightCoderEncode(element: { internalTypeId: string; staticByteLength: number }) {\n  return `\n\n    /**\n     * @notice Encodes an array of ${element.internalTypeId} into a tightly packed bytes representation.\n     * @param _input The array of ${element.internalTypeId} values to be encoded.\n     * @return The resulting tightly packed bytes representation of the input array.\n     */\n    function encode(${element.internalTypeId}[] memory _input) internal pure returns (bytes memory) {\n      bytes32[] memory _genericArray;\n      assembly {\n        _genericArray := _input\n      }\n      return TightCoder.encode(\n        _genericArray,\n        ${element.staticByteLength},\n        ${getLeftPaddingBits(element)}\n      );\n    }\n  `;\n}"
    }
  ]
}