{
  "Title": "[M-06] Withdrawing wrong LPToken from GiantPool leads to loss of funds",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95\n\n\n# Vulnerability details\n\n## Impact\nThe `GiantPoolBase.withdrawLPTokens` function ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69)) allows to withdraw LP tokens from a GiantPool by burning an equal amount of GiantLP.  \n\nThis allows a user to handle the LP tokens directly without the need for a GiantPool as intermediary.  \n\nIt is not checked however whether the LP tokens to be withdrawn were transferred to the GiantPool in exchange for staking ETH.  \n\nI.e. whether the LP token are of any value.  \n\nThere are two issues associated with this behavior.  \n\n1. A malicious user can create and mint his own LP Token and send it to the GiantPool. Users that want to withdraw LP tokens from the GiantPool can then be tricked into withdrawing worthless attacker LP tokens, thereby burning their GiantLP tokens that are mapped 1:1 to \nETH. (-> loss of funds)  \n\n2. This can also mess up internal accounting logic. For every LP token that is owned by a GiantPool there should be a corresponding GiantLP token. Using the described behavior this ratio can be broken such that there are LP token owned by the GiantPool for which there is no GiantLP token. This means some LP token cannot be transferred from the GiantPool and there will always be some amount of LP token \"stuck\" in the GiantPool.  \n\n## Proof of Concept\n1. The attacker deploys his own LPToken contract and sends a huge amount of LP tokens to the GiantPool to pass the check in `GiantPoolBase._assertUserHasEnoughGiantLPToClaimVaultLP` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L95)). \n2. The attacker tricks Bob into withdrawing the malicious LP tokens from the GiantPool ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69)). \n3. Bob's GiantLP tokens are burnt and he receives worthless LP tokens.\n\nThe same issue exists for the `GiantSavETHVaultPool.withdrawDETH` function.  \nBut in this case, the victim must also provide a wrong savETHVault address which makes this issue less likely to be exploited.  \n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe GiantPool should store information about which LP tokens it receives for staking ETH. \nWhen calling the `GiantPoolBase.withdrawLPTokens` function it can then be checked if the LP tokens to be withdrawn were indeed transferred to the GiantPool in exchange for staking ETH.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/GiantPoolBase.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}"
    },
    {
      "filename": "contracts/liquid-staking/GiantPoolBase.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}"
    }
  ]
}