{
  "Title": "M-13: Unintended Vault Operation Due to Product Settling and Oracle Version Skips",
  "Content": "# Issue M-13: Unintended Vault Operation Due to Product Settling and Oracle Version Skips \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/152 \n\n## Found by \nmstpr-brainbot\n## Summary\nVault operation can behave unexpectedly when products settle and skip versions in their oracles. This problem arises when the vault assumes a non-existent version of a product, leading to miscalculations in the _assetsAtEpoch() function. This inaccuracy can affect the distribution of shares among depositors, redeemers, and claimers, disrupting the balance of the market.\n## Vulnerability Detail\nWhen a product progresses to a new version of its oracle, it first settles at the current version plus one, then jumps to the latest version. For instance, if a product's latest version is 20 and the current version is 23, the product will first settle at version 21 and then jump from 21 to 23, bypassing version 22. This process can lead to unintended behavior in the vault, particularly if the vault's deposited epoch points to the bypassed version, which can result in a potential underflow and subsequent rounding to zero.\n\nConsider this scenario: A vault is operating with two markets, each having two products. Let's assume the vault has equal positions and collateral in both markets, with all assets priced at $1 for simplicity. Also, assume that Market0 contains product A and product B, while Market1 contains product C and product D.\n\nThe latest version of product A is 20, while the vault's latest epoch is 2, which corresponds to version 20 for product A. Similarly, the latest version of product C is 10, with the vault's latest epoch at 2, corresponding to version 10 for product A.\n\nAssume there are no positions created in product C, D, and also no deposits made to the vault, meaning the vault has not opened any positions on these products either. The oracle version for product C, D gets updated twice consecutively. Since there are no open positions in product C, D, their products will progress to version 12 directly, bypassing version 11.\n\nThis circumstance renders the epoch stale, which will lead to miscalculations in deposits, claims, and redemptions. During the _assetsAtEpoch() function, the vault incorrectly assumes that there is a version 11 of product C, D. However, these products have skipped version 11 and advanced to 12. Since the latest version of product C, D is greater than the version the vault holds, the vault presumes that version 11 exists. However, as version 11 doesn't exist, the _accumulatedAtEpoch will be the negative of whatever was deposited. This leads the vault to incorrectly assume a large loss in that market. Consequently, depositors can gain more shares, while redeemers and claimers may receive fewer shares.\n\n## Impact\nIf the above scenario happens, vault users can incur extreme losses on claim and redeem operations and depositors can earn uneven shares.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L84-L130\nsettle\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/interfaces/types/PrePosition.sol#L133-L136\nif no open positions in preposition settle version is current version\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L376\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L823-L843\nchecks for +1 version, if latestVersion > currentVersion, it assumes vault lost all the funds in that market.\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L797-L805\n\n## Tool used\n\nManual Review\n\n## Recommendation\nDon't check +1 version, check the current version recorded for that epoch in vault and the latest version of the product, cover all the versions \n\n\n\n## Discussion\n\n**kbrizzle**\n\nIt is guaranteed that all applicable versions have a corresponding checkpoint in the underlying markets at version `n` because product.settle() is called on every market ([here](https://github.com/equilibria-xyz/perennial-mono/blob/dev/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L586-L589) from [here](https://github.com/equilibria-xyz/perennial-mono/blob/dev/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L377)) when an [epoch snapshot](https://github.com/equilibria-xyz/perennial-mono/blob/dev/packages/perennial-vaults/contracts/balanced/BalancedVault.sol#L394) takes place.\n\nFurther, when there is a deposit or withdrawal `_updateMakerPosition` will create a new position in the underlying product [here](https://github.com/equilibria-xyz/perennial-mono/blob/master/packages/perennial-vaults/contracts/BalancedVault.sol#L440-L443), which will create a checkpoint for `n + 1`.\n\n**KenzoAgada**\n\nSuspected as much but wanted to make sure... Closing as invalid.\n\n**KenzoAgada**\n\nAfter internal discussion: the issue is valid, but the watson didn't fully identify the exact complex edge case where it will materialize. Therefore downgrading to medium severity.\n\n**mstpr**\n\nEscalate for 10 USDC\n\nI am not sure what's the edge case, it is straightforward.\n\nA vault is synced with its underlying product as long as it is interacting with its products. A product can advance more oracle versions while vault still outdates with another one if there isn't any interactions been made in due time. At the end of the _settle function the correct and the most updated oracle version is synced. However, just in the settlement process vault only checks the latest synced version of its and the one after that (which there might not be a +1 version due to skipping). \n\nIf a product has in version 12 and the previous version of it was 10 (means that product skipped version 11 and went directly to version 12) and the vaults latest synced version is 10 (no interactions made with vault so vault still thinks the latest version of the product is 10), the next time someone calls deposit/redeem/claim or in general anything that would trigger the settlement process, the accumulated assets at that epoch will be calculated as follows:\n\nproducts latest version of the underlying product is 10. So _accumulatedAtEpoch will calculate the balance respect to oracle version 10 and 11. However, there is no version 11, and default it will be 0 and since the latest version of the product (12) > 10 (latest synced oracle version of vault) the accounting will be mess. Since there is no oracle version 11, the accumulated balance will be calculated as the negative of version 10. If the epoch is stale, there can be deposits/redeems/claims in the latestEpoch and when the sync() happens the accounting will go off.\n\nAlso, this is directly related with user funds and huge losses can be reported, so I think this is a valid high. \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I am not sure what's the edge case, it is straightforward.\n> \n> A vault is synced with its underlying product as long as it is interacting with its products. A product can advance more oracle versions while vault still outdates with another one if there isn't any interactions been made in due time. At the end of the _settle function the correct and the most updated oracle version is synced. However, just in the settlement process vault only checks the latest synced version of its and the one after that (which there might not be a +1 version due to skipping). \n> \n> If a product has in version 12 and the previous version of it was 10 (means that product skipped version 11 and went directly to version 12) and the vaults latest synced version is 10 (no interactions made with vault so vault still thinks the latest version of the product is 10), the next time someone calls deposit/redeem/claim or in general anything that would trigger the settlement process, the accumulated assets at that epoch will be calculated as follows:\n> \n> products latest version of the underlying product is 10. So _accumulatedAtEpoch will calculate the balance respect to oracle version 10 and 11. However, there is no version 11, and default it will be 0 and since the latest version of the product (12) > 10 (latest synced oracle version of vault) the accounting will be mess. Since there is no oracle version 11, the accumulated balance will be calculated as the negative of version 10. If the epoch is stale, there can be deposits/redeems/claims in the latestEpoch and when the sync() happens the accounting will go off.\n> \n> Also, this is directly related with user funds and huge losses can be reported, so I think this is a valid high. \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nComment from a waston:\n```\n/**\n     * @notice Rebalances the collateral and position of the vault without a deposit or withdraw\n     * @dev Should be called by a keeper when a new epoch is available, and there are pending deposits / redemptions\n     */\n    function sync() external {\n        syncAccount(address(0));\n    }\n```\n`sync()` Should be called by a keeper when a new epoch is available. If the keeper is running normally, there will be no such assumptions in the report: `if a product's latest version is 20 and the current version is 23`. Because sync() will call product._settle internally. \nso the above scenario will not happen.\n\n**mstpr**\n\n> ```\n> /**\n>      * @notice Rebalances the collateral and position of the vault without a deposit or withdraw\n>      * @dev Should be called by a keeper when a new epoch is available, and there are pending deposits / redemptions\n>      */\n>     function sync() external {\n>         syncAccount(address(0));\n>     }\n> ```\n> \n> \n>     \n>   \n> \n> sync() Should be called by a keeper when a new epoch is available. so the above scenario will not happen.\n\nProduct advances an oracle version and vault syncs. \n\nWhen a product advances to version 12 from 10 by skipping version 11 (which is possible if there are no open positions in version 10) \n\nand if the epoch is stale there can be deposits made by users.\n\nNow, even if keeper would call the sync() after 1 second the above scenario is consistent. \n\n**KenzoAgada**\n\nI don't have a lot to add on this escalation.\nOn one hand, it seems the watson identified a valid critical issue.\nOn the other hand, if I understand the sponsor correctly, they said that report was not very useful or detailed nor enough to really understand and fix the problem.\nUp to Sherlock to decide severity.\n\n**jacksanford1**\n\n@securitygrid Are you satisfied with @mstpr's last response?\n\nI don't believe the likelihood and severity potential for this issue combine to warrant a High. \n\nHowever it seems to be a legitimate issue (or very close to describing one) and so it seems like a Medium. \n\n**securitygrid**\n\nIf the keeper is working, why is there a delay of 2 versions?\n\n**jacksanford1**\n\nI guess @mstpr can answer that best\n\n**mstpr**\n\nI don't think you get the issue here @securitygrid. As stated above, vaults and products separate things. Product advance a version first then vault syncs.\n\nVault only advances a version if the underlying products advances to the next version. It is completely not about keepers.\nIf marketA (2 products, long and short) and marketB (2 products, long and short) are in oracle version 3 and vault is in epoch 2,\nwhen marketA advances to version 3 but marketB is still in version 2, the vault is still in epoch2, vault can't advance to epoch3 before marketB is advanced to version 3 aswell. \n\n\n\n\n\n\n\n**jacksanford1**\n\n@securitygrid Any thoughts on mstpr's latest comment?\n\n**jacksanford1**\n\nResult:\nMedium\nUnique\n> On one hand, it seems the watson identified a valid critical issue.\n> On the other hand, if I understand the sponsor correctly, they said that report was not very useful or detailed nor enough to really understand and fix the problem.\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/152/#issuecomment-1612941681): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial/contracts/product/Product.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../controller/UControllerProvider.sol\";\nimport \"./UPayoffProvider.sol\";\nimport \"./UParamProvider.sol\";\nimport \"./types/position/AccountPosition.sol\";\nimport \"./types/accumulator/AccountAccumulator.sol\";\n\n/**\n * @title Product\n * @notice Manages logic and state for a single product market.\n * @dev Cloned by the Controller contract to launch new product markets.\n */\ncontract Product is IProduct, UInitializable, UParamProvider, UPayoffProvider, UReentrancyGuard {\n    /// @dev Whether or not the product is closed\n    BoolStorage private constant _closed = BoolStorage.wrap(keccak256(\"equilibria.perennial.Product.closed\"));\n\n    function closed() public view returns (bool) {\n        return _closed.read();\n    }\n\n    /// @dev The name of the product\n    string public name;\n\n    /// @dev The symbol of the product\n    string public symbol;\n\n    /// @dev The individual position state for each account\n    mapping(address => AccountPosition) private _positions;\n\n    /// @dev The global position state for the product\n    VersionedPosition private _position;\n\n    /// @dev The individual accumulator state for each account\n    mapping(address => AccountAccumulator) private _accumulators;\n\n    /// @dev The global accumulator state for the product\n    VersionedAccumulator private _accumulator;\n\n    /**\n     * @notice Initializes the contract state\n     * @param productInfo_ Product initialization params\n     */\n    function initialize(ProductInfo calldata productInfo_) external initializer(1) {\n        __UControllerProvider__initialize(IController(msg.sender));\n        __UPayoffProvider__initialize(productInfo_.oracle, productInfo_.payoffDefinition);\n        __UReentrancyGuard__initialize();\n        __UParamProvider__initialize(\n            productInfo_.maintenance,\n            productInfo_.fundingFee,\n            productInfo_.makerFee,\n            productInfo_.takerFee,\n            productInfo_.positionFee,\n            productInfo_.makerLimit,\n            productInfo_.utilizationCurve\n        );\n\n        name = productInfo_.name;\n        symbol = productInfo_.symbol;\n    }\n\n    /**\n     * @notice Surfaces global settlement externally\n     */\n    function settle() external nonReentrant notPaused {\n        _settle();\n    }\n\n    /**\n     * @notice Core global settlement flywheel\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settle() private returns (IOracleProvider.OracleVersion memory currentOracleVersion) {\n        IController _controller = controller();\n\n        // Get current oracle version\n        currentOracleVersion = _sync();\n\n        // Get latest oracle version\n        uint256 _latestVersion = latestVersion();\n        if (_latestVersion == currentOracleVersion.version) return currentOracleVersion; // short circuit entirely if a == c\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(_latestVersion);\n\n        // Get settle oracle version\n        uint256 _settleVersion = _position.pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // Initiate\n        _controller.incentivizer().sync(currentOracleVersion);\n        UFixed18 boundedFundingFee = _boundedFundingFee();\n\n        // value a->b\n        UFixed18 accumulatedFee = _accumulator.accumulate(\n            boundedFundingFee, _position, latestOracleVersion, settleOracleVersion);\n\n        // position a->b\n        _position.settle(_latestVersion, settleOracleVersion);\n\n        // Apply any pending fee updates if present\n        _settleFeeUpdates();\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // value b->c\n            accumulatedFee = accumulatedFee.add(\n                _accumulator.accumulate(boundedFundingFee, _position, settleOracleVersion, currentOracleVersion)\n            );\n\n            // position b->c (every accumulator version needs a position stamp)\n            _position.settle(settleOracleVersion.version, currentOracleVersion);\n        }\n\n        // settle collateral\n        _controller.collateral().settleProduct(accumulatedFee);\n\n        emit Settle(settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Surfaces account settlement externally\n     * @param account Account to settle\n     */\n    function settleAccount(address account) external nonReentrant notPaused {\n        IOracleProvider.OracleVersion memory currentOracleVersion = _settle();\n        _settleAccount(account, currentOracleVersion);\n    }\n\n    /**\n     * @notice Core account settlement flywheel\n     * @param account Account to settle\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settleAccount(address account, IOracleProvider.OracleVersion memory currentOracleVersion) private {\n        IController _controller = controller();\n\n        // Get latest oracle version\n        if (latestVersion(account) == currentOracleVersion.version) return; // short circuit entirely if a == c\n\n        // Get settle oracle version\n        uint256 _settleVersion = _positions[account].pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // sync incentivizer before accumulator\n        _controller.incentivizer().syncAccount(account, settleOracleVersion);\n\n        // value a->b\n        Fixed18 accumulated = _accumulators[account].syncTo(\n            _accumulator, _positions[account], settleOracleVersion.version).sum();\n\n        // position a->b\n        _positions[account].settle(settleOracleVersion);\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // sync incentivizer before accumulator\n            _controller.incentivizer().syncAccount(account, currentOracleVersion);\n\n            // value b->c\n            accumulated = accumulated.add(\n                _accumulators[account].syncTo(_accumulator, _positions[account], currentOracleVersion.version).sum()\n            );\n        }\n\n        // settle collateral\n        _controller.collateral().settleAccount(account, accumulated);\n\n        emit AccountSettle(account, settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Opens a taker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openTake(UFixed18 amount) external {\n        openTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open the position for\n     * @param amount Amount of the position to open\n     */\n    function openTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        maxUtilizationInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openTake(latestOracleVersion.version, amount);\n        _position.pre.openTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeTake(UFixed18 amount) external {\n        closeTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeTake(account, amount);\n    }\n\n    function _closeTake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeTake(latestOracleVersion.version, amount);\n        _position.pre.closeTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openMake(UFixed18 amount) external {\n        openMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open position for\n     * @param amount Amount of the position to open\n     */\n    function openMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        nonZeroVersionInvariant\n        makerInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openMake(latestOracleVersion.version, amount);\n        _position.pre.openMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeMake(UFixed18 amount) external {\n        closeMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        takerInvariant\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeMake(account, amount);\n    }\n\n    function _closeMake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeMake(latestOracleVersion.version, amount);\n        _position.pre.closeMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes all open and pending positions, locking for liquidation\n     * @dev Only callable by the Collateral contract as part of the liquidation flow\n     * @param account Account to close out\n     */\n    function closeAll(address account) external onlyCollateral notClosed settleForAccount(account) {\n        AccountPosition storage accountPosition = _positions[account];\n        Position memory p = accountPosition.position.next(_positions[account].pre);\n\n        // Close all positions\n        _closeMake(account, p.maker);\n        _closeTake(account, p.taker);\n\n        // Mark liquidation to lock position\n        accountPosition.liquidation = true;\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account`\n     * @param account Account to return for\n     * @return The current maintenance requirement\n     */\n    function maintenance(address account) external view returns (UFixed18) {\n        return _positions[account].maintenance();\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account` after next settlement\n     * @dev Assumes no price change and no funding, used to protect user from over-opening\n     * @param account Account to return for\n     * @return The next maintenance requirement\n     */\n    function maintenanceNext(address account) external view returns (UFixed18) {\n        return _positions[account].maintenanceNext();\n    }\n\n    /**\n     * @notice Returns whether `account` has a completely zero'd position\n     * @param account Account to return for\n     * @return The the account is closed\n     */\n    function isClosed(address account) external view returns (bool) {\n        return _positions[account].isClosed();\n    }\n\n    /**\n     * @notice Returns whether `account` is currently locked for an in-progress liquidation\n     * @param account Account to return for\n     * @return Whether the account is in liquidation\n     */\n    function isLiquidating(address account) external view returns (bool) {\n        return _positions[account].liquidation;\n    }\n\n    /**\n     * @notice Returns `account`'s current position\n     * @param account Account to return for\n     * @return Current position of the account\n     */\n    function position(address account) external view returns (Position memory) {\n        return _positions[account].position;\n    }\n\n    /**\n     * @notice Returns `account`'s current pending-settlement position\n     * @param account Account to return for\n     * @return Current pre-position of the account\n     */\n    function pre(address account) external view returns (PrePosition memory) {\n        return _positions[account].pre;\n    }\n\n    /**\n     * @notice Returns the global latest settled oracle version\n     * @return Latest settled oracle version of the product\n     */\n    function latestVersion() public view returns (uint256) {\n        return _accumulator.latestVersion;\n    }\n\n    /**\n     * @notice Returns the global position at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global position at oracle version\n     */\n    function positionAtVersion(uint256 oracleVersion) public view returns (Position memory) {\n        return _position.positionAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the current global pending-settlement position\n     * @return Global pending-settlement position\n     */\n    function pre() external view returns (PrePosition memory) {\n        return _position.pre;\n    }\n\n    /**\n     * @notice Returns the global accumulator value at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator value at oracle version\n     */\n    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.valueAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the global accumulator share at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator share at oracle version\n     */\n    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.shareAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns `account`'s latest settled oracle version\n     * @param account Account to return for\n     * @return Latest settled oracle version of the account\n     */\n    function latestVersion(address account) public view returns (uint256) {\n        return _accumulators[account].latestVersion;\n    }\n\n    /**\n     * @notice Returns The per-second rate based on the provided `position`\n     * @dev Handles 0-maker/taker edge cases\n     * @param position_ Position to base utilization on\n     * @return The per-second rate\n     */\n    function rate(Position calldata position_) public view returns (Fixed18) {\n        UFixed18 utilization = position_.taker.unsafeDiv(position_.maker);\n        Fixed18 annualizedRate = utilizationCurve().compute(utilization);\n        return annualizedRate.div(Fixed18Lib.from(365 days));\n    }\n\n    /**\n     * @notice Returns the minimum funding fee parameter with a capped range for safety\n     * @dev Caps controller.minFundingFee() <= fundingFee() <= 1\n     * @return Safe minimum funding fee parameter\n     */\n    function _boundedFundingFee() private view returns (UFixed18) {\n        return fundingFee().max(controller().minFundingFee());\n    }\n\n    /**\n     * @notice Updates product closed state\n     * @dev only callable by product owner. Settles the product before flipping the flag\n     * @param newClosed new closed value\n     */\n    function updateClosed(bool newClosed) external nonReentrant notPaused onlyProductOwner {\n        IOracleProvider.OracleVersion memory oracleVersion = _settle();\n        _closed.store(newClosed);\n        emit ClosedUpdated(newClosed, oracleVersion.version);\n    }\n\n    /**\n     * @notice Updates underlying product oracle\n     * @dev only callable by product owner\n     * @param newOracle new oracle address\n     */\n    function updateOracle(IOracleProvider newOracle) external onlyProductOwner {\n        _updateOracle(address(newOracle), latestVersion());\n    }\n\n    /// @dev Limit total maker for guarded rollouts\n    modifier makerInvariant() {\n        _;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n\n        if (next.maker.gt(makerLimit())) revert ProductMakerOverLimitError();\n    }\n\n    /// @dev Limit maker short exposure to the range 0.0-1.0x of their position. Does not apply when in closeOnly state\n    modifier takerInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 socializationFactor = next.socializationFactor();\n\n        if (socializationFactor.lt(UFixed18Lib.ONE)) revert ProductInsufficientLiquidityError(socializationFactor);\n    }\n\n    /// @dev Limit utilization to (1 - utilizationBuffer)\n    modifier maxUtilizationInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 utilization = next.taker.unsafeDiv(next.maker);\n        if (utilization.gt(UFixed18Lib.ONE.sub(utilizationBuffer())))\n            revert ProductInsufficientLiquidityError(utilization);\n    }\n\n    /// @dev Ensure that the user has only taken a maker or taker position, but not both\n    modifier positionInvariant(address account) {\n        _;\n\n        if (_positions[account].isDoubleSided()) revert ProductDoubleSidedError();\n    }\n\n    /// @dev Ensure that the user hasn't closed more than is open\n    modifier closeInvariant(address account) {\n        _;\n\n        if (_positions[account].isOverClosed()) revert ProductOverClosedError();\n    }\n\n    /// @dev Ensure that the user will have sufficient margin for maintenance after next settlement\n    modifier maintenanceInvariant(address account) {\n        _;\n\n        if (controller().collateral().liquidatableNext(account, IProduct(this)))\n            revert ProductInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the user is not currently being liquidated\n    modifier liquidationInvariant(address account) {\n        if (_positions[account].liquidation) revert ProductInLiquidationError();\n\n        _;\n    }\n\n    /// @dev Helper to fully settle an account's state\n    modifier settleForAccount(address account) {\n        IOracleProvider.OracleVersion memory _currentVersion = _settle();\n        _settleAccount(account, _currentVersion);\n\n        _;\n    }\n\n    /// @dev Ensure we have bootstraped the oracle before creating positions\n    modifier nonZeroVersionInvariant() {\n        if (latestVersion() == 0) revert ProductOracleBootstrappingError();\n\n        _;\n    }\n\n    /// @dev Ensure the product is not closed\n    modifier notClosed() {\n        if (closed()) revert ProductClosedError();\n\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial/contracts/interfaces/types/PrePosition.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed18.sol\";\nimport \"@equilibria/perennial-oracle/contracts/interfaces/IOracleProvider.sol\";\nimport \"./Position.sol\";\nimport \"../IProduct.sol\";\n\n/// @dev PrePosition type\nstruct PrePosition {\n    /// @dev Oracle version at which the new position delta was recorded\n    uint256 oracleVersion;\n\n    /// @dev Size of position to open at oracle version\n    Position openPosition;\n\n    /// @dev Size of position to close at oracle version\n    Position closePosition;\n}\nusing PrePositionLib for PrePosition global;\n\n/**\n * @title PrePositionLib\n * @notice Library that manages a pre-settlement position delta.\n * @dev PrePositions track the currently awaiting-settlement deltas to a settled Position. These are\n *      Primarily necessary to introduce lag into the settlement system such that oracle lag cannot be\n *      gamed to a user's advantage. When a user opens or closes a new position, it sits as a PrePosition\n *      for one oracle version until it's settle into the Position, making it then effective. PrePositions\n *      are automatically settled at the correct oracle version even if a flywheel call doesn't happen until\n *      several version into the future by using the historical version lookups in the corresponding \"Versioned\"\n *      global state types.\n */\nlibrary PrePositionLib {\n    /**\n     * @notice Returns whether there is no pending-settlement position delta\n     * @param self The struct to operate on\n     * @return Whether the pending-settlement position delta is empty\n     */\n    function isEmpty(PrePosition memory self) internal pure returns (bool) {\n        return self.openPosition.isEmpty() && self.closePosition.isEmpty();\n    }\n\n    /**\n     * @notice Increments the maker side of the open position delta\n     * @param self The struct to operate on\n     * @param currentVersion The current oracle version index\n     * @param amount The position amount to open\n     */\n    function openMake(PrePosition storage self, uint256 currentVersion, UFixed18 amount) internal {\n        self.openPosition.maker = self.openPosition.maker.add(amount);\n        self.oracleVersion = currentVersion;\n    }\n\n    /**\n     * @notice Increments the maker side of the close position delta\n     * @param self The struct to operate on\n     * @param currentVersion The current oracle version index\n     * @param amount The maker position amount to close\n     */\n    function closeMake(PrePosition storage self, uint256 currentVersion, UFixed18 amount) internal {\n        self.closePosition.maker = self.closePosition.maker.add(amount);\n        self.oracleVersion = currentVersion;\n    }\n\n    /**\n     * @notice Increments the taker side of the open position delta\n     * @param self The struct to operate on\n     * @param currentVersion The current oracle version index\n     * @param amount The taker position amount to open\n     */\n    function openTake(PrePosition storage self, uint256 currentVersion, UFixed18 amount) internal {\n        self.openPosition.taker = self.openPosition.taker.add(amount);\n        self.oracleVersion = currentVersion;\n    }\n\n    /**\n     * @notice Increments the taker side of the close position delta\n     * @param self The struct to operate on\n     * @param currentVersion The current oracle version index\n     * @param amount The taker position amount to close\n     */\n    function closeTake(PrePosition storage self, uint256 currentVersion, UFixed18 amount) internal {\n        self.closePosition.taker = self.closePosition.taker.add(amount);\n        self.oracleVersion = currentVersion;\n    }\n\n    /**\n     * @notice Returns whether the the pending position delta can be settled at version `toOracleVersion`\n     * @dev Pending-settlement positions deltas can be settled (1) oracle version after they are recorded\n     * @param self The struct to operate on\n     * @param toOracleVersion The potential oracle version to settle\n     * @return Whether the position delta can be settled\n     */\n    function canSettle(\n        PrePosition memory self,\n        IOracleProvider.OracleVersion memory toOracleVersion\n    ) internal pure returns (bool) {\n        return self.oracleVersion != 0 && toOracleVersion.version > self.oracleVersion;\n    }\n\n    /**\n     * @notice Computes the fee incurred for opening or closing the pending-settlement position\n     * @dev Must be called from a valid product to get the proper fee amounts\n     * @param self The struct to operate on\n     * @param latestOracleVersion The oracle version at which position was modified\n     * @return The maker / taker fee incurred\n     */\n    function computeFee(\n        PrePosition memory self,\n        IOracleProvider.OracleVersion memory latestOracleVersion\n    ) internal view returns (Position memory) {\n        Position memory positionDelta = self.openPosition.add(self.closePosition);\n\n        (UFixed18 makerNotional, UFixed18 takerNotional) = (\n            Fixed18Lib.from(positionDelta.maker).mul(latestOracleVersion.price).abs(),\n            Fixed18Lib.from(positionDelta.taker).mul(latestOracleVersion.price).abs()\n        );\n\n        IProduct product = IProduct(address(this));\n        return Position(makerNotional.mul(product.makerFee()), takerNotional.mul(product.takerFee()));\n    }\n\n    /**\n     * @notice Computes the next oracle version to settle\n     * @dev - If there is no pending-settlement position delta, returns the current oracle version\n     *      - Otherwise returns the oracle version at which the pending-settlement position delta can be first settled\n     *\n     *      Corresponds to point (b) in the Position settlement flow\n     * @param self The struct to operate on\n     * @param currentVersion The current oracle version index\n     * @return Next oracle version to settle\n     */\n    function settleVersion(PrePosition storage self, uint256 currentVersion) internal view returns (uint256) {\n        uint256 _oracleVersion = self.oracleVersion;\n        return _oracleVersion == 0 ? currentVersion : _oracleVersion + 1;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial-vaults/contracts/balanced/BalancedVault.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport \"../interfaces/IBalancedVault.sol\";\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./BalancedVaultDefinition.sol\";\n\n/**\n * @title BalancedVault\n * @notice ERC4626 vault that manages a 50-50 position between long-short markets of the same payoff on Perennial.\n * @dev Vault deploys and rebalances collateral between the corresponding long and short markets, while attempting to\n *      maintain `targetLeverage` with its open positions at any given time. Deposits are only gated in so much as to cap\n *      the maximum amount of assets in the vault. The long and short markets are expected to have the same oracle and\n *      opposing payoff functions.\n *\n *      The vault has a \"delayed mint\" mechanism for shares on deposit. After depositing to the vault, a user must wait\n *      until the next settlement of the underlying products in order for shares to be reflected in the getters.\n *      The shares will be fully reflected in contract state when the next settlement occurs on the vault itself.\n *      Similarly, when redeeming shares, underlying assets are not claimable until a settlement occurs.\n *      Each state changing interaction triggers the `settle` flywheel in order to bring the vault to the\n *      desired state.\n *      In the event that there is not a settlement for a long period of time, keepers can call the `sync` method to\n *      force settlement and rebalancing. This is most useful to prevent vault liquidation due to PnL changes\n *      causing the vault to be in an unhealthy state (far away from target leverage)\n *\n *      This implementation is designed to be upgrade-compatible with instances of the previous single-payoff\n *      BalancedVault, here: https://github.com/equilibria-xyz/perennial-mono/blob/d970debe95e41598228e8c4ae52fb816797820fb/packages/perennial-vaults/contracts/BalancedVault.sol.\n */\ncontract BalancedVault is IBalancedVault, BalancedVaultDefinition, UInitializable {\n    UFixed18 constant private TWO = UFixed18.wrap(2e18);\n\n    /// @dev The name of the vault\n    string public name;\n\n    /// @dev Deprecated storage variable. Formerly `symbol`\n    string private __unused0;\n\n    /// @dev Mapping of allowance across all users\n    mapping(address => mapping(address => UFixed18)) public allowance;\n\n    /// @dev Mapping of shares of the vault per user\n    mapping(address => UFixed18) private _balanceOf;\n\n    /// @dev Total number of shares across all users\n    UFixed18 private _totalSupply;\n\n    /// @dev Mapping of unclaimed underlying of the vault per user\n    mapping(address => UFixed18) private _unclaimed;\n\n    /// @dev Total unclaimed underlying of the vault across all users\n    UFixed18 private _totalUnclaimed;\n\n    /// @dev Deposits that have not been settled, or have been settled but not yet processed by this contract\n    UFixed18 private _deposit;\n\n    /// @dev Redemptions that have not been settled, or have been settled but not yet processed by this contract\n    UFixed18 private _redemption;\n\n    /// @dev The latest epoch that a pending deposit or redemption has been placed\n    uint256 private _latestEpoch;\n\n    /// @dev Mapping of pending (not yet converted to shares) per user\n    mapping(address => UFixed18) private _deposits;\n\n    /// @dev Mapping of pending (not yet withdrawn) per user\n    mapping(address => UFixed18) privat"
    }
  ]
}