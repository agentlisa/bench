{
  "Title": "[G-06] Using `bool`s for storage incurs overhead",
  "Content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27>\n\n1.  File: contracts/utils/RateLimited.sol (line [23](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L23))\n\n```solidity\n    bool public doPartialAction;\n```\n\n2.  File: contracts/refs/OracleRef.sol (line [25](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L25))\n\n```solidity\n    bool public override doInvert;\n```\n\n3.  File: contracts/peg/NonCustodialPSM.sol (line [52](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/peg/NonCustodialPSM.sol#L52))\n\n```solidity\n    bool public redeemPaused;\n```\n\n4.  File: contracts/peg/NonCustodialPSM.sol (line [55](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/peg/NonCustodialPSM.sol#L55))\n\n```solidity\n    bool public mintPaused;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-03-volt-protocol-contest",
  "Code": [
    {
      "filename": "contracts/security/ReentrancyGuard.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    {
      "filename": "contracts/utils/RateLimited.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../refs/CoreRef.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast a contract can perform an action e.g. Minting\n/// @author Fei Protocol\nabstract contract RateLimited is CoreRef {\n    /// @notice maximum rate limit per second governance can set for this contract\n    uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;\n\n    /// @notice the rate per second for this contract\n    uint256 public rateLimitPerSecond;\n\n    /// @notice the last time the buffer was used by the contract\n    uint256 public lastBufferUsedTime;\n\n    /// @notice the cap of the buffer that can be used at once\n    uint256 public bufferCap;\n\n    /// @notice a flag for whether to allow partial actions to complete if the buffer is less than amount\n    bool public doPartialAction;\n\n    /// @notice the buffer at the timestamp of lastBufferUsedTime\n    uint256 public bufferStored;\n\n    event BufferUsed(uint256 amountUsed, uint256 bufferRemaining);\n    event BufferCapUpdate(uint256 oldBufferCap, uint256 newBufferCap);\n    event RateLimitPerSecondUpdate(\n        uint256 oldRateLimitPerSecond,\n        uint256 newRateLimitPerSecond\n    );\n\n    constructor(\n        uint256 _maxRateLimitPerSecond,\n        uint256 _rateLimitPerSecond,\n        uint256 _bufferCap,\n        bool _doPartialAction\n    ) {\n        lastBufferUsedTime = block.timestamp;\n\n        _setBufferCap(_bufferCap);\n        bufferStored = _bufferCap;\n\n        require(\n            _rateLimitPerSecond <= _maxRateLimitPerSecond,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n        _setRateLimitPerSecond(_rateLimitPerSecond);\n\n        MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;\n        doPartialAction = _doPartialAction;\n    }\n\n    /// @notice set the rate limit per second\n    function setRateLimitPerSecond(uint256 newRateLimitPerSecond)\n        external\n        virtual\n        onlyGovernorOrAdmin\n    {\n        require(\n            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n        _updateBufferStored();\n\n        _setRateLimitPerSecond(newRateLimitPerSecond);\n    }\n\n    /// @notice set the buffer cap\n    function setBufferCap(uint256 newBufferCap)\n        external\n        virtual\n        onlyGovernorOrAdmin\n    {\n        _setBufferCap(newBufferCap);\n    }\n\n    /// @notice the amount of action used before hitting limit\n    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap\n    function buffer() public view returns (uint256) {\n        uint256 elapsed = block.timestamp - lastBufferUsedTime;\n        return\n            Math.min(bufferStored + (rateLimitPerSecond * elapsed), bufferCap);\n    }\n\n    /** \n        @notice the method that enforces the rate limit. Decreases buffer by \"amount\". \n        If buffer is <= amount either\n        1. Does a partial mint by the amount remaining in the buffer or\n        2. Reverts\n        Depending on whether doPartialAction is true or false\n    */\n    function _depleteBuffer(uint256 amount) internal virtual returns (uint256) {\n        uint256 newBuffer = buffer();\n\n        uint256 usedAmount = amount;\n        if (doPartialAction && usedAmount > newBuffer) {\n            usedAmount = newBuffer;\n        }\n\n        require(newBuffer != 0, \"RateLimited: no rate limit buffer\");\n        require(usedAmount <= newBuffer, \"RateLimited: rate limit hit\");\n\n        bufferStored = newBuffer - usedAmount;\n\n        lastBufferUsedTime = block.timestamp;\n\n        emit BufferUsed(usedAmount, bufferStored);\n\n        return usedAmount;\n    }\n\n    /// @notice function to replenish buffer\n    /// @param amount to increase buffer by if under buffer cap\n    function _replenishBuffer(uint256 amount) internal {\n        uint256 newBuffer = buffer();\n\n        uint256 _bufferCap = bufferCap; /// gas opti, save an SLOAD\n\n        /// cannot replenish any further if already at buffer cap\n        if (newBuffer == _bufferCap) {\n            return;\n        }\n\n        /// ensure that bufferStored cannot be gt buffer cap\n        bufferStored = Math.min(newBuffer + amount, _bufferCap);\n    }\n\n    function _setRateLimitPerSecond(uint256 newRateLimitPerSecond) internal {\n        uint256 oldRateLimitPerSecond = rateLimitPerSecond;\n        rateLimitPerSecond = newRateLimitPerSecond;\n\n        emit RateLimitPerSecondUpdate(\n            oldRateLimitPerSecond,\n            newRateLimitPerSecond\n        );\n    }\n\n    function _setBufferCap(uint256 newBufferCap) internal {\n        _updateBufferStored();\n\n        uint256 oldBufferCap = bufferCap;\n        bufferCap = newBufferCap;\n\n        emit BufferCapUpdate(oldBufferCap, newBufferCap);\n    }\n\n    function _resetBuffer() internal {\n        bufferStored = bufferCap;\n    }\n\n    function _updateBufferStored() internal {\n        bufferStored = buffer();\n        lastBufferUsedTime = block.timestamp;\n    }\n}"
    },
    {
      "filename": "contracts/refs/OracleRef.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IOracleRef.sol\";\nimport \"./CoreRef.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title Reference to an Oracle\n/// @author Fei Protocol\n/// @notice defines some utilities around interacting with the referenced oracle\nabstract contract OracleRef is IOracleRef, CoreRef {\n    using Decimal for Decimal.D256;\n    using SafeCast for int256;\n\n    /// @notice the oracle reference by the contract\n    IOracle public override oracle;\n\n    /// @notice the backup oracle reference by the contract\n    IOracle public override backupOracle;\n\n    /// @notice number of decimals to scale oracle price by, i.e. multiplying by 10^(decimalsNormalizer)\n    int256 public override decimalsNormalizer;\n\n    bool public override doInvert;\n\n    /// @notice OracleRef constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle oracle to reference\n    /// @param _backupOracle backup oracle to reference\n    /// @param _decimalsNormalizer number of decimals to normalize the oracle feed if necessary\n    /// @param _doInvert invert the oracle price if this flag is on\n    constructor(\n        address _core,\n        address _oracle,\n        address _backupOracle,\n        int256 _decimalsNormalizer,\n        bool _doInvert\n    ) CoreRef(_core) {\n        _setOracle(_oracle);\n        if (_backupOracle != address(0) && _backupOracle != _oracle) {\n            _setBackupOracle(_backupOracle);\n        }\n        _setDoInvert(_doInvert);\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n\n    /// @notice sets the referenced oracle\n    /// @param newOracle the new oracle to reference\n    function setOracle(address newOracle) external override onlyGovernor {\n        _setOracle(newOracle);\n    }\n\n    /// @notice sets the flag for whether to invert or not\n    /// @param newDoInvert the new flag for whether to invert\n    function setDoInvert(bool newDoInvert) external override onlyGovernor {\n        _setDoInvert(newDoInvert);\n    }\n\n    /// @notice sets the new decimalsNormalizer\n    /// @param newDecimalsNormalizer the new decimalsNormalizer\n    function setDecimalsNormalizer(int256 newDecimalsNormalizer)\n        external\n        override\n        onlyGovernor\n    {\n        _setDecimalsNormalizer(newDecimalsNormalizer);\n    }\n\n    /// @notice sets the referenced backup oracle\n    /// @param newBackupOracle the new backup oracle to reference\n    function setBackupOracle(address newBackupOracle)\n        external\n        override\n        onlyGovernorOrAdmin\n    {\n        _setBackupOracle(newBackupOracle);\n    }\n\n    /// @notice invert a peg price\n    /// @param price the peg price to invert\n    /// @return the inverted peg as a Decimal\n    /// @dev the inverted peg would be X per FEI\n    function invert(Decimal.D256 memory price)\n        public\n        pure\n        override\n        returns (Decimal.D256 memory)\n    {\n        return Decimal.one().div(price);\n    }\n\n    /// @notice updates the referenced oracle\n    function updateOracle() public override {\n        oracle.update();\n    }\n\n    /// @notice the peg price of the referenced oracle\n    /// @return the peg as a Decimal\n    /// @dev the peg is defined as FEI per X with X being ETH, dollars, etc\n    function readOracle() public view override returns (Decimal.D256 memory) {\n        (Decimal.D256 memory _peg, bool valid) = oracle.read();\n        if (!valid && address(backupOracle) != address(0)) {\n            (_peg, valid) = backupOracle.read();\n        }\n        require(valid, \"OracleRef: oracle invalid\");\n\n        // Scale the oracle price by token decimals delta if necessary\n        uint256 scalingFactor;\n        if (decimalsNormalizer < 0) {\n            scalingFactor = 10**(-1 * decimalsNormalizer).toUint256();\n            _peg = _peg.div(scalingFactor);\n        } else {\n            scalingFactor = 10**decimalsNormalizer.toUint256();\n            _peg = _peg.mul(scalingFactor);\n        }\n\n        // Invert the oracle price if necessary\n        if (doInvert) {\n            _peg = invert(_peg);\n        }\n        return _peg;\n    }\n\n    function _setOracle(address newOracle) internal {\n        require(newOracle != address(0), \"OracleRef: zero address\");\n        address oldOracle = address(oracle);\n        oracle = IOracle(newOracle);\n        emit OracleUpdate(oldOracle, newOracle);\n    }\n\n    // Supports zero address if no backup\n    function _setBackupOracle(address newBackupOracle) internal {\n        address oldBackupOracle = address(backupOracle);\n        backupOracle = IOracle(newBackupOracle);\n        emit BackupOracleUpdate(oldBackupOracle, newBackupOracle);\n    }\n\n    function _setDoInvert(bool newDoInvert) internal {\n        bool oldDoInvert = doInvert;\n        doInvert = newDoInvert;\n\n        if (oldDoInvert != newDoInvert) {\n            _setDecimalsNormalizer(-1 * decimalsNormalizer);\n        }\n\n        emit InvertUpdate(oldDoInvert, newDoInvert);\n    }\n\n    function _setDecimalsNormalizer(int256 newDecimalsNormalizer) internal {\n        int256 oldDecimalsNormalizer = decimalsNormalizer;\n        decimalsNormalizer = newDecimalsNormalizer;\n        emit DecimalsNormalizerUpdate(\n            oldDecimalsNormalizer,\n            newDecimalsNormalizer\n        );\n    }\n\n    function _setDecimalsNormalizerFromToken(address token) internal {\n        int256 feiDecimals = 18;\n        int256 _decimalsNormalizer = feiDecimals -\n            int256(uint256(IERC20Metadata(token).decimals()));\n\n        if (doInvert) {\n            _decimalsNormalizer = -1 * _decimalsNormalizer;\n        }\n\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n}"
    },
    {
      "filename": "contracts/peg/NonCustodialPSM.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Decimal} from \"../external/Decimal.sol\";\nimport {Constants} from \"../Constants.sol\";\nimport {OracleRef} from \"./../refs/OracleRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./../utils/RateLimited.sol\";\nimport {IPCVDeposit, PCVDeposit} from \"./../pcv/PCVDeposit.sol\";\nimport {INonCustodialPSM} from \"./INonCustodialPSM.sol\";\nimport {GlobalRateLimitedMinter} from \"./../utils/GlobalRateLimitedMinter.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @notice Peg Stability Module that holds no funds.\n/// On a mint, it transfers all proceeds to a PCV Deposit\n/// When funds are needed for a redemption, they are simply pulled from the PCV Deposit\ncontract NonCustodialPSM is\n    OracleRef,\n    RateLimited,\n    ReentrancyGuard,\n    INonCustodialPSM\n{\n    using Decimal for Decimal.D256;\n    using SafeCast for *;\n    using SafeERC20 for IERC20;\n\n    /// @notice the fee in basis points for selling an asset into VOLT\n    uint256 public override mintFeeBasisPoints;\n\n    /// @notice the fee in basis points for buying the asset for VOLT\n    uint256 public override redeemFeeBasisPoints;\n\n    /// @notice the PCV deposit target to deposit and withdraw from\n    IPCVDeposit public override pcvDeposit;\n\n    /// @notice the token this PSM will exchange for VOLT\n    /// Must be a stable token pegged to $1\n    IERC20 public immutable override underlyingToken;\n\n    /// @notice Rate Limited Minter contract that will be called when VOLT needs to be minted\n    GlobalRateLimitedMinter public override rateLimitedMinter;\n\n    /// @notice the max mint and redeem fee in basis points\n    /// Governance cannot change the maximum fee\n    uint256 public immutable override MAX_FEE = 300;\n\n    /// @notice boolean switch that indicates whether redeeming is paused\n    bool public redeemPaused;\n\n    /// @notice boolean switch that indicates whether minting is paused\n    bool public mintPaused;\n\n    /// @notice struct for passing constructor parameters related to OracleRef\n    struct OracleParams {\n        address coreAddress;\n        address oracleAddress;\n        address backupOracle;\n        int256 decimalsNormalizer;\n    }\n\n    /// @notice struct for passing constructor parameters related to MultiRateLimited\n    struct RateLimitedParams {\n        uint256 maxRateLimitPerSecond;\n        uint256 rateLimitPerSecond;\n        uint256 bufferCap;\n    }\n\n    /// @notice struct for passing constructor parameters related to the non custodial PSM\n    struct PSMParams {\n        uint256 mintFeeBasisPoints;\n        uint256 redeemFeeBasisPoints;\n        IERC20 underlyingToken;\n        IPCVDeposit pcvDeposit;\n        GlobalRateLimitedMinter rateLimitedMinter;\n    }\n\n    /// @notice construct the non custodial PSM. Structs are used to prevent stack too deep errors\n    /// @param params oracle ref constructor data\n    /// @param rateLimitedParams rate limited constructor data\n    /// @param psmParams non custodial PSM constructor data\n    constructor(\n        OracleParams memory params,\n        RateLimitedParams memory rateLimitedParams,\n        PSMParams memory psmParams\n    )\n        OracleRef(\n            params.coreAddress,\n            params.oracleAddress,\n            params.backupOracle,\n            params.decimalsNormalizer,\n            true /// hardcode doInvert to true to allow swaps to work correctly\n        )\n        /// rate limited replenishable passes false as the last param as there can be no partial actions\n        RateLimited(\n            rateLimitedParams.maxRateLimitPerSecond,\n            rateLimitedParams.rateLimitPerSecond,\n            rateLimitedParams.bufferCap,\n            false\n        )\n    {\n        underlyingToken = psmParams.underlyingToken;\n\n        _setGlobalRateLimitedMinter(psmParams.rateLimitedMinter);\n        _setMintFee(psmParams.mintFeeBasisPoints);\n        _setRedeemFee(psmParams.redeemFeeBasisPoints);\n        _setPCVDeposit(psmParams.pcvDeposit);\n    }\n\n    // ----------- Mint & Redeem pausing modifiers -----------\n\n    /// @notice modifier that allows execution when redemptions are not paused\n    modifier whileRedemptionsNotPaused() {\n        require(!redeemPaused, \"PegStabilityModule: Redeem paused\");\n        _;\n    }\n\n    /// @notice modifier that allows execution when minting is not paused\n    modifier whileMintingNotPaused() {\n        require(!mintPaused, \"PegStabilityModule: Minting paused\");\n        _;\n    }\n\n    // ----------- Governor & Guardian only pausing api -----------\n\n    /// @notice set secondary pausable methods to paused\n    function pauseRedeem() external onlyGuardianOrGovernor {\n        redeemPaused = true;\n        emit RedemptionsPaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to unpaused\n    function unpauseRedeem() external onlyGuardianOrGovernor {\n        redeemPaused = false;\n        emit RedemptionsUnpaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to paused\n    function pauseMint() external onlyGuardianOrGovernor {\n        mintPaused = true;\n        emit MintingPaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to unpaused\n    function unpauseMint() external onlyGuardianOrGovernor {\n        mintPaused = false;\n        emit MintingUnpaused(msg.sender);\n    }\n\n    // ----------- Governor, psm admin and parameter admin only state changing api -----------\n\n    /// @notice set the mint fee vs oracle price in basis point terms\n    /// @param newMintFeeBasisPoints the new fee in basis points for minting\n    function setMintFee(uint256 newMintFeeBasisPoints)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)\n    {\n        _setMintFee(newMintFeeBasisPoints);\n    }\n\n    /// @notice set the redemption fee vs oracle price in basis point terms\n    /// @param newRedeemFeeBasisPoints the new fee in basis points for redemptions\n    function setRedeemFee(uint256 newRedeemFeeBasisPoints)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)\n    {\n        _setRedeemFee(newRedeemFeeBasisPoints);\n    }\n\n    /// @notice set the target for sending all PCV\n    /// @param newTarget new PCV Deposit target for this PSM\n    function setPCVDeposit(IPCVDeposit newTarget)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)\n    {\n        _setPCVDeposit(newTarget);\n    }\n\n    /// @notice set the target to call for VOLT minting\n    /// @param newMinter new Global Rate Limited Minter for this PSM\n    function setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)\n    {\n        _setGlobalRateLimitedMinter(newMinter);\n    }\n\n    // ----------- PCV Controller only state changing api -----------\n\n    /// @notice withdraw ERC20 from the contract\n    /// @param token address of the ERC20 to send\n    /// @param to address destination of the ERC20\n    /// @param amount quantity of ERC20 to send\n    function withdrawERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyPCVController {\n        IERC20(token).safeTransfer(to, amount);\n        emit WithdrawERC20(msg.sender, token, to, amount);\n    }\n\n    // ----------- Public State Changing API -----------\n\n    /// @notice function to redeem VOLT for an underlying asset\n    /// We do not burn VOLT; this allows the contract's balance of VOLT to be used before the buffer is used\n    /// In practice, this helps prevent artificial cycling of mint-burn cycles and prevents DOS attacks.\n    /// This function will deplete the buffer based on the amount of VOLT that is being redeemed.\n    /// @param to the destination address for proceeds\n    /// @param amountVoltIn the amount of VOLT to sell\n    /// @param minAmountOut the minimum amount out otherwise the TX will fail\n    function redeem(\n        address to,\n        uint256 amountVoltIn,\n        uint256 minAmountOut\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        whileRedemptionsNotPaused\n        returns (uint256 amountOut)\n    {\n        _depleteBuffer(amountVoltIn); /// deplete buffer first to save gas on buffer exhaustion sad path\n\n        updateOracle();\n\n        amountOut = _getRedeemAmountOut(amountVoltIn);\n        require(\n            amountOut >= minAmountOut,\n            \"PegStabilityModule: Redeem not enough out\"\n        );\n\n        IERC20(volt()).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountVoltIn\n        );\n\n        pcvDeposit.withdraw(to, amountOut);\n\n        emit Redeem(to, amountVoltIn, amountOut);\n    }\n\n    /// @notice function to buy VOLT for an underlying asset that is pegged to $1\n    /// We first transfer any contract-owned VOLT, then mint the remaining if necessary\n    /// This function will replenish the buffer based on the amount of VOLT that is being sent out.\n    /// @param to the destination address for proceeds\n    /// @param amountIn the amount of external asset to sell to the PSM\n    /// @param minVoltAmountOut the minimum amount of VOLT out otherwise the TX will fail\n    function mint(\n        address to,\n        uint256 amountIn,\n        uint256 minVoltAmountOut\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        whileMintingNotPaused\n        returns (uint256 amountVoltOut)\n    {\n        updateOracle();\n\n        amountVoltOut = _getMintAmountOut(amountIn);\n        require(\n            amountVoltOut >= minVoltAmountOut,\n            \"PegStabilityModule: Mint not enough out\"\n        );\n\n        underlyingToken.safeTransferFrom(\n            msg.sender,\n            address(pcvDeposit),\n            amountIn\n        );\n\n        uint256 amountFeiToTransfer = Math.min(\n            volt().balanceOf(address(this)),\n            amountVoltOut\n        );\n        uint256 amountFeiToMint = amountVoltOut - amountFeiToTransfer;\n\n        if (amountFeiToTransfer != 0) {\n            IERC20(volt()).safeTransfer(to, amountFeiToTransfer);\n        }\n\n        if (amountFeiToMint != 0) {\n            rateLimitedMinter.mintVolt(to, amountFeiToMint);\n        }\n\n        _replenishBuffer(amountVoltOut);\n\n        emit Mint(to, amountIn, amountVoltOut);\n    }\n\n    // ----------- Public View-Only API ----------\n\n    /// @notice calculate the amount of VOLT out for a given `amountIn` of underlying\n    /// First get oracle price of token\n    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.\n    /// ensure decimals are normalized if on underlying they are not 18\n    /// @param amountIn the amount of external asset to sell to the PSM\n    /// @return amountVoltOut the amount of VOLT received for the amountIn of external asset\n    function getMintAmountOut(uint256 amountIn)\n        public\n        view\n        override\n        returns (uint256 amountVoltOut)\n    {\n        amountVoltOut = _getMintAmountOut(amountIn);\n    }\n\n    /// @notice calculate the amount of underlying out for a given `amountVoltIn` of VOLT\n    /// First get oracle price of token\n    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.\n    /// ensure decimals are normalized if on underlying they are not 18\n    /// @param amountVoltIn the amount of VOLT to redeem\n    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed\n    function getRedeemAmountOut(uint256 amountVoltIn)\n        public\n        view\n        override\n        returns (uint256 amountTokenOut)\n    {\n        amountTokenOut = _getRedeemAmountOut(amountVoltIn);\n    }\n\n    /// @notice getter to return the maximum amount of VOLT that could be purchased at once\n    /// @return the maximum amount of VOLT available for purchase at once through this PSM\n    function getMaxMintAmountOut() external view override returns (uint256) {\n        return\n            volt().balanceOf(address(this)) +\n            rateLimitedMinter.individualBuffer(address(this));\n    }\n\n    // ----------- Internal Methods -----------\n\n    /// @notice helper function to get mint amount out based on current market prices\n    /// @dev will revert if price is outside of bounds and price bound PSM is being used\n    /// @param amountIn the amount of stable asset in\n    /// @return amountVoltOut the amount of VOLT received for the amountIn of stable assets\n    function _getMintAmountOut(uint256 amountIn)\n        internal\n        view\n        virtual\n        returns (uint256 amountVoltOut)\n    {\n        Decimal.D256 memory price = readOracle();\n        _validatePriceRange(price);\n\n        Decimal.D256 memory adjustedAmountIn = price.mul(amountIn);\n\n        amountVoltOut = adjustedAmountIn\n            .mul(Constants.BASIS_POINTS_GRANULARITY - mintFeeBasisPoints)\n            .div(Constants.BASIS_POINTS_GRANULARITY)\n            .asUint256();\n    }\n\n    /// @notice helper function to get redeem amount out based on current market prices\n    /// @dev will revert if price is outside of bounds and price bound PSM is being used\n    /// @param amountVoltIn the amount of VOLT to redeem\n    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed\n    function _getRedeemAmountOut(uint256 amountVoltIn)\n        internal\n        view\n        virtual\n        returns (uint256 amountTokenOut)\n    {\n        Decimal.D256 memory price = readOracle();\n        _validatePriceRange(price);\n\n        /// get amount of VOLT being provided being redeemed after fees\n        Decimal.D256 memory adjustedAmountIn = Decimal.from(\n            (amountVoltIn *\n                (Constants.BASIS_POINTS_GRANULARITY - redeemFeeBasisPoints)) /\n                Constants.BASIS_POINTS_GRANULARITY\n        );\n\n        /// now turn the VOLT into the underlying token amounts\n        /// amount VOLT in / VOLT you receive for $1 = how much stable token to pay out\n        amountTokenOut = adjustedAmountIn.div(price).asUint256();\n    }\n\n    // ----------- Helper methods to change state -----------\n\n    /// @notice set the global rate limited minter this PSM calls to mint VOLT\n    /// @param newMinter the new minter contract that this PSM will reference\n    function _setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)\n        internal\n    {\n        require(\n            address(newMinter) != address(0),\n            \"PegStabilityModule: Invalid new GlobalRateLimitedMinter\"\n        );\n        GlobalRateLimitedMinter oldMinter = rateLimitedMinter;\n        rateLimitedMinter = newMinter;\n\n        emit GlobalRateLimitedMinterUpdate(oldMinter, newMinter);\n    }\n\n    /// @notice set the mint fee vs oracle price in basis point terms\n    /// @param newMintFeeBasisPoints the new fee for minting in basis points\n    function _setMintFee(uint256 newMintFeeBasisPoints) internal {\n        require(\n            newMintFeeBasisPoints <= MAX_FEE,\n            \"PegStabilityModule: Mint fee exceeds max fee\"\n        );\n        uint256 _oldMintFee = mintFeeBasisPoints;\n        mintFeeBasisPoints = newMintFeeBasisPoints;\n\n        emit MintFeeUpdate(_oldMintFee, newMintFeeBasisPoints);\n    }\n\n    /// @notice internal helper function to set the redemption fee\n    /// @param newRedeemFeeBasisPoints the new fee for redemptions in basis points\n    function _setRedeemFee(uint256 newRedeemFeeBasisPoints) internal {\n        require(\n            newRedeemFeeBasisPoints <= MAX_FEE,\n            \"PegStabilityModule: Redeem fee exceeds max fee\"\n        );\n        uint256 _oldRedeemFee = redeemFeeBasisPoints;\n        redeemFeeBasisPoints = newRedeemFeeBasisPoints;\n\n        emit RedeemFeeUpdate(_oldRedeemFee, newRedeemFeeBasisPoints);\n    }\n\n    /// @notice helper function to set the PCV deposit\n    /// @param newPCVDeposit the new PCV deposit that this PSM will pull assets from and deposit assets into\n    function _setPCVDeposit(IPCVDeposit newPCVDeposit) internal {\n        require(\n            address(newPCVDeposit) != address(0),\n            \"PegStabilityModule: Invalid new PCVDeposit\"\n        );\n        require(\n            newPCVDeposit.balanceReportedIn() == address(underlyingToken),\n            \"PegStabilityModule: Underlying token mismatch\"\n        );\n        IPCVDeposit oldTarget = pcvDeposit;\n        pcvDeposit = newPCVDeposit;\n\n        emit PCVDepositUpdate(oldTarget, newPCVDeposit);\n    }\n\n    // ----------- Hooks -----------\n\n    /// @notice overriden function in the price bound PSM\n    function _validatePriceRange(Decimal.D256 memory price)\n        internal\n        view\n        virtual\n    {}\n}"
    },
    {
      "filename": "contracts/peg/NonCustodialPSM.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Decimal} from \"../external/Decimal.sol\";\nimport {Constants} from \"../Constants.sol\";\nimport {OracleRef} from \"./../refs/OracleRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./../utils/RateLimited.sol\";\nimport {IPCVDeposit, PCVDeposit} from \"./../pcv/PCVDeposit.sol\";\nimport {INonCustodialPSM} from \"./INonCustodialPSM.sol\";\nimport {GlobalRateLimitedMinter} from \"./../utils/GlobalRateLimitedMinter.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @notice Peg Stability Module that holds no funds.\n/// On a mint, it transfers all proceeds to a PCV Deposit\n/// When funds are needed for a redemption, they are simply pulled from the PCV Deposit\ncontract NonCustodialPSM is\n    OracleRef,\n    RateLimited,\n    ReentrancyGuard,\n    INonCustodialPSM\n{\n    using Decimal for Decimal.D256;\n    using SafeCast for *;\n    using SafeERC20 for IERC20;\n\n    /// @notice the fee in basis points for selling an asset into VOLT\n    uint256 public override mintFeeBasisPoints;\n\n    /// @notice the fee in basis points for buying the asset for VOLT\n    uint256 public override redeemFeeBasisPoints;\n\n    /// @notice the PCV deposit target to deposit and withdraw from\n    IPCVDeposit public override pcvDeposit;\n\n    /// @notice the token this PSM will exchange for VOLT\n    /// Must be a stable token pegged to $1\n    IERC20 public immutable override underlyingToken;\n\n    /// @notice Rate Limited Minter contract that will be called when VOLT needs to be minted\n    GlobalRateLimitedMinter public override rateLimitedMin"
    }
  ]
}