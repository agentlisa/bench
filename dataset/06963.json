{
  "Title": "[04] `PermissionManager.revoke` TRANSACTION CAN BE FRONTRUN",
  "Content": "Calling the following `PermissionManager.revoke` function, which further calls the `PermissionManager._revoke` function, would revoke the permission from an address for calling the corresponding functions on a target contract, such as when such address has become untrusted. However, such address can monitor the mempool and frontruns the relevant `PermissionManager.revoke` transaction so it can call the corresponding functions on the target contract in a malicious manner before losing the permission. For example, when the address, who has the permission associated with `REGISTER_STANDARD_CALLBACK_PERMISSION_ID`, becomes compromised or malicious, this address can frontrun the DAO's `PermissionManager.revoke` transaction to call the `DAO.registerStandardCallback` function with the `_callbackSelector` input being `IERC721ReceiverUpgradeable.onERC721Received.selector` and the `_magicNumber` input being a `bytes4` that is not `IERC721ReceiverUpgradeable.onERC721Received.selector`; then, the safe-transfers of any ERC721 tokens to the DAO can fail.\n\nAs a mitigation, flashbots can be used to keep the `PermissionManager.revoke` transactions away from the mempool for counteracting frontrunning.\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/core/permission/PermissionManager.sol#L135-L141\n```solidity\n    function revoke(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _revoke(_where, _who, _permissionId);\n    }\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/core/permission/PermissionManager.sol#L282-L289\n```solidity\n    function _revoke(address _where, address _who, bytes32 _permissionId) internal virtual {\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n        if (permissionsHashed[permHash] != UNSET_FLAG) {\n            permissionsHashed[permHash] = UNSET_FLAG;\n\n            emit Revoked(_permissionId, msg.sender, _where, _who);\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2023-03-aragon/blob/main/packages/contracts/src/core/dao/DAO.sol#L309-L317\n```solidity\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external override auth(REGISTER_STANDARD_CALLBACK_PERMISSION_ID) {\n        _registerInterface(_interfaceId);\n        _registerCallback(_callbackSelector, _magicNumber);\n        emit StandardCallbackRegistered(_interfaceId, _callbackSelector, _magicNumber);\n    }\n```\n\n**[novaknole20 (Aragon) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/179#issuecomment-1469609828):**\n> Frontrunning this function call implies that the frontrunner has permission to call this function which is already a security risk in itself.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-03-aragon-findings/issues/179#issuecomment-1488498685):**\n> Non-Critical\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-aragon",
  "Code": [
    {
      "filename": "packages/contracts/src/core/permission/PermissionManager.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./IPermissionCondition.sol\";\nimport \"./PermissionLib.sol\";\n\n/// @title PermissionManager\n/// @author Aragon Association - 2021-2023\n/// @notice The abstract permission manager used in a DAO, its associated plugins, and other framework-related components.\nabstract contract PermissionManager is Initializable {\n    /// @notice The ID of the permission required to call the `grant`, `grantWithCondition`, `revoke`, and `bulk` function.\n    bytes32 public constant ROOT_PERMISSION_ID = keccak256(\"ROOT_PERMISSION\");\n\n    /// @notice A special address encoding permissions that are valid for any address `who` or `where`.\n    address internal constant ANY_ADDR = address(type(uint160).max);\n\n    /// @notice A special address encoding if a permissions is not set and therefore not allowed.\n    address internal constant UNSET_FLAG = address(0);\n\n    /// @notice A special address encoding if a permission is allowed.\n    address internal constant ALLOW_FLAG = address(2);\n\n    /// @notice A mapping storing permissions as hashes (i.e., `permissionHash(where, who, permissionId)`) and their status encoded by an address (unset, allowed, or redirecting to a `PermissionCondition`).\n    mapping(bytes32 => address) internal permissionsHashed;\n\n    /// @notice Thrown if a call is unauthorized.\n    /// @param where The context in which the authorization reverted.\n    /// @param who The address (EOA or contract) missing the permission.\n    /// @param permissionId The permission identifier.\n    error Unauthorized(address where, address who, bytes32 permissionId);\n\n    /// @notice Thrown if a permission has been already granted with a different condition.\n    /// @dev This makes sure that condition on the same permission can not be overwriten by a different condition.\n    /// @param where The address of the target contract to grant `_who` permission to.\n    /// @param who The address (EOA or contract) to which the permission has already been granted.\n    /// @param permissionId The permission identifier.\n    /// @param currentCondition The current condition set for permissionId.\n    /// @param newCondition The new condition it tries to set for permissionId.\n    error PermissionAlreadyGrantedForDifferentCondition(\n        address where,\n        address who,\n        bytes32 permissionId,\n        address currentCondition,\n        address newCondition\n    );\n\n    /// @notice Thrown for permission grants where `who` or `where` is `ANY_ADDR`, but no condition is present.\n    error ConditionNotPresentForAnyAddress();\n\n    /// @notice Thrown for `ROOT_PERMISSION_ID` or `EXECUTE_PERMISSION_ID` permission grants where `who` or `where` is `ANY_ADDR`.\n    error PermissionsForAnyAddressDisallowed();\n\n    /// @notice Thrown for permission grants where `who` and `where` are both `ANY_ADDR`.\n    error AnyAddressDisallowedForWhoAndWhere();\n\n    /// @notice Emitted when a permission `permission` is granted in the context `here` to the address `_who` for the contract `_where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is granted.\n    /// @param where The address of the target contract for which `_who` receives permission.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param condition The address `ALLOW_FLAG` for regular permissions or, alternatively, the `PermissionCondition` to be used.\n    event Granted(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address where,\n        address indexed who,\n        IPermissionCondition condition\n    );\n\n    /// @notice Emitted when a permission `permission` is revoked in the context `here` from the address `_who` for the contract `_where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is revoked.\n    /// @param where The address of the target contract for which `_who` loses permission.\n    /// @param who The address (EOA or contract) losing the permission.\n    event Revoked(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address where,\n        address indexed who\n    );\n\n    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through this permission manager.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(bytes32 _permissionId) {\n        _auth(_permissionId);\n        _;\n    }\n\n    /// @notice Initialization method to set the initial owner of the permission manager.\n    /// @dev The initial owner is granted the `ROOT_PERMISSION_ID` permission.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function __PermissionManager_init(address _initialOwner) internal onlyInitializing {\n        _initializePermissionManager(_initialOwner);\n    }\n\n    /// @notice Grants permission to an address to call methods in a contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function grant(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _grant(_where, _who, _permissionId);\n    }\n\n    /// @notice Grants permission to an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier if the referenced condition permits it.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function grantWithCondition(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionCondition _condition\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _grantWithCondition(_where, _who, _permissionId, _condition);\n    }\n\n    /// @notice Revokes permission from an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `_who` loses permission.\n    /// @param _who The address (EOA or contract) losing the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function revoke(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _revoke(_where, _who, _permissionId);\n    }\n\n    /// @notice Applies an array of permission operations on a single target contracts `_where`.\n    /// @param _where The address of the single target contract.\n    /// @param items The array of single-targeted permission operations to apply.\n    function applySingleTargetPermissions(\n        address _where,\n        PermissionLib.SingleTargetPermission[] calldata items\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        for (uint256 i; i < items.length; ) {\n            PermissionLib.SingleTargetPermission memory item = items[i];\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(_where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(_where, item.who, item.permissionId);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Applies an array of permission operations on multiple target contracts `items[i].where`.\n    /// @param _items The array of multi-targeted permission operations to apply.\n    function applyMultiTargetPermissions(\n        PermissionLib.MultiTargetPermission[] calldata _items\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        for (uint256 i; i < _items.length; ) {\n            PermissionLib.MultiTargetPermission memory item = _items[i];\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.GrantWithCondition) {\n                _grantWithCondition(\n                    item.where,\n                    item.who,\n                    item.permissionId,\n                    IPermissionCondition(item.condition)\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) for which the permission is checked.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if `_who` has the permissions on the target contract via the specified permission identifier.\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) public view virtual returns (bool) {\n        return\n            _isGranted(_where, _who, _permissionId, _data) || // check if `_who` has permission for `_permissionId` on `_where`\n            _isGranted(_where, ANY_ADDR, _permissionId, _data) || // check if anyone has permission for `_permissionId` on `_where`\n            _isGranted(ANY_ADDR, _who, _permissionId, _data); // check if `_who` has permission for `_permissionI` on any contract\n    }\n\n    /// @notice Grants the `ROOT_PERMISSION_ID` permission to the initial owner during initialization of the permission manager.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function _initializePermissionManager(address _initialOwner) internal {\n        _grant(address(this), _initialOwner, ROOT_PERMISSION_ID);\n    }\n\n    /// @notice This method is used in the public `grant` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    function _grant(address _where, address _who, bytes32 _permissionId) internal virtual {\n        _grantWithCondition(_where, _who, _permissionId, IPermissionCondition(ALLOW_FLAG));\n    }\n\n    /// @notice This method is used in the internal `_grant` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _condition An address either resolving to a `PermissionCondition` contract address or being the `ALLOW_FLAG` address (`address(2)`).\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function _grantWithCondition(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionCondition _condition\n    ) internal virtual {\n        if (_where == ANY_ADDR && _who == ANY_ADDR) {\n            revert AnyAddressDisallowedForWhoAndWhere();\n        }\n\n        if (_where == ANY_ADDR || _who == ANY_ADDR) {\n            bool isRestricted = isPermissionRestrictedForAnyAddr(_permissionId);\n            if (_permissionId == ROOT_PERMISSION_ID || isRestricted) {\n                revert PermissionsForAnyAddressDisallowed();\n            }\n\n            if (address(_condition) == ALLOW_FLAG) {\n                revert ConditionNotPresentForAnyAddress();\n            }\n        }\n\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n\n        address currentCondition = permissionsHashed[permHash];\n        address newCondition = address(_condition);\n\n        // Means permHash is not currently set.\n        if (currentCondition == UNSET_FLAG) {\n            permissionsHashed[permHash] = newCondition;\n\n            emit Granted(_permissionId, msg.sender, _where, _who, _condition);\n        } else if (currentCondition != newCondition) {\n            // Revert if `permHash` is already granted, but uses a different condition.\n            // If we don't revert, we either should:\n            //   - allow overriding the condition on the same permission\n            //     which could be confusing whoever granted the same permission first\n            //   - or do nothing and succeed silently which could be confusing for the caller.\n            revert PermissionAlreadyGrantedForDifferentCondition({\n                where: _where,\n                who: _who,\n                permissionId: _permissionId,\n                currentCondition: currentCondition,\n                newCondition: newCondition\n            });\n        }\n    }\n\n    /// @notice This method is used in the public `revoke` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that might have been granted in parallel.\n    function _revoke(address _where, address _who, bytes32 _permissionId) internal virtual {\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n        if (permissionsHashed[permHash] != UNSET_FLAG) {\n            permissionsHashed[permHash] = UNSET_FLAG;\n\n            emit Revoked(_permissionId, msg.sender, _where, _who);\n        }\n    }\n\n    /// @notice Checks if a caller is granted permissions on a target contract via a permission identifier and redirects the approval to a `PermissionCondition` if this was specified in the setup.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if `_who` has the permissions on the contract via the specified permissionId identifier.\n    function _isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) internal view virtual returns (bool) {\n        address accessFlagOrCondition = permissionsHashed[\n            permissionHash(_where, _who, _permissionId)\n        ];\n\n        if (accessFlagOrCondition == UNSET_FLAG) return false;\n        if (accessFlagOrCondition == ALLOW_FLAG) return true;\n\n        // Since it's not a flag, assume it's a PermissionCondition and try-catch to skip failures\n        try\n            IPermissionCondition(accessFlagOrCondition).isGranted(\n                _where,\n                _who,\n                _permissionId,\n                _data\n            )\n        returns (bool allowed) {\n            if (allowed) return true;\n        } catch {}\n\n        return false;\n    }\n\n    /// @notice A private function to be used to check permissions on the permission manager contract (`address(this)`) itself.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    function _auth(bytes32 _permissionId) internal view virtual {\n        if (!isGranted(address(this), msg.sender, _permissionId, msg.data)) {\n            revert Unauthorized({\n                where: address(this),\n                who: msg.sender,\n                permissionId: _permissionId\n            });\n        }\n    }\n\n    /// @notice Generates the hash for the `permissionsHashed` mapping obtained from the word \"PERMISSION\", the contract address, the address owning the permission, and the permission identifier.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @return The permission hash.\n    function permissionHash(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) internal pure virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"PERMISSION\", _who, _where, _permissionId));\n    }\n\n    /// @notice Decides if the granting permissionId is restricted when `_who = ANY_ADDR` or `_where = ANY_ADDR`.\n    /// @param _permissionId The permission identifier.\n    /// @return Whether or not the permission is restricted.\n    /// @dev By default, every permission is unrestricted and it is the derived contract's responsibility to override it. Note, that the `ROOT_PERMISSION_ID` is included not required to be set it again.\n    function isPermissionRestrictedForAnyAddr(\n        bytes32 _permissionId\n    ) internal view virtual returns (bool) {\n        (_permissionId); // silence the warning.\n        return false;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}"
    },
    {
      "filename": "packages/contracts/src/core/permission/PermissionManager.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./IPermissionCondition.sol\";\nimport \"./PermissionLib.sol\";\n\n/// @title PermissionManager\n/// @author Aragon Association - 2021-2023\n/// @notice The abstract permission manager used in a DAO, its associated plugins, and other framework-related components.\nabstract contract PermissionManager is Initializable {\n    /// @notice The ID of the permission required to call the `grant`, `grantWithCondition`, `revoke`, and `bulk` function.\n    bytes32 public constant ROOT_PERMISSION_ID = keccak256(\"ROOT_PERMISSION\");\n\n    /// @notice A special address encoding permissions that are valid for any address `who` or `where`.\n    address internal constant ANY_ADDR = address(type(uint160).max);\n\n    /// @notice A special address encoding if a permissions is not set and therefore not allowed.\n    address internal constant UNSET_FLAG = address(0);\n\n    /// @notice A special address encoding if a permission is allowed.\n    address internal constant ALLOW_FLAG = address(2);\n\n    /// @notice A mapping storing permissions as hashes (i.e., `permissionHash(where, who, permissionId)`) and their status encoded by an address (unset, allowed, or redirecting to a `PermissionCondition`).\n    mapping(bytes32 => address) internal permissionsHashed;\n\n    /// @notice Thrown if a call is unauthorized.\n    /// @param where The context in which the authorization reverted.\n    /// @param who The address (EOA or contract) missing the permission.\n    /// @param permissionId The permission identifier.\n    error Unauthorized(address where, address who, bytes32 permissionId);\n\n    /// @notice Thrown if a permission has been already granted with a different condition.\n    /// @dev This makes sure that condition on the same permission can not be overwriten by a different condition.\n    /// @param where The address of the target contract to grant `_who` permission to.\n    /// @param who The address (EOA or contract) to which the permission has already been granted.\n    /// @param permissionId The permission identifier.\n    /// @param currentCondition The current condition set for permissionId.\n    /// @param newCondition The new condition it tries to set for permissionId.\n    error PermissionAlreadyGrantedForDifferentCondition(\n        address where,\n        address who,\n        bytes32 permissionId,\n        address currentCondition,\n        address newCondition\n    );\n\n    /// @notice Thrown for permission grants where `who` or `where` is `ANY_ADDR`, but no condition is present.\n    error ConditionNotPresentForAnyAddress();\n\n    /// @notice Thrown for `ROOT_PERMISSION_ID` or `EXECUTE_PERMISSION_ID` permission grants where `who` or `where` is `ANY_ADDR`.\n    error PermissionsForAnyAddressDisallowed();\n\n    /// @notice Thrown for permission grants where `who` and `where` are both `ANY_ADDR`.\n    error AnyAddressDisallowedForWhoAndWhere();\n\n    /// @notice Emitted when a permission `permission` is granted in the context `here` to the address `_who` for the contract `_where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is granted.\n    /// @param where The address of the target contract for which `_who` receives permission.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param condition The address `ALLOW_FLAG` for regular permissions or, alternatively, the `PermissionCondition` to be used.\n    event Granted(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address where,\n        address indexed who,\n        IPermissionCondition condition\n    );\n\n    /// @notice Emitted when a permission `permission` is revoked in the context `here` from the address `_who` for the contract `_where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is revoked.\n    /// @param where The address of the target contract for which `_who` loses permission.\n    /// @param who The address (EOA or contract) losing the permission.\n    event Revoked(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address where,\n        address indexed who\n    );\n\n    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through this permission manager.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(bytes32 _permissionId) {\n        _auth(_permissionId);\n        _;\n    }\n\n    /// @notice Initialization method to set the initial owner of the permission manager.\n    /// @dev The initial owner is granted the `ROOT_PERMISSION_ID` permission.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function __PermissionManager_init(address _initialOwner) internal onlyInitializing {\n        _initializePermissionManager(_initialOwner);\n    }\n\n    /// @notice Grants permission to an address to call methods in a contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function grant(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _grant(_where, _who, _permissionId);\n    }\n\n    /// @notice Grants permission to an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier if the referenced condition permits it.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function grantWithCondition(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionCondition _condition\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _grantWithCondition(_where, _who, _permissionId, _condition);\n    }\n\n    /// @notice Revokes permission from an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `_who` loses permission.\n    /// @param _who The address (EOA or contract) losing the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function revoke(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _revoke(_where, _who, _permissionId);\n    }\n\n    /// @notice Applies an array of permission operations on a single target contracts `_where`.\n    /// @param _where The address of the single target contract.\n    /// @param items The array of single-targeted permission operations to apply.\n    function applySingleTargetPermissions(\n        address _where,\n        PermissionLib.SingleTargetPermission[] calldata items\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        for (uint256 i; i < items.length; ) {\n            PermissionLib.SingleTargetPermission memory item = items[i];\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(_where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(_where, item.who, item.permissionId);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Applies an array of permission operations on multiple target contracts `items[i].where`.\n    /// @param _items The array of multi-targeted permission operations to apply.\n    function applyMultiTargetPermissions(\n        PermissionLib.MultiTargetPermission[] calldata _items\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        for (uint256 i; i < _items.length; ) {\n            PermissionLib.MultiTargetPermission memory item = _items[i];\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.GrantWithCondition) {\n                _grantWithCondition(\n                    item.where,\n                    item.who,\n                    item.permissionId,\n                    IPermissionCondition(item.condition)\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) for which the permission is checked.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if `_who` has the permissions on the target contract via the specified permission identifier.\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) public view virtual returns (bool) {\n        return\n            _isGranted(_where, _who, _permissionId, _data) || // check if `_who` has permission for `_permissionId` on `_where`\n            _isGranted(_where, ANY_ADDR, _permissionId, _data) || // check if anyone has permission for `_permissionId` on `_where`\n            _isGranted(ANY_ADDR, _who, _permissionId, _data); // check if `_who` has permission for `_permissionI` on any contract\n    }\n\n    /// @notice Grants the `ROOT_PERMISSION_ID` permission to the initial owner during initialization of the permission manager.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function _initializePermissionManager(address _initialOwner) internal {\n        _grant(address(this), _initialOwner, ROOT_PERMISSION_ID);\n    }\n\n    /// @notice This method is used in the public `grant` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    function _grant(address _where, address _who, bytes32 _permissionId) internal virtual {\n        _grantWithCondition(_where, _who, _permissionId, IPermissionCondition(ALLOW_FLAG));\n    }\n\n    /// @notice This method is used in the internal `_grant` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _condition An address either resolving to a `PermissionCondition` contract address or being the `ALLOW_FLAG` address (`address(2)`).\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function _grantWithCondition(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionCondition _condition\n    ) internal virtual {\n        if (_where == ANY_ADDR && _who == ANY_ADDR) {\n            revert AnyAddressDisallowedForWhoAndWhere();\n        }\n\n        if (_where == ANY_ADDR || _who == ANY_ADDR) {\n            bool isRestricted = isPermissionRestrictedForAnyAddr(_permissionId);\n            if (_permissionId == ROOT_PERMISSION_ID || isRestricted) {\n                revert PermissionsForAnyAddressDisallowed();\n            }\n\n            if (address(_condition) == ALLOW_FLAG) {\n                revert ConditionNotPresentForAnyAddress();\n            }\n        }\n\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n\n        address currentCondition = permissionsHashed[permHash];\n        address newCondition = address(_condition);\n\n        // Means permHash is not currently set.\n        if (currentCondition == UNSET_FLAG) {"
    }
  ]
}