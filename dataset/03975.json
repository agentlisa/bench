{
  "Title": "[L18] Lack of checks for denominator",
  "Content": "The [`FractionUtil` library](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol) adds the functionality to use [`Fractions`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L10-L13).\n\n\nThese Fractions consist of two numbers, an integer numerator and an integer denominator, where the denominator should not be zero or otherwise it could create a division by zero, which may cause a `VM error: invalid opcode` error during execution.\n\n\nNevertheless, the functions inside the library do not have checks for this issue and the output may not be correct in almost all functions. For instance, [the `reduce` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L15) would return the same Fraction when reducing multiples of `(1,0)`, [the `equals` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L41) would return `true` when comparing `(0,1) == (0,0)`, and [the `div` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L112) would return `(y.denominator,0)` for the pair `(1,0)` and `(y.numerator, y.denominator)`.\n\n\nThis library is only used in [the `getOracleExchangeRate` function from the `Exchange` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Exchange.sol#L356). There, a new [`Fraction` variable](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/FractionUtil.sol#L10-L13) is created with the output from [the `medianRate` function of the `SortedOracles`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L187). In particular, the `rateDenominator` [could be zero if the `numRates(token) == 0`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L188) in the `SortedOracle` contract and no further checks will be done for this variable causing [a division by zero in the `getOracleExchangeRate` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Exchange.sol#L356) of the `Exchange` contract . If this `Fraction` is then used in any of the previously mentioned methods from the `FractionUtil` library, then the actual result will not be the expected value.\n\n\nConsider adding checks to eliminate the possibility of haveing zero as denominator in all the places where the methods from the `FractionUtil` library are used, or adding those checks in the library methods themselves.\n\n\n***Update**: Fixed in [pull request #2890](https://github.com/celo-org/celo-monorepo/pull/2890). The [`FractionUtil` contract was removed](https://github.com/celo-org/celo-monorepo/pull/2890/files#diff-a6ab9ebb5bec0a336a6b4614bd82063c). The [fraction is now calculated by calling the `div` function](https://github.com/celo-org/celo-monorepo/pull/2890/files#diff-b3cbc9c000b2a3d8f2f8360587d70368R290) from the `SafeMath` library, which checks that it is not 0.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/FractionUtil.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n// TODO(asa): Move to uint128 if gas savings are significant enough.\nlibrary FractionUtil {\n  using SafeMath for uint256;\n  using FractionUtil for Fraction;\n\n  struct Fraction {\n    uint256 numerator;\n    uint256 denominator;\n  }\n\n  function reduce(Fraction memory x) internal pure returns (Fraction memory) {\n    uint256 gcd = x.denominator;\n    uint256 y = x.numerator;\n    while (y != 0) {\n      uint256 y_ = gcd % y;\n      gcd = y;\n      y = y_;\n    }\n    Fraction memory fraction = Fraction(x.numerator.div(gcd), x.denominator.div(gcd));\n    return fraction;\n  }\n\n  /**\n   * @dev Returns whether or not at least one of numerator and denominator are non-zero.\n   * @return Whether or not at least one of numerator and denominator are non-zero.\n   */\n  function exists(Fraction memory x) internal pure returns (bool) {\n    return x.numerator > 0 || x.denominator > 0;\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x == y\n   */\n  function equals(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) == y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns a new fraction that is the sum of two rates.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x + y\n   */\n  function add(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    return\n      Fraction(\n        x.numerator.mul(y.denominator).add(y.numerator.mul(x.denominator)),\n        x.denominator.mul(y.denominator)\n      )\n        .reduce();\n  }\n\n  /**\n   * @dev Returns a new fraction that is the two rates subtracted from each other.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x - y\n   */\n  function sub(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(isGreaterThanOrEqualTo(x, y));\n    return\n      Fraction(\n        x.numerator.mul(y.denominator).sub(y.numerator.mul(x.denominator)),\n        x.denominator.mul(y.denominator)\n      )\n        .reduce();\n  }\n\n  /**\n   * @dev Returns a fraction that is the fraction times a fraction.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x * y\n   */\n  function mul(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    return Fraction(x.numerator.mul(y.numerator), x.denominator.mul(y.denominator)).reduce();\n  }\n\n  /**\n   * @dev Returns an integer that is the fraction time an integer.\n   * @param x A Fraction struct.\n   * @param y An integer.\n   * @return x * y\n   */\n  function mul(Fraction memory x, uint256 y) internal pure returns (uint256) {\n    return x.numerator.mul(y).div(x.denominator);\n  }\n\n  /**\n   * @dev Returns the inverse of the fraction.\n   * @param x A Fraction struct.\n   * @return 1 / x\n   */\n  function inverse(Fraction memory x) internal pure returns (Fraction memory) {\n    require(x.numerator != 0);\n    return Fraction(x.denominator, x.numerator);\n  }\n\n  /**\n   * @dev Returns a fraction that is the fraction divided by a fraction.\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x / y\n   */\n  function div(Fraction memory x, Fraction memory y) internal pure returns (Fraction memory) {\n    require(y.numerator != 0);\n    return Fraction(x.numerator.mul(y.denominator), x.denominator.mul(y.numerator));\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is greater than fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x > y\n   */\n  function isGreaterThan(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) > y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is greater than or equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x >= y\n   */\n  function isGreaterThanOrEqualTo(Fraction memory x, Fraction memory y)\n    internal\n    pure\n    returns (bool)\n  {\n    return x.numerator.mul(y.denominator) >= y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is less than fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x < y\n   */\n  function isLessThan(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) < y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"x\" is less than or equal to fraction \"y\".\n   * @param x A Fraction struct.\n   * @param y A Fraction struct.\n   * @return x <= y\n   */\n  function isLessThanOrEqualTo(Fraction memory x, Fraction memory y) internal pure returns (bool) {\n    return x.numerator.mul(y.denominator) <= y.numerator.mul(x.denominator);\n  }\n\n  /**\n   * @dev Returns whether fraction \"z\" is between fractions \"x\" and \"y\".\n   * @param z A Fraction struct.\n   * @param x A Fraction struct representing a rate lower than \"y\".\n   * @param y A Fraction struct representing a rate higher than \"x\".\n   * @return x <= z <= y\n   */\n  function isBetween(Fraction memory z, Fraction memory x, Fraction memory y)\n    internal\n    pure\n    returns (bool)\n  {\n    return isLessThanOrEqualTo(x, z) && isLessThanOrEqualTo(z, y);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/stability/Exchange.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./interfaces/IExchange.sol\";\nimport \"./interfaces/ISortedOracles.sol\";\nimport \"./interfaces/IReserve.sol\";\nimport \"./interfaces/IStableToken.sol\";\nimport \"../common/FractionUtil.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../baklava/Freezable.sol\";\nimport \"../common/UsingRegistry.sol\";\n\n/**\n * @title Contract that allows to exchange StableToken for GoldToken and vice versa\n * using a Constant Product Market Maker Model\n */\ncontract Exchange is IExchange, Initializable, Ownable, UsingRegistry, ReentrancyGuard, Freezable {\n  using SafeMath for uint256;\n  using FractionUtil for FractionUtil.Fraction;\n  using FixidityLib for FixidityLib.Fraction;\n\n  event Exchanged(address indexed exchanger, uint256 sellAmount, uint256 buyAmount, bool soldGold);\n\n  event UpdateFrequencySet(uint256 updateFrequency);\n\n  event MinimumReportsSet(uint256 minimumReports);\n\n  event StableTokenSet(address stable);\n\n  event SpreadSet(uint256 spread);\n\n  event ReserveFractionSet(uint256 reserveFraction);\n\n  FixidityLib.Fraction public spread;\n\n  // Fraction of the Reserve that is committed to the gold bucket when updating\n  // buckets.\n  FixidityLib.Fraction public reserveFraction;\n\n  address public stable;\n\n  // Size of the Uniswap gold bucket\n  uint256 public goldBucket;\n  // Size of the Uniswap stable token bucket\n  uint256 public stableBucket;\n\n  uint256 public lastBucketUpdate = 0;\n  uint256 public updateFrequency;\n  uint256 public minimumReports;\n\n  modifier updateBucketsIfNecessary() {\n    _updateBucketsIfNecessary();\n    _;\n  }\n\n  /**\n   * @dev Initializes the exchange, setting initial bucket sizes\n   * @param registryAddress Address of the Registry contract\n   * @param stableToken Address of the stable token\n   * @param _spread Spread charged on exchanges\n   * @param _reserveFraction Fraction to commit to the gold bucket\n   * @param _updateFrequency The time period that needs to elapse between bucket\n   * updates\n   * @param _minimumReports The minimum number of fresh reports that need to be\n   * present in the oracle to update buckets\n   * commit to the gold bucket\n   */\n  function initialize(\n    address registryAddress,\n    address _freezer,\n    address stableToken,\n    uint256 _spread,\n    uint256 _reserveFraction,\n    uint256 _updateFrequency,\n    uint256 _minimumReports\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setFreezer(_freezer);\n    setRegistry(registryAddress);\n    setStableToken(stableToken);\n    setSpread(_spread);\n    setReserveFraction(_reserveFraction);\n    setUpdateFrequency(_updateFrequency);\n    setMinimumReports(_minimumReports);\n    _updateBucketsIfNecessary();\n  }\n\n  /**\n   * @dev Exchanges sellAmount of sellToken in exchange for at least minBuyAmount of buyToken\n   * Requires the sellAmount to have been approved to the exchange\n   * @param sellAmount The amount of sellToken the user is selling to the exchange\n   * @param minBuyAmount The minimum amount of buyToken the user has to receive for this\n   * transaction to succeed\n   * @param sellGold `true` if gold is the sell token\n   * @return The amount of buyToken that was transfered\n   * @dev This function can be frozen using the Freezable interface.\n   */\n  function exchange(uint256 sellAmount, uint256 minBuyAmount, bool sellGold)\n    external\n    onlyWhenNotFrozen\n    updateBucketsIfNecessary\n    nonReentrant\n    returns (uint256)\n  {\n    uint256 buyAmount = _getBuyTokenAmount(sellAmount, sellGold);\n\n    require(buyAmount >= minBuyAmount, \"Calculated buyAmount was less than specified minBuyAmount\");\n\n    IReserve reserve = IReserve(registry.getAddressForOrDie(RESERVE_REGISTRY_ID));\n\n    if (sellGold) {\n      goldBucket = goldBucket.add(sellAmount);\n      stableBucket = stableBucket.sub(buyAmount);\n      require(\n        getGoldToken().transferFrom(msg.sender, address(reserve), sellAmount),\n        \"Transfer of sell token failed\"\n      );\n      require(IStableToken(stable).mint(msg.sender, buyAmount), \"Mint of stable token failed\");\n    } else {\n      stableBucket = stableBucket.add(sellAmount);\n      goldBucket = goldBucket.sub(buyAmount);\n      require(\n        IERC20Token(stable).transferFrom(msg.sender, address(this), sellAmount),\n        \"Transfer of sell token failed\"\n      );\n      IStableToken(stable).burn(sellAmount);\n\n      require(reserve.transferGold(msg.sender, buyAmount), \"Transfer of buyToken failed\");\n    }\n\n    emit Exchanged(msg.sender, sellAmount, buyAmount, sellGold);\n    return buyAmount;\n  }\n\n  /**\n   * @dev Returns the amount of buyToken a user would get for sellAmount of sellToken\n   * @param sellAmount The amount of sellToken the user is selling to the exchange\n   * @param sellGold `true` if gold is the sell token\n   * @return The corresponding buyToken amount.\n   */\n  function getBuyTokenAmount(uint256 sellAmount, bool sellGold) external view returns (uint256) {\n    uint256 sellTokenBucket;\n    uint256 buyTokenBucket;\n    (buyTokenBucket, sellTokenBucket) = getBuyAndSellBuckets(sellGold);\n\n    FixidityLib.Fraction memory reducedSellAmount = getReducedSellAmount(sellAmount);\n    FixidityLib.Fraction memory numerator = reducedSellAmount.multiply(\n      FixidityLib.newFixed(buyTokenBucket)\n    );\n    FixidityLib.Fraction memory denominator = FixidityLib.newFixed(sellTokenBucket).add(\n      reducedSellAmount\n    );\n\n    // Can't use FixidityLib.divide because denominator can easily be greater\n    // than maxFixedDivisor.\n    // Fortunately, we expect an integer result, so integer division gives us as\n    // much precision as we could hope for.\n    return numerator.unwrap() / denominator.unwrap();\n  }\n\n  /**\n   * @dev Returns the amount of sellToken a user would need to exchange to receive buyAmount of\n   * buyToken.\n   * @param buyAmount The amount of buyToken the user would like to purchase.\n   * @param sellGold `true` if gold is the sell token\n   * @return The corresponding sellToken amount.\n   */\n  function getSellTokenAmount(uint256 buyAmount, bool sellGold) external view returns (uint256) {\n    uint256 sellTokenBucket;\n    uint256 buyTokenBucket;\n    (buyTokenBucket, sellTokenBucket) = getBuyAndSellBuckets(sellGold);\n\n    FixidityLib.Fraction memory numerator = FixidityLib.newFixed(buyAmount.mul(sellTokenBucket));\n    FixidityLib.Fraction memory denominator = FixidityLib\n      .newFixed(buyTokenBucket.sub(buyAmount))\n      .multiply(FixidityLib.fixed1().subtract(spread));\n\n    // See comment in getBuyTokenAmount\n    return numerator.unwrap() / denominator.unwrap();\n  }\n\n  /**\n   * @notice Returns the buy token and sell token bucket sizes, in order. The ratio of\n   * the two also represents the exchange rate between the two.\n   * @param sellGold `true` if gold is the sell token\n   * @return (buyTokenBucket, sellTokenBucket)\n   */\n  function getBuyAndSellBuckets(bool sellGold) public view returns (uint256, uint256) {\n    uint256 currentGoldBucket = goldBucket;\n    uint256 currentStableBucket = stableBucket;\n\n    if (shouldUpdateBuckets()) {\n      (currentGoldBucket, currentStableBucket) = getUpdatedBuckets();\n    }\n\n    if (sellGold) {\n      return (currentStableBucket, currentGoldBucket);\n    } else {\n      return (currentGoldBucket, currentStableBucket);\n    }\n  }\n\n  /**\n    * @notice Allows owner to set the update frequency\n    * @param newUpdateFrequency The new update frequency\n    */\n  function setUpdateFrequency(uint256 newUpdateFrequency) public onlyOwner {\n    updateFrequency = newUpdateFrequency;\n    emit UpdateFrequencySet(newUpdateFrequency);\n  }\n\n  /**\n    * @notice Allows owner to set the minimum number of reports required\n    * @param newMininumReports The new update minimum number of reports required\n    */\n  function setMinimumReports(uint256 newMininumReports) public onlyOwner {\n    minimumReports = newMininumReports;\n    emit MinimumReportsSet(newMininumReports);\n  }\n\n  function setFreezer(address freezer) public onlyOwner {\n    _setFreezer(freezer);\n  }\n\n  /**\n    * @notice Allows owner to set the Stable Token address\n    * @param newStableToken The new address for Stable Token\n    */\n  function setStableToken(address newStableToken) public onlyOwner {\n    stable = newStableToken;\n    emit StableTokenSet(newStableToken);\n  }\n\n  /**\n    * @notice Allows owner to set the spread\n    * @param newSpread The new value for the spread\n    */\n  function setSpread(uint256 newSpread) public onlyOwner {\n    spread = FixidityLib.wrap(newSpread);\n    emit SpreadSet(newSpread);\n  }\n\n  /**\n    * @notice Allows owner to set the Reserve Fraction\n    * @param newReserveFraction The new value for the reserve fraction\n    */\n  function setReserveFraction(uint256 newReserveFraction) public onlyOwner {\n    reserveFraction = FixidityLib.wrap(newReserveFraction);\n    emit ReserveFractionSet(newReserveFraction);\n  }\n\n  /**\n   * @notice Returns the sell token and buy token bucket sizes, in order. The ratio of\n   * the two also represents the exchange rate between the two.\n   * @param sellGold `true` if gold is the sell token\n   * @return (sellTokenBucket, buyTokenBucket)\n   */\n  function _getBuyAndSellBuckets(bool sellGold) private view returns (uint256, uint256) {\n    if (sellGold) {\n      return (stableBucket, goldBucket);\n    } else {\n      return (goldBucket, stableBucket);\n    }\n  }\n\n  /**\n   * @dev Returns the amount of buyToken a user would get for sellAmount of sellToken\n   * @param sellAmount The amount of sellToken the user is selling to the exchange\n   * @param sellGold `true` if gold is the sell token\n   * @return The corresponding buyToken amount.\n   */\n  function _getBuyTokenAmount(uint256 sellAmount, bool sellGold) private view returns (uint256) {\n    uint256 sellTokenBucket;\n    uint256 buyTokenBucket;\n    (buyTokenBucket, sellTokenBucket) = _getBuyAndSellBuckets(sellGold);\n\n    FixidityLib.Fraction memory reducedSellAmount = getReducedSellAmount(sellAmount);\n    FixidityLib.Fraction memory numerator = reducedSellAmount.multiply(\n      FixidityLib.newFixed(buyTokenBucket)\n    );\n    FixidityLib.Fraction memory denominator = FixidityLib.newFixed(sellTokenBucket).add(\n      reducedSellAmount\n    );\n\n    // See comment in getBuyTokenAmount\n    return numerator.unwrap() / denominator.unwrap();\n  }\n\n  function getUpdatedBuckets() private view returns (uint256, uint256) {\n    uint256 updatedGoldBucket = getUpdatedGoldBucket();\n    uint256 updatedStableBucket = getOracleExchangeRate().mul(updatedGoldBucket);\n\n    return (updatedGoldBucket, updatedStableBucket);\n  }\n\n  function getUpdatedGoldBucket() private view returns (uint256) {\n    uint256 reserveGoldBalance = getGoldToken().balanceOf(\n      registry.getAddressForOrDie(RESERVE_REGISTRY_ID)\n    );\n    return reserveFraction.multiply(FixidityLib.newFixed(reserveGoldBalance)).fromFixed();\n  }\n\n  /**\n   * @notice If conditions are met, updates the Uniswap bucket sizes to track\n   * the price reported by the Oracle.\n   */\n  function _updateBucketsIfNecessary() private {\n    if (shouldUpdateBuckets()) {\n      // solhint-disable-next-line not-rely-on-time\n      lastBucketUpdate = now;\n\n      (goldBucket, stableBucket) = getUpdatedBuckets();\n    }\n  }\n\n  /**\n   * @dev Calculates the sell amount reduced by the spread.\n   * @param sellAmount The original sell amount.\n   * @return The reduced sell amount, computed as (1 - spread) * sellAmount\n   */\n  function getReducedSellAmount(uint256 sellAmount)\n    private\n    view\n    returns (FixidityLib.Fraction memory)\n  {\n    return FixidityLib.fixed1().subtract(spread).multiply(FixidityLib.newFixed(sellAmount));\n  }\n\n  /*\n   * Checks conditions required for bucket updates.\n   * @return Whether or not buckets should be updated.\n   * TODO: check the oldest report isn't expired\n   */\n  function shouldUpdateBuckets() private view returns (bool) {\n    ISortedOracles sortedOracles = ISortedOracles(\n      registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID)\n    );\n    // solhint-disable-next-line not-rely-on-time\n    bool timePassed = now >= lastBucketUpdate.add(updateFrequency);\n    bool enoughReports = sortedOracles.numRates(stable) >= minimumReports;\n    // solhint-disable-next-line not-rely-on-time\n    bool medianReportRecent = sortedOracles.medianTimestamp(stable) > now.sub(updateFrequency);\n    return timePassed && enoughReports && medianReportRecent;\n  }\n\n  function getOracleExchangeRate() private view returns (FractionUtil.Fraction memory) {\n    uint256 rateNumerator;\n    uint256 rateDenominator;\n    (rateNumerator, rateDenominator) = ISortedOracles(\n      registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID)\n    )\n      .medianRate(stable);\n    return FractionUtil.Fraction(rateNumerator, rateDenominator);\n  }\n}"
    }
  ]
}