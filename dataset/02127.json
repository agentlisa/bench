{
  "Title": "M-2: Normal users could be inadvertently grieved by the withdrawn ratios check",
  "Content": "# Issue M-2: Normal users could be inadvertently grieved by the withdrawn ratios check \n\nSource: https://github.com/sherlock-audit/2023-03-olympus-judging/issues/28 \n\n## Found by \nRaymondFam\n\n## Summary\nThe contract check on the withdrawn ratios of OHM and wstETH against the current oracle price could run into grieving naive users by taking any wstETH shifted imbalance as a fee to the treasury even though these users have not gamed the system. \n\n## Vulnerability Detail\nHere is a typical scenario, assuming the pool has been initiated with total LP equal to sqrt(100_000 * 1_000) = 10_000. (Note: OHM: $15, wstETH: $1500 with the pool pricing match up with [manager.getOhmTknPrice()](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L156) or [manager.getTknOhmPrice()](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L232), i.e. 100 OHM to 1 wstETH or 0.01 wstETH to 1 OHM. The pool token balances in each step below may be calculated via the [Constant Product Simulation](https://amm-calculator.vercel.app/) after each swap and stake.)\n\n    OHM token balance: 100_000\n    wstETH token balance: 1_000\n    Total LP: 10_000\n\n1. A series of swap activities results in the pool shifted more of the LP into wstETH.\n\n    OHM token balance: 90_909.1\n    wstETH token balance: 1_100\n    Total LP: 10_000\n\n2. Bob calls [`deposit()`](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L143) by providing 11 wstETH where 1100 OHM is minted with 1100 - 90909.1 * 0.01 = 190.91 unused OHM [burned](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L187-L190). (Note: Bob successfully stakes with 909.09 OHM and 11 wstETH and proportionately receives 100 LP.)\n\n    OHM token balance: 91_818.19\n    wstETH token balance: 1_111\n    Total LP: 10_100\n    User's LP: 100\n\n3. Bob changes his mind instantly and proceeds to call [`withdraw()`](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L203) to remove all of his LP. He receives the originally staked 909.09 OHM and 11 wstETH. All OHM is burned but he is only entitled to receive 909.09 / 100 = 9.09 wstETH since the system [takes any arbs](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L236-L240) relative to the oracle price for the Treasury and [returns the rest](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L247) to the owner.\n\n    OHM token balance: 90_909.1\n    wstETH token balance: 1_100\n    Total LP: 10_000\n    User's LP: 0\n\n## Impact\nBob suffers a loss of 11 - 9.09 = 1.91 wstETH  (~ 17.36% loss), and the system is ready to trap the next user given the currently imbalanced pool still shifted more of the LP into wstETH.\n\n## Code Snippet\n[File: BLVaultLido.sol#L143-L200](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L143-L200)\n\n[File: BLVaultLido.sol#L203-L256](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L203-L256)\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider implementing a snapshot of the entry record of OHM and wstETH and compare that with the proportionate exit record. Slash only the differential for treasury solely on dissuading large attempts to shift the pool around, and in this case it should be 0 wstETH since the originally staked wstETH is no greater than expectedWstethAmountOut.\n\n## Discussion\n\n**0xLienid**\n\nTrue, but this will be very very minor in practice. It relies on assuming no arbitrage is ever taken, it will also be helped (but not eliminated) by the solution to #003\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/60",
  "Code": [
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {IBLVaultLido, RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVaultLido.sol\";\nimport {IBLVaultManagerLido} from \"policies/BoostedLiquidity/interfaces/IBLVaultManagerLido.sol\";\nimport {BLVaultManagerLido} from \"policies/BoostedLiquidity/BLVaultManagerLido.sol\";\n\n// Import external dependencies\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IAuraBooster, IAuraRewardPool, IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\n\n// Import types\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Import libraries\nimport {Clone} from \"clones/Clone.sol\";\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\ncontract BLVaultLido is IBLVaultLido, Clone {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    // ========= ERRORS ========= //\n\n    error BLVaultLido_AlreadyInitialized();\n    error BLVaultLido_OnlyOwner();\n    error BLVaultLido_Inactive();\n    error BLVaultLido_Reentrancy();\n    error BLVaultLido_AuraDepositFailed();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(uint256 ohmAmount, uint256 wstethAmount);\n    event Withdraw(uint256 ohmAmount, uint256 wstethAmount);\n    event RewardsClaimed(address indexed rewardsToken, uint256 amount);\n\n    // ========= STATE VARIABLES ========= //\n\n    uint256 private constant _OHM_DECIMALS = 1e9;\n    uint256 private constant _WSTETH_DECIMALS = 1e18;\n\n    uint256 private _reentrancyStatus;\n\n    // ========= CONSTRUCTOR ========= //\n\n    constructor() {}\n\n    // ========= INITIALIZER ========= //\n\n    function initializeClone() external {\n        if (_reentrancyStatus != 0) revert BLVaultLido_AlreadyInitialized();\n        _reentrancyStatus = 1;\n    }\n\n    // ========= IMMUTABLE CLONE ARGS ========= //\n\n    function owner() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    function manager() public pure returns (BLVaultManagerLido) {\n        return BLVaultManagerLido(_getArgAddress(20));\n    }\n\n    function TRSRY() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    function MINTR() public pure returns (address) {\n        return _getArgAddress(60);\n    }\n\n    function ohm() public pure returns (OlympusERC20Token) {\n        return OlympusERC20Token(_getArgAddress(80));\n    }\n\n    function wsteth() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(100));\n    }\n\n    function aura() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(120));\n    }\n\n    function bal() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(140));\n    }\n\n    function vault() public pure returns (IVault) {\n        return IVault(_getArgAddress(160));\n    }\n\n    function liquidityPool() public pure returns (IBasePool) {\n        return IBasePool(_getArgAddress(180));\n    }\n\n    function pid() public pure returns (uint256) {\n        return _getArgUint256(200);\n    }\n\n    function auraBooster() public pure returns (IAuraBooster) {\n        return IAuraBooster(_getArgAddress(232));\n    }\n\n    function auraRewardPool() public pure returns (IAuraRewardPool) {\n        return IAuraRewardPool(_getArgAddress(252));\n    }\n\n    function fee() public pure returns (uint64) {\n        return _getArgUint64(272);\n    }\n\n    // ========= MODIFIERS ========= //\n\n    modifier onlyOwner() {\n        if (msg.sender != owner()) revert BLVaultLido_OnlyOwner();\n        _;\n    }\n\n    modifier onlyWhileActive() {\n        if (!manager().isLidoBLVaultActive()) revert BLVaultLido_Inactive();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_reentrancyStatus != 1) revert BLVaultLido_Reentrancy();\n\n        _reentrancyStatus = 2;\n\n        _;\n\n        _reentrancyStatus = 1;\n    }\n\n    //============================================================================================//\n    //                                      LIQUIDITY FUNCTIONS                                   //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function deposit(\n        uint256 amount_,\n        uint256 minLpAmount_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256 lpAmountOut) {\n        // Cache variables into memory\n        IBLVaultManagerLido manager = manager();\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IAuraBooster auraBooster = auraBooster();\n\n        // Calculate OHM amount to mint\n        // getOhmTknPrice returns the amount of OHM per 1 wstETH\n        uint256 ohmWstethPrice = manager.getOhmTknPrice();\n        uint256 ohmMintAmount = (amount_ * ohmWstethPrice) / _WSTETH_DECIMALS;\n\n        // Block scope to avoid stack too deep\n        {\n            // Cache OHM-wstETH BPT before\n            uint256 bptBefore = liquidityPool.balanceOf(address(this));\n\n            // Transfer in wstETH\n            wsteth.safeTransferFrom(msg.sender, address(this), amount_);\n\n            // Mint OHM\n            manager.mintOhmToVault(ohmMintAmount);\n\n            // Join Balancer pool\n            _joinBalancerPool(ohmMintAmount, amount_, minLpAmount_);\n\n            // OHM-PAIR BPT after\n            lpAmountOut = liquidityPool.balanceOf(address(this)) - bptBefore;\n            manager.increaseTotalLp(lpAmountOut);\n\n            // Stake into Aura\n            liquidityPool.approve(address(auraBooster), lpAmountOut);\n            bool depositSuccess = auraBooster.deposit(pid(), lpAmountOut, true);\n            if (!depositSuccess) revert BLVaultLido_AuraDepositFailed();\n        }\n\n        // Return unused tokens\n        uint256 unusedOhm = ohm.balanceOf(address(this));\n        uint256 unusedWsteth = wsteth.balanceOf(address(this));\n\n        if (unusedOhm > 0) {\n            ohm.increaseAllowance(MINTR(), unusedOhm);\n            manager.burnOhmFromVault(unusedOhm);\n        }\n\n        if (unusedWsteth > 0) {\n            wsteth.safeTransfer(msg.sender, unusedWsteth);\n        }\n\n        // Emit event\n        emit Deposit(ohmMintAmount - unusedOhm, amount_ - unusedWsteth);\n\n        return lpAmountOut;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256, uint256) {\n        // Cache variables into memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBLVaultManagerLido manager = manager();\n\n        // Cache OHM and wstETH balances before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 wstethBefore = wsteth.balanceOf(address(this));\n\n        // Decrease total LP\n        manager.decreaseTotalLp(lpAmount_);\n\n        // Unstake from Aura\n        auraRewardPool().withdrawAndUnwrap(lpAmount_, claim_);\n\n        // Exit Balancer pool\n        _exitBalancerPool(lpAmount_, minTokenAmounts_);\n\n        // Calculate OHM and wstETH amounts received\n        uint256 ohmAmountOut = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 wstethAmountOut = wsteth.balanceOf(address(this)) - wstethBefore;\n\n        // Calculate oracle expected wstETH received amount\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n            ? expectedWstethAmountOut\n            : wstethAmountOut;\n        if (wstethAmountOut > wstethToReturn)\n            wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n\n        // Burn OHM\n        ohm.increaseAllowance(MINTR(), ohmAmountOut);\n        manager.burnOhmFromVault(ohmAmountOut);\n\n        // Return wstETH to owner\n        wsteth.safeTransfer(msg.sender, wstethToReturn);\n\n        // Return rewards to owner\n        if (claim_) _sendRewards();\n\n        // Emit event\n        emit Withdraw(ohmAmountOut, wstethToReturn);\n\n        return (ohmAmountOut, wstethToReturn);\n    }\n\n    //============================================================================================//\n    //                                       REWARDS FUNCTIONS                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function claimRewards() external override onlyWhileActive onlyOwner nonReentrant {\n        // Claim rewards from Aura\n        auraRewardPool().getReward(owner(), true);\n\n        // Send rewards to owner\n        _sendRewards();\n    }\n\n    //============================================================================================//\n    //                                        VIEW FUNCTIONS                                      //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function getLpBalance() public view override returns (uint256) {\n        return auraRewardPool().balanceOf(address(this));\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getUserPairShare() public view override returns (uint256) {\n        // If total supply is 0 return 0\n        if (liquidityPool().totalSupply() == 0) return 0;\n\n        // Get user's LP balance\n        uint256 userLpBalance = getLpBalance();\n\n        // Get pool balances\n        (, uint256[] memory balances, ) = vault().getPoolTokens(liquidityPool().getPoolId());\n\n        // Get user's share of the wstETH\n        uint256 userWstethShare = (userLpBalance * balances[1]) / liquidityPool().totalSupply();\n\n        // Check pool against oracle price\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager().getTknOhmPrice();\n        uint256 userOhmShare = (userLpBalance * balances[0]) / liquidityPool().totalSupply();\n        uint256 expectedWstethShare = (userOhmShare * wstethOhmPrice) / _OHM_DECIMALS;\n\n        return userWstethShare > expectedWstethShare ? expectedWstethShare : userWstethShare;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getOutstandingRewards() public view override returns (RewardsData[] memory) {\n        uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n        RewardsData[] memory rewards = new RewardsData[](numExtraRewards + 2);\n\n        // Get Bal reward\n        uint256 balRewards = auraRewardPool().earned(address(this));\n        rewards[0] = RewardsData({rewardToken: address(bal()), outstandingRewards: balRewards});\n\n        // Get Aura rewards\n        uint256 auraRewards = manager().auraMiningLib().convertCrvToCvx(balRewards);\n        rewards[1] = RewardsData({rewardToken: address(aura()), outstandingRewards: auraRewards});\n\n        // Get extra rewards\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n\n            address extraRewardToken = extraRewardPool.rewardToken();\n            uint256 extraRewardAmount = extraRewardPool.earned(address(this));\n\n            rewards[i + 2] = RewardsData({\n                rewardToken: extraRewardToken,\n                outstandingRewards: extraRewardAmount\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewards;\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS                                    //\n    //============================================================================================//\n\n    function _joinBalancerPool(\n        uint256 ohmAmount_,\n        uint256 wstethAmount_,\n        uint256 minLpAmount_\n    ) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IVault vault = vault();\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmAmount_;\n        maxAmountsIn[1] = wstethAmount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, minLpAmount_),\n            fromInternalBalance: false\n        });\n\n        // Join pool\n        ohm.increaseAllowance(address(vault), ohmAmount_);\n        wsteth.approve(address(vault), wstethAmount_);\n        vault.joinPool(liquidityPool().getPoolId(), address(this), address(this), joinPoolRequest);\n    }\n\n    function _exitBalancerPool(uint256 lpAmount_, uint256[] calldata minTokenAmounts_) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IVault vault = vault();\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minTokenAmounts_,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        // Exit Balancer pool\n        liquidityPool.approve(address(vault), lpAmount_);\n        vault.exitPool(\n            liquidityPool.getPoolId(),\n            address(this),\n            payable(address(this)),\n            exitPoolRequest\n        );\n    }\n\n    function _sendRewards() internal {\n        // Send Bal rewards to owner\n        {\n            uint256 balRewards = bal().balanceOf(address(this));\n            uint256 balFee = (balRewards * fee()) / 10_000;\n            if (balRewards - balFee > 0) {\n                bal().safeTransfer(owner(), balRewards - balFee);\n                emit RewardsClaimed(address(bal()), balRewards - balFee);\n            }\n            if (balFee > 0) bal().safeTransfer(TRSRY(), balFee);\n        }\n\n        // Send Aura rewards to owner\n        {\n            uint256 auraRewards = aura().balanceOf(address(this));\n            uint256 auraFee = (auraRewards * fee()) / 10_000;\n            if (auraRewards - auraFee > 0) {\n                aura().safeTransfer(owner(), auraRewards - auraFee);\n                emit RewardsClaimed(address(aura()), auraRewards - auraFee);\n            }\n            if (auraFee > 0) aura().safeTransfer(TRSRY(), auraFee);\n        }\n\n        // Send extra rewards to owner\n        {\n            uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n            for (uint256 i; i < numExtraRewards; ) {\n                IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n                ERC20 extraRewardToken = ERC20(extraRewardPool.rewardToken());\n\n                uint256 extraRewardAmount = extraRewardToken.balanceOf(address(this));\n                uint256 extraRewardFee = (extraRewardAmount * fee()) / 10_000;\n                if (extraRewardAmount - extraRewardFee > 0) {\n                    extraRewardToken.safeTransfer(owner(), extraRewardAmount - extraRewardFee);\n                    emit RewardsClaimed(\n                        address(extraRewardToken),\n                        extraRewardAmount - extraRewardFee\n                    );\n                }\n                if (extraRewardFee > 0) extraRewardToken.safeTransfer(TRSRY(), extraRewardFee);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {IBLVaultLido, RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVaultLido.sol\";\nimport {IBLVaultManagerLido} from \"policies/BoostedLiquidity/interfaces/IBLVaultManagerLido.sol\";\nimport {BLVaultManagerLido} from \"policies/BoostedLiquidity/BLVaultManagerLido.sol\";\n\n// Import external dependencies\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IAuraBooster, IAuraRewardPool, IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\n\n// Import types\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Import libraries\nimport {Clone} from \"clones/Clone.sol\";\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\ncontract BLVaultLido is IBLVaultLido, Clone {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    // ========= ERRORS ========= //\n\n    error BLVaultLido_AlreadyInitialized();\n    error BLVaultLido_OnlyOwner();\n    error BLVaultLido_Inactive();\n    error BLVaultLido_Reentrancy();\n    error BLVaultLido_AuraDepositFailed();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(uint256 ohmAmount, uint256 wstethAmount);\n    event Withdraw(uint256 ohmAmount, uint256 wstethAmount);\n    event RewardsClaimed(address indexed rewardsToken, uint256 amount);\n\n    // ========= STATE VARIABLES ========= //\n\n    uint256 private constant _OHM_DECIMALS = 1e9;\n    uint256 private constant _WSTETH_DECIMALS = 1e18;\n\n    uint256 private _reentrancyStatus;\n\n    // ========= CONSTRUCTOR ========= //\n\n    constructor() {}\n\n    // ========= INITIALIZER ========= //\n\n    function initializeClone() external {\n        if (_reentrancyStatus != 0) revert BLVaultLido_AlreadyInitialized();\n        _reentrancyStatus = 1;\n    }\n\n    // ========= IMMUTABLE CLONE ARGS ========= //\n\n    function owner() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    function manager() public pure returns (BLVaultManagerLido) {\n        return BLVaultManagerLido(_getArgAddress(20));\n    }\n\n    function TRSRY() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    function MINTR() public pure returns (address) {\n        return _getArgAddress(60);\n    }\n\n    function ohm() public pure returns (OlympusERC20Token) {\n        return OlympusERC20Token(_getArgAddress(80));\n    }\n\n    function wsteth() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(100));\n    }\n\n    function aura() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(120));\n    }\n\n    function bal() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(140));\n    }\n\n    function vault() public pure returns (IVault) {\n        return IVault(_getArgAddress(160));\n    }\n\n    function liquidityPool() public pure returns (IBasePool) {\n        return IBasePool(_getArgAddress(180));\n    }\n\n    function pid() public pure returns (uint256) {\n        return _getArgUint256(200);\n    }\n\n    function auraBooster() public pure returns (IAuraBooster) {\n        return IAuraBooster(_getArgAddress(232));\n    }\n\n    function auraRewardPool() public pure returns (IAuraRewardPool) {\n        return IAuraRewardPool(_getArgAddress(252));\n    }\n\n    function fee() public pure returns (uint64) {\n        return _getArgUint64(272);\n    }\n\n    // ========= MODIFIERS ========= //\n\n    modifier onlyOwner() {\n        if (msg.sender != owner()) revert BLVaultLido_OnlyOwner();\n        _;\n    }\n\n    modifier onlyWhileActive() {\n        if (!manager().isLidoBLVaultActive()) revert BLVaultLido_Inactive();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_reentrancyStatus != 1) revert BLVaultLido_Reentrancy();\n\n        _reentrancyStatus = 2;\n\n        _;\n\n        _reentrancyStatus = 1;\n    }\n\n    //============================================================================================//\n    //                                      LIQUIDITY FUNCTIONS                                   //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function deposit(\n        uint256 amount_,\n        uint256 minLpAmount_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256 lpAmountOut) {\n        // Cache variables into memory\n        IBLVaultManagerLido manager = manager();\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IAuraBooster auraBooster = auraBooster();\n\n        // Calculate OHM amount to mint\n        // getOhmTknPrice returns the amount of OHM per 1 wstETH\n        uint256 ohmWstethPrice = manager.getOhmTknPrice();\n        uint256 ohmMintAmount = (amount_ * ohmWstethPrice) / _WSTETH_DECIMALS;\n\n        // Block scope to avoid stack too deep\n        {\n            // Cache OHM-wstETH BPT before\n            uint256 bptBefore = liquidityPool.balanceOf(address(this));\n\n            // Transfer in wstETH\n            wsteth.safeTransferFrom(msg.sender, address(this), amount_);\n\n            // Mint OHM\n            manager.mintOhmToVault(ohmMintAmount);\n\n            // Join Balancer pool\n            _joinBalancerPool(ohmMintAmount, amount_, minLpAmount_);\n\n            // OHM-PAIR BPT after\n            lpAmountOut = liquidityPool.balanceOf(address(this)) - bptBefore;\n            manager.increaseTotalLp(lpAmountOut);\n\n            // Stake into Aura\n            liquidityPool.approve(address(auraBooster), lpAmountOut);\n            bool depositSuccess = auraBooster.deposit(pid(), lpAmountOut, true);\n            if (!depositSuccess) revert BLVaultLido_AuraDepositFailed();\n        }\n\n        // Return unused tokens\n        uint256 unusedOhm = ohm.balanceOf(address(this));\n        uint256 unusedWsteth = wsteth.balanceOf(address(this));\n\n        if (unusedOhm > 0) {\n            ohm.increaseAllowance(MINTR(), unusedOhm);\n            manager.burnOhmFromVault(unusedOhm);\n        }\n\n        if (unusedWsteth > 0) {\n            wsteth.safeTransfer(msg.sender, unusedWsteth);\n        }\n\n        // Emit event\n        emit Deposit(ohmMintAmount - unusedOhm, amount_ - unusedWsteth);\n\n        return lpAmountOut;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256, uint256) {\n        // Cache variables into memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBLVaultManagerLido manager = manager();\n\n        // Cache OHM and wstETH balances before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 wstethBefore = wsteth.balanceOf(address(this));\n\n        // Decrease total LP\n        manager.decreaseTotalLp(lpAmount_);\n\n        // Unstake from Aura\n        auraRewardPool().withdrawAndUnwrap(lpAmount_, claim_);\n\n        // Exit Balancer pool\n        _exitBalancerPool(lpAmount_, minTokenAmounts_);\n\n        // Calculate OHM and wstETH amounts received\n        uint256 ohmAmountOut = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 wstethAmountOut = wsteth.balanceOf(address(this)) - wstethBefore;\n\n        // Calculate oracle expected wstETH received amount\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n            ? expectedWstethAmountOut\n            : wstethAmountOut;\n        if (wstethAmountOut > wstethToReturn)\n            wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n\n        // Burn OHM\n        ohm.increaseAllowance(MINTR(), ohmAmountOut);\n        manager.burnOhmFromVault(ohmAmountOut);\n\n        // Return wstETH to owner\n        wsteth.safeTransfer(msg.sender, wstethToReturn);\n\n        // Return rewards to owner\n        if (claim_) _sendRewards();\n\n        // Emit event\n        emit Withdraw(ohmAmountOut, wstethToReturn);\n\n        return (ohmAmountOut, wstethToReturn);\n    }\n\n    //============================================================================================//\n    //                                       REWARDS FUNCTIONS                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function claimRewards() external override onlyWhileActive onlyOwner nonReentrant {\n        // Claim rewards from Aura\n        auraRewardPool().getReward(owner(), true);\n\n        // Send rewards to owner\n        _sendRewards();\n    }\n\n    //============================================================================================//\n    //                                        VIEW FUNCTIONS                                      //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function getLpBalance() public view override returns (uint256) {\n        return auraRewardPool().balanceOf(address(this));\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getUserPairShare() public view override returns (uint256) {\n        // If total supply is 0 return 0\n        if (liquidityPool().totalSupply() == 0) return 0;\n\n        // Get user's LP balance\n        uint256 userLpBalance = getLpBalance();\n\n        // Get pool balances\n        (, uint256[] memory balances, ) = vault().getPoolTokens(liquidityPool().getPoolId());\n\n        // Get user's share of the wstETH\n        uint256 userWstethShare = (userLpBalance * balances[1]) / liquidityPool().totalSupply();\n\n        // Check pool against oracle price\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager().getTknOhmPrice();\n        uint256 userOhmShare = (userLpBalance * balances[0]) / liquidityPool().totalSupply();\n        uint256 expectedWstethShare = (userOhmShare * wstethOhmPrice) / _OHM_DECIMALS;\n\n        return userWstethShare > expectedWstethShare ? expectedWstethShare : userWstethShare;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getOutstandingRewards() public view override returns (RewardsData[] memory) {\n        uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n        RewardsData[] memory rewards = new RewardsData[](numExtraRewards + 2);\n\n        // Get Bal reward\n        uint256 balRewards = auraRewardPool().earned(address(this));\n        rewards[0] = RewardsData({rewardToken: address(bal()), outstandingRewards: balRewards});\n\n        // Get Aura rewards\n        uint256 auraRewards = manager().auraMiningLib().convertCrvToCvx(balRewards);\n        rewards[1] = RewardsData({rewardToken: address(aura()), outstandingRewards: auraRewards});\n\n        // Get extra rewards\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n\n            address extraRewardToken = extraRewardPool.rewardToken();\n            uint256 extraRewardAmount = extraRewardPool.earned(address(this));\n\n            rewards[i + 2] = RewardsData({\n                rewardToken: extraRewardToken,\n                outstandingRewards: extraRewardAmount\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewards;\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS                                    //\n    //============================================================================================//\n\n    function _joinBalancerPool(\n        uint256 ohmAmount_,\n        uint256 wstethAmount_,\n        uint256 minLpAmount_\n    ) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IVault vault = vault();\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmAmount_;\n        maxAmountsIn[1] = wstethAmount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, minLpAmount_),\n            fromInternalBalance: false\n        });\n\n        // Join pool\n        ohm.increaseAllowance(address(vault), ohmAmount_);\n        wsteth.approve(address(vault), wstethAmount_);\n        vault.joinPool(liquidityPool().getPoolId(), address(this), address(this), joinPoolRequest);\n    }\n\n    function _exitBalancerPool(uint256 lpAmount_, uint256[] calldata minTokenAmounts_) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IVault vault = vault();\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minTokenAmounts_,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        // Exit Balancer pool\n        liquidityPool.approve(address(vault), lpAmount_);\n        vault.exitPool(\n            liquidityPool.getPoolId(),\n            address(this),\n            payable(address(this)),\n            exitPoolRequest\n        );\n    }\n\n    function _sendRewards() internal {\n        // Send Bal rewards to owner\n        {\n            uint256 balRewards = bal().balanceOf(address(this));\n            uint256 balFee = (balRewards * fee()) / 10_000;\n            if (balRewards - balFee > 0) {\n                bal().safeTransfer(owner(), balRewards - balFee);\n                emit RewardsClaimed(address(bal()), balRewards - balFee);\n            }\n            if (balFee > 0) bal().safeTransfer(TRSRY(), balFee);\n        }\n\n        // Send Aura rewards to owner\n        {\n            uint256 auraRewards = aura().balanceOf(address(this));\n            uint256 auraFee = (auraRewards * fee()) / 10_000;\n            if (auraRewards - auraFee > 0) {\n                aura().safeTransfer(owner(), auraRewards - auraFee);\n                emit RewardsClaimed(address(aura()), auraRewards - auraFee);\n            }\n            if (auraFee > 0) aura().safeTransfer(TRSRY(), auraFee);\n        }\n\n        // Send extra rewards to owner\n        {\n            uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n            for (uint256 i; i < numExtraRewards; ) {\n                IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n                ERC20 extraRewardToken = ERC20(extraRewardPool.rewardToken());\n\n                uint256 extraRewardAmount = extraRewardToken.balanceOf(address(this));\n                uint256 extraRewardFee = (extraRewardAmount * fee()) / 10_000;\n                if (extraRewardAmount - extraRewardFee > 0) {\n                    extraRewardToken.safeTransfer(owner(), extraRewardAmount - extraRewardFee);\n                    emit RewardsClaimed(\n                        address(extraRewardToken),\n                        extraRewardAmount - extraRewardFee\n                    );\n                }\n                if (extraRewardFee > 0) extraRewardToken.safeTransfer(TRSRY(), extraRewardFee);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system"
    }
  ]
}