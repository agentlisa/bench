{
  "Title": "[H-04] Delegation rewards are not counted toward granting fund",
  "Content": "\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L236-L265><br>\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L216-L217>\n\nEach period reserves a reward for granting up to [3% (GBC: Global Budget Constraint)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L27). The GBC is split into two parts:\n\n1.  90% for proposal granting. Any proposal requesting more than 90% will [revert](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L390-L391). The total amount requested across winning proposals must not [exceed this percentage](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L447-L450).\n2.  10% for voters who have participated in that distribution period as an incentive.\n\nVoters who have participated can claim their reward after the period has ended via `claimDelegateReward()`. However, the claim function does not account for the claimed reward towards treasury granting. As a result, the treasury technically reserves up to 90% in each period while actually granting 100%.\n\nConsider this example:\n\n1.  The treasury has a total of `1000 AJNA`. 3% is reserved for this period, resulting in a GBC of `30 AJNA`. The treasury is updated to `1000 - 30 = 970 AJNA`.\n2.  90% is for proposals (`27 AJNA`) and 10% is for voters (`3 AJNA`).\n3.  Assume all `27 AJNA` are fully granted among winning proposals.\n4.  Assume 10 voters in total, all fully voted and have equal voting power. Each voter receives `0.3 AJNA`, totaling `3 AJNA`.\n5.  The treasury has spent `27 AJNA + 3 AJNA`, leaving an actual balance of `970 AJNA`.\n6.  This round has ended and the treasury updates its balance before starting a new one using [this logic](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L217). `970 += (30 - 27)` = `973`.\n7.  The treasury accounts for `973 AJNA` while having only `970 AJNA` in actuality.\n\n### More detailed analysis\n\nWhen the current period has ended and before starting a new one, the treasury will [re-account its amount in case the last period did not utilize all the reserved reward](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L217). For example, if the last period granted only 80% of the GBC among winning proposals, the remaining 10% will be re-added to the treasury.\n\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n\n197:    function _updateTreasury(\n198:        uint24 distributionId_\n199:    ) private {\n200:        bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;\n201:        uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;\n202:\n203:        uint256[] memory fundingProposalIds = _fundedProposalSlates[fundedSlateHash];\n204:\n205:        uint256 totalTokensRequested;\n206:        uint256 numFundedProposals = fundingProposalIds.length;\n207:\n208:        for (uint i = 0; i < numFundedProposals; ) {\n209:            Proposal memory proposal = _standardFundingProposals[fundingProposalIds[i]];\n210:\n211:            totalTokensRequested += proposal.tokensRequested;\n212:\n213:            unchecked { ++i; }\n214:        }\n215:\n216:        // readd non distributed tokens to the treasury\n217:        treasury += (fundsAvailable - totalTokensRequested);\n```\n\nIn the code block above, `fundsAvailable` represents 100% of the GBC and `totalTokensRequested` represents up to 90% of the GBC. As a result, the treasury always adds 10% of the reserve back to its accounting.\n\n### Proof of Concept\n\nThe following PoC code is quite long because it must go through all stages. Please append and run this function in the file `ajna-grants/test/unit/StandardFunding.t.sol`. The test should pass without errors.\n\n```solidity\nFile: ajna-grants/test/unit/StandardFunding.t.sol\n    /*\n        1. startDistributionPeriod\n        2. proposeStandard\n        3. screeningVote\n        4. fundingVote\n        5. updateSlate\n        6. executeStandard\n        7. claimDelegateReward\n    */\n        function testPoCTreasuryPrecisionLoss() public {\n        // 14 tokenholders self delegate their tokens to enable voting on the proposals\n        _selfDelegateVoters(_token, _votersArr);\n        uint allVotersInitBalance = 50_000_000 * 1e18;\n        emit log_named_uint(\"Treasury initial amount\", _grantFund.treasury());\n\n        vm.roll(_startBlock + 150);\n\n        /* =========================\n        1. startDistributionPeriod()\n        ========================= */\n        assertEq(_token.balanceOf(address(_grantFund)), 500_000_000 * 1e18, \"No token should have left the treasury\");\n        uint24 distributionId = _grantFund.startNewDistributionPeriod();\n        assertEq(_grantFund.getDistributionId(), distributionId, \"Should have the same ID\");\n        uint oldTreasury = _grantFund.treasury();\n        emit log_named_uint(\"Treasury after start, deduct 3%\", oldTreasury);\n\n        (, , , uint128 gbc, , ) = _grantFund.getDistributionPeriodInfo(distributionId);\n        assertEq(gbc, 15_000_000 * 1e18);\n        emit log_named_uint(\"GBC\", uint(gbc));\n        assertEq(oldTreasury + gbc, 500_000_000 * 1e18, \"Should be equal to the initial treasury fund\");\n\n        /* =================\n        2. proposeStandard()\n        ================= */\n        // Request 9/10 of GBC (maximal)\n        // 9/10 of GBC = 13_500_000 == 8_500_000 + 5_000_000 (all in WAD uint)\n        TestProposalParams[] memory testProposalParams = new TestProposalParams[](2);\n        testProposalParams[0] = TestProposalParams(address(this), 8_500_000 * 1e18);\n        testProposalParams[1] = TestProposalParams(address(this), 5_000_000 * 1e18);\n        TestProposal[] memory testProposals = _createNProposals(_grantFund, _token, testProposalParams);\n        assertEq(testProposals.length, 2, \"Should created exact 2 proposals\");\n        vm.roll(_startBlock + 200);\n\n        /* ===============\n        3. screeningVote()\n        =============== */\n        // Demonstrate only 6 voters, all fully use their vote power (50_000_000 * 1e18)\n        // #0 got 2 votes\n        // #1 got 4 votes\n        _screeningVote(_grantFund, _tokenHolder1, testProposals[0].proposalId, _getScreeningVotes(_grantFund, _tokenHolder1));\n        _screeningVote(_grantFund, _tokenHolder2, testProposals[0].proposalId, _getScreeningVotes(_grantFund, _tokenHolder2));\n        _screeningVote(_grantFund, _tokenHolder3, testProposals[1].proposalId, _getScreeningVotes(_grantFund, _tokenHolder3));\n        _screeningVote(_grantFund, _tokenHolder4, testProposals[1].proposalId, _getScreeningVotes(_grantFund, _tokenHolder4));\n        _screeningVote(_grantFund, _tokenHolder5, testProposals[1].proposalId, _getScreeningVotes(_grantFund, _tokenHolder5));\n        _screeningVote(_grantFund, _tokenHolder6, testProposals[1].proposalId, _getScreeningVotes(_grantFund, _tokenHolder6));\n\n        // /* =============\n        // 4. fundingVote()\n        // ============= */\n        // skip time to move from screening period to funding period\n        vm.roll(_startBlock + 600_000);\n\n        GrantFund.Proposal[] memory proposals = _getProposalListFromProposalIds(_grantFund, _grantFund.getTopTenProposals(distributionId));\n        assertEq(proposals.length, 2);\n\n        // Proposals should be sorted descending according to votes received so #1 should be the first and #0 should be the second\n        assertEq(proposals[0].proposalId, testProposals[1].proposalId, \"Should have the correct proposalId #1\");\n        assertEq(proposals[0].votesReceived, 200_000_000 * 1e18, \"Should have the voting score of 4 voters\");\n        assertEq(proposals[1].proposalId, testProposals[0].proposalId, \"Should have the correct proposalId #0\");\n        assertEq(proposals[1].votesReceived, 100_000_000 * 1e18, \"Should have the voting score of 2 voters\");\n\n        // funding period votes for two competing slates, 1, or 2 and 3\n        // #1 got 3 funding votes\n        // #0 got 3 funding votes\n        _fundingVote(_grantFund, _tokenHolder1, proposals[0].proposalId, voteYes, 50_000_000 * 1e18);\n        _fundingVote(_grantFund, _tokenHolder2, proposals[1].proposalId, voteYes, 50_000_000 * 1e18);\n        _fundingVote(_grantFund, _tokenHolder3, proposals[1].proposalId, voteYes, 50_000_000 * 1e18);\n        _fundingVote(_grantFund, _tokenHolder4, proposals[1].proposalId, voteYes, 50_000_000 * 1e18);\n        _fundingVote(_grantFund, _tokenHolder5, proposals[0].proposalId, voteYes, 50_000_000 * 1e18);\n        _fundingVote(_grantFund, _tokenHolder6, proposals[0].proposalId, voteYes, 50_000_000 * 1e18);\n\n        // Ensure that all 6 holders have fully voted.\n        for (uint i = 0; i < 6; i++) {\n            (uint128 voterPower, uint128 votingPowerRemaining, uint256 votesCast) = _grantFund.getVoterInfo(distributionId, _votersArr[i]);\n            assertEq(voterPower, 2_500_000_000_000_000 * 1e18, \"Should have 50m^2 voting power\");\n            assertEq(votingPowerRemaining, 0, \"Should have fully voted\");\n        }\n\n        // /* =============\n        // 5. updateSlate()\n        // ============= */\n        // skip to the end of the DistributionPeriod\n        vm.roll(_startBlock + 650_000);\n\n        // Updating potential Proposal Slate to include proposal that is in topTenProposal (funding Stage)\n        uint256[] memory slate = new uint256[](proposals.length); // length = 2\n        slate[0] = proposals[0].proposalId;\n        slate[1] = proposals[1].proposalId;\n        require(_grantFund.updateSlate(slate, distributionId), \"Should update slate success\");\n        (, , , , , bytes32 slateHash) = _grantFund.getDistributionPeriodInfo(distributionId);\n        assertTrue(slateHash != bytes32(0));\n        proposals = _getProposalListFromProposalIds(_grantFund, _grantFund.getFundedProposalSlate(slateHash));\n\n        // /* =================\n        // 6. executeStandard()\n        // ================= */\n        // skip to the end of the Distribution's challenge period\n        vm.roll(_startBlock + 700_000);\n\n        // execute funded proposals\n        assertEq(_token.balanceOf(address(this)), 0, \"This contract should have 0 token amount\");\n        _grantFund.executeStandard(testProposals[0].targets, testProposals[0].values, testProposals[0].calldatas, keccak256(bytes(testProposals[0].description)));\n        _grantFund.executeStandard(testProposals[1].targets, testProposals[1].values, testProposals[1].calldatas, keccak256(bytes(testProposals[1].description)));\n        \n        assertEq(testProposals[0].tokensRequested + testProposals[1].tokensRequested, _token.balanceOf(address(this)), \"The contract should received correct granted amount\");\n        emit log_named_uint(\"totalTokensRequested\", _token.balanceOf(address(this)));\n        assertEq(_token.balanceOf(address(this)), gbc * 9/10, \"Should be equal to 90% of GBC\");\n        \n        proposals = _getProposalListFromProposalIds(_grantFund, _grantFund.getFundedProposalSlate(slateHash));\n        assertTrue(proposals[0].executed && proposals[1].executed, \"Should have successfully executed\");\n\n        // /* =================\n        // 7. claimDelegateReward()\n        // ================= */\n        // Claim delegate reward for all delegatees\n        // delegates who didn't vote with their full power receive fewer rewards\n        uint totalDelegationRewards;\n        for (uint i = 0; i < _votersArr.length; i++) {\n            uint estimatedRewards = _grantFund.getDelegateReward(distributionId, _votersArr[i]);\n            changePrank(_votersArr[i]);\n            if (i > 5) {\n                // these are holders who haven't participated in this period, should have 0 reward\n                // _tokenHolder7 and above\n                vm.expectRevert(IStandardFunding.DelegateRewardInvalid.selector);\n                uint actualRewards = _grantFund.claimDelegateReward(distributionId);\n                assertTrue(estimatedRewards == 0 && actualRewards == 0, \"Should be ineligible for rewards\");\n                assertFalse(_grantFund.hasClaimedReward(distributionId, _votersArr[i]), \"Should unable to claim\");\n                assertEq(_token.balanceOf(_votersArr[i]), allVotersInitBalance, \"Balance should be the same as starting\");\n            }\n            else {\n                // these are holders who have voted\n                // _tokenHolder1 - 6\n                uint actualRewards = _grantFund.claimDelegateReward(distributionId);\n                assertEq(estimatedRewards, actualRewards, \"Should received the exact reward amount\");\n                assertTrue(estimatedRewards != 0 && actualRewards != 0, \"Should be eligible for rewards\");\n                assertTrue(_grantFund.hasClaimedReward(distributionId, _votersArr[i]), \"Should claim successfully\");\n\n                assertEq(_token.balanceOf(_votersArr[i]), allVotersInitBalance + actualRewards, \"Should have the final balance equal to init+reward\");\n                totalDelegationRewards += actualRewards;\n            }\n        }\n\n        emit log_named_uint(\"Total claimed rewards\", totalDelegationRewards);\n        assertEq(totalDelegationRewards, gbc / 10, \"Should be equal to 10% of GBC\");\n        assertEq(totalDelegationRewards + _token.balanceOf(address(this)), gbc, \"10% + 90% = 100%\");\n        assertEq(totalDelegationRewards + _token.balanceOf(address(this)) + oldTreasury, 500_000_000 * 1e18, \"10% + 90% + remaining = initial treasury\");\n        emit log_named_uint(\"Treasury at the end of the period (should be the same as started)\", _grantFund.treasury());\n\n        // Put the treasury back to the same value as the last period to have the same GBC for easier to compare.\n        // Remember this equation? \"10% + 90% + remaining = initial treasury\"\n        // Current _grantFund.treasury() = remaining.\n        // _token.balanceOf(address(this)) = 90%\n        // _grantFund.startNewDistributionPeriod() -> _grantFund._updateTreasury() = 10% (because of the invalid logic)\n        changePrank(address(this));\n        _token.approve(address(_grantFund), _token.balanceOf(address(this)));\n\n        // only put 90% back to the treasury\n        _grantFund.fundTreasury(_token.balanceOf(address(this)));\n\n        // 10% + (90%&remaining) = initial treasury\n        assertEq(totalDelegationRewards + _grantFund.treasury(), 500_000_000 * 1e18, \"Should be equal to the initial treasury\");\n\n        // The function put 10% back in, while in the actual all 100% has been spent. Loss 10%.\n        _grantFund.startNewDistributionPeriod();\n        emit log_named_uint(\"Treasury at the new period (got updated)\", _grantFund.treasury());\n        assertEq(_token.balanceOf(address(_grantFund)), 498_500_000 * 1e18, \"Should be initial-10%\");\n        emit log_named_uint(\"treasury actual balance\", _token.balanceOf(address(_grantFund)));\n\n        // The same GBC evidenced that treasury = 500_000_000 * 1e18 at the time it was calculated,\n        // But the actual balance is 500_000_000 * 1e18 - 10% = 498_500_000 * 1e18.\n        (, , , uint128 newGbc, , ) = _grantFund.getDistributionPeriodInfo(distributionId);\n        assertEq(oldTreasury + gbc, _grantFund.treasury() + gbc, \"Should have the same GBC as previous period\");\n        assertEq(gbc, newGbc, \"Should have the same GBC as previous period\");\n    }\n```\n\n```shell\nrun: forge test --match-test testPoCTreasuryPrecisionLoss -vv\n\nRunning 1 test for test/unit/StandardFunding.t.sol:StandardFundingGrantFundTest\n[PASS] testPoCTreasuryPrecisionLoss() (gas: 3451937)\nLogs:\n  Treasury initial amount: 500000000000000000000000000\n  Treasury after start, deduct 3%: 485000000000000000000000000\n  GBC: 15000000000000000000000000\n  totalTokensRequested: 13500000000000000000000000\n  Total claimed rewards: 1500000000000000000000000\n  Treasury at the end of the period (should be the same as started): 485000000000000000000000000\n  Treasury at the new period (got updated): 485000000000000000000000000\n  treasury actual balance: 498500000000000000000000000\n\nTest result: ok. 1 passed; 0 failed; finished in 1.20s\n```\n\n### Tools Used\n\n*   Manual review\n*   Foundry\n\n### Recommended Mitigation Steps\n\nIf it is safe to assume that all periods will always have 10% for delegation rewards, the contract should calculate only 90% of `fundsAvailable` when updating the treasury.\n\n```diff\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n\n197:    function _updateTreasury(\n198:        uint24 distributionId_\n199:    ) private {\n200:        bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;\n201:        uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;\n\n            ...\n\n216:        // readd non distributed tokens to the treasury\n+217:        treasury += ((fundsAvailable * 9/10) - totalTokensRequested);      \n\n```\n\n### Remark\n\nThe `claimDelegateReward()` function uses `Maths.wmul()`, which automatically rounds the multiplication result up or down. For example, `Maths.wmul(1, 0.5 * 1e18) = 1` (rounding up) while `Maths.wmul(1, 0.49 * 1e18) = 0` (rounding down). As a result, `rewardClaimed_` can lose precision for small decimal amounts and token holders typically have small fractions of tokens down to `1 wei`. It is uncertain, but the total actual paid rewards could be more than 10% if rounded up, resulting in an insignificant loss of precision in the treasury. However, if `rewardClaimed_` is deducted from `fundsAvailable`, it could lead to an integer underflow revert if `fundsAvailable - totalClaimed - totalTokensRequested = 100% - 10.xx% - 90%`, which exceeds 100%.\n\n**[Picodes (judge) increased severity to High](https://github.com/code-423n4/2023-05-ajna-findings/issues/450#issuecomment-1568861837)**\n\n**[MikeHathaway (Ajna) confirmed via duplicate issue `#263`](https://github.com/code-423n4/2023-05-ajna-findings/issues/263#issuecomment-1555119925)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/base/StandardFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }    from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast }  from \"@oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@oz/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IStandardFunding } from \"../interfaces/IStandardFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract StandardFunding is Funding, IStandardFunding {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens that can be distributed by the treasury in a quarter.\n     * @dev Stored as a Wad percentage.\n     */\n    uint256 internal constant GLOBAL_BUDGET_CONSTRAINT = 0.03 * 1e18;\n\n    /**\n     * @notice Length of the challengephase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 7 days.\n     * @dev    The period in which funded proposal slates can be checked in updateSlate.\n     */\n    uint256 internal constant CHALLENGE_PERIOD_LENGTH = 50400;\n\n    /**\n     * @notice Length of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 90 days.\n     */\n    uint48 internal constant DISTRIBUTION_PERIOD_LENGTH = 648000;\n\n    /**\n     * @notice Length of the funding phase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 10 days.\n     */\n    uint256 internal constant FUNDING_PERIOD_LENGTH = 72000;\n\n    /**\n     * @notice Keccak hash of a prefix string for standard funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_STANDARD = keccak256(bytes(\"Standard Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice ID of the current distribution period.\n     * @dev Used to access information on the status of an ongoing distribution.\n     * @dev Updated at the start of each quarter.\n     * @dev Monotonically increases by one per period.\n     */\n    uint24 internal _currentDistributionId = 0;\n\n    /**\n     * @notice Mapping of quarterly distributions from the grant fund.\n     * @dev distributionId => QuarterlyDistribution\n     */\n    mapping(uint24 => QuarterlyDistribution) internal _distributions;\n\n    /**\n     * @dev Mapping of all proposals that have ever been submitted to the grant fund for screening.\n     * @dev proposalId => Proposal\n     */\n    mapping(uint256 => Proposal) internal _standardFundingProposals;\n\n    /**\n     * @dev Mapping of distributionId to a sorted array of 10 proposalIds with the most votes in the screening period.\n     * @dev distribution.id => proposalId[]\n     * @dev A new array is created for each distribution period\n     */\n    mapping(uint256 => uint256[]) internal _topTenProposals;\n\n    /**\n     * @notice Mapping of a hash of a proposal slate to a list of funded proposals.\n     * @dev slate hash => proposalId[]\n     */\n    mapping(bytes32 => uint256[]) internal _fundedProposalSlates;\n\n    /**\n     * @notice Mapping of quarterly distributions to voters to a Quadratic Voter info struct.\n     * @dev distributionId => voter address => QuadraticVoter \n     */\n    mapping(uint256 => mapping(address => QuadraticVoter)) internal _quadraticVoters;\n\n    /**\n     * @notice Mapping of distributionId to whether surplus funds from distribution updated into treasury\n     * @dev distributionId => bool\n    */\n    mapping(uint256 => bool) internal _isSurplusFundsUpdated;\n\n    /**\n     * @notice Mapping of distributionId to user address to whether user has claimed his delegate reward\n     * @dev distributionId => address => bool\n    */\n    mapping(uint256 => mapping(address => bool)) public hasClaimedReward;\n\n    /**\n     * @notice Mapping of distributionId to user address to total votes cast on screening stage proposals.\n     * @dev distributionId => address => uint256\n    */\n    mapping(uint256 => mapping(address => uint256)) public screeningVotesCast;\n\n    /**************************************************/\n    /*** Distribution Management Functions External ***/\n    /**************************************************/\n\n    /// @inheritdoc IStandardFunding\n    function startNewDistributionPeriod() external override returns (uint24 newDistributionId_) {\n        uint24  currentDistributionId       = _currentDistributionId;\n        uint256 currentDistributionEndBlock = _distributions[currentDistributionId].endBlock;\n\n        // check that there isn't currently an active distribution period\n        if (block.number <= currentDistributionEndBlock) revert DistributionPeriodStillActive();\n\n        // update Treasury with unused funds from last two distributions\n        {\n            // Check if any last distribution exists and its challenge stage is over\n            if (currentDistributionId > 0 && (block.number > _getChallengeStageEndBlock(currentDistributionEndBlock))) {\n                // Add unused funds from last distribution to treasury\n                _updateTreasury(currentDistributionId);\n            }\n\n            // checks if any second last distribution exist and its unused funds are not added into treasury\n            if (currentDistributionId > 1 && !_isSurplusFundsUpdated[currentDistributionId - 1]) {\n                // Add unused funds from second last distribution to treasury\n                _updateTreasury(currentDistributionId - 1);\n            }\n        }\n\n        // set the distribution period to start at the current block\n        uint48 startBlock = SafeCast.toUint48(block.number);\n        uint48 endBlock = startBlock + DISTRIBUTION_PERIOD_LENGTH;\n\n        // set new value for currentDistributionId\n        newDistributionId_ = _setNewDistributionId();\n\n        // create QuarterlyDistribution struct\n        QuarterlyDistribution storage newDistributionPeriod = _distributions[newDistributionId_];\n        newDistributionPeriod.id              = newDistributionId_;\n        newDistributionPeriod.startBlock      = startBlock;\n        newDistributionPeriod.endBlock        = endBlock;\n        uint256 gbc                           = Maths.wmul(treasury, GLOBAL_BUDGET_CONSTRAINT);\n        newDistributionPeriod.fundsAvailable  = SafeCast.toUint128(gbc);\n\n        // decrease the treasury by the amount that is held for allocation in the new distribution period\n        treasury -= gbc;\n\n        emit QuarterlyDistributionStarted(\n            newDistributionId_,\n            startBlock,\n            endBlock\n        );\n    }\n\n    /**************************************************/\n    /*** Distribution Management Functions Internal ***/\n    /**************************************************/\n\n    /**\n     * @notice Get the block number at which this distribution period's challenge stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the challenge stage end block for.\n     * @return The block number at which this distribution period's challenge stage ends.\n    */\n    function _getChallengeStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ + CHALLENGE_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Get the block number at which this distribution period's screening stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the screening stage end block for.\n     * @return The block number at which this distribution period's screening stage ends.\n    */\n    function _getScreeningStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ - FUNDING_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Updates Treasury with surplus funds from distribution.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length of at most 10.\n     * @param distributionId_ distribution Id of updating distribution \n     */\n    function _updateTreasury(\n        uint24 distributionId_\n    ) private {\n        bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;\n        uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;\n\n        uint256[] memory fundingProposalIds = _fundedProposalSlates[fundedSlateHash];\n\n        uint256 totalTokensRequested;\n        uint256 numFundedProposals = fundingProposalIds.length;\n\n        for (uint i = 0; i < numFundedProposals; ) {\n            Proposal memory proposal = _standardFundingProposals[fundingProposalIds[i]];\n\n            totalTokensRequested += proposal.tokensRequested;\n\n            unchecked { ++i; }\n        }\n\n        // readd non distributed tokens to the treasury\n        treasury += (fundsAvailable - totalTokensRequested);\n\n        _isSurplusFundsUpdated[distributionId_] = true;\n    }\n\n    /**\n     * @notice Set a new DistributionPeriod Id.\n     * @dev    Increments the previous Id nonce by 1.\n     * @return newId_ The new distribution period Id.\n     */\n    function _setNewDistributionId() private returns (uint24 newId_) {\n        newId_ = _currentDistributionId += 1;\n    }\n\n    /************************************/\n    /*** Delegation Rewards Functions ***/\n    /************************************/\n\n    /// @inheritdoc IStandardFunding\n    function claimDelegateReward(\n        uint24 distributionId_\n    ) external override returns(uint256 rewardClaimed_) {\n        // Revert if delegatee didn't vote in screening stage\n        if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n\n        // Check if Challenge Period is still active\n        if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();\n\n        // check rewards haven't already been claimed\n        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n\n        QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n\n        // calculate rewards earned for voting\n        rewardClaimed_ = _getDelegateReward(currentDistribution, voter);\n\n        hasClaimedReward[distributionId_][msg.sender] = true;\n\n        emit DelegateRewardClaimed(\n            msg.sender,\n            distributionId_,\n            rewardClaimed_\n        );\n\n        // transfer rewards to delegatee\n        IERC20(ajnaTokenAddress).safeTransfer(msg.sender, rewardClaimed_);\n    }\n\n    /**\n     * @notice Calculate the delegate rewards that have accrued to a given voter, in a given distribution period.\n     * @dev    Voter must have voted in both the screening and funding stages, and is proportional to their share of votes across the stages.\n     * @param  currentDistribution_ Struct of the distribution period to calculat rewards for.\n     * @param  voter_               Struct of the funding stages voter.\n     * @return rewards_             The delegate rewards accrued to the voter.\n     */\n    function _getDelegateReward(\n        QuarterlyDistribution memory currentDistribution_,\n        QuadraticVoter memory voter_\n    ) internal pure returns (uint256 rewards_) {\n        // calculate the total voting power available to the voter that was allocated in the funding stage\n        uint256 votingPowerAllocatedByDelegatee = voter_.votingPower - voter_.remainingVotingPower;\n\n        // if none of the voter's voting power was allocated, they receive no rewards\n        if (votingPowerAllocatedByDelegatee == 0) return 0;\n\n        // calculate reward\n        // delegateeReward = 10 % of GBC distributed as per delegatee Voting power allocated\n        rewards_ = Maths.wdiv(\n            Maths.wmul(\n                currentDistribution_.fundsAvailable,\n                votingPowerAllocatedByDelegatee\n            ),\n            currentDistribution_.fundingVotePowerCast\n        ) / 10;\n    }\n\n    /***********************************/\n    /*** Proposal Functions External ***/\n    /***********************************/\n\n    /// @inheritdoc IStandardFunding\n    function updateSlate(\n        uint256[] calldata proposalIds_,\n        uint24 distributionId_\n    ) external override returns (bool newTopSlate_) {\n        QuarterlyDistribution storage currentDistribution = _distributions[distributionId_];\n\n        // store number of proposals for reduced gas cost of iterations\n        uint256 numProposalsInSlate = proposalIds_.length;\n\n        // check the each proposal in the slate is valid, and get the sum of the proposals fundingVotesReceived\n        uint256 sum = _validateSlate(distributionId_, currentDistribution.endBlock, currentDistribution.fundsAvailable, proposalIds_, numProposalsInSlate);\n\n        // get pointers for comparing proposal slates\n        bytes32 currentSlateHash = currentDistribution.fundedSlateHash;\n        bytes32 newSlateHash     = keccak256(abi.encode(proposalIds_));\n\n        // check if slate of proposals is better than the existing slate, and is thus the new top slate\n        newTopSlate_ = currentSlateHash == 0 ||\n            (currentSlateHash!= 0 && sum > _sumProposalFundingVotes(_fundedProposalSlates[currentSlateHash]));\n\n        // if slate of proposals is new top slate, update state\n        if (newTopSlate_) {\n            uint256[] storage existingSlate = _fundedProposalSlates[newSlateHash];\n\n            for (uint i = 0; i < numProposalsInSlate; ) {\n\n                // update list of proposals to fund\n                existingSlate.push(proposalIds_[i]);\n\n                unchecked { ++i; }\n            }\n\n            // update hash to point to the new leading slate of proposals\n            currentDistribution.fundedSlateHash = newSlateHash;\n\n            emit FundedSlateUpdated(\n                distributionId_,\n                newSlateHash\n            );\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function executeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, descriptionHash_)));\n        Proposal storage proposal = _standardFundingProposals[proposalId_];\n\n        uint24 distributionId = proposal.distributionId;\n\n        // check that the distribution period has ended, and one week has passed to enable competing slates to be checked\n        if (block.number <= _getChallengeStageEndBlock(_distributions[distributionId].endBlock)) revert ExecuteProposalInvalid();\n\n        // check proposal is succesful and hasn't already been executed\n        if (!_standardFundingVoteSucceeded(proposalId_) || proposal.executed) revert ProposalNotSuccessful();\n\n        proposal.executed = true;\n\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IStandardFunding\n    function proposeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_\n    ) external override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, keccak256(bytes(description_)))));\n\n        Proposal storage newProposal = _standardFundingProposals[proposalId_];\n\n        // check for duplicate proposals\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n        // cannot add new proposal after end of screening period\n        // screening period ends 72000 blocks before end of distribution period, ~ 80 days.\n        if (block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert ScreeningPeriodEnded();\n\n        // store new proposal information\n        newProposal.proposalId      = proposalId_;\n        newProposal.distributionId  = currentDistribution.id;\n        newProposal.tokensRequested = _validateCallDatas(targets_, values_, calldatas_); // check proposal parameters are valid and update tokensRequested\n\n        // revert if proposal requested more tokens than are available in the distribution period\n        if (newProposal.tokensRequested > (currentDistribution.fundsAvailable * 9 / 10)) revert InvalidProposal();\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            currentDistribution.endBlock,\n            description_\n        );\n    }\n\n    /***********************************/\n    /*** Proposal Functions Internal ***/\n    /***********************************/\n\n    /**\n     * @notice Check the validity of a potential slate of proposals to execute, and sum the slate's fundingVotesReceived.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through both voting stages.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  distributionId_                   Id of the distribution period to check the slate for.\n     * @param  endBlock                          End block of the distribution period.\n     * @param  distributionPeriodFundsAvailable_ Funds available for distribution in the distribution period.\n     * @param  proposalIds_                      Array of proposal Ids to check.\n     * @param  numProposalsInSlate_              Number of proposals in the slate.\n     * @return sum_                              The total funding votes received by all proposals in the proposed slate.\n     */\n    function _validateSlate(uint24 distributionId_, uint256 endBlock, uint256 distributionPeriodFundsAvailable_, uint256[] calldata proposalIds_, uint256 numProposalsInSlate_) internal view returns (uint256 sum_) {\n        // check that the function is being called within the challenge period\n        if (block.number <= endBlock || block.number > _getChallengeStageEndBlock(endBlock)) {\n            revert InvalidProposalSlate();\n        }\n\n        // check that the slate has no duplicates\n        if (_hasDuplicates(proposalIds_)) revert InvalidProposalSlate();\n\n        uint256 gbc = distributionPeriodFundsAvailable_;\n        uint256 totalTokensRequested = 0;\n\n        // check each proposal in the slate is valid\n        for (uint i = 0; i < numProposalsInSlate_; ) {\n            Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];\n\n            // check if Proposal is in the topTenProposals list\n            if (_findProposalIndex(proposalIds_[i], _topTenProposals[distributionId_]) == -1) revert InvalidProposalSlate();\n\n            // account for fundingVotesReceived possibly being negative\n            if (proposal.fundingVotesReceived < 0) revert InvalidProposalSlate();\n\n            // update counters\n            sum_ += uint128(proposal.fundingVotesReceived); // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n            totalTokensRequested += proposal.tokensRequested;\n\n            // check if slate of proposals exceeded budget constraint ( 90% of GBC )\n            if (totalTokensRequested > (gbc * 9 / 10)) {\n                revert InvalidProposalSlate();\n            }\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Check an array of proposalIds for duplicate IDs.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  proposalIds_ Array of proposal Ids to check.\n     * @return Boolean indicating the presence of a duplicate. True if it has a duplicate; false if not.\n     */\n    function _hasDuplicates(\n        uint256[] calldata proposalIds_\n    ) internal pure returns (bool) {\n        uint256 numProposals = proposalIds_.length;\n\n        for (uint i = 0; i < numProposals; ) {\n            for (uint j = i + 1; j < numProposals; ) {\n                if (proposalIds_[i] == proposalIds_[j]) return true;\n\n                unchecked { ++j; }\n            }\n\n            unchecked { ++i; }\n\n        }\n        return false;\n    }\n\n    /**\n     * @notice Calculates the sum of funding votes allocated to a list of proposals.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length of at most 10.\n     * @param  proposalIdSubset_ Array of proposal Ids to sum.\n     * @return sum_ The sum of the funding votes across the given proposals.\n     */\n    function _sumProposalFundingVotes(\n        uint256[] memory proposalIdSubset_\n    ) internal view returns (uint128 sum_) {\n        for (uint i = 0; i < proposalIdSubset_.length;) {\n            // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n            sum_ += uint128(_standardFundingProposals[proposalIdSubset_[i]].fundingVotesReceived);\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _standardProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        Proposal memory proposal = _standardFundingProposals[proposalId_];\n\n        if (proposal.executed)                                                     return ProposalState.Executed;\n        else if (_distributions[proposal.distributionId].endBlock >= block.number) return ProposalState.Active;\n        else if (_standardFundingVoteSucceeded(proposalId_))                      return ProposalState.Succeeded;\n        else                                                                       return ProposalState.Defeated;\n    }\n\n    /*********************************/\n    /*** Voting Functions External ***/\n    /*********************************/\n\n    /// @inheritdoc IStandardFunding\n    function fundingVote(\n        FundingVoteParams[] memory voteParams_\n    ) external override returns (uint256 votesCast_) {\n        uint24 currentDistributionId = _currentDistributionId;\n\n        QuarterlyDistribution storage currentDistribution = _distributions[currentDistributionId];\n        QuadraticVoter        storage voter               = _quadraticVoters[currentDistributionId][msg.sender];\n\n        uint256 endBlock = currentDistribution.endBlock;\n\n        uint256 screeningStageEndBlock = _getScreeningStageEndBlock(endBlock);\n\n        // check that the funding stage is active\n        if (block.number <= screeningStageEndBlock || block.number > endBlock) revert InvalidVote();\n\n        uint128 votingPower = voter.votingPower;\n\n        // if this is the first time a voter has attempted to vote this period,\n        // set initial voting power and remaining voting power\n        if (votingPower == 0) {\n\n            // calculate the voting power available to the voting power in this funding stage\n            uint128 newVotingPower = SafeCast.toUint128(_getVotesFunding(msg.sender, votingPower, voter.remainingVotingPower, screeningStageEndBlock));\n\n            voter.votingPower          = newVotingPower;\n            voter.remainingVotingPower = newVotingPower;\n        }\n\n        uint256 numVotesCast = voteParams_.length;\n\n        for (uint256 i = 0; i < numVotesCast; ) {\n            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n            // check that the proposal is part of the current distribution period\n            if (proposal.distributionId != currentDistributionId) revert InvalidVote();\n\n            // check that the proposal being voted on is in the top ten screened proposals\n            if (_findProposalIndex(voteParams_[i].proposalId, _topTenProposals[currentDistributionId]) == -1) revert InvalidVote();\n\n            // cast each successive vote\n            votesCast_ += _fundingVote(\n                currentDistribution,\n                proposal,\n                msg.sender,\n                voter,\n                voteParams_[i]\n            );\n\n            unchecked { ++i; }\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function screeningVote(\n        ScreeningVoteParams[] memory voteParams_\n    ) external override returns (uint256 votesCast_) {\n        QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n        // check screening stage is active\n        if (block.number < currentDistribution.startBlock || block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert InvalidVote();\n\n        uint256 numVotesCast = voteParams_.length;\n\n        for (uint256 i = 0; i < numVotesCast; ) {\n            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n            // check that the proposal is part of the current distribution period\n            if (proposal.distributionId != currentDistribution.id) revert InvalidVote();\n\n            uint256 votes = voteParams_[i].votes;\n\n            // cast each successive vote\n            votesCast_ += votes;\n            _screeningVote(msg.sender, proposal, votes);\n\n            unchecked { ++i; }\n        }\n    }\n\n    /*********************************/\n    /*** Voting Functions Internal ***/\n    /*********************************/\n\n    /**\n     * @notice Vote on a proposal in the funding stage of the Distribution Period.\n     * @dev    Votes can be allocated to multiple proposals, quadratically, for or against.\n     * @param  currentDistribution_  The current distribution period.\n     * @param  proposal_             The current proposal being voted upon.\n     * @param  account_              The voting account.\n     * @param  voter_                The voter data struct tracking available votes.\n     * @param  voteParams_           The amount of votes being allocated to the proposal. Not squared. If less than 0, vote is against.\n     * @return incrementalVotesUsed_ The amount of funding stage votes allocated to the proposal.\n     */\n    function _fundingVote(\n        QuarterlyDistribution storage currentDistribution_,\n        Proposal storage proposal_,\n        address account_,\n        QuadraticVoter storage voter_,\n        FundingVoteParams memory voteParams_\n    ) internal returns (uint256 incrementalVotesUsed_) {\n        uint8  support = 1;\n        uint256 proposalId = proposal_.proposalId;\n\n        // determine if voter is voting for or against the proposal\n        voteParams_.votesUsed < 0 ? support = 0 : support = 1;\n\n        uint128 votingPower = voter_.votingPower;\n\n        // the total amount of voting power used by the voter before this vote executes\n        uint128 voterPowerUsedPreVote = votingPower - voter_.remainingVotingPower;\n\n        FundingVoteParams[] storage votesCast = voter_.votesCast;\n\n        // check that the voter hasn't already voted on a proposal by seeing if it's already in the votesCast array \n        int256 voteCastIndex = _findProposalIndexOfVotesCast(proposalId, votesCast);\n\n        // voter had already cast a funding vote on this proposal\n        if (voteCastIndex != -1) {\n            // since we are converting from int256 to uint256, we can safely assume that the value will not overflow\n            FundingVoteParams storage existingVote = votesCast[uint256(voteCastIndex)];\n\n            // can't change the direction of a previous vote\n            if (support == 0 && existingVote.votesUsed > 0 || support == 1 && existingVote.votesUsed < 0) {\n                // if the vote is in the opposite direction of a previous vote,\n                // and the proposal is already in the votesCast array, revert can't change direction\n                revert FundingVoteWrongDirection();\n            }\n            else {\n                // update the votes cast for the proposal\n                existingVote.votesUsed += voteParams_.votesUsed;\n            }\n        }\n        // first time voting on this proposal, add the newly cast vote to the voter's votesCast array\n        else {\n            votesCast.push(voteParams_);\n        }\n\n        // calculate the cumulative cost of all votes made by the voter\n        // and check that attempted votes cast doesn't overflow uint128\n        uint256 sumOfTheSquareOfVotesCast = _sumSquareOfVotesCast(votesCast);\n        if (sumOfTheSquareOfVotesCast > type(uint128).max) revert InsufficientVotingPower();\n        uint128 cumulativeVotePowerUsed = SafeCast.toUint128(sumOfTheSquareOfVotesCast);\n\n        // check that the voter has enough voting power remaining to cast the vote\n        if (cumulativeVotePowerUsed > votingPower) revert InsufficientVotingPower();\n\n        // update voter voting power accumulator\n        voter_.remainingVotingPower = votingPower - cumulativeVotePowerUsed;\n\n        // calculate the change in voting power used by the voter in this vote in order to accurately track the total voting power used in the funding stage\n        // since we are moving from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 incrementalVotingPowerUsed = uint256(cumulativeVotePowerUsed - voterPowerUsedPreVote);\n\n        // update accumulator for total voting power used in the funding stage in order to calculate delegate rewards\n        currentDistribution_.fundingVotePowerCast += incrementalVotingPowerUsed;\n\n        // update proposal vote tracking\n        proposal_.fundingVotesReceived += SafeCast.toInt128(voteParams_.votesUsed);\n\n        // the incremental additional votes cast on the proposal to be used as a return value and emit value\n        incrementalVotesUsed_ = SafeCast.toUint256(Maths.abs(voteParams_.votesUsed));\n\n        // emit VoteCast instead of VoteCastWithParams to maintain compatibility with Tally\n        // emits the amount of incremental votes cast for the proposal, not the voting power cost or total votes on a proposal\n        emit VoteCast(\n            account_,\n            proposalId,\n            support,\n            incrementalVotesUsed_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Vote on a proposal in the screening stage of the Distribution Period.\n     * @param account_  The voting account.\n     * @param proposal_ The current proposal being voted upon.\n     * @param votes_    The amount of votes being cast.\n     */\n    function _screeningVote(\n        address account_,\n        Proposal storage proposal_,\n        uint256 votes_\n    ) internal {\n        uint24 distributionId = proposal_.distributionId;\n\n        // check that the voter has enough voting power to cast the vote\n        if (screeningVotesCast[distributionId][account_] + votes_ > _getVotesScreening(distributionId, account_)) revert InsufficientVotingPower();\n\n        uint256[] storage currentTopTenProposals = _topTenProposals[distributionId];\n        uint256 proposalId = proposal_.proposalId;\n\n        // update proposal votes counter\n        proposal_.votesReceived += SafeCast.toUint128(votes_);\n\n        // check if proposal was already screened\n        int indexInArray = _findProposalIndex(proposalId, currentTopTenProposals);\n        uint256 screenedProposalsLength = currentTopTenProposals.length;\n\n        // check if the proposal should be added to the top ten list for the first time\n        if (screenedProposalsLength < 10 && indexInArray == -1) {\n            currentTopTenProposals.push(proposalId);\n\n            // sort top ten proposals\n            _insertionSortProposalsByVotes(currentTopTenProposals, screenedProposalsLength);\n        }\n        else {\n            // proposal is already in the array\n            if (indexInArray != -1) {\n                // re-sort top ten proposals to account for new vote totals\n                _insertionSortProposalsByVotes(currentTopTenProposals, uint256(indexInArray));\n            }\n            // proposal isn't already in the array\n            else if(_standardFundingProposals[currentTopTenProposals[screenedProposalsLength - 1]].votesReceived < proposal_.votesReceived) {\n                // replace the least supported proposal with the new proposal\n                currentTopTenProposals.pop();\n                currentTopTenProposals.push(proposalId);\n\n                // sort top ten proposals"
    }
  ]
}