{
  "Title": "M-5: Inaccurate collateral factor calculation due to missing collateral asset",
  "Content": "# Issue M-5: Inaccurate collateral factor calculation due to missing collateral asset \n\nSource: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/341 \n\n## Found by \n0xeix, Angry\\_Mustache\\_Man, Bauer, BugHunter101, Dug, PokemonAuditSimulator, TheNaubit, immeas, juancito, mahdikarimi, ravikiran.web3, sakshamguruji, shaka, theOwl\n## Summary\nThe function `collateralFactor()` in the smart contract calculates the collateral factor for the protocol but fails to account for the removal of certain collateral assets. As a result, the total value of the removed collateral assets is not included in the calculation, leading to an inaccurate collateral factor.\n\n## Vulnerability Detail\nThe `collateralFactor()` function calculates the current collateral factor for the protocol. It iterates through each collateral asset in the system and calculates the total value of all collateral assets in USD.\n\nFor each collateral asset, the function retrieves its balance and converts it to a USD value by multiplying it with the asset's price in USD obtained from the corresponding oracle. The balance is adjusted for the decimal precision of the asset. These USD values are accumulated to calculate the totalAssetsUSD.\n```solidity\n   function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n```\nHowever, when a collateral asset is removed from the collateral list, the `collateralFactor` function fails to account for its absence. This results in an inaccurate calculation of the collateral factor. Specifically, the totalAssetsUSD variable does not include the value of the removed collateral asset, leading to an underestimation of the total collateral value. The function `SellUSSDBuyCollateral()` in the smart contract is used for rebalancing. However, it relies on the collateralFactor calculation, which has been found to be inaccurate. The collateralFactor calculation does not accurately assess the portions of collateral assets to be bought or sold during rebalancing. This discrepancy can lead to incorrect rebalancing decisions and potentially impact the stability and performance of the protocol.\n```solidity\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n```\n## Impact\nAs a consequence, the reported collateral factor may be lower than it should be, potentially affecting the risk assessment and stability of the protocol. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L179-L194\n\n## Tool used\n\nManual Review\n\n## Recommendation\nEnsure accurate calculations and maintain the integrity of the collateral factor metric in the protocol's risk management system.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/82",
  "Code": [
    {
      "filename": "ussd-contracts/contracts/USSD.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./interfaces/IStableOracle.sol\";\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\n\n/**\n    @notice USSD: Autonomous on-chain stablecoin\n */\ncontract USSD is\n    IUSSD,\n    ERC20Upgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n\n    IUSSDRebalancer public rebalancer;\n\n    // allowed to manage collateral, set tresholds and perform management tasks\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        // mint 10k USSD to create initial pool\n        _mint(msg.sender, 10_000 * 1e6);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    /**\n        @dev restrict calls only by STABLE_CONTROL_ROLE role\n     */\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n    event Mint(\n        address indexed from,\n        address indexed to,\n        address token,\n        uint256 amountToken,\n        uint256 amountStable\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                          COLLATERAL MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    CollateralInfo[] private collateral;\n\n    function collateralList()\n        public\n        view\n        override\n        returns (CollateralInfo[] memory)\n    {\n        return collateral;\n    }\n\n    function addCollateral(\n        address _address,\n        address _oracle,\n        bool _mint,\n        bool _redeem,\n        uint256[] calldata _ratios,\n        bytes memory _pathbuy,\n        bytes memory _pathsell,\n        uint256 index\n    ) public onlyControl {\n        CollateralInfo memory newCollateral = CollateralInfo({\n            token: _address,\n            mint: _mint,\n            redeem: _redeem,\n            oracle: IStableOracle(_oracle),\n            pathbuy: _pathbuy,\n            pathsell: _pathsell,\n            ratios: _ratios\n        });\n        if (index < collateral.length) {\n            collateral[index] = newCollateral; // for editing\n        } else {\n            collateral.push(newCollateral); // for adding new collateral\n        }\n    }\n\n    function swapCollateralIndexes(\n        uint256 _index1,\n        uint256 _index2\n    ) public onlyControl {\n        // cannot use (a, b) = (b, a) for storage variables\n        CollateralInfo memory tmp = collateral[_index1];\n        collateral[_index1] = collateral[_index2];\n        collateral[_index2] = tmp;\n    }\n\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n\n    function getCollateralIndex(\n        address _token\n    ) public view returns (uint256 index) {\n        for (index = 0; index < collateral.length; index++) {\n            if (collateral[index].token == _token) {\n                return index;\n            }\n        }\n    }\n\n    function hasCollateralMint(\n        address _token\n    ) public view returns (bool present) {\n        for (uint256 i = 0; i < collateral.length; i++) {\n            if (collateral[i].token == _token && collateral[i].mint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// Mint specific AMOUNT OF STABLE by giving token\n    function mintForToken(\n        address token,\n        uint256 tokenAmount,\n        address to\n    ) public returns (uint256 stableCoinAmount) {\n        require(hasCollateralMint(token), \"unsupported token\");\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        stableCoinAmount = calculateMint(token, tokenAmount);\n        _mint(to, stableCoinAmount);\n\n        emit Mint(msg.sender, to, token, tokenAmount, stableCoinAmount);\n    }\n\n    /// @dev Return how much STABLECOIN does user receive for AMOUNT of asset\n    function calculateMint(address _token, uint256 _amount) public view returns (uint256 stableCoinAmount) {\n        uint256 assetPrice = collateral[getCollateralIndex(_token)].oracle.getPriceUSD();\n        return (((assetPrice * _amount) / 1e18) * (10 ** decimals())) / (10 ** IERC20MetadataUpgradeable(_token).decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               REBALANCER\n    //////////////////////////////////////////////////////////////*/\n\n    function setRebalancer(address _rebalancer) public onlyControl {\n        rebalancer = IUSSDRebalancer(_rebalancer);\n    }\n\n    function mintRebalancer(uint256 amount) public override {\n        _mint(address(this), amount);\n    }\n\n    function burnRebalancer(uint256 amount) public override {\n        _burn(address(this), amount);\n    }\n\n    modifier onlyBalancer() {\n        require(msg.sender == address(rebalancer), \"bal\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               UNISWAP\n    //////////////////////////////////////////////////////////////*/\n\n    IV3SwapRouter public uniRouter; // uniswap router to handle operations\n\n    function setUniswapRouter(address _router) public onlyControl {\n        uniRouter = IV3SwapRouter(_router);\n    }\n\n    function UniV3SwapInput(\n        bytes memory _path,\n        uint256 _sellAmount\n    ) public override onlyBalancer {\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: _path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountIn: _sellAmount,\n                amountOutMinimum: 0\n            });\n        uniRouter.exactInput(params);\n    }\n\n    function approveToRouter(address _token) public {\n        IERC20Upgradeable(_token).approve(\n            address(uniRouter),\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n}"
    }
  ]
}