{
  "Title": "No way to revoke approval in the SDLPool might lead to unauthorized calling transfer of locks.",
  "Content": "# No way to revoke approval in the SDLPool might lead to unauthorized calling transfer of locks.\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/base/SDLPool.sol#L294\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/base/SDLPool.sol#L294</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/base/SDLPool.sol#L264\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/base/SDLPool.sol#L264</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/base/SDLPool.sol#L523\">https://github.com/Cyfrin/2023-12-stake-link/blob/549b2b8c4a5b841686fceb9c311dca9ac58225df/contracts/core/sdlPool/base/SDLPool.sol#L523</a>\n\n\n## Summary\nThere is no way to revoke the approval which given via the `approve`function\nThey may able execute transfers even after the owner revokes their permission using the `setApprovalForAll` function.\n\n## Vulnerability Details\nThe `setApprovalForAll` function allows the owner to approve anyone as the operator. \n```\n    function setApprovalForAll(address _operator, bool _approved) external {\n        address owner = msg.sender;\n        if (owner == _operator) revert ApprovalToCaller();\n\n        operatorApprovals[owner][_operator] = _approved;\n        emit ApprovalForAll(owner, _operator, _approved);\n    }\n```\nIn the same vein, the `approve` function allows the owner or operator to approve anyone to transfer the lock.\n```\n    function approve(address _to, uint256 _lockId) external {\n        address owner = ownerOf(_lockId);\n\n        if (_to == owner) revert ApprovalToCurrentOwner(); //@note\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert SenderNotAuthorized();\n\n        tokenApprovals[_lockId] = _to;\n        emit Approval(owner, _to, _lockId);\n    }\n\n```\nNote that in the function, lock cannot be approved to the owner (but can be approved to any of the operators), and can be called by the owner/operator (see the `isApprovedForAll` modifier).\n\nIf the operator approves himself to the lock, using the `approve` function, and later on, his operator status gets revoked, his lock approval status is not cleared, meaning he still has access to the lock.\n\n> As an extreme example\n> - User1 owns 5 locks.\n> - He calls the `setApprovalForAll` setting User2 as his operator.\n> - User2 calls the `approve` function on all 5 locks (It succeeds as there's no check preventing this unlike with the lock owner), getting herself both operator approval and token approvals.\n> - User1 revokes User2's operator status.\n> - User2 still has access to the locks and can transfer them.\n## Impact\nUncleared approval, gives access to transfer token.\n## Tools Used\nManual code review\n## Recommendations\nInclude a check to see if the `_to` in the `approve` function is an operator, revert if it is. \nOr clear an operator's token approvals after revoking his operator status.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/sdlPool/base/SDLPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport \"../../base/RewardsPoolController.sol\";\nimport \"../../interfaces/IBoostController.sol\";\nimport \"../../interfaces/IERC721Receiver.sol\";\n\n/**\n * @title SDL Pool\n * @notice Base SDL Pool contract to inherit from\n */\ncontract SDLPool is RewardsPoolController, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Lock {\n        uint256 amount;\n        uint256 boostAmount;\n        uint64 startTime;\n        uint64 duration;\n        uint64 expiry;\n    }\n\n    string public name;\n    string public symbol;\n\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\n    mapping(uint256 => address) internal tokenApprovals;\n\n    IERC20Upgradeable public sdlToken;\n    IBoostController public boostController;\n\n    uint256 public lastLockId;\n    mapping(uint256 => Lock) internal locks;\n    mapping(uint256 => address) internal lockOwners;\n    mapping(address => uint256) internal balances;\n\n    uint256 public totalEffectiveBalance;\n    mapping(address => uint256) internal effectiveBalances;\n\n    address public ccipController;\n\n    string public baseURI;\n\n    event InitiateUnlock(address indexed owner, uint256 indexed lockId, uint64 expiry);\n    event Withdraw(address indexed owner, uint256 indexed lockId, uint256 amount);\n    event CreateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event UpdateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event OutgoingRESDL(address indexed sender, uint256 indexed lockId);\n    event IncomingRESDL(address indexed receiver, uint256 indexed lockId);\n\n    error SenderNotAuthorized();\n    error InvalidLockId();\n    error InvalidLockingDuration();\n    error TransferFromIncorrectOwner();\n    error TransferToZeroAddress();\n    error TransferToNonERC721Implementer();\n    error TransferToCCIPController();\n    error ApprovalToCurrentOwner();\n    error ApprovalToCaller();\n    error InvalidValue();\n    error InvalidParams();\n    error UnauthorizedToken();\n    error TotalDurationNotElapsed();\n    error HalfDurationNotElapsed();\n    error InsufficientBalance();\n    error UnlockNotInitiated();\n    error DuplicateContract();\n    error ContractNotFound();\n    error UnlockAlreadyInitiated();\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function __SDLPoolBase_init(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public onlyInitializing {\n        __RewardsPoolController_init();\n        name = _name;\n        symbol = _symbol;\n        sdlToken = IERC20Upgradeable(_sdlToken);\n        boostController = IBoostController(_boostController);\n    }\n\n    /**\n     * @notice reverts if `_owner` is not the owner of `_lockId`\n     **/\n    modifier onlyLockOwner(uint256 _lockId, address _owner) {\n        _onlyLockOwner(_lockId, _owner);\n        _;\n    }\n\n    /**\n     * @notice reverts if sender is not the CCIP controller\n     **/\n    modifier onlyCCIPController() {\n        if (msg.sender != ccipController) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice returns the effective stake balance of an account\n     * @dev the effective stake balance includes the actual amount of tokens an\n     * account has staked across all locks plus any applicable boost gained by locking\n     * @param _account address of account\n     * @return effective stake balance\n     **/\n    function effectiveBalanceOf(address _account) external view returns (uint256) {\n        return effectiveBalances[_account];\n    }\n\n    /**\n     * @notice returns the number of locks owned by an account\n     * @param _account address of account\n     * @return total number of locks owned by account\n     **/\n    function balanceOf(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    /**\n     * @notice returns the owner of a lock\n     * @dev reverts if `_lockId` is invalid\n     * @param _lockId id of the lock\n     * @return lock owner\n     **/\n    function ownerOf(uint256 _lockId) public view returns (address) {\n        address owner = lockOwners[_lockId];\n        if (owner == address(0)) revert InvalidLockId();\n        return owner;\n    }\n\n    /**\n     * @notice returns the list of locks that corresponds to `_lockIds`\n     * @dev reverts if any lockId is invalid\n     * @param _lockIds list of lock ids\n     * @return list of locks\n     **/\n    function getLocks(uint256[] calldata _lockIds) external view returns (Lock[] memory) {\n        Lock[] memory retLocks = new Lock[](_lockIds.length);\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            uint256 lockId = _lockIds[i];\n            if (lockOwners[lockId] == address(0)) revert InvalidLockId();\n            retLocks[i] = locks[lockId];\n        }\n\n        return retLocks;\n    }\n\n    /**\n     * @notice returns a list of lockIds owned by an account\n     * @param _owner address of account\n     * @return list of lockIds\n     **/\n    function getLockIdsByOwner(address _owner) external view returns (uint256[] memory) {\n        uint256 maxLockId = lastLockId;\n        uint256 lockCount = balanceOf(_owner);\n        uint256 lockIdsFound;\n        uint256[] memory lockIds = new uint256[](lockCount);\n\n        for (uint256 i = 1; i <= maxLockId; ++i) {\n            if (lockOwners[i] == _owner) {\n                lockIds[lockIdsFound] = i;\n                lockIdsFound++;\n                if (lockIdsFound == lockCount) break;\n            }\n        }\n\n        assert(lockIdsFound == lockCount);\n\n        return lockIds;\n    }\n\n    /**\n     * @notice transfers a lock between accounts\n     * @dev reverts if sender is not the owner of and not approved to transfer the lock\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) external {\n        if (!_isApprovedOrOwner(msg.sender, _lockId)) revert SenderNotAuthorized();\n        _transfer(_from, _to, _lockId);\n    }\n\n    /**\n     * @notice transfers a lock between accounts and validates that the receiver supports ERC721\n     * @dev\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * - reverts if sender is not the owner of and not approved to transfer the lock\n     * - reverts if `_lockId` is invalid\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) external {\n        safeTransferFrom(_from, _to, _lockId, \"\");\n    }\n\n    /**\n     * @notice transfers a lock between accounts and validates that the receiver supports ERC721\n     * @dev\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * - reverts if sender is not the owner of and not approved to transfer the lock\n     * - reverts if `_lockId` is invalid\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     * @param _data optional data to pass to receiver\n     **/\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId,\n        bytes memory _data\n    ) public {\n        if (!_isApprovedOrOwner(msg.sender, _lockId)) revert SenderNotAuthorized();\n        _transfer(_from, _to, _lockId);\n        if (!_checkOnERC721Received(_from, _to, _lockId, _data)) revert TransferToNonERC721Implementer();\n    }\n\n    /**\n     * @notice approves `_to` to transfer `_lockId` to another address\n     * @dev\n     * - approval is revoked on transfer and can also be revoked by approving zero address\n     * - reverts if sender is not owner of lock and not an approved operator for the owner\n     * - reverts if `_to` is owner of lock\n     * - reverts if `_lockId` is invalid\n     * @param _to address approved to transfer\n     * @param _lockId id of lock\n     **/\n    function approve(address _to, uint256 _lockId) external {\n        address owner = ownerOf(_lockId);\n\n        if (_to == owner) revert ApprovalToCurrentOwner();\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert SenderNotAuthorized();\n\n        tokenApprovals[_lockId] = _to;\n        emit Approval(owner, _to, _lockId);\n    }\n\n    /**\n     * @notice returns the address approved to transfer a lock\n     * @param _lockId id of lock\n     * @return approved address\n     **/\n    function getApproved(uint256 _lockId) public view returns (address) {\n        if (lockOwners[_lockId] == address(0)) revert InvalidLockId();\n\n        return tokenApprovals[_lockId];\n    }\n\n    /**\n     * @notice approves _operator to transfer all tokens owned by sender\n     * @dev\n     * - approval will not be revoked until this function is called again with\n     *   `_approved` set to false\n     * - reverts if sender is `_operator`\n     * @param _operator address to approve/unapprove\n     * @param _approved whether address is approved or not\n     **/\n    function setApprovalForAll(address _operator, bool _approved) external {\n        address owner = msg.sender;\n        if (owner == _operator) revert ApprovalToCaller();\n\n        operatorApprovals[owner][_operator] = _approved;\n        emit ApprovalForAll(owner, _operator, _approved);\n    }\n\n    /**\n     * @notice returns whether `_operator` is approved to transfer all tokens owned by `_owner`\n     * @param _owner owner of tokens\n     * @param _operator address approved to transfer\n     * @return whether address is approved or not\n     **/\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /**\n     * @notice returns an account's staked amount for use by reward pools\n     * controlled by this contract\n     * @param _account account address\n     * @return account's staked amount\n     */\n    function staked(address _account) external view override returns (uint256) {\n        return effectiveBalances[_account];\n    }\n\n    /**\n     * @notice returns the total staked amount for use by reward pools\n     * controlled by this contract\n     * @return total staked amount\n     */\n    function totalStaked() external view override returns (uint256) {\n        return totalEffectiveBalance;\n    }\n\n    /**\n     * @notice adds a new token\n     * @param _token token to add\n     * @param _rewardsPool token rewards pool to add\n     **/\n    function addToken(address _token, address _rewardsPool) public override onlyOwner {\n        if (_token == address(sdlToken)) revert InvalidToken();\n        super.addToken(_token, _rewardsPool);\n    }\n\n    /**\n     * @notice returns whether this contract supports an interface\n     * @param _interfaceId id of interface\n     * @return whether contract supports interface or not\n     */\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool) {\n        return\n            _interfaceId == type(IERC721Upgradeable).interfaceId ||\n            _interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            _interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev returns the URI for a token\n     */\n    function tokenURI(uint256) external view returns (string memory) {\n        return baseURI;\n    }\n\n    /**\n     * @dev sets the base URI for all tokens\n     */\n    function setBaseURI(string calldata _baseURI) external onlyOwner {\n        baseURI = _baseURI;\n    }\n\n    /**\n     * @notice sets the boost controller\n     * @dev this contract handles boost calculations for locking SDL\n     * @param _boostController address of boost controller\n     */\n    function setBoostController(address _boostController) external onlyOwner {\n        boostController = IBoostController(_boostController);\n    }\n\n    /**\n     * @notice sets the CCIP controller\n     * @dev this contract interfaces with CCIP\n     * @param _ccipController address of CCIP controller\n     */\n    function setCCIPController(address _ccipController) external onlyOwner {\n        ccipController = _ccipController;\n    }\n\n    /**\n     * @notice creates a new lock\n     * @dev reverts if `_lockingDuration` exceeds maximum\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _createLock(uint256 _amount, uint64 _lockingDuration) internal view returns (Lock memory) {\n        uint256 boostAmount = boostController.getBoostAmount(_amount, _lockingDuration);\n        uint64 startTime = _lockingDuration != 0 ? uint64(block.timestamp) : 0;\n\n        return Lock(_amount, boostAmount, startTime, _lockingDuration, 0);\n    }\n\n    /**\n     * @notice updates an existing lock\n     * @dev\n     * - reverts if `_lockId` is invalid\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` exceeds maximum\n     * @param _lock lock to update\n     * @param _amount additional amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _updateLock(\n        Lock memory _lock,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal view returns (Lock memory) {\n        if ((_lock.expiry == 0 || _lock.expiry > block.timestamp) && _lockingDuration < _lock.duration) {\n            revert InvalidLockingDuration();\n        }\n\n        Lock memory lock = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n\n        uint256 baseAmount = _lock.amount + _amount;\n        uint256 boostAmount = boostController.getBoostAmount(baseAmount, _lockingDuration);\n\n        if (_lockingDuration != 0) {\n            lock.startTime = uint64(block.timestamp);\n        } else {\n            delete lock.startTime;\n        }\n\n        lock.amount = baseAmount;\n        lock.boostAmount = boostAmount;\n        lock.duration = _lockingDuration;\n        lock.expiry = 0;\n\n        return lock;\n    }\n\n    /**\n     * @notice checks if a lock is owned by an certain account\n     * @dev reverts if lock is not owner by account\n     * @param _lockId id of lock\n     * @param _owner owner address\n     **/\n    function _onlyLockOwner(uint256 _lockId, address _owner) internal view {\n        if (_owner != ownerOf(_lockId)) revert SenderNotAuthorized();\n    }\n\n    /**\n     * @notice transfers a lock between accounts\n     * @dev\n     * - reverts if `_from` is not the owner of the lock\n     * - reverts if `to` is zero address\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) internal virtual {\n        if (_from != ownerOf(_lockId)) revert TransferFromIncorrectOwner();\n        if (_to == address(0)) revert TransferToZeroAddress();\n        if (_to == ccipController) revert TransferToCCIPController();\n\n        delete tokenApprovals[_lockId];\n\n        _updateRewards(_from);\n        _updateRewards(_to);\n\n        uint256 effectiveBalanceChange = locks[_lockId].amount + locks[_lockId].boostAmount;\n        effectiveBalances[_from] -= effectiveBalanceChange;\n        effectiveBalances[_to] += effectiveBalanceChange;\n\n        balances[_from] -= 1;\n        balances[_to] += 1;\n        lockOwners[_lockId] = _to;\n\n        emit Transfer(_from, _to, _lockId);\n    }\n\n    /**\n     * taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol\n     * @notice verifies that an address supports ERC721 and calls onERC721Received if applicable\n     * @dev\n     * - called after a lock is safe transferred\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * @param _from address that lock is being transferred from\n     * @param _to address that lock is being transferred to\n     * @param _lockId id of lock\n     * @param _data optional data to be passed to receiver\n     */\n    function _checkOnERC721Received(\n        address _from,\n        address _to,\n        uint256 _lockId,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (_to.code.length > 0) {\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _lockId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert TransferToNonERC721Implementer();\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @notice returns whether an account is authorized to transfer a lock\n     * @dev returns true if `_spender` is approved to transfer `_lockId` or if `_spender` is\n     * approved to transfer all locks owned by the owner of `_lockId`\n     * @param _spender address of account\n     * @param _lockId id of lock\n     * @return whether address is authorized ot not\n     **/\n    function _isApprovedOrOwner(address _spender, uint256 _lockId) internal view returns (bool) {\n        address owner = ownerOf(_lockId);\n        return (_spender == owner || isApprovedForAll(owner, _spender) || getApproved(_lockId) == _spender);\n    }\n}"
    },
    {
      "filename": "contracts/core/sdlPool/base/SDLPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n\nimport \"../../base/RewardsPoolController.sol\";\nimport \"../../interfaces/IBoostController.sol\";\nimport \"../../interfaces/IERC721Receiver.sol\";\n\n/**\n * @title SDL Pool\n * @notice Base SDL Pool contract to inherit from\n */\ncontract SDLPool is RewardsPoolController, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Lock {\n        uint256 amount;\n        uint256 boostAmount;\n        uint64 startTime;\n        uint64 duration;\n        uint64 expiry;\n    }\n\n    string public name;\n    string public symbol;\n\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\n    mapping(uint256 => address) internal tokenApprovals;\n\n    IERC20Upgradeable public sdlToken;\n    IBoostController public boostController;\n\n    uint256 public lastLockId;\n    mapping(uint256 => Lock) internal locks;\n    mapping(uint256 => address) internal lockOwners;\n    mapping(address => uint256) internal balances;\n\n    uint256 public totalEffectiveBalance;\n    mapping(address => uint256) internal effectiveBalances;\n\n    address public ccipController;\n\n    string public baseURI;\n\n    event InitiateUnlock(address indexed owner, uint256 indexed lockId, uint64 expiry);\n    event Withdraw(address indexed owner, uint256 indexed lockId, uint256 amount);\n    event CreateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event UpdateLock(\n        address indexed owner,\n        uint256 indexed lockId,\n        uint256 amount,\n        uint256 boostAmount,\n        uint64 lockingDuration\n    );\n    event OutgoingRESDL(address indexed sender, uint256 indexed lockId);\n    event IncomingRESDL(address indexed receiver, uint256 indexed lockId);\n\n    error SenderNotAuthorized();\n    error InvalidLockId();\n    error InvalidLockingDuration();\n    error TransferFromIncorrectOwner();\n    error TransferToZeroAddress();\n    error TransferToNonERC721Implementer();\n    error TransferToCCIPController();\n    error ApprovalToCurrentOwner();\n    error ApprovalToCaller();\n    error InvalidValue();\n    error InvalidParams();\n    error UnauthorizedToken();\n    error TotalDurationNotElapsed();\n    error HalfDurationNotElapsed();\n    error InsufficientBalance();\n    error UnlockNotInitiated();\n    error DuplicateContract();\n    error ContractNotFound();\n    error UnlockAlreadyInitiated();\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function __SDLPoolBase_init(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public onlyInitializing {\n        __RewardsPoolController_init();\n        name = _name;\n        symbol = _symbol;\n        sdlToken = IERC20Upgradeable(_sdlToken);\n        boostController = IBoostController(_boostController);\n    }\n\n    /**\n     * @notice reverts if `_owner` is not the owner of `_lockId`\n     **/\n    modifier onlyLockOwner(uint256 _lockId, address _owner) {\n        _onlyLockOwner(_lockId, _owner);\n        _;\n    }\n\n    /**\n     * @notice reverts if sender is not the CCIP controller\n     **/\n    modifier onlyCCIPController() {\n        if (msg.sender != ccipController) revert SenderNotAuthorized();\n        _;\n    }\n\n    /**\n     * @notice returns the effective stake balance of an account\n     * @dev the effective stake balance includes the actual amount of tokens an\n     * account has staked across all locks plus any applicable boost gained by locking\n     * @param _account address of account\n     * @return effective stake balance\n     **/\n    function effectiveBalanceOf(address _account) external view returns (uint256) {\n        return effectiveBalances[_account];\n    }\n\n    /**\n     * @notice returns the number of locks owned by an account\n     * @param _account address of account\n     * @return total number of locks owned by account\n     **/\n    function balanceOf(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    /**\n     * @notice returns the owner of a lock\n     * @dev reverts if `_lockId` is invalid\n     * @param _lockId id of the lock\n     * @return lock owner\n     **/\n    function ownerOf(uint256 _lockId) public view returns (address) {\n        address owner = lockOwners[_lockId];\n        if (owner == address(0)) revert InvalidLockId();\n        return owner;\n    }\n\n    /**\n     * @notice returns the list of locks that corresponds to `_lockIds`\n     * @dev reverts if any lockId is invalid\n     * @param _lockIds list of lock ids\n     * @return list of locks\n     **/\n    function getLocks(uint256[] calldata _lockIds) external view returns (Lock[] memory) {\n        Lock[] memory retLocks = new Lock[](_lockIds.length);\n\n        for (uint256 i = 0; i < _lockIds.length; ++i) {\n            uint256 lockId = _lockIds[i];\n            if (lockOwners[lockId] == address(0)) revert InvalidLockId();\n            retLocks[i] = locks[lockId];\n        }\n\n        return retLocks;\n    }\n\n    /**\n     * @notice returns a list of lockIds owned by an account\n     * @param _owner address of account\n     * @return list of lockIds\n     **/\n    function getLockIdsByOwner(address _owner) external view returns (uint256[] memory) {\n        uint256 maxLockId = lastLockId;\n        uint256 lockCount = balanceOf(_owner);\n        uint256 lockIdsFound;\n        uint256[] memory lockIds = new uint256[](lockCount);\n\n        for (uint256 i = 1; i <= maxLockId; ++i) {\n            if (lockOwners[i] == _owner) {\n                lockIds[lockIdsFound] = i;\n                lockIdsFound++;\n                if (lockIdsFound == lockCount) break;\n            }\n        }\n\n        assert(lockIdsFound == lockCount);\n\n        return lockIds;\n    }\n\n    /**\n     * @notice transfers a lock between accounts\n     * @dev reverts if sender is not the owner of and not approved to transfer the lock\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) external {\n        if (!_isApprovedOrOwner(msg.sender, _lockId)) revert SenderNotAuthorized();\n        _transfer(_from, _to, _lockId);\n    }\n\n    /**\n     * @notice transfers a lock between accounts and validates that the receiver supports ERC721\n     * @dev\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * - reverts if sender is not the owner of and not approved to transfer the lock\n     * - reverts if `_lockId` is invalid\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     **/\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId\n    ) external {\n        safeTransferFrom(_from, _to, _lockId, \"\");\n    }\n\n    /**\n     * @notice transfers a lock between accounts and validates that the receiver supports ERC721\n     * @dev\n     * - calls onERC721Received on `_to` if it is a contract or reverts if it is a contract\n     *   and does not implemement onERC721Received\n     * - reverts if sender is not the owner of and not approved to transfer the lock\n     * - reverts if `_lockId` is invalid\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _lockId id of lock to transfer\n     * @param _data optional data to pass to receiver\n     **/\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _lockId,\n        bytes memory _data\n    ) public {\n        if (!_isApprovedOrOwner(msg.sender, _lockId)) revert SenderNotAuthorized();\n        _transfer(_from, _to, _lockId);\n        if (!_checkOnERC721Received(_from, _to, _lockId, _data)) revert TransferToNonERC721Implementer();\n    }\n\n    /**\n     * @notice approves `_to` to transfer `_lockId` to another address\n     * @dev\n     * - approval is revoked on transfer and can also be revoked by approving zero address\n     * - reverts if sender is not owner of lock and not an approved operator for the owner\n     * - reverts if `_to` is owner of lock\n     * - reverts if `_lockId` is invalid\n     * @param _to address approved to transfer\n     * @param _lockId id of lock\n     **/\n    function approve(address _to, uint256 _lockId) external {\n        address owner = ownerOf(_lockId);\n\n        if (_to == owner) revert ApprovalToCurrentOwner();\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert SenderNotAuthorized();\n\n        tokenApprovals[_lockId] = _to;\n        emit Approval(owner, _to, _lockId);\n    }\n\n    /**\n     * @notice returns the address approved to transfer a lock\n     * @param _lockId id of lock\n     * @return approved address\n     **/\n    function getApproved(uint256 _lockId) public view returns (address) {\n        if (lockOwners[_lockId] == address(0)) revert InvalidLockId();\n\n        return tokenApprovals[_lockId];\n    }\n\n    /**\n     * @notice approves _operator to transfer all tokens owned by sender\n     * @dev\n     * - approval will not be revoked until this function is called again with\n     *   `_approved` set to false\n     * - reverts if sender is `_operator`\n     * @param _operator address to approve/unapprove\n     * @param _approved whether address is approved or not\n     **/\n    function setApprovalForAll(address _operator, bool _approved) external {\n        address owner = msg.sender;\n        if (owner == _operator) revert ApprovalToCaller();\n\n        operatorApprovals[owner][_operator] = _approved;\n        emit ApprovalForAll(owner, _operator, _approved);\n    }\n\n    /**\n     * @notice returns whether `_operator` is approved to transfer all tokens owned by `_owner`\n     * @param _owner owner of tokens\n     * @param _operator address approved to transfer\n     * @return whether address is approved or not\n     **/\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /**\n     * @notice returns an account's staked amount for use by reward pools\n     * controlled by this contract\n     * @param _account account address\n     * @return account's staked amount\n     */\n    function staked(address _account) external view override returns (uint256) {\n        return effectiveBalances[_account];\n    }\n\n    /**\n     * @notice returns the total staked amount for use by reward pools\n     * controlled by this contract\n     * @return total staked amount\n     */\n    function totalStaked() external view override returns (uint256) {\n        return totalEffectiveBalance;\n    }\n\n    /**\n     * @notice adds a new token\n     * @param _token token to add\n     * @param _rewardsPool token rewards pool to add\n     **/\n    function addToken(address _token, address _rewardsPool) public override onlyOwner {\n        if (_token == address(sdlToken)) revert InvalidToken();\n        super.addToken(_token, _rewardsPool);\n    }\n\n    /**\n     * @notice returns whether this contract supports an interface\n     * @param _interfaceId id of interface\n     * @return whether contract supports interface or not\n     */\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool) {\n        return\n            _interfaceId == type(IERC721Upgradeable).interfaceId ||\n            _interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            _interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev returns the URI for a token\n     */\n    function tokenURI(uint256) external view returns (string memory) {\n        return baseURI;\n    }\n\n    /**\n     * @dev sets the base URI for all tokens\n     */\n    function setBaseURI(string calldata _baseURI) external onlyOwner {\n        baseURI = _baseURI;\n    }\n\n    /**\n     * @notice sets the boost controller\n     * @dev this contract handles boost calculations for locking SDL\n     * @param _boostController address of boost controller\n     */\n    function setBoostController(address _boostController) external onlyOwner {\n        boostController = IBoostController(_boostController);\n    }\n\n    /**\n     * @notice sets the CCIP controller\n     * @dev this contract interfaces with CCIP\n     * @param _ccipController address of CCIP controller\n     */\n    function setCCIPController(address _ccipController) external onlyOwner {\n        ccipController = _ccipController;\n    }\n\n    /**\n     * @notice creates a new lock\n     * @dev reverts if `_lockingDuration` exceeds maximum\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _createLock(uint256 _amount, uint64 _lockingDuration) internal view returns (Lock memory) {\n        uint256 boostAmount = boostController.getBoostAmount(_amount, _lockingDuration);\n        uint64 startTime = _lockingDuration != 0 ? uint64(block.timestamp) : 0;\n\n        return Lock(_amount, boostAmount, startTime, _lockingDuration, 0);\n    }\n\n    /**\n     * @notice updates an existing lock\n     * @dev\n     * - reverts if `_lockId` is invalid\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` exceeds maximum\n     * @param _lock lock to update\n     * @param _amount additional amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _updateLock(\n        Lock memory _lock,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal view returns (Lock memory) {\n        if ((_lock.expiry == 0 || _lock.expiry > block.timestamp) && _lockingDuration < _lock.duration) {\n            revert InvalidLockingDuration();"
    }
  ]
}