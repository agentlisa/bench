{
  "Title": "M-10: The whole ante balance of a user with a very small loan, who is up for liquidation can be stolen without repaying the debt",
  "Content": "# Issue M-10: The whole ante balance of a user with a very small loan, who is up for liquidation can be stolen without repaying the debt \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/146 \n\n## Found by \nOxZ00mer\n\nUsers with very small loans on markets with tokens having very low decimals are vulnerable to having their collateral stolen during liquidation due to precision loss.\n\n## Vulnerability Detail\n\nUsers face liquidation risk when their Borrower contract's collateral falls short of covering their loan. The `strain` parameter in the liquidation process enables liquidators to partially repay an unhealthy loan. Using a `strain` smaller than 1 results in the liquidator receiving a fraction of the user's collateral based on `collateral / strain`.\n\nThe problem arises from the fact that the `strain` value is not capped, allowing for a potentially harmful scenario. For instance, a user with an unhealthy loan worth $0.30 in a WBTC (8-decimal token) vault on Arbitrum (with very low gas costs) has $50 worth of ETH (with a price of $1500) as collateral in their Borrower contract. A malicious liquidator spots the unhealthy loan and submits a liquidation transaction with a `strain` value of 1e3 + 1. Since the strain exceeds the loan value, the liquidator's repayment amount gets rounded down to 0, effectively allowing them to claim the collateral with only the cost of gas.\n\n```solidity\nassembly (\"memory-safe\") {\n\t// ...\n\tliabilities0 := div(liabilities0, strain) // @audit rounds down to 0 <-\n\tliabilities1 := div(liabilities1, strain) // @audit rounds down to 0 <-\n\t// ...\n}\n```\n\nFollowing this, the execution bypasses the `shouldSwap` if-case and proceeds directly to the following lines:\n\n```solidity\n// @audit Won't be repaid in full since the loan is insolvent\n_repay(repayable0, repayable1);\nslot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT;\n\n// @audit will transfer the user 2e14 (0.5$)\npayable(callee).transfer(address(this).balance / strain);\nemit Liquidate(repayable0, repayable1, incentive1, priceX128);\n\n```\n\nGiven the low gas price on Arbitrum, this transaction becomes profitable for the malicious liquidator, who can repeat it to drain the user's collateral without repaying the loan. This not only depletes the user's collateral but also leaves a small amount of bad debt on the market, potentially causing accounting issues for the vaults.\n\n## Impact\n\nUsers with small loans face the theft of their collateral without the bad debt being covered, leading to financial losses for the user. Additionally, this results in a potential amount of bad debt that can disrupt the vault's accounting.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Borrower.sol#L194\n\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Borrower.sol#L283\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing a check to determine whether the repayment impact is zero or not before transferring ETH to such liquidators.\n\n```solidity\nrequire(repayable0 != 0 || repayable1 != 0, \"Zero repayment impact.\") // @audit <-\n_repay(repayable0, repayable1);\n\nslot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT;\n\npayable(callee).transfer(address(this).balance / strain);\nemit Liquidate(repayable0, repayable1, incentive1, priceX128);\n\n```\n\nAdditionally, contemplate setting a cap for the `strain` and potentially denoting it in basis points (BPS) instead of a fraction. This allows for more flexibility when users intend to repay a percentage lower than 100% but higher than 50% (e.g., 60%, 75%, etc.).\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> low, because it's more profitable to just straight liquidate fully, besides the loss per transaction will be very small\n\n**MohammedRizwan** commented:\n>  valid\n\n\n\n**Shogoki**\n\nEscalate\nI think this is a Low issue.\nThe attack is not profitable, it would probably be more profitable to straight liquidate the position. \nTherefore a liquidation bot would probably do that.\n\nIn case of the `ANTE` the user looses, i would not consider it a real loss, as it is expected he has to pay it for liquidation anyhow.\n\n\n**sherlock-admin2**\n\n > Escalate\n> I think this is a Low issue.\n> The attack is not profitable, it would probably be more profitable to straight liquidate the position. \n> Therefore a liquidation bot would probably do that.\n> \n> In case of the `ANTE` the user looses, i would not consider it a real loss, as it is expected he has to pay it for liquidation anyhow.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**CrisCodesCrap**\n\nThe vector above is profitable under the stated assumptions It demonstrates that the attacker does not need to pay off any of the debt of the victim, but can freely take the ante without paying for anything else than the gas for the transaction, hence they profit without completing the action and stealing the funds from the victim, but leaving them with unpaid debt. \n\n**Oot2k**\n\nAgree with escalation \n\n**cvetanovv**\n\nI disagree with the escalation and this report should remain a valid Medium. The Sponsor also confirms that this is a valid Medium.  Although unlikely to be exploited this way due to the opportunity cost, Watson correctly demonstrates how this can be a profitable attack vector.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\nA bug that inflicts a loss to the attacker but also compromises the system is a valid medium.\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Shogoki](https://github.com/sherlock-audit/2023-10-aloe-judging/issues/146/#issuecomment-1798908663): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "aloe-ii/core/src/Borrower.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {ImmutableArgs} from \"clones-with-immutable-args/ImmutableArgs.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {ERC20, SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IUniswapV3MintCallback} from \"v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {LIQUIDATION_GRACE_PERIOD} from \"./libraries/constants/Constants.sol\";\nimport {Q128} from \"./libraries/constants/Q.sol\";\nimport {BalanceSheet, Assets, Prices} from \"./libraries/BalanceSheet.sol\";\nimport {LiquidityAmounts} from \"./libraries/LiquidityAmounts.sol\";\nimport {square, mulDiv128} from \"./libraries/MulDiv.sol\";\nimport {extract} from \"./libraries/Positions.sol\";\nimport {TickMath} from \"./libraries/TickMath.sol\";\n\nimport {Factory} from \"./Factory.sol\";\nimport {Lender} from \"./Lender.sol\";\nimport {VolatilityOracle} from \"./VolatilityOracle.sol\";\n\ninterface ILiquidator {\n    receive() external payable;\n\n    function swap1For0(bytes calldata data, uint256 received1, uint256 expected0) external;\n\n    function swap0For1(bytes calldata data, uint256 received0, uint256 expected1) external;\n}\n\ninterface IManager {\n    /**\n     * @notice Gives the `IManager` full control of the `Borrower`. Called within `Borrower.modify`.\n     * @dev In most cases, you'll want to verify that `msg.sender` is, in fact, a `Borrower` using\n     * `factory.isBorrower(msg.sender)`.\n     * @param data Encoded parameters that were passed to `Borrower.modify`\n     * @param owner The owner of the `Borrower`\n     * @param positions The `Borrower`'s current Uniswap positions. You can convert them to an array using\n     * `Positions.extract`\n     * @return Updated positions, encoded using `Positions.zip`. Return 0 if you don't wish to make any changes.\n     */\n    function callback(bytes calldata data, address owner, uint208 positions) external returns (uint208);\n}\n\n/// @title Borrower\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract Borrower is IUniswapV3MintCallback {\n    using SafeTransferLib for ERC20;\n\n    /**\n     * @notice Most liquidations involve swapping one asset for another. To incentivize such swaps (even in\n     * volatile markets) liquidators are rewarded with a 5% bonus. To avoid paying that bonus to liquidators,\n     * the account owner can listen for this event. Once it's emitted, they have 2 minutes to bring the\n     * account back to health. If they fail, the liquidation will proceed.\n     * @dev Fortuitous price movements and/or direct `Lender.repay` can bring the account back to health and\n     * nullify the immediate liquidation threat, but they will not clear the warning. This means that next\n     * time the account is unhealthy, liquidators might skip `warn` and `liquidate` right away. To clear the\n     * warning and return to a \"clean\" state, make sure to call `modify` -- even if the callback is a no-op.\n     * @dev The deadline for regaining health (avoiding liquidation) is given by `slot0.unleashLiquidationTime`.\n     * If this value is 0, the account is in the aforementioned \"clean\" state.\n     */\n    event Warn();\n\n    /**\n     * @notice Emitted when the account gets `liquidate`d\n     * @param repay0 The amount of `TOKEN0` that was repaid\n     * @param repay1 The amount of `TOKEN1` that was repaid\n     * @param incentive1 The value of the swap bonus given to the liquidator, expressed in terms of `TOKEN1`\n     * @param priceX128 The price at which the liquidation took place\n     */\n    event Liquidate(uint256 repay0, uint256 repay1, uint256 incentive1, uint256 priceX128);\n\n    enum State {\n        Ready,\n        Locked,\n        InModifyCallback\n    }\n\n    uint256 private constant SLOT0_MASK_POSITIONS = 0x000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 private constant SLOT0_MASK_UNLEASH   = 0x00ffffffffff0000000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant SLOT0_MASK_STATE     = 0x7f00000000000000000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant SLOT0_DIRT           = 0x8000000000000000000000000000000000000000000000000000000000000000; // prettier-ignore\n\n    /// @notice The factory that created this contract\n    Factory public immutable FACTORY;\n\n    /// @notice The oracle to use for prices and implied volatility\n    VolatilityOracle public immutable ORACLE;\n\n    /// @notice The Uniswap pair in which this `Borrower` can manage positions\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n\n    /// @notice The first token of the Uniswap pair\n    ERC20 public immutable TOKEN0;\n\n    /// @notice The second token of the Uniswap pair\n    ERC20 public immutable TOKEN1;\n\n    /// @notice The lender of `TOKEN0`\n    Lender public immutable LENDER0;\n\n    /// @notice The lender of `TOKEN1`\n    Lender public immutable LENDER1;\n\n    /**\n     * @notice The `Borrower`'s only mutable storage. Lowest 144 bits store the lower/upper bounds of up to 3 Uniswap\n     * positions, encoded by `Positions.zip`. Next 64 bits are unused within the `Borrower` and available to users as\n     * \"free\" storage － no additional sstore's. These 208 bits (144 + 64) are passed to `IManager.callback`, and get\n     * updated when the callback returns a non-zero value. The next 40 bits are either 0 or `unleashLiquidationTime`,\n     * as explained in the `Warn` event docs. The highest 8 bits represent the current `State` enum, plus 128. We add\n     * 128 (i.e. set the highest bit to 1) so that the slot is always non-zero, even in the absence of Uniswap\n     * positions － this saves gas.\n     */\n    uint256 public slot0;\n\n    modifier onlyInModifyCallback() {\n        require(slot0 & SLOT0_MASK_STATE == uint256(State.InModifyCallback) << 248);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(VolatilityOracle oracle, IUniswapV3Pool pool, Lender lender0, Lender lender1) {\n        FACTORY = Factory(msg.sender);\n        ORACLE = oracle;\n        UNISWAP_POOL = pool;\n        LENDER0 = lender0;\n        LENDER1 = lender1;\n\n        TOKEN0 = lender0.asset();\n        TOKEN1 = lender1.asset();\n\n        assert(pool.token0() == address(TOKEN0) && pool.token1() == address(TOKEN1));\n    }\n\n    receive() external payable {}\n\n    function owner() public pure returns (address) {\n        return ImmutableArgs.addr();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MAIN ENTRY POINTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Warns the borrower that they're about to be liquidated. NOTE: Liquidators are only\n     * forced to call this in cases where the 5% swap bonus is up for grabs.\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     */\n    function warn(uint40 oracleSeed) external {\n        uint256 slot0_ = slot0;\n        // Essentially `slot0.state == State.Ready && slot0.unleashLiquidationTime == 0`\n        require(slot0_ & (SLOT0_MASK_STATE | SLOT0_MASK_UNLEASH) == 0);\n\n        {\n            // Fetch prices from oracle\n            (Prices memory prices, ) = getPrices(oracleSeed);\n            // Tally assets without actually withdrawing Uniswap positions\n            Assets memory assets = _getAssets(slot0_, prices, false);\n            // Fetch liabilities from lenders\n            (uint256 liabilities0, uint256 liabilities1) = _getLiabilities();\n            // Ensure only unhealthy accounts get warned\n            require(!BalanceSheet.isHealthy(prices, assets, liabilities0, liabilities1), \"Aloe: healthy\");\n        }\n\n        slot0 = slot0_ | ((block.timestamp + LIQUIDATION_GRACE_PERIOD) << 208);\n        emit Warn();\n    }\n\n    /**\n     * @notice Liquidates the borrower, using all available assets to pay down liabilities. If\n     * some or all of the payment cannot be made in-kind, `callee` is expected to swap one asset\n     * for the other at a venue of their choosing. NOTE: Branches involving callbacks will fail\n     * until the borrower has been `warn`ed and the grace period has expired.\n     * @dev As a baseline, `callee` receives `address(this).balance / strain` ETH. This amount is\n     * intended to cover transaction fees. If the liquidation involves a swap callback, `callee`\n     * receives a 5% bonus denominated in the surplus token. In other words, if the two numeric\n     * callback arguments were denominated in the same asset, the first argument would be 5% larger.\n     * @param callee A smart contract capable of swapping `TOKEN0` for `TOKEN1` and vice versa\n     * @param data Encoded parameters that get forwarded to `callee` callbacks\n     * @param strain Almost always set to `1` to pay off all debt and receive maximum reward. If\n     * liquidity is thin and swap price impact would be too large, you can use higher values to\n     * reduce swap size and make it easier for `callee` to do its job. `2` would be half swap size,\n     * `3` one third, and so on.\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     */\n    function liquidate(ILiquidator callee, bytes calldata data, uint256 strain, uint40 oracleSeed) external {\n        uint256 slot0_ = slot0;\n        // Essentially `slot0.state == State.Ready`\n        require(slot0_ & SLOT0_MASK_STATE == 0);\n        slot0 = slot0_ | (uint256(State.Locked) << 248);\n\n        uint256 priceX128;\n        uint256 liabilities0;\n        uint256 liabilities1;\n        uint256 incentive1;\n        {\n            // Fetch prices from oracle\n            (Prices memory prices, ) = getPrices(oracleSeed);\n            priceX128 = square(prices.c);\n            // Withdraw Uniswap positions while tallying assets\n            Assets memory assets = _getAssets(slot0_, prices, true);\n            // Fetch liabilities from lenders\n            (liabilities0, liabilities1) = _getLiabilities();\n            // Calculate liquidation incentive\n            incentive1 = BalanceSheet.computeLiquidationIncentive(\n                assets.fixed0 + assets.fluid0C, // total assets0 at `prices.c` (the TWAP)\n                assets.fixed1 + assets.fluid1C, // total assets1 at `prices.c` (the TWAP)\n                liabilities0,\n                liabilities1,\n                priceX128\n            );\n            // Ensure only unhealthy accounts can be liquidated\n            require(!BalanceSheet.isHealthy(prices, assets, liabilities0, liabilities1), \"Aloe: healthy\");\n        }\n\n        // NOTE: The health check values assets at the TWAP and is difficult to manipulate. However,\n        // the instantaneous price does impact what tokens we receive when burning Uniswap positions.\n        // As such, additional calls to `TOKEN0.balanceOf` and `TOKEN1.balanceOf` are required for\n        // precise inventory, and we take care not to increase `incentive1`.\n\n        unchecked {\n            // Figure out what portion of liabilities can be repaid using existing assets\n            uint256 repayable0 = Math.min(liabilities0, TOKEN0.balanceOf(address(this)));\n            uint256 repayable1 = Math.min(liabilities1, TOKEN1.balanceOf(address(this)));\n\n            // See what remains (similar to \"shortfall\" in BalanceSheet)\n            liabilities0 -= repayable0;\n            liabilities1 -= repayable1;\n\n            // Decide whether to swap or not\n            bool shouldSwap;\n            assembly (\"memory-safe\") {\n                // If both are zero or neither is zero, there's nothing more to do\n                shouldSwap := xor(gt(liabilities0, 0), gt(liabilities1, 0))\n                // Divide by `strain` and check again. This second check can generate false positives in cases\n                // where one division (not both) floors to 0, which is why we `and()` with the check above.\n                liabilities0 := div(liabilities0, strain)\n                liabilities1 := div(liabilities1, strain)\n                shouldSwap := and(shouldSwap, xor(gt(liabilities0, 0), gt(liabilities1, 0)))\n                // If not swapping, set `incentive1 = 0`\n                incentive1 := mul(shouldSwap, incentive1)\n            }\n\n            if (shouldSwap) {\n                uint256 unleashTime = (slot0_ & SLOT0_MASK_UNLEASH) >> 208;\n                require(0 < unleashTime && unleashTime < block.timestamp, \"Aloe: grace\");\n\n                incentive1 /= strain;\n                if (liabilities0 > 0) {\n                    // NOTE: This value is not constrained to `TOKEN1.balanceOf(address(this))`, so liquidators\n                    // are responsible for setting `strain` such that the transfer doesn't revert. This shouldn't\n                    // be an issue unless the borrower has already started accruing bad debt.\n                    uint256 available1 = mulDiv128(liabilities0, priceX128) + incentive1;\n\n                    TOKEN1.safeTransfer(address(callee), available1);\n                    callee.swap1For0(data, available1, liabilities0);\n\n                    repayable0 += liabilities0;\n                } else {\n                    // NOTE: This value is not constrained to `TOKEN0.balanceOf(address(this))`, so liquidators\n                    // are responsible for setting `strain` such that the transfer doesn't revert. This shouldn't\n                    // be an issue unless the borrower has already started accruing bad debt.\n                    uint256 available0 = Math.mulDiv(liabilities1 + incentive1, Q128, priceX128);\n\n                    TOKEN0.safeTransfer(address(callee), available0);\n                    callee.swap0For1(data, available0, liabilities1);\n\n                    repayable1 += liabilities1;\n                }\n            }\n\n            _repay(repayable0, repayable1);\n            slot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT;\n\n            payable(callee).transfer(address(this).balance / strain);\n            emit Liquidate(repayable0, repayable1, incentive1, priceX128);\n        }\n    }\n\n    /**\n     * @notice Allows the owner to manage their account by handing control to some `callee`. Inside the\n     * callback `callee` has access to all sub-commands (`uniswapDeposit`, `uniswapWithdraw`, `transfer`,\n     * `borrow`, `repay`, and `withdrawAnte`). Whatever `callee` does, the account MUST be healthy\n     * after the callback.\n     * @param callee The smart contract that will get temporary control of this account\n     * @param data Encoded parameters that get forwarded to `callee`\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     */\n    function modify(IManager callee, bytes calldata data, uint40 oracleSeed) external payable {\n        uint256 slot0_ = slot0;\n        // Essentially `slot0.state == State.Ready && msg.sender == owner()`\n        require(slot0_ & SLOT0_MASK_STATE == 0 && msg.sender == owner(), \"Aloe: only owner\");\n\n        slot0 = slot0_ | (uint256(State.InModifyCallback) << 248);\n        {\n            uint208 positions = callee.callback(data, msg.sender, uint208(slot0_));\n            assembly (\"memory-safe\") {\n                // Equivalent to `if (positions > 0) slot0_ = positions`\n                slot0_ := or(positions, mul(slot0_, iszero(positions)))\n            }\n        }\n        slot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT;\n\n        (uint256 liabilities0, uint256 liabilities1) = _getLiabilities();\n        if (liabilities0 > 0 || liabilities1 > 0) {\n            (uint208 ante, uint8 nSigma, uint8 mtd, uint32 pausedUntilTime) = FACTORY.getParameters(UNISWAP_POOL);\n            (Prices memory prices, bool seemsLegit) = _getPrices(oracleSeed, nSigma, mtd);\n\n            require(\n                seemsLegit && (block.timestamp > pausedUntilTime) && (address(this).balance >= ante),\n                \"Aloe: missing ante / sus price\"\n            );\n\n            Assets memory assets = _getAssets(slot0_, prices, false);\n            require(BalanceSheet.isHealthy(prices, assets, liabilities0, liabilities1), \"Aloe: unhealthy\");\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              SUB-COMMANDS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Callback for Uniswap V3 pool; necessary for `uniswapDeposit` to work\n     * @param amount0 The amount of `TOKEN0` owed to the `UNISWAP_POOL`\n     * @param amount1 The amount of `TOKEN1` owed to the `UNISWAP_POOL`\n     */\n    function uniswapV3MintCallback(uint256 amount0, uint256 amount1, bytes calldata) external {\n        require(msg.sender == address(UNISWAP_POOL));\n\n        if (amount0 > 0) TOKEN0.safeTransfer(msg.sender, amount0);\n        if (amount1 > 0) TOKEN1.safeTransfer(msg.sender, amount1);\n    }\n\n    /**\n     * @notice Allows the `owner()` to add liquidity to a Uniswap position (or create a new one). Only works\n     * within the `modify` callback.\n     * @dev The `LiquidityAmounts` library can help convert underlying amounts to units of `liquidity`.\n     * NOTE: Depending on your use-case, it may be more gas-efficient to call `UNISWAP_POOL.mint` in your\n     * own contract, instead of doing `uniswapDeposit` inside of `modify`'s callback. As long as you set\n     * this `Borrower` as the recipient in `UNISWAP_POOL.mint`, the result is the same.\n     * @param lower The tick at the position's lower bound\n     * @param upper The tick at the position's upper bound\n     * @param liquidity The amount of liquidity to add, in Uniswap's internal units\n     * @return amount0 The precise amount of `TOKEN0` that went into the Uniswap position\n     * @return amount1 The precise amount of `TOKEN1` that went into the Uniswap position\n     */\n    function uniswapDeposit(\n        int24 lower,\n        int24 upper,\n        uint128 liquidity\n    ) external onlyInModifyCallback returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = UNISWAP_POOL.mint(address(this), lower, upper, liquidity, \"\");\n    }\n\n    /**\n     * @notice Allows the `owner()` to withdraw liquidity from one of their Uniswap positions. Only works within\n     * the `modify` callback.\n     * @dev The `LiquidityAmounts` library can help convert underlying amounts to units of `liquidity`\n     * @param lower The tick at the position's lower bound\n     * @param upper The tick at the position's upper bound\n     * @param liquidity The amount of liquidity to remove, in Uniswap's internal units. Pass 0 to collect\n     * fees without burning any liquidity.\n     * @param recipient Receives the tokens from Uniswap. Usually the address of this `Borrower` account.\n     * @return burned0 The amount of `TOKEN0` that was removed from the Uniswap position\n     * @return burned1 The amount of `TOKEN1` that was removed from the Uniswap position\n     * @return collected0 Equal to `burned0` plus any earned `TOKEN0` fees that hadn't yet been claimed\n     * @return collected1 Equal to `burned1` plus any earned `TOKEN1` fees that hadn't yet been claimed\n     */\n    function uniswapWithdraw(\n        int24 lower,\n        int24 upper,\n        uint128 liquidity,\n        address recipient\n    ) external onlyInModifyCallback returns (uint256 burned0, uint256 burned1, uint256 collected0, uint256 collected1) {\n        (burned0, burned1, collected0, collected1) = _uniswapWithdraw(lower, upper, liquidity, recipient);\n    }\n\n    /**\n     * @notice The most flexible sub-command. Allows the `owner()` to transfer amounts of `TOKEN0` and `TOKEN1`\n     * to any `recipient` they want. Only works within the `modify` callback.\n     * @param amount0 The amount of `TOKEN0` to transfer\n     * @param amount1 The amount of `TOKEN1` to transfer\n     * @param recipient Receives the transferred tokens\n     */\n    function transfer(uint256 amount0, uint256 amount1, address recipient) external onlyInModifyCallback {\n        if (amount0 > 0) TOKEN0.safeTransfer(recipient, amount0);\n        if (amount1 > 0) TOKEN1.safeTransfer(recipient, amount1);\n    }\n\n    /**\n     * @notice Allows the `owner()` to borrow funds from `LENDER0` and `LENDER1`. Only works within the `modify`\n     * callback.\n     * @dev If `amount0 > 0` and interest hasn't yet accrued in this block for `LENDER0`, it will accrue\n     * prior to processing your new borrow. Same goes for `amount1 > 0` and `LENDER1`.\n     * @param amount0 The amount of `TOKEN0` to borrow\n     * @param amount1 The amount of `TOKEN1` to borrow\n     * @param recipient Receives the borrowed tokens. Usually the address of this `Borrower` account.\n     */\n    function borrow(uint256 amount0, uint256 amount1, address recipient) external onlyInModifyCallback {\n        if (amount0 > 0) LENDER0.borrow(amount0, recipient);\n        if (amount1 > 0) LENDER1.borrow(amount1, recipient);\n    }\n\n    /**\n     * @notice Allows the `owner()` to repay debts to `LENDER0` and `LENDER1`. Only works within the `modify`\n     * callback.\n     * @dev This is technically unnecessary since you could call `Lender.repay` directly, specifying this\n     * contract as the `beneficiary` and using the `transfer` sub-command to make payments. We include it\n     * because it's convenient and gas-efficient for common use-cases.\n     * @param amount0 The amount of `TOKEN0` to repay\n     * @param amount1 The amount of `TOKEN1` to repay\n     */\n    function repay(uint256 amount0, uint256 amount1) external onlyInModifyCallback {\n        _repay(amount0, amount1);\n    }\n\n    /**\n     * @notice Allows the `owner()` to withdraw their ante. Only works within the `modify` callback.\n     * @param recipient Receives the ante (as Ether)\n     */\n    function withdrawAnte(address payable recipient) external onlyInModifyCallback {\n        // WARNING: External call to user-specified address\n        recipient.transfer(address(this).balance);\n    }\n\n    /**\n     * @notice Allows the `owner()` to perform arbitrary transfers. Useful for rescuing misplaced funds. Only\n     * works within the `modify` callback.\n     * @param token The ERC20 token to transfer\n     * @param amount The amount to transfer\n     * @param recipient Receives the transferred tokens\n     */\n    function rescue(ERC20 token, uint256 amount, address recipient) external onlyInModifyCallback {\n        // WARNING: External call to user-specified address\n        token.safeTransfer(recipient, amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             BALANCE SHEET\n    //////////////////////////////////////////////////////////////*/\n\n    function getUniswapPositions() external view returns (int24[] memory) {\n        return extract(slot0);\n    }\n\n    /**\n     * @notice Summarizes all oracle data pertinent to account health\n     * @dev If `seemsLegit == false`, you can call `Factory.pause` to temporarily disable borrows\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     * @return prices The probe prices currently being used to evaluate account health\n     * @return seemsLegit Whether the Uniswap TWAP seems to have been manipulated or not\n     */\n    function getPrices(uint40 oracleSeed) public view returns (Prices memory prices, bool seemsLegit) {\n        (, uint8 nSigma, uint8 manipulationThresholdDivisor, ) = FACTORY.getParameters(UNISWAP_POOL);\n        (prices, seemsLegit) = _getPrices(oracleSeed, nSigma, manipulationThresholdDivisor);\n    }\n\n    function _getPrices(\n        uint40 oracleSeed,\n        uint8 nSigma,\n        uint8 manipulationThresholdDivisor\n    ) private view returns (Prices memory prices, bool seemsLegit) {\n        uint56 metric;\n        uint256 iv;\n        // compute current price and volatility\n        (metric, prices.c, iv) = ORACLE.consult(UNISWAP_POOL, oracleSeed);\n        // compute prices at which solvency will be checked\n        (prices.a, prices.b, seemsLegit) = BalanceSheet.computeProbePrices(\n            metric,\n            prices.c,\n            iv,\n            nSigma,\n            manipulationThresholdDivisor\n        );\n    }\n\n    function _getAssets(uint256 slot0_, Prices memory prices, bool withdraw) private returns (Assets memory assets) {\n        assets.fixed0 = TOKEN0.balanceOf(address(this));\n        assets.fixed1 = TOKEN1.balanceOf(address(this));\n\n        int24[] memory positions = extract(slot0_);\n        uint256 count = positions.length;\n        unchecked {\n            for (uint256 i; i < count; i += 2) {\n                // Load lower and upper ticks from the `positions` array\n                int24 l = positions[i];\n                int24 u = positions[i + 1];\n                // Fetch amount of `liquidity` in the position\n                (uint128 liquidity, , , , ) = UNISWAP_POOL.positions(keccak256(abi.encodePacked(address(this), l, u)));\n\n                if (liquidity == 0) continue;\n\n                // Compute lower and upper sqrt ratios\n                uint160 L = TickMath.getSqrtRatioAtTick(l);\n                uint160 U = TickMath.getSqrtRatioAtTick(u);\n\n                // Compute the value of `liquidity` (in terms of token1) at both probe prices\n                assets.fluid1A += LiquidityAmounts.getValueOfLiquidity(prices.a, L, U, liquidity);\n                assets.fluid1B += LiquidityAmounts.getValueOfLiquidity(prices.b, L, U, liquidity);\n\n                // Compute what amounts underlie `liquidity` at the current TWAP\n                (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(prices.c, L, U, liquidity);\n                assets.fluid0C += amount0;\n                assets.fluid1C += amount1;\n\n                if (!withdraw) continue;\n\n                // Withdraw all `liquidity` from the position\n                _uniswapWithdraw(l, u, liquidity, address(this));\n            }\n        }\n    }\n\n    function _getLiabilities() private view returns (uint256 amount0, uint256 amount1) {\n        amount0 = LENDER0.borrowBalanceStored(address(this));\n        amount1 = LENDER1.borrowBalanceStored(address(this));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _uniswapWithdraw(\n        int24 lower,\n        int24 upper,\n        uint128 liquidity,\n        address recipient\n    ) private returns (uint256 burned0, uint256 burned1, uint256 collected0, uint256 collected1) {\n        (burned0, burned1) = UNISWAP_POOL.burn(lower, upper, liquidity);\n        (collected0, collected1) = UNISWAP_POOL.collect(recipient, lower, upper, type(uint128).max, type(uint128).max);\n    }\n\n    function _repay(uint256 amount0, uint256 amount1) private {\n        if (amount0 > 0) {\n            TOKEN0.safeTransfer(address(LENDER0), amount0);\n            LENDER0.repay(amount0, address(this));\n        }\n        if (amount1 > 0) {\n            TOKEN1.safeTransfer(address(LENDER1), amount1);\n            LENDER1.repay(amount1, address(this));\n        }\n    }\n}"
    },
    {
      "filename": "aloe-ii/core/src/Borrower.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {ImmutableArgs} from \"clones-with-immutable-args/ImmutableArgs.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {ERC20, SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IUniswapV3MintCallback} from \"v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {LIQUIDATION_GRACE_PERIOD} from \"./libraries/constants/Constants.sol\";\nimport {Q128} from \"./libraries/constants/Q.sol\";\nimport {BalanceSheet, Assets, Prices} from \"./libraries/BalanceSheet.sol\";\nimport {LiquidityAmounts} from \"./libraries/LiquidityAmounts.sol\";\nimport {square, mulDiv128} from \"./libraries/MulDiv.sol\";\nimport {extract} from \"./libraries/Positions.sol\";\nimport {TickMath} from \"./libraries/TickMath.sol\";\n\nimport {Factory} from \"./Factory.sol\";\nimport {Lender} from \"./Lender.sol\";\nimport {VolatilityOracle} from \"./VolatilityOracle.sol\";\n\ninterface ILiquidator {\n    receive() external payable;\n\n    function swap1For0(bytes calldata data, uint256 received1, uint256 expected0) external;\n\n    function swap0For1(bytes calldata data, uint256 received0, uint256 expected1) external;\n}\n\ninterface IManager {\n    /**\n     * @notice Gives the `IManager` full control of the `Borrower`. Called within `Borrower.modify`.\n     * @dev In most cases, you'll want to verify that `msg.sender` is, in fact, a `Borrower` using\n     * `factory.isBorrower(msg.sender)`.\n     * @param data Encoded parameters that were passed to `Borrower.modify`\n     * @param owner The owner of the `Borrower`\n     * @param positions The `Borrower`'s current Uniswap positions. You can convert them to an array using\n     * `Positions.extract`\n     * @return Updated positions, encoded using `Positions.zip`. Return 0 if you don't wish to make any changes.\n     */\n    function callback(bytes calldata data, address owner, uint208 positions) external returns (uint208);\n}\n\n/// @title Borrower\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract Borrower is IUniswapV3MintCallback {\n    using SafeTransferLib for ERC20;\n\n    /**\n     * @notice Most liquidations involve swapping one asset for another. To incentivize such swaps (even in\n     * volatile markets) liquidators are rewarded with a 5% bonus. To avoid paying that bonus to liquidators,\n     * the account owner can listen for this event. Once it's emitted, they have 2 minutes to bring the\n     * account back to health. If they fail, the liquidation will proceed.\n     * @dev Fortuitous price movements and/or direct `Lender.repay` can bring the account back to health and\n     * nullify the immediate liquidation threat, but they will not clear the warning. This means that next\n     * time the account is unhealthy, liquidators might skip `warn` and `liquidate` right away. To clear the\n     * warning and return to a \"clean\" state, make sure to call `modify` -- even if the callback is a no-op.\n     * @dev The deadline for regaining health (avoiding liquidation) is given by `slot0.unleashLiquidationTime`.\n     * If this value is 0, the account is in the aforementioned \"clean\" state.\n     */\n    event Warn();\n\n    /**\n     * @notice Emitted when the account gets `liquidate`d\n     * @param repay0 The amount of `TOKEN0` that was repaid\n     * @param repay1 The amount of `TOKEN1` that was repaid\n     * @param incentive1 The value of the swap bonus given to the liquidator, expressed in terms of `TOKEN1`\n     * @param priceX128 The price at which the liquidation took place\n     */\n    event Liquidate(uint256 repay0, uint256 repay1, uint256 incentive1, uint256 priceX128);\n\n    enum State {\n        Ready,\n        Locked,\n        InModifyCallback\n    }\n\n    uint256 private constant SLOT0_MASK_POSITIONS = 0x000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 private constant SLOT0_MASK_UNLEASH   = 0x00ffffffffff0000000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant SLOT0_MASK_STATE     = 0x7f00000000000000000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant SLOT0_DIRT           = 0x8000000000000000000000000000000000000000000000000000000000000000; // prettier-ignore\n\n    /// @notice The factory that created this contract\n    Factory public immutable FACTORY;\n\n    /// @notice The oracle to use for prices and implied volatility\n    VolatilityOracle public immutable ORACLE;\n\n    /// @notice The Uniswap pair in which thi"
    }
  ]
}