{
  "Title": "[M-04] GiantPool should not check ETH amount on withdrawal",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53\n\n\n# Vulnerability details\n\n## Impact\nThe `GiantPoolBase.withdrawETH` function requires that the amount to withdraw is at least as big as the `MIN_STAKING_AMOUNT` ([https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53](https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L53)).  \n\nThis check does not serve any purpose and can actually cause the user problems when withdrawing his ETH.  \n\n## Proof of Concept\n1. Bob deposits ETH into the GiantPool with the `GiantPoolBase.depositETH` function.  \n   The amount is equal to `MIN_STAKING_AMOUNT + 0.99 * MIN_STAKING_AMOUNT`.\n2. Bob witdraws `MIN_STAKING_AMOUNT` ETH from the GiantPool.  \n3. Bob has `0.99 * MIN_STAKING_AMOUNT` ETH left in the GiantPool. This is a problem since he cannot withdraw this amount of ETH since it is smaller than `MIN_STAKING_AMOUNT`.  \n   In order to withdraw his funds, Bob needs to first add funds to the GiantPool such that the deposited amount is big enough for withdrawal.  However this causes extra transaction fees to be paid (loss of funds) and causes a bad user experience.  \n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");` statement should just be removed. It does not serve any purpose anyway.  ",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/GiantPoolBase.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}"
    }
  ]
}