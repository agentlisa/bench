{
  "Title": "[G-01] Avoid Reading and writing to state if amount is zero",
  "Content": "\n### 4 Instances\n\n1. ### Refactor `PaymentEscrow._decreaseDeposit()` to avoid state read/write if `amount` is zero\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L294\n\nIn the `PaymentEscrow._decreaseDeposit()` function as shown below checks should be implemented to avoid  reading and writing to state if the `amount` argument is zero this is because if `amount` is 0 the statement `balanceOf[token] -= amount` would not change the value of `spenderAllowance` since its being decremented by zero. This then means that in scenarios where `amount` is 0 the statement `balanceOf[token] -= amount` is re-assigning the same value to state i.e there is no state change. Also its important to note that the `_settlePayment()` function that invokes this function does note implement this check before the invocation. The diff below shows how the function should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/PaymentEscrow.sol\n\n292:    function _decreaseDeposit(address token, uint256 amount) internal {\n293:        // Directly decrease the synced balance.\n294:        balanceOf[token] -= amount;\n295:    }\n```\n```diff\ndiff --git a/src/modules/PaymentEscrow.sol b/src/modules/PaymentEscrow.sol\nindex 34c4f4c..d90f184 100644\n--- a/src/modules/PaymentEscrow.sol\n+++ b/src/modules/PaymentEscrow.sol\n@@ -291,7 +291,10 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n      */\n     function _decreaseDeposit(address token, uint256 amount) internal {\n         // Directly decrease the synced balance.\n-        balanceOf[token] -= amount;\n+        if (amount > 0){\n+            balanceOf[token] -= amount;\n+        }\n+\n     }\n```\n```\nEstimated gas saved: 5000 gas units\n```\n</details>\n\n2. ### Refactor `Storage.addRentals()` to avoid state read/write if `asset.amount` is zero\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L201\n\nIn the `Storage.addRentals()` function as shown below checks should be implemented to avoid reading and writing to state if the value of  `asset.amount` is zero this is because if `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] += asset.amount` would not change the value of `rentedAssets[asset.rentalId]` since its being incremented by zero. This then means that in scenarios where `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] += asset.amount` is re-assigning the same value to state i.e there is no state change. The diff below shows how the function should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/Storage.sol\n\n189:    function addRentals(\n190:        bytes32 orderHash,\n191:        RentalAssetUpdate[] memory rentalAssetUpdates\n192:    ) external onlyByProxy permissioned {\n193:        // Add the order to storage.\n194:        orders[orderHash] = true;\n195:\n196:        // Add the rented items to storage.\n197:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n198:            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n199:\n200:            // Update the order hash for that item.\n201:            rentedAssets[asset.rentalId] += asset.amount;\n202:        }\n203:    }\n```\n```diff\ndiff --git a/src/modules/Storage.sol b/src/modules/Storage.sol\nindex 1e46bcb..b909f41 100644\n--- a/src/modules/Storage.sol\n+++ b/src/modules/Storage.sol\n@@ -198,7 +198,10 @@ contract Storage is Proxiable, Module, StorageBase {\n             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n             // Update the order hash for that item.\n-            rentedAssets[asset.rentalId] += asset.amount;\n+            if (asset.amount > 0) {\n+                rentedAssets[asset.rentalId] += asset.amount;\n+            }\n+\n         }\n     }\n```\n```\nEstimated gas saved: 5000 gas units\n```\n</details>\n\n3. ### Refactor `Storage.removeRentals()` to avoid state read/write if `asset.amount` is zero\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L233\n\nIn the `Storage.removeRentals()` function as shown below checks should be implemented to avoid reading and writing to state if the value of  `asset.amount` is zero this is because if `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] -= asset.amount` would not change the value of `rentedAssets[asset.rentalId]` since its being decremented by zero. This then means that in scenarios where `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] -= asset.amount` is re-assigning the same value to state i.e there is no state change. The diff below shows how the function should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/Storage.sol\n\n216:    function removeRentals(\n217:        bytes32 orderHash,\n218:        RentalAssetUpdate[] calldata rentalAssetUpdates\n219:    ) external onlyByProxy permissioned {\n220:        // The order must exist to be deleted.\n221:        if (!orders[orderHash]) {\n222:            revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n223:        } else {\n224:            // Delete the order from storage.\n225:            delete orders[orderHash];\n226:        }\n227:\n228:        // Process each rental asset.\n229:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n230:            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n231:\n232:            // Reduce the amount of tokens for the particular rental ID.\n233:            rentedAssets[asset.rentalId] -= asset.amount;\n234:        }\n235:    }\n```\n```diff\ndiff --git a/src/modules/Storage.sol b/src/modules/Storage.sol\nindex 1e46bcb..b8f2248 100644\n--- a/src/modules/Storage.sol\n+++ b/src/modules/Storage.sol\n@@ -230,7 +230,10 @@ contract Storage is Proxiable, Module, StorageBase {\n             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n             // Reduce the amount of tokens for the particular rental ID.\n-            rentedAssets[asset.rentalId] -= asset.amount;\n+            if (asset.amount > 0) {\n+                rentedAssets[asset.rentalId] -= asset.amount;\n+            }\n+\n         }\n     }\n```\n```\nEstimated gas saved: 5000 gas units\n```\n</details>\n\n4. ### Refactor `Storage.removeRentalsBatch()` to avoid state read/write if `asset.amount` is zero\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L264\n\nIn the `Storage.removeRentalsBatch()` function as shown below checks should be implemented to avoid reading and writing to state if the value of  `asset.amount` is zero this is because if `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] -= asset.amount` would not change the value of `rentedAssets[asset.rentalId]` since its being decremented by zero. This then means that in scenarios where `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] -= asset.amount` is re-assigning the same value to state i.e there is no state change. The diff below shows how the function should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/Storage.sol\n\n244:    function removeRentalsBatch(\n245:        bytes32[] calldata orderHashes,\n246:        RentalAssetUpdate[] calldata rentalAssetUpdates\n247:    ) external onlyByProxy permissioned {\n248:        // Delete the orders from storage.\n249:        for (uint256 i = 0; i < orderHashes.length; ++i) {\n250:            // The order must exist to be deleted.\n251:            if (!orders[orderHashes[i]]) {\n252:                revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:            } else {\n254:                // Delete the order from storage.\n255:                delete orders[orderHashes[i]];\n256:            }\n257:        }\n258:\n259:        // Process each rental asset.\n260:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n261:            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n262:\n263:            // Reduce the amount of tokens for the particular rental ID.\n264:            rentedAssets[asset.rentalId] -= asset.amount;\n265:        }\n266:    }\n```\n```diff\ndiff --git a/src/modules/Storage.sol b/src/modules/Storage.sol\nindex 1e46bcb..677656c 100644\n--- a/src/modules/Storage.sol\n+++ b/src/modules/Storage.sol\n@@ -261,7 +261,10 @@ contract Storage is Proxiable, Module, StorageBase {\n             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n             // Reduce the amount of tokens for the particular rental ID.\n-            rentedAssets[asset.rentalId] -= asset.amount;\n+            if (asset.amount > 0) {\n+                rentedAssets[asset.rentalId] -= asset.amount;\n+            }\n+\n         }\n```\n```\nEstimated gas saved: 5000 gas units\n```\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/modules/PaymentEscrow.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\n\nimport {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\nimport {Proxiable} from \"@src/proxy/Proxiable.sol\";\nimport {\n    RentalOrder,\n    Item,\n    ItemType,\n    SettleTo,\n    OrderType\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n\n/**\n * @title PaymentEscrowBase\n * @notice Storage exists in its own base contract to avoid storage slot mismatch during upgrades.\n */\ncontract PaymentEscrowBase {\n    // Keeps a record of the current token balances in the escrow.\n    mapping(address token => uint256 amount) public balanceOf;\n\n    // Fee percentage taken from payments.\n    uint256 public fee;\n}\n\n/**\n * @title PaymentEscrow\n * @notice Module dedicated to escrowing rental payments while rentals are active. When\n *         rentals are stopped, this module will determine payouts to all parties and a\n *         fee will be reserved to be withdrawn later by a protocol admin.\n */\ncontract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n    using RentalUtils for Item;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Module Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Instantiate this contract as a module. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /**\n     * @notice Instantiates this contract as a module via a proxy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    function MODULE_PROXY_INSTANTIATION(\n        Kernel kernel_\n    ) external onlyByProxy onlyUninitialized {\n        kernel = kernel_;\n        initialized = true;\n    }\n\n    /**\n     * @notice Specifies which version of a module is being implemented.\n     */\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /**\n     * @notice Defines the keycode for this module.\n     */\n    function KEYCODE() public pure override returns (Keycode) {\n        return Keycode.wrap(\"ESCRW\");\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Calculates the fee based on the fee numerator set by an admin.\n     *\n     * @param amount Amount for which to calculate the fee.\n     */\n    function _calculateFee(uint256 amount) internal view returns (uint256) {\n        // Uses 10,000 as a denominator for the fee.\n        return (amount * fee) / 10000;\n    }\n\n    /**\n     * @dev Safe transfer for ERC20 tokens that do not consistently renturn true/false.\n     *\n     * @param token Asset address which is being sent.\n     * @param to    Destination address for the transfer.\n     * @param value Amount of the asset being transferred.\n     */\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        // Call transfer() on the token.\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n\n        // Because both reverting and returning false are allowed by the ERC20 standard\n        // to indicate a failed transfer, we must handle both cases.\n        //\n        // If success is false, the ERC20 contract reverted.\n        //\n        // If success is true, we must check if return data was provided. If no return\n        // data is provided, then no revert occurred. But, if return data is provided,\n        // then it must be decoded into a bool which will indicate the success of the\n        // transfer.\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n        }\n    }\n\n    /**\n     * @dev Calculates the pro-rata split based on the amount of time that has elapsed in\n     *      a rental order. If there are not enough funds to split perfectly, rounding is\n     *      done to make the split as fair as possible.\n     *\n     * @param amount      Amount of tokens for which to calculate the split.\n     * @param elapsedTime Elapsed time since the rental started.\n     * @param totalTime   Total time window of the rental from start to end.\n     *\n     * @return renterAmount Payment amount to send to the renter.\n     * @return lenderAmount Payment amoutn to send to the lender.\n     */\n    function _calculatePaymentProRata(\n        uint256 amount,\n        uint256 elapsedTime,\n        uint256 totalTime\n    ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n        // Calculate the numerator and adjust by a multiple of 1000.\n        uint256 numerator = (amount * elapsedTime) * 1000;\n\n        // Calculate the result, but bump by 500 to add a rounding adjustment. Then,\n        // reduce by a multiple of 1000.\n        renterAmount = ((numerator / totalTime) + 500) / 1000;\n\n        // Calculate lender amount from renter amount so no tokens are left behind.\n        lenderAmount = amount - renterAmount;\n    }\n\n    /**\n     * @dev Settles a payment via a pro-rata split. After payments are calculated, they\n     *      are transferred to their respective recipients.\n     *\n     * @param token       Token address for which to settle a payment.\n     * @param amount      Amount of the token to settle.\n     * @param lender      Lender account.\n     * @param renter      Renter accoutn.\n     * @param elapsedTime Elapsed time since the rental started.\n     * @param totalTime   Total time window of the rental from start to end.\n     */\n    function _settlePaymentProRata(\n        address token,\n        uint256 amount,\n        address lender,\n        address renter,\n        uint256 elapsedTime,\n        uint256 totalTime\n    ) internal {\n        // Calculate the pro-rata payment for renter and lender.\n        (uint256 renterAmount, uint256 lenderAmount) = _calculatePaymentProRata(\n            amount,\n            elapsedTime,\n            totalTime\n        );\n\n        // Send the lender portion of the payment.\n        _safeTransfer(token, lender, lenderAmount);\n\n        // Send the renter portion of the payment.\n        _safeTransfer(token, renter, renterAmount);\n    }\n\n    /**\n     * @dev Settles a payment by sending the full amount to one address.\n     *\n     * @param token    Token address for which to settle a payment.\n     * @param amount   Amount of the token to settle.\n     * @param settleTo Specifies whether to settle to the lender or the renter.\n     * @param lender   Lender account.\n     * @param renter   Renter account.\n     */\n    function _settlePaymentInFull(\n        address token,\n        uint256 amount,\n        SettleTo settleTo,\n        address lender,\n        address renter\n    ) internal {\n        // Determine the address that this payment will settle to.\n        address settleToAddress = settleTo == SettleTo.LENDER ? lender : renter;\n\n        // Send the payment.\n        _safeTransfer(token, settleToAddress, amount);\n    }\n\n    /**\n     * @dev Settles alls payments contained in the given item. Uses a pro-rata or in full\n     *      scheme depending on the order type and when the order was stopped.\n     *\n     * @param items     Items present in the order.\n     * @param orderType Type of the order.\n     * @param lender    Lender account.\n     * @param renter    Renter account.\n     * @param start     Timestamp that the rental began.\n     * @param end       Timestamp that the rental expires at.\n     */\n    function _settlePayment(\n        Item[] calldata items,\n        OrderType orderType,\n        address lender,\n        address renter,\n        uint256 start,\n        uint256 end\n    ) internal {\n        // Calculate the time values.\n        uint256 elapsedTime = block.timestamp - start;\n        uint256 totalTime = end - start;\n\n        // Determine whether the rental order has ended.\n        bool isRentalOver = elapsedTime >= totalTime;\n\n        // Loop through each item in the order.\n        for (uint256 i = 0; i < items.length; ++i) {\n            // Get the item.\n            Item memory item = items[i];\n\n            // Check that the item is a payment.\n            if (item.isERC20()) {\n                // Set a placeholder payment amount which can be reduced in the\n                // presence of a fee.\n                uint256 paymentAmount = item.amount;\n\n                // Take a fee on the payment amount if the fee is on.\n                if (fee != 0) {\n                    // Calculate the new fee.\n                    uint256 paymentFee = _calculateFee(paymentAmount);\n\n                    // Adjust the payment amount by the fee.\n                    paymentAmount -= paymentFee;\n                }\n\n                // Effect: Decrease the token balance. Use the payment amount pre-fee\n                // so that fees can be taken.\n                _decreaseDeposit(item.token, item.amount);\n\n                // If its a PAY order but the rental hasn't ended yet.\n                if (orderType.isPayOrder() && !isRentalOver) {\n                    // Interaction: a PAY order which hasnt ended yet. Payout is pro-rata.\n                    _settlePaymentProRata(\n                        item.token,\n                        paymentAmount,\n                        lender,\n                        renter,\n                        elapsedTime,\n                        totalTime\n                    );\n                }\n                // If its a PAY order and the rental is over, or, if its a BASE order.\n                else if (\n                    (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n                ) {\n                    // Interaction: a pay order or base order which has ended. Payout is in full.\n                    _settlePaymentInFull(\n                        item.token,\n                        paymentAmount,\n                        item.settleTo,\n                        lender,\n                        renter\n                    );\n                } else {\n                    revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Decreases the tracked token balance of a particular token on the payment\n     *      escrow contract.\n     *\n     * @param token  Token address.\n     * @param amount Amount to decrease the balance by.\n     */\n    function _decreaseDeposit(address token, uint256 amount) internal {\n        // Directly decrease the synced balance.\n        balanceOf[token] -= amount;\n    }\n\n    /**\n     * @dev Increases the tracked token balance of a particular token on the payment\n     *      escrow contract.\n     *\n     * @param token  Token address.\n     * @param amount Amount to increase the balance by.\n     */\n    function _increaseDeposit(address token, uint256 amount) internal {\n        // Directly increase the synced balance.\n        balanceOf[token] += amount;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Settles the payment for a rental order by transferring all items marked as\n     *         payments to their destination accounts. During the settlement process, if\n     *         active, a fee is taken on the payment.\n     *\n     * @param order Rental order for which to settle a payment.\n     */\n    function settlePayment(RentalOrder calldata order) external onlyByProxy permissioned {\n        // Settle all payments for the order.\n        _settlePayment(\n            order.items,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @notice Settles the payments for multiple orders by looping through each one.\n     *\n     * @param orders Rental ordesr for which to settle payments.\n     */\n    function settlePaymentBatch(\n        RentalOrder[] calldata orders\n    ) external onlyByProxy permissioned {\n        // Loop through each order.\n        for (uint256 i = 0; i < orders.length; ++i) {\n            // Settle all payments for the order.\n            _settlePayment(\n                orders[i].items,\n                orders[i].orderType,\n                orders[i].lender,\n                orders[i].renter,\n                orders[i].startTimestamp,\n                orders[i].endTimestamp\n            );\n        }\n    }\n\n    /**\n     * @notice When fungible tokens are transferred to the payment escrow contract,\n     *         their balances should be increased.\n     *\n     * @param token  Token address for the asset.\n     * @param amount Amount of the token transferred to the escrow\n     */\n    function increaseDeposit(\n        address token,\n        uint256 amount\n    ) external onlyByProxy permissioned {\n        // Cannot accept a payment of zero.\n        if (amount == 0) {\n            revert Errors.PaymentEscrow_ZeroPayment();\n        }\n\n        // Increase the deposit\n        _increaseDeposit(token, amount);\n    }\n\n    /**\n     * @notice Sets the numerator for the fee. The denominator will always be set at\n     *         10,000.\n     *\n     * @param feeNumerator Numerator of the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyByProxy permissioned {\n        // Cannot accept a fee numerator greater than 10000.\n        if (feeNumerator > 10000) {\n            revert Errors.PaymentEscrow_InvalidFeeNumerator();\n        }\n\n        // Set the fee.\n        fee = feeNumerator;\n    }\n\n    /**\n     * @notice Used to collect protocol fees. In addition, if funds are accidentally sent\n     *         to the payment escrow contract, this function can be used to skim them off.\n     *\n     * @param token Address of the token to skim.\n     * @param to    Address to send the collected tokens.\n     */\n    function skim(address token, address to) external onlyByProxy permissioned {\n        // Fetch the currently synced balance of the escrow.\n        uint256 syncedBalance = balanceOf[token];\n\n        // Fetch the true token balance of the escrow.\n        uint256 trueBalance = IERC20(token).balanceOf(address(this));\n\n        // Calculate the amount to skim.\n        uint256 skimmedBalance = trueBalance - syncedBalance;\n\n        // Send the difference to the specified address.\n        _safeTransfer(token, to, skimmedBalance);\n\n        // Emit event with fees taken.\n        emit Events.FeeTaken(token, skimmedBalance);\n    }\n\n    /**\n     * @notice Upgrades the contract to a different implementation. This implementation\n     *         contract must be compatible with ERC-1822 or else the upgrade will fail.\n     *\n     * @param newImplementation Address of the implementation contract to upgrade to.\n     */\n    function upgrade(address newImplementation) external onlyByProxy permissioned {\n        // _upgrade is implemented in the Proxiable contract.\n        _upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the contract which prevents upgrading the implementation contract.\n     *         There is no way to unfreeze once a contract has been frozen.\n     */\n    function freeze() external onlyByProxy permissioned {\n        // _freeze is implemented in the Proxiable contract.\n        _freeze();\n    }\n}"
    },
    {
      "filename": "src/modules/Storage.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\nimport {Proxiable} from \"@src/proxy/Proxiable.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {RentalId, RentalAssetUpdate} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title StorageBase\n * @notice Storage exists in its own base contract to avoid storage slot mismatch during upgrades.\n */\ncontract StorageBase {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                                Rental Storage                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Points an order hash to whether it is active.\n    mapping(bytes32 orderHash => bool isActive) public orders;\n\n    // Points an item ID to its number of actively rented tokens. This is used to\n    // determine if an item is actively rented within the protocol. For ERC721, this\n    // value will always be 1 when actively rented. Any inactive rentals will have a\n    // value of 0.\n    mapping(RentalId itemId => uint256 amount) public rentedAssets;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Deployed Safe Storage                            //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Records all safes that have been deployed by the protocol.\n    mapping(address safe => uint256 nonce) public deployedSafes;\n\n    // Records the total amount of deployed safes.\n    uint256 public totalSafes;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                                 Hook Storage                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // When interacting with the guard, any contracts that have hooks enabled\n    // should have the guard logic routed through them.\n    mapping(address to => address hook) internal _contractToHook;\n\n    // Mapping of a bitmap which denotes the hook functions that are enabled.\n    mapping(address hook => uint8 enabled) public hookStatus;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Whitelist Storage                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Allows the safe to delegate call to an approved address. For example, delegate\n    // call to a contract that would swap out an old gnosis safe module for a new one.\n    mapping(address delegate => bool isWhitelisted) public whitelistedDelegates;\n\n    // Allows for the safe registration of extensions that can be enabled on a safe.\n    mapping(address extension => bool isWhitelisted) public whitelistedExtensions;\n}\n\n/**\n * @title Storage\n * @notice Module dedicated to maintaining all the storage for the protocol. Includes\n *         storage for active rentals, deployed rental safes, hooks, and whitelists.\n */\ncontract Storage is Proxiable, Module, StorageBase {\n    using RentalUtils for address;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Module Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Instantiate this contract as a module. When using a proxy, the kernel address\n     *      should be set to address(0).\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /**\n     * @notice Instantiates this contract as a module via a proxy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    function MODULE_PROXY_INSTANTIATION(\n        Kernel kernel_\n    ) external onlyByProxy onlyUninitialized {\n        kernel = kernel_;\n        initialized = true;\n    }\n\n    /**\n     * @notice Specifies which version of a module is being implemented.\n     */\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /**\n     * @notice Defines the keycode for this module.\n     */\n    function KEYCODE() public pure override returns (Keycode) {\n        return Keycode.wrap(\"STORE\");\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                              View Functions                                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Determines if an asset is actively being rented by a wallet.\n     *\n     * @param recipient  Address of the wallet which rents the asset.\n     * @param token      Address of the token.\n     * @param identifier ID of the token.\n     */\n    function isRentedOut(\n        address recipient,\n        address token,\n        uint256 identifier\n    ) external view returns (bool) {\n        // calculate the rental ID\n        RentalId rentalId = RentalUtils.getItemPointer(recipient, token, identifier);\n\n        // Determine if there is a positive amount\n        return rentedAssets[rentalId] != 0;\n    }\n\n    /**\n     * @notice Fetches the hook address that is pointing at the the target.\n     *\n     * @param to Address which has a hook pointing to it.\n     */\n    function contractToHook(address to) external view returns (address) {\n        // Fetch the hook that the address currently points to.\n        address hook = _contractToHook[to];\n\n        // This hook may have been disabled without setting a new hook to take its place.\n        // So if the hook is disabled, then return the 0 address.\n        return hookStatus[hook] != 0 ? hook : address(0);\n    }\n\n    /**\n     * @notice Determines whether the `onTransaction()` function is enabled for the hook.\n     *\n     * @param hook Address of the hook contract.\n     */\n    function hookOnTransaction(address hook) external view returns (bool) {\n        // 1 is 0x00000001. Determines if the masked bit is enabled.\n        return (uint8(1) & hookStatus[hook]) != 0;\n    }\n\n    /**\n     * @notice Determines whether the `onStart()` function is enabled for the hook.\n     *\n     * @param hook Address of the hook contract.\n     */\n    function hookOnStart(address hook) external view returns (bool) {\n        // 2 is 0x00000010. Determines if the masked bit is enabled.\n        return uint8(2) & hookStatus[hook] != 0;\n    }\n\n    /**\n     * @notice Determines whether the `onStop()` function is enabled for the hook.\n     *\n     * @param hook Address of the hook contract.\n     */\n    function hookOnStop(address hook) external view returns (bool) {\n        // 4 is 0x00000100. Determines if the masked bit is enabled.\n        return uint8(4) & hookStatus[hook] != 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Adds an order hash to storage. Once an order hash is added to storage,\n     *         the assets contained within are considered actively rented. Additionally,\n     *         rental asset IDs are added to storage which creates a blocklist on those\n     *         assets. When the blocklist is active, the protocol guard becomes active on\n     *         them and prevents transfer or approval of the assets by the owner of the\n     *         safe.\n     *\n     * @param orderHash          Hash of the rental order which is added to storage.\n     * @param rentalAssetUpdates Asset update structs which are added to storage.\n     */\n    function addRentals(\n        bytes32 orderHash,\n        RentalAssetUpdate[] memory rentalAssetUpdates\n    ) external onlyByProxy permissioned {\n        // Add the order to storage.\n        orders[orderHash] = true;\n\n        // Add the rented items to storage.\n        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n            // Update the order hash for that item.\n            rentedAssets[asset.rentalId] += asset.amount;\n        }\n    }\n\n    /**\n     * @notice Removes an order hash from storage. Once an order hash is removed from\n     *         storage, it can no longer be stopped since the protocol will have no\n     *         record of the order. Addtionally, rental asset IDs are removed from\n     *         storage. Once these hashes are removed, they are no longer blocklisted\n     *         from being transferred out of the rental wallet by the owner.\n     *\n     * @param orderHash          Hash of the rental order which will be removed from\n     *                           storage.\n     * @param rentalAssetUpdates Asset update structs which will be removed from storage.\n     */\n    function removeRentals(\n        bytes32 orderHash,\n        RentalAssetUpdate[] calldata rentalAssetUpdates\n    ) external onlyByProxy permissioned {\n        // The order must exist to be deleted.\n        if (!orders[orderHash]) {\n            revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n        } else {\n            // Delete the order from storage.\n            delete orders[orderHash];\n        }\n\n        // Process each rental asset.\n        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n            // Reduce the amount of tokens for the particular rental ID.\n            rentedAssets[asset.rentalId] -= asset.amount;\n        }\n    }\n\n    /**\n     * @notice Behaves the same as `removeRentals()`, except that orders are processed in\n     *          a loop.\n     *\n     * @param orderHashes        All order hashes which will be removed from storage.\n     * @param rentalAssetUpdates Asset update structs which will be removed from storage.\n     */\n    function removeRentalsBatch(\n        bytes32[] calldata orderHashes,\n        RentalAssetUpdate[] calldata rentalAssetUpdates\n    ) external onlyByProxy permissioned {\n        // Delete the orders from storage.\n        for (uint256 i = 0; i < orderHashes.length; ++i) {\n            // The order must exist to be deleted.\n            if (!orders[orderHashes[i]]) {\n                revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n            } else {\n                // Delete the order from storage.\n                delete orders[orderHashes[i]];\n            }\n        }\n\n        // Process each rental asset.\n        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n            // Reduce the amount of tokens for the particular rental ID.\n            rentedAssets[asset.rentalId] -= asset.amount;\n        }\n    }\n\n    /**\n     * @notice Adds the addresss of a rental safe to storage so that protocol-deployed\n     *         rental safes can be distinguished from those deployed elsewhere.\n     *\n     * @param safe Address of the rental safe to add to storage.\n     */\n    function addRentalSafe(address safe) external onlyByProxy permissioned {\n        // Get the new safe count.\n        uint256 newSafeCount = totalSafes + 1;\n\n        // Register the safe as deployed.\n        deployedSafes[safe] = newSafeCount;\n\n        // Increment nonce.\n        totalSafes = newSafeCount;\n    }\n\n    /**\n     * @notice Connects a hook to a destination address. Once an active path is made,\n     *         any transactions originating from a rental safe to the target address\n     *         will use a hook as middleware. The hook chosen is determined by the path\n     *         set.\n     *\n     * @param to   Target address which will use a hook as middleware.\n     * @param hook Address of the hook which will act as a middleware.\n     */\n    function updateHookPath(address to, address hook) external onlyByProxy permissioned {\n        // Require that the `to` address is a contract.\n        if (to.code.length == 0) revert Errors.StorageModule_NotContract(to);\n\n        // Require that the `hook` address is a contract.\n        if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n\n        // Point the `to` address to the `hook` address.\n        _contractToHook[to] = hook;\n    }\n\n    /**\n     * @notice Updates a hook with a bitmap that indicates its active functionality.\n     *         A valid bitmap is any decimal value that is less than or equal\n     *         to 7 (0x111).\n     *\n     * @param hook   Address of the hook contract.\n     * @param bitmap Decimal value that defines the active functionality on the hook.\n     */\n    function updateHookStatus(\n        address hook,\n        uint8 bitmap\n    ) external onlyByProxy permissioned {\n        // Require that the `hook` address is a contract.\n        if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n\n        // 7 is 0x00000111. This ensures that only a valid bitmap can be set.\n        if (bitmap > uint8(7))\n            revert Errors.StorageModule_InvalidHookStatusBitmap(bitmap);\n\n        // Update the status of the hook.\n        hookStatus[hook] = bitmap;\n    }\n\n    /**\n     * @notice Toggles whether an address can be delegate called.\n     *\n     * @param delegate  Address which can be delegate called.\n     * @param isEnabled Boolean indicating whether the address is enabled.\n     */\n    function toggleWhitelistDelegate(\n        address delegate,\n        bool isEnabled\n    ) external onlyByProxy permissioned {\n        whitelistedDelegates[delegate] = isEnabled;\n    }\n\n    /**\n     * @notice Toggles whether an extension is whitelisted.\n     *\n     * @param extension Gnosis safe module which can be added to a rental safe.\n     * @param isEnabled Boolean indicatingwhether the module is enabled.\n     */\n    function toggleWhitelistExtension(\n        address extension,\n        bool isEnabled\n    ) external onlyByProxy permissioned {\n        whitelistedExtensions[extension] = isEnabled;\n    }\n\n    /**\n     * @notice Upgrades the contract to a different implementation. This implementation\n     *         contract must be compatible with ERC-1822 or else the upgrade will fail.\n     *\n     * @param newImplementation Address of the implementation contract to upgrade to.\n     */\n    function upgrade(address newImplementation) external onlyByProxy permissioned {\n        // _upgrade is implemented in the Proxiable contract.\n        _upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the contract which prevents upgrading the implementation contract.\n     *         There is no way to unfreeze once a contract has been frozen.\n     */\n    function freeze() external onlyByProxy permissioned {\n        // _freeze is implemented in the Proxiable contract.\n        _freeze();\n    }\n}"
    },
    {
      "filename": "src/modules/Storage.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\nimport {Proxiable} from \"@src/proxy/Proxiable.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {RentalId, RentalAssetUpdate} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title StorageBase\n * @notice Storage exists in its own base contract to avoid storage slot mismatch during upgrades.\n */\ncontract StorageBase {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                                Rental Storage                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Points an order hash to whether it is active.\n    mapping(bytes32 orderHash => bool isActive) public orders;\n\n    // Points an item ID to its number of actively rented tokens. This is used to\n    // determine if an item is actively rented within the protocol. For ERC721, this\n    // value will always be 1 when actively rented. Any inactive rentals will have a\n    // value of 0.\n    mapping(RentalId itemId => uint256 amount) public rentedAssets;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Deployed Safe Storage                            //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Records all safes that have been deployed by the protocol.\n    mapping(address safe => uint256 nonce) public deployedSafes;\n\n    // Record"
    }
  ]
}