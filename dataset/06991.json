{
  "Title": "[M-07] DOMAIN_SEPARATOR() is missing in LUSDToken.sol",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/LUSDToken.sol#L28\n\n\n# Vulnerability details\n\n## Impact\nThe DOMAIN_SEPARATOR() function in ERC2612 is an important part of the security of the standard. It is used to prevent replay attacks, which occur when a malicious user records a valid signed message and later sends it again to fraudulently perform an action on behalf of the original signer.\n\nThe DOMAIN_SEPARATOR() is generated based on specific contract parameters, including the contract's address, the chain ID, and a unique identifier. These parameters ensure that the domain separator is unique to the contract and the chain, and prevent attackers from using the same signature on a different chain or contract.\n\nIf the DOMAIN_SEPARATOR() function is missing from ERC2612, it can significantly impact the security of the standard. It can make it easier for attackers to replay valid signatures, since the domain separator provides a crucial part of the uniqueness and security of the signature.\n\nTherefore, it's important to ensure that the DOMAIN_SEPARATOR() function is included and properly implemented in any contract that uses ERC2612.\n\n## Proof of Concept\nOutput form slither:\n\n```solidity\n# Check LUSDToken\n\n## Check functions\n[✓] permit(address,address,uint256,uint256,uint8,bytes32,bytes32) is present\n        [✓] permit(address,address,uint256,uint256,uint8,bytes32,bytes32) -> () (correct return type)\n[✓] nonces(address) is present\n        [✓] nonces(address) -> (uint256) (correct return type)\n        [✓] nonces(address) is view\n[ ] DOMAIN_SEPARATOR() is missing\n[✓] totalSupply() is present\n        [✓] totalSupply() -> (uint256) (correct return type)\n        [✓] totalSupply() is view\n[✓] balanceOf(address) is present\n        [✓] balanceOf(address) -> (uint256) (correct return type)\n        [✓] balanceOf(address) is view\n[✓] transfer(address,uint256) is present\n        [✓] transfer(address,uint256) -> (bool) (correct return type)\n        [✓] Transfer(address,address,uint256) is emitted\n[✓] transferFrom(address,address,uint256) is present\n        [✓] transferFrom(address,address,uint256) -> (bool) (correct return type)\n        [✓] Transfer(address,address,uint256) is emitted\n[✓] approve(address,uint256) is present\n        [✓] approve(address,uint256) -> (bool) (correct return type)\n        [✓] Approval(address,address,uint256) is emitted\n[✓] allowance(address,address) is present\n        [✓] allowance(address,address) -> (uint256) (correct return type)\n        [✓] allowance(address,address) is view\n[✓] name() is present\n        [✓] name() -> (string) (correct return type)\n        [✓] name() is view\n[✓] symbol() is present\n        [✓] symbol() -> (string) (correct return type)\n        [✓] symbol() is view\n[✓] decimals() is present\n        [✓] decimals() -> (uint8) (correct return type)\n        [✓] decimals() is view\n    )\n```\n\n## Tools Used\nVS Code, Slither\n\n## Recommended Mitigation Steps\nTo mitigate this risk, it is recommended to follow the ERC2612 specification strictly and ensure that the DOMAIN_SEPARATOR is correctly implemented. ",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Core/contracts/LUSDToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/ILUSDToken.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\n/*\n*\n* Based upon OpenZeppelin's ERC20 contract:\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n*  \n* and their EIP2612 (ERC20Permit / ERC712) functionality:\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\n* \n*\n* --- Functionality added specific to the LUSDToken ---\n* \n* 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external \n* transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending LUSD directly to a Liquity \n* core contract, when they should rather call the right function. \n*\n* 2) sendToPool() and returnFromPool(): functions callable only Liquity core contracts, which move LUSD tokens between Liquity <-> user.\n*/\n\ncontract LUSDToken is CheckContract, ILUSDToken {\n    using SafeMath for uint256;\n    \n    uint256 private _totalSupply;\n    string constant internal _NAME = \"LUSD Stablecoin\";\n    string constant internal _SYMBOL = \"LUSD\";\n    string constant internal _VERSION = \"1\";\n    uint8 constant internal _DECIMALS = 18;\n\n    bool public mintingPaused = false;\n    \n    // --- Data for EIP2612 ---\n    \n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant _TYPE_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    \n    mapping (address => uint256) private _nonces;\n    \n    // User data for LUSD token\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;  \n    \n    // --- Addresses ---\n    // mappings store addresses of old versions so they can still burn (close troves)\n    mapping (address => bool) public troveManagers;\n    mapping (address => bool) public stabilityPools;\n    mapping (address => bool) public borrowerOperations;\n    // simple address variables track current version that can mint (in addition to burning)\n    // this design makes it so that only the latest version can open troves\n    address public troveManagerAddress;\n    address public stabilityPoolAddress;\n    address public borrowerOperationsAddress;\n    address public governanceAddress; // can pause/unpause minting and upgrade addresses\n    address public guardianAddress; // can pause minting during emergency\n\n    // Copied from LQTYToken.sol; since we deleted that file, we use LUSDToken's initialization\n    // to mark system deployment start time\n    uint internal immutable deploymentStartTime;\n    \n    // --- Events ---\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event GovernanceAddressChanged(address _governanceAddress);\n    event GuardianAddressChanged(address _guardianAddress);\n\n    constructor\n    ( \n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        address _governanceAddress,\n        address _guardianAddress\n    ) \n        public \n    {  \n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        // must be a smart contract (multi-sig, timelock, etc.)\n        checkContract(_governanceAddress);\n        checkContract(_guardianAddress);\n\n        troveManagerAddress = _troveManagerAddress;\n        troveManagers[_troveManagerAddress] = true;\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        stabilityPoolAddress = _stabilityPoolAddress;\n        stabilityPools[_stabilityPoolAddress] = true;\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        borrowerOperations[_borrowerOperationsAddress] = true;\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        governanceAddress = _governanceAddress;\n        emit GovernanceAddressChanged(_governanceAddress);\n\n        guardianAddress = _guardianAddress;\n        emit GuardianAddressChanged(_guardianAddress);\n        \n        bytes32 hashedName = keccak256(bytes(_NAME));\n        bytes32 hashedVersion = keccak256(bytes(_VERSION));\n        \n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _chainID();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);\n\n        deploymentStartTime = block.timestamp;\n    }\n\n    // --- Governance operations ---\n\n    function pauseMinting() external {\n        require(\n            msg.sender == guardianAddress || msg.sender == governanceAddress,\n            \"LUSD: Caller is not guardian or governance\"\n        );\n        mintingPaused = true;\n    }\n\n    function unpauseMinting() external {\n        _requireCallerIsGovernance();\n        mintingPaused = false;\n    }\n\n    function updateGovernance(address _newGovernanceAddress) external {\n        _requireCallerIsGovernance();\n        checkContract(_newGovernanceAddress); // must be a smart contract (multi-sig, timelock, etc.)\n        governanceAddress = _newGovernanceAddress;\n        emit GovernanceAddressChanged(_newGovernanceAddress);\n    }\n\n    function updateGuardian(address _newGuardianAddress) external {\n        _requireCallerIsGovernance();\n        checkContract(_newGuardianAddress); // must be a smart contract (multi-sig, timelock, etc.)\n        guardianAddress = _newGuardianAddress;\n        emit GuardianAddressChanged(_newGuardianAddress);\n    }\n\n    function upgradeProtocol(\n        address _newTroveManagerAddress,\n        address _newStabilityPoolAddress,\n        address _newBorrowerOperationsAddress\n    ) external {\n        _requireCallerIsGovernance();\n        checkContract(_newTroveManagerAddress);\n        checkContract(_newStabilityPoolAddress);\n        checkContract(_newBorrowerOperationsAddress);\n\n        troveManagerAddress = _newTroveManagerAddress;\n        troveManagers[_newTroveManagerAddress] = true;\n        emit TroveManagerAddressChanged(_newTroveManagerAddress);\n\n        stabilityPoolAddress = _newStabilityPoolAddress;\n        stabilityPools[_newStabilityPoolAddress] = true;\n        emit StabilityPoolAddressChanged(_newStabilityPoolAddress);\n\n        borrowerOperationsAddress = _newBorrowerOperationsAddress;\n        borrowerOperations[_newBorrowerOperationsAddress] = true;\n        emit BorrowerOperationsAddressChanged(_newBorrowerOperationsAddress);\n    }\n\n    // --- Functions for intra-Liquity calls ---\n\n    function mint(address _account, uint256 _amount) external override {\n        _requireMintingNotPaused();\n        _requireCallerIsBorrowerOperations();\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        _burn(_account, _amount);\n    }\n\n    function sendToPool(address _sender,  address _poolAddress, uint256 _amount) external override {\n        _requireCallerIsStabilityPool();\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {\n        _requireCallerIsTroveMorSP();\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    function getDeploymentStartTime() external view override returns (uint256) {\n        return deploymentStartTime;\n    }\n\n    // --- External functions ---\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    // --- EIP 2612 Functionality ---\n\n    function domainSeparator() public view override returns (bytes32) {    \n        if (_chainID() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function permit\n    (\n        address owner, \n        address spender, \n        uint amount, \n        uint deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s\n    ) \n        external \n        override \n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert('LUSD: Invalid s value');\n        }\n        require(deadline >= now, 'LUSD: expired deadline');\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', \n                         domainSeparator(), keccak256(abi.encode(\n                         _PERMIT_TYPEHASH, owner, spender, amount, \n                         _nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == owner, 'LUSD: invalid signature');\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) external view override returns (uint256) { // FOR EIP 2612\n        return _nonces[owner];\n    }\n\n    // --- Internal operations ---\n\n    function _chainID() private pure returns (uint256 chainID) {\n        assembly {\n            chainID := chainid()\n        }\n    }\n    \n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));\n    }\n\n    // --- Internal operations ---\n    // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        assert(sender != address(0));\n        assert(recipient != address(0));\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        assert(account != address(0));\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        assert(account != address(0));\n        \n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        assert(owner != address(0));\n        assert(spender != address(0));\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && \n            _recipient != address(this),\n            \"LUSD: Cannot transfer tokens directly to the LUSD token contract or the zero address\"\n        );\n        require(\n            !stabilityPools[_recipient] &&\n            !troveManagers[_recipient] &&\n            !borrowerOperations[_recipient],\n            \"LUSD: Cannot transfer tokens directly to the StabilityPool, TroveManager or BorrowerOps\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        // only latest borrowerOps version can mint\n        require(msg.sender == borrowerOperationsAddress, \"LUSDToken: Caller is not BorrowerOperations\");\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        // old versions of the protocol may still burn\n        require(\n            troveManagers[msg.sender] ||\n            stabilityPools[msg.sender] ||\n            borrowerOperations[msg.sender],\n            \"LUSD: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        // only latest stabilityPool can accept new deposits\n        require(msg.sender == stabilityPoolAddress, \"LUSD: Caller is not the StabilityPool\");\n    }\n\n    function _requireCallerIsTroveMorSP() internal view {\n        // old versions of the protocol may still:\n        // 1. send lusd gas reserve to liquidator\n        // 2. be able to return users their lusd from the stability pool\n        require(\n            troveManagers[msg.sender] || stabilityPools[msg.sender],\n            \"LUSD: Caller is neither TroveManager nor StabilityPool\");\n    }\n\n    function _requireCallerIsGovernance() internal view {\n        require(msg.sender == governanceAddress, \"LUSDToken: Caller is not Governance\");\n    }\n\n    function _requireMintingNotPaused() internal view {\n        require(!mintingPaused, \"LUSDToken: Minting is currently paused\");\n    }\n\n    // --- Optional functions ---\n\n    function name() external view override returns (string memory) {\n        return _NAME;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _SYMBOL;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _DECIMALS;\n    }\n\n    function version() external view override returns (string memory) {\n        return _VERSION;\n    }\n\n    function permitTypeHash() external view override returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n}"
    }
  ]
}