{
  "Title": "[C01] Governance restrictions can be bypassed",
  "Content": "**Update:** *Fixed in pull requests [#76](https://github.com/endaoment/endaoment-contracts/pull/76) and [#77](https://github.com/endaoment/endaoment-contracts/pull/77). The Endaoment team created a new [`EndaomentAdminStorage`](https://github.com/endaoment/endaoment-contracts/blob/master/contracts/EndaomentAdminStorage.sol) contract that keeps track of the current `EndaomentAdmin` implementation saved in the [`endaomentAdmin` parameter](https://github.com/endaoment/endaoment-contracts/blob/master/contracts/EndaomentAdminStorage.sol#L16). This contract extends from the`Administratable` one and also provides a restricted method to eventually change the address of the implementation. The factories [now extend](https://github.com/endaoment/endaoment-contracts/blob/master/contracts/FundFactory.sol#L15) from such contract and their addresses are stored in the `Fund` and `Org` contract whenever a new one is created. In this way the `endaomentAdmin` of both factories is passed as input parameter in the `Administratable` modifiers whenever a restricted function of the `Fund` or `Org` contract is called. It has to be noticed that, before interacting with the system, the correct roles must be set in the `EndaomentAdmin` contract configured in the `EndaomentAdminStorage` one. Even if this fixes the issue, an address is still passed as input parameter in the `Administratable` modifiers and a new contract has been generated, slightly increasing the gas cost.*\n\n\nThe entire system relies on the [`EndaomentAdmin`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/EndaomentAdmin.sol#L107) contract to restrict access to functions and to separate user roles.  \n\nThe creator of the `EndaomentAdmin` contract is the one in charge of setting specific roles to addresses.\n\n\nThe [`Fund`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol), [`FundFactory`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/FundFactory.sol), [`Org`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol), and [`OrgFactory`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol) contracts all extend from the [`Administratable` contract](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol).  \n\nThe `Administratable` contract defines the [`onlyAdmin`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol#L17) and [`onlyAdminOrRole`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Administratable.sol#L30) modifiers, used to restrict function calls in the derived contracts.  \n\nThese modifiers receive the `adminContractAddress` as input parameter and use it to instantiate the governance contract `EndaomentAdmin`.  \n\nThey then ask to the `EndaomentAdmin` contract at the specified address if the `msg.sender` has the proper rights and it eventually reverts if itâ€™s not the case.\n\n\nThe issue is that all the functions making use of these modifiers are `public` and receive an arbitrary `adminContractAddress` as input parameter.  \n\nFunctions restricted by the `onlyAdminOrRole` modifier are:\n\n\n* [`changeManager`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L62), [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119) of the `Fund` contract.\n* [`createFund`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/FundFactory.sol#L36) of the `FundFactory` contract.\n* [`approveClaim`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L79), [`cashOutOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L91) and [`setOrgWallet`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L99) of the `Org` contract.\n* [`createOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L36) of the `OrgFactory` contract.\n\n\nWhile the `onlyAdmin` modifier is exclusively used to protect `FundFactory` and `OrgFactory` constructors.\n\n\nThis opens the doors for the following attack:\n\n\n* Alice deploys her own `EndaomentAdmin` contract and sets her address as having full access (i.e. by setting every role to her address).\n* She can now call any of the restricted functions listed above or deploy new factories, passing the address of her malicious `EndaomentAdmin` contract as `adminContractAddress` in the function call parameters.\n\n\nThere are several ways now Alice can benefit from this scenario by just using the malicious `adminContractAddress`:\n\n\n* Every `Org` contract instance, if it has been deployed by the `OrgFactory`, would result in an [`allowed` organization](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L39). The `createGrant` function of the `Fund` contract [checks allowed organizations](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L101) calling the [`checkRecipient` function](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L71). Alice can:\n* Create a malicious `Org` contract by calling the [`createOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/OrgFactory.sol#L36) function of the `OrgFactory` contract making it an allowed organization.\n* Change the manager of a `Fund` contract setting her address instead, by calling the [`changeManager`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L62) function .\n* Call the [`createGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L100) function which has the `restricted` modifier ensuring that the `msg.sender == manager`. She will bypass the `require` statement in line [`101`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L101) and successfully create a grant to her malicious organization.\n* She can also finalize any grant moving out of the contract the funds needed to cover it by calling the [`finalizeGrant`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Fund.sol#L119) function. Together with the previous scenario, she can definitely steal all the funds from the contract.\n* Once every fund is transferred out to the malicious organization she can cash out everything by calling the [`cashOutOrg`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L91) function of the  \n\n`Org` factory.\n* She can finally change the [`orgWallet`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L32) of any of the deployed `Org` contracts by calling the [`setOrgWallet`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L99) function or approve any arbitrary malicious claim by calling the [`approveClaim`](https://github.com/endaoment/endaoment-contracts/blob/f60aa253d3d869ad6460877f23e6092acb313add/contracts/Org.sol#L79) function.\n\n\nMoreover, all the constructors of the cited contracts are protected by both modifiers, where the `adminContractAddress` is passed as constructor parameter. Since these modifiers can be skipped, the constructors of the factories and of `Fund` and `Org` contracts can be easily called.\n\n\nTo solve the issue consider doing the following:\n\n\n* Set the current implementation of the `EndaomentAdmin` contract in the constructor of the `Administratable` contract whenever it is called by the derived contract constructors. Save it as state variable.\n* Remove the `adminContractAddress` input parameter from any function making use of it and from the modifier definitions.\n* Change the modifier implementations to ask directly to the previously set `EndaomentAdmin` contract for `msg.sender` roles.\n* Implement an auxiliary function, with restricted access, to change, eventually, the address of the correct `EndaomentAdmin` implementation.\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/EndaomentAdmin.sol",
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./interfaces/IEndaomentAdmin.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n *\n * In order to transfer ownership, a recipient must be specified, at which point\n * the specified recipient can call `acceptOwnership` and take ownership.\n */\ncontract TwoStepOwnable {\n  address private _owner;\n  address private _newPotentialOwner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n \n  event TransferInitiated(\n    address indexed newOwner\n  );\n  \n  event TransferCancelled(\n    address indexed newPotentialOwner\n  );\n\n  /**\n   * @dev Initialize contract by setting transaction submitter as initial owner.\n   */\n  constructor() internal {\n    _owner = tx.origin;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function getOwner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\n    _;\n  }\n\n  /**\n   * @dev Returns true if the caller is the current owner.\n   */\n  function isOwner() public view returns (bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Allows a new account (`newOwner`) to accept ownership.\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(\n      newOwner != address(0),\n      \"TwoStepOwnable: new potential owner is the zero address.\"\n    );\n\n    _newPotentialOwner = newOwner;\n    emit TransferInitiated(address(newOwner));\n  }\n\n  /**\n   * @dev Cancel a transfer of ownership to a new account.\n   * Can only be called by the current owner.\n   */\n  function cancelOwnershipTransfer() public onlyOwner {\n    emit TransferCancelled(address(_newPotentialOwner));\n    delete _newPotentialOwner;\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to the caller.\n   * Can only be called by a new potential owner set by the current owner.\n   */\n  function acceptOwnership() public {\n    require(\n      msg.sender == _newPotentialOwner,\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\n    );\n\n    delete _newPotentialOwner;\n\n    emit OwnershipTransferred(_owner, msg.sender);\n\n    _owner = msg.sender;\n  }\n}\n\ncontract EndaomentAdmin is IEndaomentAdmin, TwoStepOwnable {\n  // Maintain a role status mapping with assigned accounts and paused states.\n  mapping(uint256 => RoleStatus) private _roles;\n  \n  /**\n   * @notice Set a new account on a given role and emit a `RoleModified` event\n   * if the role holder has changed. Only the owner may call this function.\n   * @param role The role that the account will be set for.\n   * @param account The account to set as the designated role bearer.\n   */\n  function setRole(Role role, address account) public override onlyOwner {\n    require(account != address(0), \"Must supply an account.\");\n    _setRole(role, account);\n  }\n\n  /**\n   * @notice Remove any current role bearer for a given role and emit a\n   * `RoleModified` event if a role holder was previously set. Only the owner\n   * may call this function.\n   * @param role The role that the account will be removed from.\n   */\n  function removeRole(Role role) public override onlyOwner {\n    _setRole(role, address(0));\n  }\n  \n  /**\n   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\n   * the owner or the designated pauser may call this function. Also, bear in\n   * mind that only the owner may unpause a role once paused.\n   * @param role The role to pause.\n   */\n  function pause(Role role) public override onlyAdminOr(Role.PAUSER) {\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n    require(!storedRoleStatus.paused, \"Role in question is already paused.\");\n    storedRoleStatus.paused = true;\n    emit RolePaused(role);\n  }\n\n  /**\n   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\n   * Only the owner may call this function.\n   * @param role The role to pause.\n   */\n  function unpause(Role role) public override onlyOwner {\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n    require(storedRoleStatus.paused, \"Role in question is already unpaused.\");\n    storedRoleStatus.paused = false;\n    emit RoleUnpaused(role);\n  }\n  \n  /**\n   * @notice External view function to check whether or not the functionality\n   * associated with a given role is currently paused or not. The owner or the\n   * pauser may pause any given role (including the pauser itself), but only the\n   * owner may unpause functionality. Additionally, the owner may call paused\n   * functions directly.\n   * @param role The role to check the pause status on.\n   * @return paused A boolean to indicate if the functionality associated with\n   * the role in question is currently paused.\n   */\n  function isPaused(Role role) public override view returns (bool paused) {\n    paused = _isPaused(role);\n  }\n\n  /**\n   * @notice External view function to check whether the caller is the current\n   * role holder.\n   * @param role The role to check for.\n   * @return hasRole A boolean indicating if the caller has the specified role.\n   */\n  function isRole(Role role) public override view returns (bool hasRole) {\n    hasRole = _isRole(role);\n  }\n\n  /**\n   * @notice External view function to check the account currently holding the\n   * given role.\n   * @return roleAddress The address of the current admin, or the null\n   * address if none is set.\n   */\n  function getRoleAddress(Role role) public override view returns (address roleAddress) {\n    require(_roles[uint256(role)].account != address(0));\n    roleAddress = _roles[uint256(role)].account;\n  }\n\n  /**\n   * @notice Private function to set a new account on a given role and emit a\n   * `RoleModified` event if the role holder has changed.\n   * @param role The role that the account will be set for.\n   * @param account The account to set as the designated role bearer.\n   */\n  function _setRole(Role role, address account) private {\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n\n    if (account != storedRoleStatus.account) {\n      storedRoleStatus.account = account;\n      emit RoleModified(role, account);\n    }\n  }\n\n  /**\n   * @notice Private view function to check whether the caller is the current\n   * role holder.\n   * @param role The role to check for.\n   * @return hasRole A boolean indicating if the caller has the specified role.\n   */\n  function _isRole(Role role) private view returns (bool hasRole) {\n    hasRole = msg.sender == _roles[uint256(role)].account;\n  }\n\n  /**\n   * @notice Private view function to check whether the given role is paused or\n   * not.\n   * @param role The role to check for.\n   * @return paused A boolean indicating if the specified role is paused or not.\n   */\n  function _isPaused(Role role) private view returns (bool paused) {\n    paused = _roles[uint256(role)].paused;\n  }\n  \n    /**\n   * @notice Modifier that throws if called by any account other than the owner\n   * or the supplied role, or if the caller is not the owner and the role in\n   * question is paused.\n   * @param role The role to require unless the caller is the owner. Permitted\n   * roles are bot commander (0) and pauser (1).\n   */\n  modifier onlyAdminOr(Role role) {\n    if (!isOwner()) {\n      require(_isRole(role), \"Caller does not have a required role.\");\n      require(!_isPaused(role), \"Role in question is currently paused.\");\n    }\n    _;\n  }\n\n}"
    },
    {
      "filename": "contracts/Administratable.sol",
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./EndaomentAdmin.sol\";\n\n/**\n * @dev Provides a of modifiers allowing contracts administered\n * by the EndaomentAdmin contract to properly restrict method calls\n * based on the a given role. \n */\ncontract Administratable {\n    /**\n        * @notice onlyAdmin checks that the caller is the EndaomentAdmin\n        * @param adminContractAddress is the supplied EndaomentAdmin contract address\n        */\n    modifier onlyAdmin(address adminContractAddress) {\n        EndaomentAdmin endaomentAdmin = EndaomentAdmin(adminContractAddress);\n        \n        require(msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN), \"Only ADMIN can access.\");\n        _;\n    }\n    \n    /**\n    * @notice onlyAdminOrRole checks that the caller is either the Admin or the provided role.\n    * @param adminContractAddress supplied EndaomentAdmin address\n    * @param role The role to require unless the caller is the owner. Permitted\n    * roles are admin (0), accountant (2), and reviewer (3).\n    */     \n    modifier onlyAdminOrRole(address adminContractAddress, IEndaomentAdmin.Role role) {\n        EndaomentAdmin endaomentAdmin = EndaomentAdmin(adminContractAddress);\n        \n        if (msg.sender != endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN)) {\n            if (!endaomentAdmin.isPaused(role)) {\n                    if (role == IEndaomentAdmin.Role.ACCOUNTANT) {\n                        require(msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ACCOUNTANT), \"Only ACCOUNTANT can access\");\n                    }\n                    if (role == IEndaomentAdmin.Role.REVIEWER) {\n                        require(msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.REVIEWER), \"Only REVIEWER can access\");\n                    }\n                    if (role == IEndaomentAdmin.Role.FUND_FACTORY) {\n                        require(msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.FUND_FACTORY), \"Only FUND_FACTORY can access\");\n                    }\n                    if (role == IEndaomentAdmin.Role.ORG_FACTORY) {\n                        require(msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ORG_FACTORY), \"Only ORG_FACTORY can access\");\n                    }\n            } else {\n                require(msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN), \"Only ADMIN can access\");\n            }\n        } else {\n            require(msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN), \"Only ADMIN can access\");\n        }\n    _;\n    }\n}"
    },
    {
      "filename": "contracts/Fund.sol",
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./Administratable.sol\";\nimport \"./OrgFactory.sol\";\n\n// FUND CONTRACT\n/**\n * @title Fund\n * @author rheeger\n * @notice Fund is a contract that serves as an on-chain US Donor-Advised Fund.\n * It holds the proceeds of gifted cryptocurrency as ERC20 tokens, \n * and allows for the manager to submit Grant reccomendations to the contract. \n * The EndaomentAdmin can then chose to approve the Grant reccomendation, triggering\n * a SafeMath transfer of a 1% fee to the EndaomentAdmin and the remainder to the \n * recipient Org contract.\n */\ncontract Fund is Administratable {\n    using SafeMath for uint256;\n\n// ========== STATE VARIABLES ==========\n    struct Grant {\n        string description;\n        uint value;\n        address recipient;\n        bool complete;\n    }\n\n    address public manager;\n    address public admin;\n    mapping(address => bool) public contributors;\n    Grant[] public grants;\n    uint public totalContributors;\n\n// ========== CONSTRUCTOR ==========\n    /**\n    * @notice Create new Fund\n    * @param creator Address of the Fund's Primary Advisor\n    * @param adminContractAddress Address of the EndaomentAdmin contract.\n    */\n    constructor (address creator, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.FUND_FACTORY){\n        require(creator != address(0));\n        manager = creator;\n    }\n\n// ========== Admin Management ==========\n    /**\n    * @notice Restricts method access to fund's manager\n    */\n    modifier restricted() {\n      require(msg.sender == manager);\n      _;\n    }\n\n// ========== Fund Management & Info ==========\n    /**\n    * @notice Change Fund Primary Advisor\n    * @param  newManager The address of the new PrimaryAdvisor.\n    * @param  adminContractAddress Address of the EndaomentAdmin contract.\n    */\n    function changeManager (address newManager, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.REVIEWER){\n        manager = newManager;\n    }\n\n    /**\n    * @notice Checks recipient of a Grant is an address created by the OrgFactory \n    * @param  recipient The address of the Grant recipient.\n    * @param  orgFactoryContractAddress Address of the OrgFactory contract.\n    */\n    function checkRecipient(address recipient, address orgFactoryContractAddress) public view returns (bool) {\n        OrgFactory x = OrgFactory ( orgFactoryContractAddress );\n\n        return x.getAllowedOrg(recipient);\n    }\n\n    /**\n    * @notice Returns summary of details about the fund [tokenBalance, ethBlance, number of grants, managerAddress]. \n    * @param  tokenAddress The token address of the stablecoin being used by the web-server.\n    */\n    function getSummary(address tokenAddress) public view returns (uint, uint, uint, address) {\n        ERC20 t = ERC20(tokenAddress);\n        uint bal = t.balanceOf(address(this));\n\n        return (\n            bal,\n            address(this).balance,\n            grants.length,\n            manager\n        );\n    }\n\n    /**\n    * @notice Create new Grant Reccomendation\n    * @param  description The address of the Owner.\n    * @param  value The value of the grant in base units.\n    * @param  recipient The address of the recieving organization's contract.\n    * @param  orgFactoryContractAddress Address of the orgFactory Contract.\n    */\n    function createGrant(string memory description, uint256 value, address recipient, address orgFactoryContractAddress) public restricted {\n        require(checkRecipient(recipient, orgFactoryContractAddress) == true);\n\n        Grant memory newGrant = Grant({\n            description: description,\n            value: value,\n            recipient: recipient,\n            complete: false\n        });\n\n        grants.push(newGrant);\n    }\n\n    /**\n    * @notice Approve Grant Reccomendation\n    * @param  index This Grant's index position\n    * @param  tokenAddress The stablecoin's token address.\n    * @param  adminContractAddress Address of the EndaomentAdmin contract.\n    */\n    function finalizeGrant(uint index, address tokenAddress, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.ACCOUNTANT){\n        EndaomentAdmin endaomentAdmin = EndaomentAdmin(adminContractAddress);\n        admin = endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN);\n        Grant storage grant = grants[index];\n        require(grant.complete == false);\n        ERC20 t = ERC20(tokenAddress);\n\n        //Process fees:\n        uint256 fee = (grant.value)/100;\n        uint256 finalGrant = (grant.value * 99)/100;\n        t.transfer(admin, fee);\n\n        t.transfer(grant.recipient, finalGrant);\n\n        grant.complete = true;\n    }\n\n    /**\n    * @notice Returns total number of grants submitted to the fund. \n    */\n    function getGrantsCount() public view returns (uint) {\n        return grants.length;\n    }\n}"
    },
    {
      "filename": "contracts/FundFactory.sol",
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./Administratable.sol\";\nimport \"./OrgFactory.sol\";\nimport \"./Fund.sol\";\n\n// FUND FACTORY CONTRACT\n/**\n * @title FundFactory\n * @author rheeger\n * @notice FundFactory is a contract that allows the EndaomentAdmin to \n * instantiate new Fund contracts. It also provides for fetching of \n * individual Org contract addresses as well as a list of all \n * allowedOrgs. \n */\ncontract FundFactory is Administratable {\n// ========== STATE VARIABLES ==========\n    Fund[] public createdFunds;\n    event fundCreated(address indexed newAddress);\n    \n// ========== CONSTRUCTOR ==========    \n    /**\n    * @notice Create new Fund Factory\n    * @param adminContractAddress Address of EndaomentAdmin contract. \n    */\n    constructor(address adminContractAddress) public onlyAdmin(adminContractAddress) {}\n        \n// ========== Fund Creation & Management ==========\n    /**\n    * @notice Creates new Fund and emits fundCreated event. \n    * @param managerAddress The address of the Fund's Primary Advisor\n    * @param adminContractAddress Address of EndaomentAdmin contract. \n    */\n    function createFund(address managerAddress, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.ACCOUNTANT) {\n        Fund newFund = new Fund(managerAddress, adminContractAddress);\n        createdFunds.push(newFund);\n        emit fundCreated(address(newFund));\n    }\n\n    /**\n    * @notice Returns total number of funds created by the factory. \n    */\n    function countFunds() public view returns (uint) {\n        return createdFunds.length;\n    }\n\n    /**\n    * @notice Returns address of a specific fund in createdFunds[] \n    * @param index The index position of the Fund \n    */\n    function getFund(uint index) public view returns (address) {\n        return address(createdFunds[index]); \n    }\n\n}"
    },
    {
      "filename": "contracts/Org.sol",
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./Administratable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n//ORG CONTRACT\n/**\n * @title Org\n * @author rheeger\n * @notice Org is a contract that serves as a smart wallet for US nonprofit\n * organizations. It holds the organization's federal Tax ID number as taxID, \n * and allows for an address to submit a Claim struct to the contract whereby \n * the organization can direct recieved grant awards from Endaoment Funds.\n */\ncontract Org is Administratable {\n    using SafeMath for uint256;\n\n// ========== STATE VARIABLES ==========\n    \n    struct Claim {\n        string firstName;\n        string lastName;\n        string eMail;\n        address desiredWallet;\n        bool filesSubmitted;\n    }\n\n    uint public taxId;\n    address public orgWallet;\n    Claim[] public claims;\n    event cashOutComplete(uint cashOutAmount);\n\n\n// ========== CONSTRUCTOR ==========    \n    \n    /**\n    * @notice Create new Organization Contract\n    * @param ein The U.S. Tax Identification Number for the Organization\n    * @param adminContractAddress Contract Address for Endaoment Admin\n    */\n    constructor(uint ein, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.ORG_FACTORY){\n        taxId = ein;\n    }\n\n// ========== Org Management & Info ==========\n    \n    /**\n     * @notice Create Organization Claim\n     * @param  fName First name of Administrator\n     * @param  lName Last name of Administrator\n     * @param  fSub Information Submitted successfully.\n     * @param  eMail Email contact for Organization Administrator.\n     * @param  orgAdminAddress Wallet address of Organization's Administrator.\n     */\n    function claimRequest(string memory fName, string memory lName, bool fSub, string memory eMail, address orgAdminAddress) public {\n        require (fSub == true);\n        require (msg.sender == orgAdminAddress);\n        \n        Claim memory newClaim = Claim({\n            firstName: fName,\n            lastName: lName,\n            eMail: eMail,\n            desiredWallet: msg.sender,\n            filesSubmitted: true\n        });\n\n        claims.push(newClaim);\n    }\n\n    /**\n     * @notice Approving Organization Claim \n     * @param  index Index value of Claim.\n     * @param  index Index value of Claim.\n     * @param adminContractAddress Contract Address for Endaoment Admin\n     */\n    function approveClaim(uint index, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.REVIEWER){\n        Claim storage claim = claims[index]; \n        \n        setOrgWallet(claim.desiredWallet, adminContractAddress);\n    }\n\n    /**\n     * @notice Cashing out Organization Contract \n     * @param  desiredWithdrawlAddress Destination for withdrawl\n     * @param tokenAddress Stablecoin address of desired token withdrawl\n     * @param adminContractAddress Contract Address for Endaoment Admin\n     */\n    function cashOutOrg(address desiredWithdrawlAddress, address tokenAddress, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.ACCOUNTANT){\n        ERC20 token = ERC20(tokenAddress);\n        uint256 cashOutAmount = token.balanceOf(address(this));\n\n        token.transfer(desiredWithdrawlAddress, cashOutAmount);\n        emit cashOutComplete(cashOutAmount);\n    }\n\n    function setOrgWallet(address providedWallet, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.REVIEWER){\n        orgWallet = providedWallet;\n    }\n\n     function getTokenBalance(address tokenAddress) public view returns (uint) {\n            ERC20 t = ERC20(tokenAddress);\n            uint256 bal = t.balanceOf(address(this));\n\n        return bal;\n     }\n\n       function getClaimsCount() public view returns (uint) {\n        return claims.length;\n    }\n\n}"
    },
    {
      "filename": "contracts/OrgFactory.sol",
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./Administratable.sol\";\nimport \"./Org.sol\";\n\n//ORG FACTORY CONTRACT\n/**\n * @title OrgFactory\n * @author rheeger\n * @notice OrgFactory is a contract that allows the EndaomentAdmin to \n * instantiate new Org contracts. It also provides for fetching of \n * individual Org contract addresses as well as a list of all \n * allowedOrgs. \n */\ncontract OrgFactory is Administratable {\n// ========== STATE VARIABLES==========\n    Org[] public deployedOrgs;\n    mapping(address => bool) public allowedOrgs;\n    event orgCreated(address indexed newAddress);\n\n// ========== CONSTRUCTOR ==========        \n    /**\n    * @notice Create new Org Factory\n    * @param adminContractAddress Address of EndaomentAdmin contract. \n    */\n    constructor(address adminContractAddress) public onlyAdmin(adminContractAddress) {}\n\n// ========== Org Creation & Management ==========\n    /**\n    * @notice  Create new Org Contract\n    * @param ein The U.S. Tax Identification Number for the Organization\n    * @param adminContractAddress Contract address for Endaoment Admin\n    */\n    function createOrg(uint ein, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.ACCOUNTANT){\n        Org newOrg = new Org(ein, adminContractAddress);\n        deployedOrgs.push(newOrg);\n        allowedOrgs[address(newOrg)] = true;\n        emit orgCreated(address(newOrg));\n    }\n\n    /**\n    * @notice Returns total number Org contracts created by the factory. \n    */\n    function countDeployedOrgs() public view returns (uint) {\n        return deployedOrgs.length;\n    }\n\n    /**\n    * @notice Returns address of given index postiion in deployedOrgs[]. \n    * @param index Array position of requested org\n    */\n    function getDeployedOrg(uint index) public view returns (address) {\n        return address(deployedOrgs[index]);\n    }\n\n    /**\n    * @notice Returns boolean is provided address is present in allowedOrgs[]. \n    * @param Org address of the organization contract requested.\n    */\n    function getAllowedOrg(address Org) public view returns (bool){\n        return allowedOrgs[Org];\n    }\n}"
    },
    {
      "filename": "contracts/OrgFactory.sol",
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./Administratable.sol\";\nimport \"./Org.sol\";\n\n//ORG FACTORY CONTRACT\n/**\n * @title OrgFactory\n * @author rheeger\n * @notice OrgFactory is a contract that allows the EndaomentAdmin to \n * instantiate new Org contracts. It also provides for fetching of \n * individual Org contract addresses as well as a list of all \n * allowedOrgs. \n */\ncontract OrgFactory is Administratable {\n// ========== STATE VARIABLES==========\n    Org[] public deployedOrgs;\n    mapping(address => bool) public allowedOrgs;\n    event orgCreated(address indexed newAddress);\n\n// ========== CONSTRUCTOR ==========        \n    /**\n    * @notice Create new Org Factory\n    * @param adminContractAddress Address of EndaomentAdmin contract. \n    */\n    constructor(address adminContractAddress) public onlyAdmin(adminContractAddress) {}\n\n// ========== Org Creation & Management ==========\n    /**\n    * @notice  Create new Org Contract\n    * @param ein The U.S. Tax Identification Number for the Organization\n    * @param adminContractAddress Contract address for Endaoment Admin\n    */\n    function createOrg(uint ein, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.ACCOUNTANT){\n        Org newOrg = new Org(ein, adminContractAddress);\n        deployedOrgs.push(newOrg);\n        allowedOrgs[address(newOrg)] = true;\n        emit orgCreated(address(newOrg));\n    }\n\n    /**\n    * @notice Returns total number Org contracts created by the factory. \n    */\n    function countDeployedOrgs() public view returns (uint) {\n        return deployedOrgs.length;\n    }\n\n    /**\n    * @notice Returns address of given index postiion in deployedOrgs[]. \n    * @param index Array position of requested org\n    */\n    function getDeployedOrg(uint index) public view returns (address) {\n        return address(deployedOrgs[index]);\n    }\n\n    /**\n    * @notice Returns boolean is provided address is present in allowedOrgs[]. \n    * @param Org address of the organization contract requested.\n    */\n    function getAllowedOrg(address Org) public view returns (bool){\n        return allowedOrgs[Org];\n    }\n}"
    },
    {
      "filename": "contracts/OrgFactory.sol",
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./Administratable.sol\";\nimport \"./Org.sol\";\n\n//ORG FACTORY CONTRACT\n/**\n * @title OrgFactory\n * @author rheeger\n * @notice OrgFactory is a contract that allows the EndaomentAdmin to \n * instantiate new Org contracts. It also provides for fetching of \n * individual Org contract addresses as well as a list of all \n * allowedOrgs. \n */\ncontract OrgFactory is Administratable {\n// ========== STATE VARIABLES==========\n    Org[] public deployedOrgs;\n    mapping(address => bool) public allowedOrgs;\n    event orgCreated(address indexed newAddress);\n\n// ========== CONSTRUCTOR ==========        \n    /**\n    * @notice Create new Org Factory\n    * @param adminContractAddress Address of EndaomentAdmin contract. \n    */\n    constructor(address adminContractAddress) public onlyAdmin(adminContractAddress) {}\n\n// ========== Org Creation & Management ==========\n    /**\n    * @notice  Create new Org Contract\n    * @param ein The U.S. Tax Identification Number for the Organization\n    * @param adminContractAddress Contract address for Endaoment Admin\n    */\n    function createOrg(uint ein, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.ACCOUNTANT){\n        Org newOrg = new Org(ein, adminContractAddress);\n        deployedOrgs.push(newOrg);\n        allowedOrgs[address(newOrg)] = true;\n        emit orgCreated(address(newOrg));\n    }\n\n    /**\n    * @notice Returns total number Org contracts created by the factory. \n    */\n    function countDeployedOrgs() public view returns (uint) {\n        return deployedOrgs.length;\n    }\n\n    /**\n    * @notice Returns address of given index postiion in deployedOrgs[]. \n    * @param index Array position of requested org\n    */\n    function getDeployedOrg(uint index) public view returns (address) {\n        return address(deployedOrgs[index]);\n    }\n\n    /**\n    * @notice Returns boolean is provided address is present in allowedOrgs[]. \n    * @param Org address of the organization contract requested.\n    */\n    function getAllowedOrg(address Org) public view returns (bool){\n        return allowedOrgs[Org];\n    }\n}"
    },
    {
      "filename": "contracts/Fund.sol",
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./Administratable.sol\";\nimport \"./OrgFactory.sol\";\n\n// FUND CONTRACT\n/**\n * @title Fund\n * @author rheeger\n * @notice Fund is a contract that serves as an on-chain US Donor-Advised Fund.\n * It holds the proceeds of gifted cryptocurrency as ERC20 tokens, \n * and allows for the manager to submit Grant reccomendations to the contract. \n * The EndaomentAdmin can then chose to approve the Grant reccomendation, triggering\n * a SafeMath transfer of a 1% fee to the EndaomentAdmin and the remainder to the \n * recipient Org contract.\n */\ncontract Fund is Administratable {\n    using SafeMath for uint256;\n\n// ========== STATE VARIABLES ==========\n    struct Grant {\n        string description;\n        uint value;\n        address recipient;\n        bool complete;\n    }\n\n    address public manager;\n    address public admin;\n    mapping(address => bool) public contributors;\n    Grant[] public grants;\n    uint public totalContributors;\n\n// ========== CONSTRUCTOR ==========\n    /**\n    * @notice Create new Fund\n    * @param creator Address of the Fund's Primary Advisor\n    * @param adminContractAddress Address of the EndaomentAdmin contract.\n    */\n    constructor (address creator, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.FUND_FACTORY){\n        require(creator != address(0));\n        manager = creator;\n    }\n\n// ========== Admin Management ==========\n    /**\n    * @notice Restricts method access to fund's manager\n    */\n    modifier restricted() {\n      require(msg.sender == manager);\n      _;\n    }\n\n// ========== Fund Management & Info ==========\n    /**\n    * @notice Change Fund Primary Advisor\n    * @param  newManager The address of the new PrimaryAdvisor.\n    * @param  adminContractAddress Address of the EndaomentAdmin contract.\n    */\n    function changeManager (address newManager, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.REVIEWER){\n        manager = newManager;\n    }\n\n    /**\n    * @notice Checks recipient of a Grant is an address created by the OrgFactory \n    * @param  recipient The address of the Grant recipient.\n    * @param  orgFactoryContractAddress Address of the OrgFactory contract.\n    */\n    function checkRecipient(address recipient, address orgFactoryContractAddress) public view returns (bool) {\n        OrgFactory x = OrgFactory ( orgFactoryContractAddress );\n\n        return x.getAllowedOrg(recipient);\n    }\n\n    /**\n    * @notice Returns summary of details about the fund [tokenBalance, ethBlance, number of grants, managerAddress]. \n    * @param  tokenAddress The token address of the stablecoin being used by the web-server.\n    */\n    function getSummary(address tokenAddress) public view returns (uint, uint, uint, address) {\n        ERC20 t = ERC20(tokenAddress);\n        uint bal = t.balanceOf(address(this));\n\n        return (\n            bal,\n            address(this).balance,\n            grants.length,\n            manager\n        );\n    }\n\n    /**\n    * @notice Create new Grant Reccomendation\n    * @param  description The address of the Owner.\n    * @param  value The value of the grant in base units.\n    * @param  recipient The address of the recieving organization's contract.\n    * @param  orgFactoryContractAddress Address of the orgFactory Contract.\n    */\n    function createGrant(string memory description, uint256 value, address recipient, address orgFactoryContractAddress) public restricted {\n        require(checkRecipient(recipient, orgFactoryContractAddress) == true);\n\n        Grant memory newGrant = Grant({\n            description: description,\n            value: value,\n            recipient: recipient,\n            complete: false\n        });\n\n        grants.push(newGrant);\n    }\n\n    /**\n    * @notice Approve Grant Reccomendation\n    * @param  index This Grant's index position\n    * @param  tokenAddress The stablecoin's token address.\n    * @param  adminContractAddress Address of the EndaomentAdmin contract.\n    */\n    function finalizeGrant(uint index, address tokenAddress, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, IEndaomentAdmin.Role.ACCOUNTANT){\n        EndaomentAdmin endaomentAdmin = EndaomentAdmin(adminContractAddress);\n        admin = endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN);\n        Grant storage grant = grants[index];\n        require(grant.complete == false);\n        ERC20 t = ERC20(tokenAddress);\n\n        //Process fees:\n        uint256 fee = (grant.val"
    }
  ]
}