{
  "Title": "Deployment To Chains Other Than Ethereum",
  "Content": "Below are some considerations to take into account when deploying this system to chains other than Ethereum.\n\n\n* The [`isSignerValid`](https://github.com/euler-xyz/ethereum-vault-connector/blob/69626eba206ae301b919f021e71b49feaf7ea8f5/src/EthereumVaultConnector.sol#L921-L926) function implements logic to prevent precompiles from being used as signers in the `permit` function. It assumes that the addresses of precompiles are values of `0xFF` or lower. This is true for Ethereum but may not be the case for other chains. For instance, on the zkSync Era chain system contract addresses start with `0x8000`.\n* Typical address aliasing in chains like Arbitrum or Optimism might break the assumption of having the same prefix for different sub-accounts. Specifically, whenever an account is a contract and not an externally owned account (EOA), Layer 1 to Layer 2 (L1 -> L2) messages will have the `msg.sender` aliased with a mask. This might result in different aliased account prefixes. The EVC will need to integrate un-aliasing features if it is intended to support cross-chain messaging.\n* Some chains, like zkSync Era, employ different memory growth mechanisms. In Ethereum, memory grows in words of 32 bytes each, whereas in zkSync Era, memory grows directly in bytes. Consequently, opcodes like `mstore` and `mload` may yield different results when utilized.\n\n\n***Update:** Resolved in [pull request #133](https://github.com/euler-xyz/ethereum-vault-connector/pull/133) by defining the `isSignerValid` function as `virtual`. The Euler team stated:*\n\n\n\n> *The `isSignerValid` function has been specifically added to the EVC in order to be overridden in case it is needed, depending on the chain to which the EVC is to be deployed. As you correctly noticed (i.e., for zkSync Era chain, the function will have to be overridden in order to invalidate signer addresses starting with `0x8000`), depending on the chain to which the EVC is to be deployed, other contract modifications might be necessary. Deployment to each chain will have to be closely evaluated.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/EthereumVaultConnector.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.19;\n\nimport \"./Set.sol\";\nimport \"./Events.sol\";\nimport \"./Errors.sol\";\nimport \"./TransientStorage.sol\";\nimport \"./interfaces/IEthereumVaultConnector.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IERC1271.sol\";\n\n/// @title EthereumVaultConnector\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice This contract implements the Ethereum Vault Connector.\ncontract EthereumVaultConnector is Events, Errors, TransientStorage, IEVC {\n    using ExecutionContext for EC;\n    using Set for SetStorage;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                       CONSTANTS                                           //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    string public constant name = \"Ethereum Vault Connector\";\n    string public constant version = \"1\";\n\n    bytes32 internal constant HASHED_NAME = keccak256(bytes(name));\n    bytes32 internal constant HASHED_VERSION = keccak256(bytes(version));\n\n    bytes32 internal constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    bytes32 internal constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address signer,uint256 nonceNamespace,uint256 nonce,uint256 deadline,uint256 value,bytes data)\"\n    );\n\n    uint256 internal immutable CACHED_CHAIN_ID;\n    bytes32 internal immutable CACHED_DOMAIN_SEPARATOR;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                        STORAGE                                            //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    // EVC implements controller isolation, meaning that unless in transient state, only one controller per account can\n    // be enabled. However, this can lead to a suboptimal user experience. In the event a user wants to have multiple\n    // controllers enabled, a separate wallet must be created and funded. Although there is nothing wrong with having\n    // many accounts within the same wallet, this can be a bad experience. In order to improve on this, EVC supports\n    // the concept of an owner that owns 256 accounts within EVC.\n\n    // Every Ethereum address has 256 accounts in the EVC (including the primary account - called the owner).\n    // Each account has an account ID from 0-255, where 0 is the owner account's ID. In order to compute the account\n    // addresses, the account ID is treated as a uint256 and XORed (exclusive ORed) with the Ethereum address.\n    // In order to record the owner of a group of 256 accounts, the EVC uses a definition of an address prefix.\n    // An address prefix is a part of an address having the first 19 bytes common with any of the 256 account\n    // addresses belonging to the same group.\n    // account/152 -> prefix/152\n    // To get an address prefix for the account, it's enough to take the account address and right shift it by 8 bits.\n\n    // Yes, this reduces the security of addresses by 8 bits, but creating multiple addresses in the wallet also reduces\n    // security: if somebody is trying to brute-force one of user's N>1 private keys, they have N times as many chances\n    // of succeeding per guess. It has to be admitted that the EVC model is weaker because finding a private key for\n    // an owner gives access to all accounts, but there is still a very comfortable security margin.\n\n    // Internal data structure that stores the addressPrefix owner and mode flags\n    struct OwnerStorage {\n        // The addressPrefix owner\n        address owner;\n        // Flag indicating if the addressPrefix is in lockdown mode\n        bool isLockdownMode;\n        // Flag indicating if the permit function is disabled for the addressPrefix\n        bool isPermitDisabledMode;\n    }\n\n    mapping(bytes19 addressPrefix => OwnerStorage ownerStorage) internal ownerLookup;\n\n    mapping(bytes19 addressPrefix => mapping(address operator => uint256 operatorBitField)) internal operatorLookup;\n\n    mapping(bytes19 addressPrefix => mapping(uint256 nonceNamespace => uint256 nonce)) internal nonceLookup;\n\n    mapping(address account => SetStorage) internal accountCollaterals;\n\n    mapping(address account => SetStorage) internal accountControllers;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                CONSTRUCTOR, FALLBACKS                                     //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    constructor() {\n        CACHED_CHAIN_ID = block.chainid;\n        CACHED_DOMAIN_SEPARATOR = calculateDomainSeparator();\n    }\n\n    receive() external payable {\n        // only receives value, no need to do anything here\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                       MODIFIERS                                           //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice A modifier that allows only the address recorded as an owner of the address prefix to call the function.\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\n    /// will be) as an owner in the ownerLookup.\n    /// @param addressPrefix The address prefix for which it is checked whether the caller is the owner.\n    modifier onlyOwner(bytes19 addressPrefix) {\n        // calculate a phantom address from the address prefix which can be used as an input to the authenticateCaller()\n        // function\n        address phantomAccount = address(uint160(uint152(addressPrefix)) << 8);\n        authenticateCaller(phantomAccount, false, false);\n\n        _;\n    }\n\n    /// @notice A modifier that allows only the owner or an operator of the account to call the function.\n    /// @dev The owner of an address prefix is an address that matches the address that has previously been recorded (or\n    /// will be) as an owner in the ownerLookup. An operator of an account is an address that has been authorized by the\n    /// owner of an account to perform operations on behalf of the owner.\n    /// @param account The address of the account for which it is checked whether the caller is the owner or an\n    /// operator.\n    modifier onlyOwnerOrOperator(address account) {\n        authenticateCaller(account, true, true);\n\n        _;\n    }\n\n    /// @notice A modifier checks whether msg.sender is the only controller for the account.\n    /// @dev The controller cannot use permit function in conjunction with this modifier.\n    modifier onlyController(address account) {\n        {\n            uint256 numOfControllers = accountControllers[account].numElements;\n            address controller = accountControllers[account].firstElement;\n\n            if (numOfControllers != 1) {\n                revert EVC_ControllerViolation();\n            }\n\n            if (controller != msg.sender) {\n                revert EVC_NotAuthorized();\n            }\n        }\n\n        _;\n    }\n\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered as well as checks for\n    /// controlCollateral re-entrancy.\n    modifier nonReentrantChecksAndControlCollateral() {\n        {\n            EC context = executionContext;\n\n            if (context.areChecksInProgress()) {\n                revert EVC_ChecksReentrancy();\n            }\n\n            if (context.isControlCollateralInProgress()) {\n                revert EVC_ControlCollateralReentrancy();\n            }\n        }\n\n        _;\n    }\n\n    /// @notice A modifier that verifies whether account or vault status checks are re-entered and sets the lock.\n    /// @dev This modifier also clears the current account on behalf of which the operation is performed as it shouldn't\n    /// be relied upon when the checks are in progress.\n    modifier nonReentrantChecks() virtual {\n        EC contextCache = executionContext;\n\n        if (contextCache.areChecksInProgress()) {\n            revert EVC_ChecksReentrancy();\n        }\n\n        executionContext = contextCache.setChecksInProgress().setOnBehalfOfAccount(address(0));\n\n        _;\n\n        executionContext = contextCache;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                   PUBLIC FUNCTIONS                                        //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    // Execution internals\n\n    /// @inheritdoc IEVC\n    function getRawExecutionContext() external view returns (uint256 context) {\n        context = EC.unwrap(executionContext);\n    }\n\n    /// @inheritdoc IEVC\n    function getCurrentOnBehalfOfAccount(address controllerToCheck)\n        public\n        view\n        returns (address onBehalfOfAccount, bool controllerEnabled)\n    {\n        onBehalfOfAccount = executionContext.getOnBehalfOfAccount();\n\n        // for safety, revert if no account has been authenticated\n        if (onBehalfOfAccount == address(0)) {\n            revert EVC_OnBehalfOfAccountNotAuthenticated();\n        }\n\n        controllerEnabled =\n            controllerToCheck == address(0) ? false : accountControllers[onBehalfOfAccount].contains(controllerToCheck);\n    }\n\n    /// @inheritdoc IEVC\n    function areChecksDeferred() external view returns (bool) {\n        return executionContext.areChecksDeferred();\n    }\n\n    /// @inheritdoc IEVC\n    function areChecksInProgress() external view returns (bool) {\n        return executionContext.areChecksInProgress();\n    }\n\n    /// @inheritdoc IEVC\n    function isControlCollateralInProgress() external view returns (bool) {\n        return executionContext.isControlCollateralInProgress();\n    }\n\n    /// @inheritdoc IEVC\n    function isOperatorAuthenticated() external view returns (bool) {\n        return executionContext.isOperatorAuthenticated();\n    }\n\n    /// @inheritdoc IEVC\n    function isSimulationInProgress() external view returns (bool) {\n        return executionContext.isSimulationInProgress();\n    }\n\n    // Owners and operators\n\n    /// @inheritdoc IEVC\n    function haveCommonOwner(address account, address otherAccount) external pure returns (bool) {\n        return haveCommonOwnerInternal(account, otherAccount);\n    }\n\n    /// @inheritdoc IEVC\n    function getAddressPrefix(address account) external pure returns (bytes19) {\n        return getAddressPrefixInternal(account);\n    }\n\n    /// @inheritdoc IEVC\n    function getAccountOwner(address account) external view returns (address) {\n        return getAccountOwnerInternal(account);\n    }\n\n    /// @inheritdoc IEVC\n    function isLockdownMode(bytes19 addressPrefix) external view returns (bool) {\n        return ownerLookup[addressPrefix].isLockdownMode;\n    }\n\n    /// @inheritdoc IEVC\n    function isPermitDisabledMode(bytes19 addressPrefix) external view returns (bool) {\n        return ownerLookup[addressPrefix].isPermitDisabledMode;\n    }\n\n    /// @inheritdoc IEVC\n    function getNonce(bytes19 addressPrefix, uint256 nonceNamespace) external view returns (uint256) {\n        return nonceLookup[addressPrefix][nonceNamespace];\n    }\n\n    /// @inheritdoc IEVC\n    function getOperator(bytes19 addressPrefix, address operator) external view returns (uint256) {\n        return operatorLookup[addressPrefix][operator];\n    }\n\n    /// @inheritdoc IEVC\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool) {\n        return isAccountOperatorAuthorizedInternal(account, operator);\n    }\n\n    /// @inheritdoc IEVC\n    function setLockdownMode(bytes19 addressPrefix, bool enabled) public payable virtual onlyOwner(addressPrefix) {\n        if (ownerLookup[addressPrefix].isLockdownMode != enabled) {\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\n            // function or within a checks-deferrable call. to disable this mode a direct call to the EVC must\n            // be made\n            if (!enabled && (executionContext.areChecksDeferred() || inPermitSelfCall())) {\n                revert EVC_NotAuthorized();\n            }\n\n            ownerLookup[addressPrefix].isLockdownMode = enabled;\n            emit LockdownModeStatus(addressPrefix, enabled);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    function setPermitDisabledMode(\n        bytes19 addressPrefix,\n        bool enabled\n    ) public payable virtual onlyOwner(addressPrefix) {\n        if (ownerLookup[addressPrefix].isPermitDisabledMode != enabled) {\n            // to increase user security, it is prohibited to disable this mode within the self-call of the permit\n            // function (by definition) or within a checks-deferrable call. to disable this mode a direct call to\n            // the EVC must be made\n            if (!enabled && executionContext.areChecksDeferred()) {\n                revert EVC_NotAuthorized();\n            }\n\n            ownerLookup[addressPrefix].isPermitDisabledMode = enabled;\n            emit PermitDisabledModeStatus(addressPrefix, enabled);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    function setNonce(\n        bytes19 addressPrefix,\n        uint256 nonceNamespace,\n        uint256 nonce\n    ) public payable virtual onlyOwner(addressPrefix) {\n        if (nonceLookup[addressPrefix][nonceNamespace] >= nonce) {\n            revert EVC_InvalidNonce();\n        }\n\n        nonceLookup[addressPrefix][nonceNamespace] = nonce;\n\n        unchecked {\n            nonce -= 1;\n        }\n\n        emit NonceUsed(addressPrefix, nonceNamespace, nonce);\n    }\n\n    /// @inheritdoc IEVC\n    /// @dev Uses authenticateCaller() function instead of onlyOwner() modifier to authenticate and get the caller\n    /// address at once.\n    function setOperator(bytes19 addressPrefix, address operator, uint256 operatorBitField) public payable virtual {\n        // calculate a phantom address from the address prefix which can be used as an input to the authenticateCaller()\n        // function\n        address phantomAccount = address(uint160(uint152(addressPrefix)) << 8);\n        address msgSender = authenticateCaller(phantomAccount, false, false);\n\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\n        if (operator == address(this) || haveCommonOwnerInternal(msgSender, operator)) {\n            revert EVC_InvalidAddress();\n        }\n\n        if (operatorLookup[addressPrefix][operator] == operatorBitField) {\n            revert EVC_InvalidOperatorStatus();\n        } else {\n            operatorLookup[addressPrefix][operator] = operatorBitField;\n\n            emit OperatorStatus(addressPrefix, operator, operatorBitField);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    /// @dev Uses authenticateCaller() function instead of onlyOwnerOrOperator() modifier to authenticate and get the\n    /// caller address at once.\n    function setAccountOperator(address account, address operator, bool authorized) public payable virtual {\n        address msgSender = authenticateCaller(account, true, false);\n\n        // if the account and the caller have a common owner, the caller must be the owner. if the account and the\n        // caller don't have a common owner, the caller must be an operator and the owner address is taken from the\n        // storage\n        address owner = haveCommonOwnerInternal(account, msgSender) ? msgSender : getAccountOwnerInternal(account);\n\n        // if it's an operator calling, it can only act for itself and must not be able to change other operators status\n        if (owner != msgSender && operator != msgSender) {\n            revert EVC_NotAuthorized();\n        }\n\n        // the operator can neither be the EVC nor can be one of 256 accounts of the owner\n        if (operator == address(this) || haveCommonOwnerInternal(owner, operator)) {\n            revert EVC_InvalidAddress();\n        }\n\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\n\n        // The bitMask defines which accounts the operator is authorized for. The bitMask is created from the account\n        // number which is a number up to 2^8 in binary, or 256. 1 << (uint160(owner) ^ uint160(account)) transforms\n        // that number in an 256-position binary array like 0...010...0, marking the account positionally in a uint256.\n        uint256 bitMask = 1 << (uint160(owner) ^ uint160(account));\n\n        // The operatorBitField is a 256-position binary array, where each 1 signals by position the account that the\n        // operator is authorized for.\n        uint256 oldOperatorBitField = operatorLookup[addressPrefix][operator];\n        uint256 newOperatorBitField = authorized ? oldOperatorBitField | bitMask : oldOperatorBitField & ~bitMask;\n\n        if (oldOperatorBitField == newOperatorBitField) {\n            revert EVC_InvalidOperatorStatus();\n        } else {\n            operatorLookup[addressPrefix][operator] = newOperatorBitField;\n\n            emit OperatorStatus(addressPrefix, operator, newOperatorBitField);\n        }\n    }\n\n    // Collaterals management\n\n    /// @inheritdoc IEVC\n    function getCollaterals(address account) external view returns (address[] memory) {\n        return accountCollaterals[account].get();\n    }\n\n    /// @inheritdoc IEVC\n    function isCollateralEnabled(address account, address vault) external view returns (bool) {\n        return accountCollaterals[account].contains(vault);\n    }\n\n    /// @inheritdoc IEVC\n    function enableCollateral(\n        address account,\n        address vault\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\n        if (vault == address(this)) revert EVC_InvalidAddress();\n\n        if (accountCollaterals[account].insert(vault)) {\n            emit CollateralStatus(account, vault, true);\n        }\n        requireAccountStatusCheck(account);\n    }\n\n    /// @inheritdoc IEVC\n    function disableCollateral(\n        address account,\n        address vault\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\n        if (accountCollaterals[account].remove(vault)) {\n            emit CollateralStatus(account, vault, false);\n        }\n        requireAccountStatusCheck(account);\n    }\n\n    /// @inheritdoc IEVC\n    function reorderCollaterals(\n        address account,\n        uint8 index1,\n        uint8 index2\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\n        accountCollaterals[account].reorder(index1, index2);\n        requireAccountStatusCheck(account);\n    }\n\n    // Controllers management\n\n    /// @inheritdoc IEVC\n    function getControllers(address account) external view returns (address[] memory) {\n        return accountControllers[account].get();\n    }\n\n    /// @inheritdoc IEVC\n    function isControllerEnabled(address account, address vault) external view returns (bool) {\n        return accountControllers[account].contains(vault);\n    }\n\n    /// @inheritdoc IEVC\n    function enableController(\n        address account,\n        address vault\n    ) public payable virtual nonReentrantChecksAndControlCollateral onlyOwnerOrOperator(account) {\n        if (vault == address(this)) revert EVC_InvalidAddress();\n\n        if (accountControllers[account].insert(vault)) {\n            emit ControllerStatus(account, vault, true);\n        }\n        requireAccountStatusCheck(account);\n    }\n\n    /// @inheritdoc IEVC\n    function disableController(address account) public payable virtual nonReentrantChecksAndControlCollateral {\n        if (accountControllers[account].remove(msg.sender)) {\n            emit ControllerStatus(account, msg.sender, false);\n        }\n        requireAccountStatusCheck(account);\n    }\n\n    // Permit\n\n    /// @inheritdoc IEVC\n    function permit(\n        address signer,\n        uint256 nonceNamespace,\n        uint256 nonce,\n        uint256 deadline,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata signature\n    ) public payable virtual nonReentrantChecksAndControlCollateral {\n        // cannot be called within the self-call of the permit function; can occur for nested calls\n        if (inPermitSelfCall()) {\n            revert EVC_NotAuthorized();\n        }\n\n        if (signer == address(0) || !isSignerValid(signer)) {\n            revert EVC_InvalidAddress();\n        }\n\n        bytes19 addressPrefix = getAddressPrefixInternal(signer);\n        uint256 currentNonce = nonceLookup[addressPrefix][nonceNamespace];\n\n        if (currentNonce == type(uint256).max || currentNonce != nonce) {\n            revert EVC_InvalidNonce();\n        }\n\n        if (deadline < block.timestamp) {\n            revert EVC_InvalidTimestamp();\n        }\n\n        if (data.length == 0) {\n            revert EVC_InvalidData();\n        }\n\n        bytes32 permitHash = getPermitHash(signer, nonceNamespace, nonce, deadline, value, data);\n\n        if (\n            signer != recoverECDSASigner(permitHash, signature)\n                && !isValidERC1271Signature(signer, permitHash, signature)\n        ) {\n            revert EVC_NotAuthorized();\n        }\n\n        if (ownerLookup[addressPrefix].isPermitDisabledMode) {\n            revert EVC_PermitDisabledMode();\n        }\n\n        unchecked {\n            nonceLookup[addressPrefix][nonceNamespace] = currentNonce + 1;\n        }\n\n        emit NonceUsed(addressPrefix, nonceNamespace, nonce);\n\n        // EVC address becomes the msg.sender for the duration this self-call, no authentication is required here.\n        // the signer will be later on authenticated as per data, depending on the functions that will be called\n        (bool success, bytes memory result) = callWithContextInternal(address(this), signer, value, data);\n\n        if (!success) revertBytes(result);\n    }\n\n    // Calls forwarding\n\n    /// @inheritdoc IEVC\n    function call(\n        address targetContract,\n        address onBehalfOfAccount,\n        uint256 value,\n        bytes calldata data\n    ) public payable virtual nonReentrantChecksAndControlCollateral returns (bytes memory result) {\n        EC contextCache = executionContext;\n        executionContext = contextCache.setChecksDeferred();\n\n        bool success;\n        (success, result) = callWithAuthenticationInternal(targetContract, onBehalfOfAccount, value, data);\n\n        if (!success) revertBytes(result);\n\n        restoreExecutionContext(contextCache);\n    }\n\n    /// @inheritdoc IEVC\n    function controlCollateral(\n        address targetCollateral,\n        address onBehalfOfAccount,\n        uint256 value,\n        bytes calldata data\n    )\n        public\n        payable\n        virtual\n        nonReentrantChecksAndControlCollateral\n        onlyController(onBehalfOfAccount)\n        returns (bytes memory result)\n    {\n        if (!accountCollaterals[onBehalfOfAccount].contains(targetCollateral)) {\n            revert EVC_NotAuthorized();\n        }\n\n        EC contextCache = executionContext;\n        executionContext = contextCache.setChecksDeferred().setControlCollateralInProgress();\n\n        bool success;\n        (success, result) = callWithContextInternal(targetCollateral, onBehalfOfAccount, value, data);\n\n        if (!success) revertBytes(result);\n\n        restoreExecutionContext(contextCache);\n    }\n\n    /// @inheritdoc IEVC\n    function batch(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\n        EC contextCache = executionContext;\n        executionContext = contextCache.setChecksDeferred();\n\n        uint256 length = items.length;\n        for (uint256 i; i < length; ++i) {\n            BatchItem calldata item = items[i];\n            (bool success, bytes memory result) =\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\n\n            if (!success) revertBytes(result);\n        }\n\n        restoreExecutionContext(contextCache);\n    }\n\n    // Simulations\n\n    /// @inheritdoc IEVC\n    function batchRevert(BatchItem[] calldata items) public payable virtual nonReentrantChecksAndControlCollateral {\n        BatchItemResult[] memory batchItemsResult;\n        StatusCheckResult[] memory accountsStatusCheckResult;\n        StatusCheckResult[] memory vaultsStatusCheckResult;\n\n        EC contextCache = executionContext;\n\n        if (contextCache.areChecksDeferred()) {\n            revert EVC_SimulationBatchNested();\n        }\n\n        executionContext = contextCache.setChecksDeferred().setSimulationInProgress();\n\n        uint256 length = items.length;\n        batchItemsResult = new BatchItemResult[](length);\n\n        for (uint256 i; i < length; ++i) {\n            BatchItem calldata item = items[i];\n            (batchItemsResult[i].success, batchItemsResult[i].result) =\n                callWithAuthenticationInternal(item.targetContract, item.onBehalfOfAccount, item.value, item.data);\n        }\n\n        executionContext = contextCache.setChecksInProgress();\n\n        accountsStatusCheckResult = checkStatusAllWithResult(SetType.Account);\n        vaultsStatusCheckResult = checkStatusAllWithResult(SetType.Vault);\n\n        executionContext = contextCache;\n\n        revert EVC_RevertedBatchResult(batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult);\n    }\n\n    /// @inheritdoc IEVC\n    function batchSimulation(BatchItem[] calldata items)\n        public\n        payable\n        virtual\n        returns (\n            BatchItemResult[] memory batchItemsResult,\n            StatusCheckResult[] memory accountsStatusCheckResult,\n            StatusCheckResult[] memory vaultsStatusCheckResult\n        )\n    {\n        (bool success, bytes memory result) = address(this).delegatecall(abi.encodeCall(this.batchRevert, items));\n\n        if (success) {\n            revert EVC_BatchPanic();\n        } else if (bytes4(result) != EVC_RevertedBatchResult.selector) {\n            revertBytes(result);\n        }\n\n        assembly {\n            result := add(result, 4)\n        }\n\n        (batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult) =\n            abi.decode(result, (BatchItemResult[], StatusCheckResult[], StatusCheckResult[]));\n    }\n\n    // Account Status Check\n\n    /// @inheritdoc IEVC\n    function isAccountStatusCheckDeferred(address account) external view returns (bool) {\n        if (executionContext.areChecksInProgress()) {\n            revert EVC_ChecksReentrancy();\n        }\n\n        return accountStatusChecks.contains(account);\n    }\n\n    /// @inheritdoc IEVC\n    function requireAccountStatusCheck(address account) public payable virtual nonReentrantChecks {\n        if (executionContext.areChecksDeferred()) {\n            accountStatusChecks.insert(account);\n        } else {\n            requireAccountStatusCheckInternal(account);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    function forgiveAccountStatusCheck(address account)\n        public\n        payable\n        virtual\n        nonReentrantChecks\n        onlyController(account)\n    {\n        accountStatusChecks.remove(account);\n    }\n\n    // Vault Status Check\n\n    /// @inheritdoc IEVC\n    function isVaultStatusCheckDeferred(address vault) external view returns (bool) {\n        if (executionContext.areChecksInProgress()) {\n            revert EVC_ChecksReentrancy();\n        }\n\n        return vaultStatusChecks.contains(vault);\n    }\n\n    /// @inheritdoc IEVC\n    function requireVaultStatusCheck() public payable virtual nonReentrantChecks {\n        if (executionContext.areChecksDeferred()) {\n            vaultStatusChecks.insert(msg.sender);\n        } else {\n            requireVaultStatusCheckInternal(msg.sender);\n        }\n    }\n\n    /// @inheritdoc IEVC\n    function forgiveVaultStatusCheck() public payable virtual nonReentrantChecks {\n        vaultStatusChecks.remove(msg.sender);\n    }\n\n    /// @inheritdoc IEVC\n    function requireAccountAndVaultStatusCheck(address account) public payable virtual nonReentrantChecks {\n        if (executionContext.areChecksDeferred()) {\n            accountStatusChecks.insert(account);\n            vaultStatusChecks.insert(msg.sender);\n        } else {\n            requireAccountStatusCheckInternal(account);\n            requireVaultStatusCheckInternal(msg.sender);\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                  INTERNAL FUNCTIONS                                       //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    function authenticateCaller(\n        address account,\n        bool allowOperator,\n        bool checkLockdownMode\n    ) internal virtual returns (address) {\n        bytes19 addressPrefix = getAddressPrefixInternal(account);\n        address owner = ownerLookup[addressPrefix].owner;\n        bool lockdownMode = ownerLookup[addressPrefix].isLockdownMode;\n\n        if (checkLockdownMode && lockdownMode) {\n            revert EVC_LockdownMode();\n        }\n\n        address msgSender = _msgSender();\n        bool authenticated = false;\n\n        // check if the caller is the owner of the account\n        if (haveCommonOwnerInternal(account, msgSender)) {\n            // if the owner is not registered, register it\n            if (owner == address(0)) {\n                setAccountOwnerInternal(account, msgSender);\n                authenticated = true;\n            } else if (owner == msgSender) {\n                authenticated = true;\n            }\n        }\n\n        // if the caller is not the owner, check if it is an operator if operators are allowed\n        if (!authenticated && allowOperator) {\n            authenticated = isAccountOperatorAuthorizedInternal(account, msgSender);\n        }\n\n        // must revert if neither the owner nor the operator were authenticated\n        if (!authenticated) {\n            revert EVC_NotAuthorized();\n        }\n\n        return msgSender;\n    }\n\n    function callWithContextInternal(\n        address targetContract,\n        address onBehalfOfAccount,\n        uint256 value,\n        bytes calldata data\n    ) internal virtual returns (bool success, bytes memory result) {\n        if (value == type(uint256).max) {\n            value = address(this).balance;\n        } else if (value > address(this).balance) {\n            revert EVC_InvalidValue();\n        }\n\n        EC contextCache = executionContext;\n        address msgSender = _msgSender();\n\n        // set the onBehalfOfAccount in the execution context for the duration of the external call.\n        // considering that the operatorAuthenticated is only meant to be observable by external\n        // contracts, it is sufficient to set it here rather than in the authentication function.\n        // apart from the usual scenario (when an owner operates on behalf of its account),\n        // the operatorAuthenticated should be cleared when about to execute the permit self-call, when\n        // target contract is equal to the msg.sender in call() and batch(), or when the controlCollateral is in\n        // progress (in which case the operatorAuthenticated is not relevant)\n        if (\n            haveCommonOwnerInternal(onBehalfOfAccount, msgSender) || targetContract == msg.sender\n                || targetContract == address(this) || contextCache.isControlCollateralInProgress()\n        ) {\n            executionContext = contextCache.setOnBehalfOfAccount(onBehalfOfAccount).clearOperatorAuthenticated();\n        } else {\n            executionContext = contextCache.setOnBehalfOfAccount(onBehalfOfAccount).setOperatorAuthenticated();\n        }\n\n        emit CallWithContext(\n            msgSender, getAddressPrefixInternal(onBehalfOfAccount), onBehalfOfAccount, targetContract, bytes4(data)\n        );\n\n        (success, result) = targetContract.call{value: value}(data);\n\n        executionContext = contextCache;\n    }\n\n    function callWithAuthenticationInternal(\n        address targetContract,\n        address onBehalfOfAccount,\n        uint256 value,\n        bytes calldata data\n    ) internal virtual returns (bool success, bytes memory result) {\n        if (targetContract == address(this)) {\n            if (onBehalfOfAccount != address(0)) {\n                revert EVC_InvalidAddress();\n            }\n\n            if (value != 0) {\n                revert EVC_InvalidValue();\n            }\n\n            // delegatecall is used here to pr"
    }
  ]
}