{
  "Title": "[L08] Paymasters cannot reduce unstaking delay after withdrawal window [core]",
  "Content": "The `StakeManager` contract allows paymasters to lock funds for a period of time and they are [intentionally prevented](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/StakeManager.sol#L87) from reducing the delay. However, after unstaking their funds and waiting for the withdrawal period, they should be able to stake again with any delay. This is possible if they withdraw their funds first (which [clears the saved delay](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/StakeManager.sol#L127)), but this is should not be a necessary requirement.\n\n\nConsider [updating the staking guard condition](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/StakeManager.sol#L87) to allow the delay time to be reduced if the `withdrawTime` has been reached.\n\n\n***Update**: Fixed in pull request [#76](https://github.com/eth-infinitism/account-abstraction/pull/76/files). Staking state is no longer affected by the `withdrawTo` function. Users can now unlock an existing stake using `unlockStake` without needing to withdraw the funds, and they can then immediately restake by calling the `addStakeTo` function.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/StakeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8;\n\nimport \"hardhat/console.sol\";\n\n/**\n * manage deposit of sender or paymaster, to pay for gas.\n * paymaster must stake some of the deposit.\n */\ncontract StakeManager {\n\n    /// minimum number of blocks to after 'unlock' before amount can be withdrawn.\n    uint32 immutable public unstakeDelaySec;\n\n    constructor(uint32 _unstakeDelaySec) {\n        unstakeDelaySec = _unstakeDelaySec;\n    }\n\n    event Deposited(\n        address indexed account,\n        uint256 totalDeposit,\n        uint256 unstakeDelaySec\n    );\n\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event DepositUnstaked(\n        address indexed account,\n        uint256 withdrawTime\n    );\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 withdrawAmount\n    );\n\n    /// @param amount of ether deposited for this account\n    /// @param unstakeDelaySec - time the deposit is locked, after calling unlock (or zero if deposit is not locked)\n    /// @param withdrawTime - first block timestamp where 'withdrawTo' will be callable, or zero if not locked\n    struct DepositInfo {\n        uint112 amount;\n        uint32 unstakeDelaySec;\n        uint64 withdrawTime;\n    }\n\n    /// maps accounts to their deposits\n    mapping(address => DepositInfo) public deposits;\n\n    function getDepositInfo(address account) external view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    function balanceOf(address account) public view returns (uint) {\n        return deposits[account].amount;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    function internalIncrementDeposit(address account, uint amount) internal {\n        deposits[account].amount += uint112(amount);\n    }\n\n    function internalDecrementDeposit(address account, uint amount) internal {\n        deposits[account].amount -= uint112(amount);\n    }\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) public payable {\n        internalIncrementDeposit(account, msg.value);\n        DepositInfo storage info = deposits[account];\n        emit Deposited(msg.sender, info.amount, info.unstakeDelaySec);\n    }\n\n    /**\n     * stake the account's deposit.\n     * any pending unstakeDeposit is first cancelled.\n     * can also set (or increase) the deposit with call.\n     * @param _unstakeDelaySec the new lock time before the deposit can be withdrawn.\n     */\n    function addStakeTo(address account, uint32 _unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[account];\n        require(_unstakeDelaySec >= info.unstakeDelaySec, \"cannot decrease unstake time\");\n        uint112 amount = deposits[msg.sender].amount + uint112(msg.value);\n        deposits[account] = DepositInfo(\n            amount,\n            _unstakeDelaySec,\n            0);\n        emit Deposited(account, amount, _unstakeDelaySec);\n    }\n\n    /**\n     * attempt to unstake the deposit.\n     * the value can be withdrawn (using withdrawTo) after the unstake delay.\n     */\n    function unstakeDeposit() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.withdrawTime == 0, \"already unstaking\");\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        emit DepositUnstaked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * withdraw from the deposit.\n     * will fail if the deposit is already staked or too low.\n     * after a paymaster unlocks and withdraws some of the value, it must call addStake() to stake the value again.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint withdrawAmount) external {\n        DepositInfo memory info = deposits[msg.sender];\n        if (info.unstakeDelaySec != 0) {\n            require(info.withdrawTime > 0, \"must call unstakeDeposit() first\");\n            require(info.withdrawTime <= block.timestamp, \"Withdrawal is not due\");\n        }\n        require(withdrawAmount <= info.amount, \"Withdraw amount too large\");\n\n        // store the remaining value, with stake info cleared.\n        deposits[msg.sender] = DepositInfo(\n            info.amount - uint112(withdrawAmount),\n            0,\n            0);\n        withdrawAddress.transfer(withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n    }\n\n    /**\n     * check if the given account is staked and didn't unlock it yet.\n     * @param account the account (paymaster) to check\n     * @param requiredStake the minimum deposit\n     * @param requiredDelaySec the minimum required stake time.\n     */\n    function isStaked(address account, uint requiredStake, uint requiredDelaySec) public view returns (bool) {\n        DepositInfo memory info = deposits[account];\n        return info.amount >= requiredStake &&\n        info.unstakeDelaySec >= requiredDelaySec &&\n        info.withdrawTime == 0;\n    }\n}"
    },
    {
      "filename": "contracts/StakeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8;\n\nimport \"hardhat/console.sol\";\n\n/**\n * manage deposit of sender or paymaster, to pay for gas.\n * paymaster must stake some of the deposit.\n */\ncontract StakeManager {\n\n    /// minimum number of blocks to after 'unlock' before amount can be withdrawn.\n    uint32 immutable public unstakeDelaySec;\n\n    constructor(uint32 _unstakeDelaySec) {\n        unstakeDelaySec = _unstakeDelaySec;\n    }\n\n    event Deposited(\n        address indexed account,\n        uint256 totalDeposit,\n        uint256 unstakeDelaySec\n    );\n\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event DepositUnstaked(\n        address indexed account,\n        uint256 withdrawTime\n    );\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 withdrawAmount\n    );\n\n    /// @param amount of ether deposited for this account\n    /// @param unstakeDelaySec - time the deposit is locked, after calling unlock (or zero if deposit is not locked)\n    /// @param withdrawTime - first block timestamp where 'withdrawTo' will be callable, or zero if not locked\n    struct DepositInfo {\n        uint112 amount;\n        uint32 unstakeDelaySec;\n        uint64 withdrawTime;\n    }\n\n    /// maps accounts to their deposits\n    mapping(address => DepositInfo) public deposits;\n\n    function getDepositInfo(address account) external view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    function balanceOf(address account) public view returns (uint) {\n        return deposits[account].amount;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    function internalIncrementDeposit(address account, uint amount) internal {\n        deposits[account].amount += uint112(amount);\n    }\n\n    function internalDecrementDeposit(address account, uint amount) internal {\n        deposits[account].amount -= uint112(amount);\n    }\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) public payable {\n        internalIncrementDeposit(account, msg.value);\n        DepositInfo storage info = deposits[account];\n        emit Deposited(msg.sender, info.amount, info.unstakeDelaySec);\n    }\n\n    /**\n     * stake the account's deposit.\n     * any pending unstakeDeposit is first cancelled.\n     * can also set (or increase) the deposit with call.\n     * @param _unstakeDelaySec the new lock time before the deposit can be withdrawn.\n     */\n    function addStakeTo(address account, uint32 _unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[account];\n        require(_unstakeDelaySec >= info.unstakeDelaySec, \"cannot decrease unstake time\");\n        uint112 amount = deposits[msg.sender].amount + uint112(msg.value);\n        deposits[account] = DepositInfo(\n            amount,\n            _unstakeDelaySec,\n            0);\n        emit Deposited(account, amount, _unstakeDelaySec);\n    }\n\n    /**\n     * attempt to unstake the deposit.\n     * the value can be withdrawn (using withdrawTo) after the unstake delay.\n     */\n    function unstakeDeposit() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.withdrawTime == 0, \"already unstaking\");\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        emit DepositUnstaked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * withdraw from the deposit.\n     * will fail if the deposit is already staked or too low.\n     * after a paymaster unlocks and withdraws some of the value, it must call addStake() to stake the value again.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint withdrawAmount) external {\n        DepositInfo memory info = deposits[msg.sender];\n        if (info.unstakeDelaySec != 0) {\n            require(info.withdrawTime > 0, \"must call unstakeDeposit() first\");\n            require(info.withdrawTime <= block.timestamp, \"Withdrawal is not due\");\n        }\n        require(withdrawAmount <= info.amount, \"Withdraw amount too large\");\n\n        // store the remaining value, with stake info cleared.\n        deposits[msg.sender] = DepositInfo(\n            info.amount - uint112(withdrawAmount),\n            0,\n            0);\n        withdrawAddress.transfer(withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n    }\n\n    /**\n     * check if the given account is staked and didn't unlock it yet.\n     * @param account the account (paymaster) to check\n     * @param requiredStake the minimum deposit\n     * @param requiredDelaySec the minimum required stake time.\n     */\n    function isStaked(address account, uint requiredStake, uint requiredDelaySec) public view returns (bool) {\n        DepositInfo memory info = deposits[account];\n        return info.amount >= requiredStake &&\n        info.unstakeDelaySec >= requiredDelaySec &&\n        info.withdrawTime == 0;\n    }\n}"
    }
  ]
}