{
  "Title": "M-5: Low precision is used when checking spot price deviation",
  "Content": "# Issue M-5: Low precision is used when checking spot price deviation \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/32 \n\n## Found by \nxiaoming90\n## Summary\n\nLow precision is used when checking spot price deviation, which might lead to potential manipulation or create the potential for an MEV opportunity due to valuation discrepancy.\n\n## Vulnerability Detail\n\nAssume the following:\n\n- The max deviation is set to 1%\n- `nTokenOracleValue` is 1,000,000,000\n- `nTokenSpotValue` is 980,000,001\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/global/Constants.sol#L47\n\n```solidity\nFile: Constants.sol\n46:     // Basis for percentages\n47:     int256 internal constant PERCENTAGE_DECIMALS = 100;\n```\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/nToken/nTokenCalculations.sol#L65\n\n```solidity\nFile: nTokenCalculations.sol\n61:             int256 maxValueDeviationPercent = int256(\n62:                 uint256(uint8(nToken.parameters[Constants.MAX_MINT_DEVIATION_LIMIT]))\n63:             );\n64:             // Check deviation limit here\n65:             int256 deviationInPercentage = nTokenOracleValue.sub(nTokenSpotValue).abs()\n66:                 .mul(Constants.PERCENTAGE_DECIMALS).div(nTokenOracleValue);\n67:             require(deviationInPercentage <= maxValueDeviationPercent, \"Over Deviation Limit\");\n```\n\nBased on the above formula:\n\n```solidity\nnTokenOracleValue.sub(nTokenSpotValue).abs().mul(Constants.PERCENTAGE_DECIMALS).div(nTokenOracleValue);\n((nTokenOracleValue - nTokenSpotValue) * Constants.PERCENTAGE_DECIMALS) / nTokenOracleValue\n((1,000,000,000 - 980,000,001) * 100) / 1,000,000,000\n(19,999,999 * 100) / 1,000,000,000\n1,999,999,900 / 1,000,000,000 = 1.9999999 = 1\n```\n\nThe above shows that the oracle and spot values have deviated by 1.99999%, which is close to 2%. However, due to a rounding error, it is rounded down to 1%, and the TX will not revert.\n\n## Impact\n\nThe purpose of the deviation check is to ensure that the spot market value is not manipulated. If the deviation check is not accurate, it might lead to potential manipulation or create the potential for an MEV opportunity due to valuation discrepancy.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/nToken/nTokenCalculations.sol#L65\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider increasing the precision.\n\nFor instance, increasing the precision from `Constants.PERCENTAGE_DECIMALS` (100) to 1e8 would have caught the issue mentioned earlier in the report even after the rounding down.\n\n```solidity\nnTokenOracleValue.sub(nTokenSpotValue).abs().mul(1e8).div(nTokenOracleValue);\n((nTokenOracleValue - nTokenSpotValue) * 1e8) / nTokenOracleValue\n((1,000,000,000 - 980,000,001) * 1e8) / 1,000,000,000\n(19,999,999 * 1e8) / 1,000,000,000 = 1999999.9 = 1999999\n```\n\n1% of 1e8 = 1000000\n\n```solidity\nrequire(deviationInPercentage <= maxValueDeviationPercent, \"Over Deviation Limit\")\nrequire(1999999 <= 1000000, \"Over Deviation Limit\") => Revert\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { This is valid}\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "contracts-v3/contracts/global/Constants.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity >=0.7.6;\n\n/// @title All shared constants for the Notional system should be declared here.\nlibrary Constants {\n    uint8 internal constant CETH_DECIMAL_PLACES = 8;\n\n    // Token precision used for all internal balances, TokenHandler library ensures that we\n    // limit the dust amount caused by precision mismatches\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\n    uint256 internal constant INCENTIVE_ACCUMULATION_PRECISION = 1e18;\n\n    // ETH will be initialized as the first currency\n    uint256 internal constant ETH_CURRENCY_ID = 1;\n    uint8 internal constant ETH_DECIMAL_PLACES = 18;\n    int256 internal constant ETH_DECIMALS = 1e18;\n    address internal constant ETH_ADDRESS = address(0);\n    // Used to prevent overflow when converting decimal places to decimal precision values via\n    // 10**decimalPlaces. This is a safe value for int256 and uint256 variables. We apply this\n    // constraint when storing decimal places in governance.\n    uint256 internal constant MAX_DECIMAL_PLACES = 36;\n\n    // Address of the account where fees are collected\n    address internal constant FEE_RESERVE = 0x0000000000000000000000000000000000000FEE;\n    // Address of the account where settlement funds are collected, this is only\n    // used for off chain event tracking.\n    address internal constant SETTLEMENT_RESERVE = 0x00000000000000000000000000000000000005e7;\n\n    // Most significant bit\n    bytes32 internal constant MSB =\n        0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    // Each bit set in this mask marks where an active market should be in the bitmap\n    // if the first bit refers to the reference time. Used to detect idiosyncratic\n    // fcash in the nToken accounts\n    bytes32 internal constant ACTIVE_MARKETS_MASK = (\n        MSB >> ( 90 - 1) | // 3 month\n        MSB >> (105 - 1) | // 6 month\n        MSB >> (135 - 1) | // 1 year\n        MSB >> (147 - 1) | // 2 year\n        MSB >> (183 - 1) | // 5 year\n        MSB >> (211 - 1) | // 10 year\n        MSB >> (251 - 1)   // 20 year\n    );\n\n    // Basis for percentages\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    // Min Buffer Scale and Buffer Scale are used in ExchangeRate to increase the maximum\n    // possible buffer values at the higher end of the uint8 range.\n    int256 internal constant MIN_BUFFER_SCALE = 150;\n    int256 internal constant BUFFER_SCALE = 10;\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\n    // for a bitmap portfolio\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\n    uint256 internal constant FIVE_MINUTES = 300;\n\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\n    uint256 internal constant DAY = 86400;\n    // We use six day weeks to ensure that all time references divide evenly\n    uint256 internal constant WEEK = DAY * 6;\n    uint256 internal constant MONTH = WEEK * 5;\n    uint256 internal constant QUARTER = MONTH * 3;\n    uint256 internal constant YEAR = QUARTER * 4;\n    \n    // These constants are used in DateTime.sol\n    uint256 internal constant DAYS_IN_WEEK = 6;\n    uint256 internal constant DAYS_IN_MONTH = 30;\n    uint256 internal constant DAYS_IN_QUARTER = 90;\n\n    // Offsets for each time chunk denominated in days\n    uint256 internal constant MAX_DAY_OFFSET = 90;\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\n\n    // Offsets for each time chunk denominated in bits\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\n\n    // Number of decimal places that rates are stored in, equals 100%\n    int256 internal constant RATE_PRECISION = 1e9;\n    // Used for prime cash scalars\n    uint256 internal constant SCALAR_PRECISION = 1e18;\n    // Used in prime rate lib\n    int256 internal constant DOUBLE_SCALAR_PRECISION = 1e36;\n    // One basis point in RATE_PRECISION terms\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\n    uint256 internal constant DELEVERAGE_BUFFER = 300 * BASIS_POINT;\n    // Used for scaling cash group factors\n    uint256 internal constant FIVE_BASIS_POINTS = 5 * BASIS_POINT;\n    // Used for residual purchase incentive and cash withholding buffer\n    uint256 internal constant TEN_BASIS_POINTS = 10 * BASIS_POINT;\n    // Used for max oracle rate\n    uint256 internal constant FIFTEEN_BASIS_POINTS = 15 * BASIS_POINT;\n    // Used in max rate calculations\n    uint256 internal constant MAX_LOWER_INCREMENT = 150;\n    uint256 internal constant MAX_LOWER_INCREMENT_VALUE = 150 * 25 * BASIS_POINT;\n    uint256 internal constant TWENTY_FIVE_BASIS_POINTS = 25 * BASIS_POINT;\n    uint256 internal constant ONE_HUNDRED_FIFTY_BASIS_POINTS = 150 * BASIS_POINT;\n\n    // This is the ABDK64x64 representation of RATE_PRECISION\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\n\n    uint8 internal constant FCASH_ASSET_TYPE          = 1;\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\n    uint8 internal constant VAULT_SHARE_ASSET_TYPE    = 9;\n    uint8 internal constant VAULT_DEBT_ASSET_TYPE     = 10;\n    uint8 internal constant VAULT_CASH_ASSET_TYPE     = 11;\n    // Used for tracking legacy nToken assets\n    uint8 internal constant LEGACY_NTOKEN_ASSET_TYPE  = 12;\n\n    // Account context flags\n    bytes1 internal constant HAS_ASSET_DEBT           = 0x01;\n    bytes1 internal constant HAS_CASH_DEBT            = 0x02;\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO      = 0x8000;\n    bytes2 internal constant ACTIVE_IN_BALANCES       = 0x4000;\n    bytes2 internal constant UNMASK_FLAGS             = 0x3FFF;\n    uint16 internal constant MAX_CURRENCIES           = uint16(UNMASK_FLAGS);\n\n    // Equal to 100% of all deposit amounts for nToken liquidity across fCash markets.\n    int256 internal constant DEPOSIT_PERCENT_BASIS    = 1e8;\n\n    // nToken Parameters: there are offsets in the nTokenParameters bytes6 variable returned\n    // in nTokenHandler. Each constant represents a position in the byte array.\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\n    uint8 internal constant MAX_MINT_DEVIATION_LIMIT = 5;\n\n    // Liquidation parameters\n    // Default percentage of collateral that a liquidator is allowed to liquidate, will be higher if the account\n    // requires more collateral to be liquidated\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\n    // Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 30;\n\n    // Pause Router liquidation enabled states\n    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;\n    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;\n    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;\n    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;\n\n    // Requires vault accounts to enter a position for a minimum of 1 min\n    // to mitigate strange behavior where accounts may enter and exit using\n    // flash loans or other MEV type behavior.\n    uint256 internal constant VAULT_ACCOUNT_MIN_TIME = 1 minutes;\n\n    // Placeholder constant to mark the variable rate prime cash maturity\n    uint40 internal constant PRIME_CASH_VAULT_MATURITY = type(uint40).max;\n\n    // This represents the maximum percent change allowed before and after \n    // a rebalancing. 100_000 represents a 0.01% change\n    // as a result of rebalancing. We should expect to never lose value as\n    // a result of rebalancing, but some rounding errors may exist as a result\n    // of redemption and deposit.\n    int256 internal constant REBALANCING_UNDERLYING_DELTA_PERCENT = 100_000;\n\n    // Ensures that the minimum total underlying held by the contract continues\n    // to accrue interest so that money market oracle rates are properly updated\n    // between rebalancing. With a minimum rebalancing cool down time of 6 hours\n    // we would be able to detect at least 1 unit of accrual at 8 decimal precision\n    // at an interest rate of 2.8 basis points (0.0288%) with 0.05e8 minimum balance\n    // held in a given token.\n    //\n    //                          MIN_ACCRUAL * (86400 / REBALANCING_COOL_DOWN_HOURS)\n    // MINIMUM_INTEREST_RATE =  ---------------------------------------------------\n    //                                     MINIMUM_UNDERLYING_BALANCE\n    int256 internal constant MIN_TOTAL_UNDERLYING_VALUE = 0.05e8;\n}"
    },
    {
      "filename": "contracts-v3/contracts/internal/nToken/nTokenCalculations.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    PrimeRate,\n    nTokenPortfolio,\n    CashGroupParameters,\n    MarketParameters,\n    PortfolioAsset\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {Bitmap} from \"../../math/Bitmap.sol\";\n\nimport {BitmapAssetsHandler} from \"../portfolio/BitmapAssetsHandler.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {CashGroup} from \"../markets/CashGroup.sol\";\nimport {DateTime} from \"../markets/DateTime.sol\";\nimport {AssetHandler} from \"../valuation/AssetHandler.sol\";\n\nimport {nTokenHandler} from \"./nTokenHandler.sol\";\n\nlibrary nTokenCalculations {\n    using Bitmap for bytes32;\n    using SafeInt256 for int256;\n    using PrimeRateLib for PrimeRate;\n    using CashGroup for CashGroupParameters;\n\n    /// @notice Calculates the tokens to mint to the account as a ratio of the nToken\n    /// present value denominated in asset cash terms.\n    /// @return the amount of tokens to mint, the ifCash bitmap\n    function calculateTokensToMint(\n        nTokenPortfolio memory nToken,\n        int256 primeCashToDeposit,\n        uint256 blockTime\n    ) internal view returns (int256) {\n        require(primeCashToDeposit >= 0); // dev: deposit amount negative\n        if (primeCashToDeposit == 0) return 0;\n\n        if (nToken.lastInitializedTime != 0) {\n            // For the sake of simplicity, nTokens cannot be minted if they have assets\n            // that need to be settled. This is only done during market initialization.\n            uint256 nextSettleTime = nTokenHandler.getNextSettleTime(nToken);\n            // If next settle time <= blockTime then the token can be settled\n            require(nextSettleTime > blockTime, \"Requires settlement\");\n        }\n\n        if (nToken.totalSupply == 0) {\n            // Allow for the first deposit and bypass all the PV valuation\n            return primeCashToDeposit;\n        } else {\n            (int256 nTokenOracleValue, int256 nTokenSpotValue) = nTokenCalculations.getNTokenPrimePVForMinting(\n                nToken, blockTime\n            );\n\n            // Defensive check to ensure PV remains positive\n            require(nTokenOracleValue >= 0);\n            require(nTokenSpotValue >= 0);\n\n            int256 maxValueDeviationPercent = int256(\n                uint256(uint8(nToken.parameters[Constants.MAX_MINT_DEVIATION_LIMIT]))\n            );\n            // Check deviation limit here\n            int256 deviationInPercentage = nTokenOracleValue.sub(nTokenSpotValue).abs()\n                .mul(Constants.PERCENTAGE_DECIMALS).div(nTokenOracleValue);\n            require(deviationInPercentage <= maxValueDeviationPercent, \"Over Deviation Limit\");\n\n            // nTokenSpotValuePost = nTokenOracleValue + amountToDeposit\n            // (tokenSupply + tokensToMint) / tokenSupply == (nTokenSpotValue + amountToDeposit) / nTokenOracleValue\n            // (tokenSupply + tokensToMint) == (nTokenSpotValue + amountToDeposit) * tokenSupply / nTokenOracleValue\n            // (tokenSupply + tokensToMint) == tokenSupply + (amountToDeposit * tokenSupply) / nTokenSpotValue\n            // tokensToMint == (amountToDeposit * tokenSupply) / nTokenSpotValue\n            return primeCashToDeposit.mul(nToken.totalSupply).div(nTokenSpotValue);\n        }\n    }\n\n    function getNTokenPrimePVForMinting(nTokenPortfolio memory nToken, uint256 blockTime)\n        internal view returns (int256 nTokenOracleValue, int256 nTokenSpotValue) {\n        // Skip the \"nextSettleTime\" check in this method. nTokens are not mintable when markets\n        // are not yet initialized.\n\n        (int256 totalOracleValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\n            {nToken: nToken, blockTime: blockTime, useOracleRate: true}\n        );\n        (int256 totalSpotValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\n            {nToken: nToken, blockTime: blockTime, useOracleRate: false}\n        );\n        int256 ifCashResidualPrimePV = _getIfCashResidualPrimePV(nToken, blockTime);\n\n        // Return the total present value denominated in asset terms\n        nTokenOracleValue = totalOracleValueInMarkets.add(ifCashResidualPrimePV).add(nToken.cashBalance);\n        nTokenSpotValue = totalSpotValueInMarkets.add(ifCashResidualPrimePV).add(nToken.cashBalance);\n    }\n\n    /// @notice Returns the nToken present value denominated in asset terms.\n    function getNTokenPrimePV(nTokenPortfolio memory nToken, uint256 blockTime)\n        internal view returns (int256) {\n        {\n            uint256 nextSettleTime = nTokenHandler.getNextSettleTime(nToken);\n            // If the first asset maturity has passed (the 3 month), this means that all the LTs must\n            // be settled except the 6 month (which is now the 3 month). We don't settle LTs except in\n            // initialize markets so we calculate the cash value of the portfolio here.\n            if (nextSettleTime <= blockTime) {\n                // NOTE: this condition should only be present for a very short amount of time, which is the window between\n                // when the markets are no longer tradable at quarter end and when the new markets have been initialized.\n                // We time travel back to one second before maturity to value the liquidity tokens. Although this value is\n                // not strictly correct the different should be quite slight. We do this to ensure that free collateral checks\n                // for withdraws and liquidations can still be processed. If this condition persists for a long period of time then\n                // the entire protocol will have serious problems as markets will not be tradable.\n                blockTime = nextSettleTime - 1;\n            }\n        }\n\n        // This is the total value in liquid assets\n        (int256 totalOracleValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\n            {nToken: nToken, blockTime: blockTime, useOracleRate: true}\n        );\n\n        int256 ifCashResidualPrimePV = _getIfCashResidualPrimePV(nToken, blockTime);\n\n        // Return the total present value denominated in prime cash terms\n        return totalOracleValueInMarkets.add(ifCashResidualPrimePV).add(nToken.cashBalance);\n    }\n\n    function _getIfCashResidualPrimePV(\n        nTokenPortfolio memory nToken, uint256 blockTime\n    ) private view returns (int256) {\n        // Then get the total value in any idiosyncratic fCash residuals (if they exist)\n        bytes32 ifCashBits = getNTokenifCashBits(\n            nToken.tokenAddress,\n            nToken.cashGroup.currencyId,\n            nToken.lastInitializedTime,\n            blockTime,\n            nToken.cashGroup.maxMarketIndex\n        );\n\n        if (ifCashBits != 0) {\n            // Non idiosyncratic residuals have already been accounted for\n            (int256 ifCashResidualUnderlyingPV, /* hasDebt */) = BitmapAssetsHandler.getNetPresentValueFromBitmap(\n                nToken.tokenAddress,\n                nToken.cashGroup.currencyId,\n                nToken.lastInitializedTime,\n                blockTime,\n                nToken.cashGroup,\n                false, // nToken present value calculation does not use risk adjusted values\n                ifCashBits\n            );\n            return nToken.cashGroup.primeRate.convertFromUnderlying(ifCashResidualUnderlyingPV);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Handles the case when liquidity tokens should be withdrawn in proportion to their amounts\n     * in the market. This will be the case when there is no idiosyncratic fCash residuals in the nToken\n     * portfolio.\n     * @param nToken portfolio object for nToken\n     * @param nTokensToRedeem amount of nTokens to redeem\n     * @param tokensToWithdraw array of liquidity tokens to withdraw from each market, proportional to\n     * the account's share of the total supply\n     * @param netfCash an empty array to hold net fCash values calculated later when the tokens are actually\n     * withdrawn from markets\n     */\n    function _getProportionalLiquidityTokens(\n        nTokenPortfolio memory nToken,\n        int256 nTokensToRedeem\n    ) private pure returns (int256[] memory tokensToWithdraw, int256[] memory netfCash) {\n        uint256 numMarkets = nToken.portfolioState.storedAssets.length;\n        tokensToWithdraw = new int256[](numMarkets);\n        netfCash = new int256[](numMarkets);\n\n        for (uint256 i = 0; i < numMarkets; i++) {\n            int256 totalTokens = nToken.portfolioState.storedAssets[i].notional;\n            tokensToWithdraw[i] = totalTokens.mul(nTokensToRedeem).div(nToken.totalSupply);\n        }\n    }\n\n    /**\n     * @notice Returns the number of liquidity tokens to withdraw from each market if the nToken\n     * has idiosyncratic residuals during nToken redeem. In this case the redeemer will take\n     * their cash from the rest of the fCash markets, redeeming around the nToken.\n     * @param nToken portfolio object for nToken\n     * @param nTokensToRedeem amount of nTokens to redeem\n     * @param blockTime block time\n     * @param ifCashBits the bits in the bitmap that represent ifCash assets\n     * @return tokensToWithdraw array of tokens to withdraw from each corresponding market\n     * @return netfCash array of netfCash amounts to go back to the account\n     */\n    function getLiquidityTokenWithdraw(\n        nTokenPortfolio memory nToken,\n        int256 nTokensToRedeem,\n        uint256 blockTime,\n        bytes32 ifCashBits\n    ) internal view returns (int256[] memory, int256[] memory) {\n        // If there are no ifCash bits set then this will just return the proportion of all liquidity tokens\n        if (ifCashBits == 0) return _getProportionalLiquidityTokens(nToken, nTokensToRedeem);\n\n        (\n            int256 totalPrimeValueInMarkets,\n            int256[] memory netfCash\n        ) = getNTokenMarketValue({nToken: nToken, blockTime: blockTime, useOracleRate: true});\n        int256[] memory tokensToWithdraw = new int256[](netfCash.length);\n\n        // NOTE: this total portfolio asset value does not include any cash balance the nToken may hold.\n        // The redeemer will always get a proportional share of this cash balance and therefore we don't\n        // need to account for it here when we calculate the share of liquidity tokens to withdraw. We are\n        // only concerned with the nToken's portfolio assets in this method.\n        int256 totalPortfolioAssetValue;\n        {\n            // Returns the risk adjusted net present value for the idiosyncratic residuals\n            (int256 underlyingPV, /* hasDebt */) = BitmapAssetsHandler.getNetPresentValueFromBitmap(\n                nToken.tokenAddress,\n                nToken.cashGroup.currencyId,\n                nToken.lastInitializedTime,\n                blockTime,\n                nToken.cashGroup,\n                true, // use risk adjusted here to assess a penalty for withdrawing around the residual\n                ifCashBits\n            );\n\n            // NOTE: we do not include cash balance here because the account will always take their share\n            // of the cash balance regardless of the residuals\n            totalPortfolioAssetValue = totalPrimeValueInMarkets.add(\n                nToken.cashGroup.primeRate.convertFromUnderlying(underlyingPV)\n            );\n        }\n\n        // Loops through each liquidity token and calculates how much the redeemer can withdraw to get\n        // the requisite amount of present value after adjusting for the ifCash residual value that is\n        // not accessible via redemption.\n        for (uint256 i = 0; i < tokensToWithdraw.length; i++) {\n            int256 totalTokens = nToken.portfolioState.storedAssets[i].notional;\n            // Redeemer's baseline share of the liquidity tokens based on total supply:\n            //      redeemerShare = totalTokens * nTokensToRedeem / totalSupply\n            // Scalar factor to account for residual value (need to inflate the tokens to withdraw\n            // proportional to the value locked up in ifCash residuals):\n            //      scaleFactor = totalPortfolioAssetValue / totalPrimeValueInMarkets\n            // Final math equals:\n            //      tokensToWithdraw = redeemerShare * scalarFactor\n            //      tokensToWithdraw = (totalTokens * nTokensToRedeem * totalPortfolioAssetValue)\n            //         / (totalPrimeValueInMarkets * totalSupply)\n            tokensToWithdraw[i] = totalTokens\n                .mul(nTokensToRedeem)\n                .mul(totalPortfolioAssetValue);\n\n            tokensToWithdraw[i] = tokensToWithdraw[i]\n                .div(totalPrimeValueInMarkets)\n                .div(nToken.totalSupply);\n\n            // This is the share of net fcash that will be credited back to the account\n            netfCash[i] = netfCash[i].mul(tokensToWithdraw[i]).div(totalTokens);\n        }\n\n        return (tokensToWithdraw, netfCash);\n    }\n\n    /// @notice Returns the value of all the liquid assets in an nToken portfolio which are defined by\n    /// the liquidity tokens held in each market and their corresponding fCash positions. The formula\n    /// can be described as:\n    /// totalPrimeValue = sum_per_liquidity_token(cashClaim + presentValue(netfCash))\n    ///     where netfCash = fCashClaim + fCash\n    ///     and fCash refers the the fCash position at the corresponding maturity\n    function getNTokenMarketValue(nTokenPortfolio memory nToken, uint256 blockTime, bool useOracleRate)\n        internal view returns (int256 totalPrimeValue, int256[] memory netfCash)\n    {\n        uint256 numMarkets = nToken.portfolioState.storedAssets.length;\n        netfCash = new int256[](numMarkets);\n\n        MarketParameters memory market;\n        for (uint256 i = 0; i < numMarkets; i++) {\n            // Load the corresponding market into memory\n            nToken.cashGroup.loadMarket(market, i + 1, true, blockTime);\n            PortfolioAsset memory liquidityToken = nToken.portfolioState.storedAssets[i];\n\n            // Get the fCash claims and fCash assets. We do not use haircut versions here because\n            // nTokenRedeem does not require it and getNTokenPV does not use it (a haircut is applied\n            // at the end of the calculation to the entire PV instead).\n            (int256 primeCashClaim, int256 fCashClaim) = AssetHandler.getCashClaims(liquidityToken, market);\n\n            // fCash is denominated in underlying\n            netfCash[i] = fCashClaim.add(\n                BitmapAssetsHandler.getifCashNotional(\n                    nToken.tokenAddress,\n                    nToken.cashGroup.currencyId,\n                    liquidityToken.maturity\n                )\n            );\n\n            // This calculates for a single liquidity token:\n            // primeCashClaim + convertToPrimeCash(pv(netfCash))\n            int256 netPrimeValueInMarket = primeCashClaim.add(\n                nToken.cashGroup.primeRate.convertFromUnderlying(\n                    AssetHandler.getPresentfCashValue(\n                        netfCash[i],\n                        liquidityToken.maturity,\n                        blockTime,\n                        // No need to call cash group for oracle rate, it is up to date here\n                        // and we are assured to be referring to this market.\n                        useOracleRate ? market.oracleRate : market.lastImpliedRate\n                    )\n                )\n            );\n\n            // Calculate the running total\n            totalPrimeValue = totalPrimeValue.add(netPrimeValueInMarket);\n        }\n    }\n\n    /// @notice Returns just the bits in a bitmap that are idiosyncratic\n    function getNTokenifCashBits(\n        address tokenAddress,\n        uint256 currencyId,\n        uint256 lastInitializedTime,\n        uint256 blockTime,\n        uint256 maxMarketIndex\n    ) internal view returns (bytes32) {\n        // If max market index is less than or equal to 2, there are never ifCash assets by construction\n        if (maxMarketIndex <= 2) return bytes32(0);\n        bytes32 assetsBitmap = BitmapAssetsHandler.getAssetsBitmap(tokenAddress, currencyId);\n        // Handles the case when there are no assets at the first initialization\n        if (assetsBitmap == 0) return assetsBitmap;\n\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\n\n        if (tRef == lastInitializedTime) {\n            // This is a more efficient way to turn off ifCash assets in the common case when the market is\n            // initialized immediately\n            return assetsBitmap & ~(Constants.ACTIVE_MARKETS_MASK);\n        } else {\n            // In this branch, initialize markets has occurred past the time above. It would occur in these\n            // two scenarios (both should be exceedingly rare):\n            // 1. initializing a cash group with 3+ markets for the first time (not beginning on the tRef)\n            // 2. somehow initialize markets has been delayed for more than 24 hours\n            for (uint i = 1; i <= maxMarketIndex; i++) {\n                // In this loop we get the maturity of each active market and turn off the corresponding bit\n                // one by one. It is less efficient than the option above.\n                uint256 maturity = tRef + DateTime.getTradedMarket(i);\n                (uint256 bitNum, /* */) = DateTime.getBitNumFromMaturity(lastInitializedTime, maturity);\n                assetsBitmap = assetsBitmap.setBit(bitNum, false);\n            }\n\n            return assetsBitmap;\n        }\n    }\n}"
    },
    {
      "filename": "contracts-v3/contracts/internal/nToken/nTokenCalculations.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    PrimeRate,\n    nTokenPortfolio,\n    CashGroupParameters,\n    MarketParameters,\n    PortfolioAsset\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {Bitmap} from \"../../math/Bitmap.sol\";\n\nimport {BitmapAssetsHandler} from \"../portfolio/BitmapAssetsHandler.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {CashGroup} from \"../markets/CashGroup.sol\";\nimport {DateTime} from \"../markets/DateTime.sol\";\nimport {AssetHandler} from \"../valuation/AssetHandler.sol\";\n\nimport {nTokenHandler} from \"./nTokenHandler.sol\";\n\nlibrary nTokenCalculations {\n    using Bitmap for bytes32;\n    using SafeInt256 for int256;\n    using PrimeRateLib for PrimeRate;\n    using CashGroup for CashGroupParameters;\n\n    /// @notice Calculates the tokens to mint to the account as a ratio of the nToken\n    /// present value denominated in asset cash terms.\n    /// @return the amount of tokens to mint, the ifCash bitmap\n    function calculateTokensToMint(\n        nTokenPortfolio memory nToken,\n        int256 primeCashToDeposit,\n        uint256 blockTime\n    ) internal view returns (int256) {\n        require(primeCashToDeposit >= 0); // dev: deposit amount negative\n        if (primeCashToDeposit == 0) return 0;\n\n        if (nToken.lastInitializedTime != 0) {\n            // For the sake of simplicity, nTokens cannot be minted if they have assets\n            // that need to be settled. This is only done during market initialization.\n            uint256 nextSettleTime = nTokenHandler.getNextSettleTime(nToken);\n            // If next settle time <= blockTime then the token can be settled\n            require(nextSettleTime > blockTime, \"Requires settlement\");\n        }\n\n        if (nToken.totalSupply == 0) {\n            // Allow for the first deposit and bypass all the PV valuation\n            return primeCashToDeposit;\n        } else {\n            (int256 nTokenOracleValue, int256 nTokenSpotValue) = nTokenCalculations.getNTokenPrimePVForMinting(\n                nToken, blockTime\n            );\n\n            // Defensive check to ensure PV remains positive\n            require(nTokenOracleValue >= 0);\n            require(nTokenSpotValue >= 0);\n\n            int256 maxValueDeviationPercent = int256(\n                uint256(uint8(nToken.parameters[Constants.MAX_MINT_DEVIATION_LIMIT]))\n            );\n            // Check deviation limit here\n            int256 deviationInPercentage = nTokenOracleValue.sub(nTokenSpotValue).abs()\n                .mul(Constants.PERCENTAGE_DECIMALS).div(nTokenOracleValue);\n            require(deviationInPercentage <= maxValueDeviationPercent, \"Over Deviation Limit\");\n\n            // nTokenSpotValuePost = nTokenOracleValue + amountToDeposit\n            // (tokenSupply + tokensToMint) / tokenSupply == (nTokenSpotValue + amountToDeposit) / nTokenOracleValue\n            // (tokenSupply + tokensToMint) == (nTokenSpotValue + amountToDeposit) * tokenSupply / nTokenOracleValue\n            // (tokenSupply + tokensToMint) == tokenSupply + (amountToDeposit * tokenSupply) / nTokenSpotValue\n            // tokensToMint == (amountToDeposit * tokenSupply) / nTokenSpotValue\n            return primeCashToDeposit.mul(nToken.totalSupply).div(nTokenSpotValue);\n        }\n    }\n\n    function getNTokenPrimePVForMinting(nTokenPortfolio memory nToken, uint256 blockTime)\n        internal view returns (int256 nTokenOracleValue, int256 nTokenSpotValue) {\n        // Skip the \"nextSettleTime\" check in this method. nTokens are not mintable when markets\n        // are not yet initialized.\n\n        (int256 totalOracleValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\n            {nToken: nToken, blockTime: blockTime, useOracleRate: true}\n        );\n        (int256 totalSpotValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\n            {nToken: nToken, blockTime: blockTime, useOracleRate: false}\n        );\n        int256 ifCashResidualPrimePV = _getIfCashResidualPrimePV(nToken, blockTime);\n\n        // Return the total present value denominated in asset terms\n        nTokenOracleValue = totalOracleValueInMarkets.add(ifCashResidualPrimePV).add(nToken.cashBalance);\n        nTokenSpotValue = totalSpotValueInMarkets.add(ifCashResidualPrimePV).add(nToken.cashBalance);\n    }\n\n    /// @notice Returns the nToken present value denominated in asset terms.\n    function getNTokenPrimePV(nTokenPortfolio memory nToken, uint256 blockTime)\n        internal view returns (int256) {\n        {\n            uint256 nextSettleTime = nTokenHandler.getNextSettleTime(nToken);\n            // If the first asset maturity has passed (the 3 month), this means that all the LTs must\n            // be settled except the 6 month (which is now the 3 month). We don't settle LTs except in\n            // initialize markets so we calculate the cash value of the portfolio here.\n            if (nextSettleTime <= blockTime) {\n                // NOTE: this condition should only be present for a very short amount of time, which is the window between\n                // when the markets are no longer tradable at quarter end and when the new markets have been initialized.\n                // We time travel back to one second before maturity to value the liquidity tokens. Although this value is\n                // not strictly correct the different should be quite slight. We do this to ensur"
    }
  ]
}