{
  "Title": "Missing Docstrings",
  "Content": "Throughout the [codebase](https://github.com/widolabs/wido-contracts/tree/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/), there are several parts that do not have docstrings. For example:\n\n\n* [Line 14](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/WidoCollateralSwap_Aave.sol#L13-L14) of [`WidoCollateralSwap_Aave.sol`](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/WidoCollateralSwap_Aave.sol)\n* [Line 12](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/WidoCollateralSwap_ERC3156.sol#L11-L12) of [`WidoCollateralSwap_ERC3156.sol`](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/WidoCollateralSwap_ERC3156.sol)\n* [Line 9](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/libraries/LibCollateralSwap.sol#L8-L9) of [`LibCollateralSwap.sol`](https://github.com/widolabs/wido-contracts/blob/d96ef2dd6a7ff3d04c44ebe87994411d1f8c84e7/contracts/compound/libraries/LibCollateralSwap.sol)\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well (even copied interfaces). When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update**: Resolved in [pull request #34](https://github.com/widolabs/wido-contracts/pull/34/files) at commit [9a24c01](https://github.com/widolabs/wido-contracts/tree/9a24c01aeb667759535561a0a58879c2d5be3127).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/compound/WidoCollateralSwap_Aave.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IPoolAddressesProvider} from \"aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol\";\nimport {IFlashLoanSimpleReceiver} from \"aave-v3-core/contracts/flashloan/interfaces/IFlashLoanSimpleReceiver.sol\";\nimport {IPool} from \"aave-v3-core/contracts/interfaces/IPool.sol\";\nimport {IComet} from \"./interfaces/IComet.sol\";\nimport {LibCollateralSwap} from \"./libraries/LibCollateralSwap.sol\";\nimport {IWidoCollateralSwap} from \"./interfaces/IWidoCollateralSwap.sol\";\n\ncontract WidoCollateralSwap_Aave is IFlashLoanSimpleReceiver, IWidoCollateralSwap {\n    using SafeMath for uint256;\n\n    /// @dev Aave addresses provider contract\n    IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n\n    /// @dev Aave Pool contract\n    IPool public immutable override POOL;\n\n    error InvalidProvider();\n\n    constructor(IPoolAddressesProvider _addressProvider) {\n        ADDRESSES_PROVIDER = _addressProvider;\n        POOL = IPool(_addressProvider.getPool());\n    }\n\n    /// @notice Performs a collateral swap with Aave\n    /// @param existingCollateral The collateral currently locked in the Comet contract\n    /// @param finalCollateral The final collateral desired collateral\n    /// @param sigs The required signatures to allow and revoke permission to this contract\n    /// @param swap The necessary data to swap one collateral for the other\n    /// @param comet The address of the Comet contract to interact with\n    function swapCollateral(\n        LibCollateralSwap.Collateral calldata existingCollateral,\n        LibCollateralSwap.Collateral calldata finalCollateral,\n        LibCollateralSwap.Signatures calldata sigs,\n        LibCollateralSwap.WidoSwap calldata swap,\n        address comet\n    ) external override {\n        bytes memory data = abi.encode(\n            msg.sender,\n            comet,\n            existingCollateral,\n            sigs,\n            swap\n        );\n\n        POOL.flashLoanSimple(\n            address(this),\n            finalCollateral.addr,\n            finalCollateral.amount,\n            data,\n            0\n        );\n    }\n\n    /// @notice Executes an operation after receiving the flash-borrowed asset\n    /// @dev Ensure that the contract can return the debt + premium, e.g., has\n    ///      enough funds to repay and has approved the Pool to pull the total amount\n    /// @param asset The address of the flash-borrowed asset\n    /// @param amount The amount of the flash-borrowed asset\n    /// @param premium The fee of the flash-borrowed asset\n    /// @param params The byte-encoded params passed when initiating the flashloan\n    /// @return True if the execution of the operation succeeds, false otherwise\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address /*initiator*/,\n        bytes calldata params\n    ) external override returns (bool) {\n        if (msg.sender != address(POOL)) {\n            revert InvalidProvider();\n        }\n\n        LibCollateralSwap.performCollateralSwap(asset, amount, premium, params);\n\n        // approve loan provider to pull lent amount + fee\n        IERC20(asset).approve(\n            address(POOL),\n            amount.add(premium)\n        );\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/compound/WidoCollateralSwap_ERC3156.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC3156FlashBorrower, IERC3156FlashLender} from \"./interfaces/IERC3156.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IComet} from \"./interfaces/IComet.sol\";\nimport {LibCollateralSwap} from \"./libraries/LibCollateralSwap.sol\";\nimport {IWidoCollateralSwap} from \"./interfaces/IWidoCollateralSwap.sol\";\n\ncontract WidoCollateralSwap_ERC3156 is IERC3156FlashBorrower, IWidoCollateralSwap {\n    using SafeMath for uint256;\n\n    /// @dev ERC3156 lender contract\n    IERC3156FlashLender public immutable loanProvider;\n\n    /// @dev The typehash for the ERC-3156 `onFlashLoan` return\n    bytes32 internal constant ON_FLASH_LOAN_RESPONSE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    error InvalidProvider();\n\n    constructor(IERC3156FlashLender _loanProvider) {\n        loanProvider = _loanProvider;\n    }\n\n    /// @notice Performs a collateral swap\n    /// @param existingCollateral The collateral currently locked in the Comet contract\n    /// @param finalCollateral The final collateral desired collateral\n    /// @param sigs The required signatures to allow and revoke permission to this contract\n    /// @param swap The necessary data to swap one collateral for the other\n    /// @param comet The address of the Comet contract to interact with\n    function swapCollateral(\n        LibCollateralSwap.Collateral calldata existingCollateral,\n        LibCollateralSwap.Collateral calldata finalCollateral,\n        LibCollateralSwap.Signatures calldata sigs,\n        LibCollateralSwap.WidoSwap calldata swap,\n        address comet\n    ) external override {\n        bytes memory data = abi.encode(\n            msg.sender,\n            comet,\n            existingCollateral,\n            sigs,\n            swap\n        );\n\n        loanProvider.flashLoan(\n            IERC3156FlashBorrower(this),\n            finalCollateral.addr,\n            finalCollateral.amount,\n            data\n        );\n    }\n\n    /// @notice Callback to be executed by the flash loan provider\n    /// @dev Only allow-listed providers should have access\n    function onFlashLoan(\n        address /* initiator */,\n        address borrowedAsset,\n        uint256 borrowedAmount,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        if (msg.sender != address(loanProvider)) {\n            revert InvalidProvider();\n        }\n\n        LibCollateralSwap.performCollateralSwap(borrowedAsset, borrowedAmount, fee, data);\n\n        // approve loan provider to pull lent amount + fee\n        IERC20(borrowedAsset).approve(\n            address(loanProvider),\n            borrowedAmount.add(fee)\n        );\n\n        return ON_FLASH_LOAN_RESPONSE;\n    }\n}"
    },
    {
      "filename": "contracts/compound/libraries/LibCollateralSwap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.7;\n\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IComet} from \"../interfaces/IComet.sol\";\n\nlibrary LibCollateralSwap {\n    using SafeMath for uint256;\n\n    error WidoRouterFailed();\n\n    struct Collateral {\n        address addr;\n        uint256 amount;\n    }\n\n    struct Signatures {\n        Signature allow;\n        Signature revoke;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct WidoSwap {\n        address router;\n        address tokenManager;\n        bytes callData;\n    }\n\n    /// @dev Performs all the steps to swap collaterals on the Comet contract\n    function performCollateralSwap(\n        address borrowedAsset,\n        uint256 borrowedAmount,\n        uint256 fee,\n        bytes memory data\n    ) external {\n        // decode payload\n        (\n        address user,\n        IComet comet,\n        Collateral memory existingCollateral,\n        Signatures memory signatures,\n        WidoSwap memory swapDetails\n        ) = abi.decode(\n            data,\n            (address, IComet, Collateral, Signatures, WidoSwap)\n        );\n\n        // supply new collateral on behalf of user\n        _supplyTo(comet, user, borrowedAsset, borrowedAmount.sub(fee));\n\n        // withdraw existing collateral\n        _withdrawFrom(comet, user, existingCollateral, signatures);\n\n        // execute swap\n        _swap(existingCollateral, swapDetails);\n\n        // check amount of surplus collateral\n        uint256 surplusAmount = IERC20(borrowedAsset).balanceOf(address(this)) - borrowedAmount - fee;\n\n        // if positive slippage, supply extra to user\n        if (surplusAmount > 0) {\n            _supplyTo(comet, user, borrowedAsset, surplusAmount);\n        }\n    }\n\n    /// @dev Performs the swap of the collateral on the WidoRouter\n    function _swap(\n        Collateral memory collateral,\n        WidoSwap memory swap\n    ) internal {\n        // approve WidoTokenManager initial collateral to make the swap\n        IERC20(collateral.addr).approve(\n            swap.tokenManager,\n            collateral.amount\n        );\n\n        // execute swap\n        (bool success, bytes memory result) = swap.router.call(swap.callData);\n\n        if (!success) {\n            if (result.length < 68) revert WidoRouterFailed();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n    }\n\n    /// @dev Supplies collateral on behalf of user\n    function _supplyTo(\n        IComet comet,\n        address user,\n        address asset,\n        uint256 amount\n    ) internal {\n        IERC20(asset).approve(address(comet), amount);\n        comet.supplyTo(user, asset, amount);\n    }\n\n    /// @dev This function withdraws the collateral from the user.\n    ///  It requires two consecutive EIP712 signatures to allow and revoke\n    ///  permissions to and from this contract.\n    function _withdrawFrom(\n        IComet comet,\n        address user,\n        Collateral memory collateral,\n        Signatures memory sigs\n    ) internal {\n        // get current nonce\n        uint256 nonce = comet.userNonce(user);\n        // allow the contract\n        _allowBySig(comet, user, true, nonce, sigs.allow);\n        // withdraw assets\n        comet.withdrawFrom(user, address(this), collateral.addr, collateral.amount);\n        // increment nonce\n        unchecked { nonce++; }\n        // revoke permission\n        _allowBySig(comet, user, false, nonce, sigs.revoke);\n    }\n\n    /// @dev Executes a single `allowBySig` operation on the Comet contract\n    function _allowBySig(\n        IComet comet,\n        address user,\n        bool allowed,\n        uint256 nonce,\n        Signature memory sig\n    ) internal {\n        comet.allowBySig(\n            user,\n            address(this),\n            allowed,\n            nonce,\n            10e9,\n            sig.v,\n            sig.r,\n            sig.s\n        );\n    }\n\n}"
    }
  ]
}