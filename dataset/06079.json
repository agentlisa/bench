{
  "Title": "[L-01] `guardian` can fast track every proposal",
  "Content": "In `TemporalGovernor` the `guardian` has a special permission that they can `fastTrackProposalExecution` which will [bypass the normal `queueProposal` flow](https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L354-L367):\n\nhttps://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/Governance/TemporalGovernor.sol#L261-L268\n```solidity\nFile: core/Governance/TemporalGovernor.sol\n\n261:    /// @notice Allow the guardian to process a VAA when the\n262:    /// Temporal Governor is paused this is only for use during\n263:    /// periods of emergency when the governance on moonbeam is\n264:    /// compromised and we need to stop additional proposals from going through.\n265:    /// @param VAA The signed Verified Action Approval to process\n266:    function fastTrackProposalExecution(bytes memory VAA) external onlyOwner {\n267:        _executeProposal(VAA, true); /// override timestamp checks and execute\n268:    }\n```\n\nThis as the comment suggest should only be done in emergencies.\n\nHowever there is nothing indicating that the `VAA` in question is supposed to be fast tracked. Hence a `guardian` can always fast track any `VAA`s that they please, bypassing the `queueProposal` functionality.\n\n### Recommendation\nConsider adding another parameter to the `payload` indicating if the `VAA` is intended to be fast tracked or not.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-moonwell",
  "Code": [
    {
      "filename": "src/core/Governance/TemporalGovernor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IWormhole} from \"@protocol/core/Governance/IWormhole.sol\";\n\nimport {ITemporalGovernor} from \"@protocol/core/Governance/ITemporalGovernor.sol\";\n\n/// @notice contract that governs the Base deployment of moonwell leveraging the wormhole bridge\n/// as the source of truth. Wormhole will be fed in actions from the moonbeam chain and this contract\n/// will execute them on base.\n/// There are a few assumptions that are made in this contract:\n/// 1. Wormhole is secure and will not send malicious messages or be deactivated.\n/// 2. Moonbeam is secure.\n/// 3. Governance on Moonbeam cannot be compromised.\n/// if 1. is untrue and wormhole is deactivated, then this contract will be unable to upgrade the base instance\n/// if 1. is untrue and wormhole sends malicious messages, then this contract will be paused, and the guardian\n/// will have to fast track a proposal to hand ownership to a new governor, and wormhole will have to revoke\n/// the permissions on the compromised validator set.\n/// if 2. is untrue, then this contract will be paused until moonbeam is restored\n/// if 3. is untrue, then this contract will be paused until moonbeam governance is restored, if gov control\n/// cannot be restored, then this governance will be compromised.\ncontract TemporalGovernor is ITemporalGovernor, Ownable, Pausable {\n    using SafeCast for *;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// ----------- IMMUTABLES -----------\n\n    /// @notice reference to the wormhole bridge\n    IWormhole public immutable wormholeBridge;\n\n    /// @notice returns the amount of time a proposal must wait before being processed.\n    uint256 public immutable proposalDelay;\n\n    /// @notice returns the amount of time until this contract can be unpaused permissionlessly\n    uint256 public immutable permissionlessUnpauseTime;\n\n    /// ----------- SINGLE STORAGE SLOT -----------\n\n    /// @notice last paused time\n    uint248 public lastPauseTime;\n\n    /// @notice returns whether or not the guardian can pause.\n    /// starts true and then is turned false when the guardian pauses\n    /// governance can then reactivate it.\n    bool public guardianPauseAllowed = true;\n\n    /// ----------- MAPPINGS -----------\n\n    /// @notice Map of chain id => trusted sender\n    mapping(uint16 => EnumerableSet.Bytes32Set) private trustedSenders;\n\n    /// @notice Record of processed messages to prevent replaying\n    /// and enforce time limits are respected\n    mapping(bytes32 => ProposalInfo) public queuedTransactions;\n\n    constructor(\n        address wormholeCore,\n        uint256 _proposalDelay,\n        uint256 _permissionlessUnpauseTime,\n        TrustedSender[] memory _trustedSenders\n    ) Ownable() {\n        wormholeBridge = IWormhole(wormholeCore);\n        proposalDelay = _proposalDelay;\n        permissionlessUnpauseTime = _permissionlessUnpauseTime;\n\n        // Using https://book.wormhole.com/reference/contracts.html#testnet chain ids and local contracts\n        // Mark 0xf16165f1046f1b3cdb37da25e835b986e696313a as trusted to emit from eth mainnet\n        // Establish a list of trusted emitters from eash chain\n        for (uint256 i = 0; i < _trustedSenders.length; i++) {\n            trustedSenders[_trustedSenders[i].chainId].add(\n                addressToBytes(_trustedSenders[i].addr)\n            );\n        }\n    }\n\n    /// ------------- VIEW ONLY API -------------\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        bytes32 addr\n    ) public view returns (bool) {\n        return trustedSenders[chainId].contains(addr);\n    }\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        address addr\n    ) external view returns (bool) {\n        return isTrustedSender(chainId, addressToBytes(addr));\n    }\n\n    /// @notice returns the list of trusted senders for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @return The list of trusted senders\n    function allTrustedSenders(uint16 chainId)\n        external\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory trustedSendersList = new bytes32[](\n            trustedSenders[chainId].length()\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < trustedSendersList.length; i++) {\n                trustedSendersList[i] = trustedSenders[chainId].at(i);\n            }\n        }\n\n        return trustedSendersList;\n    }\n\n    /// @notice Wormhole addresses are denominated in 32 byte chunks. Converting the address to a bytes20\n    /// then to a bytes32 *left* aligns it, so we right shift to get the proper data\n    /// @param addr The address to convert\n    /// @return The address as a bytes32\n    function addressToBytes(address addr) public pure returns (bytes32) {\n        return bytes32(bytes20(addr)) >> 96;\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Updates the list of trusted senders\n    /// @param _trustedSenders The list of trusted senders, allowing one\n    /// trusted sender per chain id\n    function setTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].add(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    true /// added to list\n                );\n            }\n        }\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Removes trusted senders from the list\n    /// @param _trustedSenders The list of trusted senders, allowing multiple\n    /// trusted sender per chain id\n    function unSetTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].remove(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    false /// removed from list\n                );\n            }\n        }\n    }\n\n    /// @notice grant the guardians the pause ability\n    function grantGuardiansPause() external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update grant guardian pause\"\n        );\n\n        guardianPauseAllowed = true;\n        lastPauseTime = 0;\n\n        emit GuardianPauseGranted(block.timestamp);\n    }\n\n    /// ------------- GUARDIAN / GOVERNOR ONLY API -------------\n\n    /// @notice callable only via a gov proposal (governance) or by the guardian\n    /// this revokes guardian's ability, no more pausing or fast tracking and\n    /// unpauses the contract if paused\n    function revokeGuardian() external {\n        address oldGuardian = owner();\n        require(\n            msg.sender == oldGuardian || msg.sender == address(this),\n            \"TemporalGovernor: cannot revoke guardian\"\n        );\n\n        _transferOwnership(address(0));\n        guardianPauseAllowed = false;\n        lastPauseTime = 0;\n\n        if (paused()) {\n            _unpause();\n        }\n\n        emit GuardianRevoked(oldGuardian);\n    }\n\n    /// ------------- PERMISSIONLESS APIs -------------\n\n    /// @notice We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    /// @dev callable only when unpaused\n    function queueProposal(bytes memory VAA) external whenNotPaused {\n        _queueProposal(VAA);\n    }\n\n    /// @notice Taken mostly from the best practices docs from wormhole.\n    /// We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    function executeProposal(bytes memory VAA) public whenNotPaused {\n        _executeProposal(VAA, false);\n    }\n\n    /// @notice unpauses the contract, and blocks the guardian from pausing again until governance reapproves them\n    function permissionlessUnpause() external whenPaused {\n        /// lastPauseTime cannot be equal to 0 at this point because\n        /// block.timstamp on a real chain will always be gt 0 and\n        /// toggle pause will set lastPauseTime to block.timestamp\n        /// which means if the contract is paused on a live network,\n        /// its lastPauseTime cannot be 0\n        require(\n            lastPauseTime + permissionlessUnpauseTime <= block.timestamp,\n            \"TemporalGovernor: not past pause window\"\n        );\n\n        lastPauseTime = 0;\n        _unpause();\n\n        assert(!guardianPauseAllowed); /// this should never revert, statement for SMT solving\n\n        emit PermissionlessUnpaused(block.timestamp);\n    }\n\n    /// @notice Allow the guardian to process a VAA when the\n    /// Temporal Governor is paused this is only for use during\n    /// periods of emergency when the governance on moonbeam is\n    /// compromised and we need to stop additional proposals from going through.\n    /// @param VAA The signed Verified Action Approval to process\n    function fastTrackProposalExecution(bytes memory VAA) external onlyOwner {\n        _executeProposal(VAA, true); /// override timestamp checks and execute\n    }\n\n    /// @notice Allow the guardian to pause the contract\n    /// removes the guardians ability to call pause again until governance reaaproves them\n    /// starts the timer for the permissionless unpause\n    /// cannot call this function if guardian is revoked\n    function togglePause() external onlyOwner {\n        if (paused()) {\n            _unpause();\n        } else {\n            require(\n                guardianPauseAllowed,\n                \"TemporalGovernor: guardian pause not allowed\"\n            );\n\n            guardianPauseAllowed = false;\n            lastPauseTime = block.timestamp.toUint248();\n            _pause();\n        }\n\n        /// statement for SMT solver\n        assert(!guardianPauseAllowed); /// this should be an unreachable state\n    }\n\n    /// ------------- HELPER FUNCTIONS -------------\n\n    /// queue a proposal\n    function _queueProposal(bytes memory VAA) private {\n        /// Checks\n\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        // Ensure VAA parsing verification succeeded.\n        require(valid, reason);\n\n        address intendedRecipient;\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n\n        (intendedRecipient, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        // Very important to check to make sure that the VAA we're processing is specifically designed\n        // to be sent to this contract\n        require(intendedRecipient == address(this), \"TemporalGovernor: Incorrect destination\");\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        /// Check that the VAA hasn't already been processed (replay protection)\n        require(\n            queuedTransactions[vm.hash].queueTime == 0,\n            \"TemporalGovernor: Message already queued\"\n        );\n\n        /// Effect\n\n        // Add the VAA to queued messages so that it can't be replayed\n        queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n\n        emit QueuedTransaction(intendedRecipient, targets, values, calldatas);\n    }\n\n    function _executeProposal(bytes memory VAA, bool overrideDelay) private {\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        require(valid, reason); /// ensure VAA parsing verification succeeded\n\n        if (!overrideDelay) {\n            require(\n                queuedTransactions[vm.hash].queueTime != 0,\n                \"TemporalGovernor: tx not queued\"\n            );\n            require(\n                queuedTransactions[vm.hash].queueTime + proposalDelay <=\n                    block.timestamp,\n                \"TemporalGovernor: timelock not finished\"\n            );\n        } else if (queuedTransactions[vm.hash].queueTime == 0) {\n            /// if queue time is 0 due to fast track execution, set it to current block timestamp\n            queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n        }\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        require(\n            !queuedTransactions[vm.hash].executed,\n            \"TemporalGovernor: tx already executed\"\n        );\n\n        queuedTransactions[vm.hash].executed = true;\n\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n        (, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        /// Interaction (s)\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        for (uint256 i = 0; i < targets.length; i++) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes memory data = calldatas[i];\n\n            // Go make our call, and if it is not successful revert with the error bubbling up\n            (bool success, bytes memory returnData) = target.call{value: value}(\n                data\n            );\n\n            /// revert on failure with error message if any\n            require(success, string(returnData));\n\n            emit ExecutedTransaction(target, value, data);\n        }\n    }\n\n    /// @notice arity check for payload\n    function _sanityCheckPayload(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas\n    ) private pure {\n        require(targets.length != 0, \"TemporalGovernor: Empty proposal\");\n        require(\n            targets.length == values.length &&\n                targets.length == calldatas.length,\n            \"TemporalGovernor: Arity mismatch for payload\"\n        );\n    }\n}"
    },
    {
      "filename": "src/core/Governance/TemporalGovernor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IWormhole} from \"@protocol/core/Governance/IWormhole.sol\";\n\nimport {ITemporalGovernor} from \"@protocol/core/Governance/ITemporalGovernor.sol\";\n\n/// @notice contract that governs the Base deployment of moonwell leveraging the wormhole bridge\n/// as the source of truth. Wormhole will be fed in actions from the moonbeam chain and this contract\n/// will execute them on base.\n/// There are a few assumptions that are made in this contract:\n/// 1. Wormhole is secure and will not send malicious messages or be deactivated.\n/// 2. Moonbeam is secure.\n/// 3. Governance on Moonbeam cannot be compromised.\n/// if 1. is untrue and wormhole is deactivated, then this contract will be unable to upgrade the base instance\n/// if 1. is untrue and wormhole sends malicious messages, then this contract will be paused, and the guardian\n/// will have to fast track a proposal to hand ownership to a new governor, and wormhole will have to revoke\n/// the permissions on the compromised validator set.\n/// if 2. is untrue, then this contract will be paused until moonbeam is restored\n/// if 3. is untrue, then this contract will be paused until moonbeam governance is restored, if gov control\n/// cannot be restored, then this governance will be compromised.\ncontract TemporalGovernor is ITemporalGovernor, Ownable, Pausable {\n    using SafeCast for *;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// ----------- IMMUTABLES -----------\n\n    /// @notice reference to the wormhole bridge\n    IWormhole public immutable wormholeBridge;\n\n    /// @notice returns the amount of time a proposal must wait before being processed.\n    uint256 public immutable proposalDelay;\n\n    /// @notice returns the amount of time until this contract can be unpaused permissionlessly\n    uint256 public immutable permissionlessUnpauseTime;\n\n    /// ----------- SINGLE STORAGE SLOT -----------\n\n    /// @notice last paused time\n    uint248 public lastPauseTime;\n\n    /// @notice returns whether or not the guardian can pause.\n    /// starts true and then is turned false when the guardian pauses\n    /// governance can then reactivate it.\n    bool public guardianPauseAllowed = true;\n\n    /// ----------- MAPPINGS -----------\n\n    /// @notice Map of chain id => trusted sender\n    mapping(uint16 => EnumerableSet.Bytes32Set) private trustedSenders;\n\n    /// @notice Record of processed messages to prevent replaying\n    /// and enforce time limits are respected\n    mapping(bytes32 => ProposalInfo) public queuedTransactions;\n\n    constructor(\n        address wormholeCore,\n        uint256 _proposalDelay,\n        uint256 _permissionlessUnpauseTime,\n        TrustedSender[] memory _trustedSenders\n    ) Ownable() {\n        wormholeBridge = IWormhole(wormholeCore);\n        proposalDelay = _proposalDelay;\n        permissionlessUnpauseTime = _permissionlessUnpauseTime;\n\n        // Using https://book.wormhole.com/reference/contracts.html#testnet chain ids and local contracts\n        // Mark 0xf16165f1046f1b3cdb37da25e835b986e696313a as trusted to emit from eth mainnet\n        // Establish a list of trusted emitters from eash chain\n        for (uint256 i = 0; i < _trustedSenders.length; i++) {\n            trustedSenders[_trustedSenders[i].chainId].add(\n                addressToBytes(_trustedSenders[i].addr)\n            );\n        }\n    }\n\n    /// ------------- VIEW ONLY API -------------\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        bytes32 addr\n    ) public view returns (bool) {\n        return trustedSenders[chainId].contains(addr);\n    }\n\n    /// @notice returns whether or not the address is in the trusted senders list for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @param addr The address to check\n    function isTrustedSender(\n        uint16 chainId,\n        address addr\n    ) external view returns (bool) {\n        return isTrustedSender(chainId, addressToBytes(addr));\n    }\n\n    /// @notice returns the list of trusted senders for a given chain\n    /// @param chainId The wormhole chain id to check\n    /// @return The list of trusted senders\n    function allTrustedSenders(uint16 chainId)\n        external\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory trustedSendersList = new bytes32[](\n            trustedSenders[chainId].length()\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < trustedSendersList.length; i++) {\n                trustedSendersList[i] = trustedSenders[chainId].at(i);\n            }\n        }\n\n        return trustedSendersList;\n    }\n\n    /// @notice Wormhole addresses are denominated in 32 byte chunks. Converting the address to a bytes20\n    /// then to a bytes32 *left* aligns it, so we right shift to get the proper data\n    /// @param addr The address to convert\n    /// @return The address as a bytes32\n    function addressToBytes(address addr) public pure returns (bytes32) {\n        return bytes32(bytes20(addr)) >> 96;\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Updates the list of trusted senders\n    /// @param _trustedSenders The list of trusted senders, allowing one\n    /// trusted sender per chain id\n    function setTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].add(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    true /// added to list\n                );\n            }\n        }\n    }\n\n    /// @notice only callable through a governance proposal\n    /// @dev Removes trusted senders from the list\n    /// @param _trustedSenders The list of trusted senders, allowing multiple\n    /// trusted sender per chain id\n    function unSetTrustedSenders(\n        TrustedSender[] calldata _trustedSenders\n    ) external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update trusted senders\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _trustedSenders.length; i++) {\n                trustedSenders[_trustedSenders[i].chainId].remove(\n                    addressToBytes(_trustedSenders[i].addr)\n                );\n\n                emit TrustedSenderUpdated(\n                    _trustedSenders[i].chainId,\n                    _trustedSenders[i].addr,\n                    false /// removed from list\n                );\n            }\n        }\n    }\n\n    /// @notice grant the guardians the pause ability\n    function grantGuardiansPause() external {\n        require(\n            msg.sender == address(this),\n            \"TemporalGovernor: Only this contract can update grant guardian pause\"\n        );\n\n        guardianPauseAllowed = true;\n        lastPauseTime = 0;\n\n        emit GuardianPauseGranted(block.timestamp);\n    }\n\n    /// ------------- GUARDIAN / GOVERNOR ONLY API -------------\n\n    /// @notice callable only via a gov proposal (governance) or by the guardian\n    /// this revokes guardian's ability, no more pausing or fast tracking and\n    /// unpauses the contract if paused\n    function revokeGuardian() external {\n        address oldGuardian = owner();\n        require(\n            msg.sender == oldGuardian || msg.sender == address(this),\n            \"TemporalGovernor: cannot revoke guardian\"\n        );\n\n        _transferOwnership(address(0));\n        guardianPauseAllowed = false;\n        lastPauseTime = 0;\n\n        if (paused()) {\n            _unpause();\n        }\n\n        emit GuardianRevoked(oldGuardian);\n    }\n\n    /// ------------- PERMISSIONLESS APIs -------------\n\n    /// @notice We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    /// @dev callable only when unpaused\n    function queueProposal(bytes memory VAA) external whenNotPaused {\n        _queueProposal(VAA);\n    }\n\n    /// @notice Taken mostly from the best practices docs from wormhole.\n    /// We explicitly don't care who is relaying this, as long\n    /// as the VAA is only processed once AND, critically, intended for this contract.\n    /// @param VAA The signed Verified Action Approval to process\n    function executeProposal(bytes memory VAA) public whenNotPaused {\n        _executeProposal(VAA, false);\n    }\n\n    /// @notice unpauses the contract, and blocks the guardian from pausing again until governance reapproves them\n    function permissionlessUnpause() external whenPaused {\n        /// lastPauseTime cannot be equal to 0 at this point because\n        /// block.timstamp on a real chain will always be gt 0 and\n        /// toggle pause will set lastPauseTime to block.timestamp\n        /// which means if the contract is paused on a live network,\n        /// its lastPauseTime cannot be 0\n        require(\n            lastPauseTime + permissionlessUnpauseTime <= block.timestamp,\n            \"TemporalGovernor: not past pause window\"\n        );\n\n        lastPauseTime = 0;\n        _unpause();\n\n        assert(!guardianPauseAllowed); /// this should never revert, statement for SMT solving\n\n        emit PermissionlessUnpaused(block.timestamp);\n    }\n\n    /// @notice Allow the guardian to process a VAA when the\n    /// Temporal Governor is paused this is only for use during\n    /// periods of emergency when the governance on moonbeam is\n    /// compromised and we need to stop additional proposals from going through.\n    /// @param VAA The signed Verified Action Approval to process\n    function fastTrackProposalExecution(bytes memory VAA) external onlyOwner {\n        _executeProposal(VAA, true); /// override timestamp checks and execute\n    }\n\n    /// @notice Allow the guardian to pause the contract\n    /// removes the guardians ability to call pause again until governance reaaproves them\n    /// starts the timer for the permissionless unpause\n    /// cannot call this function if guardian is revoked\n    function togglePause() external onlyOwner {\n        if (paused()) {\n            _unpause();\n        } else {\n            require(\n                guardianPauseAllowed,\n                \"TemporalGovernor: guardian pause not allowed\"\n            );\n\n            guardianPauseAllowed = false;\n            lastPauseTime = block.timestamp.toUint248();\n            _pause();\n        }\n\n        /// statement for SMT solver\n        assert(!guardianPauseAllowed); /// this should be an unreachable state\n    }\n\n    /// ------------- HELPER FUNCTIONS -------------\n\n    /// queue a proposal\n    function _queueProposal(bytes memory VAA) private {\n        /// Checks\n\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        // Ensure VAA parsing verification succeeded.\n        require(valid, reason);\n\n        address intendedRecipient;\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n\n        (intendedRecipient, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        // Very important to check to make sure that the VAA we're processing is specifically designed\n        // to be sent to this contract\n        require(intendedRecipient == address(this), \"TemporalGovernor: Incorrect destination\");\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        /// Check that the VAA hasn't already been processed (replay protection)\n        require(\n            queuedTransactions[vm.hash].queueTime == 0,\n            \"TemporalGovernor: Message already queued\"\n        );\n\n        /// Effect\n\n        // Add the VAA to queued messages so that it can't be replayed\n        queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n\n        emit QueuedTransaction(intendedRecipient, targets, values, calldatas);\n    }\n\n    function _executeProposal(bytes memory VAA, bool overrideDelay) private {\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n\n        require(valid, reason); /// ensure VAA parsing verification succeeded\n\n        if (!overrideDelay) {\n            require(\n                queuedTransactions[vm.hash].queueTime != 0,\n                \"TemporalGovernor: tx not queued\"\n            );\n            require(\n                queuedTransactions[vm.hash].queueTime + proposalDelay <=\n                    block.timestamp,\n                \"TemporalGovernor: timelock not finished\"\n            );\n        } else if (queuedTransactions[vm.hash].queueTime == 0) {\n            /// if queue time is 0 due to fast track execution, set it to current block timestamp\n            queuedTransactions[vm.hash].queueTime = block.timestamp.toUint248();\n        }\n\n        // Ensure the emitterAddress of this VAA is a trusted address\n        require(\n            trustedSenders[vm.emitterChainId].contains(vm.emitterAddress), /// allow multiple per chainid\n            \"TemporalGovernor: Invalid Emitter Address\"\n        );\n\n        require(\n            !queuedTransactions[vm.hash].executed,\n            \"TemporalGovernor: tx already executed\"\n        );\n\n        queuedTransactions[vm.hash].executed = true;\n\n        address[] memory targets; /// contracts to call\n        uint256[] memory values; /// native token amount to send\n        bytes[] memory calldatas; /// calldata to send\n        (, targets, values, calldatas) = abi.decode(\n            vm.payload,\n            (address, address[], uint256[], bytes[])\n        );\n\n        /// Interaction (s)\n\n        _sanityCheckPayload(targets, values, calldatas);\n\n        for (uint256 i = 0; i < targets.length; i++) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes memory data = calldatas[i];\n\n            // Go make our call, and if it is not successful revert with the error bubbling up\n            (bool success, bytes memory returnData) = target.call{value: value}(\n                data\n            );\n\n            /// revert on failure with error message if any\n            require(success, string(returnData));\n\n            emit ExecutedTransaction(target, value, data);\n        }\n    }\n\n    /// @notice arity check for payload\n    function _sanityCheckPayload(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas\n    ) private pure {\n        require(targets.length != 0, \"TemporalGovernor: Empty proposal\");\n        require(\n            targets.length == values.length &&\n                targets.length == calldatas.length,\n            \"TemporalGovernor: Arity mismatch for payload\"\n        );\n    }\n}"
    }
  ]
}