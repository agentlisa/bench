{
  "Title": "[H-07] Incorrect math means `data.removeAndRepayData.removeAssetFromSGL` will never work once SGL has accrued interest",
  "Content": "\nThe code to remove shares from Singularity is as follows:\n\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/2ddbcb1cde03b548e13421b2dba66435d2ac8eb5/contracts/Magnetar/modules/MagnetarOptionModule.sol#L158-L159>\n\n```solidity\n            singularity_.removeAsset(data.user, removeAssetTo, share);\n```\n\nWhere `share` is computed in this way:\n\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/2ddbcb1cde03b548e13421b2dba66435d2ac8eb5/contracts/Magnetar/modules/MagnetarOptionModule.sol#L153>\n\n```solidity\nuint256 share = yieldBox_.toShare(_assetId, _removeAmount, false);\n```\n\nThe line is calculating: The (incorrectly rounded down) amount of shares of Yieldbox to burn in order to withdraw from Yieldbox the `_removeAmount`.\n\nBut the code is calling:\n\n`singularity_.removeAsset(data.user, removeAssetTo, share);`\n\nThis is asking Singularity to remove a % (part) of the total assets in Singularity. Due to this, the line will stop working as soon as singularity has had any operation that generated interest.\n\n### Proof of Concept\n\nPlease see the formula used by Singularity for pricing asset:\n\n<https://github.com/Tapioca-DAO/Tapioca-bar/blob/c2031ac2e2667ac8f9ac48eaedae3dd52abef559/contracts/markets/singularity/SGLCommon.sol#L199-L216>\n\n```solidity\n    function _removeAsset(address from, address to, uint256 fraction) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);\n        share = (fraction * allShare) / _totalAsset.base;\n    }\n```\n\nAs you can see, the `fraction` will be computed against `_totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);`. Meaning that the math will be incorrect as soon as any operation is done in Singularity\n\n### Coded POC\n\nThis Poc is built on the public repo: <https://github.com/GalloDaSballo/yieldbox-foundry>\n\nWe show how a change in interest will change `fraction`. In my local testing, `fraction` and `shares` are already out of sync. However, due to decimals it may be possible for them to be the same value, until some interest will make `borrowElastic` grow.\n\n### Logs\n\n```\n[PASS] testSingularityRebasedMathIsNotYieldbox() (gas: 34810)\nLogs:\nfraction 999999990000000099999\nshare 100000000000000000000000000000\n\n[PASS] testSingularityRebasedMathIsNotYieldboxAfterInterest() (gas: 34756)\nLogs:\nfraction 666666662222222251851\nshare 100000000000000000000000000000\n```\n\n### Code\n\n```solidity\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {TargetFunctions} from \"./TargetFunctions.sol\";\nimport {FoundryAsserts} from \"@chimera/FoundryAsserts.sol\";\n\ncontract CryticToFoundry is Test, TargetFunctions, FoundryAsserts {\n    function setUp() public {\n        setup();\n    }\n\n    \n    function testSingularityRebasedMathIsNotYieldbox() public {        \n        uint256 amountToRepay = 1000e18;\n\n        uint256 totalAssetShares = 2000e18;\n        uint256 totalAssetBase = 2000e18;\n        uint256 totalBorrowElastic = 2000e18;\n\n        uint256 share = yieldBox.toShare(assetId, amountToRepay, false);\n        uint256 allShare = totalAssetShares + yieldBox.toShare(assetId, totalBorrowElastic, true);\n\n        uint256 fraction = allShare == 0 ? share : (share * totalAssetBase) / allShare;\n        console2.log(\"fraction\", fraction);\n        console2.log(\"share\", share);\n    }\n\n    function testSingularityRebasedMathIsNotYieldboxAfterInterest() public {        \n        uint256 amountToRepay = 1000e18;\n\n        uint256 totalAssetShares = 2000e18;\n        uint256 totalAssetBase = 2000e18;\n        uint256 totalBorrowElastic = 3000e18; // NOTE: Higher cause of interest\n\n        uint256 share = yieldBox.toShare(assetId, amountToRepay, false);\n        uint256 allShare = totalAssetShares + yieldBox.toShare(assetId, totalBorrowElastic, true);\n\n        uint256 fraction = allShare == 0 ? share : (share * totalAssetBase) / allShare;\n        console2.log(\"fraction\", fraction);\n        console2.log(\"share\", share);\n    }\n}\n```\n\n### Mitigation\n\nThe unused function `getFractionForAmount` should help, minus some possible rounding considerations.\n\n**[cryptotechmaker (Tapioca) confirmed, but disagreed with severity and commented via duplicate Issue #159](https://github.com/code-423n4/2024-02-tapioca-findings/issues/159#issuecomment-2034483179):**\n> PR [here](https://github.com/Tapioca-DAO/tapioca-periph/commit/a22fdf0efe5a63538e072f4947ed65fd72e029a2).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/modules/MagnetarOptionModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {\n    ExitPositionAndRemoveCollateralData, MagnetarWithdrawData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOption} from \"tapioca-periph/interfaces/tap-token/ITapiocaOption.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {MagnetarBaseModule} from \"./MagnetarBaseModule.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarOptionModule\n * @author TapiocaDAO\n * @notice Magnetar options related operations\n */\ncontract MagnetarOptionModule is MagnetarBaseModule {\n    using SafeERC20 for IERC20;\n\n    error Magnetar_ActionParamsMismatch();\n    error Magnetar_tOLPTokenMismatch();\n    error Magnetar_MarketCallFailed(bytes call);\n\n    /**\n     * @notice helper to exit from  tOB, unlock from tOLP, remove from SGL, repay on BB, remove collateral from BB and withdraw\n     * @dev all steps are optional:\n     *         - if `removeAndRepayData.exitData.exit` is false, the exit operation is skipped\n     *         - if `removeAndRepayData.unlockData.unlock` is false, the unlock operation is skipped\n     *         - if `removeAndRepayData.removeAssetFromSGL` is false, the removeAsset operation is skipped\n     *         - if `!removeAndRepayData.assetWithdrawData.withdraw && removeAndRepayData.repayAssetOnBB`, the repay operation is performed\n     *         - if `removeAndRepayData.removeCollateralFromBB` is false, the rmeove collateral is skipped\n     *     - the helper can either stop at the remove asset from SGL step or it can continue until is removes & withdraws collateral from BB\n     *         - removed asset can be withdrawn by providing `removeAndRepayData.assetWithdrawData`\n     *     - BB collateral can be removed by providing `removeAndRepayData.collateralWithdrawData`\n     */\n    function exitPositionAndRemoveCollateral(ExitPositionAndRemoveCollateralData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        // Check whitelisted\n        if (data.externalData.bigBang != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.bigBang)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.bigBang);\n            }\n        }\n        if (data.externalData.singularity != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.singularity)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.singularity);\n            }\n        }\n\n        IMarket bigBang_ = IMarket(data.externalData.bigBang);\n        ISingularity singularity_ = ISingularity(data.externalData.singularity);\n        IYieldBox yieldBox_ = IYieldBox(singularity_.yieldBox());\n\n        // if `removeAndRepayData.exitData.exit` the following operations are performed\n        //      - if ownerOfTapTokenId is user, transfers the oTAP token id to this contract\n        //      - tOB.exitPosition\n        //      - if `!removeAndRepayData.unlockData.unlock`, transfer the obtained tokenId to the user\n        uint256 tOLPId = 0;\n        if (data.removeAndRepayData.exitData.exit) {\n            if (data.removeAndRepayData.exitData.oTAPTokenID == 0) revert Magnetar_ActionParamsMismatch();\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.exitData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.exitData.target);\n            }\n\n            address oTapAddress = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).oTAP();\n            (, ITapiocaOption.TapOption memory oTAPPosition) =\n                ITapiocaOption(oTapAddress).attributes(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            tOLPId = oTAPPosition.tOLP;\n\n            address ownerOfTapTokenId = IERC721(oTapAddress).ownerOf(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            if (ownerOfTapTokenId != data.user && ownerOfTapTokenId != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n            if (ownerOfTapTokenId == data.user) {\n                // IERC721(oTapAddress).safeTransferFrom(\n                //     data.user, address(this), data.removeAndRepayData.exitData.oTAPTokenID, \"0x\"\n                // );\n                bool isErr = pearlmit.transferFromERC721(\n                    data.user, address(this), oTapAddress, data.removeAndRepayData.exitData.oTAPTokenID\n                );\n                if (isErr) revert Magnetar_ExtractTokenFail();\n            }\n            ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).exitPosition(\n                data.removeAndRepayData.exitData.oTAPTokenID\n            );\n\n            if (!data.removeAndRepayData.unlockData.unlock) {\n                address tOLPContract = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).tOLP();\n\n                //transfer tOLP to the data.user\n                IERC721(tOLPContract).safeTransferFrom(address(this), data.user, tOLPId, \"0x\");\n            }\n        }\n\n        // performs a tOLP.unlock operation\n        if (data.removeAndRepayData.unlockData.unlock) {\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.unlockData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.unlockData.target);\n            }\n\n            if (data.removeAndRepayData.unlockData.tokenId != 0) {\n                if (tOLPId != 0) {\n                    if (tOLPId != data.removeAndRepayData.unlockData.tokenId) {\n                        revert Magnetar_tOLPTokenMismatch();\n                    }\n                }\n                tOLPId = data.removeAndRepayData.unlockData.tokenId;\n            }\n\n            address ownerOfTOLP = IERC721(data.removeAndRepayData.unlockData.target).ownerOf(tOLPId);\n\n            if (ownerOfTOLP != data.user && ownerOfTOLP != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n\n            ITapiocaOptionLiquidityProvision(data.removeAndRepayData.unlockData.target).unlock(\n                tOLPId, data.externalData.singularity, data.user\n            );\n        }\n\n        // if `data.removeAndRepayData.removeAssetFromSGL` performs the follow operations:\n        //      - removeAsset from SGL\n        //      - if `data.removeAndRepayData.assetWithdrawData.withdraw` withdraws by using the `withdrawTo` operation\n        uint256 _removeAmount = data.removeAndRepayData.removeAmount;\n        if (data.removeAndRepayData.removeAssetFromSGL) {\n            uint256 _assetId = singularity_.assetId();\n            uint256 share = yieldBox_.toShare(_assetId, _removeAmount, false);\n\n            address removeAssetTo = data.removeAndRepayData.assetWithdrawData.withdraw\n                || data.removeAndRepayData.repayAssetOnBB ? address(this) : data.user;\n\n            singularity_.removeAsset(data.user, removeAssetTo, share);\n\n            //withdraw\n            if (data.removeAndRepayData.assetWithdrawData.withdraw) {\n                uint256 computedAmount = yieldBox_.toAmount(_assetId, share, false);\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.amountLD = computedAmount;\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.minAmountLD = computedAmount;\n                _withdrawToChain(data.removeAndRepayData.assetWithdrawData);\n            }\n        }\n\n        // performs a BigBang repay operation\n        if (!data.removeAndRepayData.assetWithdrawData.withdraw && data.removeAndRepayData.repayAssetOnBB) {\n            _setApprovalForYieldBox(address(bigBang_), yieldBox_);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper).repay(\n                address(this), data.user, false, data.removeAndRepayData.repayAmount\n            );\n            (bool[] memory successes, bytes[] memory results) = bigBang_.execute(modules, calls, true);\n\n            if (!successes[0]) revert Magnetar_MarketCallFailed(calls[0]);\n            uint256 repayed = IMarketHelper(data.externalData.marketHelper).repayView(results[0]);\n            // transfer excess amount to the data.user\n            if (repayed < _removeAmount) {\n                uint256 bbAssetId = bigBang_.assetId();\n                yieldBox_.transfer(\n                    address(this), data.user, bbAssetId, yieldBox_.toShare(bbAssetId, _removeAmount - repayed, false)\n                );\n            }\n        }\n\n        // performs a BigBang removeCollateral operation\n        // if `data.removeAndRepayData.collateralWithdrawData.withdraw` withdraws by using the `withdrawTo` method\n        if (data.removeAndRepayData.removeCollateralFromBB) {\n            uint256 _collateralId = bigBang_.collateralId();\n            uint256 collateralShare = yieldBox_.toShare(_collateralId, data.removeAndRepayData.collateralAmount, false);\n            address removeCollateralTo =\n                data.removeAndRepayData.collateralWithdrawData.withdraw ? address(this) : data.user;\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper)\n                .removeCollateral(data.user, removeCollateralTo, collateralShare);\n            bigBang_.execute(modules, calls, true);\n\n            //withdraw\n            if (data.removeAndRepayData.collateralWithdrawData.withdraw) {\n                uint256 computedAmount = yieldBox_.toAmount(_collateralId, collateralShare, false);\n                data.removeAndRepayData.collateralWithdrawData.lzSendParams.sendParam.amountLD = computedAmount;\n                data.removeAndRepayData.collateralWithdrawData.lzSendParams.sendParam.minAmountLD = computedAmount;\n                _withdrawToChain(data.removeAndRepayData.collateralWithdrawData);\n            }\n        }\n        _revertYieldBoxApproval(address(bigBang_), yieldBox_);\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/modules/MagnetarOptionModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {\n    ExitPositionAndRemoveCollateralData, MagnetarWithdrawData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOption} from \"tapioca-periph/interfaces/tap-token/ITapiocaOption.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {MagnetarBaseModule} from \"./MagnetarBaseModule.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarOptionModule\n * @author TapiocaDAO\n * @notice Magnetar options related operations\n */\ncontract MagnetarOptionModule is MagnetarBaseModule {\n    using SafeERC20 for IERC20;\n\n    error Magnetar_ActionParamsMismatch();\n    error Magnetar_tOLPTokenMismatch();\n    error Magnetar_MarketCallFailed(bytes call);\n\n    /**\n     * @notice helper to exit from  tOB, unlock from tOLP, remove from SGL, repay on BB, remove collateral from BB and withdraw\n     * @dev all steps are optional:\n     *         - if `removeAndRepayData.exitData.exit` is false, the exit operation is skipped\n     *         - if `removeAndRepayData.unlockData.unlock` is false, the unlock operation is skipped\n     *         - if `removeAndRepayData.removeAssetFromSGL` is false, the removeAsset operation is skipped\n     *         - if `!removeAndRepayData.assetWithdrawData.withdraw && removeAndRepayData.repayAssetOnBB`, the repay operation is performed\n     *         - if `removeAndRepayData.removeCollateralFromBB` is false, the rmeove collateral is skipped\n     *     - the helper can either stop at the remove asset from SGL step or it can continue until is removes & withdraws collateral from BB\n     *         - removed asset can be withdrawn by providing `removeAndRepayData.assetWithdrawData`\n     *     - BB collateral can be removed by providing `removeAndRepayData.collateralWithdrawData`\n     */\n    function exitPositionAndRemoveCollateral(ExitPositionAndRemoveCollateralData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        // Check whitelisted\n        if (data.externalData.bigBang != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.bigBang)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.bigBang);\n            }\n        }\n        if (data.externalData.singularity != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.singularity)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.singularity);\n            }\n        }\n\n        IMarket bigBang_ = IMarket(data.externalData.bigBang);\n        ISingularity singularity_ = ISingularity(data.externalData.singularity);\n        IYieldBox yieldBox_ = IYieldBox(singularity_.yieldBox());\n\n        // if `removeAndRepayData.exitData.exit` the following operations are performed\n        //      - if ownerOfTapTokenId is user, transfers the oTAP token id to this contract\n        //      - tOB.exitPosition\n        //      - if `!removeAndRepayData.unlockData.unlock`, transfer the obtained tokenId to the user\n        uint256 tOLPId = 0;\n        if (data.removeAndRepayData.exitData.exit) {\n            if (data.removeAndRepayData.exitData.oTAPTokenID == 0) revert Magnetar_ActionParamsMismatch();\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.exitData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.exitData.target);\n            }\n\n            address oTapAddress = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).oTAP();\n            (, ITapiocaOption.TapOption memory oTAPPosition) =\n                ITapiocaOption(oTapAddress).attributes(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            tOLPId = oTAPPosition.tOLP;\n\n            address ownerOfTapTokenId = IERC721(oTapAddress).ownerOf(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            if (ownerOfTapTokenId != data.user && ownerOfTapTokenId != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n            if (ownerOfTapTokenId == data.user) {\n                // IERC721(oTapAddress).safeTransferFrom(\n                //     data.user, address(this), data.removeAndRepayData.exitData.oTAPTokenID, \"0x\"\n                // );\n                bool isErr = pearlmit.transferFromERC721(\n                    data.user, address(this), oTapAddress, data.removeAndRepayData.exitData.oTAPTokenID\n                );\n                if (isErr) revert Magnetar_ExtractTokenFail();\n            }\n            ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).exitPosition(\n                data.removeAndRepayData.exitData.oTAPTokenID\n            );\n\n            if (!data.removeAndRepayData.unlockData.unlock) {\n                address tOLPContract = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).tOLP();\n\n                //transfer tOLP to the data.user\n                IERC721(tOLPContract).safeTransferFrom(address(this), data.user, tOLPId, \"0x\");\n            }\n        }\n\n        // performs a tOLP.unlock operation\n        if (data.removeAndRepayData.unlockData.unlock) {\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.unlockData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.unlockData.target);\n            }\n\n            if (data.removeAndRepayData.unlockData.tokenId != 0) {\n                if (tOLPId != 0) {\n                    if (tOLPId != data.removeAndRepayData.unlockData.tokenId) {\n                        revert Magnetar_tOLPTokenMismatch();\n                    }\n                }\n                tOLPId = data.removeAndRepayData.unlockData.tokenId;\n            }\n\n            address ownerOfTOLP = IERC721(data.removeAndRepayData.unlockData.target).ownerOf(tOLPId);\n\n            if (ownerOfTOLP != data.user && ownerOfTOLP != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n\n            ITapiocaOptionLiquidityProvision(data.removeAndRepayData.unlockData.target).unlock(\n                tOLPId, data.externalData.singularity, data.user\n            );\n        }\n\n        // if `data.removeAndRepayData.removeAssetFromSGL` performs the follow operations:\n        //      - removeAsset from SGL\n        //      - if `data.removeAndRepayData.assetWithdrawData.withdraw` withdraws by using the `withdrawTo` operation\n        uint256 _removeAmount = data.removeAndRepayData.removeAmount;\n        if (data.removeAndRepayData.removeAssetFromSGL) {\n            uint256 _assetId = singularity_.assetId();\n            uint256 share = yieldBox_.toShare(_assetId, _removeAmount, false);\n\n            address removeAssetTo = data.removeAndRepayData.assetWithdrawData.withdraw\n                || data.removeAndRepayData.repayAssetOnBB ? address(this) : data.user;\n\n            singularity_.removeAsset(data.user, removeAssetTo, share);\n\n            //withdraw\n            if (data.removeAndRepayData.assetWithdrawData.withdraw) {\n                uint256 computedAmount = yieldBox_.toAmount(_assetId, share, false);\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.amountLD = computedAmount;\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.minAmountLD = computedAmount;\n                _withdrawToChain(data.removeAndRepayData.assetWithdrawData);\n            }\n        }\n\n        // performs a BigBang repay operation\n        if (!data.removeAndRepayData.assetWithdrawData.withdraw && data.removeAndRepayData.repayAssetOnBB) {\n            _setApprovalForYieldBox(address(bigBang_), yieldBox_);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper).repay(\n                address(this), data.user, false, data.removeAndRepayData.repayAmount\n            );\n            (bool[] memory successes, bytes[] memory results) = bigBang_.execute(modules, calls, true);\n\n            if (!successes[0]) revert Magnetar_MarketCallFailed(calls[0]);\n            uint256 repayed = IMarketHelper(data.externalData.marketHelper).repayView(results[0]);\n            // transfer excess amount to the data.user\n            if (repayed < _removeAmount) {\n                uint256 bbAssetId = bigBang_.assetId();\n                yieldBox_.transfer(\n                    address(this), data.user, bbAssetId, yieldBox_.toShare(bbAssetId, _removeAmount - repayed, false)\n                );\n            }\n        }\n\n        // performs a BigBang removeCollateral operation\n        // if `data.removeAndRepayData.collateralWithdrawData.withdraw` withdraws by using the `withdrawTo` method\n        if (data.removeAndRepayData.removeCollateralFromBB) {\n            uint256 _collateralId = bigBang_.collateralId();\n            uint256 collateralShare = yieldBox_.toShare(_collateralId, data.removeAndRepayData.collateralAmount, false);\n            address removeCollateralTo =\n                data.removeAndRepayData.collateralWithdrawData.withdraw ? address(this) : data.user;\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper)\n                .removeCollateral(data.user, removeCollateralTo, collateralShare);\n            bigBang_.execute(modules, calls, true);\n\n            //withdraw\n            if (data.removeAndRepayData.collateralWithdrawData.withdraw) {\n                uint256 computedAmount = yieldBox_.toAmount(_collateralId, collateralShare, false);\n                data.removeAndRepayData.collateralWithdrawData.lzSendParams.sendParam.amountLD = computedAmount;\n                data.removeAndRepayData.collateralWithdrawData.lzSendParams.sendParam.minAmountLD = computedAmount;\n                _withdrawToChain(data.removeAndRepayData.collateralWithdrawData);\n            }\n        }\n        _revertYieldBoxApproval(address(bigBang_), yieldBox_);\n    }\n}"
    },
    {
      "filename": "contracts/markets/singularity/SGLCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {ISingularity, IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {SGLStorage} from \"./SGLStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLCommon is SGLStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error TooMuch();\n    error MinLimit();\n    error TransferFailed();\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function getInterestDetails()\n        external\n        view\n        returns (ISingularity.AccrueInfo memory _accrueInfo, uint256 utilization)\n    {\n        (_accrueInfo,,,,, utilization,) = _getInterestRate();\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getInterestRate()\n        internal\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        )\n    {\n        _accrueInfo = accrueInfo;\n        _totalBorrow = totalBorrow;\n        _totalAsset = totalAsset;\n        extraAmount = 0;\n        feeFraction = 0;\n        logStartingInterest = false;\n\n        uint256 fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return (_accrueInfo, totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        if (_totalBorrow.base == 0) {\n            // If there are no borrows, reset the interest rate\n            if (_accrueInfo.interestPerSecond != startingInterestPerSecond) {\n                _accrueInfo.interestPerSecond = startingInterestPerSecond;\n                logStartingInterest = true;\n            }\n            return (_accrueInfo, _totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n\n        // Accrue interest\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.interestPerSecond * elapsedTime) / 1e18;\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        //take accrued values into account\n        fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        uint256 feeAmount = (extraAmount * protocolFee) / FEE_PRECISION; // % of interest paid goes to fee\n        feeFraction = (feeAmount * _totalAsset.base) / (fullAssetAmount - feeAmount);\n        _accrueInfo.feesEarnedFraction += feeFraction.toUint128();\n        _totalAsset.base = _totalAsset.base + feeFraction.toUint128();\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Update interest rate\n        if (utilization < minimumTargetUtilization) {\n            uint256 underFactor =\n                ((minimumTargetUtilization - utilization) * FACTOR_PRECISION) / minimumTargetUtilization;\n            uint256 scale = interestElasticity + (underFactor * underFactor * elapsedTime);\n            _accrueInfo.interestPerSecond =\n                ((uint256(_accrueInfo.interestPerSecond) * interestElasticity) / scale).toUint64();\n            if (_accrueInfo.interestPerSecond < minimumInterestPerSecond) {\n                _accrueInfo.interestPerSecond = minimumInterestPerSecond; // 0.25% APR minimum\n            }\n        } else if (utilization > maximumTargetUtilization) {\n            uint256 overFactor = ((utilization - maximumTargetUtilization) * FACTOR_PRECISION) / fullUtilizationMinusMax;\n            uint256 scale = interestElasticity + (overFactor * overFactor * elapsedTime);\n            uint256 newInterestPerSecond = (uint256(_accrueInfo.interestPerSecond) * scale) / interestElasticity;\n            if (newInterestPerSecond > maximumInterestPerSecond) {\n                newInterestPerSecond = maximumInterestPerSecond; // 1000% APR maximum\n            }\n            _accrueInfo.interestPerSecond = newInterestPerSecond.toUint64();\n        }\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        (, _totalBorrow,,,,,) = _getInterestRate();\n    }\n\n    function _accrue() internal override {\n        (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        ) = _getInterestRate();\n\n        if (logStartingInterest) {\n            emit LogAccrue(0, 0, startingInterestPerSecond, 0);\n        } else {\n            emit LogAccrue(extraAmount, feeFraction, _accrueInfo.interestPerSecond, utilization);\n        }\n        accrueInfo = _accrueInfo;\n        totalBorrow = _totalBorrow;\n        totalAsset = _totalAsset;\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _assetId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, address, uint256 _assetId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            if (share > yieldBox.balanceOf(address(this), _assetId) - total) {\n                revert TooMuch();\n            }\n        } else {\n            // yieldBox.transfer(from, address(this), _assetId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _assetId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @dev Concrete implementation of `addAsset`.\n    function _addAsset(address from, address to, bool skim, uint256 share) internal returns (uint256 fraction) {\n        Rebase memory _totalAsset = totalAsset;\n        uint256 totalAssetShare = _totalAsset.elastic;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        fraction = allShare == 0 ? share : (share * _totalAsset.base) / allShare;\n        if (_totalAsset.base + fraction.toUint128() < 1000) {\n            return 0;\n        }\n        totalAsset = _totalAsset.add(share, fraction);\n\n        balanceOf[to] += fraction;\n        emit Transfer(address(0), to, fraction);\n\n        _addTokens(from, to, assetId, share, totalAssetShare, skim);\n        emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);\n    }\n\n    /// @dev Concrete implementation of `removeAsset`.\n    /// @param from The account to remove from. Should always be msg.sender except for `depositFeesToyieldBox()`.\n    function _removeAsset(address from, address to, uint256 fraction) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);\n        share = (fraction * allShare) / _totalAsset.base;\n\n        _totalAsset.base -= fraction.toUint128();\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        balanceOf[from] -= fraction;\n        emit Transfer(from, address(0), fraction);\n        _totalAsset.elastic -= share.toUint128();\n        totalAsset = _totalAsset;\n        emit LogRemoveAsset(from, to, share, fraction);\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Return the equivalent of collateral borrow part in asset amount.\n    function _getAmountForBorrowPart(uint256 borrowPart) internal view returns (uint256) {\n        return totalBorrow.toElastic(borrowPart, false);\n    }\n\n    function _isWhitelisted(uint16 _chainId, address _contract) internal view returns (bool) {\n        return ICluster(penrose.cluster()).isWhitelisted(_chainId, _contract);\n    }\n\n    struct _ViewLiquidationStruct {\n        address user;\n        uint256 maxBorrowPart;\n        uint256 minLiquidationBonus;\n        uint256 exchangeRate;\n        IYieldBox yieldBox;\n        uint256 collateralId;\n        uint256 userCollateralShare;\n        uint256 userBorrowPart;\n        Rebase totalBorrow;\n        uint256 liquidationBonusAmount;\n        uint256 liquidationCollateralizationRate;\n        uint256 liquidationMultiplier;\n        uint256 exchangeRatePrecision;\n        uint256 feeDecimalsPrecision;\n    }\n}"
    }
  ]
}