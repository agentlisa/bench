{
  "Title": "M-1: Blacklisted accounts can still transact.",
  "Content": "# Issue M-1: Blacklisted accounts can still transact. \n\nSource: https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update-judging/issues/4 \n\n## Found by \n0xkmg, Krace, Tendency, ZanyBonzy, ZdravkoHr., blutorque, bughuntoor, cawfree, merlin, neocrao, sa9933, smbv-1923, turvec\n## Summary\n\nAccounts that have been blacklisted by the [`BLACKLISTER_ROLE`](https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update/blob/21920190e0772afa18e7f856a036fea3ef5b9635/telcoin-contracts/contracts/util/abstract/Blacklist.sol#L32) continue to transact normally.\n\n## Vulnerability Detail\n\nCurrently, the only real effect of blacklisting an account is the seizure of [`Stablecoin`](https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update/blob/main/telcoin-contracts/contracts/stablecoin/Stablecoin.sol) funds:\n\n```solidity\n/**\n * @notice Overrides Blacklist function to transfer balance of a blacklisted user to the caller.\n * @dev This function is called internally when an account is blacklisted.\n * @param user The blacklisted user whose balance will be transferred.\n */\nfunction _onceBlacklisted(address user) internal override {\n  _transfer(user, _msgSender(), balanceOf(user));\n}\n```\n\nHowever, following a call to [`addBlackList(address)`](https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update/blob/21920190e0772afa18e7f856a036fea3ef5b9635/telcoin-contracts/contracts/util/abstract/Blacklist.sol#L72C14-L72C26), the blacklisted account may continue to transact using [`Stablecoin`](https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update/blob/main/telcoin-contracts/contracts/stablecoin/Stablecoin.sol).\n\nCombined with previous audit reports, which attest to the blacklist function's [susceptibility to frontrunning](https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/43), the current implementation of the blacklist operation can effectively be considered a no-op.\n\n## Impact\n\nMedium, as this the failure of a manually administered security feature.\n\n## Code Snippet\n\n### [ðŸ“„ Stablecoin.sol](https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update/blob/main/telcoin-contracts/contracts/stablecoin/Stablecoin.sol)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nERC20s that enforce blacklists normally prevent a sanctioned address from being able to transact:\n\n### [ðŸ“„ Stablecoin.sol](https://github.com/sherlock-audit/2024-02-telcoin-platform-audit-update/blob/main/telcoin-contracts/contracts/stablecoin/Stablecoin.sol)\n\n```diff\n+ error Blacklisted(address account);\n\n+function _update(address from, address to, uint256 value) internal virtual override {\n+\n+  if (blacklisted(from)) revert Blacklisted(from); \n+  if (blacklisted(to)) revert Blacklisted(to);\n+\n+  super._update(from, to, value);\n+}\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; high(1)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/telcoin/telcoin-contracts/pull/3.\n\n**spacegliderrrr**\n\nFix looks good, blacklisted addresses can no longer send and receive tokens.\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/196",
  "Code": [
    {
      "filename": "telcoin-contracts/contracts/util/abstract/Blacklist.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n/**\n * @title Blacklist\n * @author Amir Shirif\n * @notice A Telcoin Contract\n * @notice This contract is meant to allow for the prevention of the interaction of certain addreses\n */\nabstract contract Blacklist is AccessControlUpgradeable {\n    /// @custom:storage-location erc7201:telcoin.storage.Blacklist\n    struct BlacklistStorage {\n        mapping(address => bool) _blacklist;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"erc7201.telcoin.storage.Blacklist\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant BlacklistStorageLocation =\n        0x74958077aaf7e7942dc6838d7ab914c8ab92cc0aa85fe20a608ddf5aa4c04000;\n\n    function _getBlacklistStorage()\n        private\n        pure\n        returns (BlacklistStorage storage $)\n    {\n        assembly {\n            $.slot := BlacklistStorageLocation\n        }\n    }\n\n    bytes32 public constant BLACKLISTER_ROLE = keccak256(\"BLACKLISTER_ROLE\");\n\n    /**\n     * @dev reverts if the blacklisting of an already blacklisted address is attempted\n     */\n    error AlreadyBlacklisted(address user);\n\n    /**\n     * @dev reverts if the removal of a blacklisting of an address not blacklisted is attempted\n     */\n    error NotBlacklisted(address user);\n\n    /**\n     * @dev emits when address is blacklisted\n     */\n    event AddedBlacklist(address user);\n\n    /**\n     * @dev emits when address is removed from blacklist\n     */\n    event RemovedBlacklist(address user);\n\n    /************************************************\n     *   blacklist fuctions\n     ************************************************/\n\n    /**\n     * @notice returns blacklsit status of address\n     * @return bool representing blacklist status\n     */\n    function blacklisted(address user) public view returns (bool) {\n        BlacklistStorage storage $ = _getBlacklistStorage();\n        return $._blacklist[user];\n    }\n\n    /**\n     * @notice updates blacklisted list to include user\n     * @dev restricted to BLACKLISTER_ROLE\n     * @param user blacklisted address\n     */\n    function addBlackList(\n        address user\n    ) public virtual onlyRole(BLACKLISTER_ROLE) {\n        if (blacklisted(user)) revert AlreadyBlacklisted(user);\n        _setBlacklist(user, true);\n        _onceBlacklisted(user);\n        emit AddedBlacklist(user);\n    }\n\n    /**\n     * @notice updates blacklisted list to remove user\n     * @dev restricted to BLACKLISTER_ROLE\n     * @param user blacklisted address\n     */\n    function removeBlackList(\n        address user\n    ) public virtual onlyRole(BLACKLISTER_ROLE) {\n        if (!blacklisted(user)) revert NotBlacklisted(user);\n        _setBlacklist(user, false);\n        emit RemovedBlacklist(user);\n    }\n\n    // Internal function to set the blacklist state of an address\n    function _setBlacklist(address user, bool state) internal virtual {\n        BlacklistStorage storage $ = _getBlacklistStorage();\n        $._blacklist[user] = state;\n    }\n\n    // Internal hook that can be overridden for custom logic when an address is blacklisted\n    function _onceBlacklisted(address user) internal virtual {}\n}"
    },
    {
      "filename": "telcoin-contracts/contracts/util/abstract/Blacklist.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n/**\n * @title Blacklist\n * @author Amir Shirif\n * @notice A Telcoin Contract\n * @notice This contract is meant to allow for the prevention of the interaction of certain addreses\n */\nabstract contract Blacklist is AccessControlUpgradeable {\n    /// @custom:storage-location erc7201:telcoin.storage.Blacklist\n    struct BlacklistStorage {\n        mapping(address => bool) _blacklist;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"erc7201.telcoin.storage.Blacklist\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant BlacklistStorageLocation =\n        0x74958077aaf7e7942dc6838d7ab914c8ab92cc0aa85fe20a608ddf5aa4c04000;\n\n    function _getBlacklistStorage()\n        private\n        pure\n        returns (BlacklistStorage storage $)\n    {\n        assembly {\n            $.slot := BlacklistStorageLocation\n        }\n    }\n\n    bytes32 public constant BLACKLISTER_ROLE = keccak256(\"BLACKLISTER_ROLE\");\n\n    /**\n     * @dev reverts if the blacklisting of an already blacklisted address is attempted\n     */\n    error AlreadyBlacklisted(address user);\n\n    /**\n     * @dev reverts if the removal of a blacklisting of an address not blacklisted is attempted\n     */\n    error NotBlacklisted(address user);\n\n    /**\n     * @dev emits when address is blacklisted\n     */\n    event AddedBlacklist(address user);\n\n    /**\n     * @dev emits when address is removed from blacklist\n     */\n    event RemovedBlacklist(address user);\n\n    /************************************************\n     *   blacklist fuctions\n     ************************************************/\n\n    /**\n     * @notice returns blacklsit status of address\n     * @return bool representing blacklist status\n     */\n    function blacklisted(address user) public view returns (bool) {\n        BlacklistStorage storage $ = _getBlacklistStorage();\n        return $._blacklist[user];\n    }\n\n    /**\n     * @notice updates blacklisted list to include user\n     * @dev restricted to BLACKLISTER_ROLE\n     * @param user blacklisted address\n     */\n    function addBlackList(\n        address user\n    ) public virtual onlyRole(BLACKLISTER_ROLE) {\n        if (blacklisted(user)) revert AlreadyBlacklisted(user);\n        _setBlacklist(user, true);\n        _onceBlacklisted(user);\n        emit AddedBlacklist(user);\n    }\n\n    /**\n     * @notice updates blacklisted list to remove user\n     * @dev restricted to BLACKLISTER_ROLE\n     * @param user blacklisted address\n     */\n    function removeBlackList(\n        address user\n    ) public virtual onlyRole(BLACKLISTER_ROLE) {\n        if (!blacklisted(user)) revert NotBlacklisted(user);\n        _setBlacklist(user, false);\n        emit RemovedBlacklist(user);\n    }\n\n    // Internal function to set the blacklist state of an address\n    function _setBlacklist(address user, bool state) internal virtual {\n        BlacklistStorage storage $ = _getBlacklistStorage();\n        $._blacklist[user] = state;\n    }\n\n    // Internal hook that can be overridden for custom logic when an address is blacklisted\n    function _onceBlacklisted(address user) internal virtual {}\n}"
    }
  ]
}