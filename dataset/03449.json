{
  "Title": "[L07] Inconsistent decoding methodologies could cause outcome discrepancies",
  "Content": "To support all of its extensibility and flexibility, the Limit Order Protocol routinely has to deal with dynamic bytes data and arbitrary return values from external contracts. As a result, the protocol includes an [`ArgumentsDecoder`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/libraries/ArgumentsDecoder.sol) library to more efficiently convert dynamic bytes values into basic data types. However, this library is not used exclusively, and in some cases `abi.decode` is used instead. Additionally, some contracts are using [`abi coder v1`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/libraries/ArgumentsDecoder.sol) while others are using [`abi coder v2`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/PredicateHelper.sol). The former performs more similarly to the `ArgumentsDecoder` library, whereas the latter performs additional checks when decoding.\n\n\nThe inconsistent usage of these different decoding methodologies can result in subtle discrepancies between the intention and actual behavior of the codebase.\n\n\nFor instance, the [`simulateCalls`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L116) function only uses the [`ArgumentsDecoder.decodeBool`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/libraries/ArgumentsDecoder.sol#L16) function. If the `simulateCalls` function is used to check calls that would be made in the predicate part of an order, then its results could deviate from what actually occurs when the predicate conditions are evaluated, because different decoding methodologies are employed.\n\n\nSo, for instance, if a predicate makes an external `staticcall` to some function that returns a `uint256` value greater than one rather than the expected `bool`, then that call will revert, because the return value is [decoded with `abi coder v2`â€˜s `abi.decode`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/PredicateHelper.sol#L19) which will not accept such values as `bool`. However, if the exact same call is made with `simulateCalls`, then it [will simply be marked as `true`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L123), because `decodeBool` treats any value larger than zero as `true`.\n\n\nTo make the `simulateCalls` function fully mirror the behavior of actual predicate calls, consider modifying it to use `abi.decode`.\n\n\n***Update:** Fixed in [pull request #82](https://github.com/1inch/limit-order-protocol/pull/82).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OrderMixin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./helpers/AmountCalculator.sol\";\nimport \"./helpers/ChainlinkCalculator.sol\";\nimport \"./helpers/NonceManager.sol\";\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./interfaces/InteractiveNotificationReceiver.sol\";\nimport \"./libraries/ArgumentsDecoder.sol\";\nimport \"./libraries/Permitable.sol\";\n\n/// @title Order Limits v1 mixin\nabstract contract OrderMixin is\n    EIP712,\n    AmountCalculator,\n    ChainlinkCalculator,\n    NonceManager,\n    PredicateHelper,\n    Permitable\n{\n    using Address for address;\n    using ArgumentsDecoder for bytes;\n\n    /// @notice Emitted every time order gets filled, including partial fills\n    event OrderFilled(\n        address indexed maker,\n        bytes32 orderHash,\n        uint256 remaining\n    );\n\n    /// @notice Emitted when order gets cancelled\n    event OrderCanceled(\n        address indexed maker,\n        bytes32 orderHash\n    );\n\n    // Fixed-size order part with core information\n    struct StaticOrder {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n    }\n\n    // `StaticOrder` extension including variable-sized additional order meta information\n    struct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n        bytes makerAssetData;\n        bytes takerAssetData;\n        bytes getMakerAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n        bytes getTakerAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n        bytes predicate;      // this.staticcall(bytes) => (bool)\n        bytes permit;         // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n        bytes interaction;\n    }\n\n    bytes32 constant public LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(uint256 salt,address makerAsset,address takerAsset,address maker,address receiver,address allowedSender,uint256 makingAmount,uint256 takingAmount,bytes makerAssetData,bytes takerAssetData,bytes getMakerAmount,bytes getTakerAmount,bytes predicate,bytes permit,bytes interaction)\"\n    );\n\n    /// @notice Stores unfilled amounts for each order plus one.\n    /// Therefore 0 means order doesn't exist and 1 means order was filled\n    mapping(bytes32 => uint256) private _remaining;\n\n    /// @notice Returns unfilled amount for order. Throws if order does not exist\n    function remaining(bytes32 orderHash) external view returns(uint256 amount) {\n        amount = _remaining[orderHash];\n        require(amount > 0, \"LOP: Unknown order\");\n        unchecked { amount -= 1; }\n    }\n\n    /// @notice Returns unfilled amount for order\n    /// @return Result Unfilled amount of order plus one if order exists. Otherwise 0\n    function remainingRaw(bytes32 orderHash) external view returns(uint256) {\n        return _remaining[orderHash];\n    }\n\n    /// @notice Same as `remainingRaw` but for multiple orders\n    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory results) {\n        results = new uint256[](orderHashes.length);\n        for (uint i = 0; i < orderHashes.length; i++) {\n            results[i] = _remaining[orderHashes[i]];\n        }\n    }\n\n    /// @notice Checks order predicate\n    function checkPredicate(Order memory order) public view returns(bool) {\n        bytes memory result = address(this).functionStaticCall(order.predicate, \"LOP: predicate call failed\");\n        require(result.length == 32, \"LOP: invalid predicate return\");\n        return result.decodeBool();\n    }\n\n    /**\n     * @notice Calls every target with corresponding data. Then reverts with CALL_RESULTS_0101011 where zeroes and ones\n     * denote failure or success of the corresponding call\n     * @param targets Array of addresses that will be called\n     * @param data Array of data that will be passed to each call\n     */\n    function simulateCalls(address[] calldata targets, bytes[] calldata data) external {\n        require(targets.length == data.length, \"LOP: array size mismatch\");\n        bytes memory reason = new bytes(targets.length);\n        for (uint i = 0; i < targets.length; i++) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = targets[i].call(data[i]);\n            if (success && result.length > 0) {\n                success = result.decodeBool();\n            }\n            reason[i] = success ? bytes1(\"1\") : bytes1(\"0\");\n        }\n\n        // Always revert and provide per call results\n        revert(string(abi.encodePacked(\"CALL_RESULTS_\", reason)));\n    }\n\n    /// @notice Cancels order by setting remaining amount to zero\n    function cancelOrder(Order memory order) external {\n        require(order.maker == msg.sender, \"LOP: Access denied\");\n\n        bytes32 orderHash = _hash(order);\n        require(_remaining[orderHash] != 1, \"LOP: already filled\");\n        _remaining[orderHash] = 1;\n        emit OrderCanceled(msg.sender, orderHash);\n    }\n\n    /// @notice Fills an order. If one doesn't exist (first fill) it will be created using order.makerAssetData\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount\n    ) external returns(uint256, uint256) {\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, msg.sender);\n    }\n\n    /// @notice Same as `fillOrder` but calls permit first,\n    /// allowing to approve token spending and make a swap in one transaction.\n    /// Also allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    /// @param target Address that will receive swap funds\n    /// @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.\n    /// See tests for examples\n    function fillOrderToWithPermit(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target,\n        bytes calldata permit\n    ) external returns(uint256, uint256) {\n        (address token, bytes calldata permitData) = permit.decodeTargetAndData();\n        _permit(token, permitData);\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, target);\n    }\n\n    /// @notice Same as `fillOrder` but allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    /// @param target Address that will receive swap funds\n    function fillOrderTo(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target\n    ) public returns(uint256, uint256) {\n        bytes32 orderHash = _hash(order);\n\n        {  // Stack too deep\n            uint256 remainingMakerAmount = _remaining[orderHash];\n            if (remainingMakerAmount == 0) {\n                // First fill: validate order and permit maker asset\n                require(order.allowedSender == address(0) || order.allowedSender == msg.sender, \"LOP: private order\");\n                require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"LOP: bad signature\");\n                remainingMakerAmount = order.makingAmount;\n                if (order.permit.length > 0) {\n                    (address token, bytes memory permit) = order.permit.decodeTargetAndCalldata();\n                    _permitMemory(token, permit);\n                    require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n                }\n            } else {\n                unchecked { remainingMakerAmount -= 1; }\n            }\n\n            // Check if order is valid\n            if (order.predicate.length > 0) {\n                require(checkPredicate(order), \"LOP: predicate returned false\");\n            }\n\n            // Compute maker and taker assets amount\n            if ((takingAmount == 0) == (makingAmount == 0)) {\n                revert(\"LOP: only one amount should be 0\");\n            }\n            else if (takingAmount == 0) {\n                if (makingAmount > remainingMakerAmount) {\n                    makingAmount = remainingMakerAmount;\n                }\n                takingAmount = _callGetTakerAmount(order, makingAmount);\n                require(takingAmount <= thresholdAmount, \"LOP: taking amount too high\");\n            }\n            else {\n                makingAmount = _callGetMakerAmount(order, takingAmount);\n                if (makingAmount > remainingMakerAmount) {\n                    makingAmount = remainingMakerAmount;\n                    takingAmount = _callGetTakerAmount(order, makingAmount);\n                }\n                require(makingAmount >= thresholdAmount, \"LOP: making amount too low\");\n            }\n\n            require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n            // Update remaining amount in storage\n            unchecked {\n                remainingMakerAmount = remainingMakerAmount - makingAmount;\n                _remaining[orderHash] = remainingMakerAmount + 1;\n            }\n            emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n        }\n\n        // Taker => Maker\n        _makeCall(\n            order.takerAsset,\n            abi.encodePacked(\n                IERC20.transferFrom.selector,\n                uint256(uint160(msg.sender)),\n                uint256(uint160(order.receiver == address(0) ? order.maker : order.receiver)),\n                takingAmount,\n                order.takerAssetData\n            )\n        );\n\n        // Maker can handle funds interactively\n        if (order.interaction.length > 0) {\n            (address interactionTarget, bytes memory interactionData) = order.interaction.decodeTargetAndCalldata();\n            InteractiveNotificationReceiver(interactionTarget).notifyFillOrder(\n                msg.sender, order.makerAsset, order.takerAsset, makingAmount, takingAmount, interactionData\n            );\n        }\n\n        // Maker => Taker\n        _makeCall(\n            order.makerAsset,\n            abi.encodePacked(\n                IERC20.transferFrom.selector,\n                uint256(uint160(order.maker)),\n                uint256(uint160(target)),\n                makingAmount,\n                order.makerAsset\n            )\n        );\n\n        return (makingAmount, takingAmount);\n    }\n\n    function _hash(Order memory order) private view returns(bytes32) {\n        StaticOrder memory staticOrder;\n        assembly {  // solhint-disable-line no-inline-assembly\n            staticOrder := order\n        }\n        return _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    LIMIT_ORDER_TYPEHASH,\n                    staticOrder,\n                    keccak256(order.makerAssetData),\n                    keccak256(order.takerAssetData),\n                    keccak256(order.getMakerAmount),\n                    keccak256(order.getTakerAmount),\n                    keccak256(order.predicate),\n                    keccak256(order.permit),\n                    keccak256(order.interaction)\n                )\n            )\n        );\n    }\n\n    function _makeCall(address asset, bytes memory assetData) private {\n        bytes memory result = asset.functionCall(assetData, \"LOP: asset.call failed\");\n        if (result.length > 0) {\n            require(result.decodeBool(), \"LOP: asset.call bad result\");\n        }\n    }\n\n    function _callGetMakerAmount(Order memory order, uint256 takerAmount) private view returns(uint256 makerAmount) {\n        if (order.getMakerAmount.length == 0) {\n            // On empty order.getMakerAmount calldata only whole fills are allowed\n            require(takerAmount == order.takingAmount, \"LOP: wrong taker amount\");\n            return order.makingAmount;\n        }\n        bytes memory result = address(this).functionStaticCall(abi.encodePacked(order.getMakerAmount, takerAmount), \"LOP: getMakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getMakerAmount ret\");\n        return result.decodeUint256();\n    }\n\n    function _callGetTakerAmount(Order memory order, uint256 makerAmount) private view returns(uint256 takerAmount) {\n        if (order.getTakerAmount.length == 0) {\n            // On empty order.getTakerAmount calldata only whole fills are allowed\n            require(makerAmount == order.makingAmount, \"LOP: wrong maker amount\");\n            return order.takingAmount;\n        }\n        bytes memory result = address(this).functionStaticCall(abi.encodePacked(order.getTakerAmount, makerAmount), \"LOP: getTakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getTakerAmount ret\");\n        return result.decodeUint256();\n    }\n}"
    },
    {
      "filename": "contracts/helpers/PredicateHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n\n/// @title A helper contract for executing boolean functions on arbitrary target call results\ncontract PredicateHelper {\n    using Address for address;\n\n    /// @notice Calls every target with corresponding data\n    /// @return Result True if call to any target returned True. Otherwise, false\n    function or(address[] calldata targets, bytes[] calldata data) external view returns(bool) {\n        require(targets.length == data.length, \"PH: input array size mismatch\");\n        for (uint i = 0; i < targets.length; i++) {\n            bytes memory result = targets[i].functionStaticCall(data[i], \"PH: 'or' subcall failed\");\n            require(result.length == 32, \"PH: invalid call result\");\n            if (abi.decode(result, (bool))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Calls every target with corresponding data\n    /// @return Result True if calls to all targets returned True. Otherwise, false\n    function and(address[] calldata targets, bytes[] calldata data) external view returns(bool) {\n        require(targets.length == data.length, \"PH: input array size mismatch\");\n        for (uint i = 0; i < targets.length; i++) {\n            bytes memory result = targets[i].functionStaticCall(data[i], \"PH: 'and' subcall failed\");\n            require(result.length == 32, \"PH: invalid call result\");\n            if (!abi.decode(result, (bool))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Calls target with specified data and tests if it's equal to the value\n    /// @param value Value to test\n    /// @return Result True if call to target returns the same value as `value`. Otherwise, false\n    function eq(uint256 value, address target, bytes memory data) external view returns(bool) {\n        bytes memory result = target.functionStaticCall(data, \"PH: eq\");\n        require(result.length == 32, \"PH: invalid call result\");\n        return abi.decode(result, (uint256)) == value;\n    }\n\n    /// @notice Calls target with specified data and tests if it's lower than value\n    /// @param value Value to test\n    /// @return Result True if call to target returns value which is lower than `value`. Otherwise, false\n    function lt(uint256 value, address target, bytes memory data) external view returns(bool) {\n        bytes memory result = target.functionStaticCall(data, \"PH: lt\");\n        require(result.length == 32, \"PH: invalid call result\");\n        return abi.decode(result, (uint256)) < value;\n    }\n\n    /// @notice Calls target with specified data and tests if it's bigger than value\n    /// @param value Value to test\n    /// @return Result True if call to target returns value which is bigger than `value`. Otherwise, false\n    function gt(uint256 value, address target, bytes memory data) external view returns(bool) {\n        bytes memory result = target.functionStaticCall(data, \"PH: gt\");\n        require(result.length == 32, \"PH: invalid call result\");\n        return abi.decode(result, (uint256)) > value;\n    }\n\n    /// @notice Checks passed time against block timestamp\n    /// @return Result True if current block timestamp is lower than `time`. Otherwise, false\n    function timestampBelow(uint256 time) external view returns(bool) {\n        return block.timestamp < time;  // solhint-disable-line not-rely-on-time\n    }\n}"
    }
  ]
}