{
  "Title": "[12] The memory cost calculation logic `_revertWithReasonIfOneIsReturned` is duplicated in multiple places",
  "Content": "\n`_revertWithReasonIfOneIsReturned` implements a memory cost calculation logic. This is duplicated in four places: `_performERC20Transfer`, `_performERC721Transfer`, `_performERC1155Transfer`, `_performERC1155BatchTransfer`.\n\nSeveral slight issues were identified with this function and those may or may not be present in five places in total.\n\n### Proof of Concept\n**Context:** [LowLevelHelper.sol#L46](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/LowLevelHelpers.sol#L46), [TokenTransferrer.sol#L79](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/TokenTransferrer.sol#L79), [TokenTransferrer.sol#L259](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/TokenTransferrer.sol#L259), [TokenTransferrer.sol#L393](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/TokenTransferrer.sol#L393), [TokenTransferrer.sol#L639](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/TokenTransferrer.sol#L639)\n\n### Recommended Mitigation Steps\n\nReduce code duplication and risk of differences between them.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/LowLevelHelpers.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title LowLevelHelpers\n * @author 0age\n * @notice LowLevelHelpers contains logic for performing various low-level\n *         operations.\n */\ncontract LowLevelHelpers {\n    /**\n     * @dev Internal view function to staticcall an arbitrary target with given\n     *      calldata. Note that no data is written to memory and no contract\n     *      size check is performed.\n     *\n     * @param target   The account to staticcall.\n     * @param callData The calldata to supply when staticcalling the target.\n     *\n     * @return success The status of the staticcall to the target.\n     */\n    function _staticcall(address target, bytes memory callData)\n        internal\n        view\n        returns (bool success)\n    {\n        assembly {\n            // Perform the staticcall.\n            success := staticcall(\n                gas(),\n                target,\n                add(callData, OneWord),\n                mload(callData),\n                0,\n                0\n            )\n        }\n    }\n\n    /**\n     * @dev Internal view function to revert and pass along the revert reason if\n     *      data was returned by the last call and that the size of that data\n     *      does not exceed the currently allocated memory size.\n     */\n    function _revertWithReasonIfOneIsReturned() internal view {\n        assembly {\n            // If it returned a message, bubble it up as long as sufficient gas\n            // remains to do so:\n            if returndatasize() {\n                // Ensure that sufficient gas is available to copy returndata\n                // while expanding memory where necessary. Start by computing\n                // the word size of returndata and allocated memory.\n                let returnDataWords := div(returndatasize(), OneWord)\n\n                // Note: use the free memory pointer in place of msize() to work\n                // around a Yul warning that prevents accessing msize directly\n                // when the IR pipeline is activated.\n                let msizeWords := div(mload(FreeMemoryPointerSlot), OneWord)\n\n                // Next, compute the cost of the returndatacopy.\n                let cost := mul(CostPerWord, returnDataWords)\n\n                // Then, compute cost of new memory allocation.\n                if gt(returnDataWords, msizeWords) {\n                    cost := add(\n                        cost,\n                        add(\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\n                            div(\n                                sub(\n                                    mul(returnDataWords, returnDataWords),\n                                    mul(msizeWords, msizeWords)\n                                ),\n                                MemoryExpansionCoefficient\n                            )\n                        )\n                    )\n                }\n\n                // Finally, add a small constant and compare to gas remaining;\n                // bubble up the revert data if enough gas is still available.\n                if lt(add(cost, ExtraGasBuffer), gas()) {\n                    // Copy returndata to memory; overwrite existing memory.\n                    returndatacopy(0, 0, returndatasize())\n\n                    // Revert, specifying memory region with copied returndata.\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to determine if the first word of returndata\n     *      matches an expected magic value.\n     *\n     * @param expected The expected magic value.\n     *\n     * @return A boolean indicating whether the expected value matches the one\n     *         located in the first word of returndata.\n     */\n    function _doesNotMatchMagic(bytes4 expected) internal pure returns (bool) {\n        // Declare a variable for the value held by the return data buffer.\n        bytes4 result;\n\n        // Utilize assembly in order to read directly from returndata buffer.\n        assembly {\n            // Only put result on stack if return data is exactly one word.\n            if eq(returndatasize(), OneWord) {\n                // Copy the word directly from return data into scratch space.\n                returndatacopy(0, 0, OneWord)\n\n                // Take value from scratch space and place it on the stack.\n                result := mload(0)\n            }\n        }\n\n        // Return a boolean indicating whether expected and located value match.\n        return result != expected;\n    }\n}"
    }
  ]
}