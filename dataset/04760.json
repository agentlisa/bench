{
  "Title": "[H-01] Anyone making use of the MagicLP's TWAP to determine token prices will be exploitable.",
  "Content": "\nMagicLP provides a TWAP value which can be accessed via `_BASE_PRICE_CUMULATIVE_LAST_`\n\nIt is updated in the function below:\n\n    function _twapUpdate() internal {\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            /// @dev It is desired and expected for this value to\n            /// overflow once it has hit the max of `type.uint256`.\n            unchecked {\n                _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n            }\n        }\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\nIt is updated by any function that changes the reserves, for example:\n\n    function _resetTargetAndReserve() internal returns (uint256 baseBalance, uint256 quoteBalance) {\n        baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {\n            revert ErrOverflow();\n        }\n        _BASE_RESERVE_ = uint112(baseBalance);\n        _QUOTE_RESERVE_ = uint112(quoteBalance);\n        _BASE_TARGET_ = uint112(baseBalance);\n        _QUOTE_TARGET_ = uint112(quoteBalance);\n        _RState_ = uint32(PMMPricing.RState.ONE);\n        _twapUpdate();\n    }\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        _BASE_RESERVE_ = baseReserve.toUint112();\n        _QUOTE_RESERVE_ = quoteReserve.toUint112();\n        _twapUpdate();\n    }\n\nThe root cause of the issue is that the TWAP is updated *after* reserve changes. Since the TWAP multiplies the duration of time since the last update with the new reserves, an attacker has control over the registered price for the entire passed duration.\n\nFor reference, the Uniswap and Beanstalk TWAPs are provided below:\n\n*   [UniswapV2](https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L79) - priceXCumulativeLast is written and then reserves are changed\n*   [Beanstalk](https://github.com/BeanstalkFarms/Basin/blob/e5441fc78f0fd4b77a898812d0fd22cb43a0af55/src/Well.sol#L209) - pumps are updated before the swap operation.\n\nRareSkills details how TWAP operation works [here](https://www.rareskills.io/post/twap-uniswap-v2).\n\n### Impact\n\nAny application making use of the MagicLP's TWAP to determine token prices will be exploitable.\n\n### Proof of Concept\n\n1.  At time T0, \\`*BASE_PRICE_CUMULATIVE_LAST* = X.\n2.  Integrating contract records (T0,X)\n3.  T seconds pass, without swaps, meaning price remained X.\n4.  A contract queries `_BASE_PRICE_CUMULATIVE_LAST_` to execute a large swap(A->B). The swap could be done through MIMswap or any other AMM.\n5.  Attacker frontruns the query by inflating the A reserves with a large swap. New price is Y >> X.\n6.  Integrating contract records (T0+T, X + Y &ast; T)\n7.  When calculating TWAP for last T seconds: `(X+Y*T-X)/(T0+T-T0) = Y*T/T = Y`. Attacker has succeeded in manipulating the price to Y.\n8.  The victim performs a losing trade\n9.  Attacker swaps back (B->A) to get back their tokens minus swap fees, profiting from the price manipulation.\n\n### Recommended Mitigation Steps\n\n`_twapUpdate()` needs to be called before reserves are updated.\n\n**[0xCalibur (Abracadabra) disputed and commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/227#issuecomment-1998137380):**\n > It's as designed. Integrating protocol should always check for min output to avoid frontrunning.\n\n**[cccz (Judge) commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/227#issuecomment-2026576344):**\n > I think this is valid, the problem is that the TWAP algorithm is wrong, TWAP: https://en.wikipedia.org/wiki/Time-weighted_average_price\n> By the way, the code here is consistent with DODOV2.\n\n**[0xCalibur (Abracadabra) commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/227#issuecomment-2037142014):**\n > We decided to removed the TWAP functionality at the end. But during the time of this review, this was in the code.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "contracts/UniswapV2Pair.sol",
      "content": "pragma solidity =0.5.16;\n\nimport './interfaces/IUniswapV2Pair.sol';\nimport './UniswapV2ERC20.sol';\nimport './libraries/Math.sol';\nimport './libraries/UQ112x112.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IUniswapV2Factory.sol';\nimport './interfaces/IUniswapV2Callee.sol';\n\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {\n    using SafeMath  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}"
    },
    {
      "filename": "src/Well.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuardUpgradeable} from \"ozu/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC20Upgradeable, ERC20PermitUpgradeable} from \"ozu/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {IERC20, SafeERC20} from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\nimport {IWell, Call} from \"src/interfaces/IWell.sol\";\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {LibBytes} from \"src/libraries/LibBytes.sol\";\nimport {ClonePlus} from \"src/utils/ClonePlus.sol\";\n\n/**\n * @title Well\n * @author Publius, Silo Chad, Brean\n * @dev A Well is a constant function AMM allowing the provisioning of liquidity\n * into a single pooled on-chain liquidity position.\n */\ncontract Well is ERC20PermitUpgradeable, IWell, ReentrancyGuardUpgradeable, ClonePlus {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint;\n\n    bytes32 constant RESERVES_STORAGE_SLOT = keccak256(\"reserves.storage.slot\");\n\n    function init(string memory name, string memory symbol) public initializer {\n        __ERC20Permit_init(name);\n        __ERC20_init(name, symbol);\n    }\n\n    //////////////////// WELL DEFINITION ////////////////////\n\n    /// This Well uses a dynamic immutable storage layout. Immutable storage is\n    /// used for gas-efficient reads during Well operation. The Well must be\n    /// created by cloning with a pre-encoded byte string containing immutable\n    /// data.\n    ///\n    /// Let n = number of tokens\n    ///     m = length of well function data (bytes)\n    ///\n    /// TYPE        NAME                       LOCATION (CONSTANT)\n    /// ==============================================================\n    /// address     aquifer()                  0        (LOC_AQUIFER_ADDR)\n    /// uint256     numberOfTokens()           20       (LOC_TOKENS_COUNT)\n    /// address     wellFunctionAddress()      52       (LOC_WELL_FUNCTION_ADDR)\n    /// uint256     wellFunctionDataLength()   72       (LOC_WELL_FUNCTION_DATA_LENGTH)\n    /// uint256     numberOfPumps()            104      (LOC_PUMPS_COUNT)\n    /// --------------------------------------------------------------\n    /// address     token0                     136      (LOC_VARIABLE)\n    /// ...\n    /// address     tokenN                     136 + (n-1) * 32\n    /// --------------------------------------------------------------\n    /// byte        wellFunctionData0          136 + n * 32\n    /// ...\n    /// byte        wellFunctionDataM          136 + n * 32 + m\n    /// --------------------------------------------------------------\n    /// address     pump1Address               136 + n * 32 + m\n    /// uint256     pump1DataLength            136 + n * 32 + m + 20\n    /// byte        pump1Data                  136 + n * 32 + m + 52\n    /// ...\n    /// ==============================================================\n\n    uint constant LOC_AQUIFER_ADDR = 0;\n    uint constant LOC_TOKENS_COUNT = LOC_AQUIFER_ADDR + 20;\n    uint constant LOC_WELL_FUNCTION_ADDR = LOC_TOKENS_COUNT + 32;\n    uint constant LOC_WELL_FUNCTION_DATA_LENGTH = LOC_WELL_FUNCTION_ADDR + 20;\n    uint constant LOC_PUMPS_COUNT = LOC_WELL_FUNCTION_DATA_LENGTH + 32;\n    uint constant LOC_VARIABLE = LOC_PUMPS_COUNT + 32;\n\n    function tokens() public pure returns (IERC20[] memory ts) {\n        ts = _getArgIERC20Array(LOC_VARIABLE, numberOfTokens());\n    }\n\n    function wellFunction() public pure returns (Call memory _wellFunction) {\n        _wellFunction.target = wellFunctionAddress();\n        uint dataLoc = LOC_VARIABLE + numberOfTokens() * 32;\n        _wellFunction.data = _getArgBytes(dataLoc, wellFunctionDataLength());\n    }\n\n    function pumps() public pure returns (Call[] memory _pumps) {\n        if (numberOfPumps() == 0) return _pumps;\n\n        _pumps = new Call[](numberOfPumps());\n        uint dataLoc = LOC_VARIABLE + numberOfTokens() * 32 + wellFunctionDataLength();\n\n        uint pumpDataLength;\n        for (uint i = 0; i < _pumps.length; i++) {\n            _pumps[i].target = _getArgAddress(dataLoc);\n            dataLoc += 20;\n            pumpDataLength = _getArgUint256(dataLoc);\n            dataLoc += 32;\n            _pumps[i].data = _getArgBytes(dataLoc, pumpDataLength);\n            dataLoc += pumpDataLength;\n        }\n    }\n\n    /**\n     * @dev {wellData} is unused in this implementation.\n     */\n    function wellData() public pure returns (bytes memory) {}\n\n    function aquifer() public pure override returns (address) {\n        return _getArgAddress(LOC_AQUIFER_ADDR);\n    }\n\n    function well()\n        external\n        pure\n        returns (\n            IERC20[] memory _tokens,\n            Call memory _wellFunction,\n            Call[] memory _pumps,\n            bytes memory _wellData,\n            address _aquifer\n        )\n    {\n        _tokens = tokens();\n        _wellFunction = wellFunction();\n        _pumps = pumps();\n        _aquifer = aquifer();\n    }\n\n    //////////////////// WELL DEFINITION: HELPERS ////////////////////\n\n    /**\n     * @notice Returns the number of tokens that are tradable in this Well.\n     * @dev Length of the `tokens()` array.\n     */\n    function numberOfTokens() public pure returns (uint) {\n        return _getArgUint256(LOC_TOKENS_COUNT);\n    }\n\n    /**\n     * @notice Returns the address of the Well Function.\n     */\n    function wellFunctionAddress() public pure returns (address) {\n        return _getArgAddress(LOC_WELL_FUNCTION_ADDR);\n    }\n\n    /**\n     * @notice Returns the length of the configurable `data` parameter passed during calls to the Well Function.\n     */\n    function wellFunctionDataLength() public pure returns (uint) {\n        return _getArgUint256(LOC_WELL_FUNCTION_DATA_LENGTH);\n    }\n\n    /**\n     * @notice Returns the number of Pumps which this Well was initialized with.\n     */\n    function numberOfPumps() public pure returns (uint) {\n        return _getArgUint256(LOC_PUMPS_COUNT);\n    }\n\n    /**\n     * @notice Returns address & data used to call the first Pump.\n     * @dev Provided as an optimization in the case where {numberOfPumps} returns 1.\n     */\n    function firstPump() public pure returns (Call memory _pump) {\n        uint dataLoc = LOC_VARIABLE + numberOfTokens() * 32 + wellFunctionDataLength();\n        _pump.target = _getArgAddress(dataLoc);\n        uint pumpDataLength = _getArgUint256(dataLoc + 20);\n        _pump.data = _getArgBytes(dataLoc + 52, pumpDataLength);\n    }\n\n    //////////////////// SWAP: FROM ////////////////////\n\n    /**\n     * @dev MUST revert if a fee on transfer token is used. The requisite check\n     * is performed in {_setReserves}.\n     */\n    function swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint amountOut) {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    /**\n     * @dev Note that `amountOut` is the amount *transferred* by the Well; if a fee\n     * is charged on transfers of `toToken`, the amount received by `recipient`\n     * will be less than `amountOut`.\n     */\n    function swapFromFeeOnTransfer(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint amountOut) {\n        amountIn = _safeTransferFromFeeOnTransfer(fromToken, msg.sender, amountIn);\n        amountOut = _swapFrom(fromToken, toToken, amountIn, minAmountOut, recipient);\n    }\n\n    function _swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient\n    ) internal returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n        uint reserveJBefore = reserves[j];\n        reserves[j] = _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountOut = reserveJBefore - reserves[j];\n        if (amountOut < minAmountOut) {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapOut(IERC20 fromToken, IERC20 toToken, uint amountIn) external view returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[i] += amountIn;\n\n        // underflow is desired; Well Function SHOULD NOT increase reserves of both `i` and `j`\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// SWAP: TO ////////////////////\n\n    /**\n     * @dev {swapTo} does not support fee on transfer tokens, and no corresponding\n     * \"swapToFeeOnTransfer\" function is provided as this would require either:\n     * (a) inclusion of the fee as a parameter with verification; or\n     * (b) iterative transfers which attempts to back-calculate the fee.\n     */\n    function swapTo(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint maxAmountIn,\n        uint amountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n        uint reserveIBefore = reserves[i];\n        reserves[i] = _calcReserve(wellFunction(), reserves, i, totalSupply());\n\n        // Note: The rounding approach of the Well function determines whether\n        // slippage from imprecision goes to the Well or to the User.\n        amountIn = reserves[i] - reserveIBefore;\n\n        if (amountIn > maxAmountIn) {\n            revert SlippageIn(amountIn, maxAmountIn);\n        }\n\n        _swapTo(fromToken, toToken, amountIn, amountOut, recipient);\n        _setReserves(_tokens, reserves);\n    }\n\n    /**\n     * @dev Executes token transfers and emits Swap event. Used by {swapTo} to\n     * avoid stack too deep errors.\n     */\n    function _swapTo(IERC20 fromToken, IERC20 toToken, uint amountIn, uint amountOut, address recipient) internal {\n        fromToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        toToken.safeTransfer(recipient, amountOut);\n        emit Swap(fromToken, toToken, amountIn, amountOut, recipient);\n    }\n\n    /**\n     * @dev Assumes both tokens incur no fee on transfer.\n     */\n    function getSwapIn(IERC20 fromToken, IERC20 toToken, uint amountOut) external view returns (uint amountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        (uint i, uint j) = _getIJ(_tokens, fromToken, toToken);\n\n        reserves[j] -= amountOut;\n\n        amountIn = _calcReserve(wellFunction(), reserves, i, totalSupply()) - reserves[i];\n    }\n\n    //////////////////// SHIFT ////////////////////\n\n    /**\n     * @dev When using Wells for a multi-step swap, gas costs can be reduced by\n     * \"shifting\" tokens from one Well to another rather than returning them to\n     * a router (like Pipeline).\n     *\n     * Example multi-hop swap: WETH -> DAI -> USDC\n     *\n     * 1. Using a router without {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=0xROUTER)                     [1]\n     *  Call the router, which performs:\n     *      Well1.swapFrom(fromToken=WETH, toToken=DAI, recipient=0xROUTER)\n     *          WETH.transfer(sender=0xROUTER, recipient=Well1)              [2]\n     *          DAI.transfer(sender=Well1, recipient=0xROUTER)               [3]\n     *      Well2.swapFrom(fromToken=DAI, toToken=USDC, recipient=0xROUTER)\n     *          DAI.transfer(sender=0xROUTER, recipient=Well2)               [4]\n     *          USDC.transfer(sender=Well2, recipient=0xROUTER)              [5]\n     *  USDC.transfer(sender=0xROUTER, recipient=0xUSER)                     [6]\n     *\n     *  Note: this could be optimized by configuring the router to deliver\n     *  tokens from the last swap directly to the user.\n     *\n     * 2. Using a router with {shift}:\n     *  WETH.transfer(sender=0xUSER, recipient=Well1)                        [1]\n     *  Call the router, which performs:\n     *      Well1.shift(tokenOut=DAI, recipient=Well2)\n     *          DAI.transfer(sender=Well1, recipient=Well2)                  [2]\n     *      Well2.shift(tokenOut=USDC, recipient=0xUSER)\n     *          USDC.transfer(sender=Well2, recipient=0xUSER)                [3]\n     */\n    function shift(\n        IERC20 tokenOut,\n        uint minAmountOut,\n        address recipient\n    ) external nonReentrant returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = new uint[](_tokens.length);\n\n        // Use the balances of the pool instead of the stored reserves.\n        // If there is a change in token balances relative to the currently\n        // stored reserves, the extra tokens can be shifted into `tokenOut`.\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n        uint j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n\n        if (amountOut >= minAmountOut) {\n            tokenOut.safeTransfer(recipient, amountOut);\n            reserves[j] -= amountOut;\n            _setReserves(_tokens, reserves);\n            emit Shift(reserves, tokenOut, amountOut, recipient);\n        } else {\n            revert SlippageOut(amountOut, minAmountOut);\n        }\n    }\n\n    function getShiftOut(IERC20 tokenOut) external view returns (uint amountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n\n        uint j = _getJ(_tokens, tokenOut);\n        amountOut = reserves[j] - _calcReserve(wellFunction(), reserves, j, totalSupply());\n    }\n\n    //////////////////// ADD LIQUIDITY ////////////////////\n\n    function addLiquidity(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, false);\n    }\n\n    function addLiquidityFeeOnTransfer(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint lpAmountOut) {\n        lpAmountOut = _addLiquidity(tokenAmountsIn, minLpAmountOut, recipient, true);\n    }\n\n    /**\n     * @dev Gas optimization: {IWell.AddLiquidity} is emitted even if `lpAmountOut` is 0.\n     */\n    function _addLiquidity(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        bool feeOnTransfer\n    ) internal returns (uint lpAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n\n        if (feeOnTransfer) {\n            for (uint i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                tokenAmountsIn[i] = _safeTransferFromFeeOnTransfer(_tokens[i], msg.sender, tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        } else {\n            for (uint i; i < _tokens.length; ++i) {\n                if (tokenAmountsIn[i] == 0) continue;\n                _tokens[i].safeTransferFrom(msg.sender, address(this), tokenAmountsIn[i]);\n                reserves[i] = reserves[i] + tokenAmountsIn[i];\n            }\n        }\n\n        lpAmountOut = _calcLpTokenSupply(wellFunction(), reserves) - totalSupply();\n        if (lpAmountOut < minLpAmountOut) {\n            revert SlippageOut(lpAmountOut, minLpAmountOut);\n        }\n\n        _mint(recipient, lpAmountOut);\n        _setReserves(_tokens, reserves);\n        emit AddLiquidity(tokenAmountsIn, lpAmountOut, recipient);\n    }\n\n    /**\n     * @dev Assumes that no tokens involved incur a fee on transfer.\n     */\n    function getAddLiquidityOut(uint[] memory tokenAmountsIn) external view returns (uint lpAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = reserves[i] + tokenAmountsIn[i];\n        }\n        lpAmountOut = _calcLpTokenSupply(wellFunction(), reserves) - totalSupply();\n    }\n\n    //////////////////// REMOVE LIQUIDITY: BALANCED ////////////////////\n\n    function removeLiquidity(\n        uint lpAmountIn,\n        uint[] calldata minTokenAmountsOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint[] memory tokenAmountsOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        uint lpTokenSupply = totalSupply();\n\n        tokenAmountsOut = new uint[](_tokens.length);\n        _burn(msg.sender, lpAmountIn);\n        for (uint i; i < _tokens.length; ++i) {\n            tokenAmountsOut[i] = (lpAmountIn * reserves[i]) / lpTokenSupply;\n            if (tokenAmountsOut[i] < minTokenAmountsOut[i]) {\n                revert SlippageOut(tokenAmountsOut[i], minTokenAmountsOut[i]);\n            }\n            _tokens[i].safeTransfer(recipient, tokenAmountsOut[i]);\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidity(lpAmountIn, tokenAmountsOut, recipient);\n    }\n\n    function getRemoveLiquidityOut(uint lpAmountIn) external view returns (uint[] memory tokenAmountsOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        uint lpTokenSupply = totalSupply();\n\n        tokenAmountsOut = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            tokenAmountsOut[i] = (lpAmountIn * reserves[i]) / lpTokenSupply;\n        }\n    }\n\n    //////////////////// REMOVE LIQUIDITY: ONE TOKEN ////////////////////\n\n    function removeLiquidityOneToken(\n        uint lpAmountIn,\n        IERC20 tokenOut,\n        uint minTokenAmountOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint tokenAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n        uint j = _getJ(_tokens, tokenOut);\n\n        tokenAmountOut = _getRemoveLiquidityOneTokenOut(lpAmountIn, j, reserves);\n        if (tokenAmountOut < minTokenAmountOut) {\n            revert SlippageOut(tokenAmountOut, minTokenAmountOut);\n        }\n\n        _burn(msg.sender, lpAmountIn);\n        tokenOut.safeTransfer(recipient, tokenAmountOut);\n\n        reserves[j] = reserves[j] - tokenAmountOut;\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidityOneToken(lpAmountIn, tokenOut, tokenAmountOut, recipient);\n    }\n\n    function getRemoveLiquidityOneTokenOut(\n        uint lpAmountIn,\n        IERC20 tokenOut\n    ) external view returns (uint tokenAmountOut) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        uint j = _getJ(_tokens, tokenOut);\n        tokenAmountOut = _getRemoveLiquidityOneTokenOut(lpAmountIn, j, reserves);\n    }\n\n    /**\n     * @dev Shared logic for removing a single token from liquidity.\n     * Calculates change in reserve `j` given a change in LP token supply.\n     *\n     * Note: `lpAmountIn` is the amount of LP the user is burning in exchange\n     * for some amount of token `j`.\n     */\n    function _getRemoveLiquidityOneTokenOut(\n        uint lpAmountIn,\n        uint j,\n        uint[] memory reserves\n    ) private view returns (uint tokenAmountOut) {\n        uint newLpTokenSupply = totalSupply() - lpAmountIn;\n        uint newReserveJ = _calcReserve(wellFunction(), reserves, j, newLpTokenSupply);\n        tokenAmountOut = reserves[j] - newReserveJ;\n    }\n\n    //////////// REMOVE LIQUIDITY: IMBALANCED ////////////\n\n    function removeLiquidityImbalanced(\n        uint maxLpAmountIn,\n        uint[] calldata tokenAmountsOut,\n        address recipient,\n        uint deadline\n    ) external nonReentrant expire(deadline) returns (uint lpAmountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _updatePumps(_tokens.length);\n\n        for (uint i; i < _tokens.length; ++i) {\n            _tokens[i].safeTransfer(recipient, tokenAmountsOut[i]);\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n\n        lpAmountIn = totalSupply() - _calcLpTokenSupply(wellFunction(), reserves);\n        if (lpAmountIn > maxLpAmountIn) {\n            revert SlippageIn(lpAmountIn, maxLpAmountIn);\n        }\n        _burn(msg.sender, lpAmountIn);\n\n        _setReserves(_tokens, reserves);\n        emit RemoveLiquidity(lpAmountIn, tokenAmountsOut, recipient);\n    }\n\n    function getRemoveLiquidityImbalancedIn(uint[] calldata tokenAmountsOut) external view returns (uint lpAmountIn) {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = _getReserves(_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = reserves[i] - tokenAmountsOut[i];\n        }\n        lpAmountIn = totalSupply() - _calcLpTokenSupply(wellFunction(), reserves);\n    }\n\n    //////////////////// RESERVES ////////////////////\n\n    /**\n     * @dev Sync the reserves of the Well with its current balance of underlying tokens.\n     */\n    function sync() external nonReentrant {\n        IERC20[] memory _tokens = tokens();\n        uint[] memory reserves = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; ++i) {\n            reserves[i] = _tokens[i].balanceOf(address(this));\n        }\n        _setReserves(_tokens, reserves);\n        emit Sync(reserves);\n    }\n\n    /**\n     * @dev Transfer excess tokens held by the Wel"
    }
  ]
}