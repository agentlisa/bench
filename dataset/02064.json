{
  "Title": "M-5: If auction price goes to 0, NFT might become unclaimable/ stuck forever",
  "Content": "# Issue M-5: If auction price goes to 0, NFT might become unclaimable/ stuck forever \n\nSource: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/17 \n\n## Found by \nGimelSec, Koolex, Vagner, chaduke, deadrxsezzz\n\n## Summary\nThere are certain ERC20 tokens which revert on zero value transfers (e.g. LEND). If an NFT's price drops down to 0, nobody will be able to claim it as the transaction will always revert.\n\n## Vulnerability Detail\nThe time of  `loan.auction.duration` passes. The NFT's price is 0. Alice tries to purchase/ claim it, however the ERC20 token on which the auctions is going reverts on 0 value transfers. The NFT becomes stuck forever and no one can take the rights of it.\n\nConsider the following scenarios: \n1.\n > The ERC20 used in the auction is pausable \n > Throughout the auction, the token gets paused. Now, the auction is still going, the price is dropping and no one is able to claim it.\n > The ERC20 doesn't get unpaused up until the auction ends.\n > Since no one was able to purchase the NFT during the auction, its price now is 0. Since the token reverts on zero value transfers, the NFT is stuck forever.\n\n2.\n > Alice is looking at NFT auction which is coming near its end.\n > Alice is looking to purchase the NFT for as little as possible and starts monitoring the mempool, so in case someone tries to buy it, she can front-run the transaction and get the NFT herself. At this point Alice getting the NFT should be guaranteed\n > However, there aren't many other active users/ they aren't paying attention to said NFT. Little time goes by, auction ends and price is set to 0.\n > Alice is happy she can claim the NFT for free. However, the token reverts on 0 value transfers and now no one can claim it and the NFT is lost forever.\n\n## Impact\nNFT might be lost forever\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L43-#L45\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAddress ERC20 tokens which revert on 0 value transfers. Auctions which are run with such tokens should have a minimal price of 1 wei ( instead of 0)\n\n\n\n## Discussion\n\n**npasquie**\n\nfix: https://github.com/kairos-loan/kairos-contracts/pull/49\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/56",
  "Code": [
    {
      "filename": "kairos-contracts/src/AuctionFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IAuctionFacet} from \"./interface/IAuctionFacet.sol\";\n\nimport {BuyArg, NFToken, Ray} from \"./DataStructure/Objects.sol\";\nimport {Loan, Protocol, Provision, SupplyPosition} from \"./DataStructure/Storage.sol\";\nimport {RayMath} from \"./utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"./utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"./SupplyPositionLogic/SafeMint.sol\";\nimport {protocolStorage, supplyPositionStorage, ONE, ZERO} from \"./DataStructure/Global.sol\";\n// solhint-disable-next-line max-line-length\nimport {LoanAlreadyRepaid, CollateralIsNotLiquidableYet} from \"./DataStructure/Errors.sol\";\n\n/// @notice handles sale of collaterals being liquidated, following a dutch auction starting at repayment date\ncontract AuctionFacet is IAuctionFacet, SafeMint {\n    using RayMath for Ray;\n    using RayMath for uint256;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice buy one or multiple NFTs in liquidation\n    /// @param args arguments on what and how to buy\n    function buy(BuyArg[] memory args) external {\n        for (uint256 i = 0; i < args.length; i++) {\n            useLoan(args[i]);\n        }\n    }\n\n    /// @notice gets the price to buy the underlying collateral of the loan\n    /// @param loanId identifier of the loan\n    /// @return price computed price\n    function price(uint256 loanId) public view returns (uint256) {\n        Loan storage loan = protocolStorage().loan[loanId];\n        uint256 loanEndDate = loan.endDate;\n        uint256 timeSinceLiquidable = block.timestamp - loanEndDate;\n\n        checkLoanStatus(loanId);\n\n        /* the decreasing factor controls the evolution of the price from its initial value to 0 (and staying at 0)\n        over the course of the auction duration */\n        Ray decreasingFactor = timeSinceLiquidable >= loan.auction.duration\n            ? ZERO\n            : ONE.sub(timeSinceLiquidable.div(loan.auction.duration));\n\n        /* the estimated value arises from the mean of the loan offer loanToValues used in the loan regarding their\n        share in the collateral usage. This must stay consitent even if less than the full value of the NFT has been\n        used as collateral */\n        uint256 estimatedValue = loan.lent.mul(ONE.div(loan.shareLent));\n\n        /* by mutliplying the estimated price by some factor and slowly decreasing this price over time we aim to\n        make sure a liquidator will buy the NFT at fair market price. */\n        return estimatedValue.mul(loan.auction.priceFactor).mul(decreasingFactor);\n    }\n\n    /// @notice handles buying one NFT\n    /// @param arg arguments on what and how to buy\n    function useLoan(BuyArg memory arg) internal {\n        Loan storage loan = protocolStorage().loan[arg.loanId];\n\n        checkLoanStatus(arg.loanId);\n        uint256 toPay = price(arg.loanId);\n\n        /* store as liquidated and paid before transfers to avoid malicious reentrency, following\n        checks-effects-interaction pattern */\n        loan.payment.liquidated = true;\n        loan.payment.paid = toPay;\n        loan.assetLent.checkedTransferFrom(msg.sender, address(this), toPay);\n        loan.collateral.implem.safeTransferFrom(address(this), arg.to, loan.collateral.id);\n\n        emit Buy(arg.loanId, abi.encode(arg));\n    }\n\n    /// @notice checks that loan is liquidable, revert if not\n    /// @param loanId identifier of the loan\n    function checkLoanStatus(uint256 loanId) internal view {\n        Loan storage loan = protocolStorage().loan[loanId];\n\n        if (block.timestamp < loan.endDate) {\n            revert CollateralIsNotLiquidableYet(loan.endDate, loanId);\n        }\n        if (loan.payment.paid != 0 || loan.payment.liquidated) {\n            revert LoanAlreadyRepaid(loanId);\n        }\n    }\n}"
    }
  ]
}