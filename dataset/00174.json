{
  "Title": "M-4: FeeManager's admin cannot grant or revoke any role",
  "Content": "# Issue M-4: FeeManager's admin cannot grant or revoke any role \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/148 \n\n## Found by \n0x73696d616f, KupiaSec, fibonacci, fugazzi, juan, sammy\n## Summary\n\nThe `FeeManager` contract lacks an interface for the admin to grant or revoke roles.\n\n## Vulnerability Detail\n\nThe contest's README states:\n```bash\nADMIN_ROLE\n...\nOn FeeManager, this role can:\n...\n3) Grant or revoke any role to/from any address (`grantRole`, `revokeRole`).\n```\n\nThe `FeeManager` contract, inherited from solady's `OwnableRoles` contract, only permits the owner to manage roles.\n\n```solidity\n/// @dev Allows the owner to grant `user` `roles`.\n/// If the `user` already has a role, then it will be a no-op for the role.\nfunction grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\n    _grantRoles(user, roles);\n}\n\n/// @dev Allows the owner to remove `user` `roles`.\n/// If the `user` does not have a role, then it will be a no-op for the role.\nfunction revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\n    _removeRoles(user, roles);\n}\n```\n\nThe `FeeManager` contract itself does not provide any interfaces that enable the admin to grant or revoke roles.\n\n## Impact\n\nThe admin cannot grant or revoke any roles. This limitation cannot be changed since the contract is not upgradable. A new role can only be granted or revoked by the owner, which is the `TitlesCore` contract, and it also lacks the corresponding functions.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/README.md#q-are-there-any-protocol-roles-please-list-them-and-provide-whether-they-are-trusted-or-restricted-or-provide-a-more-comprehensive-description-of-what-a-role-can-and-cant-doimpact\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L115\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement admin interfaces to manage roles\n\n```solidity\nfunction grantRoles(address guy, uint256 roles)\n    public\n    payable\n    override\n    onlyOwnerOrRoles(ADMIN_ROLE)\n{\n    _grantRoles(guy, roles);\n}\n\nfunction revokeRoles(address guy, uint256 roles)\n    public\n    payable\n    override\n    onlyOwnerOrRoles(ADMIN_ROLE)\n{\n    _removeRoles(guy, roles);\n}\n```\n\n\n\n## Discussion\n\n**0xf1b0**\n\nEscalate\n\nI believe this is a valid issue. The implementation does not align with what is described in the README.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> I believe this is a valid issue. The implementation does not align with what is described in the README.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**WangSecurity**\n\nAgree with escalation that it's valid, but I believe it could be spotted on deployment and fixed with re-deploy without losing funds. Moreover, the roles can still be set and revoked. Hence, believe medium is approriate here, planning to accept the escalation.\n\n**WangSecurity**\n\nAgain, agree with escalation and making it a valid medium. Planning to make a new family of issues with the core issue \"roles are set incorrectly or not set at all\" with the following duplicates:\n\n#166, #197, #213, #146. \n\n**0xjuaan**\n\nhi @WangSecurity, #240 is a dupe of this\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xf1b0](https://github.com/sherlock-audit/2024-04-titles-judging/issues/148/#issuecomment-2107262040): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "README.md",
      "content": "# TITLES contest details\n\n- Join [Sherlock Discord](https://discord.gg/MABEWyASkp)\n- Submit findings using the issue page in your private contest repo (label issues as med or high)\n- [Read for more details](https://docs.sherlock.xyz/audits/watsons)\n\n# Q&A\n\n### Q: On what chains are the smart contracts going to be deployed?\nEthereum, Base, OP, Zora, Blast, Arbitrum, zkSync, Degen\n___\n\n### Q: If you are integrating tokens, are you allowing only whitelisted tokens to work with the codebase or any complying with the standard? Are they assumed to have certain properties, e.g. be non-reentrant? Are there any types of <a href=\"https://github.com/d-xo/weird-erc20\" target=\"_blank\" rel=\"noopener noreferrer\">weird tokens</a> you want to integrate?\nThe current version supports native ETH.\n___\n\n### Q: Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED? If these integrations are trusted, should auditors also assume they are always responsive, for example, are oracles trusted to provide non-stale information, or VRF providers to respond within a designated timeframe?\nThe only third-party integration we utilize at this time is 0xSplits, and there are no critical roles involved.  Any issues directly related to 0xSplits own implementation is NOT in scope, consider the protocol to be trusted for the purpose of this audit.\n___\n\n### Q: Are there any protocol roles? Please list them and provide whether they are TRUSTED or RESTRICTED, or provide a more comprehensive description of what a role can and can't do/impact.\nThere are a few roles in the system with varying levels of power. \n\nADMIN_ROLE (Trusted) => Granted by the deployer to internal, trusted addresses only.\n  On TitlesCore, this role can:\n    1) Change the ERC-1155 Edition implementation contract to an arbitrary address (`setEditionImplementation`). No post-auth validation is performed.\n    2) Upgrade the contract to an arbitrary new implementation (via `_authorizeUpgrade`, inherited and overridden with auth check from Solady's `UUPSUpgradeable`)\n\n  On TitlesGraph, this role can:\n    1) Create new Edges at will (`createEdges`). No post-auth validation is applied, except the typical uniqueness checks.\n    2) Upgrade the contract to an arbitrary new implementation (via `_authorizeUpgrade`, inherited and overridden with auth check from Solady's `UUPSUpgradeable`)\n    3) Grant or revoke any role to/from any address (`grantRole`, `revokeRole`).\n\n  On FeeManager, this role can:\n    1) Set the protocol fees (`setProtocolFees`). All fees are constrained to a constant range.\n    2) Create or change a fee route for any work within any Edition (`createRoute`). This is the only way to change the fee route for a work after publication.\n    3) Withdraw any funds locked in the contract (`withdraw`). This is the only way to withdraw funds from the contract.\n    3) Grant or revoke any role to/from any address (`grantRole`, `revokeRole`).\n\nEDITION_MANAGER_ROLE (Restricted) =>\n  On an Edition, this role can:\n    1) Publish a new work with any desired configuration (`publish`). This is the only way to create new works after the Edition is created.\n    2) Mint promotional copies of any work (`promoMint`). There are no limitations on this action aside from the work's supply cap and minting period.\n    3) Set the Edition's ERC2981 royalty receiver (`setRoyaltyTarget`). This is the only way to change the royalty receiver for the Edition.\n    4) Grant or revoke any role to/from any address (`grantRole`, `revokeRole`).\n\nEDITION_PUBLISHER_ROLE (Restricted) =>\n  On TitlesCore, this role can:\n    1) Publish a new work under any Edition for which they have been granted the role (i.e. `edition.hasAnyRole(msg.sender, EDITION_PUBLISHER_ROLE)` is true) (`publish`). After auth, the request is passed to the Edition contract for further handling.\n\nEDITION_MINTER_ROLE (Restricted) =>\n  On an Edition, this role can:\n    1) Mint promotional copies of any work (`promoMint`). There are no limitations on this action aside from the work's supply cap and minting period.\n\nOther roles which don't have specific role IDs:\n  - Editions have an Ownable `owner` who can:\n    1) Mint promotional copies of any work (`promoMint`). There are no limitations on this action aside from the work's supply cap and minting period.\n    2) Grant or revoke EDITION_PUBLISHER_ROLE to/from any address (`grantPublisherRole`, `revokePublisherRole`).\n    3) Manage the ERC1155 contract in typical ways (e.g. transfer ownership). Notably, the owner CANNOT manage roles other than EDITION_PUBLISHER_ROLE.\n\n  - Works within an Edition have a `creator` who can:\n    1) Update the minting period for the work (`setTimeframe`). This is the only way to change the minting period for a work after publication.\n    2) Set the fee strategy for any work within the Edition (`setFeeStrategy`). This is the only way to change the fee strategy for a work after publication. The fee strategy is validated by the Fee Manager, and the final strategy (which may have been modified during validation) is applied immediately.\n    3) Set the metadata for their own works. This is the only way to change the metadata for a work after publication.\n    4) Transfer full ownership of the work to a new address (`transferWork`). This is the only way to change the creator for a work.\n\n  - FeeManager has an Ownable `owner` (essentially synonymous with `ADMIN_ROLE`, held by TitlesCore) who can:\n    1) Set the protocol fees (`setProtocolFees`). All fees are constrained to a constant range. This role is granted to the TitlesCore contract whose currently scoped version does not have a mechanism for leveraging this permission directly.\n    2) Create or change a fee route for any work within any Edition (`createRoute`). This is the only way to change the fee route for a work after publication.\n___\n\n### Q: For permissioned functions, please list all checks and requirements that will be made before calling the function.\nTitlesCore:\n  - `initialize` => initializer, cannot be run twice\n  - `publish` => checks that the caller has the EDITION_PUBLISHER_ROLE on the given Edition. \n  - `setEditionImplementation` => checks that the caller is the owner or has the ADMIN_ROLE\n\nFeeManager:\n  - `createRoute` => checks that the caller is the owner or has the ADMIN_ROLE\n  - `setProtocolFees` => checks that the caller is the owner or has the ADMIN_ROLE\n  - `withdraw` => checks that the caller is the owner or has the ADMIN_ROLE\n\nTitlesGraph:\n  - `createEdge` => checks that the caller is the contract identified by the `from` node (the `node.entity.target`).\n  - `createEdges` => checks that the caller is the owner or has the ADMIN_ROLE\n  - `acknowledgeEdge` (standard flow) => checks that the caller is either the creator of the contract identified by the `to` node, or that contract itself.\n  - `unacknowledgeEdge` (standard flow) => checks that the caller is either the creator of the contract identified by the `to` node, or that contract itself.\n  - `acknowledgeEdge` (signature flow) => checks that the given signature is valid for the `to` node's creator (supports both ECDSA and ERC1271 signers), that the signed hash matches (based on the edge ID and data provided), and that the signature has not been previously used.\n  - `unacknowledgeEdge` (signature flow) => checks that the given signature is valid for the `to` node's creator (supports both ECDSA and ERC1271 signers), that the signed hash matches (based on the edge ID and data provided), and that the signature has not been previously used.\n\nEdition:\n  - `initialize` => initializer, cannot be run twice\n  - `publish` => checks that the caller has the EDITION_MANAGER_ROLE\n  - `promoMint` => checks that the caller is the owner of the Edition or holds the EDITION_MANAGER_ROLE or EDITION_MINTER_ROLE\n  - `setFeeStrategy` => checks that the caller is the creator of the work for which the strategy is being set.\n  - `setMetadata` => checks that the caller is the owner if ID is 0 (representing the Edition itself), or the creator of the specified work otherwise.\n  - `setTimeframe` => checks that the caller is the creator of the work for which the timeframe is being set.\n  - `transferWork` => checks that the caller is the creator of the work being transferred.\n  - `grantRoles`/`revokeRoles` => checks that the caller has the EDITION_MANAGER_ROLE\n  - `grantPublisherRole`/`revokePublisherRole` => checks that the caller is the owner of the Edition or has the EDITION_MANAGER_ROLE\n___\n\n### Q: Is the codebase expected to comply with any EIPs? Can there be/are there any deviations from the specification?\nstrict implementation of EIPs\n1271 (Graph), 712 (Graph, Edition), 2981 (Edition), 1155 (Edition)\n___\n\n### Q: Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, arbitrage bots, etc.)?\nN/A\n___\n\n### Q: Are there any hardcoded values that you intend to change before (some) deployments?\nThe exact amounts of the fees controlled by FeeManager may change before deployment, but only within the bounds of the current fee constants.\n___\n\n### Q: If the codebase is to be deployed on an L2, what should be the behavior of the protocol in case of sequencer issues (if applicable)? Should Sherlock assume that the Sequencer won't misbehave, including going offline?\nOut of scope\n___\n\n### Q: Should potential issues, like broken assumptions about function behavior, be reported if they could pose risks in future integrations, even if they might not be an issue in the context of the scope? If yes, can you elaborate on properties/invariants that should hold?\nYes.\n___\n\n### Q: Please discuss any design choices you made.\nFund Management: We chose to delegate fee payouts to 0xSplits v2. The protocol aims to avoid any direct TVL in this release.\n\nGraph: This is a new concept with a vast future design space, so we've erred on the side of a minimal implementation with low complexity. We intend to further standardize the OpenGraph model in the future.\n___\n\n### Q: Please list any known issues/acceptable risks that should not result in a valid finding.\nN/A\n___\n\n### Q: We will report issues where the core protocol functionality is inaccessible for at least 7 days. Would you like to override this value?\nNo\n___\n\n### Q: Please provide links to previous audits (if any).\nN/A\n___\n\n### Q: Please list any relevant protocol resources.\nRun `forge doc` or check out the /docs directory in the repo for pretty comprehensive auto-generated docs from the natspec. \n___\n\n### Q: Additional audit information.\nIn addition to the security of funds, we would also like there to be focus on the sanctity of the data in the TitlesGraph and the permissioning around it (only the appropriate people/contracts can signal reference and acknowledgement of reference). \n___\n\n\n\n# Audit scope\n\n\n[wallflower-contract-v2 @ d23c44def46ce4fd74f3daae36df0135acae7505](https://github.com/titlesnyc/wallflower-contract-v2/tree/d23c44def46ce4fd74f3daae36df0135acae7505)\n- [wallflower-contract-v2/src/TitlesCore.sol](wallflower-contract-v2/src/TitlesCore.sol)\n- [wallflower-contract-v2/src/editions/Edition.sol](wallflower-contract-v2/src/editions/Edition.sol)\n- [wallflower-contract-v2/src/fees/FeeManager.sol](wallflower-contract-v2/src/fees/FeeManager.sol)\n- [wallflower-contract-v2/src/graph/TitlesGraph.sol](wallflower-contract-v2/src/graph/TitlesGraph.sol)\n- [wallflower-contract-v2/src/shared/Common.sol](wallflower-contract-v2/src/shared/Common.sol)"
    },
    {
      "filename": "wallflower-contract-v2/src/fees/FeeManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {LibZip} from \"solady/utils/LibZip.sol\";\nimport {OwnableRoles} from \"solady/auth/OwnableRoles.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {SplitFactoryV2} from \"splits-v2/splitters/SplitFactoryV2.sol\";\nimport {SplitV2Lib} from \"splits-v2/libraries/SplitV2.sol\";\n\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport \"src/shared/Common.sol\";\n\n/// @title Titles Fee Manager\n/// @notice Manages fees for the Titles Protocol\n/// @dev The FeeManager contract is responsible for collecting fees associated with protocol actions.\ncontract FeeManager is OwnableRoles {\n    using SafeTransferLib for address;\n    using LibZip for bytes;\n\n    /// @notice The payload for creating a {Strategy}.\n    /// @param edition The address of the {Edition} to be associated with the {Strategy}.\n    /// @param tokenId The ID of the token to be associated with the {Strategy}.\n    /// @param strategy The {Strategy} to be created.\n    struct StrategyPayload {\n        address edition;\n        uint256 tokenId;\n        Strategy strategy;\n    }\n\n    /////////////////////\n    // Events & Errors //\n    /////////////////////\n\n    /// @notice Emitted when a fee is collected.\n    /// @param edition The address of the edition for which the fee was collected.\n    /// @param work The ID of the work for which the fee was collected.\n    /// @param asset The address of the asset which was collected.\n    /// @param fee The amount of the fee collected.\n    /// @param referrerShare The portion of the collected fee which was paid to the referrer.\n    event FeeCollected(\n        address indexed edition, uint256 work, address asset, uint256 fee, uint256 referrerShare\n    );\n\n    /// @notice Emitted when the protocol fees are changed.\n    /// @param protocolFeeBps The new protocol fee in basis points.\n    /// @param protocolFlatFee The new protocol flat fee.\n    /// @param mintReferrerRevshareBps The new partner revenue share in basis points.\n    event ProtocolFeesChanged(\n        uint16 protocolFeeBps, uint128 protocolFlatFee, uint16 mintReferrerRevshareBps\n    );\n\n    /// @notice Thrown when an invalid fee configuration is supplied.\n    error InvalidFee();\n\n    /// @notice Thrown when a fee cannot be routed.\n    error NotRoutable();\n\n    ///////////////////\n    // Fee Constants //\n    ///////////////////\n\n    /// @dev The maximum basis points (BPS) value. Equivalent to 100%.\n    uint16 public constant MAX_BPS = 10_000;\n\n    /// @dev The maximum protocol fee in basis points (BPS). Equivalent to 33.33%.\n    uint16 public constant MAX_PROTOCOL_FEE_BPS = 3333;\n\n    /// @dev The maximum protocol fee in wei. Applies to both flat and percentage fees.\n    uint64 public constant MAX_PROTOCOL_FEE = 0.1 ether;\n\n    /// @dev The maximum royalty fee in basis points (BPS). Equivalent to 95%.\n    uint16 public constant MAX_ROYALTY_BPS = 9500;\n\n    /// @dev The minimum royalty fee in basis points (BPS). Equivalent to 2.5%.\n    uint16 public constant MIN_ROYALTY_BPS = 250;\n\n    ///////////////////////\n    // Fee Configuration //\n    ///////////////////////\n\n    /// @notice The protocol creation fee. This fee is collected when a new {Edition} is created.\n    uint128 public protocolCreationFee = 0.0001 ether;\n\n    /// @notice The flat fee for the protocol. This fee is collected on all mint transactions.\n    uint128 public protocolFlatFee = 0.0006 ether;\n\n    /// @notice The protocol fee share in basis points (BPS). Only applies to protocol fees collected for unpriced mints.\n    uint32 public protocolFeeshareBps = 3333;\n\n    /// @notice The share of protocol fees to be distributed to the direct referrer of the mint, in basis points (BPS).\n    uint16 public mintReferrerRevshareBps = 5000;\n\n    /// @notice The share of protocol fees to be distributed to the referrer of the collection, in basis points (BPS).\n    uint16 public collectionReferrerRevshareBps = 2500;\n\n    /// @notice The address of the protocol fee receiver.\n    address public protocolFeeReceiver;\n\n    /// @notice The {SplitFactoryV2} contract used to create fee splits.\n    SplitFactoryV2 public splitFactory;\n\n    /// @notice The mapping of referrers for each {Edition}'s creation.\n    mapping(IEdition edition => address referrer) public referrers;\n\n    /// @notice The mapping of fee receivers by ID.\n    mapping(bytes32 id => Target receiver) private _feeReceivers;\n\n    /// @notice Initializes the {FeeManager} contract.\n    /// @param protocolFeeReceiver_ The address of the protocol fee receiver.\n    /// @param splitFactory_ The address of the {SplitFactoryV2} contract.\n    constructor(address admin_, address protocolFeeReceiver_, address splitFactory_) {\n        _initializeOwner(msg.sender);\n        _grantRoles(admin_, ADMIN_ROLE);\n        protocolFeeReceiver = protocolFeeReceiver_;\n        splitFactory = SplitFactoryV2(splitFactory_);\n    }\n\n    /// @notice Creates a new fee route for the given {Edition} and attributions.\n    /// @param edition_ The {Edition} for which to create the route.\n    /// @param tokenId_ The token ID associated with the route.\n    /// @param attributions_ The attributions to be associated with the route.\n    /// @param referrer_ The address of the referrer to receive a share of the fee.\n    function createRoute(\n        IEdition edition_,\n        uint256 tokenId_,\n        Target[] calldata attributions_,\n        address referrer_\n    ) external onlyOwnerOrRoles(ADMIN_ROLE) returns (Target memory receiver) {\n        Target memory creator = edition_.node(tokenId_).creator;\n\n        if (attributions_.length == 0) {\n            // No attributions, pay the creator directly\n            receiver = creator;\n        } else {\n            // Distribute the fee among the creator and attributions\n            (address[] memory targets, uint256[] memory revshares) = _buildSharesAndTargets(\n                creator, attributions_, edition_.feeStrategy(tokenId_).revshareBps\n            );\n\n            // Create the split. The protocol retains \"ownership\" to enable future use cases.\n            receiver = Target({\n                target: splitFactory.createSplit(\n                    SplitV2Lib.Split({\n                        recipients: targets,\n                        allocations: revshares,\n                        totalAllocation: 1e6,\n                        distributionIncentive: 0\n                    }),\n                    address(this),\n                    creator.target\n                    ),\n                chainId: creator.chainId\n            });\n        }\n\n        _feeReceivers[getRouteId(edition_, tokenId_)] = receiver;\n        referrers[edition_] = referrer_;\n    }\n\n    /// @notice Collects the creation fee for a given {Edition}.\n    /// @param edition_ The {Edition} for which to collect the creation fee.\n    /// @param tokenId_ The token ID associated with the fee.\n    /// @param feePayer_ The address of the account paying the fee.\n    function collectCreationFee(IEdition edition_, uint256 tokenId_, address feePayer_)\n        external\n        payable\n    {\n        Fee memory fee = getCreationFee();\n        if (fee.amount == 0) return;\n\n        _route(fee, Target({target: protocolFeeReceiver, chainId: block.chainid}), feePayer_);\n        emit FeeCollected(address(edition_), tokenId_, ETH_ADDRESS, fee.amount, 0);\n    }\n\n    /// @notice Collects the mint fee for a given {Edition}.\n    /// @param edition_ The {Edition} for which to collect the mint fee.\n    /// @param tokenId_ The token ID associated with the fee.\n    /// @param amount_ The amount of the fee to collect.\n    /// @param payer_ The address of the account paying the fee.\n    /// @param referrer_ The address of the referrer to receive a share of the fee.\n    function collectMintFee(\n        IEdition edition_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address payer_,\n        address referrer_\n    ) external payable {\n        _collectMintFee(\n            edition_, tokenId_, amount_, payer_, referrer_, getMintFee(edition_, tokenId_, amount_)\n        );\n    }\n\n    /// @notice Collects the mint fee for a given {Edition} and token ID, routing it as appropriate.\n    /// @param edition The {Edition} for which the fee is being collected.\n    /// @param tokenId_ The token ID associated with the fee.\n    /// @param amount_ The amount of the fee to collect.\n    /// @param payer_ The address of the account paying the fee.\n    /// @param referrer_ The address of the referrer to receive a share of the fee.\n    /// @param strategy_ The {Strategy} to use for computing the fee split.\n    function collectMintFee(\n        IEdition edition,\n        uint256 tokenId_,\n        uint256 amount_,\n        address payer_,\n        address referrer_,\n        Strategy calldata strategy_\n    ) external payable {\n        _collectMintFee(\n            edition, tokenId_, amount_, payer_, referrer_, getMintFee(strategy_, amount_)\n        );\n    }\n\n    /// @notice Gets the fee receiver for a given {Edition}.\n    /// @param edition_ The {Edition} for which to get the fee receiver.\n    /// @return feeReceiver The {Target} to receive the fee.\n    function feeReceiver(IEdition edition_, uint256 tokenId_) public view returns (Target memory) {\n        return _feeReceivers[getRouteId(edition_, tokenId_)];\n    }\n\n    /// @notice Calculates the fee for creating a new {Edition}.\n    /// @return fee The {Fee} for creating a new {Edition}.\n    /// @dev The creation fee is a flat fee collected by the protocol when a new {Edition} is created.\n    function getCreationFee() public view returns (Fee memory fee) {\n        return Fee({asset: ETH_ADDRESS, amount: protocolCreationFee});\n    }\n\n    /// @notice Calculates the mint fee for a given {Edition} based on its {Strategy}.\n    /// @param edition_ The {Edition} for which to calculate the mint fee.\n    /// @return fee The {Fee} for minting the {Edition}.\n    /// @dev The mint fee is calculated as the sum of:\n    ///      - The mint fee specified by the creator in the {Strategy}.\n    ///      - The protocol's base transaction fee (see {protocolFlatFee}).\n    function getMintFee(IEdition edition_, uint256 tokenId_, uint256 quantity_)\n        public\n        view\n        returns (Fee memory fee)\n    {\n        return getMintFee(edition_.feeStrategy(tokenId_), quantity_);\n    }\n\n    /// @notice Calculates the mint fee for a given {Strategy} based on the quantity of tokens being minted.\n    /// @param strategy_ The {Strategy} for which to calculate the mint fee.\n    /// @param quantity_ The quantity of tokens being minted.\n    /// @return fee The {Fee} for minting the tokens.\n    /// @dev The mint fee is calculated as the sum of:\n    ///      - The {Strategy.mintFee}.\n    ///      - The {protocolFlatFee}.\n    function getMintFee(Strategy memory strategy_, uint256 quantity_)\n        public\n        view\n        returns (Fee memory fee)\n    {\n        // Return the total fee (creator's mint fee + protocol flat fee)\n        return Fee({asset: ETH_ADDRESS, amount: quantity_ * (strategy_.mintFee + protocolFlatFee)});\n    }\n\n    /// @notice Calculates the referrer share for a given amount.\n    /// @param protocolFee_ The amount from which to calculate the referrer share.\n    /// @return referrerShare The mint referrer's share.\n    function getMintReferrerShare(uint256 protocolFee_, address referrer_)\n        public\n        view\n        returns (uint256)\n    {\n        if (referrer_ == address(0)) return 0;\n        return protocolFee_ * mintReferrerRevshareBps / MAX_BPS;\n    }\n\n    /// @notice Calculates the collection referrer share for a given amount.\n    /// @param protocolFee_ The amount from which to calculate the collection referrer share.\n    /// @return referrerShare The collection referrer's share.\n    function getCollectionReferrerShare(uint256 protocolFee_, address referrer_)\n        public\n        view\n        returns (uint256)\n    {\n        if (referrer_ == address(0)) return 0;\n        return protocolFee_ * collectionReferrerRevshareBps / MAX_BPS;\n    }\n\n    /// @notice Gets the route ID for a given {Edition} and token ID.\n    /// @param edition_ The {Edition} for which to get the route ID.\n    /// @param tokenId_ The token ID for which to get the route ID.\n    /// @return id The route ID.\n    function getRouteId(IEdition edition_, uint256 tokenId_) public pure returns (bytes32 id) {\n        return keccak256(abi.encodePacked(edition_, tokenId_));\n    }\n\n    /// @notice Updates the protocol fees which are collected for various actions.\n    /// @param protocolCreationFee_ The new protocol creation fee. This fee is collected when a new {Edition} is created. Cannot exceed {MAX_PROTOCOL_FEE}.\n    /// @param protocolFlatFee_ The new protocol flat fee. This fee is collected on all mint transactions. Cannot exceed {MAX_PROTOCOL_FEE}.\n    /// @param protocolFeeShareBps_ The new protocol fee share in basis points. Cannot exceed {MAX_PROTOCOL_FEE_BPS}.\n    /// @param mintReferrerRevshareBps_ The new mint referrer revenue share in basis points. This plus the collection referrer share cannot exceed {MAX_ROYALTY_BPS}.\n    /// @param collectionReferrerRevshareBps_ The new collection referrer revenue share in basis points. This plus the mint referrer share cannot exceed {MAX_ROYALTY_BPS}.\n    /// @dev This function can only be called by the owner or an admin.\n    function setProtocolFees(\n        uint64 protocolCreationFee_,\n        uint64 protocolFlatFee_,\n        uint16 protocolFeeShareBps_,\n        uint16 mintReferrerRevshareBps_,\n        uint16 collectionReferrerRevshareBps_\n    ) external onlyOwnerOrRoles(ADMIN_ROLE) {\n        if (\n            protocolCreationFee_ > MAX_PROTOCOL_FEE || protocolFlatFee_ > MAX_PROTOCOL_FEE\n                || protocolFeeShareBps_ > MAX_PROTOCOL_FEE_BPS\n                || (mintReferrerRevshareBps_ + collectionReferrerRevshareBps_) > MAX_BPS\n        ) {\n            revert InvalidFee();\n        }\n        protocolCreationFee = protocolCreationFee_;\n        protocolFlatFee = protocolFlatFee_;\n        protocolFeeshareBps = protocolFeeShareBps_;\n        mintReferrerRevshareBps = mintReferrerRevshareBps_;\n        collectionReferrerRevshareBps = collectionReferrerRevshareBps_;\n    }\n\n    /// @notice Returns a validated {Strategy} based on the given data.\n    /// @param strategy_ The {Strategy} to validate.\n    /// @return strategy The validated {Strategy}.\n    function validateStrategy(Strategy calldata strategy_)\n        external\n        pure\n        returns (Strategy memory strategy)\n    {\n        // Clamp the revshare to the range of [MIN_ROYALTY_BPS...MAX_ROYALTY_BPS]\n        uint16 revshareBps = strategy_.revshareBps > MAX_ROYALTY_BPS\n            ? MAX_ROYALTY_BPS\n            : strategy_.revshareBps < MIN_ROYALTY_BPS ? MIN_ROYALTY_BPS : strategy_.revshareBps;\n\n        // Clamp the royalty to the range of [0...MAX_ROYALTY_BPS]\n        uint16 royaltyBps =\n            strategy_.royaltyBps > MAX_ROYALTY_BPS ? MAX_ROYALTY_BPS : strategy_.royaltyBps;\n\n        strategy = Strategy({\n            asset: strategy_.asset == address(0) ? ETH_ADDRESS : strategy_.asset,\n            mintFee: strategy_.mintFee,\n            revshareBps: revshareBps,\n            royaltyBps: royaltyBps\n        });\n    }\n\n    /// @notice Allows the contract to receive ETH.\n    receive() external payable {}\n\n    /// @notice An escape hatch to transfer any trapped assets from the contract to the given address.\n    /// @param asset_ The address of the asset to withdraw.\n    /// @param amount_ The amount of the asset to withdraw.\n    /// @param to_ The address to send the asset to.\n    /// @dev This is meant to be used in cases where the contract is holding assets that it should not be. This function can only be called by an admin.\n    function withdraw(address asset_, uint256 amount_, address to_)\n        external\n        onlyRolesOrOwner(ADMIN_ROLE)\n    {\n        _transfer(asset_, amount_, address(this), to_);\n    }\n\n    /// @notice Collects the given {Fee} for a given {Edition} and token ID, routing it as appropriate.\n    /// @param edition_ The {Edition} for which the fee is being collected.\n    /// @param tokenId_ The token ID associated with the fee.\n    /// @param amount_ The amount of tokens being minted.\n    /// @param payer_ The address of the account paying the fee.\n    /// @param referrer_ The address of the referrer to receive a share of the fee.\n    /// @param fee_ The {Fee} to collect.\n    function _collectMintFee(\n        IEdition edition_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address payer_,\n        address referrer_,\n        Fee memory fee_\n    ) internal {\n        if (fee_.amount == 0) return;\n\n        // For free mints:\n        // - Protocol Share = 1/3 of flat fee\n        // - Edition Share = 2/3 of flat fee\n        //\n        // For priced mints:\n        // - Protocol Share = 100% of flat fee, shared as follows:\n        // - Edition Share = 100% of creator-specified mint cost, 0% of flat fee\n        //\n        // In both cases, the protocol and edition shares may be split as follows:\n        // - Protocol Share\n        //   - If a referred mint, mint referrer gets 50% of the protocol share\n        //   - If a referred collection, collection referrer gets 25% of the protcol share\n        //   - Protocol fee receiver gets the remainder of the protocol share\n        // - Edition Share\n        //   - Attributions equally split 25% of the edition share, if applicable\n        //   - Creator gets the remainder of the edition share\n\n        uint256 protocolFee = protocolFlatFee * amount_;\n        uint256 protocolShare;\n        if (fee_.amount == protocolFee) {\n            protocolShare = protocolFee * protocolFeeshareBps / MAX_BPS;\n        } else {\n            protocolShare = protocolFee;\n        }\n\n        _route(\n            Fee({asset: fee_.asset, amount: fee_.amount - protocolShare}),\n            _feeReceivers[getRouteId(edition_, tokenId_)],\n            payer_\n        );\n\n        uint256 referrerShare =\n            _splitProtocolFee(edition_, fee_.asset, protocolShare, payer_, referrer_);\n        emit FeeCollected(address(edition_), tokenId_, fee_.asset, fee_.amount, referrerShare);\n    }\n\n    function _splitProtocolFee(\n        IEdition edition_,\n        address asset_,\n        uint256 amount_,\n        address payer_,\n        address referrer_\n    ) internal returns (uint256 referrerShare) {\n        // The creation and mint referrers earn 25% and 50% of the protocol's share respectively, if applicable\n        uint256 mintReferrerShare = getMintReferrerShare(amount_, referrer_);\n        uint256 collectionReferrerShare = getCollectionReferrerShare(amount_, referrers[edition_]);\n        referrerShare = mintReferrerShare + collectionReferrerShare;\n\n        _route(\n            Fee({asset: asset_, amount: amount_ - referrerShare}),\n            Target({target: protocolFeeReceiver, chainId: block.chainid}),\n            payer_\n        );\n\n        _route(\n            Fee({asset: asset_, amount: mintReferrerShare}),\n            Target({target: referrer_, chainId: block.chainid}),\n            payer_\n        );\n\n        _route(\n            Fee({asset: asset_, amount: collectionReferrerShare}),\n            Target({target: referrer_, chainId: block.chainid}),\n            payer_\n        );\n    }\n\n    /// @notice Routes the given {Fee} to the appropriate receiver.\n    /// @param fee_ The {Fee} to route.\n    /// @param feeReceiver_ The {Target} to receive the fee.\n    /// @param feePayer_ The address of the account paying the fee.\n    /// @dev If the fee amount is zero, this function will return early. If the receiver is not on the same chain as the payer, this function will revert.\n    function _route(Fee memory fee_, Target memory feeReceiver_, address feePayer_) internal {\n        // Cross-chain fee routing is not supported yet\n        if (block.chainid != feeReceiver_.chainId) revert NotRoutable();\n        if (fee_.amount == 0) return;\n\n        _transfer(fee_.asset, fee_.amount, feePayer_, feeReceiver_.target);\n    }\n\n    /// @notice Transfers the given amount of the given asset from the sender to the receiver.\n    /// @param asset_ The address of the asset to transfer.\n    /// @param amount_ The amount of the asset to transfer.\n    /// @param from_ The address of the account sending the asset.\n    /// @param to_ The address of the account receiving the asset.\n    function _transfer(address asset_, uint256 amount_, address from_, address to_) internal {\n        if (asset_ == ETH_ADDRESS) {\n            to_.safeTransferETH(amount_);\n        } else {\n            asset_.safeTransferFrom(from_, to_, amount_);\n        }\n    }\n\n    /// @notice Builds the targets and shares arrays for a given creator and attributions.\n    /// @param creator The creator of the work.\n    /// @param attributions The attributions for the work.\n    /// @param revshareBps The revshare in basis points.\n    /// @return targets The array of targets.\n    /// @return shares The array of shares.\n    /// @dev Note that cross-chain payouts are not currently supported. Rather than reverting, this"
    }
  ]
}