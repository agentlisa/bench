{
  "Title": "[M-02] First liquidity provider will suffer from revert or fund loss",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/periphery/LiquidityManager.sol#L135\n\n\n# Vulnerability details\n\n## Impact\nThe first liquidity depositor should supply three input values `amount0Min, amount1Min, liquidity` via `AddLiquidityParams` but these three values should meet an accurate relationship, or else the depositor will suffer from revert or fund loss\n\n## Proof of Concept\nThe LPs are supposed to use the function `LiquidityManager.addLiquidity(AddLiquidityParams calldata params)` to add liquidity.\nWhen the pool is not empty, this function calculates the `amount0, amount1` according to the current total liquidity and the requested liquidity.\nBut when the pool is empty, these amounts are supposed to be provided by the caller.\n```solidity\nLiquidityManager.sol\n\n120:   struct AddLiquidityParams {\n121:     address token0;\n122:     address token1;\n123:     uint256 token0Exp;\n124:     uint256 token1Exp;\n125:     uint256 upperBound;\n126:     uint256 liquidity;\n127:     uint256 amount0Min;\n128:     uint256 amount1Min;\n129:     uint256 sizeMin;\n130:     address recipient;\n131:     uint256 deadline;\n132:   }\n133:\n134:   /// @notice Add liquidity to a liquidity position\n135:   function addLiquidity(AddLiquidityParams calldata params) external payable checkDeadline(params.deadline) {\n136:     address lendgine = LendgineAddress.computeAddress(\n137:       factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n138:     );\n139:\n140:     uint256 r0 = ILendgine(lendgine).reserve0();\n141:     uint256 r1 = ILendgine(lendgine).reserve1();\n142:     uint256 totalLiquidity = ILendgine(lendgine).totalLiquidity();\n143:\n144:     uint256 amount0;\n145:     uint256 amount1;\n146:\n147:     if (totalLiquidity == 0) {\n148:       amount0 = params.amount0Min;//@audit-info caller specifies the actual reserve amount\n149:       amount1 = params.amount1Min;//@audit-info\n150:     } else {\n151:       amount0 = FullMath.mulDivRoundingUp(params.liquidity, r0, totalLiquidity);\n152:       amount1 = FullMath.mulDivRoundingUp(params.liquidity, r1, totalLiquidity);\n153:     }\n154:\n155:     if (amount0 < params.amount0Min || amount1 < params.amount1Min) revert AmountError();\n156:\n157:     uint256 size = ILendgine(lendgine).deposit(\n158:       address(this),\n159:       params.liquidity,\n160:       abi.encode(\n161:         PairMintCallbackData({\n162:           token0: params.token0,\n163:           token1: params.token1,\n164:           token0Exp: params.token0Exp,\n165:           token1Exp: params.token1Exp,\n166:           upperBound: params.upperBound,\n167:           amount0: amount0,\n168:           amount1: amount1,\n169:           payer: msg.sender\n170:         })\n171:       )\n172:     );\n173:     if (size < params.sizeMin) revert AmountError();\n174:\n175:     Position memory position = positions[params.recipient][lendgine]; // SLOAD\n176:\n177:     (, uint256 rewardPerPositionPaid,) = ILendgine(lendgine).positions(address(this));\n178:     position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);\n179:     position.rewardPerPositionPaid = rewardPerPositionPaid;\n180:     position.size += size;\n181:\n182:     positions[params.recipient][lendgine] = position; // SSTORE\n183:\n184:     emit AddLiquidity(msg.sender, lendgine, params.liquidity, size, amount0, amount1, params.recipient);\n185:   }\n\n```\nThen how does the caller decides these amount? These values should be chosen very carefully as we explain below.\n\nThe whole protocol is based on its invariant that is defined in `Pair.invariant()`.\nThe invariant is actually ensuring that `a+b-c-d` stays not negative for all trades (interactions regarding reserve/liquidity).\nOnce `a+b-c-d` becomes strictly positive, anyone can call `swap()` function to pull the `token0` of that amount without any cost.\n```solidity\nPair.sol\n52:   /// @inheritdoc IPair\n53:   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n54:     if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n55:\n56:     uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n57:     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n58:\n59:     if (scale1 > 2 * upperBound) revert InvariantError();\n60:\n61:     uint256 a = scale0 * 1e18;\n62:     uint256 b = scale1 * upperBound;\n63:     uint256 c = (scale1 * scale1) / 4;\n64:     uint256 d = upperBound * upperBound;\n65:\n66:     return a + b >= c + d;//@audit-info if strict inequality holds, anyone can pull token0 using swap()\n67:   }\n```\n\nSo going back to the question, if the LP choose the values `amount0, amount1, liquidity` not accurately, the transaction reverts or `a+b-c-d` becomes greater than zero.\n\nGenerally, liquidity providers do not specify the desired liquidity amount in other protocols.\nDuring the conversation with the sponsor team, it is understood that they avoided the calculation of `liquidity` from `amount0, amount1` because it is too complicated.\nOff-chain calculation will be necessary to help the situation, and this would limit the growth of the protocol.\nIf any other protocol is going to integrate Numoen, they will face the same problem.\n\nI did some calculation and got the formula for the liquidity as below.\n\n$\nL = \\frac{PCy+C^2x+\\sqrt{2PC^3xy+C^4x^2}}{2P^2}\n$\nwhere $C=10^{18}$, $x$ is `amount0`, $y$ is `amount1`, $P$ is the `upperBound`, $L$ is the liquidity amount that should be used.\n\nBecause the LP will almost always suffer revert or fund loss without help of off-chain calculation, I submit this as a medium finding.\nI would like to note that there still exists a mitigation (not that crazy).\nAs a side note, it would be very helpful to add new preview functions.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nAdd a functionality to calculate the liquidity for the first deposit on-chain.\nAnd it is also recommended to add preview functions.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-numoen-contest",
  "Code": [
    {
      "filename": "src/periphery/LiquidityManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { Multicall } from \"./Multicall.sol\";\nimport { Payment } from \"./Payment.sol\";\nimport { SelfPermit } from \"./SelfPermit.sol\";\n\nimport { ILendgine } from \"../core/interfaces/ILendgine.sol\";\nimport { IPairMintCallback } from \"../core/interfaces/callback/IPairMintCallback.sol\";\n\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { LendgineAddress } from \"./libraries/LendgineAddress.sol\";\n\n/// @notice Manages liquidity provider positions\n/// @author Kyle Scott (kyle@numoen.com)\ncontract LiquidityManager is Multicall, Payment, SelfPermit, IPairMintCallback {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n  event AddLiquidity(\n    address indexed from,\n    address indexed lendgine,\n    uint256 liquidity,\n    uint256 size,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n\n  event RemoveLiquidity(\n    address indexed from,\n    address indexed lendgine,\n    uint256 liquidity,\n    uint256 size,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n\n  event Collect(address indexed from, address indexed lendgine, uint256 amount, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error LivelinessError();\n\n  error AmountError();\n\n  error ValidationError();\n\n  error PositionInvalidError();\n\n  error CollectError();\n\n  /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  address public immutable factory;\n\n  struct Position {\n    uint256 size;\n    uint256 rewardPerPositionPaid;\n    uint256 tokensOwed;\n  }\n\n  /// @notice Owner to lendgine to position\n  mapping(address => mapping(address => Position)) public positions;\n\n  /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n  constructor(address _factory, address _weth) Payment(_weth) {\n    factory = _factory;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           LIVELINESS MODIFIER\n    //////////////////////////////////////////////////////////////*/\n\n  modifier checkDeadline(uint256 deadline) {\n    if (deadline < block.timestamp) revert LivelinessError();\n    _;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                                CALLBACK\n    //////////////////////////////////////////////////////////////*/\n\n  struct PairMintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 amount0;\n    uint256 amount1;\n    address payer;\n  }\n\n  /// @notice callback that sends the underlying tokens for the specified amount of liquidity shares\n  function pairMintCallback(uint256, bytes calldata data) external {\n    PairMintCallbackData memory decoded = abi.decode(data, (PairMintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    if (decoded.amount0 > 0) pay(decoded.token0, decoded.payer, msg.sender, decoded.amount0);\n    if (decoded.amount1 > 0) pay(decoded.token1, decoded.payer, msg.sender, decoded.amount1);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        LIQUIDITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct AddLiquidityParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 liquidity;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    uint256 sizeMin;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Add liquidity to a liquidity position\n  function addLiquidity(AddLiquidityParams calldata params) external payable checkDeadline(params.deadline) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    uint256 r0 = ILendgine(lendgine).reserve0();\n    uint256 r1 = ILendgine(lendgine).reserve1();\n    uint256 totalLiquidity = ILendgine(lendgine).totalLiquidity();\n\n    uint256 amount0;\n    uint256 amount1;\n\n    if (totalLiquidity == 0) {\n      amount0 = params.amount0Min;\n      amount1 = params.amount1Min;\n    } else {\n      amount0 = FullMath.mulDivRoundingUp(params.liquidity, r0, totalLiquidity);\n      amount1 = FullMath.mulDivRoundingUp(params.liquidity, r1, totalLiquidity);\n    }\n\n    if (amount0 < params.amount0Min || amount1 < params.amount1Min) revert AmountError();\n\n    uint256 size = ILendgine(lendgine).deposit(\n      address(this),\n      params.liquidity,\n      abi.encode(\n        PairMintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          amount0: amount0,\n          amount1: amount1,\n          payer: msg.sender\n        })\n      )\n    );\n    if (size < params.sizeMin) revert AmountError();\n\n    Position memory position = positions[params.recipient][lendgine]; // SLOAD\n\n    (, uint256 rewardPerPositionPaid,) = ILendgine(lendgine).positions(address(this));\n    position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);\n    position.rewardPerPositionPaid = rewardPerPositionPaid;\n    position.size += size;\n\n    positions[params.recipient][lendgine] = position; // SSTORE\n\n    emit AddLiquidity(msg.sender, lendgine, params.liquidity, size, amount0, amount1, params.recipient);\n  }\n\n  struct RemoveLiquidityParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 size;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Removes from a liquidity position\n  function removeLiquidity(RemoveLiquidityParams calldata params) external payable checkDeadline(params.deadline) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n    (uint256 amount0, uint256 amount1, uint256 liquidity) = ILendgine(lendgine).withdraw(recipient, params.size);\n    if (amount0 < params.amount0Min || amount1 < params.amount1Min) revert AmountError();\n\n    Position memory position = positions[msg.sender][lendgine]; // SLOAD\n\n    (, uint256 rewardPerPositionPaid,) = ILendgine(lendgine).positions(address(this));\n    position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);\n    position.rewardPerPositionPaid = rewardPerPositionPaid;\n    position.size -= params.size;\n\n    positions[msg.sender][lendgine] = position; // SSTORE\n\n    emit RemoveLiquidity(msg.sender, lendgine, liquidity, params.size, amount0, amount1, recipient);\n  }\n\n  struct CollectParams {\n    address lendgine;\n    address recipient;\n    uint256 amountRequested;\n  }\n\n  /// @notice Collects interest owed to the callers liqudity position\n  function collect(CollectParams calldata params) external payable returns (uint256 amount) {\n    ILendgine(params.lendgine).accruePositionInterest();\n\n    address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n    Position memory position = positions[msg.sender][params.lendgine]; // SLOAD\n\n    (, uint256 rewardPerPositionPaid,) = ILendgine(params.lendgine).positions(address(this));\n    position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);\n    position.rewardPerPositionPaid = rewardPerPositionPaid;\n\n    amount = params.amountRequested > position.tokensOwed ? position.tokensOwed : params.amountRequested;\n    position.tokensOwed -= amount;\n\n    positions[msg.sender][params.lendgine] = position; // SSTORE\n\n    uint256 collectAmount = ILendgine(params.lendgine).collect(recipient, amount);\n    if (collectAmount != amount) revert CollectError(); // extra check for safety\n\n    emit Collect(msg.sender, params.lendgine, amount, recipient);\n  }\n}"
    }
  ]
}