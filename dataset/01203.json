{
  "Title": "Missing Check for Setting Alpha Values",
  "Content": "\n\n\n`alphaDenominator` should never exceed `alphaNumerator`, as specified by the audit documentation as well as this [error](https://github.com/VenusProtocol/venus-protocol/blob/f31a0543da039dab69112c6be3e36ea54959503b/contracts/Tokens/Prime/libs/Scores.sol#L43) which would be thrown in the `calculateScore` function: \n\n\n\n\n\n\n```\nassert(alphaNumerator <= alphaDenominator);  \n\n```\n\n\n\n\n\n\n\n\n\n\nConsider ensuring that `alphaNumerator <= alphaDenominator` in the [`initialize`](https://github.com/VenusProtocol/venus-protocol/blob/f31a0543da039dab69112c6be3e36ea54959503b/contracts/Tokens/Prime/Prime.sol#L85) and [`updateAlpha`](https://github.com/VenusProtocol/venus-protocol/blob/f31a0543da039dab69112c6be3e36ea54959503b/contracts/Tokens/Prime/Prime.sol#L112) functions. \n\n\n\n\n\n***Update:*** Resolved at commit [f7d463b](https://github.com/VenusProtocol/venus-protocol/commit/f7d463b4c9e3467aea026ce33d0f3f643ada3022), at commit [a7e913f](https://github.com/VenusProtocol/venus-protocol/commit/a7e913ff2bbc4489b8b76b2c01a07151ba0b2cdc), at commit [5a04aa0](https://github.com/VenusProtocol/venus-protocol/commit/5a04aa0354c3d5bbf6a91234547920c7f52a65cc).\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Tokens/Prime/libs/Scores.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport \"./FixedMath.sol\";\n\nusing SafeCastUpgradeable for uint256;\n\nlibrary Scores {\n    /**\n     * @notice Calculate a membership score given some amount of `xvs` and `capital`, along\n     *  with some ð° = `alphaNumerator` / `alphaDenominator`.\n     * @param xvs amount of xvs (xvs, 1e18 decimal places)\n     * @param capital amount of capital (USDC, 1e6 decimal places)\n     * @param alphaNumerator alpha param numerator\n     * @param alphaDenominator alpha param denominator\n     * @return membership score with 1e18 decimal places\n     *\n     * @dev ð° must be in the range [0, 1]\n     */\n    function calculateScore(\n        uint256 xvs,\n        uint256 capital,\n        uint256 alphaNumerator,\n        uint256 alphaDenominator\n    ) internal pure returns (uint256) {\n        // Score function is:\n        // xvs^ð° * capital^(1-ð°)\n        //    = capital * capital^(-ð°) * xvs^ð°\n        //    = capital * (xvs / capital)^ð°\n        //    = capital * (e ^ (ln(xvs / capital))) ^ ð°\n        //    = capital * e ^ (ð° * ln(xvs / capital))     (1)\n        // or\n        //    = capital / ( 1 / e ^ (ð° * ln(xvs / capital)))\n        //    = capital / (e ^ (ð° * ln(xvs / capital)) ^ -1)\n        //    = capital / e ^ (ð° * -1 * ln(xvs / capital))\n        //    = capital / e ^ (ð° * ln(capital / xvs))     (2)\n        //\n        // To avoid overflows, use (1) when xvs < capital and\n        // use (2) when capital < xvs\n\n        assert(alphaNumerator <= alphaDenominator);\n\n        // If any side is 0, exit early\n        if (xvs == 0 || capital == 0) return 0;\n\n        // If both sides are equal, we have:\n        // xvs^ð° * capital^(1-ð°)\n        //    = xvs^ð° * xvs^(1-ð°)\n        //    = xvs^(ð° + 1 - ð°)     = xvs\n        if (xvs == capital) return xvs;\n\n        bool lessxvsThanCapital = xvs < capital;\n\n        // (xvs / capital) or (capital / xvs), always in range (0, 1)\n        int256 ratio = lessxvsThanCapital ? FixedMath.toFixed(xvs, capital) : FixedMath.toFixed(capital, xvs);\n\n        // e ^ ( ln(ratio) * ð° )\n        int256 exponentiation = FixedMath.exp(\n            (FixedMath.ln(ratio) * alphaNumerator.toInt256()) / alphaDenominator.toInt256()\n        );\n\n        if (lessxvsThanCapital) {\n            // capital * e ^ (ð° * ln(xvs / capital))\n            return FixedMath.uintMul(capital, exponentiation);\n        }\n\n        // capital / e ^ (ð° * ln(capital / xvs))\n        return FixedMath.uintDiv(capital, exponentiation);\n    }\n}"
    },
    {
      "filename": "contracts/Tokens/Prime/Prime.sol",
      "content": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport \"./PrimeStorage.sol\";\nimport \"./libs/Scores.sol\";\n\ninterface IVToken {\n    function borrowBalanceStored(address account) external returns (uint);\n    function exchangeRateStored() external returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function underlying() external view returns (address);\n}\n\ninterface IXVSVault {\n    function getUserInfo(\n        address _rewardToken,\n        uint256 _pid,\n        address _user\n    ) external view returns (uint256 amount, uint256 rewardDebt, uint256 pendingWithdrawals);\n}\n\ninterface IProtocolShareReserve {\n    enum Schema {\n        DEFAULT,\n        SPREAD_PRIME_CORE\n    }\n\n    function getUnreleasedFunds(\n        address comptroller,\n        Schema schema,\n        address destination,\n        address asset\n    ) external view returns (uint256);\n\n    function releaseFunds(address comptroller, address[] memory assets) external;\n}\n\ninterface IIncomeDestination {\n    function updateAssetsState(address comptroller, address asset) external;\n}\n\nerror MarketNotSupported();\nerror InvalidLimit();\nerror IneligibleToClaim();\nerror WaitMoreTime();\nerror UserHasNoPrimeToken();\nerror InvalidCaller();\nerror InvalidComptroller();\nerror NoScoreUpdatesRequired();\nerror MarketAlreadyExists();\n\ncontract Prime is IIncomeDestination, AccessControlledV8, PrimeStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice address of WBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WBNB;\n\n    /// @notice address of vBNB contract\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vBNB;\n\n    /// @notice Emitted when prime token is minted\n    event Mint(address indexed user, bool isIrrevocable);\n\n    /// @notice Emitted when prime token is burned\n    event Burn(address indexed user);\n\n    /// @notice Emitted asset state is update by protocol share reserve\n    event UpdatedAssetsState(address indexed comptroller, address indexed asset);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _wbnb, address _vbnb) {\n        require(_wbnb != address(0), \"Prime: WBNB address invalid\");\n        require(_vbnb != address(0), \"Prime: vBNB address invalid\");\n        WBNB = _wbnb;\n        vBNB = _vbnb;\n\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _xvsVault,\n        address _xvsVaultRewardToken,\n        uint256 _xvsVaultPoolId,\n        uint128 _alphaNumerator,\n        uint128 _alphaDenominator,\n        address _accessControlManager,\n        address _protocolShareReserve,\n        address _comptroller\n    ) external virtual initializer {\n        alphaNumerator = _alphaNumerator;\n        alphaDenominator = _alphaDenominator;\n        xvsVaultRewardToken = _xvsVaultRewardToken;\n        xvsVaultPoolId = _xvsVaultPoolId;\n        xvsVault = _xvsVault;\n        nextScoreUpdateRoundId = 0;\n        protocolShareReserve = _protocolShareReserve;\n        comptroller = _comptroller;\n\n        __AccessControlled_init(_accessControlManager);\n    }\n\n    /**\n     * @notice Update value of alpha\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\n     */\n    function updateAlpha(uint128 _alphaNumerator, uint128 _alphaDenominator) external {\n        _checkAccessAllowed(\"updateAlpha(uint128,uint128)\");\n\n        alphaNumerator = _alphaNumerator;\n        alphaDenominator = _alphaDenominator;\n\n        for (uint i = 0; i < allMarkets.length; i++) {\n            accrueInterest(allMarkets[i]);\n        }\n\n        _startScoreUpdateRound();\n    }\n\n    /**\n     * @notice Update multipliers for a market\n     * @param _supplyMultiplier new supply multiplier for the market\n     * @param _borrowMultiplier new borrow multiplier for the market\n     */\n    function updateMultipliers(address market, uint256 _supplyMultiplier, uint256 _borrowMultiplier) external {\n        _checkAccessAllowed(\"updateMultipliers(address,uint256,uint256)\");\n        if (!markets[market].exists) revert MarketNotSupported();\n        \n        accrueInterest(market);\n        markets[market].supplyMultiplier = _supplyMultiplier;\n        markets[market].borrowMultiplier = _borrowMultiplier;\n\n        _startScoreUpdateRound();\n    }\n\n    /**\n     * @notice Add a market to prime program\n     * @param vToken address of the market vToken\n     * @param supplyMultiplier the multiplier for supply cap. It should be converted to 1e18\n     * @param borrowMultiplier the multiplier for borrow cap. It should be converted to 1e18\n     */\n    function addMarket(address vToken, uint256 supplyMultiplier, uint256 borrowMultiplier) external {\n        _checkAccessAllowed(\"addMarket(address,uint256,uint256)\");\n        if (markets[vToken].exists) revert MarketAlreadyExists();\n\n        markets[vToken].rewardIndex = 0;\n        markets[vToken].supplyMultiplier = supplyMultiplier;\n        markets[vToken].borrowMultiplier = borrowMultiplier;\n        markets[vToken].sumOfMembersScore = 0;\n        markets[vToken].exists = true;\n\n        vTokenForAsset[_getUnderlying(vToken)] = vToken;\n\n        allMarkets.push(vToken);\n        _startScoreUpdateRound();\n    }\n\n    /**\n     * @notice Set limits for total tokens that can be mined\n     * @param irrevocableLimit total number of irrevocable tokens that can be minted\n     * @param revocableLimit total number of revocable tokens that can be minted\n     */\n    function setLimit(uint256 irrevocableLimit, uint256 revocableLimit) external {\n        _checkAccessAllowed(\"setLimit(uint256,uint256)\");\n        if (irrevocableLimit < _totalIrrevocable || revocableLimit < _totalRevocable) revert InvalidLimit();\n\n        _revocableLimit = revocableLimit;\n        _irrevocableLimit = irrevocableLimit;\n    }\n\n    /**\n     * @notice Directly issue prime tokens to users\n     * @param isIrrevocable is the tokens being issued is irrevocable\n     * @param users list of address to issue tokens to\n     */\n    function issue(bool isIrrevocable, address[] calldata users) external {\n        _checkAccessAllowed(\"issue(bool,address[])\");\n\n        if (isIrrevocable) {\n            for (uint i = 0; i < users.length; i++) {\n                _mint(true, users[i]);\n                _initializeMarkets(users[i]);\n            }\n        } else {\n            for (uint i = 0; i < users.length; i++) {\n                _mint(false, users[i]);\n                _initializeMarkets(users[i]);\n                delete stakedAt[users[i]];\n            }\n        }\n    }\n\n    /**\n     * @notice Executed by XVSVault whenever user's XVSVault balance changes\n     * @param user the account address whose balance was updated\n     */\n    function xvsUpdated(address user) external {\n        uint256 totalStaked = _xvsBalanceOfUser(user);\n        bool isAccountEligible = isEligible(totalStaked);\n\n        if (tokens[user].exists && !isAccountEligible) {\n            address[] storage _allMarkets = allMarkets;\n            for (uint i = 0; i < _allMarkets.length; i++) {\n                executeBoost(user, _allMarkets[i]);\n                \n                markets[_allMarkets[i]].sumOfMembersScore = markets[_allMarkets[i]].sumOfMembersScore - interests[_allMarkets[i]][user].score;\n                interests[_allMarkets[i]][user].score = 0;\n                interests[_allMarkets[i]][user].rewardIndex = 0;\n            }\n\n            _burn(user);\n        } else if (!isAccountEligible && !tokens[user].exists && stakedAt[user] > 0) {\n            stakedAt[user] = 0;\n        } else if (stakedAt[user] == 0 && isAccountEligible && !tokens[user].exists) {\n            stakedAt[user] = block.timestamp;\n        } else if (tokens[user].exists && isAccountEligible) {\n            address[] storage _allMarkets = allMarkets;\n            for (uint i = 0; i < _allMarkets.length; i++) {\n                executeBoost(user, _allMarkets[i]);\n                updateScore(user, _allMarkets[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice For claiming prime token when staking period is completed\n     */\n    function claim() external {\n        if (stakedAt[msg.sender] == 0) revert IneligibleToClaim();\n        if (block.timestamp - stakedAt[msg.sender] < STAKING_PERIOD) revert WaitMoreTime();\n\n        stakedAt[msg.sender] = 0;\n\n        _mint(false, msg.sender);\n        _initializeMarkets(msg.sender);\n    }\n\n    /**\n     * @notice Initializes all the markets for the user when a prime token is minted\n     * @param account the account address for which markets needs to be initialized\n     */\n    function _initializeMarkets(address account) internal {\n        address[] storage _allMarkets = allMarkets;\n        for (uint i = 0; i < _allMarkets.length; i++) {\n            address market = _allMarkets[i];\n            accrueInterest(market);\n\n            interests[market][account].rewardIndex = markets[market].rewardIndex;\n\n            uint score = _calculateScore(market, account);\n            interests[market][account].score = score;\n            markets[market].sumOfMembersScore = markets[market].sumOfMembersScore + score;\n        }\n    }\n\n    /**\n     * @notice fetch the current XVS balance of user in the XVSVault\n     * @param user the account address for which markets needs to be initialized\n     * @return xvsBalance the XVS balance of user\n     */\n    function _xvsBalanceOfUser(address user) internal view returns (uint256) {\n        (uint256 xvs, , uint256 pendingWithdrawals) = IXVSVault(xvsVault).getUserInfo(\n            xvsVaultRewardToken,\n            xvsVaultPoolId,\n            user\n        );\n        return (xvs - pendingWithdrawals);\n    }\n\n    /**\n     * @notice calculate the current score of user\n     * @param market the market for which to calculate the score\n     * @param user the account for which to calculate the score\n     * @return score the score of the user\n     */\n    function _calculateScore(address market, address user) internal returns (uint256) {\n        uint256 xvsBalanceForScore = _xvsBalanceForScore(_xvsBalanceOfUser(user));\n\n        IVToken vToken = IVToken(market);\n        uint256 borrow = vToken.borrowBalanceStored(user);\n        uint256 exchangeRate = vToken.exchangeRateStored();\n        uint256 balanceOfAccount = vToken.balanceOf(user);\n        uint256 supply = (exchangeRate * balanceOfAccount) / EXP_SCALE;\n\n        return\n            Scores.calculateScore(\n                xvsBalanceForScore,\n                _capitalForScore(xvsBalanceForScore, borrow, supply, market),\n                alphaNumerator,\n                alphaDenominator\n            );\n    }\n\n    /**\n     * @notice calcukate the current XVS balance that will be used in calculation of score\n     * @param xvs the actual XVS balance of user\n     * @return xvsBalanceForScore the XVS balance to use in score\n     */\n    function _xvsBalanceForScore(uint256 xvs) internal view returns (uint256) {\n        if (xvs > MAXIMUM_XVS_CAP) {\n            return MAXIMUM_XVS_CAP;\n        } else {\n            return xvs;\n        }\n    }\n\n    /**\n     * @notice calculate the capital for calculation of score\n     * @param xvs the actual XVS balance of user\n     * @param borrow the borrow balance of user\n     * @param supply the supply balance of user\n     * @param market the market vToken address\n     * @return capital the capital to use in calculation of score\n     */\n    function _capitalForScore(\n        uint256 xvs,\n        uint256 borrow,\n        uint256 supply,\n        address market\n    ) internal view returns (uint256) {\n        uint256 borrowCap = (xvs * markets[market].borrowMultiplier) / EXP_SCALE;\n        uint256 supplyCap = (xvs * markets[market].supplyMultiplier) / EXP_SCALE;\n\n        if (supply > supplyCap) {\n            supply = supplyCap;\n        }\n\n        if (borrow > borrowCap) {\n            borrow = borrowCap;\n        }\n\n        return (supply + borrow);\n    }\n\n    /**\n     * @notice Used to mint a new prime token\n     * @param isIrrevocable is the tokens being issued is irrevocable\n     * @param user token owner\n     */\n    function _mint(bool isIrrevocable, address user) internal {\n        if (tokens[user].exists) revert IneligibleToClaim();\n\n        tokens[user].exists = true;\n        tokens[user].isIrrevocable = isIrrevocable;\n\n        if (isIrrevocable) {\n            _totalIrrevocable++;\n        } else {\n            _totalRevocable++;\n        }\n\n        if (_totalIrrevocable > _irrevocableLimit || _totalRevocable > _revocableLimit) revert InvalidLimit();\n\n        emit Mint(user, isIrrevocable);\n    }\n\n    /**\n     * @notice Used to burn a new prime token\n     * @param user owner whose prime token to burn\n     */\n    function _burn(address user) internal {\n        if (!tokens[user].exists) revert UserHasNoPrimeToken();\n\n        if (tokens[user].isIrrevocable) {\n            _totalIrrevocable--;\n        } else {\n            _totalRevocable--;\n        }\n\n        tokens[user].exists = false;\n        tokens[user].isIrrevocable = false;\n\n        _updateRoundAfterTokenBurned(user);\n\n        emit Burn(user);\n    }\n\n    /**\n     * @notice Used to get if the XVS balance is eligible for prime token\n     * @param amount amount of XVS\n     */\n    function isEligible(uint256 amount) internal view returns (bool) {\n        if (amount >= MINIMUM_STAKED_XVS) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Accrue rewards for the user. Must be called by Comptroller before changing account's borrow or supply balance.\n     * @param user account for which we need to accrue rewards\n     * @param vToken the market for which we need to accrue rewards\n     */\n    function executeBoost(address user, address vToken) public {\n        if (!markets[vToken].exists || !tokens[user].exists) {\n            return;\n        }\n\n        accrueInterest(vToken);\n        interests[vToken][user].accrued += _interestAccrued(vToken, user);\n        interests[vToken][user].rewardIndex = markets[vToken].rewardIndex;\n    }\n\n    /**\n     * @notice Update total score of user and market. Must be called after changing account's borrow or supply balance.\n     * @param user account for which we need to update score\n     * @param market the market for which we need to score\n     */\n    function updateScore(address user, address market) public {\n        if (!markets[market].exists) {\n            return;\n        }\n\n        if (!tokens[user].exists) {\n            return;\n        }\n\n        uint score = _calculateScore(market, user);\n        markets[market].sumOfMembersScore = markets[market].sumOfMembersScore - interests[market][user].score + score;\n        interests[market][user].score = score;\n    }\n\n    /**\n     * @notice Distributes income from market since last distribution\n     * @param vToken the market for which to distribute the income\n     */\n    function accrueInterest(address vToken) public {\n        if (!markets[vToken].exists) revert MarketNotSupported();\n\n        address underlying = _getUnderlying(vToken);\n\n        uint totalIncomeUnreleased = IProtocolShareReserve(protocolShareReserve).getUnreleasedFunds(\n            comptroller,\n            IProtocolShareReserve.Schema.SPREAD_PRIME_CORE,\n            address(this),\n            underlying\n        );\n\n        uint256 distributionIncome = totalIncomeUnreleased - unreleasedIncome[underlying];\n        \n\n        if (distributionIncome == 0) {\n            return;\n        }\n\n        unreleasedIncome[underlying] = totalIncomeUnreleased;\n\n        uint256 delta;\n        if (markets[vToken].sumOfMembersScore > 0) {\n            delta = ((distributionIncome * EXP_SCALE) / markets[vToken].sumOfMembersScore);\n        }\n\n        markets[vToken].rewardIndex = markets[vToken].rewardIndex + delta;\n    }\n\n    /**\n     * @notice Returns boosted interest accrued for a user\n     * @param vToken the market for which to fetch the accrued interest\n     * @param user the account for which to get the accrued interest\n     */\n    function getInterestAccrued(address vToken, address user) public returns (uint256) {\n        accrueInterest(vToken);\n\n        return _interestAccrued(vToken, user);\n    }\n\n    function _interestAccrued(address vToken, address user) internal returns (uint256) {\n        uint256 index = markets[vToken].rewardIndex - interests[vToken][user].rewardIndex;\n        uint256 score = interests[vToken][user].score;\n\n        return (index * score) / EXP_SCALE;\n    }\n\n    /**\n     * @notice For user to claim boosted yield\n     * @param vToken the market for which claim the accrued interest\n     */\n    function claimInterest(address vToken) external {\n        uint256 amount = getInterestAccrued(vToken, msg.sender);\n        amount += interests[vToken][msg.sender].accrued;\n\n        interests[vToken][msg.sender].rewardIndex = markets[vToken].rewardIndex;\n        interests[vToken][msg.sender].accrued = 0;\n\n        IERC20Upgradeable asset = IERC20Upgradeable(_getUnderlying(vToken));\n\n        if (amount > asset.balanceOf(address(this))) {\n            address[] memory assets = new address[](1);\n            assets[0] = address(asset);\n            IProtocolShareReserve(protocolShareReserve).releaseFunds(comptroller, assets);\n        }\n\n        asset.safeTransfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Callback by ProtocolShareReserve to update assets state when funds are released to this contract\n     * @param _comptroller The address of the Comptroller whose income is distributed\n     * @param asset The address of the asset whose income is distributed\n     */\n    function updateAssetsState(address _comptroller, address asset) external {\n        if (msg.sender != protocolShareReserve) revert InvalidCaller();\n        if (comptroller != _comptroller) revert InvalidComptroller();\n\n        address vToken = vTokenForAsset[asset];\n        if (vToken == address(0)) revert MarketNotSupported();\n\n        IVToken market = IVToken(vToken);\n        unreleasedIncome[_getUnderlying(address(market))] = 0;\n\n        emit UpdatedAssetsState(comptroller, asset);\n    }\n\n    /**\n     * @notice Update total score of multiple users and market\n     * @param users accounts for which we need to update score\n     */\n    function updateScores(address[] memory users) external {\n        if (pendingScoreUpdates == 0) revert NoScoreUpdatesRequired();\n        if (nextScoreUpdateRoundId == 0) revert NoScoreUpdatesRequired();\n\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            \n            if (!tokens[user].exists) revert UserHasNoPrimeToken();\n            if (isScoreUpdated[nextScoreUpdateRoundId][user]) continue;\n\n            address[] storage _allMarkets = allMarkets;\n            for (uint i = 0; i < _allMarkets.length; i++) {\n                address market = _allMarkets[i];\n                updateScore(user, market);\n            }\n\n            pendingScoreUpdates--;\n            isScoreUpdated[nextScoreUpdateRoundId][user] = true;\n        }\n    }\n\n    /**\n     * @notice starts round to update scores of a particular or all markets\n     */\n    function _startScoreUpdateRound() internal {\n        nextScoreUpdateRoundId++;\n        totalScoreUpdatesRequired = _totalIrrevocable + _totalRevocable;\n        pendingScoreUpdates = totalScoreUpdatesRequired;\n    }\n\n    /**\n     * @notice update the required score updates when token is burned before round is completed\n     */\n    function _updateRoundAfterTokenBurned(address user) internal {\n        if (totalScoreUpdatesRequired > 0) totalScoreUpdatesRequired--;\n        \n        if (pendingScoreUpdates > 0 && !isScoreUpdated[nextScoreUpdateRoundId][user]) {\n            pendingScoreUpdates--;\n        }\n    }\n\n    function _getUnderlying(address vToken) internal view returns (address) {\n        if (vToken == vBNB) {\n            return WBNB;\n        } else {\n            return IVToken(vToken).underlying();\n        }\n    }\n}"
    }
  ]
}