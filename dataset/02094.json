{
  "Title": "M-9: Gas spikes after outages may prevent order execution",
  "Content": "# Issue M-9: Gas spikes after outages may prevent order execution \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/173 \n\n## Found by \nIllIllI, ShadowForce, simon135\n\n## Summary\n\nUsers are required to specify execution fee at order creation. This fee is to reimburse the keeper for executing their order, and is based on a formula that includes the `tx.price` of the keeper when it executes the order.\n\n\n## Vulnerability Detail\n\nIf the user submits an order to exit the position, and specifies a very generous execution fee, there may be an outage in the keeper or oracle network that delays the execution of the order. When the outage is resolved, the transaction gas fees may spike because of all of the queued orders that were waiting for the network to come back (similar to a long-on storm), and or due to other protocols trying to service their own liquidations.\n\nIn such a scenario, the user's oracle price is protected for a certain amount of time, but after that window passes, the order won't be executable. The issue is that there is no way for the user to update the execution fee so that it still gets executed during the gas spike, without altering their execution price.\n\n\n## Impact\n\nIt's entirely possible that the provided execution fee would generally be described as excessive, at the time of order creation, but due to the outage it became insufficient. During the time window where the order isn't executed, the user's position may change from a profit, to a loss, or even become liquidated.\n\n\n## Code Snippet\n\nUpdating the execution fee always touches the order, which changes the update timestamp, which is used to decide which oracle prices are valid:\n```solidity\n// File: gmx-synthetics/contracts/exchange/OrderHandler.sol : OrderHandler.   #1\n\n88             // allow topping up of executionFee as partially filled or frozen orders\n89             // will have their executionFee reduced\n90             address wnt = TokenUtils.wnt(dataStore);\n91             uint256 receivedWnt = orderVault.recordTransferIn(wnt);\n92 @>          order.setExecutionFee(order.executionFee() + receivedWnt);\n93     \n94             uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n95             GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n96     \n97 @>          order.touch();\n98             OrderStoreUtils.set(dataStore, key, order);\n99     \n100            OrderEventUtils.emitOrderUpdated(eventEmitter, key, sizeDeltaUsd, triggerPrice, acceptablePrice);\n101:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/OrderHandler.sol#L68-L101\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nAllow the user to update the execution fee without changing the order timestamp if the `tx.gasprice` of the update transaction is above some threshold/execution fee factor \n\n\n\n\n## Discussion\n\n**xvi10**\n\nthis is a valid concern but we do not think the contracts should be changed to add this feature, instead keepers may be reimbursed through a keeper fund or the protocol may run keepers that are willing to execute the transactions even if the execution fee will not be fully reimbursed\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/exchange/OrderHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title OrderHandler\n// @dev Contract to handle creation, execution and cancellation of orders\ncontract OrderHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error OrderNotUpdatable(Order.OrderType orderType);\n    error InvalidKeeperForFrozenOrder(address keeper);\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev creates an order in the order store\n    // @param account the order's account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        address account,\n        BaseOrderUtils.CreateOrderParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createOrderFeatureDisabledKey(address(this), uint256(params.orderType)));\n\n        return OrderUtils.createOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            referralStorage,\n            account,\n            params\n        );\n    }\n\n    /**\n     * @dev Updates the given order with the specified size delta, acceptable price, and trigger price.\n     * The `updateOrder()` feature must be enabled for the given order type. The caller must be the owner\n     * of the order, and the order must not be a market order. The size delta, trigger price, and\n     * acceptable price are updated on the order, and the order is unfrozen. Any additional WNT that is\n     * transferred to the contract is added to the order's execution fee. The updated order is then saved\n     * in the order store, and an `OrderUpdated` event is emitted.\n     *\n     * @param key The unique ID of the order to be updated\n     * @param sizeDeltaUsd The new size delta for the order\n     * @param acceptablePrice The new acceptable price for the order\n     * @param triggerPrice The new trigger price for the order\n     */\n    function updateOrder(\n        bytes32 key,\n        uint256 sizeDeltaUsd,\n        uint256 acceptablePrice,\n        uint256 triggerPrice,\n        uint256 minOutputAmount,\n        Order.Props memory order\n    ) external payable globalNonReentrant onlyController {\n        FeatureUtils.validateFeature(dataStore, Keys.updateOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            revert OrderNotUpdatable(order.orderType());\n        }\n\n        order.setSizeDeltaUsd(sizeDeltaUsd);\n        order.setTriggerPrice(triggerPrice);\n        order.setAcceptablePrice(acceptablePrice);\n        order.setMinOutputAmount(minOutputAmount);\n        order.setIsFrozen(false);\n\n        // allow topping up of executionFee as partially filled or frozen orders\n        // will have their executionFee reduced\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 receivedWnt = orderVault.recordTransferIn(wnt);\n        order.setExecutionFee(order.executionFee() + receivedWnt);\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderUpdated(eventEmitter, key, sizeDeltaUsd, triggerPrice, acceptablePrice);\n    }\n\n    /**\n     * @dev Cancels the given order. The `cancelOrder()` feature must be enabled for the given order\n     * type. The caller must be the owner of the order, and the order must not be a market order. The\n     * order is cancelled by calling the `cancelOrder()` function in the `OrderUtils` contract. This\n     * function also records the starting gas amount and the reason for cancellation, which is passed to\n     * the `cancelOrder()` function.\n     *\n     * @param key The unique ID of the order to be cancelled\n     */\n    function cancelOrder(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Order.Props memory order = OrderStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            ExchangeUtils.validateRequestCancellation(\n                _dataStore,\n                order.updatedAtBlock(),\n                \"Order\"\n            );\n        }\n\n        OrderUtils.cancelOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            key,\n            order.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev simulate execution of an order to check for any errors\n    // @param key the order key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteOrder(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n        uint256 startingGas = gasleft();\n\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleOrderError(key, startingGas, reasonBytes);\n        }\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the order\n    // @param startingGas the starting gas\n    function _executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(key, oracleParams, keeper, startingGas);\n        // limit swaps require frozen order keeper for execution since on creation it can fail due to output amount\n        // which would automatically cause the order to be frozen\n        // limit increase and limit / trigger decrease orders may fail due to output amount as well and become frozen\n        // but only if their acceptablePrice is reached\n        if (params.order.isFrozen() || params.order.orderType() == Order.OrderType.LimitSwap) {\n            _validateFrozenOrderKeeper(keeper);\n        }\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeOrderFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n    }\n\n    // @dev handle a caught order error\n    // @param key the order's key\n    // @param startingGas the starting gas\n    // @param reason the error reason\n    // @param reasonKey the hash or the error reason\n    function _handleOrderError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (\n            OracleUtils.isEmptyPriceError(errorSelector) ||\n            errorSelector == InvalidKeeperForFrozenOrder.selector\n        ) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        bool isMarketOrder = BaseOrderUtils.isMarketOrder(order.orderType());\n\n        if (isMarketOrder) {\n            OrderUtils.cancelOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        } else {\n            if (\n                errorSelector == FeatureUtils.DisabledFeature.selector ||\n                errorSelector == PositionUtils.EmptyPosition.selector ||\n                errorSelector == BaseOrderUtils.InvalidOrderPrices.selector\n            ) {\n                ErrorUtils.revertWithCustomError(reasonBytes);\n            }\n\n            // freeze unfulfillable orders to prevent the order system from being gamed\n            // an example of gaming would be if a user creates a limit order\n            // with size greater than the available amount in the pool\n            // the user waits for their limit price to be hit, and if price\n            // moves in their favour after, they can deposit into the pool\n            // to allow the order to be executed then close the order for a profit\n            //\n            // frozen order keepers will have additional validations before executing\n            // frozen orders to prevent gaming\n            //\n            // alternatively, the user can call updateOrder to unfreeze the order\n            OrderUtils.freezeOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev validate that the keeper is a frozen order keeper\n    // @param keeper address of the keeper\n    function _validateFrozenOrderKeeper(address keeper) internal view {\n        if (!roleStore.hasRole(keeper, Role.FROZEN_ORDER_KEEPER)) {\n            revert InvalidKeeperForFrozenOrder(keeper);\n        }\n    }\n}"
    }
  ]
}