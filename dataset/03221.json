{
  "Title": "Incorrect slippage check",
  "Content": "##### Description\nCondition in slippage check is logically reversed: \nhttps://github.com/yearn/hardhat-monorepo/blob/ecc0b5147992b34c315e08af170ceb4a5fe071ee/packages/yswaps/contracts/TradeFactory/TradeFactoryExecutor.sol#L150\n##### Recommendation\nNote: this issue was found by the developers\n\n***\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/yswaps/contracts/TradeFactory/TradeFactoryExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\nimport '@yearn/contract-utils/contracts/utils/Machinery.sol';\n\nimport '../swappers/async/AsyncSwapper.sol';\nimport '../swappers/async/MultipleAsyncSwapper.sol';\nimport '../swappers/sync/SyncSwapper.sol';\n\nimport './TradeFactoryPositionsHandler.sol';\n\ninterface ITradeFactoryExecutor {\n  event SyncTradeExecuted(address indexed _strategy, uint256 _receivedAmount, address indexed _swapper);\n\n  event AsyncTradeExecuted(uint256 _receivedAmount, address _swapper);\n\n  event MultipleAsyncTradeExecuted(uint256[] _receivedAmount, address _swapper);\n\n  error InvalidAmountOut();\n\n  struct SyncTradeExecutionDetails {\n    address _tokenIn;\n    address _tokenOut;\n    uint256 _amountIn;\n    uint256 _maxSlippage;\n  }\n\n  struct AsyncTradeExecutionDetails {\n    address _strategy;\n    address _tokenIn;\n    address _tokenOut;\n    uint256 _amount;\n    uint256 _minAmountOut;\n  }\n\n  // Sync execution\n  function execute(SyncTradeExecutionDetails calldata _tradeExecutionDetails, bytes calldata _data) external returns (uint256 _receivedAmount);\n\n  // Async execution\n  function execute(\n    AsyncTradeExecutionDetails calldata _tradeExecutionDetails,\n    address _swapper,\n    bytes calldata _data\n  ) external returns (uint256 _receivedAmount);\n\n  // Multiple async execution\n  function execute(\n    AsyncTradeExecutionDetails[] calldata _tradesExecutionDetails,\n    address _swapper,\n    bytes calldata _data\n  ) external;\n}\n\nabstract contract TradeFactoryExecutor is ITradeFactoryExecutor, TradeFactoryPositionsHandler, Machinery {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  constructor(address _mechanicsRegistry) Machinery(_mechanicsRegistry) {}\n\n  // Machinery\n  function setMechanicsRegistry(address __mechanicsRegistry) external virtual override onlyRole(MASTER_ADMIN) {\n    _setMechanicsRegistry(__mechanicsRegistry);\n  }\n\n  // Execute via sync swapper\n  function execute(SyncTradeExecutionDetails calldata _tradeExecutionDetails, bytes calldata _data)\n    external\n    override\n    onlyRole(STRATEGY)\n    returns (uint256 _receivedAmount)\n  {\n    address _swapper = strategySyncSwapper[msg.sender];\n    if (_tradeExecutionDetails._tokenIn == address(0) || _tradeExecutionDetails._tokenOut == address(0)) revert CommonErrors.ZeroAddress();\n    if (_tradeExecutionDetails._amountIn == 0) revert CommonErrors.ZeroAmount();\n    if (_tradeExecutionDetails._maxSlippage == 0) revert CommonErrors.ZeroSlippage();\n    IERC20(_tradeExecutionDetails._tokenIn).safeTransferFrom(msg.sender, _swapper, _tradeExecutionDetails._amountIn);\n    uint256 _preSwapBalanceOut = IERC20(_tradeExecutionDetails._tokenOut).balanceOf(msg.sender);\n    ISyncSwapper(_swapper).swap(\n      msg.sender,\n      _tradeExecutionDetails._tokenIn,\n      _tradeExecutionDetails._tokenOut,\n      _tradeExecutionDetails._amountIn,\n      _tradeExecutionDetails._maxSlippage,\n      _data\n    );\n    _receivedAmount = IERC20(_tradeExecutionDetails._tokenOut).balanceOf(msg.sender) - _preSwapBalanceOut;\n    emit SyncTradeExecuted(msg.sender, _receivedAmount, _swapper);\n  }\n\n  // Execute via async swapper\n  function execute(\n    AsyncTradeExecutionDetails calldata _tradeExecutionDetails,\n    address _swapper,\n    bytes calldata _data\n  ) external override onlyMechanic returns (uint256 _receivedAmount) {\n    if (\n      !_tokensOutByStrategyAndTokenIn[_tradeExecutionDetails._strategy][_tradeExecutionDetails._tokenIn].contains(\n        _tradeExecutionDetails._tokenOut\n      )\n    ) revert InvalidTrade();\n    if (!_swappers.contains(_swapper)) revert InvalidSwapper();\n    uint256 _amount = _tradeExecutionDetails._amount != 0\n      ? _tradeExecutionDetails._amount\n      : IERC20(_tradeExecutionDetails._tokenIn).balanceOf(_tradeExecutionDetails._strategy);\n    IERC20(_tradeExecutionDetails._tokenIn).safeTransferFrom(_tradeExecutionDetails._strategy, _swapper, _amount);\n    uint256 _preSwapBalanceOut = IERC20(_tradeExecutionDetails._tokenOut).balanceOf(_tradeExecutionDetails._strategy);\n    IAsyncSwapper(_swapper).swap(\n      _tradeExecutionDetails._strategy,\n      _tradeExecutionDetails._tokenIn,\n      _tradeExecutionDetails._tokenOut,\n      _amount,\n      _tradeExecutionDetails._minAmountOut,\n      _data\n    );\n    _receivedAmount = IERC20(_tradeExecutionDetails._tokenOut).balanceOf(_tradeExecutionDetails._strategy) - _preSwapBalanceOut;\n    if (_receivedAmount < _tradeExecutionDetails._minAmountOut) revert InvalidAmountOut();\n    emit AsyncTradeExecuted(_receivedAmount, _swapper);\n  }\n\n  function execute(\n    AsyncTradeExecutionDetails[] calldata _tradesExecutionDetails,\n    address _swapper,\n    bytes calldata _data\n  ) external override onlyMechanic {\n    // Balance out holder will firstly have the pre swap balance out of each strategy\n    uint256[] memory _balanceOutHolder = new uint256[](_tradesExecutionDetails.length);\n    if (!_swappers.contains(_swapper)) revert InvalidSwapper();\n    for (uint256 i; i < _tradesExecutionDetails.length; i++) {\n      if (\n        !_tokensOutByStrategyAndTokenIn[_tradesExecutionDetails[i]._strategy][_tradesExecutionDetails[i]._tokenIn].contains(\n          _tradesExecutionDetails[i]._tokenOut\n        )\n      ) revert InvalidTrade();\n      uint256 _amount = _tradesExecutionDetails[i]._amount != 0\n        ? _tradesExecutionDetails[i]._amount\n        : IERC20(_tradesExecutionDetails[i]._tokenIn).balanceOf(_tradesExecutionDetails[i]._strategy);\n      IERC20(_tradesExecutionDetails[i]._tokenIn).safeTransferFrom(_tradesExecutionDetails[i]._strategy, _swapper, _amount);\n      _balanceOutHolder[i] = IERC20(_tradesExecutionDetails[i]._tokenOut).balanceOf(_tradesExecutionDetails[i]._strategy);\n    }\n    IMultipleAsyncSwapper(_swapper).swapMultiple(_data);\n    for (uint256 i; i < _tradesExecutionDetails.length; i++) {\n      // Balance out holder will now store the total received amount of token out per strat\n      _balanceOutHolder[i] = IERC20(_tradesExecutionDetails[i]._tokenOut).balanceOf(_tradesExecutionDetails[i]._strategy) - _balanceOutHolder[i];\n      if (_tradesExecutionDetails[i]._minAmountOut < _balanceOutHolder[i]) revert InvalidAmountOut();\n    }\n    emit MultipleAsyncTradeExecuted(_balanceOutHolder, _swapper);\n  }\n}"
    }
  ]
}