{
  "Title": "An unvalidated user input in the `_getAddLiquidityOneCoinCallData` function",
  "Content": "##### Description\nThe `_getAddLiquidityOneCoinCallData` function utilizes variable `i`, which is an arbitrary value passed by the user, without any validation from the `add_liquidity_one_coin` function. If this value is outside the valid range, the transaction will be reverted due to built-in range checks.\n\nRelated code: add_liquidity_one_coin - https://github.com/Gearbox-protocol/integrations-v3/blob/2575396b2c933953483dd85cb2d5900134349f80/contracts/adapters/curve/CurveV1_Base.sol#L325-L333\n\n##### Recommendation\nWe recommend adding an assertion to explicitly validate any values passed by the user.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/adapters/curve/CurveV1_Base.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2023.\npragma solidity ^0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {RAY} from \"@gearbox-protocol/core-v2/contracts/libraries/Constants.sol\";\nimport {BitMask} from \"@gearbox-protocol/core-v3/contracts/libraries/BitMask.sol\";\nimport {IncorrectParameterException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\nimport {ICurvePool} from \"../../integrations/curve/ICurvePool.sol\";\nimport {ICurveV1Adapter} from \"../../interfaces/curve/ICurveV1Adapter.sol\";\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\n\n/// @title Curve adapter base\n/// @notice Implements logic allowing credit accounts to interact with Curve pools with arbitrary number of coins,\n///         supporting stable/crypto plain/meta/lending pools of different versions\nabstract contract CurveV1AdapterBase is AbstractAdapter, ICurveV1Adapter {\n    using BitMask for uint256;\n\n    uint16 public constant override _gearboxAdapterVersion = 3_00;\n\n    /// @notice Pool LP token address (added for backward compatibility)\n    address public immutable override token;\n\n    /// @notice Pool LP token address\n    address public immutable override lp_token;\n\n    /// @notice Collateral token mask of pool LP token in the credit manager\n    uint256 public immutable override lpTokenMask;\n\n    /// @notice Base pool address (for metapools only)\n    address public immutable override metapoolBase;\n\n    /// @notice Number of coins in the pool\n    uint256 public immutable override nCoins;\n\n    /// @notice Whether pool is cryptoswap or stableswap\n    bool public immutable override use256;\n\n    address public immutable override token0;\n    address public immutable override token1;\n    address public immutable override token2;\n    address public immutable override token3;\n\n    uint256 public immutable override token0Mask;\n    uint256 public immutable override token1Mask;\n    uint256 public immutable override token2Mask;\n    uint256 public immutable override token3Mask;\n\n    address public immutable override underlying0;\n    address public immutable override underlying1;\n    address public immutable override underlying2;\n    address public immutable override underlying3;\n\n    uint256 public immutable override underlying0Mask;\n    uint256 public immutable override underlying1Mask;\n    uint256 public immutable override underlying2Mask;\n    uint256 public immutable override underlying3Mask;\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager address\n    /// @param _curvePool Target Curve pool address\n    /// @param _lp_token Pool LP token address\n    /// @param _metapoolBase Metapool's base pool address (must have 2 or 3 coins) or zero address\n    /// @param _nCoins Number of coins in the pool\n    constructor(address _creditManager, address _curvePool, address _lp_token, address _metapoolBase, uint256 _nCoins)\n        AbstractAdapter(_creditManager, _curvePool) // U:[CRVB-1]\n        nonZeroAddress(_lp_token) // U:[CRVB-1]\n    {\n        lpTokenMask = _getMaskOrRevert(_lp_token); // U:[CRVB-1]\n\n        token = _lp_token; // U:[CRVB-1]\n        lp_token = _lp_token; // U:[CRVB-1]\n        metapoolBase = _metapoolBase; // U:[CRVB-1]\n        nCoins = _nCoins; // U:[CRVB-1]\n        use256 = _use256();\n\n        address[4] memory tokens;\n        uint256[4] memory tokenMasks;\n        unchecked {\n            for (uint256 i; i < nCoins; ++i) {\n                tokens[i] = _getCoin(_curvePool, i); // U:[CRVB-1]\n                if (tokens[i] == address(0)) revert IncorrectParameterException(); // U:[CRVB-1]\n                tokenMasks[i] = _getMaskOrRevert(tokens[i]); // U:[CRVB-1]\n            }\n        }\n\n        token0 = tokens[0];\n        token1 = tokens[1];\n        token2 = tokens[2];\n        token3 = tokens[3];\n\n        token0Mask = tokenMasks[0];\n        token1Mask = tokenMasks[1];\n        token2Mask = tokenMasks[2];\n        token3Mask = tokenMasks[3];\n\n        // underlying tokens (only relevant for meta and lending pools)\n        address[4] memory underlyings;\n        uint256[4] memory underlyingMasks;\n        unchecked {\n            for (uint256 i; i < 4; ++i) {\n                if (_metapoolBase != address(0)) {\n                    underlyings[i] = i == 0 ? token0 : _getCoin(_metapoolBase, i - 1); // U:[CRVB-1]\n                } else {\n                    // some pools are proxy contracts and return empty data when there is no function with given signature,\n                    // which later results in revert when trying to decode the result, so low-level call is used instead\n                    (bool success, bytes memory returnData) = _callWithAlternative(\n                        abi.encodeWithSignature(\"underlying_coins(uint256)\", i),\n                        abi.encodeWithSignature(\"underlying_coins(int128)\", i)\n                    ); // U:[CRVB-1]\n                    if (success && returnData.length > 0) underlyings[i] = abi.decode(returnData, (address));\n                    else break;\n                }\n\n                if (underlyings[i] != address(0)) underlyingMasks[i] = _getMaskOrRevert(underlyings[i]); // U:[CRVB-1]\n            }\n        }\n\n        underlying0 = underlyings[0];\n        underlying1 = underlyings[1];\n        underlying2 = underlyings[2];\n        underlying3 = underlyings[3];\n\n        underlying0Mask = underlyingMasks[0];\n        underlying1Mask = underlyingMasks[1];\n        underlying2Mask = underlyingMasks[2];\n        underlying3Mask = underlyingMasks[3];\n    }\n\n    // -------- //\n    // EXCHANGE //\n    // -------- //\n\n    /// @notice Exchanges one pool asset to another\n    /// @param i Index of the asset to spend\n    /// @param j Index of the asset to receive\n    /// @param dx Amount of asset i to spend\n    /// @param min_dy Minimum amount of asset j to receive\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy)\n        external\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        return _exchange(i, j, dx, min_dy); // U:[CRVB-3]\n    }\n\n    /// @dev Same as the previous one but accepts coin indexes as `int128`\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy)\n        external\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        return _exchange(_toU256(i), _toU256(j), dx, min_dy); // U:[CRVB-3]\n    }\n\n    /// @dev Implementation of both versions of `exchange`\n    function _exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) = _exchange_impl(i, j, _getExchangeCallData(i, j, dx, min_dy), false); // U:[CRVB-3]\n    }\n\n    /// @notice Exchanges the entire balance of one pool asset to another, except the specified amount\n    /// @param i Index of the asset to spend\n    /// @param j Index of the asset to receive\n    /// @param leftoverAmount Amount of input asset to keep on the account\n    /// @param rateMinRAY Minimum exchange rate between assets i and j, scaled by 1e27\n    function exchange_diff(uint256 i, uint256 j, uint256 leftoverAmount, uint256 rateMinRAY)\n        external\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        address creditAccount = _creditAccount(); // U:[CRVB-4]\n\n        address tokenIn = _get_token(i); // U:[CRVB-4]\n        uint256 dx = IERC20(tokenIn).balanceOf(creditAccount); // U:[CRVB-4]\n        if (dx <= leftoverAmount) return (0, 0);\n\n        unchecked {\n            dx -= leftoverAmount; // U:[CRVB-4]\n        }\n        uint256 min_dy = (dx * rateMinRAY) / RAY; // U:[CRVB-4]\n        (tokensToEnable, tokensToDisable) =\n            _exchange_impl(i, j, _getExchangeCallData(i, j, dx, min_dy), leftoverAmount <= 1); // U:[CRVB-4]\n    }\n\n    /// @dev Internal implementation of `exchange` and `exchange_diff`\n    ///      - passes calldata to the target contract\n    ///      - sets max approval for the input token before the call and resets it to 1 after\n    ///      - enables output asset after the call\n    ///      - disables input asset only when exchanging the entire balance\n    function _exchange_impl(uint256 i, uint256 j, bytes memory callData, bool disableTokenIn)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _approveToken(_get_token(i), type(uint256).max); // U:[CRVB-3,4]\n        _execute(callData); // U:[CRVB-3,4]\n        _approveToken(_get_token(i), 1); // U:[CRVB-3,4]\n        (tokensToEnable, tokensToDisable) = (_get_token_mask(j), disableTokenIn ? _get_token_mask(i) : 0); // U:[CRVB-3,4]\n    }\n\n    /// @dev Returns calldata for `exchange` and `exchange_diff` calls\n    function _getExchangeCallData(uint256 i, uint256 j, uint256 dx, uint256 min_dy)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return use256\n            ? abi.encodeWithSignature(\"exchange(uint256,uint256,uint256,uint256)\", i, j, dx, min_dy)\n            : abi.encodeWithSignature(\"exchange(int128,int128,uint256,uint256)\", i, j, dx, min_dy); // U:[CRVB-3,4]\n    }\n\n    /// @notice Exchanges one pool's underlying asset to another\n    /// @param i Index of the underlying asset to spend\n    /// @param j Index of the underlying asset to receive\n    /// @param dx Amount of underlying asset i to spend\n    /// @param min_dy Minimum amount of underlying asset j to receive\n    function exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy)\n        external\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        return _exchange_underlying(i, j, dx, min_dy); // U:[CRVB-5]\n    }\n\n    /// @dev Same as the previous one but accepts coin indexes as `int128`\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy)\n        external\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        return _exchange_underlying(_toU256(i), _toU256(j), dx, min_dy); // U:[CRVB-5]\n    }\n\n    /// @dev Implementation of both versions of `exchange_underlying`\n    function _exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) =\n            _exchange_underlying_impl(i, j, _getExchangeUnderlyingCallData(i, j, dx, min_dy), false); // U:[CRVB-5]\n    }\n\n    /// @notice Exchanges the entire balance of one pool's underlying asset to another, except the specified amount\n    /// @param i Index of the underlying asset to spend\n    /// @param j Index of the underlying asset to receive\n    /// @param rateMinRAY Minimum exchange rate between underlying assets i and j, scaled by 1e27\n    function exchange_diff_underlying(uint256 i, uint256 j, uint256 leftoverAmount, uint256 rateMinRAY)\n        external\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        address creditAccount = _creditAccount(); // U:[CRVB-6]\n\n        address tokenIn = _get_underlying(i); // U:[CRVB-6]\n        uint256 dx = IERC20(tokenIn).balanceOf(creditAccount); // U:[CRVB-6]\n        if (dx <= leftoverAmount) return (0, 0);\n\n        unchecked {\n            dx -= leftoverAmount; // U:[CRVB-6]\n        }\n        uint256 min_dy = (dx * rateMinRAY) / RAY; // U:[CRVB-6]\n        (tokensToEnable, tokensToDisable) =\n            _exchange_underlying_impl(i, j, _getExchangeUnderlyingCallData(i, j, dx, min_dy), leftoverAmount <= 1); // U:[CRVB-6]\n    }\n\n    /// @dev Internal implementation of `exchange_underlying` and `exchange_diff_underlying`\n    ///      - passes calldata to the target contract\n    ///      - sets max approval for the input token before the call and resets it to 1 after\n    ///      - enables output asset after the call\n    ///      - disables input asset only when exchanging the entire balance\n    function _exchange_underlying_impl(uint256 i, uint256 j, bytes memory callData, bool disableTokenIn)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _approveToken(_get_underlying(i), type(uint256).max); // U:[CRVB-5,6]\n        _execute(callData); // U:[CRVB-5,6]\n        _approveToken(_get_underlying(i), 1); // U:[CRVB-5,6]\n        (tokensToEnable, tokensToDisable) = (_get_underlying_mask(j), disableTokenIn ? _get_underlying_mask(i) : 0); // U:[CRVB-5,6]\n    }\n\n    /// @dev Returns calldata for `exchange_underlying` and `exchange_diff_underlying` calls\n    function _getExchangeUnderlyingCallData(uint256 i, uint256 j, uint256 dx, uint256 min_dy)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return use256\n            ? abi.encodeWithSignature(\"exchange_underlying(uint256,uint256,uint256,uint256)\", i, j, dx, min_dy)\n            : abi.encodeWithSignature(\"exchange_underlying(int128,int128,uint256,uint256)\", i, j, dx, min_dy); // U:[CRVB-5,6]\n    }\n\n    // ------------- //\n    // ADD LIQUIDITY //\n    // ------------- //\n\n    /// @dev Internal implementation of `add_liquidity`\n    ///      - passes calldata to the target contract\n    ///      - sets max approvals for the specified tokens before the call and resets them to 1 after\n    ///      - enables LP token\n    function _add_liquidity(bool t0Approve, bool t1Approve, bool t2Approve, bool t3Approve)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _approveTokens(t0Approve, t1Approve, t2Approve, t3Approve, type(uint256).max); // U:[CRV2-2, CRV3-2, CRV4-2]\n        _execute(msg.data); // U:[CRV2-2, CRV3-2, CRV4-2]\n        _approveTokens(t0Approve, t1Approve, t2Approve, t3Approve, 1); // U:[CRV2-2, CRV3-2, CRV4-2]\n        (tokensToEnable, tokensToDisable) = (lpTokenMask, 0); // U:[CRV2-2, CRV3-2, CRV4-2]\n    }\n\n    /// @notice Adds given amount of asset as liquidity to the pool\n    /// @param amount Amount to deposit\n    /// @param i Index of the asset to deposit\n    /// @param minAmount Minimum amount of LP tokens to receive\n    function add_liquidity_one_coin(uint256 amount, uint256 i, uint256 minAmount)\n        external\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) =\n            _add_liquidity_one_coin_impl(i, _getAddLiquidityOneCoinCallData(i, amount, minAmount), false); // U:[CRVB-7]\n    }\n\n    /// @notice Adds the entire balance of asset as liquidity to the pool, except the specified amount\n    /// @param leftoverAmount Amount of underlying to keep on the account\n    /// @param i Index of the asset to deposit\n    /// @param rateMinRAY Minimum exchange rate between deposited asset and LP token, scaled by 1e27\n    function add_diff_liquidity_one_coin(uint256 leftoverAmount, uint256 i, uint256 rateMinRAY)\n        external\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        address creditAccount = _creditAccount(); // U:[CRVB-8]\n\n        address tokenIn = _get_token(i); // U:[CRVB-8]\n        uint256 amount = IERC20(tokenIn).balanceOf(creditAccount); // U:[CRVB-8]\n        if (amount <= leftoverAmount) return (0, 0);\n\n        unchecked {\n            amount -= leftoverAmount; // U:[CRVB-8]\n        }\n        uint256 minAmount = (amount * rateMinRAY) / RAY; // U:[CRVB-8]\n        (tokensToEnable, tokensToDisable) =\n            _add_liquidity_one_coin_impl(i, _getAddLiquidityOneCoinCallData(i, amount, minAmount), leftoverAmount <= 1); // U:[CRVB-8]\n    }\n\n    /// @dev Internal implementation of `add_liquidity_one_coin' and `add_diff_liquidity_one_coin`\n    ///      - passes calldata to the target contract\n    ///      - sets max approval for the input token before the call and resets it to 1 after\n    ///      - enables LP token\n    ///      - disables input token only when adding the entire balance\n    function _add_liquidity_one_coin_impl(uint256 i, bytes memory callData, bool disableTokenIn)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _approveToken(_get_token(i), type(uint256).max); // U:[CRVB-7,8]\n        _execute(callData); // U:[CRVB-7,8]\n        _approveToken(_get_token(i), 1); // U:[CRVB-7,8]\n        (tokensToEnable, tokensToDisable) = (lpTokenMask, disableTokenIn ? _get_token_mask(i) : 0); // U:[CRVB-7,8]\n    }\n\n    /// @notice Returns the amount of LP token received for adding a single asset to the pool\n    /// @param amount Amount to deposit\n    /// @param i Index of the asset to deposit\n    function calc_add_one_coin(uint256 amount, uint256 i) external view override returns (uint256) {\n        // some pools omit the second argument of `calc_token_amount` function, so\n        // a call with alternative signature is made in case the first one fails\n        (bytes memory callData, bytes memory callDataAlt) = _getCalcAddOneCoinCallData(i, amount);\n        (bool success, bytes memory returnData) = _callWithAlternative(callData, callDataAlt);\n        if (success && returnData.length > 0) {\n            return abi.decode(returnData, (uint256));\n        } else {\n            revert(\"calc_token_amount reverted\");\n        }\n    }\n\n    /// @dev Returns calldata for adding liquidity in coin `i`, must be overriden in derived adapters\n    function _getAddLiquidityOneCoinCallData(uint256 i, uint256 amount, uint256 minAmount)\n        internal\n        view\n        virtual\n        returns (bytes memory callData);\n\n    /// @dev Returns calldata for calculating the result of adding liquidity in coin `i`,\n    ///      must be overriden in derived adapters\n    function _getCalcAddOneCoinCallData(uint256 i, uint256 amount)\n        internal\n        view\n        virtual\n        returns (bytes memory callData, bytes memory callDataAlt);\n\n    // ---------------- //\n    // REMOVE LIQUIDITY //\n    // ---------------- //\n\n    /// @dev Internal implementation of `remove_liquidity`\n    ///      - passes calldata to the target contract\n    ///      - enables all pool tokens\n    function _remove_liquidity() internal returns (uint256 tokensToEnable, uint256 tokensToDisable) {\n        _execute(msg.data); // U:[CRV2-3, CRV3-3, CRV4-3]\n        (tokensToEnable, tokensToDisable) = (token0Mask | token1Mask | token2Mask | token3Mask, 0); // U:[CRV2-3, CRV3-3, CRV4-3]\n    }\n\n    /// @dev Internal implementation of `remove_liquidity_imbalance`\n    ///      - passes calldata to the target contract\n    ///      - enables specified pool tokens\n    function _remove_liquidity_imbalance(bool t0Enable, bool t1Enable, bool t2Enable, bool t3Enable)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _execute(msg.data); // U:[CRV2-4, CRV3-4, CRV4-4]\n\n        if (t0Enable) tokensToEnable = tokensToEnable.enable(token0Mask); // U:[CRV2-4, CRV3-4, CRV4-4]\n        if (t1Enable) tokensToEnable = tokensToEnable.enable(token1Mask); // U:[CRV2-4, CRV3-4, CRV4-4]\n        if (t2Enable) tokensToEnable = tokensToEnable.enable(token2Mask); // U:[CRV3-4, CRV4-4]\n        if (t3Enable) tokensToEnable = tokensToEnable.enable(token3Mask); // U:[CRV4-4]\n        tokensToDisable = 0; // U:[CRV2-4, CRV3-4, CRV4-4]\n    }\n\n    /// @notice Removes liquidity from the pool in a specified asset\n    /// @param amount Amount of liquidity to remove\n    /// @param i Index of the asset to withdraw\n    /// @param minAmount Minimum amount of asset to receive\n    function remove_liquidity_one_coin(uint256 amount, uint256 i, uint256 minAmount)\n        external\n        virtual\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) = _remove_liquidity_one_coin(amount, i, minAmount); // U:[CRVB-9]\n    }\n\n    /// @dev Same as the previous one but accepts coin indexes as `int128`\n    function remove_liquidity_one_coin(uint256 amount, int128 i, uint256 minAmount)\n        external\n        virtual\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) = _remove_liquidity_one_coin(amount, _toU256(i), minAmount); // U:[CRVB-9]\n    }\n\n    /// @dev Implementation of both versions of `remove_liquidity_one_coin`\n    function _remove_liquidity_one_coin(uint256 amount, uint256 i, uint256 minAmount)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) =\n            _remove_liquidity_one_coin_impl(i, _getRemoveLiquidityOneCoinCallData(i, amount, minAmount), false); // U:[CRVB-9]\n    }\n\n    /// @notice Removes all liquidity from the pool, except the specified amount, in a specified asset\n    /// @param leftoverAmount Amount of Curve LP to keep on the account\n    /// @param i Index of the asset to withdraw\n    /// @param rateMinRAY Minimum exchange rate between LP token and received token, scaled by 1e27\n    function remove_diff_liquidity_one_coin(uint256 leftoverAmount, uint256 i, uint256 rateMinRAY)\n        external\n        virtual\n        override\n        creditFacadeOnly // U:[CRVB-2]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        return _remove_diff_liquidity_one_coin(i, leftoverAmount, rateMinRAY); // U:[CRVB-10]\n    }\n\n    /// @dev Implementation of `remove_diff_liquidity_one_coin`\n    function _remove_diff_liquidity_one_coin(uint256 i, uint256 leftoverAmount, uint256 rateMinRAY)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        address creditAccount = _creditAccount(); // U:[CRVB-10]\n\n        uint256 amount = IERC20(lp_token).balanceOf(creditAccount); // U:[CRVB-10]\n        if (amount <= leftoverAmount) return (0, 0);\n\n        unchecked {\n            amount -= leftoverAmount; // U:[CRVB-10]\n        }\n        uint256 minAmount = (amount * rateMinRAY) / RAY; // U:[CRVB-10]\n        (tokensToEnable, tokensToDisable) = _remove_liquidity_one_coin_impl(\n            i, _getRemoveLiquidityOneCoinCallData(i, amount, minAmount), leftoverAmount <= 1\n        ); // U:[CRVB-10]\n    }\n\n    /// @dev Internal implementation of `remove_liquidity_one_coin` and `remove_diff_liquidity_one_coin`\n    ///      - passes calldata to the targe contract\n    ///      - enables received asset\n    ///      - disables LP token only when removing all liquidity\n    function _remove_liquidity_one_coin_impl(uint256 i, bytes memory callData, bool disableLP)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _execute(callData);\n        (tokensToEnable, tokensToDisable) = (_get_token_mask(i), disableLP ? lpTokenMask : 0); // U:[CRVB-9,10]\n    }\n\n    /// @dev Returns calldata for `remove_liquidity_one_coin` and `remove_diff_liquidity_one_coin` calls\n    function _getRemoveLiquidityOneCoinCallData(uint256 i, uint256 amount, uint256 minAmount)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return use256\n            ? abi.encodeWithSignature(\"remove_liquidity_one_coin(uint256,uint256,uint256)\", amount, i, minAmount)\n            : abi.encodeWithSignature(\"remove_liquidity_one_coin(uint256,int128,uint256)\", amount, i, minAmount); // U:[CRVB-9,10]\n    }\n\n    // ------- //\n    // HELPERS //\n    // ------- //\n\n    /// @dev Returns true if pool is a cryptoswap pool, which is determined by whether it implements `mid_fee`\n    function _use256() internal view returns (bool result) {\n        try ICurvePool(targetContract).mid_fee() returns (uint256) {\n            result = true;\n        } catch {\n            result = false;\n        }\n    }\n\n    /// @dev Returns `i`-th coin of the `pool`, tries both signatures\n    function _getCoin(address pool, uint256 i) internal view returns (address coin) {\n        try ICurvePool(pool).coins(i) returns (address addr) {\n            coin = addr;\n        } catch {\n            try ICurvePool(pool).coins(int128(int256(i))) returns (address addr) {\n                coin = addr;\n            } catch {}\n        }\n    }\n\n    /// @dev Performs a low-level call to the target contract with provided calldata, and, should it fail,\n    ///      makes a second call with alternative calldata\n    function _callWithAlternative(bytes memory callData, bytes memory callDataAlt)\n        internal\n        view\n        returns (bool success, bytes memory returnData)\n    {\n        (success, returnData) = targetContract.staticcall(callData);\n        if (!success || returnData.length == 0) {\n            (success, returnData) = targetContract.staticcall(callDataAlt);\n        }\n    }\n\n    /// @dev Returns token `i`'s address\n    function _get_token(uint256 i) internal view returns (address addr) {\n        if (i == 0) return token0;\n        if (i == 1) return token1;\n        if (i == 2) return token2;\n        if (i == 3) return token3;\n    }\n\n    /// @dev Returns underlying `i`'s address\n    function _get_underlying(uint256 i) internal view returns (address addr) {\n        if (i == 0) return underlying0;\n        if (i == 1) return underlying1;\n        if (i == 2) return underlying2;\n        if (i == 3) return underlying3;\n    }\n\n    /// @dev Returns token `i`'s mask\n    function _get_token_mask(uint256 i) internal view returns (uint256 mask) {\n        if (i == 0) return token0Mask;\n        if (i == 1) return token1Mask;\n        if (i == 2) return token2Mask;\n        if (i == 3) return token3Mask;\n    }\n\n    /// @dev Returns underlying `i`'s mask\n    function _get_underlying_mask(uint256 i) internal view returns (uint256 mask) {\n        if (i == 0) return underlying0Mask;\n        if (i == 1) return underlying1Mask;\n        if (i == 2) return underlying2Mask;\n        if (i == 3) return underlying3Mask;\n    }\n\n    /// @dev Sets target contract's approval for specified tokens to `amount`\n    function _approveTokens(bool t0Approve, bool t1Approve, bool t2Approve, bool t3Approve, uint256 amount) internal {\n        if (t0Approve) _approveToken(token0, amount);\n        if (t1Approve) _approveToken(token1, amount);\n        if (t2Approve) _approveToken(token2, amount);\n        if (t3Approve) _approveToken(token3, amount);\n    }\n\n    /// @dev Returns `int128`-typed number as `uint256`\n    function _toU256(int128 i) internal pure returns (uint256) {\n        return uint256(int256(i));\n    }\n}"
    }
  ]
}