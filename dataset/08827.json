{
  "Title": "[M-03] The logic of _isUnderlying() in NotionalTradeModule is wrong which will cause mintFCashPosition() and redeemFCashPosition() revert on `fcash` tokens which asset token is underlying token (asset.tokenType == TokenType.NonMintable)",
  "Content": "_Submitted by unforgiven_\n\nFor some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting or burning when it is called with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in ` NotionalTradeModule  ` will not work for those `fcash` tokens because `_isUnderlying()` returns `true` result for those tokens which would make `NotionalTradeModule`'s logic for `mintFCashPosition()` and `redeemFCashPosition()` will eventually call `redeemToUnderlying()` and `mintViaUnderlying()` in `wfCashLogic` and those function in `wfCashLogic` will call `NotionalV2` with `useUnderlying==True` and `NotionalV2` will fail and revert for `fcash` tokens which asset token is underlying token, so the whole transaction will fail and `_mintFCashPosition()` and `_redeemFCashPosition()`  logic in ` NotionalTradeModule  ` will not work for those `fcash` tokens and manager can't add them to `set` protocol.\n\n### Proof of Concept\n\nwhen for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `_isUnderlying()` in `NotionalTradeModule` contract first check that `isUnderlying = _paymentToken == underlyingToken` so for `fcash` tokens where asset token is underlying token it is going to return `isUnderlying==True`. let's assume that for some specific `fcash` asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and follow the code execution.\nThis is `_isUnderlying()` code in `NotionalTradeModule`:\n\n        function _isUnderlying(\n            IWrappedfCashComplete _fCashPosition,\n            IERC20 _paymentToken\n        )\n        internal\n        view\n        returns(bool isUnderlying)\n        {\n            (IERC20 underlyingToken, IERC20 assetToken) = _getUnderlyingAndAssetTokens(_fCashPosition);\n            isUnderlying = _paymentToken == underlyingToken;\n            if(!isUnderlying) {\n                require(_paymentToken == assetToken, \"Token is neither asset nor underlying token\");\n            }\n        }\n\nAs you can see it calls `_getUnderlyingAndAssetTokens()` and then check `_paymentToken == underlyingToken` to see that if payment token is equal to `underlyingToken`. `_getUnderlyingAndAssetTokens()` uses `getUnderlyingToken()` and `getAssetToken()` in `wfCashBase`. This is `getUnderlyingToken()` code in `wfCashBase`:\n\n        /// @notice Returns the token and precision of the token that this token settles\n        /// to. For example, fUSDC will return the USDC token address and 1e6. The zero\n        /// address will represent ETH.\n        function getUnderlyingToken() public view override returns (IERC20 underlyingToken, int256 underlyingPrecision) {\n            (Token memory asset, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());\n\n            if (asset.tokenType == TokenType.NonMintable) {\n                // In this case the asset token is the underlying\n                return (IERC20(asset.tokenAddress), asset.decimals);\n            } else {\n                return (IERC20(underlying.tokenAddress), underlying.decimals);\n            }\n        }\n\nAs you can see for our specific `fcash` token this function will return asset token as underlying token. so for this specific `fcash` token, the asset token and underlying token will be same in `_isUnderlying()` of `NationalTradeModule` but because code first check `isUnderlying = _paymentToken == underlyingToken` so the function will return `isUnderlying=True` as a result for our specific `fcash` token (which asset token is underlying token)\nThis is `_mintFCashPosition()` and `_redeemFCashPosition()` code in ` NotionalTradeModule  `:\n\n        /**\n         * @dev Redeem a given fCash position from the specified send token (either underlying or asset token)\n         * @dev Alo adjust the components / position of the set token accordingly\n         */\n        function _mintFCashPosition(\n            ISetToken _setToken,\n            IWrappedfCashComplete _fCashPosition,\n            IERC20 _sendToken,\n            uint256 _fCashAmount,\n            uint256 _maxSendAmount\n        )\n        internal\n        returns(uint256 sentAmount)\n        {\n            if(_fCashAmount == 0) return 0;\n\n            bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);\n\n\n            _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);\n\n            uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));\n            uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));\n\n            _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying);\n\n\n            (sentAmount,) = _updateSetTokenPositions(\n                _setToken,\n                address(_sendToken),\n                preTradeSendTokenBalance,\n                address(_fCashPosition),\n                preTradeReceiveTokenBalance\n            );\n\n            require(sentAmount <= _maxSendAmount, \"Overspent\");\n            emit FCashMinted(_setToken, _fCashPosition, _sendToken, _fCashAmount, sentAmount);\n        }\n\n        /**\n         * @dev Redeem a given fCash position for the specified receive token (either underlying or asset token)\n         * @dev Alo adjust the components / position of the set token accordingly\n         */\n        function _redeemFCashPosition(\n            ISetToken _setToken,\n            IWrappedfCashComplete _fCashPosition,\n            IERC20 _receiveToken,\n            uint256 _fCashAmount,\n            uint256 _minReceiveAmount\n        )\n        internal\n        returns(uint256 receivedAmount)\n        {\n            if(_fCashAmount == 0) return 0;\n\n            bool toUnderlying = _isUnderlying(_fCashPosition, _receiveToken);\n            uint256 preTradeReceiveTokenBalance = _receiveToken.balanceOf(address(_setToken));\n            uint256 preTradeSendTokenBalance = _fCashPosition.balanceOf(address(_setToken));\n\n            _redeem(_setToken, _fCashPosition, _fCashAmount, toUnderlying);\n\n\n            (, receivedAmount) = _updateSetTokenPositions(\n                _setToken,\n                address(_fCashPosition),\n                preTradeSendTokenBalance,\n                address(_receiveToken),\n                preTradeReceiveTokenBalance\n            );\n\n\n            require(receivedAmount >= _minReceiveAmount, \"Not enough received amount\");\n            emit FCashRedeemed(_setToken, _fCashPosition, _receiveToken, _fCashAmount, receivedAmount);\n\n        }\n\nAs you can see they both uses `_isUnderlying()` to find out that if `_sendToken` is asset token or underlying token. for our specific `fcash` token, the result of `_isUnderlying()` will be `True` and `_mintFCashPosition()` and `_redeemFCashPosition()`  will call `_mint()` and `_redeem()` with `toUnderlying` set as `True`. This is `_mint()` and `_redeem()` code:\n\n        /**\n         * @dev Invokes the wrappedFCash token's mint function from the setToken\n         */\n        function _mint(\n            ISetToken _setToken,\n            IWrappedfCashComplete _fCashPosition,\n            uint256 _maxAssetAmount,\n            uint256 _fCashAmount,\n            bool _fromUnderlying\n        )\n        internal\n        {\n            uint32 minImpliedRate = 0;\n\n            bytes4 functionSelector = \n                _fromUnderlying ? _fCashPosition.mintViaUnderlying.selector : _fCashPosition.mintViaAsset.selector;\n            bytes memory mintCallData = abi.encodeWithSelector(\n                functionSelector,\n                _maxAssetAmount,\n                uint88(_fCashAmount),\n                address(_setToken),\n                minImpliedRate,\n                _fromUnderlying\n            );\n            _setToken.invoke(address(_fCashPosition), 0, mintCallData);\n        }\n\n        /**\n         * @dev Redeems the given amount of fCash token on behalf of the setToken\n         */\n        function _redeem(\n            ISetToken _setToken,\n            IWrappedfCashComplete _fCashPosition,\n            uint256 _fCashAmount,\n            bool _toUnderlying\n        )\n        internal\n        {\n            uint32 maxImpliedRate = type(uint32).max;\n\n            bytes4 functionSelector =\n                _toUnderlying ? _fCashPosition.redeemToUnderlying.selector : _fCashPosition.redeemToAsset.selector;\n            bytes memory redeemCallData = abi.encodeWithSelector(\n                functionSelector,\n                _fCashAmount,\n                address(_setToken),\n                maxImpliedRate\n            );\n            _setToken.invoke(address(_fCashPosition), 0, redeemCallData);\n        }\n\nAs you can see they are using `_toUnderlying` value to decide calling between (`mintViaUnderlying()` or `mintViaAsset()`) and (`redeemToUnderlying()` or `redeemToAsset()`), for our specific `fcash` `_toUnderlying` will be `True` so those functions will call `mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic`.\n`mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic` execution flow eventually would call `NotionalV2` functions with `useUnderlying=True` for this specific `fcash` token, but `NotionalV2` will revert for that call because for that `fcash` token asset token is underlying token and `NotionalV2` can't handle calls with `useUnderlying==True` for that `fcash` Token. This will cause all the transaction to fail and manager can't call `redeemFCashPosition()` or `mintFCashPosition()` functions for those `fcash` tokens that asset token is underlying token.\nIn summery `NotionalTradeModule` logic will not work for all `fcash` tokens becasue the logic of `_isUnderlying()` is wrong for `fcash` tokens that asset token is underlying token.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nChange the logic of `_isUnderlying()` in `NotionalTradeModule` so it returns correct results for all `fcash` tokens. One simple solution can be that it first check `payment token`  value with `asset token` value.\n\n**[ckoopmann (Index Coop) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/87#issuecomment-1156022313):**\n > Will need input from @jeffywu here, is the description of the Notional side of things correct ? \n> \n> I'll also try to reproduce this issue in a test maybe to make sure if it is valid.\n> \n> Not sure if this is \"High Risk\" as no funds seem to be at risk. However from the description it might render the `NotionalTradeModule` incompatible with certain fCash tokens, which we certainly want to avoid. So will have to review this in more detail.\n\n**[jeffywu (Notional) commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/87#issuecomment-1156585499):**\n > Agree with @ckoopmann that severity should be reduced here, what this would cause is a revert not any loss of funds.\n> \n> The simple fix would just be to always use `mintViaAsset` and `mintViaUnderlying` for the case when fCash has a non-mintable type (currently there are no fCash assets of this type and none planned). However, we can also add the ability to query this on the wfCash side to make things more compatible.\n\n**[ckoopmann (Index Coop) commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/87#issuecomment-1157114524):**\n > @jeffywu What do you think of the suggested mitigation strategy ? \n> \n> As far as I understand we would just have to change:\n> `isUnderlying = _paymentToken == underlyingToken;` to `isUnderlying = _paymentToken != assetToken;` to avoid the described issue, no ?  \n\n**[jeffywu (Notional) commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/87#issuecomment-1157570874):**\n > To make this more fool proof what I can do is just add a check on the wrapped fCash side to see if the token is non-mintable and then override the useUnderlying flag internally there. I think that will be a better solution since getUnderlyingToken already has logic to return the asset token when it is marked as non-mintable. That would mean that you would not need to make any changes, I think this will make it easier for integrating developers in the future.\n> \n> Specifically add checks here:\n> https://github.com/notional-finance/wrapped-fcash/blob/master/contracts/wfCashLogic.sol#L57-L58\n> and here:\n> https://github.com/notional-finance/wrapped-fcash/blob/master/contracts/wfCashLogic.sol#L210-L211\n> \n> and overwrite the incoming useUnderlying if we are in this situation.\n\n**[ckoopmann (Index Coop) commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/87#issuecomment-1159612676):**\n> @jeffywu Sounds great to me. If I understand correctly that means I would not have to change anything on the trade module side. Let me know if that is incorrect.\n\n**[jeffywu (Notional) resolved and commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/87#issuecomment-1159704963):**\n> @ckoopmann, no changes necessary on your side. You can see the changes [here](https://github.com/notional-finance/wrapped-fcash/pull/11/commits/0ab1ae1080c8eb14fd24d180a01f8ec2c8919022#diff-7c9f6e4700cce75c3c2abb4902f45f7398dcac73135a605b59825b26de7d6af0R60).\n\n> https://github.com/notional-finance/wrapped-fcash/pull/11/commits/0ab1ae1080c8eb14fd24d180a01f8ec2c8919022#diff-7c9f6e4700cce75c3c2abb4902f45f7398dcac73135a605b59825b26de7d6af0R245\n\n**[gzeoneth (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-notional-coop-findings/issues/87#issuecomment-1166523407):**\n> There doesn't seems to be loss of fund as it would revert. Judging as Med Risk.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-notional-coop",
  "Code": [
    {
      "filename": "contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        (/* */, uint256 maxFCash) = getTotalFCashAvailable();\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, maxFCash);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        uint256 maxFCash\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH, bool hasTransferFee, uint256 precision) = _getTokenForMintInternal();\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint16 currencyId = getCurrencyId();\n        \n        if (isETH) {\n            // Use WETH if lending ETH. Although Notional natively supports ETH, we use WETH here for integration\n            // contracts so they only have to support ERC20 token transfers.\n            // NOTE: safeTransferFrom not required since WETH is known to be compatible\n            IERC20((address(WETH))).transferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n        } else {\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            depositAmountExternal = token.balanceOf(address(this)) - balanceBefore;\n        }\n\n        if (maxFCash < fCashAmount) {\n            // Transfer fees will break the lending at zero functionality since fees will cause lending\n            // to occur at slightly less than a 1-1 ratio. Just don't allow this to occur.\n            require(hasTransferFee == false);\n            require(minImpliedRate == 0, \"Slippage\");\n            // NOTE: lending at zero\n            uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n            require(fCashAmountExternal <= depositAmountExternal);\n\n            uint256 msgValue;\n            if (isETH) {\n                msgValue = fCashAmountExternal;\n                // Re-wrap the residual ETH to send back to the account\n                WETH.deposit{value: depositAmountExternal - fCashAmountExternal}();\n            }\n\n            // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n            // back to the account\n            NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n        } else if (isETH || hasTransferFee || getCashBalance() > 0) {\n            _lendLegacy(currencyId, depositAmountExternal, fCashAmount, minImpliedRate, isETH);\n        } else {\n            // Executes a lending action on Notional. Since this lending action uses an existing cash balance\n            // prior to pulling payment, we cannot use it if there is a cash balance on the wrapper contract,\n            // it will cause existing cash balances to be minted into fCash and create a shortfall. In normal\n            // conditions, this method is more gas efficient.\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                currencyId,\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver\n        _mint(receiver, fCashAmount);\n\n        // Residual tokens will be sent back to msg.sender, not the receiver. The msg.sender\n        // was used to transfer tokens in and these are any residual tokens left that were not\n        // lent out. Sending these tokens back to the receiver risks them getting locked on a\n        // contract that does not have the capability to transfer them off\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    function _lendLegacy(\n        uint16 currencyId,\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        uint32 minImpliedRate,\n        bool isETH\n    ) internal {\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient.\n\n        // If deposit amount external is in excess of the cost to purchase fCash amount (often the case),\n        // then we need to return the difference between postTradeCash - preTradeCash. This is done because\n        // the encoded trade does not automatically withdraw the entire cash balance in case the wrapper\n        // is holding a cash balance.\n        uint256 preTradeCash = getCashBalance();\n\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeLegacyLendTrade(\n            currencyId,\n            getMarketIndex(),\n            depositAmountExternal,\n            fCashAmount,\n            minImpliedRate\n        );\n        uint256 msgValue = isETH ? depositAmountExternal : 0;\n        // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n        // native ETH tokens will be wrapped back to WETH.\n        NotionalV2.batchBalanceAndTradeAction{value: msgValue}(address(this), action);\n\n        uint256 postTradeCash = getCashBalance();\n\n        if (preTradeCash != postTradeCash) {\n            // If ETH, then redeem to WETH (redeemToUnderlying == false), next line ensures\n            // that postTradeCash is always increasing from preTradeCash.\n            NotionalV2.withdraw(currencyId, _safeUint88(postTradeCash - preTradeCash), !isETH);\n        }\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address /* _operator */,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata /* _data */\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(msg.sender == address(NotionalV2), \"Invalid\");\n        // Only accept the fcash id that corresponds to the listed currency and maturity\n        require(_id == fCashID, \"Invalid\");\n        // Protect against signed value underflows\n        require(int256(_value) > 0, \"Invalid\");\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(ac.hasDebt == 0x00);\n        require(assets.length == 1);\n        require(EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType) == fCashID\n        );\n\n        // Mint ERC20 tokens for the sender\n        _mint(_from, _value);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) external override {\n        _burnInternal(msg.sender, amount, opts);\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint256 minUnderlyingOut\n    ) external override {\n        _burnInternal(\n            msg.sender,\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                minUnderlyingOut: minUnderlyingOut\n            })\n        );\n    }\n\n    /// @notice This method is here only in the case where someone has transferred invalid fCash\n    /// to the contract and would prevent ERC1155 transfer hooks from succeeding. In this case the\n    /// owner can recover the invalid fCash to a designated receiver. This can only occur if the fCash\n    /// is transferred prior to contract creation.\n    function recoverInvalidfCash(uint256 fCashId, address receiver) external {\n        // Only the Notional owner can call this method\n        require(msg.sender == NotionalV2.owner());\n        // Cannot transfer the native fCash id of this wrapper\n        require(fCashId != getfCashId());\n        uint256 balance = NotionalV2.balanceOf(address(this), fCashId);\n        // There should be a positive balance before we try to transfer this\n        require(balance > 0);\n        NotionalV2.safeTransferFrom(address(this), receiver, fCashId, balance, \"\");\n        \n        // Double check that we don't incur debt\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        require(ac.hasDebt == 0x00);\n    }\n\n    /// @notice Allows the owner to recover prime cash profits to the treasury after all\n    /// shares have been withdrawn.\n    function recoverPrimeCash() external {\n        address owner = NotionalV2.owner();\n        // Only the Notional owner can call this method\n        require(msg.sender == owner);\n        // Can only do this after maturity and when the total supply has drawn down\n        require(hasMatured());\n        require(totalSupply() == 0);\n\n        uint256 cashBalance = getCashBalance();\n        require(cashBalance > 0);\n        _withdrawCashToAccount(getCurrencyId(), owner, _safeUint88(cashBalance));\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burnInternal(\n        address from,\n        uint256 fCashShares,\n        RedeemOpts memory opts\n    ) internal nonReentrant {\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        require(opts.redeemToUnderlying || opts.transferfCash);\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, fCashShares);\n\n        if (hasMatured()) {\n            require(opts.transferfCash == false);\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled, it is cheaper to call this method than\n            // cache it in storage locally\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n            uint256 primeCashClaim = _getMaturedCashValue(fCashShares);\n\n            // Transfer withdrawn tokens to the `from` address\n            uint256 tokensTransferred = _withdrawCashToAccount(\n                currencyId, opts.receiver, _safeUint88(primeCashClaim)\n            );\n            require(opts.minUnderlyingOut <= tokensTransferred, \"Slippage\");\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                fCashShares, // Amount of fCash to send\n                \"\"\n            );\n\n            // Double check that we don't incur debt, this can happen if the wrapper has\n            // lent a cash balance and there is actually insufficient fCash to remove.\n            AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n            require(ac.hasDebt == 0x00);\n        } else {\n            uint256 tokensTransferred = _sellfCash(opts.receiver, fCashShares);\n            require(opts.minUnderlyingOut <= tokensTransferred, \"Slippage\");\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 primeCashToWithdraw\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, primeCashToWithdraw, !isETH);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint16 currencyId = getCurrencyId();\n\n        (uint256 initialCashBalance, uint256 fCashBalance) = getBalances();\n        bool hasInsufficientfCash = fCashBalance < fCashToSell;\n\n        uint256 primeCashToWithdraw;\n        if (hasInsufficientfCash) {\n            // If there is insufficient fCash, calculate how much prime cash would be purchased if the\n            // given fCash amount would be sold and that will be how much the wrapper will withdraw and\n            // send to the receiver. Since fCash always sells at a discount to underlying prior to maturity,\n            // the wrapper is guaranteed to have sufficient cash to send to the account.\n            (/* */, primeCashToWithdraw, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                fCashToSell,\n                getMaturity(),\n                0,\n                block.timestamp\n            );\n            // If this is zero then it signifies that the trade will fail.\n            require(primeCashToWithdraw > 0, \"Redeem Failed\");\n\n            // Re-write the fCash to sell to the entire fCash balance.\n            fCashToSell = fCashBalance;\n        }\n\n        if (fCashToSell > 0) {\n            // Sells fCash on Notional AMM (via borrowing)\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\n                currencyId,\n                getMarketIndex(),\n                _safeUint88(fCashToSell),\n                0 // Slippage is not checked here, it will be enforced in the calling function\n                  // via minUnderlyingOut\n            );\n            NotionalV2.batchBalanceAndTradeAction(address(this), action);\n        }\n\n        uint256 postTradeCash = getCashBalance();\n\n        // If the account did not have insufficient fCash, then the amount of cash change here is what\n        // the receiver is owed. In the other case, we transfer to the receiver the total calculated amount\n        // above without modification.\n        if (!hasInsufficientfCash) primeCashToWithdraw = postTradeCash - initialCashBalance;\n        require(primeCashToWithdraw <= postTradeCash);\n\n        // Withdraw the total amount of cash and send it to the receiver\n        NotionalV2.withdraw(currencyId, _safeUint88(primeCashToWithdraw), !isETH);\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    function _sendTokensToReceiver(\n        IERC20 token,\n        address receiver,\n        bool isETH,\n        uint256 balanceBefore\n    ) private returns (uint256 tokensTransferred) {\n        uint256 balanceAfter = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        tokensTransferred = balanceAfter - balanceBefore;\n\n        if (isETH) {\n            // No need to use safeTransfer for WETH since it is known to be compatible\n            IERC20(address(WETH)).transfer(receiver, tokensTransferred);\n        } else if (tokensTransferred > 0) {\n            token.safeTransfer(receiver, tokensTransferred);\n        }\n    }\n\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\n        require(x <= uint256(type(uint88).max));\n        return uint88(x);\n    }\n}"
    },
    {
      "filename": "contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        (/* */, uint256 maxFCash) = getTotalFCashAvailable();\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, maxFCash);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        uint256 maxFCash\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH, bool hasTransferFee, uint256 precision) = _getTokenForMintInternal();\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint16 currencyId = getCurrencyId();\n        \n        if (isETH) {\n            // Use WETH if lending ETH. Although Notional natively supports ETH, we use WETH here for integration\n            // contracts so they only have to support ERC20 token transfers.\n            // NOTE: safeTransferFrom not required since WETH is known to be compatible\n            IERC20((address(WETH))).transferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n        } else {\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            depositAmountExternal = token.balanceOf(address(this)) - balanceBefore;\n        }\n\n        if (maxFCash < fCashAmount) {\n            // Transfer fees will break the lending at zero functionality since fees will cause lending\n            // to occur at slightly less than a 1-1 ratio. Just don't allow this to occur.\n            require(hasTransferFee == false);\n            require(minImpliedRate == 0, \"Slippage\");\n            // NOTE: lending at zero\n            uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n            require(fCashAmountExternal <= depositAmountExternal);\n\n            uint256 msgValue;\n            if (isETH) {\n                msgValue = fCashAmountExternal;\n                // Re-wrap the residual ETH to send back to the account\n                WETH.deposit{value: depositAmountExternal - fCashAmountExternal}();\n            }\n\n            // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n            // back to the account\n            NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n        } else if (isETH || hasTransferFee || getCashBalance() > 0) {\n            _lendLegacy(currencyId, depositAmountExternal, fCashAmount, minImpliedRate, isETH);\n        } else {\n            // Executes a lending action on Notional. Since this lending action uses an existing cash balance\n            // prior to pulling payment, we cannot use it if there is a cash balance on the wrapper contract,\n            // it will cause existing cash balances to be minted into fCash and create a shortfall. In normal\n            // conditions, this method is more gas efficient.\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                currencyId,\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver\n        _mint(receiver, fCashAmount);\n\n        // Residual tokens will be sent back to msg.sender, not the receiver. The msg.sender\n        // was used to transfer tokens in and these are any residual tokens left that were not\n        // lent out. Sending these tokens back to the receiver risks them getting locked on a\n        // contract that does not have the capability to transfer them off\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    function _lendLegacy(\n        uint16 currencyId,\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        uint32 minImpliedRate,\n        bool isETH\n    ) internal {\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient.\n\n        // If deposit amount external is in excess of the cost to purchase fCash amount (often the case),\n        // then we need to return the difference between postTradeCash - preTradeCash. This is done because\n        // the encoded trade does not automatically withdraw the entire cash balance in case the wrapper\n        // is holding a cash balance.\n        uint256 preTradeCash = getCashBalance();\n\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeLegacyLendTrade(\n            currencyId,\n            getMarketIndex(),\n            depositAmountExternal,\n            fCashAmount,\n            minImpliedRate\n        );\n        uint256 msgValue = isETH ? depositAmountExternal : 0;\n        // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n        // native ETH tokens will be wrapped back to WETH.\n        NotionalV2.batchBalanceAndTradeAction{value: msgValue}(address(this), action);\n\n        uint256 postTradeCash = getCashBalance();\n\n        if (preTradeCash != postTradeCash) {\n            // If ETH, then redeem to WETH (redeemToUnderlying == false), next line ensures\n            // that postTradeCash is always increasing from preTradeCash.\n            NotionalV2.withdraw(currencyId, _safeUint88(postTradeCash - preTradeCash), !isETH);\n        }\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address /* _operator */,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata /* _data */\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(msg.sender == address(NotionalV2), \"Invalid\");\n        // Only accept the fcash id that corresponds to the listed currency and maturity\n        require(_id == fCashID, \"Invalid\");\n        // Protect against signed value underflows\n        require(int256(_value) > 0, \"Invalid\");\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(ac.hasDebt == 0x00);\n        require(assets.length == 1);\n        require(EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType) == fCashID\n        );\n\n        // Mint ERC20 tokens for the sender\n        _mint(_from, _value);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) external override {\n        _burnInternal(msg.sender, amount, opts);\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint256 minUnderlyingOut\n    ) external override {\n        _burnInternal(\n            msg.sender,\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                minUnderlyingOut: minUnderlyingOut\n            })\n        );\n    }\n\n    /// @notice This method is here only in the case where someone has transferred invalid fCash\n    /// to the contract and would prevent ERC1155 transfer hooks from succeeding. In this case the\n    /// owner can recover the invalid fCash to a designated receiver. This can only occur if the fCash\n    /// is transferred prior to contract creation.\n    function recoverInvalidfCash(uint256 fCashId, address receiver) external {\n        // Only the Notional owner can call this method\n        require(msg.sender == NotionalV2.owner());\n        // Cannot transfer the native fCash id of this wrapper\n        require(fCashId != getfCashId());\n        uint256 balance = NotionalV2.balanceOf(address(this), fCashId);\n        // There should be a positive balance before we try to transfer this\n        require(balance > 0);\n        NotionalV2.safeTransferFrom(address(this), receiver, fCashId, balance, \"\");\n        \n        // Double check that we don't incur debt\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        require(ac.hasDebt == 0x00);\n    }\n\n    /// @notice Allows the owner to recover prime cash profits to the treasury after all\n    /// shares have been withdrawn.\n    function recoverPrimeCash() external {\n        address owner = NotionalV2.owner();\n        // Only the Notional owner can call this method\n        require(msg.sender == owner);\n        // Can only do this after maturity and when the total supply has drawn down\n        require(hasMatured());\n        require(totalSupply() == 0);\n\n        uint256 cashBalance = getCashBalance();\n        require(cashBalance > 0);\n        _withdrawCashToAccount(getCurrencyId(), owner, _safeUint88(cashBalance));\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burnInternal(\n        address from,\n        uint256 fCashShares,\n        RedeemOpts memory opts\n    ) internal nonReentrant {\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        require(opts.redeemToUnderlying || opts.transferfCash);\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, fCashShares);\n\n        if (hasMatured()) {\n            require(opts.transferfCash == false);\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled, it is cheaper to call this method than\n            // cache it in storage locally\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n            uint256 primeCashClaim = _getMaturedCashValue(fCashShares);\n\n            // Transfer withdrawn tokens to the `from` address\n            uint256 tokensTransferred = _withdrawCashToAccount(\n                currencyId, opts.receiver, _safeUint88(primeCashClaim)\n            );\n            require(opts.minUnderlyingOut <= tokensTransferred, \"Slippage\");\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                fCashShares, // Amount of fCash to send\n                \"\"\n            );\n\n            // Double check that we don't incur debt, this can happen if the wrapper has\n            // lent a cash balance and there is actually insufficient fCash to remove.\n            AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n            require(ac.hasDebt == 0x00);\n        } else {\n            uint256 tokensTransferred = _sellfCash(opts.receiver, fCashShares);\n            require(opts.minUnderlyingOut <= tokensTransferred, \"Slippage\");\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 primeCashToWithdraw\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, primeCashToWithdraw, !isETH);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell\n    ) private returns (uint256 tokensTransferred) {\n        (IERC"
    }
  ]
}