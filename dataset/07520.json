{
  "Title": "[M-03] `CrossChainExecutor` contracts do not update the necessary states for failing transactions",
  "Content": "\n[EthereumToOptimismExecutor.sol#L45-L59](https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-optimism/EthereumToOptimismExecutor.sol#L45-L59)<br>\n[EthereumToArbitrumExecutor.sol#L31-L45](https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumExecutor.sol#L31-L45)\n\nThe `CrossChainExecutorArbitrum` and `CrossChainExecutorOptimism` contracts both use `CallLib` library to invoke `Call`s on external contract. As per the `CallLib` library implementation, any failing `Call` results in the entire transaction getting reverted.\n\nThe `CrossChainExecutor` contracts does not store whether the calls in `CallLib.Call[]` were already attempted which failed.\n\nThis creates several issues for `CrossChainExecutor` contracts.\n\n1.  Offchain components can be tricked to submit failing `Call[]`s again and again. This can be used to drain the offchain component of gas.\n\n2.  Once a failing `Call[]` was invoked (which failed) and if again the same `Call[]` is invoked, the transaction should revert with `CallsAlreadyExecuted` error but it reverts with `CallFailure` error.\n\n3.  It is difficult to determine whether a to-be executed `Call[]` is pending or the invocation was already tried but failed.\n\nPoCs for the above issues are listed below.\n\n### Proof of Concept\n\n#### Scenario 1\n\n```solidity\ncontract Foo {\n    function bar() public {\n        for(uint256 i; ; i++) {}\n    }\n}\n```\n\n*   The attacker relays the `Foo.bar()` call in the `CrossChainRelayer` contract with `maxGasLimit` as the `_gasLimit` parameter.\n*   The transport layer tries to invoke the `Foo.bar()` call by calling the `CrossChainExecutor.executeCalls()`. This transaction reverts costing the transport layer client `maxGasLimit` gas.\n*   Since no state updates were performed in `CrossChainExecutor`, the transport layer still assumes the relayed call as pending which needs to be executed. The transport layer client again tries to execute the pending relayed call which reverts again.\n*   Repeated execution of the above steps can deplete the gas reserves of transport layer client.\n\n#### Scenario 2\n\n```solidity\ncontract Foo {\n    function bar() public {\n        revert();\n    }\n}\n```\n\n*   The attacker relays the `Foo.bar()` call in the `CrossChainRelayer` contract.\n*   The transport layer tries to invoke the `Foo.bar()` call by calling the `CrossChainExecutor.executeCalls()`. This transaction gets reverted.\n*   Since the relayed calls still seems as pending, the transport layer tries to invoke the `Foo.bar()` call again. This call should get reverted with `CallsAlreadyExecuted` error but it gets reverted with `CallFailure` error.\n\n### Recommended Mitigation Steps\n\nThe `CrossChainExecutor` contract should store whether a relayed call was attempted to be executed to make sure the execution cannot be tried again.\n\nThe `CallLib` library can be changed to not completely revert the transaction when any individual `Call` gets failed.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1339843628):**\n > Not convinced by High Severity but the fact that you cannot determine whether calls were already attempted seems valid.\n\n**[PierrickGT (PoolTogether) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1353499958):**\n > Indeed, in the current implementation, it's pretty difficult to know which calls succeeded and which calls failed.\n> \n> So we've added two events:\n> - `event CallSuccess(uint256 callIndex, bytes successData);`\n> - `event CallFailure(uint256 callIndex, bytes errorData);`\n> \n> When a Call fails, we emit the `CallFailure` event and exit early the loop going through the batch calls.\n> `CallLib.executeCalls` will return `false` and then the transaction will revert with the custom error `ExecuteCallsFailed`.\n> \n> If all calls have executed successfully, `CallLib.executeCalls` will return `true` and then the `ExecutedCalls` event will be emitted.\n> \n> This way, it's possible to know which calls succeeded and which didn't.<br>\n> If one Call fails, the entire transaction must revert cause the user may have intended to execute all the calls in one transaction and maybe some calls depends on others to succeed.\n> \n> I think this issue should be labeled as 2 (Med Risk) since it would indeed have been difficult for the transport layer client to figure out why the transaction failed and if it was worth replaying in the future.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1364420621):**\n > I think the finding was well thought out and can tell it helped shaped the protocol.\n> \n> I believe Medium severity could be reasonably marked, however I think Low Severity to be the most appropriate one.\n> \n> Specifically:\n> - No loss of funds (beside gas happens)\n> - Similar architectures (e.g Chainlink Keepers), share the similar \"cannot tell if failed or not\"\n> - The responsibility for determining if the tx will fail is on the caller (relayer)\n> \n> For those reasons I believe QA Low (Notable finding for Relayer / Service Operators) to be the most appropriate.\n> \n> I will flag this during triage to get more opinions.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1365455690):**\n > Some additional thinking I'm having is that a failed tx could remain un-broadcasted for an indefinite amount of time, and this could create issues for the receiving contract if / when the contract is made to not revert.\n>\n > Specifically the fact that a failed tx can be relayed in the future (no expiration) seems to create a risk that can cause loss of value, which leads to me believe there is a valid argument for Medium Severity.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/166#issuecomment-1365508555):**\n > After further thinking, I believe the most appropriate severity is Medium.\n> \n> The Warden has shown how the code allows the execution of old failed txs, while that is fine, I believe the lack of expiry can create situations in which a old message could be broadcasted and the broadcasting of it could cause a non idempotent behavior.\n> \n> The simplest example I can think of would be an unpause tx, that fails up until a set of contracts are paused, which would put a paused system (probably because of an exploit or the need for immediate stop) back into the unpaused state.\n> \n> While the externalities are multiple, I believe because:\n> - The general nature of the system\n> - The lack of expiration for old calls\n> \n> That Medium Severity is the most appropriate.\n> \n> Personally I would recommend considering a way to make calls expire after some time to avoid potential gotchas (or integrators may want to verify that via a nonce system or similar)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-12-pooltogether",
  "Code": [
    {
      "filename": "src/ethereum-optimism/EthereumToOptimismExecutor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.16;\n\nimport { ICrossDomainMessenger } from \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\";\n\nimport \"../interfaces/ICrossChainExecutor.sol\";\nimport \"../libraries/CallLib.sol\";\n\n/**\n * @title CrossChainExecutorOptimism contract\n * @notice The CrossChainExecutorOptimism contract executes calls from the Ethereum chain.\n *         These calls are sent by the `CrossChainRelayerOptimism` contract which lives on the Ethereum chain.\n */\ncontract CrossChainExecutorOptimism is ICrossChainExecutor {\n  /* ============ Variables ============ */\n\n  /// @notice Address of the Optimism cross domain messenger on the Optimism chain.\n  ICrossDomainMessenger public immutable crossDomainMessenger;\n\n  /// @notice Address of the relayer contract on the Ethereum chain.\n  ICrossChainRelayer public relayer;\n\n  /**\n   * @notice Nonce to uniquely identify the batch of calls that were executed\n   *         nonce => boolean\n   * @dev Ensure that batch of calls cannot be replayed once they have been executed.\n   */\n  mapping(uint256 => bool) public executed;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice CrossChainExecutorOptimism constructor.\n   * @param _crossDomainMessenger Address of the Optimism cross domain messenger on the Optimism chain\n   */\n  constructor(ICrossDomainMessenger _crossDomainMessenger) {\n    require(address(_crossDomainMessenger) != address(0), \"Executor/CDM-not-zero-address\");\n    crossDomainMessenger = _crossDomainMessenger;\n  }\n\n  /* ============ External Functions ============ */\n\n  /// @inheritdoc ICrossChainExecutor\n  function executeCalls(\n    uint256 _nonce,\n    address _sender,\n    CallLib.Call[] calldata _calls\n  ) external {\n    ICrossChainRelayer _relayer = relayer;\n    _isAuthorized(_relayer);\n\n    bool _executedNonce = executed[_nonce];\n    executed[_nonce] = true;\n\n    CallLib.executeCalls(_nonce, _sender, _calls, _executedNonce);\n\n    emit ExecutedCalls(_relayer, _nonce);\n  }\n\n  /**\n   * @notice Set relayer contract address.\n   * @dev Will revert if it has already been set.\n   * @param _relayer Address of the relayer contract on the Ethereum chain\n   */\n  function setRelayer(ICrossChainRelayer _relayer) external {\n    require(address(relayer) == address(0), \"Executor/relayer-already-set\");\n    relayer = _relayer;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Check if sender is authorized to call `executeCalls`.\n   * @param _relayer Address of the relayer on the Ethereum chain\n   */\n  function _isAuthorized(ICrossChainRelayer _relayer) internal view {\n    ICrossDomainMessenger _crossDomainMessenger = crossDomainMessenger;\n\n    require(\n      msg.sender == address(_crossDomainMessenger) &&\n        _crossDomainMessenger.xDomainMessageSender() == address(_relayer),\n      \"Executor/sender-unauthorized\"\n    );\n  }\n}"
    },
    {
      "filename": "src/ethereum-arbitrum/EthereumToArbitrumExecutor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.16;\n\nimport { AddressAliasHelper } from \"@arbitrum/nitro-contracts/src/libraries/AddressAliasHelper.sol\";\n\nimport \"../interfaces/ICrossChainExecutor.sol\";\nimport \"../libraries/CallLib.sol\";\n\n/**\n * @title CrossChainExecutorArbitrum contract\n * @notice The CrossChainExecutorArbitrum contract executes calls from the Ethereum chain.\n *         These calls are sent by the `CrossChainRelayerArbitrum` contract which lives on the Ethereum chain.\n */\ncontract CrossChainExecutorArbitrum is ICrossChainExecutor {\n  /* ============ Variables ============ */\n\n  /// @notice Address of the relayer contract on the Ethereum chain.\n  ICrossChainRelayer public relayer;\n\n  /**\n   * @notice Nonce to uniquely identify the batch of calls that were executed.\n   *         nonce => boolean\n   * @dev Ensure that batch of calls cannot be replayed once they have been executed.\n   */\n  mapping(uint256 => bool) public executed;\n\n  /* ============ External Functions ============ */\n\n  /// @inheritdoc ICrossChainExecutor\n  function executeCalls(\n    uint256 _nonce,\n    address _sender,\n    CallLib.Call[] calldata _calls\n  ) external {\n    ICrossChainRelayer _relayer = relayer;\n    _isAuthorized(_relayer);\n\n    bool _executedNonce = executed[_nonce];\n    executed[_nonce] = true;\n\n    CallLib.executeCalls(_nonce, _sender, _calls, _executedNonce);\n\n    emit ExecutedCalls(_relayer, _nonce);\n  }\n\n  /**\n   * @notice Set relayer contract address.\n   * @dev Will revert if it has already been set.\n   * @param _relayer Address of the relayer contract on the Ethereum chain\n   */\n  function setRelayer(ICrossChainRelayer _relayer) external {\n    require(address(relayer) == address(0), \"Executor/relayer-already-set\");\n    relayer = _relayer;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Check that the message came from the `relayer` on the Ethereum chain.\n   * @dev We check that the sender is the L1 contract's L2 alias.\n   * @param _relayer Address of the relayer on the Ethereum chain\n   */\n  function _isAuthorized(ICrossChainRelayer _relayer) internal view {\n    require(\n      msg.sender == AddressAliasHelper.applyL1ToL2Alias(address(_relayer)),\n      \"Executor/sender-unauthorized\"\n    );\n  }\n}"
    }
  ]
}