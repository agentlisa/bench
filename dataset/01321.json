{
  "Title": "Lack of existence validation when adding a new unripe token",
  "Content": "**Description:** [`UnripeFacet::addUnripeToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/barn/UnripeFacet.sol#L227-L236) does not currently check if the `unripeToken` has been already added. Unlike `LibWhitelist::whitelistToken`, which has [this check](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibWhitelist.sol#L80), the current implementation allows the Beanstalk Community Multisig (BCM) to modify the settings for existing unripe tokens.\n\n**Impact:** Unripe tokens were introduced as a mechanism for recapitalization after the governance hack of April 2022. While the BCM affords more flexibility and control compared to the previous implementation of fully on-chain governance, if the BCM were to become compromised in any way or sign off on a vulnerable contract upgrade, privileged access to this function could result in the ability to manipulate the unripe token mechanisms that exist within the protocol by altering the Merkle root for a pre-existing unripe token.\n\n**Recommended Mitigation:** Validate that the unripe token has not already been added to prevent changes to existing unripe tokens.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/barn/UnripeFacet.sol",
      "content": "/*\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IBean} from \"contracts/interfaces/IBean.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibUnripe} from \"contracts/libraries/LibUnripe.sol\";\nimport {LibTransfer} from \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/C.sol\";\nimport \"contracts/beanstalk/ReentrancyGuard.sol\";\n\n/// @author ZrowGz, Publius\n/// @title VestingFacet\n/// @notice Manage the logic of the vesting process for the Barnraised Funds\n\ncontract UnripeFacet is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using LibTransfer for IERC20;\n    using SafeMath for uint256;\n\n    uint256 constant DECIMALS = 1e6;\n\n    event AddUnripeToken(\n        address indexed unripeToken,\n        address indexed underlyingToken,\n        bytes32 merkleRoot\n    );\n\n    event ChangeUnderlying(address indexed token, int256 underlying);\n\n    event Chop(\n        address indexed account,\n        address indexed token,\n        uint256 amount,\n        uint256 underlying\n    );\n\n    event Pick(\n        address indexed account,\n        address indexed token,\n        uint256 amount\n    );\n\n    function chop(\n        address unripeToken,\n        uint256 amount,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable nonReentrant returns (uint256 underlyingAmount) {\n        uint256 unripeSupply = IERC20(unripeToken).totalSupply();\n\n        amount = LibTransfer.burnToken(IBean(unripeToken), amount, msg.sender, fromMode);\n\n        underlyingAmount = _getPenalizedUnderlying(unripeToken, amount, unripeSupply);\n\n        LibUnripe.decrementUnderlying(unripeToken, underlyingAmount);\n\n        address underlyingToken = s.u[unripeToken].underlyingToken;\n\n        IERC20(underlyingToken).sendToken(underlyingAmount, msg.sender, toMode);\n\n        emit Chop(msg.sender, unripeToken, amount, underlyingAmount);\n    }\n\n    function pick(\n        address token,\n        uint256 amount,\n        bytes32[] memory proof,\n        LibTransfer.To mode\n    ) external payable nonReentrant {\n        bytes32 root = s.u[token].merkleRoot;\n        require(root != bytes32(0), \"UnripeClaim: invalid token\");\n        require(\n            !picked(msg.sender, token),\n            \"UnripeClaim: already picked\"\n        );\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));\n        require(\n            MerkleProof.verify(proof, root, leaf),\n            \"UnripeClaim: invalid proof\"\n        );\n        s.unripeClaimed[token][msg.sender] = true;\n\n        LibTransfer.sendToken(IERC20(token), amount, msg.sender, mode);\n\n        emit Pick(msg.sender, token, amount);\n    }\n\n    function picked(address account, address token)\n        public\n        view\n        returns (bool)\n    {\n        return s.unripeClaimed[token][account];\n    }\n\n    function getUnderlying(address unripeToken, uint256 amount)\n        public\n        view\n        returns (uint256 redeem)\n    {\n        return _getUnderlying(unripeToken, amount, IERC20(unripeToken).totalSupply());\n    }\n\n    function _getUnderlying(address unripeToken, uint256 amount, uint256 supply)\n        private\n        view\n        returns (uint256 redeem)\n    {\n        redeem = s.u[unripeToken].balanceOfUnderlying.mul(amount).div(\n            supply\n        );\n    }\n\n    function getPenalty(address unripeToken)\n        external\n        view\n        returns (uint256 penalty)\n    {\n        return getPenalizedUnderlying(unripeToken, DECIMALS);\n    }\n\n    function getPenalizedUnderlying(address unripeToken, uint256 amount)\n        public\n        view\n        returns (uint256 redeem)\n    {\n        return _getPenalizedUnderlying(unripeToken, amount, IERC20(unripeToken).totalSupply());\n    }\n\n    function _getPenalizedUnderlying(address unripeToken, uint256 amount, uint256 supply)\n        public\n        view\n        returns (uint256 redeem)\n    {\n        require(isUnripe(unripeToken), \"not vesting\");\n        uint256 sharesBeingRedeemed = getRecapPaidPercentAmount(amount);\n        redeem = _getUnderlying(unripeToken, sharesBeingRedeemed, supply);\n    }\n\n    function isUnripe(address unripeToken) public view returns (bool unripe) {\n        unripe = s.u[unripeToken].underlyingToken != address(0);\n    }\n\n    function balanceOfUnderlying(address unripeToken, address account)\n        external\n        view\n        returns (uint256 underlying)\n    {\n        return\n            getUnderlying(unripeToken, IERC20(unripeToken).balanceOf(account));\n    }\n\n    function balanceOfPenalizedUnderlying(address unripeToken, address account)\n        external\n        view\n        returns (uint256 underlying)\n    {\n        return\n            getPenalizedUnderlying(\n                unripeToken,\n                IERC20(unripeToken).balanceOf(account)\n            );\n    }\n\n    function getRecapFundedPercent(address unripeToken)\n        public\n        view\n        returns (uint256 percent)\n    {\n        if (unripeToken == C.UNRIPE_BEAN) {\n            return LibUnripe.percentBeansRecapped();\n        } else if (unripeToken == C.UNRIPE_LP) {\n            return LibUnripe.percentLPRecapped();\n        }\n        revert(\"not vesting\");\n    }\n\n    function getPercentPenalty(address unripeToken)\n        external\n        view\n        returns (uint256 penalty)\n    {\n        return getRecapPaidPercentAmount(getRecapFundedPercent(unripeToken));\n    }\n\n    function getRecapPaidPercent() external view returns (uint256 penalty) {\n        penalty = getRecapPaidPercentAmount(DECIMALS);\n    }\n\n    function getRecapPaidPercentAmount(uint256 amount)\n        private\n        view\n        returns (uint256 penalty)\n    {\n        return s.fertilizedIndex.mul(amount).div(s.unfertilizedIndex);\n    }\n\n    function getUnderlyingPerUnripeToken(address unripeToken)\n        external\n        view\n        returns (uint256 underlyingPerToken)\n    {\n        underlyingPerToken = s\n            .u[unripeToken]\n            .balanceOfUnderlying\n            .mul(DECIMALS)\n            .div(IERC20(unripeToken).totalSupply());\n    }\n\n    function getTotalUnderlying(address unripeToken)\n        external\n        view\n        returns (uint256 underlying)\n    {\n        return s.u[unripeToken].balanceOfUnderlying;\n    }\n\n    function addUnripeToken(\n        address unripeToken,\n        address underlyingToken,\n        bytes32 root\n    ) external payable nonReentrant {\n        LibDiamond.enforceIsOwnerOrContract();\n        s.u[unripeToken].underlyingToken = underlyingToken;\n        s.u[unripeToken].merkleRoot = root;\n        emit AddUnripeToken(unripeToken, underlyingToken, root);\n    }\n\n    function getUnderlyingToken(address unripeToken)\n        external\n        view\n        returns (address underlyingToken)\n    {\n        return s.u[unripeToken].underlyingToken;\n    }\n}"
    }
  ]
}