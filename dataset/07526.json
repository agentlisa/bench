{
  "Title": "[H-05] Attacker can manipulate low TVL Uniswap V3 pool to borrow and swap to make Lending Pool in loss",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L176>\n\nIn Paraspace protocol, any Uniswap V3 position that are consist of ERC20 tokens that Paraspace support can be used as collateral to borrow funds from Paraspace pool. The value of the Uniswap V3 position will be sum of value of ERC20 tokens in it.\n\n```solidity\nfunction getTokenPrice(uint256 tokenId) public view returns (uint256) {\n    UinswapV3PositionData memory positionData = getOnchainPositionData(\n        tokenId\n    );\n\n    PairOracleData memory oracleData = _getOracleData(positionData);\n\n    (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n        .getAmountsForLiquidity(\n            oracleData.sqrtPriceX96,\n            TickMath.getSqrtRatioAtTick(positionData.tickLower),\n            TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n            positionData.liquidity\n        );\n\n    (\n        uint256 feeAmount0,\n        uint256 feeAmount1\n    ) = getLpFeeAmountFromPositionData(positionData);\n\n    return // @audit can be easily manipulated with low TVL pool\n        (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n            10**oracleData.token0Decimal) +\n        (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n            10**oracleData.token1Decimal);\n}\n```\n\nHowever, Uniswap V3 can have multiple pools for the **same pairs** of ERC20 tokens with **different fee** params. A fews has most the liquidity, while other pools have extremely little TVL or even not created yet. Attackers can abuse it, create low TVL pool where liquidity in this pool mostly (or fully) belong to attackerâ€™s position, deposit this position as collateral and borrow token in Paraspace pool, swap to make the original position reduce the original value and cause Paraspace pool in loss.\n\n### Proof of Concept\n\nConsider the scenario where WETH and DAI are supported as collateral in Paraspace protocol.\n\n1.  Alice (attacker) create a new WETH/DAI pool in Uniswap V3 and add liquidity with the following amount<br>\n    `1e18 wei WETH - 1e6 wei DAI = 1 WETH - 1e-12 DAI ~= 1 ETH`<br>\n    Let's just assume Alice position has price range from `[MIN_TICK, MAX_TICK]` so the math can be approximately like Uniswap V2 - constant product.<br>\n    Note that this pool only has liquidity from Alice.\n2. Alice deposit this position into Paraspace, value of this position is approximately `1 WETH` and Alice borrow maximum possible amount of USDC.\n3. Alice make swap in her WETH/DAI pool in Uniswap V3 to make the position become<br>\n    `1e6 wei WETH - 1e18 wei DAI = 1e-12 WETH - 1 DAI ~= 1 DAI`\n\nPlease note that the math I've done above is approximation based on Uniswap V2 formula `x * y = k` because Alice provided liquidity from `MIN_TICK` to `MAX_TICK`.<br>\nFor more information about Uniswap V3 formula, please check their whitepaper here: <https://uniswap.org/whitepaper-v3.pdf>.\n\n### Recommended Mitigation Steps\n\nConsider adding whitelist, only allowing pool with enough TVL to be collateral in Paraspace protocol.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1376406262):** \n> Overinflated severity\n\n**[minhquanym (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1400899415):**\n > Hi @LSDan,\n> Maybe there is a misunderstanding here. I believed I gave enough proof to make it a High issue and protocol can be at loss.<br>\n> You can think of it as using Uniswap V3 pool as a price Oracle. However, it did not even use TWA price but spot price and pool with low liquidity is really easy to be manipulated. We all can see many examples about Price manipulation attacks recently and they had a common cause that price can be changed in one block.<br>\n> About the Uniswap V3 pool with low liquidity, you can check out this one https://etherscan.io/address/0xbb256c2F1B677e27118b0345FD2b3894D2E6D487.<br>\n> This is a USDC-USDT pool with only `$8k` in it.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1403968688):**\n > This is not true because Alice's pool will be immediately arbed each time she attempts a price manipulation. Accordingly, this issue only exists when a pair has very low liquidity on UniV3 and no liquidity elsewhere. I would have accepted this as a QA, but it does not fall into the realm of a high risk issue.\n> \n> I'm open to accepting this as a medium if you can give me a more concrete scenario where the value that Alice is extracting from the protocol through this attack is sustainable and significant enough to exceed the gas price of creating a new UniV3 pool.\n\n**[minhquanym (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1404042265):**\n > @LSDan, Please correct me if I'm wrong but I don't think Alice's pool can be arbed when the whole attack happens in 1 transaction. Because of that, I still believe that this is a High. For example, \n> 1. price before manipulation is `p1`\n> 2. flash loan and swap to change the price to `p2`\n> 3. add liquidity and borrow at price `p2`\n> 4. change the price back to `p1`\n> 5. repay the flash loan\n> \n> That's basically the idea. You can see price is back to `p1` at the end. \n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/407#issuecomment-1404876330):**\n > Ok yeah... I see what you're saying now. This could be used to drain the pool because the underlying asset price comes from a different oracle. So if Alice creates a pool with 100 USDC and 100 USDT, and drops 3mm USDC from a flash loan into it, the external oracle will value the LP at `$3mm`. High makes sense. Thanks for the additional clarity.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IUniswapV3OracleWrapper} from \"../interfaces/IUniswapV3OracleWrapper.sol\";\nimport {IPoolAddressesProvider} from \"../interfaces/IPoolAddressesProvider.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IUniswapV3Factory} from \"../dependencies/uniswap/IUniswapV3Factory.sol\";\nimport {IUniswapV3PoolState} from \"../dependencies/uniswap/IUniswapV3PoolState.sol\";\nimport {INonfungiblePositionManager} from \"../dependencies/uniswap/INonfungiblePositionManager.sol\";\nimport {LiquidityAmounts} from \"../dependencies/uniswap/LiquidityAmounts.sol\";\nimport {TickMath} from \"../dependencies/uniswap/libraries/TickMath.sol\";\nimport {SqrtLib} from \"../dependencies/math/SqrtLib.sol\";\nimport {FullMath} from \"../dependencies/uniswap/libraries/FullMath.sol\";\nimport {IERC20Detailed} from \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport {UinswapV3PositionData} from \"../interfaces/IUniswapV3PositionInfoProvider.sol\";\n\ncontract UniswapV3OracleWrapper is IUniswapV3OracleWrapper {\n    IUniswapV3Factory immutable UNISWAP_V3_FACTORY;\n    INonfungiblePositionManager immutable UNISWAP_V3_POSITION_MANAGER;\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n\n    constructor(\n        address _factory,\n        address _manager,\n        address _addressProvider\n    ) {\n        UNISWAP_V3_FACTORY = IUniswapV3Factory(_factory);\n        UNISWAP_V3_POSITION_MANAGER = INonfungiblePositionManager(_manager);\n        ADDRESSES_PROVIDER = IPoolAddressesProvider(_addressProvider);\n    }\n\n    struct FeeParams {\n        uint256 feeGrowthOutside0X128Lower;\n        uint256 feeGrowthOutside1X128Lower;\n        uint256 feeGrowthOutside0X128Upper;\n        uint256 feeGrowthOutside1X128Upper;\n    }\n\n    struct PairOracleData {\n        uint256 token0Price;\n        uint256 token1Price;\n        uint8 token0Decimal;\n        uint8 token1Decimal;\n        uint160 sqrtPriceX96;\n    }\n\n    /**\n     * @notice get onchain position data from uniswap for the specified tokenId.\n     */\n    function getOnchainPositionData(uint256 tokenId)\n        public\n        view\n        returns (UinswapV3PositionData memory)\n    {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 tokensOwed0,\n            uint256 tokensOwed1\n        ) = UNISWAP_V3_POSITION_MANAGER.positions(tokenId);\n\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(token0, token1, fee)\n        );\n        (uint160 currentPrice, int24 currentTick, , , , , ) = pool.slot0();\n\n        return\n            UinswapV3PositionData({\n                token0: token0,\n                token1: token1,\n                fee: fee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                currentTick: currentTick,\n                currentPrice: currentPrice,\n                liquidity: liquidity,\n                feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: feeGrowthInside1LastX128,\n                tokensOwed0: tokensOwed0,\n                tokensOwed1: tokensOwed1\n            });\n    }\n\n    /**\n     * @notice get onchain liquidity amount for the specified tokenId.\n     */\n    function getLiquidityAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLiquidityAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLiquidityAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public pure returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = LiquidityAmounts.getAmountsForLiquidity(\n            positionData.currentPrice,\n            TickMath.getSqrtRatioAtTick(positionData.tickLower),\n            TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n            positionData.liquidity\n        );\n    }\n\n    /**\n     * @notice get liquidity provider fee amount for the specified tokenId.\n     */\n    function getLpFeeAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLpFeeAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity provider fee amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLpFeeAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public view returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = _getPendingFeeAmounts(positionData);\n\n        token0Amount += positionData.tokensOwed0;\n        token1Amount += positionData.tokensOwed1;\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId.\n     */\n    function getTokenPrice(uint256 tokenId) public view returns (uint256) {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n\n        PairOracleData memory oracleData = _getOracleData(positionData);\n\n        (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n            .getAmountsForLiquidity(\n                oracleData.sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(positionData.tickLower),\n                TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n                positionData.liquidity\n            );\n\n        (\n            uint256 feeAmount0,\n            uint256 feeAmount1\n        ) = getLpFeeAmountFromPositionData(positionData);\n\n        return\n            (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n                10**oracleData.token0Decimal) +\n            (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n                10**oracleData.token1Decimal);\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId array.\n     */\n    function getTokensPrices(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory prices = new uint256[](tokenIds.length);\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            prices[index] = getTokenPrice(tokenIds[index]);\n        }\n\n        return prices;\n    }\n\n    /**\n     * @notice Returns the total price for the specified tokenId array.\n     */\n    function getTokensPricesSum(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 sum = 0;\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            sum += getTokenPrice(tokenIds[index]);\n        }\n\n        return sum;\n    }\n\n    function latestAnswer() external pure returns (int256) {\n        revert(\"unimplemented\");\n    }\n\n    function _getOracleData(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (PairOracleData memory)\n    {\n        PairOracleData memory oracleData;\n        IPriceOracleGetter oracle = IPriceOracleGetter(\n            ADDRESSES_PROVIDER.getPriceOracle()\n        );\n        oracleData.token0Price = oracle.getAssetPrice(positionData.token0);\n        oracleData.token1Price = oracle.getAssetPrice(positionData.token1);\n\n        oracleData.token0Decimal = IERC20Detailed(positionData.token0)\n            .decimals();\n        oracleData.token1Decimal = IERC20Detailed(positionData.token1)\n            .decimals();\n\n        // TODO using bit shifting for the 2^96\n        // positionData.sqrtPriceX96;\n\n        if (oracleData.token1Decimal == oracleData.token0Decimal) {\n            // multiply by 10^18 then divide by 10^9 to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    ((oracleData.token0Price * (10**18)) /\n                        (oracleData.token1Price))\n                ) * 2**96) / 1E9\n            );\n        } else if (oracleData.token1Decimal > oracleData.token0Decimal) {\n            // multiple by 10^(decimalB - decimalA) to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token1Decimal -\n                                oracleData.token0Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) / 1E9\n            );\n        } else {\n            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token0Decimal -\n                                oracleData.token1Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) /\n                    10 **\n                        (9 +\n                            oracleData.token0Decimal -\n                            oracleData.token1Decimal)\n            );\n        }\n\n        return oracleData;\n    }\n\n    function _getPendingFeeAmounts(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(\n                positionData.token0,\n                positionData.token1,\n                positionData.fee\n            )\n        );\n        FeeParams memory feeParams;\n\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Lower,\n            feeParams.feeGrowthOutside1X128Lower,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickLower);\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Upper,\n            feeParams.feeGrowthOutside1X128Upper,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickUpper);\n\n        uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n        uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n\n        unchecked {\n            // calculate fee growth below\n            uint256 feeGrowthBelow0X128;\n            uint256 feeGrowthBelow1X128;\n            if (positionData.currentTick >= positionData.tickLower) {\n                feeGrowthBelow0X128 = feeParams.feeGrowthOutside0X128Lower;\n                feeGrowthBelow1X128 = feeParams.feeGrowthOutside1X128Lower;\n            } else {\n                feeGrowthBelow0X128 =\n                    feeGrowthGlobal0X128 -\n                    feeParams.feeGrowthOutside0X128Lower;\n                feeGrowthBelow1X128 =\n                    feeGrowthGlobal1X128 -\n                    feeParams.feeGrowthOutside1X128Lower;\n            }\n\n            // calculate fee growth above\n            uint256 feeGrowthAbove0X128;\n            uint256 feeGrowthAbove1X128;\n            if (positionData.currentTick < positionData.tickUpper) {\n                feeGrowthAbove0X128 = feeParams.feeGrowthOutside0X128Upper;\n                feeGrowthAbove1X128 = feeParams.feeGrowthOutside1X128Upper;\n            } else {\n                feeGrowthAbove0X128 =\n                    feeGrowthGlobal0X128 -\n                    feeParams.feeGrowthOutside0X128Upper;\n                feeGrowthAbove1X128 =\n                    feeGrowthGlobal1X128 -\n                    feeParams.feeGrowthOutside1X128Upper;\n            }\n            uint256 feeGrowthInside0X128;\n            uint256 feeGrowthInside1X128;\n\n            feeGrowthInside0X128 =\n                feeGrowthGlobal0X128 -\n                feeGrowthBelow0X128 -\n                feeGrowthAbove0X128;\n            feeGrowthInside1X128 =\n                feeGrowthGlobal1X128 -\n                feeGrowthBelow1X128 -\n                feeGrowthAbove1X128;\n\n            token0Amount = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0X128 -\n                        positionData.feeGrowthInside0LastX128,\n                    positionData.liquidity,\n                    Q128\n                )\n            );\n\n            token1Amount = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1X128 -\n                        positionData.feeGrowthInside1LastX128,\n                    positionData.liquidity,\n                    Q128\n                )\n            );\n        }\n    }\n}"
    }
  ]
}