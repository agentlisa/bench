{
  "Title": "Inconsistent slot size for upgrades",
  "Content": "Throughout the whole codebase, several contracts are allowed to be upgradable in order to improve/extend the functionalities or to fix a vulnerability. To mitigate the possibility of having a storage collision, those contracts define an array at the bottom of the contract that its length added to the number of variables defined in the contract adds to a fix number, usually 50.\n\n\nHowever, there are contracts in which the sum is not consistent with the rest of the codebase. In particular:\n\n\n* The [`ScannerRegistryManaged` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryManaged.sol#L44) whose sum adds up to 45.\n* The [`StakeAwareUpgradeable` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/StakeAware.sol#L40) whose sum adds up to 5.\n* The [`AgentRegistryCore` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L83) whose sum adds up to 45.\n\n\nIn order to improve the code’s readability, prevent future storage collisions on contracts that may have less storage slots available, and to be consistent with the rest of the code, consider fixing all the respective places where the sum does not add up to a common fixed number. Furthermore, consider documenting as in-line comments all the variables that took one of those places as documentation for the `__gap` variable as an exercise to double corroborate its final length.\n\n\n***Update:** Fixed in [pull request 45](https://github.com/forta-protocol/forta-token/pull/45) and on [commit `4a49ba4bdc53702fe199d06d249a0e961ee8385b` in pull request 77](https://github.com/forta-protocol/forta-token/pull/77/commits/4a49ba4bdc53702fe199d06d249a0e961ee8385b). The team has [explicitly described](https://github.com/forta-protocol/forta-token/pull/77#issue-1141608847) the slot usages in those files and added upgradeability information in the `README.md` file to mitigate future problems.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/components/scanners/ScannerRegistryManaged.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"./ScannerRegistryCore.sol\";\n\nabstract contract ScannerRegistryManaged is ScannerRegistryCore {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(uint256 => EnumerableSet.AddressSet) private _managers;\n\n    event ManagerEnabled(uint256 indexed scannerId, address indexed manager, bool enabled);\n\n    modifier onlyManagerOf(uint256 scannerId) {\n        require(_managers[scannerId].contains(_msgSender()), \"ScannerRegistryManaged: Restricted to scanner owner\");\n        _;\n    }\n\n    /**\n     * @dev Managers\n     */\n    function isManager(uint256 scannerId, address manager) public view virtual returns (bool) {\n        return _managers[scannerId].contains(manager);\n    }\n\n    function getManagerCount(uint256 scannerId) public view virtual returns (uint256) {\n        return _managers[scannerId].length();\n    }\n\n    function getManagerAt(uint256 scannerId, uint256 index) public view virtual returns (address) {\n        return _managers[scannerId].at(index);\n    }\n\n    function setManager(uint256 scannerId, address manager, bool enable) public onlyOwnerOf(scannerId) {\n        if (enable) {\n            _managers[scannerId].add(manager);\n        } else {\n            _managers[scannerId].remove(manager);\n        }\n        emit ManagerEnabled(scannerId, manager, enable);\n    }\n\n    uint256[44] private __gap;\n}"
    },
    {
      "filename": "contracts/components/utils/StakeAware.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../staking/IStakeController.sol\";\nimport \"../staking/FortaStakingSubjectTypes.sol\";\nimport \"../Roles.sol\";\nimport \"./AccessManaged.sol\";\n\nabstract contract StakeAwareUpgradeable is AccessManagedUpgradeable {\n    IStakeController private _stakeController;\n\n    event StakeControllerUpdated(address indexed newstakeController);\n\n    function __StakeAwareUpgradeable_init(address stakeController) internal initializer {\n        _setStakeController(stakeController);\n    }\n\n    function _setStakeController(address stakeController) private {\n        require(stakeController != address(0), \"StakeAwareUpgradeable: stakeController cannot be address(0)\");\n        _stakeController = IStakeController(stakeController);\n        emit StakeControllerUpdated(stakeController);\n    }\n\n    function setStakeController(address stakeController) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setStakeController(stakeController);\n    }\n\n    function getStakeController() public view returns(address) {\n        return address(_stakeController);\n    }\n\n    function _isStakedOverMin(uint8 subjectType, uint256 subject) internal view returns(bool) {\n        return _stakeController.isStakedOverMin(subjectType, subject);\n    }\n\n    function _getMinStake(uint8 subjectType) internal view returns (uint256) {\n        return _stakeController.getMinStake(subjectType);\n    }\n\n    uint256[4] private __gap;\n}"
    },
    {
      "filename": "contracts/components/agents/AgentRegistryCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n\nimport \"../BaseComponentUpgradeable.sol\";\nimport \"../../tools/FrontRunningProtection.sol\";\n\nabstract contract AgentRegistryCore is\n    BaseComponentUpgradeable,\n    FrontRunningProtection,\n    ERC721Upgradeable\n{\n    event AgentCommitted(bytes32 indexed commit);\n    event AgentUpdated(uint256 indexed agentId, address indexed by, string metadata, uint256[] chainIds);\n\n    modifier onlyOwnerOf(uint256 agentId) {\n        require(_msgSender() == ownerOf(agentId), \"AgentRegistryCore: Restricted to agent owner\");\n        _;\n    }\n\n    modifier onlySorted(uint256[] memory array) {\n        require(array.length > 0, \"AgentRegistryCore: At least one chain id required\");\n        for (uint256 i = 1; i < array.length; ++i ) {\n            require(array[i] > array[i-1], \"AgentRegistryCore: Values must be sorted\");\n        }\n        _;\n    }\n\n    function prepareAgent(bytes32 commit) public {\n        _frontrunCommit(commit);\n        emit AgentCommitted(commit);\n    }\n\n    function createAgent(uint256 agentId, address owner, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, owner, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _mint(owner, agentId);\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    function isCreated(uint256 agentId) public view returns(bool) {\n        return _exists(agentId);\n    }\n\n    function updateAgent(uint256 agentId, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlyOwnerOf(agentId)\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    /**\n     * Hook: Agent metadata change (create/update)\n     */\n    function _beforeAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n    }\n\n    function _agentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        emit AgentUpdated(agentId, _msgSender(), newMetadata, newChainIds);\n    }\n\n    function _afterAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        _emitHook(abi.encodeWithSignature(\"hook_afterAgentUpdate(uint256)\", agentId));\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[45] private __gap;\n}"
    }
  ]
}