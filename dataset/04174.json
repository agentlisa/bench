{
  "Title": "[L09][Fixed] oToken symbols might not be unique",
  "Content": "An oToken symbol is generated by using the [intrinsic characteristics](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L108-L114) of the option in the [`_getNameAndSymbol` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Otoken.sol#L107) from the `Otoken` contract.\n\n\nNevertheless, the symbol may not be unique due to the lack of the collateral asset information in its string, leading to a confusing state where different oTokens are mixed and displayed as the same one to end-users or other projects. For instance, the following example shows the current symbol for one oToken but it does not reflect the collateral asset’s type used:\n\n\n\n```\ntokenSymbol (ex: oETHUSDC-05SEP20-200P)\n\n```\n\nConsider adding the collateral asset’s info into the tokenSymbol string.\n\n\n**Update:** *Fixed in [PR#297](https://github.com/opynfinance/GammaProtocol/pull/297).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Otoken.sol",
      "content": "/* SPDX-License-Identifier: UNLICENSED */\npragma solidity =0.6.10;\n\nimport {ERC20Initializable} from \"./packages/oz/upgradeability/ERC20Initializable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {Strings} from \"./packages/oz/Strings.sol\";\nimport {BokkyPooBahsDateTimeLibrary} from \"./packages/BokkyPooBahsDateTimeLibrary.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\n\n/**\n * @title Otoken\n * @author Opyn Team\n * @notice Otoken is the ERC20 token for an option\n * @dev The Otoken inherits ERC20Initializable because we need to use the init instead of constructor\n */\ncontract Otoken is ERC20Initializable {\n    using SafeMath for uint256;\n\n    /// @notice address of the AddressBook module\n    address public addressBook;\n\n    /// @notice asset that the option references\n    address public underlyingAsset;\n\n    /// @notice asset that the strike price is denominated in\n    address public strikeAsset;\n\n    /// @notice asset that is held as collateral against short/written options\n    address public collateralAsset;\n\n    /// @notice strike price with decimals = 8\n    uint256 public strikePrice;\n\n    /// @notice expiration timestamp of the option, represented as a unix timestamp\n    uint256 public expiryTimestamp;\n\n    /// @notice True if a put option, False if a call option\n    bool public isPut;\n\n    uint256 private constant STRIKE_PRICE_SCALE = 1e8;\n    uint256 private constant STRIKE_PRICE_DIGITS = 8;\n\n    /**\n     * @notice initialize the oToken\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 8\n     * @param _expiryTimestamp expiration timestamp of the option, represented as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     */\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTimestamp,\n        bool _isPut\n    ) external initializer {\n        addressBook = _addressBook;\n        underlyingAsset = _underlyingAsset;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n        strikePrice = _strikePrice;\n        expiryTimestamp = _expiryTimestamp;\n        isPut = _isPut;\n        (string memory tokenName, string memory tokenSymbol) = _getNameAndSymbol();\n        __ERC20_init_unchained(tokenName, tokenSymbol);\n        _setupDecimals(8);\n    }\n\n    /**\n     * @notice mint oToken for an account\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to mint token to\n     * @param amount amount to mint\n     */\n    function mintOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can mint Otokens\"\n        );\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice burn oToken from an account.\n     * @dev Controller only method where access control is taken care of by _beforeTokenTransfer hook\n     * @param account account to burn token from\n     * @param amount amount to burn\n     */\n    function burnOtoken(address account, uint256 amount) external {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getController(),\n            \"Otoken: Only Controller can burn Otokens\"\n        );\n        _burn(account, amount);\n    }\n\n    /**\n     * @notice generates the name and symbol for an option\n     * @dev this function uses a named return variable to avoid the stack-too-deep error\n     * @return tokenName (ex: ETHUSDC 05-September-2020 200 Put USDC Collateral)\n     * @return tokenSymbol (ex: oETHUSDC-05SEP20-200P)\n     */\n    function _getNameAndSymbol() internal view returns (string memory tokenName, string memory tokenSymbol) {\n        string memory underlying = ERC20Initializable(underlyingAsset).symbol();\n        string memory strike = ERC20Initializable(strikeAsset).symbol();\n        string memory collateral = ERC20Initializable(collateralAsset).symbol();\n        string memory displayStrikePrice = _getDisplayedStrikePrice(strikePrice);\n\n        // convert expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(expiryTimestamp);\n\n        // get option type string\n        (string memory typeSymbol, string memory typeFull) = _getOptionType(isPut);\n\n        //get option month string\n        (string memory monthSymbol, string memory monthFull) = _getMonth(month);\n\n        // concatenated name string: ETHUSDC 05-September-2020 200 Put USDC Collateral\n        tokenName = string(\n            abi.encodePacked(\n                underlying,\n                strike,\n                \" \",\n                _uintTo2Chars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                typeFull,\n                \" \",\n                collateral,\n                \" Collateral\"\n            )\n        );\n\n        // concatenated symbol string: oETHUSDC-05SEP20-200P\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"o\",\n                underlying,\n                strike,\n                \"-\",\n                _uintTo2Chars(day),\n                monthSymbol,\n                _uintTo2Chars(year),\n                \"-\",\n                displayStrikePrice,\n                typeSymbol\n            )\n        );\n    }\n\n    /**\n     * @dev convert strike price scaled by 1e8 to human readable number string\n     * @param _strikePrice strike price scaled by 1e8\n     * @return strike price string\n     */\n    function _getDisplayedStrikePrice(uint256 _strikePrice) internal pure returns (string memory) {\n        uint256 remainder = _strikePrice.mod(STRIKE_PRICE_SCALE);\n        uint256 quotient = _strikePrice.div(STRIKE_PRICE_SCALE);\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) return quotientStr;\n\n        uint256 trailingZeroes = 0;\n        while (remainder.mod(10) == 0) {\n            remainder = remainder / 10;\n            trailingZeroes += 1;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory tmpStr = Strings.toString(remainder);\n        tmpStr = _slice(tmpStr, 1, 1 + STRIKE_PRICE_DIGITS - trailingZeroes);\n\n        string memory completeStr = string(abi.encodePacked(quotientStr, \".\", tmpStr));\n        return completeStr;\n    }\n\n    /**\n     * @dev return a representation of a number using 2 characters, adds a leading 0 if one digit, uses two trailing digits if a 3 digit number\n     * @return 2 characters that corresponds to a number\n     */\n    function _uintTo2Chars(uint256 number) internal pure returns (string memory) {\n        if (number > 99) number = number % 100;\n        string memory str = Strings.toString(number);\n        if (number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n        return str;\n    }\n\n    /**\n     * @dev return string representation of option type\n     * @return shortString a 1 character representation of option type (P or C)\n     * @return longString a full length string of option type (Put or Call)\n     */\n    function _getOptionType(bool _isPut) internal pure returns (string memory shortString, string memory longString) {\n        if (_isPut) {\n            return (\"P\", \"Put\");\n        } else {\n            return (\"C\", \"Call\");\n        }\n    }\n\n    /**\n     * @dev cut string s into s[start:end]\n     * @param _s the string to cut\n     * @param _start the starting index\n     * @param _end the ending index (excluded in the substring)\n     */\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure returns (string memory) {\n        bytes memory a = new bytes(_end - _start);\n        for (uint256 i = 0; i < _end - _start; i++) {\n            a[i] = bytes(_s)[_start + i];\n        }\n        return string(a);\n    }\n\n    /**\n     * @dev return string representation of a month\n     * @return shortString a 3 character representation of a month (ex: SEP, DEC, etc)\n     * @return longString a full length string of a month (ex: September, December, etc)\n     */\n    function _getMonth(uint256 _month) internal pure returns (string memory shortString, string memory longString) {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}"
    }
  ]
}