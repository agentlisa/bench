{
  "Title": "Incorrect Batch Hashes Due to Memory Corruption",
  "Content": "When committing a new batch, the `ScrollChain` contract calls the [`_commitChunk`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#L394) function to compute a hash for each chunk in the batch. This hash includes the block contexts, as well as L1 and L2 transaction hashes that are part of this chunk. The `_commitChunk` function does this by getting the free memory pointer, storing everything it needs contiguously starting there, and then getting the free memory pointer again to [compute the keccak256 hash of this section of memory](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#L468).\n\n\n\n\n```\nÂ +----------------------+---------------------------+---------------------------+\n|    block contexts    |       L1 msg hashes       |       L2 msg hashes       |\n| (58 bytes per block) | (32 bytes per L1 message) | (32 bytes per L2 message) |\n+----------------------+---------------------------+---------------------------+\n^                                                                              ^ \nfree memory pointer (read from 0x40)                                     dataPtr\n\n```\n\n\nImportantly, the function relies on the free memory pointer pointing to the same memory location to be able to [fetch the initial location](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#L467) from which to start computing the hash. However, when [fetching the L1 message hashes](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#L426), the code does an external call to [`getCrossDomainMessage`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#LL507C63-L507C63) which stores its return value in memory. This causes the free memory pointer to be shifted by a word to the right for each L1 message being processed. This means that the chunk hashes are incomplete and the commitment would not include parts of the information needed as soon as a block contains L1 transactions.\n\n\nThe resulting batch would thus have an incorrect hash. The network would not be able to finalize when there are L1 transactions in a batch because the hash would not match with the proof based on the zkEVM circuits.\n\n\nConsider limiting the inline assembly usage to be less error-prone for memory corruption issues. Otherwise, make sure to keep track of the right pointer to begin the hashing. Further, ensure that these endpoints and any changes to them are fully end-to-end tested.\n\n\n***Update:** Resolved in [pull request #546](https://github.com/scroll-tech/scroll/pull/546) at commit [9606c61](https://github.com/scroll-tech/scroll/pull/546/commits/9606c61f5e70d46fae9e4024b574790bc14ff671).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/rollup/ScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {ChunkCodec} from \"../../libraries/codec/ChunkCodec.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, IScrollChain {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates the status of sequencer.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateSequencer(address indexed account, bool status);\n\n    /// @notice Emitted when the address of rollup verifier is updated.\n    /// @param oldVerifier The address of old rollup verifier.\n    /// @param newVerifier The address of new rollup verifier.\n    event UpdateVerifier(address oldVerifier, address newVerifier);\n\n    /// @notice Emitted when the value of `maxNumL2TxInChunk` is updated.\n    /// @param oldMaxNumL2TxInChunk The old value of `maxNumL2TxInChunk`.\n    /// @param newMaxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    event UpdateMaxNumL2TxInChunk(uint256 oldMaxNumL2TxInChunk, uint256 newMaxNumL2TxInChunk);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint256 public immutable layer2ChainId;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumL2TxInChunk;\n\n    /// @notice The address of L1MessageQueue.\n    address public messageQueue;\n\n    /// @notice The address of RollupVerifier.\n    address public verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice The latest finalized batch index.\n    uint256 public lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        require(isSequencer[msg.sender], \"caller not sequencer\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(uint256 _chainId) {\n        layer2ChainId = _chainId;\n    }\n\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumL2TxInChunk\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messageQueue = _messageQueue;\n        verifier = _verifier;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateVerifier(address(0), _verifier);\n        emit UpdateMaxNumL2TxInChunk(0, _maxNumL2TxInChunk);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    /// @dev Although `_withdrawRoot` is always zero, we add this parameter for the convenience of unit testing.\n    function importGenesisBatch(\n        bytes calldata _batchHeader,\n        bytes32 _stateRoot,\n        bytes32 _withdrawRoot\n    ) external {\n        // check genesis batch header length\n        require(_stateRoot != bytes32(0), \"zero state root\");\n\n        // check whether the genesis batch is imported\n        require(finalizedStateRoots[0] == bytes32(0), \"Genesis batch imported\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.version(memPtr) +\n                BatchHeaderV0Codec.batchIndex(memPtr) +\n                BatchHeaderV0Codec.l1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.totalL1MessagePopped(memPtr);\n            require(sum == 0, \"not all fields are zero\");\n        }\n        require(BatchHeaderV0Codec.dataHash(memPtr) != bytes32(0), \"zero data hash\");\n        require(BatchHeaderV0Codec.parentBatchHash(memPtr) == bytes32(0), \"nonzero parent batch hash\");\n\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n        withdrawRoots[0] = _withdrawRoot;\n\n        emit CommitBatch(_batchHash);\n        emit FinalizeBatch(_batchHash, _stateRoot, _withdrawRoot);\n    }\n\n    /// @inheritdoc IScrollChain\n    function commitBatch(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) external override OnlySequencer {\n        require(_version == 0, \"invalid version\");\n\n        // check whether the batch is empty\n        uint256 _chunksLength = _chunks.length;\n        require(_chunksLength > 0, \"batch is empty\");\n\n        // The overall memory layout in this function is organized as follows\n        // +---------------------+-------------------+------------------+\n        // | parent batch header | chunk data hashes | new batch header |\n        // +---------------------+-------------------+------------------+\n        // ^                     ^                   ^\n        // batchPtr              dataPtr             newBatchPtr (re-use var batchPtr)\n        //\n        // 1. We copy the parent batch header from calldata to memory starting at batchPtr\n        // 2. We store `_chunksLength` number of Keccak hashes starting at `dataPtr`. Each Keccak\n        //    hash corresponds to the data hash of a chunk. So we reserve the memory region from\n        //    `dataPtr` to `dataPtr + _chunkLength * 32` for the chunk data hashes.\n        // 3. The memory starting at `newBatchPtr` is used to store the new batch header and compute\n        //    the batch hash.\n\n        // the variable `batchPtr` will be reused later for the current batch\n        (uint256 batchPtr, bytes32 _parentBatchHash) = _loadBatchHeader(_parentBatchHeader);\n\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(batchPtr);\n        uint256 _totalL1MessagesPoppedOverall = BatchHeaderV0Codec.totalL1MessagePopped(batchPtr);\n        require(committedBatches[_batchIndex] == _parentBatchHash, \"incorrect parent batch hash\");\n        require(committedBatches[_batchIndex + 1] == 0, \"batch already committed\");\n\n        // load `dataPtr` and reserve the memory region for chunk data hashes\n        uint256 dataPtr;\n        assembly {\n            dataPtr := mload(0x40)\n            mstore(0x40, add(dataPtr, mul(_chunksLength, 32)))\n        }\n\n        // compute the data hash for each chunk\n        uint256 _totalL1MessagesPoppedInBatch;\n        for (uint256 i = 0; i < _chunksLength; i++) {\n            uint256 _totalNumL1MessagesInChunk = _commitChunk(\n                dataPtr,\n                _chunks[i],\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            unchecked {\n                _totalL1MessagesPoppedInBatch += _totalNumL1MessagesInChunk;\n                _totalL1MessagesPoppedOverall += _totalNumL1MessagesInChunk;\n                dataPtr += 32;\n            }\n        }\n\n        // check the length of bitmap\n        unchecked {\n            require(\n                ((_totalL1MessagesPoppedInBatch + 255) / 256) * 32 == _skippedL1MessageBitmap.length,\n                \"wrong bitmap length\"\n            );\n        }\n\n        // compute the data hash for current batch\n        bytes32 _dataHash;\n        assembly {\n            let dataLen := mul(_chunksLength, 0x20)\n            _dataHash := keccak256(sub(dataPtr, dataLen), dataLen)\n\n            batchPtr := mload(0x40) // reset batchPtr\n            _batchIndex := add(_batchIndex, 1) // increase batch index\n        }\n\n        // store entries, the order matters\n        BatchHeaderV0Codec.storeVersion(batchPtr, _version);\n        BatchHeaderV0Codec.storeBatchIndex(batchPtr, _batchIndex);\n        BatchHeaderV0Codec.storeL1MessagePopped(batchPtr, _totalL1MessagesPoppedInBatch);\n        BatchHeaderV0Codec.storeTotalL1MessagePopped(batchPtr, _totalL1MessagesPoppedOverall);\n        BatchHeaderV0Codec.storeDataHash(batchPtr, _dataHash);\n        BatchHeaderV0Codec.storeParentBatchHash(batchPtr, _parentBatchHash);\n        BatchHeaderV0Codec.storeSkippedBitmap(batchPtr, _skippedL1MessageBitmap);\n\n        // compute batch hash\n        bytes32 _batchHash = BatchHeaderV0Codec.computeBatchHash(batchPtr, 89 + _skippedL1MessageBitmap.length);\n\n        committedBatches[_batchIndex] = _batchHash;\n        emit CommitBatch(_batchHash);\n    }\n\n    /// @inheritdoc IScrollChain\n    function revertBatch(bytes calldata _batchHeader, uint256 _count) external onlyOwner {\n        require(_count > 0, \"count must be nonzero\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check batch hash\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // check finalization\n        require(_batchIndex > lastFinalizedBatchIndex, \"can only revert unfinalized batch\");\n\n        while (_count > 0) {\n            committedBatches[_batchIndex] = bytes32(0);\n            unchecked {\n                _batchIndex += 1;\n                _count -= 1;\n            }\n\n            emit RevertBatch(_batchHash);\n\n            _batchHash = committedBatches[_batchIndex];\n            if (_batchHash == bytes32(0)) break;\n        }\n    }\n\n    /// @inheritdoc IScrollChain\n    function finalizeBatchWithProof(\n        bytes calldata _batchHeader,\n        bytes32 _prevStateRoot,\n        bytes32 _postStateRoot,\n        bytes32 _withdrawRoot,\n        bytes calldata _aggrProof\n    ) external override OnlySequencer {\n        require(_prevStateRoot != bytes32(0), \"previous state root is zero\");\n        require(_postStateRoot != bytes32(0), \"new state root is zero\");\n\n        // compute batch hash and verify\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        bytes32 _dataHash = BatchHeaderV0Codec.dataHash(memPtr);\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // verify previous state root.\n        require(finalizedStateRoots[_batchIndex - 1] == _prevStateRoot, \"incorrect previous state root\");\n\n        // avoid duplicated verification\n        require(finalizedStateRoots[_batchIndex] == bytes32(0), \"batch already verified\");\n\n        // compute public input hash\n        bytes32 _publicInputHash = keccak256(abi.encode(_prevStateRoot, _postStateRoot, _withdrawRoot, _dataHash));\n\n        // verify batch\n        IRollupVerifier(verifier).verifyAggregateProof(_aggrProof, _publicInputHash);\n\n        // check and update lastFinalizedBatchIndex\n        unchecked {\n            require(lastFinalizedBatchIndex + 1 == _batchIndex, \"incorrect batch index\");\n            lastFinalizedBatchIndex = _batchIndex;\n        }\n\n        // record state root and withdraw root\n        finalizedStateRoots[_batchIndex] = _postStateRoot;\n        withdrawRoots[_batchIndex] = _withdrawRoot;\n\n        // Pop finalized and non-skipped message from L1MessageQueue.\n        uint256 _l1MessagePopped = BatchHeaderV0Codec.l1MessagePopped(memPtr);\n        if (_l1MessagePopped > 0) {\n            IL1MessageQueue _queue = IL1MessageQueue(messageQueue);\n\n            unchecked {\n                uint256 _startIndex = BatchHeaderV0Codec.totalL1MessagePopped(memPtr) - _l1MessagePopped;\n\n                for (uint256 i = 0; i < _l1MessagePopped; i += 256) {\n                    uint256 _count = 256;\n                    if (_l1MessagePopped - i < _count) {\n                        _count = _l1MessagePopped - i;\n                    }\n                    uint256 _skippedBitmap = BatchHeaderV0Codec.skippedBitmap(memPtr, i / 256);\n\n                    _queue.popCrossDomainMessage(_startIndex, _count, _skippedBitmap);\n\n                    _startIndex += 256;\n                }\n            }\n        }\n\n        emit FinalizeBatch(_batchHash, _postStateRoot, _withdrawRoot);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the status of sequencer.\n    /// @dev This function can only called by contract owner.\n    /// @param _account The address of account to update.\n    /// @param _status The status of the account to update.\n    function updateSequencer(address _account, bool _status) external onlyOwner {\n        isSequencer[_account] = _status;\n\n        emit UpdateSequencer(_account, _status);\n    }\n\n    /// @notice Update the address verifier contract.\n    /// @param _newVerifier The address of new verifier contract.\n    function updateVerifier(address _newVerifier) external onlyOwner {\n        address _oldVerifier = verifier;\n        verifier = _newVerifier;\n\n        emit UpdateVerifier(_oldVerifier, _newVerifier);\n    }\n\n    /// @notice Update the value of `maxNumL2TxInChunk`.\n    /// @param _maxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    function updateMaxNumL2TxInChunk(uint256 _maxNumL2TxInChunk) external onlyOwner {\n        uint256 _oldMaxNumL2TxInChunk = maxNumL2TxInChunk;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateMaxNumL2TxInChunk(_oldMaxNumL2TxInChunk, _maxNumL2TxInChunk);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @return memPtr The start memory offset of loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    function _loadBatchHeader(bytes calldata _batchHeader) internal pure returns (uint256 memPtr, bytes32 _batchHash) {\n        // load to memory\n        uint256 _length;\n        (memPtr, _length) = BatchHeaderV0Codec.loadAndValidate(_batchHeader);\n\n        // compute batch hash\n        _batchHash = BatchHeaderV0Codec.computeBatchHash(memPtr, _length);\n    }\n\n    /// @dev Internal function to commit a chunk.\n    /// @param memPtr The start memory offset to store list of `dataHash`.\n    /// @param _chunk The encoded chunk to commit.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _totalNumL1MessagesInChunk The total number of L1 message popped in current chunk\n    function _commitChunk(\n        uint256 memPtr,\n        bytes memory _chunk,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256 _totalNumL1MessagesInChunk) {\n        uint256 chunkPtr;\n        uint256 dataPtr;\n        uint256 blockPtr;\n\n        assembly {\n            dataPtr := mload(0x40)\n            chunkPtr := add(_chunk, 0x20) // skip chunkLength\n            blockPtr := add(chunkPtr, 1) // skip numBlocks\n        }\n\n        uint256 _numBlocks = ChunkCodec.validateChunkLength(chunkPtr, _chunk.length);\n\n        // concatenate block contexts\n        for (uint256 i = 0; i < _numBlocks; i++) {\n            dataPtr = ChunkCodec.copyBlockContext(chunkPtr, dataPtr, i);\n        }\n\n        // concatenate tx hashes\n        uint256 l2TxPtr = ChunkCodec.l2TxPtr(chunkPtr, _numBlocks);\n\n        // avoid stack too deep on forge coverage\n        uint256 _totalTransactionsInChunk;\n        while (_numBlocks > 0) {\n            // concatenate l1 message hashes\n            uint256 _numL1MessagesInBlock = ChunkCodec.numL1Messages(blockPtr);\n            dataPtr = _loadL1MessageHashes(\n                dataPtr,\n                _numL1MessagesInBlock,\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            // concatenate l2 transaction hashes\n            uint256 _numTransactionsInBlock = ChunkCodec.numTransactions(blockPtr);\n            for (uint256 j = _numL1MessagesInBlock; j < _numTransactionsInBlock; j++) {\n                bytes32 txHash;\n                (txHash, l2TxPtr) = ChunkCodec.loadL2TxHash(l2TxPtr);\n                assembly {\n                    mstore(dataPtr, txHash)\n                    dataPtr := add(dataPtr, 0x20)\n                }\n            }\n\n            unchecked {\n                _totalTransactionsInChunk += _numTransactionsInBlock;\n                _totalNumL1MessagesInChunk += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedInBatch += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedOverall += _numL1MessagesInBlock;\n\n                _numBlocks -= 1;\n                blockPtr += ChunkCodec.BLOCK_CONTEXT_LENGTH;\n            }\n        }\n\n        // check the number of L2 transactions in the chunk\n        require(\n            _totalTransactionsInChunk - _totalNumL1MessagesInChunk <= maxNumL2TxInChunk,\n            \"too many L2 txs in one chunk\"\n        );\n\n        // check chunk has correct length\n        require(l2TxPtr - chunkPtr == _chunk.length, \"incomplete l2 transaction data\");\n\n        // compute data hash and store to memory\n        assembly {\n            let startPtr := mload(0x40)\n            let dataHash := keccak256(startPtr, sub(dataPtr, startPtr))\n\n            mstore(memPtr, dataHash)\n        }\n\n        return _totalNumL1MessagesInChunk;\n    }\n\n    /// @dev Internal function to load L1 message hashes from the message queue.\n    /// @param _ptr The memory offset to store the transaction hash.\n    /// @param _numL1Messages The number of L1 messages to load.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return uint256 The new memory offset after loading.\n    function _loadL1MessageHashes(\n        uint256 _ptr,\n        uint256 _numL1Messages,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256) {\n        if (_numL1Messages == 0) return _ptr;\n        IL1MessageQueue _messageQueue = IL1MessageQueue(messageQueue);\n\n        unchecked {\n            uint256 _bitmap;\n            for (uint256 i = 0; i < _numL1Messages; i++) {\n                uint256 quo = _totalL1MessagesPoppedInBatch >> 8;\n                uint256 rem = _totalL1MessagesPoppedInBatch & 0xff;\n\n                // load bitmap every 256 bits\n                if (i == 0 || rem == 0) {\n                    assembly {\n                        _bitmap := calldataload(add(_skippedL1MessageBitmap.offset, mul(0x20, quo)))\n                    }\n                }\n                if (((_bitmap >> rem) & 1) == 0) {\n                    // message not skipped\n                    bytes32 _hash = _messageQueue.getCrossDomainMessage(_totalL1MessagesPoppedOverall);\n                    assembly {\n                        mstore(_ptr, _hash)\n                        _ptr := add(_ptr, 0x20)\n                    }\n                }\n\n                _totalL1MessagesPoppedInBatch += 1;\n                _totalL1MessagesPoppedOverall += 1;\n            }\n        }\n\n        return _ptr;\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/ScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {ChunkCodec} from \"../../libraries/codec/ChunkCodec.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, IScrollChain {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates the status of sequencer.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateSequencer(address indexed account, bool status);\n\n    /// @notice Emitted when the address of rollup verifier is updated.\n    /// @param oldVerifier The address of old rollup verifier.\n    /// @param newVerifier The address of new rollup verifier.\n    event UpdateVerifier(address oldVerifier, address newVerifier);\n\n    /// @notice Emitted when the value of `maxNumL2TxInChunk` is updated.\n    /// @param oldMaxNumL2TxInChunk The old value of `maxNumL2TxInChunk`.\n    /// @param newMaxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    event UpdateMaxNumL2TxInChunk(uint256 oldMaxNumL2TxInChunk, uint256 newMaxNumL2TxInChunk);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint256 public immutable layer2ChainId;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumL2TxInChunk;\n\n    /// @notice The address of L1MessageQueue.\n    address public messageQueue;\n\n    /// @notice The address of RollupVerifier.\n    address public verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice The latest finalized batch index.\n    uint256 public lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        require(isSequencer[msg.sender], \"caller not sequencer\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(uint256 _chainId) {\n        layer2ChainId = _chainId;\n    }\n\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumL2TxInChunk\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messageQueue = _messageQueue;\n        verifier = _verifier;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateVerifier(address(0), _verifier);\n        emit UpdateMaxNumL2TxInChunk(0, _maxNumL2TxInChunk);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    /// @dev Although `_withdrawRoot` is always zero, we add this parameter for the convenience of unit testing.\n    function importGenesisBatch(\n        bytes calldata _batchHeader,\n        bytes32 _stateRoot,\n        bytes32 _withdrawRoot\n    ) external {\n        // check genesis batch header length\n        require(_stateRoot != bytes32(0), \"zero state root\");\n\n        // check whether the genesis batch is imported\n        require(finalizedStateRoots[0] == bytes32(0), \"Genesis batch imported\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.version(memPtr) +\n                BatchHeaderV0Codec.batchIndex(memPtr) +\n                BatchHeaderV0Codec.l1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.totalL1MessagePopped(memPtr);\n            require(sum == 0, \"not all fields are zero\");\n        }\n        require(BatchHeaderV0Codec.dataHash(memPtr) != bytes32(0), \"zero data hash\");\n        require(BatchHeaderV0Codec.parentBatchHash(memPtr) == bytes32(0), \"nonzero parent batch hash\");\n\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n        withdrawRoots[0] = _withdrawRoot;\n\n        emit CommitBatch(_batchHash);\n        emit FinalizeBatch(_batchHash, _stateRoot, _withdrawRoot);\n    }\n\n    /// @inheritdoc IScrollChain\n    function commitBatch(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) external override OnlySequencer {\n        require(_version == 0, \"invalid version\");\n\n        // check whether the batch is empty\n        uint256 _chunksLength = _chunks.length;\n        require(_chunksLength > 0, \"batch is empty\");\n\n        // The overall memory layout in this function is organized as follows\n        // +---------------------+-------------------+------------------+\n        // | parent batch header | chunk data hashes | new batch header |\n        // +---------------------+-------------------+------------------+\n        // ^                     ^                   ^\n        // batchPtr              dataPtr             newBatchPtr (re-use var batchPtr)\n        //\n        // 1. We copy the parent batch header from calldata to memory starting at batchPtr\n        // 2. We store `_chunksLength` number of Keccak hashes starting at `dataPtr`. Each Keccak\n        //    hash corresponds to the data hash of a chunk. So we reserve the memory region from\n        //    `dataPtr` to `dataPtr + _chunkLength * 32` for the chunk data hashes.\n        // 3. The memory starting at `newBatchPtr` is used to store the new batch header and compute\n        //    the batch hash.\n\n        // the variable `batchPtr` will be reused later for the current batch\n        (uint256 batchPtr, bytes32 _parentBatchHash) = _loadBatchHeader(_parentBatchHeader);\n\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(batchPtr);\n        uint256 _totalL1MessagesPoppedOverall = BatchHeaderV0Codec.totalL1MessagePopped(batchPtr);\n        require(committedBatches[_batchIndex] == _parentBatchHash, \"incorrect parent batch hash\");\n        require(committedBatches[_batchIndex + 1] == 0, \"batch already committed\");\n\n        // load `dataPtr` and reserve the memory region for chunk data hashes\n        uint256 dataPtr;\n        assembly {\n            dataPtr := mload(0x40)\n            mstore(0x40, add(dataPtr, mul(_chunksLength, 32)))\n        }\n\n        // compute the data hash for each chunk\n        uint256 _totalL1MessagesPoppedInBatch;\n        for (uint256 i = 0; i < _chunksLength; i++) {\n            uint256 _totalNumL1MessagesInChunk = _commitChunk(\n                dataPtr,\n                _chunks[i],\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            unchecked {\n                _totalL1MessagesPoppedInBatch += _totalNumL1MessagesInChunk;\n                _totalL1MessagesPoppedOverall += _totalNumL1MessagesInChunk;\n                dataPtr += 32;\n            }\n        }\n\n        // check the length of bitmap\n        unchecked {\n            require(\n                ((_totalL1MessagesPoppedInBatch + 255) / 256) * 32 == _skippedL1MessageBitmap.length,\n                \"wrong bitmap length\"\n            );\n        }\n\n        // compute the data hash for current batch\n        bytes32 _dataHash;\n        assembly {\n            let dataLen := mul(_chunksLength, 0x20)\n            _dataHash := keccak256(sub(dataPtr, dataLen), dataLen)\n\n            batchPtr := mload(0x40) // reset batchPtr\n            _batchIndex := add(_batchIndex, 1) // increase batch index\n        }\n\n        // store entries, the order matters\n        BatchHeaderV0Codec.storeVersion(batchPtr, _version);\n        BatchHeaderV0Codec.storeBatchIndex(batchPtr, _batchIndex);\n        BatchHeaderV0Codec.storeL1MessagePopped(batchPtr, _totalL1MessagesPoppedInBatch);\n        BatchHeaderV0Codec.storeTotalL1MessagePopped(batchPtr, _totalL1MessagesPoppedOverall);\n        BatchHeaderV0Codec.storeDataHash(batchPtr, _dataHash);\n        BatchHeaderV0Codec.storeParentBatchHash(batchPtr, _parentBatchHash);\n        BatchHeaderV0Codec.storeSkippedBitmap(batchPtr, _skippedL1MessageBitmap);\n\n        // compute batch hash\n        bytes32 _batchHash = BatchHeaderV0Codec.computeBatchHash(batchPtr, 89 + _skippedL1MessageBitmap.length);\n\n        committedBatches[_batchIndex] = _batchHash;\n        emit CommitBatch(_batchHash);\n    }\n\n    /// @inheritdoc IScrollChain\n    function revertBatch(bytes calldata _batchHeader, uint256 _count) external onlyOwner {\n        require(_count > 0, \"count must be nonzero\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check batch hash\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // check finalization\n        require(_batchIndex > lastFinalizedBatchIndex, \"can only revert unfinalized batch\");\n\n        while (_count > 0) {\n            committedBatches[_batchIndex] = bytes32(0);\n            unchecked {\n                _batchIndex += 1;\n                _count -= 1;\n            }\n\n            emit RevertBatch(_batchHash);\n\n            _batchHash = committedBatches[_batchIndex];\n            if (_batchHash == bytes32(0)) break;\n        }\n    }\n\n    /// @inheritdoc IScrollChain\n    function finalizeBatchWithProof(\n        bytes calldata _batchHeader,\n        bytes32 _prevStateRoot,\n        bytes32 _postStateRoot,\n        bytes32 _withdrawRoot,\n        bytes calldata _aggrProof\n    ) external override OnlySequencer {\n        require(_prevStateRoot != bytes32(0), \"previous state root is zero\");\n        require(_postStateRoot != bytes32(0), \"new state root is zero\");\n\n        // compute batch hash and verify\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        bytes32 _dataHash = BatchHeaderV0Codec.dataHash(memPtr);\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // verify previous state root.\n        require(finalizedStateRoots[_batchIndex - 1] == _prevStateRoot, \"incorrect previous state root\");\n\n        // avoid duplicated verification\n        require(finalizedStateRoots[_batchIndex] == bytes32(0), \"batch already verified\");\n\n        // compute public input hash\n        bytes32 _publicInputHash = keccak256(abi.encode(_prevStateRoot, _postStateRoot, _withdrawRoot, _dataHash));\n\n        // verify batch\n        IRollupVerifier(verifier).verifyAggregateProof(_aggrProof, _publicInputHash);\n\n        // check and update lastFinalizedBatchIndex\n        unchecked {\n            require(lastFinalizedBatchIndex + 1 == _batchIndex, \"incorrect batch index\");\n            lastFinalizedBatchIndex = _batchIndex;\n        }\n\n        // record state root and withdraw root\n        finalizedStateRoots[_batchIndex] = _postStateRoo"
    }
  ]
}