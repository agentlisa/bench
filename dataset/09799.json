{
  "Title": "[M-02] The `pay()` function can still be DOSed",
  "Content": "_Submitted by IllIllI_\n\nFrom the prior contest:\n\n> in the pay() function users repay their debt and in line 364:<br>\n> <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L364><br>\n> it decreases their debt.\n>\n> lets say a user wants to repay all his debt, he calls the pay() function with his full debt.<br>\n> an attacker can see it and frontrun to repay a single token for his debt (since it's likely the token uses 18 decimals, a single token is worth almost nothing)<br>\n> and since your solidity version is above 0.8.0 the line:<br>\n> due.debt -= assetsIn\\[i]; will revert due to underflow\n>\n> The attacker can keep doing it everytime the user is going to pay and since 1 token is baisicly 0\\$ (18 decimals) the attacker doesn't lose real money\n\n[code-423n4/2022-01-timeswap-findings#86 (comment)](https://github.com/code-423n4/2022-01-timeswap-findings/issues/86#issue-1095233776)\n\nThe sponsor said this about the fix:\n\n> The convenience contract will implement how much asset to pay in.\n\n[code-423n4/2022-01-timeswap-findings#86 (comment)](https://github.com/code-423n4/2022-01-timeswap-findings/issues/86#issuecomment-1014760269)\n\nThe `pay()` function however is still DOSable. Having the `Convenience` contract contain a workaround means the `Convenience` contract is no longer a convenience but a requirement.\n\n```solidity\n            due.debt -= param.assetsIn[i];\n```\n\n[TimeswapPair.sol#L485](https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L485)\n\n### Proof of Concept\n\nFrom the prior contest:\n\n> A DoS on every user that repay his full debt (or enough that the difference between his total debt to what he pays his negligible)\n\n[code-423n4/2022-01-timeswap-findings#86](https://github.com/code-423n4/2022-01-timeswap-findings/issues/86)\n\n### Recommended Mitigation Steps\n\nMove the DOS protection to `TimeswapPair.pay()`\n\n**[amateur-dev (Timeswap) confirmed](https://github.com/code-423n4/2022-03-timeswap-findings/issues/11)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/11#issuecomment-1086576722):**\n > I believe this is a potential security risk and `medium` risk is appropriate. It is important to ensure protocol availability cannot be negatively impacted by nefarious actors.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-timeswap",
  "Code": [
    {
      "filename": "Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from './interfaces/IPair.sol';\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {MintMath} from './libraries/MintMath.sol';\nimport {BurnMath} from './libraries/BurnMath.sol';\nimport {LendMath} from './libraries/LendMath.sol';\nimport {WithdrawMath} from './libraries/WithdrawMath.sol';\nimport {BorrowMath} from './libraries/BorrowMath.sol';\nimport {PayMath} from './libraries/PayMath.sol';\nimport {SafeTransfer} from './libraries/SafeTransfer.sol';\nimport {Array} from './libraries/Array.sol';\nimport {Callback} from './libraries/Callback.sol';\nimport {BlockNumber} from './libraries/BlockNumber.sol';\n\n/// @title Timeswap Pair\n/// @author Timeswap Labs\n/// @notice It is recommnded to use Timeswap Convenience to interact with this contract.\n/// @notice All error messages are coded and can be found in the documentation.\ncontract TimeswapPair is IPair {\n    using SafeTransfer for IERC20;\n    using Array for Due[];\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc IPair\n    IFactory public immutable override factory;\n    /// @inheritdoc IPair\n    IERC20 public immutable override asset;\n    /// @inheritdoc IPair\n    IERC20 public immutable override collateral;\n    /// @inheritdoc IPair\n    uint16 public immutable override fee;\n    /// @inheritdoc IPair\n    uint16 public immutable override protocolFee;\n\n    /// @dev Stores the individual states of each Pool.\n    mapping(uint256 => Pool) private pools;\n\n    /// @dev Stores the access state for reentrancy guard.\n    uint256 private locked;\n\n    /* ===== VIEW =====*/\n\n    /// @inheritdoc IPair\n    function constantProduct(uint256 maturity)\n        external\n        view\n        override\n        returns (\n            uint112 x,\n            uint112 y,\n            uint112 z\n        )\n    {\n        State memory state = pools[maturity].state;\n        return (state.x, state.y, state.z);\n    }\n\n    /// @inheritdoc IPair\n    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {\n        return pools[maturity].state.reserves;\n    }\n\n    /// @inheritdoc IPair\n    function totalLiquidity(uint256 maturity) external view override returns (uint256) {\n        return pools[maturity].state.totalLiquidity;\n    }\n\n    /// @inheritdoc IPair\n    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].liquidities[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalClaims(uint256 maturity) external view override returns (Claims memory) {\n        return pools[maturity].state.totalClaims;\n    }\n\n    /// @inheritdoc IPair\n    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {\n        return pools[maturity].claims[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {\n        return pools[maturity].state.totalDebtCreated;\n    }\n\n    /// @inheritdoc IPair\n    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {\n        return pools[maturity].dues[owner][id];\n    }\n\n    /* ===== INIT ===== */\n\n    /// @dev Initializes the Pair contract.\n    /// @dev Called by the Timeswap factory contract.\n    /// @param _asset The address of the ERC20 being lent and borrowed.\n    /// @param _collateral The address of the ERC20 as the collateral.\n    /// @param _fee The chosen fee rate.\n    /// @param _protocolFee The chosen protocol fee rate.\n    constructor(\n        IERC20 _asset,\n        IERC20 _collateral,\n        uint16 _fee,\n        uint16 _protocolFee\n    ) {\n        factory = IFactory(msg.sender);\n        asset = _asset;\n        collateral = _collateral;\n        fee = _fee;\n        protocolFee = _protocolFee;\n    }\n\n    /* ===== MODIFIER ===== */\n\n    /// @dev The modifier for reentrancy guard.\n    modifier lock() {\n        require(locked == 0, 'E211');\n        locked = 1;\n        _;\n        locked = 0;\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc IPair\n    function mint(\n        uint256 maturity,\n        address liquidityTo,\n        address dueTo,\n        uint112 xIncrease,\n        uint112 yIncrease,\n        uint112 zIncrease,\n        bytes calldata data\n    )\n        external\n        override\n        lock\n        returns (\n            uint256 liquidityOut,\n            uint256 id,\n            Due memory dueOut\n        )\n    {\n        require(block.timestamp < maturity, 'E202');\n        require(maturity - block.timestamp < 0x100000000, 'E208');\n        require(liquidityTo != address(0) && dueTo != address(0), 'E201');\n        require(liquidityTo != address(this) && dueTo != address(this), 'E204');\n        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205');\n        \n        Pool storage pool = pools[maturity];\n\n        if (pool.state.totalLiquidity == 0) {\n            uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);\n            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);\n\n            pool.state.totalLiquidity += liquidityTotal;\n            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;\n        } else {\n            uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);\n            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);\n\n            pool.state.totalLiquidity += liquidityTotal;\n            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;\n        }\n        require(liquidityOut > 0, 'E212');\n        pool.liquidities[liquidityTo] += liquidityOut;\n\n        dueOut.debt = MintMath.getDebt(maturity, xIncrease, yIncrease);\n        dueOut.collateral = MintMath.getCollateral(maturity, zIncrease);\n        dueOut.startBlock = BlockNumber.get();\n\n        Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data);\n\n        id = pool.dues[dueTo].insert(dueOut);\n\n        pool.state.reserves.asset += xIncrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x += xIncrease;\n        pool.state.y += yIncrease;\n        pool.state.z += zIncrease;\n\n        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Mint(maturity, msg.sender, liquidityTo, dueTo, xIncrease, liquidityOut, id, dueOut);\n    }\n\n    /// @inheritdoc IPair\n    function burn(\n        uint256 maturity,\n        address assetTo,\n        address collateralTo,\n        uint256 liquidityIn\n    ) external override lock returns (Tokens memory tokensOut) {\n        require(block.timestamp >= maturity, 'E203');\n        require(assetTo != address(0) && collateralTo != address(0), 'E201');\n        require(assetTo != address(this) && collateralTo != address(this), 'E204');\n        require(liquidityIn > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n\n        tokensOut.asset = BurnMath.getAsset(pool.state, liquidityIn);\n        tokensOut.collateral = BurnMath.getCollateral(pool.state, liquidityIn);\n\n        pool.state.totalLiquidity -= liquidityIn;\n\n        pool.liquidities[msg.sender] -= liquidityIn;\n\n        pool.state.reserves.asset -= tokensOut.asset;\n        pool.state.reserves.collateral -= tokensOut.collateral;\n\n        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);\n        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);\n\n        emit Burn(maturity, msg.sender, assetTo, collateralTo, liquidityIn, tokensOut);\n    }\n\n    /// @inheritdoc IPair\n    function lend(\n        uint256 maturity,\n        address bondTo,\n        address insuranceTo,\n        uint112 xIncrease,\n        uint112 yDecrease,\n        uint112 zDecrease,\n        bytes calldata data\n    ) external override lock returns (Claims memory claimsOut) {\n        require(block.timestamp < maturity, 'E202');\n        require(bondTo != address(0) && insuranceTo != address(0), 'E201');\n        require(bondTo != address(this) && insuranceTo != address(this), 'E204');\n        require(xIncrease > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n        require(pool.state.totalLiquidity > 0, 'E206');\n\n        LendMath.check(pool.state, xIncrease, yDecrease, zDecrease, fee);\n\n        claimsOut.bond = LendMath.getBond(maturity, xIncrease, yDecrease);\n        claimsOut.insurance = LendMath.getInsurance(maturity, pool.state, xIncrease, zDecrease);\n\n        Callback.lend(asset, xIncrease, data);\n\n        pool.state.totalClaims.bond += claimsOut.bond;\n        pool.state.totalClaims.insurance += claimsOut.insurance;\n\n        pool.claims[bondTo].bond += claimsOut.bond;\n        pool.claims[insuranceTo].insurance += claimsOut.insurance;\n\n        pool.state.reserves.asset += xIncrease;\n\n        pool.state.x += xIncrease;\n        pool.state.y -= yDecrease;\n        pool.state.z -= zDecrease;\n\n        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Lend(maturity, msg.sender, bondTo, insuranceTo, xIncrease, claimsOut);\n    }\n\n    /// @inheritdoc IPair\n    function withdraw(\n        uint256 maturity,\n        address assetTo,\n        address collateralTo,\n        Claims memory claimsIn\n    ) external override lock returns (Tokens memory tokensOut) {\n        require(block.timestamp >= maturity, 'E203');\n        require(assetTo != address(0) && collateralTo != address(0), 'E201');\n        require(assetTo != address(this) && collateralTo != address(this), 'E204');\n        require(claimsIn.bond > 0 || claimsIn.insurance > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n\n        tokensOut.asset = WithdrawMath.getAsset(pool.state, claimsIn.bond);\n        tokensOut.collateral = WithdrawMath.getCollateral(pool.state, claimsIn.insurance);\n\n        pool.state.totalClaims.bond -= claimsIn.bond;\n        pool.state.totalClaims.insurance -= claimsIn.insurance;\n\n        Claims storage sender = pool.claims[msg.sender];\n\n        sender.bond -= claimsIn.bond;\n        sender.insurance -= claimsIn.insurance;\n\n        pool.state.reserves.asset -= tokensOut.asset;\n        pool.state.reserves.collateral -= tokensOut.collateral;\n\n        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);\n        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);\n\n        emit Withdraw(maturity, msg.sender, assetTo, collateralTo, claimsIn, tokensOut);\n    }\n\n    /// @inheritdoc IPair\n    function borrow(\n        uint256 maturity,\n        address assetTo,\n        address dueTo,\n        uint112 xDecrease,\n        uint112 yIncrease,\n        uint112 zIncrease,\n        bytes calldata data\n    ) external override lock returns (uint256 id, Due memory dueOut) {\n        require(block.timestamp < maturity, 'E202');\n        require(assetTo != address(0) && dueTo != address(0), 'E201');\n        require(assetTo != address(this) && dueTo != address(this), 'E204');\n        require(xDecrease > 0, 'E205');\n\n        Pool storage pool = pools[maturity];\n        require(pool.state.totalLiquidity > 0, 'E206');\n\n        BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);\n\n        dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);\n        dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);\n        dueOut.startBlock = BlockNumber.get();\n\n        Callback.borrow(collateral, dueOut.collateral, data);\n\n        id = pool.dues[dueTo].insert(dueOut);\n\n        pool.state.reserves.asset -= xDecrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x -= xDecrease;\n        pool.state.y += yIncrease;\n        pool.state.z += zIncrease;\n\n        asset.safeTransfer(assetTo, xDecrease);\n\n        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut);\n    }\n\n    /// @inheritdoc IPair\n    function pay(\n        uint256 maturity,\n        address to,\n        address owner,\n        uint256[] memory ids,\n        uint112[] memory assetsIn,\n        uint112[] memory collateralsOut,\n        bytes calldata data\n    ) external override lock returns (uint128 assetIn, uint128 collateralOut) {\n        require(block.timestamp < maturity, 'E202');\n        require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');\n        require(to != address(0), 'E201');\n        require(to != address(this), 'E204');\n\n        Pool storage pool = pools[maturity];\n\n        Due[] storage dues = pool.dues[owner];\n\n        for (uint256 i; i < ids.length; i++) {\n            Due storage due = dues[ids[i]];\n            require(due.startBlock != BlockNumber.get(), 'E207');\n            if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');\n            PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);\n            due.debt -= assetsIn[i];\n            due.collateral -= collateralsOut[i];\n            assetIn += assetsIn[i];\n            collateralOut += collateralsOut[i];\n        }\n        if (assetIn > 0) Callback.pay(asset, assetIn, data);\n\n        pool.state.reserves.asset += assetIn;\n        pool.state.reserves.collateral -= collateralOut;\n\n        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut);\n\n        emit Pay(maturity, msg.sender, to, owner, ids, assetsIn, collateralsOut, assetIn, collateralOut);\n    }\n}"
    },
    {
      "filename": "Timeswap/Core/contracts/TimeswapPair.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from './interfaces/IPair.sol';\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {TimeswapMath} from './libraries/TimeswapMath.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Array} from './libraries/Array.sol';\nimport {Callback} from './libraries/Callback.sol';\nimport {BlockNumber} from './libraries/BlockNumber.sol';\n\n/// @title Timeswap Pair\n/// @author Timeswap Labs\n/// @notice It is recommended to use Timeswap Convenience to interact with this contract.\n/// @notice All error messages are coded and can be found in the documentation.\ncontract TimeswapPair is IPair {\n    using SafeERC20 for IERC20;\n    using Array for Due[];\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc IPair\n    IFactory public immutable override factory;\n    /// @inheritdoc IPair\n    IERC20 public immutable override asset;\n    /// @inheritdoc IPair\n    IERC20 public immutable override collateral;\n    /// @inheritdoc IPair\n    uint16 public immutable override fee;\n    /// @inheritdoc IPair\n    uint16 public immutable override protocolFee;\n\n    /// @inheritdoc IPair\n    uint256 public override protocolFeeStored;\n\n    /// @dev Stores the individual states of each Pool.\n    mapping(uint256 => Pool) private pools;\n\n    /// @dev Stores the access state for reentrancy guard.\n    uint256 private locked = 1;\n\n    /* ===== VIEW =====*/\n\n    /// @inheritdoc IPair\n    function feeStored(uint256 maturity)\n        external\n        view\n        override\n        returns (uint256) \n    {\n        return pools[maturity].state.feeStored;\n    }\n\n    /// @inheritdoc IPair\n    function constantProduct(uint256 maturity)\n        external\n        view\n        override\n        returns (uint112, uint112, uint112)\n    {\n        State storage state = pools[maturity].state;\n        return (state.x, state.y, state.z);\n    }\n\n    /// @inheritdoc IPair\n    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {\n        return pools[maturity].state.reserves;\n    }\n\n    /// @inheritdoc IPair\n    function totalLiquidity(uint256 maturity) external view override returns (uint256) {\n        return pools[maturity].state.totalLiquidity;\n    }\n\n    /// @inheritdoc IPair\n    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].liquidities[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalClaims(uint256 maturity) external view override returns (Claims memory) {\n        return pools[maturity].state.totalClaims;\n    }\n\n    /// @inheritdoc IPair\n    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {\n        return pools[maturity].claims[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {\n        return pools[maturity].state.totalDebtCreated;\n    }\n\n    /// @inheritdoc IPair\n    function totalDuesOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].dues[owner].length;\n    }\n\n    /// @inheritdoc IPair\n    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {\n        return pools[maturity].dues[owner][id];\n    }\n\n    /* ===== INIT ===== */\n\n    /// @dev Initializes the Pair contract.\n    /// @dev Called by the Timeswap factory contract.\n    /// @param _asset The address of the ERC20 being lent and borrowed.\n    /// @param _collateral The address of the ERC20 as the collateral.\n    /// @param _fee The chosen fee rate.\n    /// @param _protocolFee The chosen protocol fee rate.\n    constructor(\n        IERC20 _asset,\n        IERC20 _collateral,\n        uint16 _fee,\n        uint16 _protocolFee\n    ) {\n        factory = IFactory(msg.sender);\n        asset = _asset;\n        collateral = _collateral;\n        fee = _fee;\n        protocolFee = _protocolFee;\n    }\n\n    /* ===== MODIFIER ===== */\n\n    /// @dev The modifier for reentrancy guard.\n    modifier lock() {\n        require(locked == 1, 'E211');\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc IPair\n    function mint(MintParam calldata param)\n        external\n        override\n        lock\n        returns (\n            uint256 assetIn,\n            uint256 liquidityOut,\n            uint256 id,\n            Due memory dueOut\n        )\n    {   \n        require(block.timestamp < param.maturity, 'E202');\n        unchecked { require(param.maturity - block.timestamp < 0x100000000, 'E208'); }\n        require(param.liquidityTo != address(0), 'E201');\n        require(param.dueTo != address(0), 'E201');\n        require(param.liquidityTo != address(this), 'E204');\n        require(param.dueTo != address(this), 'E204');\n        require(param.xIncrease != 0, 'E205');\n        require(param.yIncrease != 0, 'E205');\n        require(param.zIncrease != 0, 'E205');\n        \n        Pool storage pool = pools[param.maturity];\n\n        uint256 feeStoredIncrease;\n        (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(\n            param.maturity,\n            pool.state,\n            param.xIncrease,\n            param.yIncrease,\n            param.zIncrease\n        );\n\n        require(liquidityOut != 0, 'E212');\n        pool.state.totalLiquidity += liquidityOut;\n        pool.liquidities[param.liquidityTo] += liquidityOut;\n\n        pool.state.feeStored += feeStoredIncrease;\n\n\n        id = pool.dues[param.dueTo].insert(dueOut);\n\n        pool.state.reserves.asset += param.xIncrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x += param.xIncrease;\n        pool.state.y += param.yIncrease;\n        pool.state.z += param.zIncrease;\n\n        assetIn = param.xIncrease;\n        assetIn += feeStoredIncrease;\n        Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Mint(\n            param.maturity, \n            msg.sender, \n            param.liquidityTo, \n            param.dueTo, \n            assetIn, \n            liquidityOut, \n            id, \n            dueOut,\n            feeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function burn(BurnParam calldata param) \n        external \n        override \n        lock \n        returns (\n            uint256 assetOut, \n            uint128 collateralOut\n        ) \n    {\n        require(block.timestamp >= param.maturity, 'E203');\n        require(param.assetTo != address(0), 'E201');\n        require(param.collateralTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.collateralTo != address(this), 'E204');\n        require(param.liquidityIn != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        require(pool.state.totalLiquidity > 0, 'E206');\n\n        uint128 _assetOut;\n        uint256 feeOut;\n        (_assetOut, collateralOut, feeOut) = TimeswapMath.burn(\n            pool.state,\n            param.liquidityIn\n        );\n\n        pool.state.totalLiquidity -= param.liquidityIn;\n\n        pool.liquidities[msg.sender] -= param.liquidityIn;\n\n        assetOut = _assetOut;\n        assetOut += feeOut;\n\n        if (assetOut != 0) {\n            pool.state.reserves.asset -= _assetOut;\n            pool.state.feeStored -= feeOut;\n            asset.safeTransfer(param.assetTo, assetOut);\n        }\n        if (collateralOut != 0) {\n            pool.state.reserves.collateral -= collateralOut;\n            collateral.safeTransfer(param.collateralTo, collateralOut);\n        }\n\n        emit Burn(\n            param.maturity,\n            msg.sender, \n            param.assetTo, \n            param.collateralTo, \n            param.liquidityIn, \n            assetOut, \n            collateralOut,\n            feeOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function lend(LendParam calldata param) \n        external \n        override \n        lock \n        returns (\n            uint256 assetIn,\n            Claims memory claimsOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.bondTo != address(0), 'E201');\n        require(param.insuranceTo != address(0), 'E201');\n        require(param.bondTo != address(this), 'E204');\n        require(param.insuranceTo != address(this), 'E204');\n        require(param.xIncrease != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        require(pool.state.totalLiquidity != 0, 'E206');\n\n        uint256 feeStoredIncrease;\n        uint256 protocolFeeStoredIncrease;\n        (claimsOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.lend(\n            param.maturity,\n            pool.state,\n            param.xIncrease,\n            param.yDecrease,\n            param.zDecrease,\n            fee,\n            protocolFee\n        );\n\n        pool.state.feeStored += feeStoredIncrease;\n        protocolFeeStored += protocolFeeStoredIncrease;\n\n        pool.state.totalClaims.bondPrincipal += claimsOut.bondPrincipal;\n        pool.state.totalClaims.bondInterest += claimsOut.bondInterest;\n        pool.state.totalClaims.insurancePrincipal += claimsOut.insurancePrincipal;\n        pool.state.totalClaims.insuranceInterest += claimsOut.insuranceInterest;\n\n        pool.claims[param.bondTo].bondPrincipal += claimsOut.bondPrincipal;\n        pool.claims[param.bondTo].bondInterest += claimsOut.bondInterest;\n        pool.claims[param.insuranceTo].insurancePrincipal += claimsOut.insurancePrincipal;\n        pool.claims[param.insuranceTo].insuranceInterest += claimsOut.insuranceInterest;\n\n        pool.state.reserves.asset += param.xIncrease;\n\n        pool.state.x += param.xIncrease;\n        pool.state.y -= param.yDecrease;\n        pool.state.z -= param.zDecrease;\n\n        assetIn = param.xIncrease;\n        assetIn += feeStoredIncrease;\n        assetIn += protocolFeeStoredIncrease;\n\n        Callback.lend(asset, assetIn, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Lend(\n            param.maturity,\n            msg.sender, \n            param.bondTo, \n            param.insuranceTo, \n            assetIn, \n            claimsOut,\n            feeStoredIncrease,\n            protocolFeeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function withdraw(WithdrawParam calldata param)\n        external \n        override \n        lock \n        returns (\n            Tokens memory tokensOut\n        ) \n    {\n        require(block.timestamp >= param.maturity, 'E203');\n        require(param.assetTo != address(0), 'E201');\n        require(param.collateralTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.collateralTo != address(this), 'E204');\n        require(\n            param.claimsIn.bondPrincipal != 0 || \n            param.claimsIn.bondInterest != 0 ||\n            param.claimsIn.insurancePrincipal != 0 ||\n            param.claimsIn.insuranceInterest != 0, \n            'E205'\n        );\n\n        Pool storage pool = pools[param.maturity];\n\n        tokensOut = TimeswapMath.withdraw(pool.state, param.claimsIn);\n\n        pool.state.totalClaims.bondPrincipal -= param.claimsIn.bondPrincipal;\n        pool.state.totalClaims.bondInterest -= param.claimsIn.bondInterest;\n        pool.state.totalClaims.insurancePrincipal -= param.claimsIn.insurancePrincipal;\n        pool.state.totalClaims.insuranceInterest -= param.claimsIn.insuranceInterest;\n\n        Claims storage sender = pool.claims[msg.sender];\n\n        sender.bondPrincipal -= param.claimsIn.bondPrincipal;\n        sender.bondInterest -= param.claimsIn.bondInterest;\n        sender.insurancePrincipal -= param.claimsIn.insurancePrincipal;\n        sender.insuranceInterest -= param.claimsIn.insuranceInterest;\n\n        if (tokensOut.asset != 0) {\n            pool.state.reserves.asset -= tokensOut.asset;\n            asset.safeTransfer(param.assetTo, tokensOut.asset);\n        }\n        if (tokensOut.collateral != 0) {\n            pool.state.reserves.collateral -= tokensOut.collateral;\n            collateral.safeTransfer(param.collateralTo, tokensOut.collateral);\n        }\n\n        emit Withdraw(\n            param.maturity,\n            msg.sender, \n            param.assetTo, \n            param.collateralTo, \n            param.claimsIn, \n            tokensOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function borrow(BorrowParam calldata param)\n        external \n        override \n        lock \n        returns (\n            uint256 assetOut,\n            uint256 id, \n            Due memory dueOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.assetTo != address(0), 'E201');\n        require(param.dueTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.dueTo != address(this), 'E204');\n        require(param.xDecrease != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        require(pool.state.totalLiquidity != 0, 'E206');\n\n        uint256 feeStoredIncrease;\n        uint256 protocolFeeStoredIncrease;\n        (dueOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.borrow(\n            param.maturity,\n            pool.state,\n            param.xDecrease,\n            param.yIncrease,\n            param.zIncrease,\n            fee,\n            protocolFee\n        );\n\n        pool.state.feeStored += feeStoredIncrease;\n        protocolFeeStored += protocolFeeStoredIncrease;\n\n        id = pool.dues[param.dueTo].insert(dueOut);\n\n        pool.state.reserves.asset -= param.xDecrease;\n        pool.state.reserves.collateral += dueOut.collateral;\n        pool.state.totalDebtCreated += dueOut.debt;\n\n        pool.state.x -= param.xDecrease;\n        pool.state.y += param.yIncrease;\n        pool.state.z += param.zIncrease;\n\n        assetOut = param.xDecrease;\n        assetOut -= feeStoredIncrease;\n        assetOut -= protocolFeeStoredIncrease;\n\n        asset.safeTransfer(param.assetTo, assetOut);\n\n        Callback.borrow(collateral, dueOut.collateral, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Borrow(\n            param.maturity, \n            msg.sender, \n            param.assetTo, \n            param.dueTo, \n            assetOut, \n            id, \n            dueOut,\n            feeStoredIncrease,\n            protocolFeeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function pay(PayParam calldata param)\n        external \n        override \n        lock \n        returns (\n            uint128 assetIn, \n            uint128 collateralOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.owner != address(0), 'E201');\n        require(param.to != address(0), 'E201');\n        require(param.to != address(this), 'E204');\n        require(param.ids.length == param.assetsIn.length, 'E205');\n        require(param.ids.length == param.collateralsOut.length, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n\n        Due[] storage dues = pool.dues[param.owner];\n        require(dues.length >= param.ids.length, 'E205');\n\n        for (uint256 i; i < param.ids.length;) {\n            Due storage due = dues[param.ids[i]];\n            require(due.startBlock != BlockNumber.get(), 'E207');\n            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');\n            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');\n            due.debt -= param.assetsIn[i];\n            due.collateral -= param.collateralsOut[i];\n            assetIn += param.assetsIn[i];\n            collateralOut += param.collateralsOut[i];\n            unchecked { ++i; }\n        }\n\n        pool.state.reserves.asset += assetIn;\n        pool.state.reserves.collateral -= collateralOut;\n\n        if (collateralOut != 0) collateral.safeTransfer(param.to, collateralOut);\n\n        if (assetIn != 0) Callback.pay(asset, assetIn, param.data);\n\n        emit Pay(\n            param.maturity, \n            msg.sender, \n            param.to, \n            param.owner, \n            param.ids, \n            param.assetsIn, \n            param.collateralsOut, \n            assetIn, \n            collateralOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function collectProtocolFee(address to) external override lock returns (uint256 protocolFeeOut) {\n        require(msg.sender == factory.owner(), 'E216');\n\n        protocolFeeOut = protocolFeeStored;\n        protocolFeeStored = 0;\n\n        asset.safeTransfer(to, protocolFeeOut);\n\n        emit CollectProtocolFee(msg.sender, to, protocolFeeOut);\n    }\n}"
    }
  ]
}