{
  "Title": "[M-01] `PirexGmx.initiateMigration` can be blocked",
  "Content": "\n`PirexGmx.initiateMigration` can be blocked so contract will not be able to migrate his funds to another contract using gmx.\n\n### Proof of Concept\n\nPirexGmx was designed with the thought that the current contract can be changed with another during migration.\n\n`PirexGmx.initiateMigration` is the first point in this long process.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/main/src/PirexGmx.sol#L921-L935>\n\n```solidity\n    function initiateMigration(address newContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (newContract == address(0)) revert ZeroAddress();\n\n\n        // Notify the reward router that the current/old contract is going to perform\n        // full account transfer to the specified new contract\n        gmxRewardRouterV2.signalTransfer(newContract);\n\n\n        migratedTo = newContract;\n\n\n        emit InitiateMigration(newContract);\n    }\n```\n\nAs you can see `gmxRewardRouterV2.signalTransfer(newContract);` is called to start migration.\n\nThis is the code of signalTransfer function\n<https://arbiscan.io/address/0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1#code#F1#L282>\n\n```solidity\n    function signalTransfer(address _receiver) external nonReentrant {\n        require(IERC20(gmxVester).balanceOf(msg.sender) == 0, \"RewardRouter: sender has vested tokens\");\n        require(IERC20(glpVester).balanceOf(msg.sender) == 0, \"RewardRouter: sender has vested tokens\");\n\n        _validateReceiver(_receiver);\n        pendingReceivers[msg.sender] = _receiver;\n    }\n```\n\nAs you can see the main condition to start migration is that PirexGmx doesn't control any gmxVester and glpVester tokens.\n\nSo attacker can [deposit](https://arbiscan.io/address/0xa75287d2f8b217273e7fcd7e86ef07d33972042e#code#F1#L117) and receive such tokens and then just transfer tokens directly to PirexGmx.\n\nAs a result migration will never be possible as there is no possibility for PirexGmx to burn those gmxVester and glpVester tokens.\n\nAlso in the same way, the migration receiver can also be blocked.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nThink about how to make contract ensure that he doesn't control any gmxVester and glpVester tokens before migration.\n\n**[Picodes (judge) decreased severity to Medium](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/61)**\n\n**Please note: the following comment occurred after judging and awarding were finalized.**\n\n**[kphed (Redacted Cartel) commented](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/61#issuecomment-1382029037):**\n> This issue is invalid and not possible to carry out as a non-GMX insider (if the GMX team and multisig were malicious, there would be many other ways in which they can steal value, so this specific vector would be the least of our concerns) for the following reasons:\n>\n> 1. The vester token transfer methods are overridden which removes the possibility of an attacker acquiring vGMX or vGLP and transferring it to the PirexGmx contract via those methods.\n\n> Vester.sol | Lines 246-263\n> - [vGMX](https://arbiscan.io/address/0x199070ddfd1cfb69173aa2f7e20906f26b363004#code#F1#L246)\n> - [vGLP](https://arbiscan.io/address/0xa75287d2f8b217273e7fcd7e86ef07d33972042e#code#F1#L246)\n> ```\n> // empty implementation, tokens are non-transferrable\n> function transfer(address /* recipient */, uint256 /* amount */) public override returns (bool) {\n>      revert(\"Vester: non-transferrable\");\n> }\n> \n> ...\n> \n> // empty implementation, tokens are non-transferrable\n> function transferFrom(address /* sender */, address /* recipient */, uint256 /* amount */) public virtual override returns (bool) {\n>      revert(\"Vester: non-transferrable\");\n> }\n> ```\n> \n> 2. The `depositForAccount` method can only be called by an account set by the GMX team as a \"handler\" so an attacker can't volunteer esGMX be vested on behalf of another account. Even if `depositForAccount` were to be callable by anyone, esGMX has to first be unstaked before it can be deposited for vesting, which is never the case for our contracts.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "src/PirexGmx.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Pausable} from \"openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PxERC20} from \"src/PxERC20.sol\";\nimport {PirexFees} from \"src/PirexFees.sol\";\nimport {DelegateRegistry} from \"src/external/DelegateRegistry.sol\";\nimport {IRewardRouterV2} from \"src/interfaces/IRewardRouterV2.sol\";\nimport {RewardTracker} from \"src/external/RewardTracker.sol\";\nimport {IStakedGlp} from \"src/interfaces/IStakedGlp.sol\";\nimport {IVault} from \"src/interfaces/IVault.sol\";\nimport {IRewardDistributor} from \"src/interfaces/IRewardDistributor.sol\";\nimport {IPirexRewards} from \"src/interfaces/IPirexRewards.sol\";\nimport {IGlpManager} from \"src/interfaces/IGlpManager.sol\";\n\ncontract PirexGmx is ReentrancyGuard, Owned, Pausable {\n    using SafeTransferLib for ERC20;\n\n    // Configurable fees\n    enum Fees {\n        Deposit,\n        Redemption,\n        Reward\n    }\n\n    // Configurable external contracts\n    enum Contracts {\n        PirexFees,\n        RewardRouterV2,\n        RewardTrackerGmx,\n        RewardTrackerGlp,\n        FeeStakedGlp,\n        StakedGmx,\n        StakedGlp,\n        GmxVault,\n        GlpManager\n    }\n\n    // Fee denominator\n    uint256 public constant FEE_DENOMINATOR = 1_000_000;\n\n    // Fee maximum (i.e. 20%)\n    uint256 public constant FEE_MAX = 200_000;\n\n    // External token contracts\n    ERC20 public immutable gmxBaseReward; // e.g. WETH (Ethereum)\n    ERC20 public immutable gmx;\n    ERC20 public immutable esGmx;\n\n    // Pirex token contract(s) which are unlikely to change\n    PxERC20 public immutable pxGmx;\n    PxERC20 public immutable pxGlp;\n\n    // Pirex fee repository and distribution contract\n    PirexFees public pirexFees;\n\n    // Pirex reward module contract\n    address public immutable pirexRewards;\n\n    // Snapshot vote delegation contract\n    DelegateRegistry public immutable delegateRegistry;\n\n    // GMX contracts\n    IRewardRouterV2 public gmxRewardRouterV2;\n    RewardTracker public rewardTrackerGmx;\n    RewardTracker public rewardTrackerGlp;\n    RewardTracker public feeStakedGlp;\n    RewardTracker public stakedGmx;\n    IStakedGlp public stakedGlp;\n    address public glpManager;\n    IVault public gmxVault;\n\n    // Migration related address\n    address public migratedTo;\n\n    // Snapshot space\n    bytes32 public delegationSpace = bytes32(\"gmx.eth\");\n\n    // Fees (e.g. 5000 / 1000000 = 0.5%)\n    mapping(Fees => uint256) public fees;\n\n    event ConfigureGmxState(\n        address indexed caller,\n        RewardTracker rewardTrackerGmx,\n        RewardTracker rewardTrackerGlp,\n        RewardTracker feeStakedGlp,\n        RewardTracker stakedGmx,\n        address glpManager,\n        IVault gmxVault\n    );\n    event SetFee(Fees indexed f, uint256 fee);\n    event SetContract(Contracts indexed c, address contractAddress);\n    event DepositGmx(\n        address indexed caller,\n        address indexed receiver,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event DepositGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event RedeemGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 minOut,\n        uint256 redemption,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event ClaimRewards(\n        uint256 baseRewards,\n        uint256 esGmxRewards,\n        uint256 gmxBaseRewards,\n        uint256 glpBaseRewards,\n        uint256 gmxEsGmxRewards,\n        uint256 glpEsGmxRewards\n    );\n    event ClaimUserReward(\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 rewardAmount,\n        uint256 feeAmount\n    );\n    event InitiateMigration(address newContract);\n    event CompleteMigration(address oldContract);\n    event SetDelegationSpace(string delegationSpace, bool shouldClear);\n    event SetVoteDelegate(address voteDelegate);\n    event ClearVoteDelegate();\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidToken(address token);\n    error NotPirexRewards();\n    error InvalidFee();\n    error EmptyString();\n    error NotMigratedTo();\n    error PendingMigration();\n\n    /**\n        @param  _pxGmx              address  PxGmx contract address\n        @param  _pxGlp              address  PxGlp contract address\n        @param  _pirexFees          address  PirexFees contract address\n        @param  _pirexRewards       address  PirexRewards contract address\n        @param  _delegateRegistry   address  Delegation registry contract address\n        @param  _gmxBaseReward      address  GMX base reward token contract address\n        @param  _gmx                address  GMX token contract address\n        @param  _esGmx              address  esGMX token contract address\n        @param  _gmxRewardRouterV2  address  GMX Reward Router contract address\n        @param  _stakedGlp          address  Staked GLP token contract address\n    */\n    constructor(\n        address _pxGmx,\n        address _pxGlp,\n        address _pirexFees,\n        address _pirexRewards,\n        address _delegateRegistry,\n        address _gmxBaseReward,\n        address _gmx,\n        address _esGmx,\n        address _gmxRewardRouterV2,\n        address _stakedGlp\n    ) Owned(msg.sender) {\n        // Start the contract paused, to ensure contract set is properly configured\n        _pause();\n\n        if (_pxGmx == address(0)) revert ZeroAddress();\n        if (_pxGlp == address(0)) revert ZeroAddress();\n        if (_pirexFees == address(0)) revert ZeroAddress();\n        if (_pirexRewards == address(0)) revert ZeroAddress();\n        if (_delegateRegistry == address(0)) revert ZeroAddress();\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_esGmx == address(0)) revert ZeroAddress();\n        if (_gmxRewardRouterV2 == address(0)) revert ZeroAddress();\n        if (_stakedGlp == address(0)) revert ZeroAddress();\n\n        pxGmx = PxERC20(_pxGmx);\n        pxGlp = PxERC20(_pxGlp);\n        pirexFees = PirexFees(_pirexFees);\n        pirexRewards = _pirexRewards;\n        delegateRegistry = DelegateRegistry(_delegateRegistry);\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        esGmx = ERC20(_esGmx);\n        gmxRewardRouterV2 = IRewardRouterV2(_gmxRewardRouterV2);\n        stakedGlp = IStakedGlp(_stakedGlp);\n    }\n\n    modifier onlyPirexRewards() {\n        if (msg.sender != pirexRewards) revert NotPirexRewards();\n        _;\n    }\n\n    /**\n        @notice Compute post-fee asset and fee amounts from a fee type and total assets\n        @param  f              enum     Fee\n        @param  assets         uint256  GMX/GLP/WETH asset amount\n        @return postFeeAmount  uint256  Post-fee asset amount (for mint/burn/claim/etc.)\n        @return feeAmount      uint256  Fee amount\n     */\n    function _computeAssetAmounts(Fees f, uint256 assets)\n        internal\n        view\n        returns (uint256 postFeeAmount, uint256 feeAmount)\n    {\n        feeAmount = (assets * fees[f]) / FEE_DENOMINATOR;\n        postFeeAmount = assets - feeAmount;\n\n        assert(feeAmount + postFeeAmount == assets);\n    }\n\n    /**\n        @notice Calculate the base (e.g. WETH) or esGMX rewards for either GMX or GLP\n        @param  isBaseReward  bool     Whether to calculate base or esGMX rewards\n        @param  useGmx        bool     Whether the calculation should be for GMX\n        @return               uint256  Amount of WETH/esGMX rewards\n     */\n    function _calculateRewards(bool isBaseReward, bool useGmx)\n        internal\n        view\n        returns (uint256)\n    {\n        RewardTracker r;\n\n        if (isBaseReward) {\n            r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;\n        } else {\n            r = useGmx ? stakedGmx : feeStakedGlp;\n        }\n\n        address distributor = r.distributor();\n        uint256 pendingRewards = IRewardDistributor(distributor)\n            .pendingRewards();\n        uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)\n            .balanceOf(distributor);\n        uint256 blockReward = pendingRewards > distributorBalance\n            ? distributorBalance\n            : pendingRewards;\n        uint256 precision = r.PRECISION();\n        uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +\n            ((blockReward * precision) / r.totalSupply());\n\n        if (cumulativeRewardPerToken == 0) return 0;\n\n        return\n            r.claimableReward(address(this)) +\n            ((r.stakedAmounts(address(this)) *\n                (cumulativeRewardPerToken -\n                    r.previousCumulatedRewardPerToken(address(this)))) /\n                precision);\n    }\n\n    /**\n        @notice Configure GMX contract state\n     */\n    function configureGmxState() external onlyOwner whenPaused {\n        // Variables which can be assigned by reading previously-set GMX contracts\n        rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());\n        rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());\n        feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());\n        stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());\n        glpManager = gmxRewardRouterV2.glpManager();\n        gmxVault = IVault(IGlpManager(glpManager).vault());\n\n        emit ConfigureGmxState(\n            msg.sender,\n            rewardTrackerGmx,\n            rewardTrackerGlp,\n            feeStakedGlp,\n            stakedGmx,\n            glpManager,\n            gmxVault\n        );\n\n        // Approve GMX to enable staking\n        gmx.safeApprove(address(stakedGmx), type(uint256).max);\n    }\n\n    /**\n        @notice Set fee\n        @param  f    enum     Fee\n        @param  fee  uint256  Fee amount\n     */\n    function setFee(Fees f, uint256 fee) external onlyOwner {\n        if (fee > FEE_MAX) revert InvalidFee();\n\n        fees[f] = fee;\n\n        emit SetFee(f, fee);\n    }\n\n    /**\n        @notice Set a contract address\n        @param  c                enum     Contracts\n        @param  contractAddress  address  Contract address\n     */\n    function setContract(Contracts c, address contractAddress)\n        external\n        onlyOwner\n    {\n        if (contractAddress == address(0)) revert ZeroAddress();\n\n        emit SetContract(c, contractAddress);\n\n        if (c == Contracts.PirexFees) {\n            pirexFees = PirexFees(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardRouterV2) {\n            gmxRewardRouterV2 = IRewardRouterV2(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGmx) {\n            rewardTrackerGmx = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGlp) {\n            rewardTrackerGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.FeeStakedGlp) {\n            feeStakedGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.StakedGmx) {\n            // Set the current stakedGmx (pending change) approval amount to 0\n            gmx.safeApprove(address(stakedGmx), 0);\n\n            stakedGmx = RewardTracker(contractAddress);\n\n            // Approve the new stakedGmx contract address allowance to the max\n            gmx.safeApprove(contractAddress, type(uint256).max);\n            return;\n        }\n\n        if (c == Contracts.StakedGlp) {\n            stakedGlp = IStakedGlp(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.GmxVault) {\n            gmxVault = IVault(contractAddress);\n            return;\n        }\n\n        glpManager = contractAddress;\n    }\n\n    /**\n        @notice Deposit GMX for pxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  pxGMX receiver\n        @return           uint256  GMX deposited\n        @return           uint256  pxGMX minted for the receiver\n        @return           uint256  pxGMX distributed as fees\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's GMX to this contract and stake it for rewards\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n        gmxRewardRouterV2.stakeGmx(amount);\n\n        // Get the pxGMX amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGMX for the receiver (excludes fees)\n        pxGmx.mint(receiver, postFeeAmount);\n\n        // Mint pxGMX for fee distribution contract\n        if (feeAmount != 0) {\n            pxGmx.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGmx(msg.sender, receiver, amount, postFeeAmount, feeAmount);\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit fsGLP for pxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  pxGLP receiver\n        @return           uint256  fsGLP deposited\n        @return           uint256  pxGLP minted for the receiver\n        @return           uint256  pxGLP distributed as fees\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's fsGLP (unstaked for the user, staked for this contract)\n        stakedGlp.transferFrom(msg.sender, address(this), amount);\n\n        // Get the pxGLP amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGLP for the receiver (excludes fees)\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            address(stakedGlp),\n            0,\n            0,\n            0,\n            amount,\n            postFeeAmount,\n            feeAmount\n        );\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit GLP for pxGLP\n        @param  token          address  GMX-whitelisted token for minting GLP (optional)\n        @param  tokenAmount    uint256  Token amount\n        @param  minUsdg        uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp         uint256  Minimum GLP amount minted from tokens\n        @param  receiver       address  pxGLP receiver\n        @return deposited      uint256  GLP deposited\n        @return postFeeAmount  uint256  pxGLP minted for the receiver\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 deposited,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (token == address(0)) {\n            // Mint and stake GLP using ETH\n            deposited = gmxRewardRouterV2.mintAndStakeGlpETH{\n                value: tokenAmount\n            }(minUsdg, minGlp);\n        } else {\n            ERC20 t = ERC20(token);\n\n            // Intake user ERC20 tokens and approve GLP Manager contract for amount\n            t.safeTransferFrom(msg.sender, address(this), tokenAmount);\n            t.safeApprove(glpManager, tokenAmount);\n\n            // Mint and stake GLP using ERC20 tokens\n            deposited = gmxRewardRouterV2.mintAndStakeGlp(\n                token,\n                tokenAmount,\n                minUsdg,\n                minGlp\n            );\n        }\n\n        // Calculate the post-fee and fee amounts based on the fee type and total deposited\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            deposited\n        );\n\n        // Mint pxGLP for the receiver\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            deposited,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for pxGLP\n        @param  minUsdg    uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp     uint256  Minimum GLP amount minted from ETH\n        @param  receiver   address  pxGLP receiver\n        @return deposited  uint256  GLP deposited\n        @return            uint256  pxGLP minted for the receiver\n        @return            uint256  pxGLP distributed as fees\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _depositGlp(address(0), msg.value, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for pxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  pxGLP receiver\n        @return              uint256  GLP deposited\n        @return              uint256  pxGLP minted for the receiver\n        @return              uint256  pxGLP distributed as fees\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _depositGlp(token, tokenAmount, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP\n        @param  token          address  GMX-whitelisted token to be redeemed (optional)\n        @param  amount         uint256  pxGLP amount\n        @param  minOut         uint256  Minimum token output from GLP redemption\n        @param  receiver       address  Output token recipient\n        @return redeemed       uint256  Output tokens from redeeming GLP\n        @return postFeeAmount  uint256  pxGLP burned from the msg.sender\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 redeemed,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (minOut == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Calculate the post-fee and fee amounts based on the fee type and total amount\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Redemption,\n            amount\n        );\n\n        // Burn pxGLP before redeeming the underlying GLP\n        pxGlp.burn(msg.sender, postFeeAmount);\n\n        // Transfer pxGLP from caller to the fee distribution contract\n        if (feeAmount != 0) {\n            ERC20(pxGlp).safeTransferFrom(\n                msg.sender,\n                address(pirexFees),\n                feeAmount\n            );\n        }\n\n        // Unstake and redeem the underlying GLP for ERC20 tokens\n        redeemed = token == address(0)\n            ? gmxRewardRouterV2.unstakeAndRedeemGlpETH(\n                postFeeAmount,\n                minOut,\n                receiver\n            )\n            : gmxRewardRouterV2.unstakeAndRedeemGlp(\n                token,\n                postFeeAmount,\n                minOut,\n                receiver\n            );\n\n        emit RedeemGlp(\n            msg.sender,\n            receiver,\n            token,\n            amount,\n            minOut,\n            redeemed,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Redeem pxGLP for ETH from redeeming GLP\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ETH output from GLP redemption\n        @param  receiver  address  ETH recipient\n        @return           uint256  ETH redeemed from GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlpETH(\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _redeemPxGlp(address(0), amount, minOut, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP for ERC20 tokens from redeeming GLP\n        @param  token     address  GMX-whitelisted token to be redeemed\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ERC20 output from GLP redemption\n        @param  receiver  address  ERC20 token recipient\n        @return           uint256  ERC20 tokens from redeeming GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _redeemPxGlp(token, amount, minOut, receiver);\n    }\n\n    /**\n        @notice Claim WETH/esGMX rewards + multiplier points (MP)\n        @return producerTokens  ERC20[]    Producer tokens (pxGLP and pxGMX)\n        @return rewardTokens    ERC20[]    Reward token contract instances\n        @return rewardAmounts   uint256[]  Reward amounts from each producerToken\n     */\n    function claimRewards()\n        external\n        onlyPirexRewards\n        returns (\n            ERC20[] memory producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        // Assign return values used by the PirexRewards contract\n        producerTokens = new ERC20[](4);\n        rewardTokens = new ERC20[](4);\n        rewardAmounts = new uint256[](4);\n        producerTokens[0] = pxGmx;\n        producerTokens[1] = pxGlp;\n        producerTokens[2] = pxGmx;\n        producerTokens[3] = pxGlp;\n        rewardTokens[0] = gmxBaseReward;\n        rewardTokens[1] = gmxBaseReward;\n        rewardTokens[2] = ERC20(pxGmx); // esGMX rewards distributed as pxGMX\n        rewardTokens[3] = ERC20(pxGmx);\n\n        // Get pre-reward claim reward token balances to calculate actual amount received\n        uint256 baseRewardBeforeClaim = gmxBaseReward.balanceOf(address(this));\n        uint256 esGmxBeforeClaim = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        );\n\n        // Calculate the unclaimed reward token amounts produced for each token type\n        uint256 gmxBaseRewards = _calculateRewards(true, true);\n        uint256 glpBaseRewards = _calculateRewards(true, false);\n        uint256 gmxEsGmxRewards = _calculateRewards(false, true);\n        uint256 glpEsGmxRewards = _calculateRewards(false, false);\n\n        // Claim and stake esGMX + MP, and claim WETH\n        gmxRewardRouterV2.handleRewards(\n            false,\n            false,\n            true,\n            true,\n            true,\n            true,\n            false\n        );\n\n        uint256 baseRewards = gmxBaseReward.balanceOf(address(this)) -\n            baseRewardBeforeClaim;\n        uint256 esGmxRewards = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        ) - esGmxBeforeClaim;\n\n        if (baseRewards != 0) {\n            // This may not be necessary and is more of a hedge against a discrepancy between\n            // the actual rewards and the calculated amounts. Needs further consideration\n            rewardAmounts[0] =\n                (gmxBaseRewards * baseRewards) /\n                (gmxBaseRewards + glpBaseRewards);\n            rewardAmounts[1] = baseRewards - rewardAmounts[0];\n        }\n\n        if (esGmxRewards != 0) {\n            rewardAmounts[2] =\n                (gmxEsGmxRewards * esGmxRewards) /\n                (gmxEsGmxRewards + glpEsGmxRewards);\n            rewardAmounts[3] = esGmxRewards - rewardAmounts[2];\n        }\n\n        emit ClaimRewards(\n            baseRewards,\n            esGmxRewards,\n            gmxBaseRewards,\n            glpBaseRewards,\n            gmxEsGmxRewards,\n            glpEsGmxRewards\n        );\n    }\n\n    /**\n        @notice Mint/transfer the specified reward token to the receiver\n        @param  token     address  Reward token address\n        @param  amount    uint256  Reward amount\n        @param  receiver  address  Reward receiver\n     */\n    function claimUserReward(\n        address token,\n        uint256 amount,\n        address receiver\n    ) external onlyPirexRewards {\n        if (token == address(0)) revert ZeroAddress();\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Reward,\n            amount\n        );\n\n        if (token == address(pxGmx)) {\n            // Mint pxGMX for the user - the analog for esGMX rewards\n            pxGmx.mint(receiver, postFeeAmount);\n\n            if (feeAmount != 0) pxGmx.mint(address(pirexFees), feeAmount);\n        } else if (token == address(gmxBaseReward)) {\n            gmxBaseReward.safeTransfer(receiver, postFeeAmount);\n\n            if (feeAmount != 0)\n                gmxBaseReward.safeTransfer(address(pirexFees), feeAmount);\n        }\n\n        emit ClaimUserReward(receiver, token, amount, postFeeAmount, feeAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        VOTE DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set delegationSpace\n        @param  _delegationSpace  string  Snapshot delegation space\n        @param  shouldClear       bool    Whether to clear the vote delegate for the current space\n     */\n    function setDelegationSpace(\n        string memory _delegationSpace,\n        bool shouldClear\n    ) external onlyOwner {\n        if (shouldClear) {\n            // Clear the delegation for the current delegation space\n            clearVoteDelegate();\n        }\n\n        bytes memory d = bytes(_delegationSpace);\n\n        if (d.length == 0) revert EmptyString();\n\n        delegationSpace = bytes32(d);\n\n        emit SetDelegationSpace(_delegationSpace, shouldClear);\n    }\n\n    /**\n        @notice Set vote delegate\n        @param  voteDelegate  address  Account to delegate votes to\n     */\n    function setVoteDelegate(address voteDelegate) external onlyOwner {\n        if (voteDelegate == address(0)) revert ZeroAddress();\n\n        emit SetVoteDelegate(voteDelegate);\n\n        delegateRegistry.setDelegate(delegationSpace, voteDelegate);\n    }\n\n    /**\n        @notice Clear vote delegate\n     */\n    function clearVoteDelegate() public onlyOwner {\n        emit ClearVoteDelegate();\n\n        delegateRegistry.clearDelegate(delegationSpace);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        EMERGENCY/MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set the contract's pause state\n        @param state  bool  Pause state\n    */\n    function setPauseState(bool state) external onlyOwner {\n        if (state) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**\n        @notice Initiate contract migration (called by the old contract)\n        @param  newContract  address  Address of the new contract\n    */\n    function initiateMigration(address newContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (newContract == address(0)) revert ZeroAddress();\n\n        // Notify the reward router that the current/old contract is going to perform\n        // full account transfer to the specified new contract\n        gmxRewardRouterV2.signalTransfer(newContract);\n\n        migratedTo = newContract;\n\n        emit InitiateMigration(newContract);\n    }\n\n    /**\n        @notice Migrate remaining (base) reward to the new contract after completing migration\n    */\n    function migrateReward() external whenPaused {\n        if (msg.sender != migratedTo) revert NotMigratedTo();\n        if (gmxRewardRouterV2.pendingReceivers(address(this)) != address(0))\n            revert PendingMigration();\n\n        // Transfer out any remaining base reward (ie. WETH) to the new contract\n        gmxBaseReward.safeTransfer(\n            migratedTo,\n            gmxBaseReward.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @notice Complete contract migration (called by the new contract)\n        @param  oldContract  address  Address of the old contract\n    */\n    function completeMigration(address oldContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (oldContract == address(0)) revert ZeroAddress();\n\n        // Trigger harvest to claim remaining rewards before the account transfer\n        IPirexRewards(pirexRewards).harvest();\n\n        // Complete the full account transfer process\n        gmxRewardRouterV2.acceptTransfer(oldContract);\n\n        // Perform reward token transfer from the old contract to the new one\n        PirexGmx(oldContract).migrateReward();\n\n        emit CompleteMigration(oldContract);\n    }\n}"
    }
  ]
}