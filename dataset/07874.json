{
  "Title": "[M-06] Calling swapAVAXForExactTokens function while sending excess amount cannot refund such excess amount",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521\n\n\n# Vulnerability details\n\n## Impact\nWhen calling the `swapAVAXForExactTokens`  function, `if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value)` is executed, which is for refunding any excess amount sent in; this is confirmed by this function's comment as well. However, executing `amountsIn[0] - msg.value` will always revert when `msg.value > amountsIn[0]` is true. Developers who has the design of the `swapAVAXForExactTokens` function in mind could develop front-ends and contracts that will send excess amount when calling the `swapAVAXForExactTokens` function. Hence, the users, who rely on these front-ends and contracts for interacting with the `swapAVAXForExactTokens` function will always find such interactions being failed since calling this function with the excess amount will always revert. As a result, the user experience becomes degraded, and the usability of the protocol becomes limited.\n\nhttps://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521\n```solidity\n    /// @notice Swaps AVAX for exact tokens while performing safety checks\n    /// @dev will refund any excess sent\n    ...\n    function swapAVAXForExactTokens(\n        uint256 _amountOut,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        override\n        ensure(_deadline)\n        verifyInputs(_pairBinSteps, _tokenPath)\n        returns (uint256[] memory amountsIn)\n    {\n        ...\n\n        if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value);\n    }\n```\n\n## Proof of Concept\nPlease add the following test in `test\\LBRouter.Swaps.t.sol`. This test will pass to demonstrate the described scenario.\n```solidity\n    function testSwapAVAXForExactTokensIsUnableToRefund() public {\n        uint256 amountOut = 1e18;\n\n        (uint256 amountIn, ) = router.getSwapIn(pairWavax, amountOut, false);\n\n        IERC20[] memory tokenList = new IERC20[](2);\n        tokenList[0] = wavax;\n        tokenList[1] = token6D;\n        uint256[] memory pairVersions = new uint256[](1);\n        pairVersions[0] = DEFAULT_BIN_STEP;\n\n        vm.deal(DEV, amountIn + 500);\n\n        // Although the swapAVAXForExactTokens function supposes to refund any excess sent,\n        //   calling it reverts when sending more than amountIn\n        //   because executing _safeTransferAVAX(_to, amountsIn[0] - msg.value) results in arithmetic underflow\n        vm.expectRevert(stdError.arithmeticError);\n        router.swapAVAXForExactTokens{value: amountIn + 1}(amountOut, pairVersions, tokenList, DEV, block.timestamp);\n    }\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nhttps://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L520 can be updated to the following code.\n```solidity\n        if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, msg.value - amountsIn[0]);\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-trader-joe-v2-contest",
  "Code": [
    {
      "filename": "src/LBRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport \"./LBErrors.sol\";\nimport \"./libraries/BinHelper.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/FeeHelper.sol\";\nimport \"./libraries/Math512Bits.sol\";\nimport \"./libraries/SwapHelper.sol\";\nimport \"./libraries/TokenHelper.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/ILBToken.sol\";\nimport \"./interfaces/ILBRouter.sol\";\n\n/// @title Liquidity Book Router\n/// @author Trader Joe\n/// @notice Main contract to interact with to swap and manage liquidity on Joe V2 exchange.\ncontract LBRouter is ILBRouter {\n    using TokenHelper for IERC20;\n    using TokenHelper for IWAVAX;\n    using FeeHelper for FeeHelper.FeeParameters;\n    using Math512Bits for uint256;\n    using SwapHelper for ILBPair.Bin;\n\n    ILBFactory public immutable override factory;\n    IJoeFactory public immutable override oldFactory;\n    IWAVAX public immutable override wavax;\n\n    modifier onlyFactoryOwner() {\n        if (msg.sender != factory.owner()) revert LBRouter__NotFactoryOwner();\n        _;\n    }\n\n    modifier ensure(uint256 _deadline) {\n        if (block.timestamp > _deadline) revert LBRouter__DeadlineExceeded(_deadline, block.timestamp);\n        _;\n    }\n\n    modifier verifyInputs(uint256[] memory _pairBinSteps, IERC20[] memory _tokenPath) {\n        if (_pairBinSteps.length == 0 || _pairBinSteps.length + 1 != _tokenPath.length)\n            revert LBRouter__LengthsMismatch();\n        _;\n    }\n\n    /// @notice Constructor\n    /// @param _factory LBFactory address\n    /// @param _oldFactory Address of old factory (Joe V1)\n    /// @param _wavax Address of WAVAX\n    constructor(\n        ILBFactory _factory,\n        IJoeFactory _oldFactory,\n        IWAVAX _wavax\n    ) {\n        factory = _factory;\n        oldFactory = _oldFactory;\n        wavax = _wavax;\n    }\n\n    /// @dev Receive function that only accept AVAX from the WAVAX contract\n    receive() external payable {\n        if (msg.sender != address(wavax)) revert LBRouter__SenderIsNotWAVAX();\n    }\n\n    /// @notice Returns the approximate id corresponding to the inputted price.\n    /// Warning, the returned id may be inaccurate close to the start price of a bin\n    /// @param _LBPair The address of the LBPair\n    /// @param _price The price of y per x (multiplied by 1e36)\n    /// @return The id corresponding to this price\n    function getIdFromPrice(ILBPair _LBPair, uint256 _price) external view override returns (uint24) {\n        return BinHelper.getIdFromPrice(_price, _LBPair.feeParameters().binStep);\n    }\n\n    /// @notice Returns the price corresponding to the inputted id\n    /// @param _LBPair The address of the LBPair\n    /// @param _id The id\n    /// @return The price corresponding to this id\n    function getPriceFromId(ILBPair _LBPair, uint24 _id) external view override returns (uint256) {\n        return BinHelper.getPriceFromId(_id, _LBPair.feeParameters().binStep);\n    }\n\n    /// @notice Simulate a swap in\n    /// @param _LBPair The address of the LBPair\n    /// @param _amountOut The amount of token to receive\n    /// @param _swapForY Whether you swap X for Y (true), or Y for X (false)\n    /// @return amountIn The amount of token to send in order to receive _amountOut token\n    /// @return feesIn The amount of fees paid in token sent\n    function getSwapIn(\n        ILBPair _LBPair,\n        uint256 _amountOut,\n        bool _swapForY\n    ) public view override returns (uint256 amountIn, uint256 feesIn) {\n        (uint256 _pairReserveX, uint256 _pairReserveY, uint256 _activeId) = _LBPair.getReservesAndId();\n\n        if (_amountOut == 0 || (_swapForY ? _amountOut > _pairReserveY : _amountOut > _pairReserveX))\n            revert LBRouter__WrongAmounts(_amountOut, _swapForY ? _pairReserveY : _pairReserveX); // If this is wrong, then we're sure the amounts sent are wrong\n\n        FeeHelper.FeeParameters memory _fp = _LBPair.feeParameters();\n        _fp.updateVariableFeeParameters(_activeId);\n\n        uint256 _amountOutOfBin;\n        uint256 _amountInWithFees;\n        uint256 _reserve;\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstNonEmptyBinId function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            {\n                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));\n                _reserve = _swapForY ? _reserveY : _reserveX;\n            }\n            uint256 _price = BinHelper.getPriceFromId(_activeId, _fp.binStep);\n            if (_reserve != 0) {\n                _amountOutOfBin = _amountOut > _reserve ? _reserve : _amountOut;\n\n                uint256 _amountInToBin = _swapForY\n                    ? _amountOutOfBin.shiftDivRoundUp(Constants.SCALE_OFFSET, _price)\n                    : _price.mulShiftRoundUp(_amountOutOfBin, Constants.SCALE_OFFSET);\n\n                // We update the fee, but we don't store the new volatility reference, volatility accumulated and indexRef to not penalize traders\n                _fp.updateVolatilityAccumulated(_activeId);\n                uint256 _fee = _fp.getFeeAmount(_amountInToBin);\n                _amountInWithFees = _amountInToBin + _fee;\n\n                if (_amountInWithFees + _reserve > type(uint112).max) revert LBRouter__SwapOverflows(_activeId);\n                amountIn += _amountInWithFees;\n                feesIn += _fee;\n                _amountOut -= _amountOutOfBin;\n            }\n\n            if (_amountOut != 0) {\n                _activeId = _LBPair.findFirstNonEmptyBinId(uint24(_activeId), _swapForY);\n            } else {\n                break;\n            }\n        }\n        if (_amountOut != 0) revert LBRouter__BrokenSwapSafetyCheck(); // Safety check, but should never be false as it would have reverted on transfer\n    }\n\n    /// @notice Simulate a swap out\n    /// @param _LBPair The address of the LBPair\n    /// @param _amountIn The amount of token sent\n    /// @param _swapForY Whether you swap X for Y (true), or Y for X (false)\n    /// @return amountOut The amount of token received if _amountIn tokenX are sent\n    /// @return feesIn The amount of fees paid in token sent\n    function getSwapOut(\n        ILBPair _LBPair,\n        uint256 _amountIn,\n        bool _swapForY\n    ) external view override returns (uint256 amountOut, uint256 feesIn) {\n        (, , uint256 _activeId) = _LBPair.getReservesAndId();\n\n        FeeHelper.FeeParameters memory _fp = _LBPair.feeParameters();\n        _fp.updateVariableFeeParameters(_activeId);\n        ILBPair.Bin memory _bin;\n\n        // Performs the actual swap, bin per bin\n        // It uses the findFirstNonEmptyBinId function to make sure the bin we're currently looking at\n        // has liquidity in it.\n        while (true) {\n            {\n                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));\n                _bin = ILBPair.Bin(uint112(_reserveX), uint112(_reserveY), 0, 0);\n            }\n            if (_bin.reserveX != 0 || _bin.reserveY != 0) {\n                (uint256 _amountInToBin, uint256 _amountOutOfBin, FeeHelper.FeesDistribution memory _fees) = _bin\n                    .getAmounts(_fp, _activeId, _swapForY, _amountIn);\n\n                if (_amountInToBin > type(uint112).max) revert LBRouter__BinReserveOverflows(_activeId);\n\n                _amountIn -= _amountInToBin + _fees.total;\n                feesIn += _fees.total;\n                amountOut += _amountOutOfBin;\n            }\n\n            if (_amountIn != 0) {\n                _activeId = _LBPair.findFirstNonEmptyBinId(uint24(_activeId), _swapForY);\n            } else {\n                break;\n            }\n        }\n        if (_amountIn != 0) revert LBRouter__TooMuchTokensIn(_amountIn);\n    }\n\n    /// @notice Create a liquidity bin LBPair for _tokenX and _tokenY using the factory\n    /// @param _tokenX The address of the first token\n    /// @param _tokenY The address of the second token\n    /// @param _activeId The active id of the pair\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @return pair The address of the newly created LBPair\n    function createLBPair(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _binStep\n    ) external override returns (ILBPair pair) {\n        pair = factory.createLBPair(_tokenX, _tokenY, _activeId, _binStep);\n    }\n\n    /// @notice Add liquidity while performing safety checks\n    /// @dev This function is compliant with fee on transfer tokens\n    /// @param _liquidityParameters The liquidity parameters\n    /// @return depositIds Bin ids where the liquidity was actually deposited\n    /// @return liquidityMinted Amounts of LBToken minted for each bin\n    function addLiquidity(LiquidityParameters memory _liquidityParameters)\n        external\n        override\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        ILBPair _LBPair = _getLBPairInformation(\n            _liquidityParameters.tokenX,\n            _liquidityParameters.tokenY,\n            _liquidityParameters.binStep\n        );\n        if (_liquidityParameters.tokenX != _LBPair.tokenX()) revert LBRouter__WrongTokenOrder();\n\n        _liquidityParameters.tokenX.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountX);\n        _liquidityParameters.tokenY.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountY);\n\n        (depositIds, liquidityMinted) = _addLiquidity(_liquidityParameters, _LBPair);\n    }\n\n    /// @notice Add liquidity with AVAX while performing safety checks\n    /// @dev This function is compliant with fee on transfer tokens\n    /// @param _liquidityParameters The liquidity parameters\n    /// @return depositIds Bin ids where the liquidity was actually deposited\n    /// @return liquidityMinted Amounts of LBToken minted for each bin\n    function addLiquidityAVAX(LiquidityParameters memory _liquidityParameters)\n        external\n        payable\n        override\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        ILBPair _LBPair = _getLBPairInformation(\n            _liquidityParameters.tokenX,\n            _liquidityParameters.tokenY,\n            _liquidityParameters.binStep\n        );\n        if (_liquidityParameters.tokenX != _LBPair.tokenX()) revert LBRouter__WrongTokenOrder();\n\n        if (_liquidityParameters.tokenX == wavax && _liquidityParameters.amountX == msg.value) {\n            _wavaxDepositAndTransfer(address(_LBPair), msg.value);\n            _liquidityParameters.tokenY.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountY);\n        } else if (_liquidityParameters.tokenY == wavax && _liquidityParameters.amountY == msg.value) {\n            _liquidityParameters.tokenX.safeTransferFrom(msg.sender, address(_LBPair), _liquidityParameters.amountX);\n            _wavaxDepositAndTransfer(address(_LBPair), msg.value);\n        } else\n            revert LBRouter__WrongAvaxLiquidityParameters(\n                address(_liquidityParameters.tokenX),\n                address(_liquidityParameters.tokenY),\n                _liquidityParameters.amountX,\n                _liquidityParameters.amountY,\n                msg.value\n            );\n\n        (depositIds, liquidityMinted) = _addLiquidity(_liquidityParameters, _LBPair);\n    }\n\n    /// @notice Remove liquidity while performing safety checks\n    /// @dev This function is compliant with fee on transfer tokens\n    /// @param _tokenX The address of token X\n    /// @param _tokenY The address of token Y\n    /// @param _binStep The bin step of the LBPair\n    /// @param _amountXMin The min amount to receive of token X\n    /// @param _amountYMin The min amount to receive of token Y\n    /// @param _ids The list of ids to burn\n    /// @param _amounts The list of amounts to burn of each id in `_ids`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountX Amount of token X returned\n    /// @return amountY Amount of token Y returned\n    function removeLiquidity(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint16 _binStep,\n        uint256 _amountXMin,\n        uint256 _amountYMin,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) returns (uint256 amountX, uint256 amountY) {\n        ILBPair _LBPair = _getLBPairInformation(_tokenX, _tokenY, _binStep);\n        if (_tokenX != _LBPair.tokenX()) {\n            (_tokenX, _tokenY) = (_tokenY, _tokenX);\n            (_amountXMin, _amountYMin) = (_amountYMin, _amountXMin);\n        }\n\n        (amountX, amountY) = _removeLiquidity(_LBPair, _amountXMin, _amountYMin, _ids, _amounts, _to);\n    }\n\n    /// @notice Remove AVAX liquidity while performing safety checks\n    /// @dev This function is **NOT** compliant with fee on transfer tokens.\n    /// This is wanted as it would make users pays the fee on transfer twice,\n    /// use the `removeLiquidity` function to remove liquidity with fee on transfer tokens.\n    /// @param _token The address of token\n    /// @param _binStep The bin step of the LBPair\n    /// @param _amountTokenMin The min amount to receive of token\n    /// @param _amountAVAXMin The min amount to receive of AVAX\n    /// @param _ids The list of ids to burn\n    /// @param _amounts The list of amounts to burn of each id in `_ids`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountToken Amount of token returned\n    /// @return amountAVAX Amount of AVAX returned\n    function removeLiquidityAVAX(\n        IERC20 _token,\n        uint16 _binStep,\n        uint256 _amountTokenMin,\n        uint256 _amountAVAXMin,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) returns (uint256 amountToken, uint256 amountAVAX) {\n        ILBPair _LBPair = _getLBPairInformation(_token, IERC20(wavax), _binStep);\n\n        bool _isAVAXTokenY = IERC20(wavax) == _LBPair.tokenY();\n        {\n            if (!_isAVAXTokenY) {\n                (_amountTokenMin, _amountAVAXMin) = (_amountAVAXMin, _amountTokenMin);\n            }\n\n            (uint256 _amountX, uint256 _amountY) = _removeLiquidity(\n                _LBPair,\n                _amountTokenMin,\n                _amountAVAXMin,\n                _ids,\n                _amounts,\n                address(this)\n            );\n\n            (amountToken, amountAVAX) = _isAVAXTokenY ? (_amountX, _amountY) : (_amountY, _amountX);\n        }\n\n        _token.safeTransfer(_to, amountToken);\n\n        wavax.withdraw(amountAVAX);\n        _safeTransferAVAX(_to, amountAVAX);\n    }\n\n    /// @notice Swaps exact tokens for tokens while performing safety checks\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        amountOut = _swapExactTokensForTokens(_amountIn, _pairs, _pairBinSteps, _tokenPath, _to);\n\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Swaps exact tokens for AVAX while performing safety checks\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMinAVAX The min amount of AVAX to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForAVAX(\n        uint256 _amountIn,\n        uint256 _amountOutMinAVAX,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        if (_tokenPath[_pairBinSteps.length] != IERC20(wavax))\n            revert LBRouter__InvalidTokenPath(address(_tokenPath[_pairBinSteps.length]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        amountOut = _swapExactTokensForTokens(_amountIn, _pairs, _pairBinSteps, _tokenPath, address(this));\n\n        if (_amountOutMinAVAX > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMinAVAX, amountOut);\n\n        wavax.withdraw(amountOut);\n        _safeTransferAVAX(_to, amountOut);\n    }\n\n    /// @notice Swaps exact AVAX for tokens while performing safety checks\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactAVAXForTokens(\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external payable override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        _wavaxDepositAndTransfer(_pairs[0], msg.value);\n\n        amountOut = _swapExactTokensForTokens(msg.value, _pairs, _pairBinSteps, _tokenPath, _to);\n\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Swaps tokens for exact tokens while performing safety checks\n    /// @param _amountOut The amount of token to receive\n    /// @param _amountInMax The max amount of token to send\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountsIn Input amounts for every step of the swap\n    function swapTokensForExactTokens(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256[] memory amountsIn) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n        amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);\n\n        if (amountsIn[0] > _amountInMax) revert LBRouter__MaxAmountInExceeded(_amountInMax, amountsIn[0]);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);\n\n        if (_amountOutReal < _amountOut) revert LBRouter__InsufficientAmountOut(_amountOut, _amountOutReal);\n    }\n\n    /// @notice Swaps tokens for exact AVAX while performing safety checks\n    /// @param _amountAVAXOut The amount of AVAX to receive\n    /// @param _amountInMax The max amount of token to send\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountsIn Input amounts for every step of the swap\n    function swapTokensForExactAVAX(\n        uint256 _amountAVAXOut,\n        uint256 _amountInMax,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256[] memory amountsIn) {\n        if (_tokenPath[_pairBinSteps.length] != IERC20(wavax))\n            revert LBRouter__InvalidTokenPath(address(_tokenPath[_pairBinSteps.length]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n        amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountAVAXOut);\n\n        if (amountsIn[0] > _amountInMax) revert LBRouter__MaxAmountInExceeded(_amountInMax, amountsIn[0]);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, address(this));\n\n        if (_amountOutReal < _amountAVAXOut) revert LBRouter__InsufficientAmountOut(_amountAVAXOut, _amountOutReal);\n\n        wavax.withdraw(_amountOutReal);\n        _safeTransferAVAX(_to, _amountOutReal);\n    }\n\n    /// @notice Swaps AVAX for exact tokens while performing safety checks\n    /// @dev will refund any excess sent\n    /// @param _amountOut The amount of tokens to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountsIn Input amounts for every step of the swap\n    function swapAVAXForExactTokens(\n        uint256 _amountOut,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        override\n        ensure(_deadline)\n        verifyInputs(_pairBinSteps, _tokenPath)\n        returns (uint256[] memory amountsIn)\n    {\n        if (_tokenPath[0] != IERC20(wavax)) revert LBRouter__InvalidTokenPath(address(_tokenPath[0]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n        amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);\n\n        if (amountsIn[0] > msg.value) revert LBRouter__MaxAmountInExceeded(msg.value, amountsIn[0]);\n\n        _wavaxDepositAndTransfer(_pairs[0], amountsIn[0]);\n\n        uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);\n\n        if (_amountOutReal < _amountOut) revert LBRouter__InsufficientAmountOut(_amountOut, _amountOutReal);\n\n        if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value);\n    }\n\n    /// @notice Swaps exact tokens for tokens while performing safety checks supporting for fee on transfer tokens\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        IERC20 _targetToken = _tokenPath[_pairs.length];\n\n        uint256 _balanceBefore = _targetToken.balanceOf(_to);\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        _swapSupportingFeeOnTransferTokens(_pairs, _pairBinSteps, _tokenPath, _to);\n\n        amountOut = _targetToken.balanceOf(_to) - _balanceBefore;\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Swaps exact tokens for AVAX while performing safety checks supporting for fee on transfer tokens\n    /// @param _amountIn The amount of token to send\n    /// @param _amountOutMinAVAX The min amount of AVAX to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMinAVAX,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address payable _to,\n        uint256 _deadline\n    ) external override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        if (_tokenPath[_pairBinSteps.length] != IERC20(wavax))\n            revert LBRouter__InvalidTokenPath(address(_tokenPath[_pairBinSteps.length]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        uint256 _balanceBefore = wavax.balanceOf(address(this));\n\n        _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], _amountIn);\n\n        _swapSupportingFeeOnTransferTokens(_pairs, _pairBinSteps, _tokenPath, address(this));\n\n        amountOut = wavax.balanceOf(address(this)) - _balanceBefore;\n        if (_amountOutMinAVAX > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMinAVAX, amountOut);\n\n        wavax.withdraw(amountOut);\n        _safeTransferAVAX(_to, amountOut);\n    }\n\n    /// @notice Swaps exact AVAX for tokens while performing safety checks supporting for fee on transfer tokens\n    /// @param _amountOutMin The min amount of token to receive\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _tokenPath The swap path using the binSteps following `_pairBinSteps`\n    /// @param _to The address of the recipient\n    /// @param _deadline The deadline of the tx\n    /// @return amountOut Output amount of the swap\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 _amountOutMin,\n        uint256[] memory _pairBinSteps,\n        IERC20[] memory _tokenPath,\n        address _to,\n        uint256 _deadline\n    ) external payable override ensure(_deadline) verifyInputs(_pairBinSteps, _tokenPath) returns (uint256 amountOut) {\n        if (_tokenPath[0] != IERC20(wavax)) revert LBRouter__InvalidTokenPath(address(_tokenPath[0]));\n\n        address[] memory _pairs = _getPairs(_pairBinSteps, _tokenPath);\n\n        IERC20 _targetToken = _tokenPath[_pairs.length];\n\n        uint256 _balanceBefore = _targetToken.balanceOf(_to);\n\n        _wavaxDepositAndTransfer(_pairs[0], msg.value);\n\n        _swapSupportingFeeOnTransferTokens(_pairs, _pairBinSteps, _tokenPath, _to);\n\n        amountOut = _targetToken.balanceOf(_to) - _balanceBefore;\n        if (_amountOutMin > amountOut) revert LBRouter__InsufficientAmountOut(_amountOutMin, amountOut);\n    }\n\n    /// @notice Unstuck tokens that are sent to this contract by mistake\n    /// @dev Only callable by the factory owner\n    /// @param _token The address of the token\n    /// @param _to The address of the user to send back the tokens\n    /// @param _amount The amount to send\n    function sweep(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyFactoryOwner {\n        if (address(_token) == address(0)) {\n            if (_amount == type(uint256).max) _amount = address(this).balance;\n            _safeTransferAVAX(_to, _amount);\n        } else {\n            if (_amount == type(uint256).max) _amount = _token.balanceOf(address(this));\n            _token.safeTransfer(_to, _amount);\n        }\n    }\n\n    /// @notice Unstuck LBTokens that are sent to this contract by mistake\n    /// @dev Only callable by the factory owner\n    /// @param _lbToken The address of the LBToken\n    /// @param _to The address of the user to send back the tokens\n    /// @param _ids The list of token ids\n    /// @param _amounts The list of amounts to send\n    function sweepLBToken(\n        ILBToken _lbToken,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    ) external override onlyFactoryOwner {\n        _lbToken.safeBatchTransferFrom(address(this), _to, _ids, _amounts);\n    }\n\n    /// @notice Helper function to add liquidity\n    /// @param _liq The liquidity parameter\n    /// @param _LBPair LBPair where liquidity is deposited\n    /// @return depositIds Bin ids where the liquidity was actually deposited\n    /// @return liquidityMinted Amounts of LBToken minted for each bin\n    function _addLiquidity(LiquidityParameters memory _liq, ILBPair _LBPair)\n        private\n        ensure(_liq.deadline)\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted)\n    {\n        unchecked {\n            if (_liq.deltaIds.length != _liq.distributionX.length && _liq.deltaIds.length != _liq.distributionY.length)\n                revert LBRouter__LengthsMismatch();\n\n            if (_liq.activeIdDesired > type(uint24).max || _liq.idSlippage > type(uint24).max)\n                revert LBRouter__IdDesiredOverflows(_liq.activeIdDesired, _liq.idSlippage);\n\n            (, , uint256 _activeId) = _LBPair.getReservesAndId();\n            if (\n                _liq.activeIdDesired + _liq.idSlippage < _activeId || _activeId + _liq.idSlippage < _liq.activeIdDesired\n            ) revert LBRouter__IdSlippageCaught(_liq.activeIdDesired, _liq.idSlippage, _activeId);\n\n            depositIds = new uint256[](_liq.deltaIds.length);\n            for (uint256 i; i < depositIds.length; ++i) {\n                int256 _id = int256(_activeId) + _liq.deltaIds[i];\n                if (_id < 0 || uint256(_id) > type(uint24).max) revert LBRouter__IdOverflows(_id);\n                depositIds[i] = uint256(_id);\n            }\n\n            uint256 _amountXAdded;\n            uint256 _amountYAdded;\n\n            (_amountXAdded, _amountYAdded, liquidityMinted) = _LBPair.mint(\n                depositIds,\n                _liq.distributionX,\n                _liq.distributionY,\n                _liq.to\n            );\n\n            if (_amountXAdded < _liq.amountXMin || _amountYAdded < _liq.amountYMin)\n                revert LBRouter__AmountSlippageCaught(_liq.amountXMin, _amountXAdded, _liq.amountYMin, _amountYAdded);\n        }\n    }\n\n    /// @notice Helper function to return the amounts in\n    /// @param _pairBinSteps The bin step of the pairs (0: V1, other values will use V2)\n    /// @param _pairs The list of pairs\n    /// @param _tokenPath The swap path\n    /// @param _amountOut The amount out\n    /// @return amountsIn The list of amounts in\n    function _getAmountsIn(\n        uint256[] memory _pairBinSteps,\n        address[] memory _pairs,\n        IERC20[] memory _tokenPath,\n        uint256 _amountOut\n    ) private view returns (uint256[] memory amountsIn) {\n        amountsIn = new uint256[](_tokenPath.length);\n        // Avoid doing -1, as `_pairs.length == _pairBinSteps.length-1`\n        amountsIn[_pairs.length] = _amountOut;\n\n        for (uint256 i = _pairs.length; i != 0; i--) {\n            IERC20 _token = _tokenPath[i - 1];\n            uint256 _binStep = _pairBinSteps[i - 1];\n\n            address _pair = _pairs[i - 1];\n\n            if (_binStep == 0) {\n                (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();\n                if (_token > _tokenPath[i]) {\n                    (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);\n                }\n\n                uint256 amountOut_ = amountsIn[i];\n                // Legacy uniswap way of rounding\n                amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) /"
    }
  ]
}