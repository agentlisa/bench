{
  "Title": "H-6: Lend or mint after maturity",
  "Content": "# Issue H-6: Lend or mint after maturity \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/208 \n\n## Found by \nHonorLt, kenzo, Holmgren\n\n## Summary\nThe protocol does not forbid lending or minting after the maturity leaving the possibility to profit from early users.\n\n## Vulnerability Detail\nLet's take the mint function as an example:\n```solidity\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) external unpaused(u, m, p) returns (bool) {\n        // Fetch the desired principal token\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer the users principal tokens to the lender contract\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n\n        // Mint the tokens received from the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n```\nIt is a simple function that accepts the principal token and mints the corresponding ERC5095 tokens in return. There are no restrictions on timing, the user can mint even after the maturity. Malicious actors can take this as an advantage to pump their bags on behalf of legitimate early users.\n\nScenario:\n1) Legitimate users lend and mint their ERC5095 tokens before maturity.\n2) When the maturity kicks in, lender tokens are redeemed and holdings are updated.\n3) Legitimate users try to redeem their ERC5095 for the underlying tokens. The formula is ```(amount * holdings[u][m]) / token.totalSupply();```\n4) A malicious actor sandwiches legitimate users, and mints the ERC5095 thus increasing the totalSupply and reducing other user shares. Then redeem principals again and burn their own shares for increased rewards.\n\nExample with concrete values:\n1) userA deposits ```100``` tokens, user B deposits ```200``` tokens. The total supply minted is ```300``` ERC5095 tokens.\n2) After the maturity the redemption happens and now let's say ```holdings[u][m]``` is ```330``` (+30).\n3) userA tries to redeem the underlying. The expected amount is: ```100 * 330 / 300 = 110```.\nHowever, this action is frontrunned by userC (malicious) who mints yet another ```500``` tokens post-maturity. The total supply becomes ```800```. The real value userA now receives is: ```110 * 330 / 800 = 45.375```.\n4) After that the malicious actor userC invokes the redemption again, and the ```holdings[u][m]``` is now ```330 - 45.375 + 550 = 834.625```.\n5) userC redeems the underlying: ```500 * 834.625 / 700 ~= 596.16``` (expected was ```550```).\n6) Now all the remaining users will also slightly benefit, e.g. in this case userB redeems what's left: ```200 * 238.46 / 200 = 238.46``` (expected was ```220```).\n\n## Impact\nThe amount legitimate users receive will be devaluated, while malicious actor can increase their ROI without meaningfully contributing to the protocol and locking their tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L264-L288\n\n## Tool used\n\nManual Review\n\n## Recommendation\nLend/mint should be forbidden post-maturity.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol'; // library of MarketPlace specific constructs\nimport 'src/lib/Swivel.sol'; // library of Swivel specific constructs\nimport 'src/lib/Element.sol'; // library of Element specific constructs\nimport 'src/lib/Safe.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusAMM.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/ISensePeriphery.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IElementVault.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/IAPWineRouter.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleToken.sol';\n\n/// @title Lender\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users\n/// @notice The contract holds the principal tokens and mints an ERC-5095 tokens to users to represent their loans\ncontract Lender {\n    /// @notice minimum wait before the admin may withdraw funds or change the fee rate\n    uint256 public constant HOLD = 3 days;\n\n    /// @notice address that is allowed to set and withdraw fees, disable principals, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal token has been paused by the admin\n    mapping(address => mapping(uint256 => bool[9])) public paused;\n\n    /// @notice contract used to execute swaps on Swivel's exchange\n    address public immutable swivelAddr;\n    /// @notice a SushiSwap router used by Pendle to execute swaps\n    address public immutable pendleAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public constant MIN_FEENOMINATOR = 500;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping(address => uint256) public withdrawals;\n\n    /// @notice emitted upon lending to a protocol\n    event Lend(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 returned,\n        uint256 spent,\n        address sender\n    );\n    /// @notice emitted upon minting Illuminate principal tokens\n    event Mint(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount\n    );\n    /// @notice emitted upon scheduling a withdrawal\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted upon blocking a scheduled withdrawal\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n    /// @notice emitted upon scheduling a fee change\n    event ScheduleFeeChange(uint256 when);\n    /// @notice emitted upon blocking a scheduled fee change\n    event BlockFeeChange();\n    /// @notice emitted upon pausing or unpausing of a principal token\n    event PauseMarket(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        address token,\n        bool indexed state\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    modifier unpaused(\n        address u,\n        uint256 m,\n        uint8 p\n    ) {\n        if (paused[u][m][p]) {\n            revert Exception(1, p, 0, address(0), address(0));\n        }\n        _;\n    }\n\n    /// @notice initializes the Lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    constructor(address s, address p) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // approve the underlying for max per given principal\n        for (uint8 i; i != 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).token(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses.\n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        for (uint256 i; i != u.length; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice approves market contracts that require lender approval\n    /// @param u address of an underlying asset\n    /// @param a APWine's router contract\n    /// @param e Element's vault contract\n    /// @param n Notional's token contract\n    function approve(\n        address u,\n        address a,\n        address e,\n        address n\n    ) external authorized(marketPlace) {\n        uint256 max = type(uint256).max;\n        IERC20 uToken = IERC20(u);\n        if (a != address(0)) {\n            Safe.approve(uToken, a, max);\n        }\n        if (e != address(0)) {\n            Safe.approve(uToken, e, max);\n        }\n        if (n != address(0)) {\n            Safe.approve(uToken, n, max);\n        }\n        if (IERC20(u).allowance(address(this), swivelAddr) == 0) {\n            Safe.approve(uToken, swivelAddr, max);\n        }\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (block.timestamp < feeTime) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for Illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on Illuminate\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) external unpaused(u, m, p) returns (bool) {\n        // Fetch the desired principal token\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer the users principal tokens to the lender contract\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n\n        // Mint the tokens received from the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method for the Illuminate and Yield protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y Yield Space Pool for the principal token\n    /// @param minimum slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y,\n        uint256 minimum\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Check that the principal is Illuminate or Yield\n        if (\n            p != uint8(MarketPlace.Principals.Illuminate) &&\n            p != uint8(MarketPlace.Principals.Yield)\n        ) {\n            revert Exception(6, 0, 0, address(0), address(0));\n        }\n\n        // Get principal token for this market\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Extract fee\n        fees[u] = fees[u] + a / feenominator;\n\n        // Transfer underlying from user to the lender contract\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Make sure the Yield Space Pool matches principal token\n            address fyToken = IYield(y).fyToken();\n            if (IYield(y).fyToken() != principal) {\n                revert Exception(12, 0, 0, fyToken, principal);\n            }\n        }\n\n        // Swap underlying for PTs to lender\n        uint256 returned = yield(\n            u,\n            y,\n            a - a / feenominator,\n            address(this),\n            principal,\n            minimum\n        );\n\n        // Mint Illuminate PTs to msg.sender\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n\n        return returned;\n    }\n\n    /// @notice lend method signature for Swivel\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y Yield Space Pool for the Illuminate PT in this market\n    /// @param o array of Swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @param e flag to indicate if returned funds should be swapped in Yield Space Pool\n    /// @param premiumSlippage slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s,\n        bool e,\n        uint256 premiumSlippage\n    ) external unpaused(u, m, p) returns (uint256) {\n        {\n            // Check that the principal is Swivel\n            if (p != uint8(MarketPlace.Principals.Swivel)) {\n                revert Exception(\n                    6,\n                    p,\n                    uint8(MarketPlace.Principals.Swivel),\n                    address(0),\n                    address(0)\n                );\n            }\n\n            // Lent represents the total amount of underlying to be lent\n            uint256 lent = swivelAmount(a);\n\n            // Transfer underlying token from user to Illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n\n            // Get the underlying balance prior to calling initiate\n            uint256 starting = IERC20(u).balanceOf(address(this));\n\n            // Verify and collect the fee\n            {\n                // Calculate fee for the total amount to be lent\n                uint256 fee = lent / feenominator;\n\n                // Get last order to be processed's index\n                uint256 lastIndex = a.length - 1;\n\n                // Add the accumulated fees to the total\n                a[lastIndex] = a[lastIndex] - fee; // Revert here if fee not paid\n\n                // Extract fee\n                fees[u] += fee;\n            }\n\n            uint256 received;\n            {\n                // Get the starting amount of principal tokens\n                uint256 startingZcTokens = IERC20(\n                    IMarketPlace(marketPlace).token(u, m, p)\n                ).balanceOf(address(this));\n\n                // Fill the given orders on Swivel\n                ISwivel(swivelAddr).initiate(o, a, s);\n\n                if (e) {\n                    // Calculate the premium\n                    uint256 premium = IERC20(u).balanceOf(address(this)) -\n                        starting;\n\n                    // Swap the premium for Illuminate principal tokens\n                    swivelLendPremium(u, m, y, premium, premiumSlippage);\n                }\n\n                // Compute how many principal tokens were received\n                received =\n                    IERC20(IMarketPlace(marketPlace).token(u, m, p)).balanceOf(\n                        address(this)\n                    ) -\n                    startingZcTokens;\n            }\n\n            // Mint Illuminate principal tokens to the user\n            IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n            {\n                emit Lend(\n                    uint8(MarketPlace.Principals.Swivel),\n                    u,\n                    m,\n                    received,\n                    lent,\n                    msg.sender\n                );\n            }\n            return received;\n        }\n    }\n\n    /// @notice lend method signature for Element\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param e Element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Get the principal token for this market for Element\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer underlying token from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] = fees[u] + a / feenominator;\n\n        uint256 purchased;\n        {\n            // Calculate the amount to be lent\n            uint256 lent = a - a / feenominator;\n\n            // Create the variables needed to execute an Element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                poolId: i,\n                amount: lent,\n                kind: Element.SwapKind.GIVEN_IN,\n                assetIn: IAny(u),\n                assetOut: IAny(principal),\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000'\n            });\n\n            // Conduct the swap on Element\n            purchased = elementSwap(e, swap, fund, r, d);\n        }\n\n        // Mint tokens to the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, purchased);\n\n        emit Lend(p, u, m, purchased, a, msg.sender);\n        return purchased;\n    }\n\n    /// @notice lend method signature for Pendle\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(\n                a - fee,\n                r,\n                path,\n                address(this),\n                d\n            )[1];\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n        return returned;\n    }\n\n    /// @notice lend method signature for APWine\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x APWine router that executes the swap\n    /// @param pool the AMM pool used by APWine to execute the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x,\n        address pool\n    ) external unpaused(u, m, p) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting APWine token balance\n        uint256 starting = IERC20(principal).balanceOf(address(this));\n\n        // Swap on the APWine Pool using the provided market and params\n        IAPWineRouter(x).swapExactAmountIn(\n            pool,\n            apwinePairPath(),\n            apwineTokenPath(),\n            lent,\n            r,\n            address(this),\n            d,\n            address(0)\n        );\n\n        // Calculate the amount of APWine principal tokens received after the swap\n        uint256 received = IERC20(principal).balanceOf(address(this)) -\n            starting;\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice lend method signature for Tempus\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x Tempus AMM that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x\n    ) external unpaused(u, m, p) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting balance of the principal token\n        uint256 start = IERC20(principal).balanceOf(address(this));\n\n        // Get the Tempus Router from the principal token\n        address controller = ITempusPool(ITempusToken(principal).pool())\n            .controller();\n\n        // Swap on the Tempus Router using the provided market and params\n        ITempus(controller).depositAndFix(x, lent, true, r, d);\n\n        // Calculate the amount of Tempus principal tokens received after the deposit\n        uint256 received = IERC20(principal).balanceOf(address(this)) - start;\n\n        // Verify that a minimum number of principal tokens were received\n        if (received < r) {\n            revert Exception(11, received, r, address(0), address(0));\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice lend method signature for Sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev Sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param x AMM that is used to conduct the swap\n    /// @param s Sense's maturity for the given market\n    /// @param adapter Sense's adapter necessary to facilitate the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        uint256 s,\n        address adapter\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Retrieve the principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Determine the fee\n        uint256 fee = a / feenominator;\n\n        // Add the accumulated fees to the total\n        fees[u] = fees[u] + fee;\n\n        // Determine lent amount after fees\n        uint256 lent = a - fee;\n\n        // Stores the amount of principal tokens received in swap for underlying\n        uint256 received;\n        {\n            // Get the starting balance of the principal token\n            uint256 starting = token.balanceOf(address(this));\n\n            // Swap those tokens for the principal tokens\n            ISensePeriphery(x).swapUnderlyingForPTs(adapter, s, lent, r);\n\n            // Calculate number of principal tokens received in the swap\n            received = token.balanceOf(address(this)) - starting;\n\n            // Verify that we received the principal tokens\n            if (received < r) {\n                revert Exception(11, 0, 0, address(0), address(0));\n            }\n        }\n\n        // Mint the Illuminate tokens based on the returned amount\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @dev lend method signature for Notional\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Instantiate Notional princpal token\n        address token = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = a / feenominator;\n        fees[u] = fees[u] + fee;\n\n        // Swap on the Notional Token wrapper\n        uint256 received = INotional(token).deposit(a - fee, address(this));\n\n        // Verify that we received the principal tokens\n        if (received < r) {\n            revert Exception(16, received, r, address(0), address(0));\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice allows the admin to schedule the withdrawal of tokens\n    /// @param e address of (erc20) token to withdraw\n    /// @return bool true if successful\n    function scheduleWithdrawal(address e)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        uint256 when = block.timestamp + HOLD;\n\n        withdrawals[e] = when;\n\n        emit ScheduleWithdrawal(e, when);\n        return true;\n    }\n\n    /// @notice emergency function to block unplanned withdrawals\n    /// @param e address of token withdrawal to block\n    /// @return bool true if successful\n    function blockWithdrawal(address e)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        delete withdrawals[e];\n\n        emit BlockWithdrawal(e);\n        return true;\n    }\n\n    /// @notice allows the admin to schedule a change to the fee denominators\n    function scheduleFeeChange() external authorized(admin) returns (bool) {\n        uint256 when = block.timestamp + HOLD;\n        feeChange = when;\n\n        emit ScheduleFeeChange(when);\n\n        return true;\n    }\n\n    /// @notice Emergency function to block unplanned changes to fee structure\n    function blockFeeChange() external authorized(admin) returns (bool) {\n        delete feeChange;\n\n        emit BlockFeeChange();\n\n        return true;\n    }\n\n    /// @notice allows the admin to withdraw the given token, provided the holding period has been observed\n    /// @param e Address of token to withdraw\n    /// @return bool true if successful\n    function withdraw(address e) external authorized(admin) returns (bool) {\n        uint256 when = withdrawals[e];\n        if (when == 0) {\n            revert Exception(18, 0, 0, address(0), address(0));\n        }\n\n        if (block.timestamp < when) {\n            revert Exception(19, 0, 0, address(0), address(0));\n        }\n\n        delete withdrawals[e];\n\n        delete fees[e];\n\n        IERC20 token = IERC20(e);\n        Safe.transfer(token, admin, token.balanceOf(address(this)));\n\n        return true;\n    }\n\n    /// @notice withdraws accumulated lending fees of the underlying token\n    /// @param e address of the underlying token to withdraw\n    /// @return bool true if successful\n    function withdrawFee(address e) external authorized(admin) returns (bool) {\n        // Get the token to be withdrawn\n        IERC20 token = IERC20(e);\n\n        // Get the balance to be transferred\n        uint256 balance = fees[e];\n\n        // Reset accumulated fees of the token to 0\n        fees[e] = 0;\n\n        // Transfer the accumulated fees to the admin\n        Safe.transfer(token, admin, balance);\n\n        return true;\n    }\n\n    /// @notice pauses a market and prevents execution of all lending for that principal\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param b bool representing whether to pause or unpause\n    /// @return bool true if successful\n    function pause(\n        address u,\n        uint256 m,\n        uint8 p,\n        bool b\n    ) external authorized(admin) returns (bool) {\n        paused[u][m][p] = b;\n        emit PauseMarket(p, u, m, IMarketPlace(marketPlace).token(u, m, p), b);\n        return true;\n    }\n\n    /// @notice Tranfers FYTs for APWine redemptions\n    /// @param f FYT contract address\n    /// @param a amount of tokens to send to the redeemer\n    function transferFYTs(address f, uint256 a)\n        external\n        authorized(IMarketPlace(marketPlace).redeemer())\n    {\n        Safe.transfer(IERC20(f), IMarketPlace(marketPlace).redeemer(), a);\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param c An array of inputs for each call.\n    function batch(bytes[] calldata c)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](c.length);\n\n        for (uint256 i; i < c.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                c[i]\n            );\n\n            if (!success) revert(RevertMsgE"
    }
  ]
}