{
  "Title": "Lack of event emission in transferFromPreSigned function of ERC865Token contract",
  "Content": "The [`ERC865Token`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol) contract’s purpose is to extend ERC20 `transfer` and `transferFrom` operations with pre-signed transfers of tokens. This is achieved via the [`transferPreSigned`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L30) and [`transferFromPreSigned`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L187) public functions.\n\n\nAdditionally, a new event called [`TransferPreSigned`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L20) takes care of logging pre-signed transfers . Even though this event is [properly emitted](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L56) after a successful `transferPreSigned` operation, `TransferPreSigned` [is not emitted](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L215) before the execution of the `transferFromPreSigned` function is completed, which may be difficult tracking this operation via event logs.\n\n\nTo favor consistency and operations traceability, and taking into account that the counterpart ERC20 `transferFrom` [does emit](https://github.com/OpenZeppelin/openzeppelin-eth/blob/b047d28476e274bca2a6091c280a7f55afe74e10/contracts/token/ERC20/ERC20.sol#L165) a `Transfer` event, consider emitting a `TransferPreSigned` event after a `transferFromPreSigned` operation is successfully registered.\n\n\n***Update:*** *Fixed. The* [*`transferFromPreSigned`*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol#L220) [*function now emits the*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol#L220) [*`TransferPreSigned`*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol#L220) [*event*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol#L220)*.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/ERC865Token.sol",
      "content": "pragma solidity ^0.4.24;\n\n// import \"zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\";\n// import \"openzeppelin-eth/contracts/token/ERC20/ERC20.sol\";\nimport \"./ERC865.sol\";\n\n/**\n * @title ERC865Token Token\n *\n * ERC865Token allows users paying transfers in tokens instead of gas\n * https://github.com/ethereum/EIPs/issues/865\n *\n */\n\ncontract ERC865Token is ERC865 {\n\n    /* Nonces of transfers performed */\n    mapping(bytes => bool) signatures;\n\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    event ApprovalPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    /**\n     * @notice Submit a presigned transfer\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSigned(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {        \n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);\n\n        address from = recover(hashedTx, _signature);     \n        require(from != address(0));\n        _transfer(from, _to, _value);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_value).sub(_fee);\n        // _balances[_to] = _balances[_to].add(_value);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(from, _to, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Submit a presigned approval\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = approvePreSignedHashing(address(this), _spender, _value, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, _value);\n        // _allowed[from][_spender] = _value;\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Increase the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, allowance(from, _spender).add(_addedValue));\n        // _allowed[from][_spender] = _allowed[from][_spender].add(_addedValue);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _allowed[from][_spender]);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Decrease the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner\n     * @param _spender address The address which will spend the funds.\n     * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function decreaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n\n        uint oldValue = allowance(from, _spender);\n        if (_subtractedValue > oldValue) {\n            _approve(from, _spender, 0);\n            // _allowed[from][_spender] = 0;\n        } else {\n            _approve(from, _spender, allowance(from,_spender).sub(_subtractedValue));\n            // _allowed[from][_spender] = oldValue.sub(_subtractedValue);\n        }\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _subtractedValue);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another\n     * @param _signature bytes The signature, issued by the spender.\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSigned(\n        bytes _signature,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferFromPreSignedHashing(address(this), _from, _to, _value, _fee, _nonce);\n\n        address spender = recover(hashedTx, _signature);\n        require(spender != address(0));\n\n        _transfer(_from, _to, _value);\n        // _balances[_from] = _balances[_from].sub(_value);\n        // _balances[_to] = _balances[_to].add(_value);\n        _approve(_from, spender, allowance(_from, spender).sub(_value));\n        // _allowed[_from][spender] = _allowed[_from][spender].sub(_value);\n        _transfer(spender, msg.sender, _fee);\n        // _balances[spender] = _balances[spender].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(_from, _to, _value);\n        // Transfer(spender, msg.sender, _fee);\n        return true;\n    }\n\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferPreSigned\n     * @param _token address The address of the token.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSignedHashing(\n        address _token,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"48664c16\": transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by approvePreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"f7ac9c2e\": approvePreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by increaseApprovalPreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"a45f71ff\": increaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xa45f71ff), _token, _spender, _addedValue, _fee, _nonce));\n    }\n\n     /**\n      * @notice Hash (keccak256) of the payload used by decreaseApprovalPreSigned\n      * @param _token address The address of the token\n      * @param _spender address The address which will spend the funds.\n      * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n      * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n      * @param _nonce uint256 Presigned transaction number.\n      */\n    function decreaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"59388d78\": decreaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x59388d78), _token, _spender, _subtractedValue, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferFromPreSigned\n     * @param _token address The address of the token\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSignedHashing(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"b7656dc5\": transferFromPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xb7656dc5), _token, _from, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Recover signer address from a message by using his signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes sig) public pure returns (address) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n\n      //Check the signature length\n      if (sig.length != 65) {\n        return (address(0));\n      }\n\n      // Divide the signature in r, s and v variables\n      assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n      }\n\n    //   // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    //    if (v < 27) {\n    //         v += 27;\n    //    }\n\n      // If the version is correct return the signer address\n      if (v != 27 && v != 28) {\n        return (address(0));\n      } else {\n        return ecrecover(hash, v, r, s);\n      }\n    }\n\n}"
    },
    {
      "filename": "contracts/token/ERC20/ERC20.sol",
      "content": "pragma solidity ^0.4.24;\n\nimport \"zos-lib/contracts/Initializable.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract ERC20 is Initializable, IERC20 {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param owner address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address owner,\n    address spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) public returns (bool) {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    public\n    returns (bool)\n  {\n    require(value <= _allowed[from][msg.sender]);\n\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    _transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n  * @dev Transfer token for a specified addresses\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function _transfer(address from, address to, uint256 value) internal {\n    require(value <= _balances[from]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(from, to, value);\n  }\n\n  /**\n   * @dev Internal function that mints an amount of the token and assigns it to\n   * an account. This encapsulates the modification of balances such that the\n   * proper events are emitted.\n   * @param account The account that will receive the created tokens.\n   * @param amount The amount that will be created.\n   */\n  function _mint(address account, uint256 amount) internal {\n    require(account != 0);\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Internal function that burns an amount of the token of a given\n   * account.\n   * @param account The account whose tokens will be burnt.\n   * @param amount The amount that will be burnt.\n   */\n  function _burn(address account, uint256 amount) internal {\n    require(account != 0);\n    require(amount <= _balances[account]);\n\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[account] = _balances[account].sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Internal function that burns an amount of the token of a given\n   * account, deducting from the sender's allowance for said account. Uses the\n   * internal burn function.\n   * @param account The account whose tokens will be burnt.\n   * @param amount The amount that will be burnt.\n   */\n  function _burnFrom(address account, uint256 amount) internal {\n    require(amount <= _allowed[account][msg.sender]);\n\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n    // this function needs to emit an event with the updated approval.\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n      amount);\n    _burn(account, amount);\n  }\n\n  uint256[50] private ______gap;\n}"
    },
    {
      "filename": "contracts/token/ERC865Token.sol",
      "content": "pragma solidity ^0.4.24;\n\nimport \"zos-lib/contracts/Initializable.sol\";\nimport { ECDSA } from \"openzeppelin-eth/contracts/cryptography/ECDSA.sol\";\nimport \"./IERC865.sol\";\n\n/**\n * @title ERC865Token Token\n *\n * ERC865Token allows users paying transfers in tokens instead of gas\n * https://github.com/ethereum/EIPs/issues/865\n *\n */\n\ncontract ERC865Token is Initializable, IERC865 {\n\n    /* hashed tx of transfers performed */\n    mapping(bytes32 => bool) hashedTxs;    \n    /**\n     * @dev Submit a presigned transfer\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSigned(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {        \n        require(_to != address(0), \n        \"Invalid _to address\"\n        );        \n\n        bytes32 hashedParams = getTransferPreSignedHash(address(this), _to, _value, _fee, _nonce);\n        address from = ECDSA.recover(hashedParams, _signature);     \n        require(from != address(0), \n        \"Invalid from address recovered\"\n        );\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false,\n        \"Transaction hash was already used\"\n        );\n        hashedTxs[hashedTx] = true;\n        _transfer(from, _to, _value);\n        _transfer(from, msg.sender, _fee);\n\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @dev Submit a presigned approval\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0),\n        \"Invalid _spender address\"\n        );        \n\n        bytes32 hashedParams = getApprovePreSignedHash(address(this), _spender, _value, _fee, _nonce);\n        address from = ECDSA.recover(hashedParams, _signature);\n        require(from != address(0),\n        \"Invalid from address recovered\"\n        );\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false,\n        \"Transaction hash was already used\"\n        );\n        hashedTxs[hashedTx] = true;\n        _approve(from, _spender, _value);        \n        _transfer(from, msg.sender, _fee);        \n        \n        emit ApprovalPreSigned(from, _spender, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseAllowancePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0),\n        \"Invalid _spender address\"\n        );        \n\n        bytes32 hashedParams = getIncreaseAllowancePreSignedHash(address(this), _spender, _addedValue, _fee, _nonce);\n        address from = ECDSA.recover(hashedParams, _signature);\n        require(from != address(0),\n        \"Invalid from address recovered\"\n        );\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false,\n        \"Transaction hash was already used\"\n        );\n        hashedTxs[hashedTx] = true;\n        _approve(from, _spender, allowance(from, _spender).add(_addedValue));        \n        _transfer(from, msg.sender, _fee);        \n        \n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\n     * @param _signature bytes The signature, issued by the owner\n     * @param _spender address The address which will spend the funds.\n     * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function decreaseAllowancePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0),\n        \"Invalid _spender address\"\n        );              \n\n        bytes32 hashedParams = getDecreaseAllowancePreSignedHash(address(this), _spender, _subtractedValue, _fee, _nonce);\n        address from = ECDSA.recover(hashedParams, _signature);\n        require(from != address(0),\n        \"Invalid from address recovered\"\n        );\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false,\n        \"Transaction hash was already used\"\n        );        \n        // if substractedValue is greater than allowance will fail as allowance is uint256\n        hashedTxs[hashedTx] = true;\n        _approve(from, _spender, allowance(from,_spender).sub(_subtractedValue));            \n        _transfer(from, msg.sender, _fee);                \n\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\n     * @param _signature bytes The signature, issued by the spender.\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSigned(\n        bytes _signature,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0),\n        \"Invalid _to address\"\n        );        \n\n        bytes32 hashedParams = getTransferFromPreSignedHash(address(this), _from, _to, _value, _fee, _nonce);\n\n        address spender = ECDSA.recover(hashedParams, _signature);\n        require(spender != address(0),\n        \"Invalid spender address recovered\"\n        );\n        bytes32 hashedTx = keccak256(abi.encodePacked(spender, hashedParams));\n        require(hashedTxs[hashedTx] == false,\n        \"Transaction hash was already used\"\n        );\n        hashedTxs[hashedTx] = true;\n        _transfer(_from, _to, _value);        \n        _approve(_from, spender, allowance(_from, spender).sub(_value));        \n        _transfer(spender, msg.sender, _fee);        \n        \n        emit TransferPreSigned(_from, _to, msg.sender, _value, _fee);\n        return true;\n    }\n\n\n    /**\n     * @dev Hash (keccak256) of the payload used by transferPreSigned\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\n     * @param _token address The address of the token.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function getTransferPreSignedHash(\n        address _token,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"0d98dcb1\": getTransferPreSignedHash(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x0d98dcb1), _token, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @dev Hash (keccak256) of the payload used by approvePreSigned\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function getApprovePreSignedHash(\n        address _token,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"79250dcf\": getApprovePreSignedHash(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x79250dcf), _token, _spender, _value, _fee, _nonce));\n    }\n\n    /**\n     * @dev Hash (keccak256) of the payload used by increaseAllowancePreSigned\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function getIncreaseAllowancePreSignedHash(\n        address _token,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"138e8da1\": getIncreaseAllowancePreSignedHash(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x138e8da1), _token, _spender, _addedValue, _fee, _nonce));\n    }\n\n     /**\n      * @dev Hash (keccak256) of the payload used by decreaseAllowancePreSigned\n      * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\n      * @param _token address The address of the token\n      * @param _spender add"
    }
  ]
}