{
  "Title": "Missing error messages in require statements",
  "Content": "There are [several](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L40) [`require`](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L40) [statements](https://github.com/propsproject/props-token-distribution/blob/eaf0c6fddd320a258a9d7531d72d07a830fae58a/contracts/token/ERC865Token.sol#L40) in the `ERC865Token` contract without error messages. Consider including specific and informative error messages in all require statements.\n\n\n***Update:*** *Fixed. All the* *`require`* *statements of the* [*`ERC865Token`*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol) [*contract*](https://github.com/propsproject/props-token-distribution/blob/7ead8c55da3770c4d39db8c89a8aa20ec62e97b1/contracts/token/ERC865Token.sol) *now have an error message.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/ERC865Token.sol",
      "content": "pragma solidity ^0.4.24;\n\n// import \"zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\";\n// import \"openzeppelin-eth/contracts/token/ERC20/ERC20.sol\";\nimport \"./ERC865.sol\";\n\n/**\n * @title ERC865Token Token\n *\n * ERC865Token allows users paying transfers in tokens instead of gas\n * https://github.com/ethereum/EIPs/issues/865\n *\n */\n\ncontract ERC865Token is ERC865 {\n\n    /* Nonces of transfers performed */\n    mapping(bytes => bool) signatures;\n\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    event ApprovalPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\n    /**\n     * @notice Submit a presigned transfer\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSigned(\n        bytes _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {        \n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);\n\n        address from = recover(hashedTx, _signature);     \n        require(from != address(0));\n        _transfer(from, _to, _value);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_value).sub(_fee);\n        // _balances[_to] = _balances[_to].add(_value);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(from, _to, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Submit a presigned approval\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = approvePreSignedHashing(address(this), _spender, _value, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, _value);\n        // _allowed[from][_spender] = _value;\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _value);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, _value, _fee);\n        return true;\n    }\n\n    /**\n     * @notice Increase the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner.\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n        _approve(from, _spender, allowance(from, _spender).add(_addedValue));\n        // _allowed[from][_spender] = _allowed[from][_spender].add(_addedValue);\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _allowed[from][_spender]);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Decrease the amount of tokens that an owner allowed to a spender.\n     * @param _signature bytes The signature, issued by the owner\n     * @param _spender address The address which will spend the funds.\n     * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function decreaseApprovalPreSigned(\n        bytes _signature,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_spender != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);\n        address from = recover(hashedTx, _signature);\n        require(from != address(0));\n\n        uint oldValue = allowance(from, _spender);\n        if (_subtractedValue > oldValue) {\n            _approve(from, _spender, 0);\n            // _allowed[from][_spender] = 0;\n        } else {\n            _approve(from, _spender, allowance(from,_spender).sub(_subtractedValue));\n            // _allowed[from][_spender] = oldValue.sub(_subtractedValue);\n        }\n        _transfer(from, msg.sender, _fee);\n        // _balances[from] = _balances[from].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Approval(from, _spender, _subtractedValue);\n        // Transfer(from, msg.sender, _fee);\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another\n     * @param _signature bytes The signature, issued by the spender.\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSigned(\n        bytes _signature,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(signatures[_signature] == false);\n\n        bytes32 hashedTx = transferFromPreSignedHashing(address(this), _from, _to, _value, _fee, _nonce);\n\n        address spender = recover(hashedTx, _signature);\n        require(spender != address(0));\n\n        _transfer(_from, _to, _value);\n        // _balances[_from] = _balances[_from].sub(_value);\n        // _balances[_to] = _balances[_to].add(_value);\n        _approve(_from, spender, allowance(_from, spender).sub(_value));\n        // _allowed[_from][spender] = _allowed[_from][spender].sub(_value);\n        _transfer(spender, msg.sender, _fee);\n        // _balances[spender] = _balances[spender].sub(_fee);\n        // _balances[msg.sender] = _balances[msg.sender].add(_fee);\n        signatures[_signature] = true;\n\n        // Transfer(_from, _to, _value);\n        // Transfer(spender, msg.sender, _fee);\n        return true;\n    }\n\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferPreSigned\n     * @param _token address The address of the token.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferPreSignedHashing(\n        address _token,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"48664c16\": transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by approvePreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _value uint256 The amount of tokens to allow.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function approvePreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"f7ac9c2e\": approvePreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by increaseApprovalPreSigned\n     * @param _token address The address of the token\n     * @param _spender address The address which will spend the funds.\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function increaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _addedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"a45f71ff\": increaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xa45f71ff), _token, _spender, _addedValue, _fee, _nonce));\n    }\n\n     /**\n      * @notice Hash (keccak256) of the payload used by decreaseApprovalPreSigned\n      * @param _token address The address of the token\n      * @param _spender address The address which will spend the funds.\n      * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\n      * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n      * @param _nonce uint256 Presigned transaction number.\n      */\n    function decreaseApprovalPreSignedHashing(\n        address _token,\n        address _spender,\n        uint256 _subtractedValue,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"59388d78\": decreaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0x59388d78), _token, _spender, _subtractedValue, _fee, _nonce));\n    }\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferFromPreSigned\n     * @param _token address The address of the token\n     * @param _from address The address which you want to send tokens from.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\n     * @param _nonce uint256 Presigned transaction number.\n     */\n    function transferFromPreSignedHashing(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        /* \"b7656dc5\": transferFromPreSignedHashing(address,address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encodePacked(bytes4(0xb7656dc5), _token, _from, _to, _value, _fee, _nonce));\n    }\n\n    /**\n     * @notice Recover signer address from a message by using his signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes sig) public pure returns (address) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n\n      //Check the signature length\n      if (sig.length != 65) {\n        return (address(0));\n      }\n\n      // Divide the signature in r, s and v variables\n      assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n      }\n\n    //   // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n    //    if (v < 27) {\n    //         v += 27;\n    //    }\n\n      // If the version is correct return the signer address\n      if (v != 27 && v != 28) {\n        return (address(0));\n      } else {\n        return ecrecover(hash, v, r, s);\n      }\n    }\n\n}"
    }
  ]
}