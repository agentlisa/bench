{
  "Title": "Use of send and call",
  "Content": "Use of **send** and **call** primitives is always risky and should be analyzed in detail. One occurrence of call found [in line 91 of Fundraiser.sol](https://github.com/cosmos/fundraiser-lib/blob/693cf3f32e9fd679216372876dda86fa57a3277e/src/truffle/contracts/Fundraiser.sol#L91).\n\n\nRemove unneeded `call.value()`\n\n\nUsing `call.value()` [is potentially dangerous, and was responsible for the TheDAO hack](https://ethereum.stackexchange.com/questions/6391/what-does-call-value-mean-and-how-did-it-allow-the-attack-to-the-dao). We couldn’t find a reason to use `treasury.call.value(msg.value)()` instead of the simpler`treasury.send(msg.value)`. We recommend making this change.\n\n\nFor more info on this problem, [see this note](https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send%28%29-in-Ethereum-&-Solidity#abuse).\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/truffle/contracts/Fundraiser.sol",
      "content": "//! Fundraiser contract. Just records who sent what.\n//! By Parity Technologies, 2017.\n//! Released under the Apache Licence 2.\n//! Modified by the Interchain Foundation.\n\npragma solidity ^0.4.7;\n\n/// Will accept Ether \"contributions\" and record each both as a log and in a\n/// queryable record.\ncontract Fundraiser {\n\n\n    // How much is enough?\n    uint public constant dust = 1 finney; // XXX: change for production\n\n\n    // Special addresses: \n    //  administrator can halt/unhalt/kill/adjustRate;\n    //  treasury receives all the funds\n    address public admin;\n    address public treasury;\n\n    // Begin and end block for the fundraising period\n    uint public beginBlock;\n    uint public endBlock;\n\n    // Number of atoms per ether.\n    // Correspondingly, number of 10^(-18)atoms per wei\n    uint public atomRate; \n\n    // Are contributions abnormally halted?\n    bool public isHalted = false;\n\n    // The record maps cosmos addresses to the product of their donation amount and the current atomRate.\n    // The returns maps cosmos addresses to their ethereum return addresses.\n    // NOTE: We could use a struct instead but would currently\n    // save only one SSLOAD/SSTORE and at the expense\n    // of relying on solidity type packing :o !\n    mapping (address => uint) public record;\n    mapping (address => address) public returnAddresses;\n\n    // The total amount of ether raised\n    uint public totalEther = 0;\n    // The total amount of atoms suggested for allocation\n    uint public totalAtom = 0;\n\n    /// Constructor. `_admin` has the ability to pause the\n    /// contribution period and, eventually, kill this contract. `_treasury`\n    /// receives all funds. `_beginBlock` and `_endBlock` define the begin and\n    /// end of the period. `_atomRate` is the ratio of atoms to ether.\n    function Fundraiser(address _admin, address _treasury, uint _beginBlock, uint _endBlock, uint _atomRate) {\n        admin = _admin;\n        treasury = _treasury;\n        beginBlock = _beginBlock;\n        endBlock = _endBlock;\n\tatomRate = _atomRate;\n    }\n\n    // Can only be called by _admin.\n    modifier only_admin { if (msg.sender != admin) throw; _; }\n    // Can only be called by prior to the period.\n    modifier only_before_period { if (block.number >= beginBlock) throw; _; }\n    // Can only be called during the period when not halted.\n    modifier only_during_period { if (block.number < beginBlock || block.number >= endBlock || isHalted) throw; _; }\n    // Can only be called during the period when halted.\n    modifier only_during_halted_period { if (block.number < beginBlock || block.number >= endBlock || !isHalted) throw; _; }\n    // Can only be called after the period.\n    modifier only_after_period { if (block.number < endBlock) throw; _; }\n    // The value of the message must be sufficiently large to not be considered dust.\n    modifier is_not_dust { if (msg.value < dust) throw; _; }\n\n    /// Some contribution `amount` received from `recipient` at rate of `currentRate`.\n    event Received(address indexed recipient, uint amount, uint currentRate);\n    /// Period halted abnormally.\n    event Halted();\n    /// Period restarted after abnormal halt.\n    event Unhalted();\n\n    /// Fallback function throws. Successful donation requires arguments\n    function() {\n\tthrow;\n    }\n\n    /// Receive a contribution for a donor cosmos address.\n    /// Also store returnAddress just-in-case.\n    function donate(address _donor, address _returnAddress, bytes32 checksum) payable only_during_period is_not_dust {\n\t// checksum is the sha3 of the xor of the bytes32 versions of the cosmos address and the return address\n\tif (!(sha3(bytes32(_donor)^bytes32(_returnAddress)) == checksum)) throw;\n\n\t// forward the funds to the treasurer\n        if (!treasury.call.value(msg.value)()) throw;\n\n\t// calculate the number of atoms at the current rate\n\tvar atoms = msg.value * atomRate;\n\n\t// update the donor details\n        record[_donor] += atoms;\n        returnAddresses[_donor] = _returnAddress; // XXX: overwrites\n\n\t// update the totals\n        totalEther += msg.value;\n\ttotalAtom += atoms;\n\n        Received(_donor, msg.value, atomRate);\n    }\n\n    /// Adjust the atomRate\n    /// NOTE: Should we allow rate to adjust before the period starts?\n    function adjustRate(uint newRate) only_admin only_during_period {\n\tatomRate = newRate;\n    }\n\n    /// Halt the contribution period. Any attempt at contributing will fail.\n    function halt() only_admin only_during_period {\n        isHalted = true;\n        Halted();\n    }\n\n    /// Unhalt the contribution period.\n    function unhalt() only_admin only_during_halted_period {\n        isHalted = false;\n        Unhalted();\n    }\n\n    /// Kill this contract.\n    function kill() only_admin only_after_period {\n        suicide(treasury);\n    }\n}"
    }
  ]
}