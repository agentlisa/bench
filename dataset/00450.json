{
  "Title": "M-31: BBLeverage's and SGLLeverage's `buyCollateral()` remove the required funds from the target twice",
  "Content": "# Issue M-31: BBLeverage's and SGLLeverage's `buyCollateral()` remove the required funds from the target twice \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/139 \n\n## Found by \nduc, hyh\n## Summary\n\nThe collateral purchase proceedings of leverage buy operation aren't returned to the user, but kept with the contract instead, so the funds are being requested from the user twice, first in a usual borrow and buy workflow (user now had a liability of `collateralShare` size), then once again via `_addCollateral` (user has transferred `collateralShare` directly in addition to that).\n\n## Vulnerability Detail\n\nBoth `buyCollateral()` functions are now broken this way, removing twice the value from the user. The accounting is being updated accordingly to reflect only one instance, so the funds are lost for the user.\n\nI.e. after each of the operations user borrowed the `collateralShare` worth of `asset` and then additionally to that supplied it directly via `_addCollateral`. As only one collateral addition is recorded, the loss for them is `collateralShare` of collateral. Since the accounting is updated it will not be possible to manually fix the situation in production, so the redeployment would be due.\n\n## Impact\n\nIt's an unconditional user loss each time the operations are used. There are no prerequisites, so the probability of it is high. Funds loss impact has high severity.\n\nLikelihood: High + Impact: High = Severity: Critical/High.\n\n## Code Snippet\n\nFirst `calldata_.borrowAmount` is being borrowed for `calldata_.from`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L82-L102\n\n```solidity\n        {\n            (, uint256 borrowShare) = _borrow(\n>>              calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n```\n\nAnd while borrow proceedings are being held in the contract, the same funds are being requested again from `calldata_.from` in the collateral form:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L102-L110\n\n```solidity\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n>>      _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLendingCommon.sol#L40-L49\n\n```solidity\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n>>      _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBCommon.sol#L128-L138\n\n```solidity\n    function _addTokens(address from, uint256 _tokenId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            require(share <= yieldBox.balanceOf(address(this), _tokenId) - total, \"BB: too much\");\n        } else {\n            // yieldBox.transfer(from, address(this), _tokenId, share);\n>>          bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _tokenId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n```\n\nThis last step of requesting `collateralShare` that is already with BBLeverage/SGLLeverage contract doesn't make sense for `buyCollateral()`, being a leftover from the legacy logic (when the collateral funds were transferred to a user, while now they aren't).\n\nSGLLeverage situation is the same, first borrow `calldata_.borrowAmount`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol#L73-L85\n\n```solidity\n>>      (, uint256 borrowShare) = _borrow(calldata_.from, address(this), calldata_.borrowAmount);\n\n        (uint256 borrowShareToAmount,) =\n            yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        amountOut = leverageExecutor.getCollateral(\n            collateralId,\n            address(asset),\n            address(collateral),\n            supplyShareToAmount + borrowShareToAmount,\n            calldata_.from,\n            calldata_.data\n        );\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n```\n\nThen additionally request `collateralShare` from `calldata_.from`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol#L85-L93\n\n```solidity\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        _allowedBorrow(calldata_.from, collateralShare);\n>>      _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLendingCommon.sol#L39-L50\n\n```solidity\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        userCollateralShare[to] += share;\n        totalCollateralShare = oldTotalCollateralShare + share;\n\n>>      _addTokens(from, to, collateralId, share, oldTotalCollateralShare, skim);\n\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLCommon.sol#L165-L177\n\n```solidity\n    function _addTokens(address from, address, uint256 _assetId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            if (share > yieldBox.balanceOf(address(this), _assetId) - total) {\n                revert TooMuch();\n            }\n        } else {\n            // yieldBox.transfer(from, address(this), _assetId, share);\n>>          bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _assetId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n```\n\nThe root cause is that leverageExecutor's logic has changed: previously `getCollateral()` put the funds to `from`, while now the funds are directly transferred to the BBLeverage/SGLLeverage contract, which is `msg.sender` for `leverageExecutor`, e.g.:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/SimpleLeverageExecutor.sol#L38-L47\n\n```solidity\n    function getCollateral(\n        ....\n    ) external payable override returns (uint256 collateralAmountOut) {\n        // Should be called only by approved SGL/BB markets.\n        if (!cluster.isWhitelisted(0, msg.sender)) revert SenderNotValid();\n>>      return _swapAndTransferToSender(true, assetAddress, collateralAddress, assetAmountIn, swapperData);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/BaseLeverageExecutor.sol#L129-L159\n\n```solidity\n    function _swapAndTransferToSender(\n        bool sendBack,\n        ...\n    ) internal returns (uint256 amountOut) {\n        ...\n\n        // If the tokenOut is a tOFT, wrap it. Handles ETH and ERC20.\n        // If `sendBack` is true, wrap the `amountOut to` the sender. else, wrap it to this contract.\n        if (swapData.toftInfo.isTokenOutToft) {\n            _handleToftWrapToSender(sendBack, tokenOut, amountOut);\n        } else if (sendBack == true) {\n            // If the token wasn't sent by the wrap OP, send it as a transfer.\n>>          IERC20(tokenOut).safeTransfer(msg.sender, amountOut);\n        }\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/leverage/AssetTotsDaiLeverageExecutor.sol#L38-L65\n\n```solidity\n    function getCollateral(address assetAddress, address collateralAddress, uint256 assetAmountIn, bytes calldata data)\n        ...\n    {\n        ...\n\n        // Wrap into tsDai to sender\n        sDaiAddress.safeApprove(collateralAddress, collateralAmountOut);\n>>      ITOFT(collateralAddress).wrap(address(this), msg.sender, collateralAmountOut);\n        sDaiAddress.safeApprove(collateralAddress, 0);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a flag to `_addCollateral()`, indicating that the funds were already transferred to the contract and only accounting update is needed, e.g.:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLendingCommon.sol#L40-L49\n\n```diff\n-   function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n+   function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share, bool addTokens) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n-       _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n+       if (addTokens) _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLendingCommon.sol#L39-L50\n\n```diff\n-   function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n+   function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share, bool addTokens) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        userCollateralShare[to] += share;\n        totalCollateralShare = oldTotalCollateralShare + share;\n\n-       _addTokens(from, to, collateralId, share, oldTotalCollateralShare, skim);\n+       if (addTokens) _addTokens(from, to, collateralId, share, oldTotalCollateralShare, skim);\n\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L102-L110\n\n```diff\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n-       _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n+       _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare, false);\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol#L85-L93\n\n```diff\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        _allowedBorrow(calldata_.from, collateralShare);\n-       _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n+       _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare, false);\n    }\n```\n\nAll other `_addCollateral()` instances should be updated to go with `addTokens == true`.\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nDuplicate of https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/57\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**WangAudit** commented:\n> tbh; after looking at _borrow function; I didn't see how funds are requested by the user there\n\n\n\n**nevillehuang**\n\n@cryptotechmaker Seems very similar to #141 and #60, so could be duplicates, preconditioned that users must have supplied sufficient allowance. Seems borderline high severity but could be medium. What do you think?\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/367.\n\n**huuducsc**\n\nEscalate\nThe severity of this issue should be high. Users having allowances for the BigBang or Singularity markets is a very common situation, not a kind of external condition or specific state. It's similar to an allowance attack, which is critical for any protocol.\n\n**sherlock-admin2**\n\n> Escalate\n> The severity of this issue should be high. Users having allowances for the BigBang or Singularity markets is a very common situation, not a kind of external condition or specific state. It's similar to an allowance attack, which is critical for any protocol.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nThe severity of the potential duplicated issue #60 applies here. In my opinion, it should remain Medium severity because the loss is limited only to the allowance the user has.\nAccording to Sherlock's [documentation](https://docs.sherlock.xyz/audits/judging/judging#iv.-how-to-identify-a-high-issue) to be High severity: \"Definite loss of funds without (extensive) limitations of external conditions.\"\n\n**huuducsc**\n\nI believe this issue deserves a high severity because approving for the market is a very common behavior among users, which is expected in the workflow of protocol and shouldn't be considered as an external condition. Regarding issue #87, although it requires a difference in decimals of tokens, it is still considered to have a high severity since the sponsor confirmed that they may use different decimals of tokens in the future.\n\n**cvetanovv**\n\nThat a user has a maximum allowance is common but not always the case and depends on the user. Losses are limited only to the allowance and funds the user has. \n\nFor this reason, I planned to reject the escalation and leave the issue as it is.\n\n\n**huuducsc**\n\n@cvetanovv The statement that \"the loss is limited to the allowance and funds the user has\" is not a feasible reason to downgrade this issue, according to the criteria of Sherlock:\n<img width=\"707\" alt=\"Screenshot 2024-04-08 at 18 38 55\" src=\"https://github.com/sherlock-audit/2024-02-tapioca-judging/assets/80202717/511409df-5205-4a3f-8b16-beacdd26ab46\">\n\nApproval for this own protocol (markets) isn't considered external conditions since most users will approve when using this protocol, and it's commonly expected behavior. In history, there have been several approval attacks which caused huge losses for users and protocols, such as the [Old Dolomite exploit](https://cointelegraph.com/news/old-dolomite-exchange-contract-suffers-1-8-million-loss-from-approval-exploit). \n\nAdditionally, #87 is still a high issue even when it requires different decimals tokens, which depends on the admin. Therefore, I believe this issue and other issues, which can cause loss from approval for markets, truly deserve high severity.\n\n**cvetanovv**\n\nHey @huuducsc, I'm not downgrading this issue as you say. This issue is judged by the Protocol and Lead Judge as Medium with which I agree for now. \n\n@nevillehuang What do you think? I have to admit it is borderline High/Medium. What makes it Medium in my opinion is the limitation to allowance and the funds it has.\n\nOn the other hand, unsuspecting users can give a lot of allowances and have a lot of funds and lose a lot of funds because of this bug. Even hundreds of thousands. So I think there is a reason to upgrade it to High.\n\n**huuducsc**\n\n@cvetanovv \n> What makes it Medium in my opinion is the limitation to allowance and the funds it has.\n\nWhen users are not aware of this vulnerability, they may approve millions or infinite funds to the protocol after its launch. As I mentioned, most users will routinely approve for markets when using this protocol because it's expected behavior from both protocol and users. The limitation of possible lost funds depends on users, but it will still be very huge on a regular basis. Therefore, there is no reason to consider this issue as medium severity, based on Sherlock's criteria, since it doesn't require any external conditions\n\n**nevillehuang**\n\n@maarcweiss @cryptotechmaker Could you let us know why you believe this issue is medium severity?\n\n**0xRektora**\n\nI also think It's borderline a high/medium because at the end it's gonna depend on the approval. We integrated a new approval system on Tapioca right before the audit start that takes in a permit for each transaction, there's no infinite approvals. The values are equal to the amounts needed and can't be updated by the web3 wallet because it's a permit.\n\nIf we take this into context I'd see it as a medium and not a high because the likelihood would be low.\n\n**cvetanovv**\n\nAfter this additional information from @0xRektora I decided to keep my original decision to reject the escalation and this issue will remain Medium.\n\n**huuducsc**\n\n> We integrated a new approval system on Tapioca right before the audit start that takes in a permit for each transaction\n\nThis statement wasn't mentioned in the contest's docs, so I believe it is out of scope and shouldn't be taken into context. Additionally, I believe this cannot prevent users from approving for markets, since the protocol didn't have any rules or docs to restrict user approval, so the likelihood should be high.\n\n**cvetanovv**\n\nI agree with the @huuducsc escalation and will upgrade the severity to High. \n\nAn unsuspecting user may have a lot of permission and since funds will always be double removed then High severity is appropriate.\n\n**0xadrii**\n\nIn response to [Duc's comment](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/139#issuecomment-2046625097), I believe that Rektora is referring to the Pearlmit approval system, which could clearly be found in the [contracts in-scope](https://github.com/sherlock-audit/2024-02-tapioca-0xadrii/blob/main/Tapioca-bar/contracts/Penrose.sol#L36), and was also explicitly mentioned by the sponsors as one of the breaking changes for this audit in [this comment on Sherlock's official tapioca discord channel](https://ptb.discord.com/channels/812037309376495636/1210627002982207499/1211689249280368730). Just want to clarify that this approval system must not be considered out of scope given that it is one of the essential additions for this audit\n\n**cvetanovv**\n\nIf we consider the new approval system then things change. So my last decision is to take into consideration [sponsor](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/139#issuecomment-2045788465) and @0xadrii comment and reject the escalation.\n\n**huuducsc**\n\n@cvetanovv\n> Just want to clarify that this approval system must not be considered out of scope given that it is one of the essential additions for this audit\n\n I agree with @0xadrii that the permit system is not out of scope, but he just wanted to clarify it and he didn't point out any consideration of this issue as a medium. My demonstration for considering it a high severity is that there is no statement in the docs which restricts the approval from users to protocol. The protocol didn't tell users to only use the permit functionality, so I believe the likelihood of this issue is still high since it doesn't need any external condition.\n\n**0xadrii**\n\nWell, I did not mention it but my comment was actually meant to support [the sponsor's comment](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/139#issuecomment-2045788465) and make it clear that the permit integration must be considered for this audit. The sponsor's comment shows how likelihood is clearly  low and hence medium severity is justified \n\n**huuducsc**\n\n@0xadrii I mean the sponsor only mentioned a functionality of permit and didn't show any evidence to consider the likelihood as low. I still don't know why approval for the market should be considered as low likelihood since there are no restrictions for it in the protocol's docs\n\n\n**cvetanovv**\n\nMy final decision is to reject the escalation and this issue will remain Medium.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [huuducsc](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/139/#issuecomment-2031944515): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLendingCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IUsdo} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {BBCommon} from \"./BBCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLendingCommon is BBCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BorrowCapReached();\n    error OracleCallFailed();\n    error NothingToRepay();\n    error RepayAmountNotValid();\n    error AllowanceNotValid();\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n        _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(address from, address to, uint256 share) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(address from, address to, uint256 amount, uint256 feeAmount)\n        internal\n        returns (uint256 part, uint256 share)\n    {\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n\n        if (totalBorrowCap > 0) {\n            if (totalBorrow.elastic > totalBorrowCap) revert BorrowCapReached();\n        }\n\n        userBorrowPart[from] += part;\n        emit LogBorrow(from, to, amount, feeAmount, part);\n\n        //mint USDO\n        IUsdo(address(asset)).mint(address(this), amount);\n\n        //deposit borrowed amount to user\n        share = _depositAmountToYb(asset, to, assetId, amount);\n    }\n\n    function _computeVariableOpeningFee(uint256 amount) internal returns (uint256) {\n        if (amount == 0) return 0;\n\n        //get asset <> USDC price ( USDO <> USDC )\n        (bool updated, uint256 _exchangeRate) = assetOracle.get(oracleData);\n        if (!updated) revert OracleCallFailed();\n\n        if (_exchangeRate >= minMintFeeStart) {\n            return (amount * minMintFee) / FEE_PRECISION;\n        }\n        if (_exchangeRate <= maxMintFeeStart) {\n            return (amount * maxMintFee) / FEE_PRECISION;\n        }\n\n        uint256 fee = maxMintFee\n            - (((_exchangeRate - maxMintFeeStart) * (maxMintFee - minMintFee)) / (minMintFeeStart - maxMintFeeStart));\n\n        if (fee > maxMintFee) return (amount * maxMintFee) / FEE_PRECISION;\n        if (fee < minMintFee) return (amount * minMintFee) / FEE_PRECISION;\n\n        if (fee > 0) {\n            return (amount * fee) / FEE_PRECISION;\n        }\n        return 0;\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(address from, address to, uint256 part) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        // @dev check allowance\n        if (msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n            (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n\n        // @dev sub `part` of totalBorrow\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n        userBorrowPart[to] -= part;\n\n        // @dev amount includes the opening & accrued fees\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n\n        // @dev burn USDO\n        IUsdo(address(asset)).burn(address(this), amount);\n\n        emit LogRepay(from, to, amount, part);\n    }\n\n    function _safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567)); //decimals() selector\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IBigBang} from \"tapioca-periph/interfaces/bar/IBigBang.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBStorage} from \"./BBStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBCommon is BBStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NotEnough();\n    error TransferFailed();\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns total market debt\n    function getTotalDebt() external view returns (uint256) {\n        return totalBorrow.elastic;\n    }\n\n    /// @notice returns the current debt rate\n    function getDebtRate() public view returns (uint256) {\n        if (isMainMarket) return penrose.bigBangEthDebtRate(); // default 0.5%\n        if (totalBorrow.elastic == 0) return minDebtRate;\n\n        uint256 _ethMarketTotalDebt = IBigBang(penrose.bigBangEthMarket()).getTotalDebt();\n        uint256 _currentDebt = totalBorrow.elastic;\n        uint256 _maxDebtPoint = (_ethMarketTotalDebt * debtRateAgainstEthMarket) / 1e18;\n\n        if (_currentDebt >= _maxDebtPoint) return maxDebtRate;\n\n        uint256 debtPercentage = (_currentDebt * DEBT_PRECISION) / _maxDebtPoint;\n        uint256 debt = ((maxDebtRate - minDebtRate) * debtPercentage) / DEBT_PRECISION + minDebtRate;\n\n        if (debt > maxDebtRate) return maxDebtRate;\n\n        return debt;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        uint256 elapsedTime = block.timestamp - accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return totalBorrow;\n        }\n\n        // Calculate fees\n        _totalBorrow = totalBorrow;\n        uint256 extraAmount = (uint256(_totalBorrow.elastic) * (getDebtRate() / 31536000) * elapsedTime) / 1e18;\n        uint256 max = type(uint128).max - totalBorrowCap;\n\n        if (extraAmount > max) {\n            extraAmount = max;\n        }\n        _totalBorrow.elastic += extraAmount.toUint128();\n    }\n\n    function _accrue() internal override {\n        IBigBang.AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        //update debt rate\n        uint256 annumDebtRate = getDebtRate();\n        _accrueInfo.debtRate = (annumDebtRate / 31557600).toUint64(); //per second; account for leap years\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        // Calculate fees\n        uint256 extraAmount = 0;\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.debtRate * elapsedTime) / 1e18;\n\n        // cap `extraAmount` to avoid overflow risk when converting it from uint256 to uint128\n        uint256 max = type(uint128).max - totalBorrowCap;\n\n        if (extraAmount > max) {\n            extraAmount = max;\n        }\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        emit LogAccrue(extraAmount, _accrueInfo.debtRate);\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _tokenId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, uint256 _tokenId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            require(share <= yieldBox.balanceOf(address(this), _tokenId) - total, \"BB: too much\");\n        } else {\n            // yieldBox.transfer(from, address(this), _tokenId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _tokenId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @notice deposits an amount to YieldBox\n    /// @param token the IERC20 token to deposit\n    /// @param to the shares receiver\n    /// @param id the IERC20 YieldBox asset id\n    /// @param amount the amount to deposit\n    function _depositAmountToYb(IERC20 token, address to, uint256 id, uint256 amount)\n        internal\n        returns (uint256 share)\n    {\n        address(token).safeApprove(address(yieldBox), amount);\n        (, share) = yieldBox.depositAsset(id, address(this), to, amount, 0);\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20, IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {SGLLendingCommon} from \"./SGLLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLLeverage is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n        uint256 supplyShareToAmount;\n        if (supplyShare > 0) {\n            (supplyShareToAmount,) =\n                yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n        }\n        (, uint256 borrowShare) = _borrow(calldata_.from, address(this), calldata_.borrowAmount);\n\n        (uint256 borrowShareToAmount,) =\n            yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        amountOut = leverageExecutor.getCollateral(\n            collateralId,\n            address(asset),\n            address(collateral),\n            supplyShareToAmount + borrowShareToAmount,\n            calldata_.from,\n            calldata_.data\n        );\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralCalldata {\n        address from;\n        uint256 share;\n        bytes data;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _SellCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.share = share;\n            calldata_.data = data;\n        }\n\n        _allowedBorrow(calldata_.from, calldata_.share);\n        _removeCollateral(calldata_.from, address(this), calldata_.share);\n\n        yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, calldata_.share);\n        uint256 leverageAmount = yieldBox.toAmount(collateralId, calldata_.share, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), leverageAmount, calldata_.from, calldata_.data\n        );\n        uint256 shareOut = yieldBox.toShare(assetId, amountOut, false);\n\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(assetId, address(this), address(this), 0, shareOut);\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        uint256 partOwed = userBorrowPart[calldata_.from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(calldata_.from, calldata_.from, false, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(calldata_.from, calldata_.from, false, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20, IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {SGLLendingCommon} from \"./SGLLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLLeverage is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n        uint256 supplyShareToAmount;\n        if (supplyShare > 0) {\n            (supplyShareToAmount,) =\n                yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n        }\n        (, uint256 borrowShare) = _borrow(calldata_.from, address(this), calldata_.borrowAmount);\n\n        (uint256 borrowShareToAmount,) =\n            yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        amountOut = leverageExecutor.getCollateral(\n            collateralId,\n            address(asset),\n            address(collateral),\n            supplyShareToAmount + borrowShareToAmount,\n            calldata_.from,"
    }
  ]
}