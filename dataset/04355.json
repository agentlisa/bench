{
  "Title": "[C04] DisputeCrowdsourcer contract does not allow for the purchase of overload tokens once its size is filled",
  "Content": "The `DisputeCrowdsourcer`‘s [`contribute`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L75) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L75) is expected to mint [DISP tokens](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L18) for contributors until the funding goal is reached. After the funding goal has been reached, further contributions are rewarded with “overload tokens” to enable participants to quickly raise the dispute stakes without waiting through multiple dispute rounds. This mechanism prevents malicious parties from dragging out disputes.\n\n\nHowever, in [line 78](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L78) of `DisputeCrowdsourcer.sol`, `size.sub(_curStake)` will inevitably revert if `_curStake` is larger than `size`. `size` is the funding goal of the `DisputeCrowdsourcer` and is the threshold at which DISP tokens stop being minted, replaced by the minting of overload tokens. The value of `_curStake` is calculated by the [`getStake`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L106) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L106) which sums the total supply of all DISP and overload tokens. As a consequence, only the first purchase of overload tokens that brings the total stake above the funding goal will succeed. Every subsequent attempt to contribute to the tentative outcome (*i.e.* by purchasing overload tokens) will revert because the total number of overload tokens and DISP tokens will exceed the funding goal (*i.e.* `size`).\n\n\nConsider refactoring the `contribute` function to handle the described scenario, where the total number of overload tokens and DISP tokens exceeds the funding goal, so as to ensure disputes cannot be easily dragged out by malicious parties.\n\n\n*Note: The* *`DisputeCrowdsourcer`* *contract is not within the scope of this audit but has many interactions with the contracts covered by this report.*\n\n\n***Update:*** *fixed in* [*`2ea5753`*](https://github.com/AugurProject/augur/commit/2ea575351ff90253cca7380ccf141fec2e101b0b) *by removing the concept of overload tokens.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/reporting/IDisputeOverloadToken.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/reporting/BaseReportingParticipant.sol';\nimport 'ROOT/libraries/Initializable.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/IAugur.sol';\n\n\ncontract DisputeCrowdsourcer is VariableSupplyToken, BaseReportingParticipant, IDisputeCrowdsourcer, Initializable {\n    IUniverse internal universe;\n    IDisputeOverloadToken disputeOverloadToken;\n\n    string constant public name = \"Dispute Crowdsourcer Token\";\n    string constant public symbol = \"DISP\";\n\n    function initialize(IAugur _augur, IMarket _market, uint256 _size, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, IDisputeOverloadToken _disputeOverloadToken, address _erc820RegistryAddress) public beforeInitialized returns (bool) {\n        endInitialization();\n        augur = _augur;\n        market = _market;\n        universe = market.getUniverse();\n        reputationToken = market.getReputationToken();\n        size = _size;\n        payoutNumerators = _payoutNumerators;\n        payoutDistributionHash = _payoutDistributionHash;\n        disputeOverloadToken = _disputeOverloadToken;\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n        return true;\n    }\n\n    function redeem(address _redeemer) public returns (bool) {\n        bool _isDisavowed = isDisavowed();\n        if (!_isDisavowed && !market.isFinalized()) {\n            market.finalize();\n        }\n        uint256 _amount = balances[_redeemer];\n        uint256 _overloadAmount = disputeOverloadToken.balanceOf(_redeemer);\n        uint256 _totalAmount = _amount.add(_overloadAmount);\n\n        if (_totalAmount == 0) {\n            return true;\n        }\n\n        uint256 _reputationShare = _totalAmount;\n\n        uint256 _totalRep = reputationToken.balanceOf(address(this));\n\n        if (_totalRep == 0) {\n            return true;\n        }\n\n        uint256 _excessRep = _totalRep.sub(getStake());\n        uint256 _excessRepAvailableForBaseContributions = _excessRep.min(totalSupply().mul(2) / 5);\n        uint256 _excessRepAvailableForOverloadContributions = _excessRep.sub(_excessRepAvailableForBaseContributions);\n\n        if (_overloadAmount > 0) {\n            _reputationShare = _reputationShare.add(_excessRepAvailableForOverloadContributions.mul(_overloadAmount) / disputeOverloadToken.totalSupply());\n            disputeOverloadToken.trustedBurn(_redeemer, _overloadAmount);\n        }\n        if (_amount > 0) {\n            _reputationShare = _reputationShare.add(_excessRepAvailableForBaseContributions.mul(_amount) / totalSupply());\n            burn(_redeemer, _amount);\n        }\n\n        require(reputationToken.transfer(_redeemer, _reputationShare));\n\n        augur.logDisputeCrowdsourcerRedeemed(universe, _redeemer, address(market), _totalAmount, _reputationShare, payoutNumerators);\n        return true;\n    }\n\n    function contribute(address _participant, uint256 _amount, bool _overload) public returns (uint256) {\n        require(IMarket(msg.sender) == market);\n        uint256 _curStake = getStake();\n        uint256 _baseAmount = _amount.min(size.sub(_curStake));\n        uint256 _totalAmount = _baseAmount;\n        if (_overload) {\n            uint256 _overloadAmount = _amount.min(universe.getDisputeThresholdForDisputePacing().sub(_curStake)).sub(_baseAmount);\n            _totalAmount = _totalAmount.add(_overloadAmount);\n            disputeOverloadToken.trustedMint(_participant, _overloadAmount);\n        }\n        if (_totalAmount == 0) {\n            return 0;\n        }\n        reputationToken.trustedReportingParticipantTransfer(_participant, address(this), _totalAmount);\n        if (_baseAmount > 0) {\n            mint(_participant, _baseAmount);\n        }\n        assert(reputationToken.balanceOf(address(this)) >= getStake());\n        return _totalAmount;\n    }\n\n    function forkAndRedeem() public returns (bool) {\n        fork();\n        redeem(msg.sender);\n        return true;\n    }\n\n    function getRemainingToFill() public view returns (uint256) {\n        return size.sub(getStake());\n    }\n\n    function getStake() public view returns (uint256) {\n        return totalSupply().add(disputeOverloadToken.totalSupply());\n    }\n\n    function setSize(uint256 _size) public returns (bool) {\n        require(IMarket(msg.sender) == market);\n        size = _size;\n        return true;\n    }\n\n    function getDisputeOverloadToken() public returns (IDisputeOverloadToken) {\n        return disputeOverloadToken;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logDisputeCrowdsourcerTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logDisputeCrowdsourcerTokensMinted(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logDisputeCrowdsourcerTokensBurned(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function getReputationToken() public view returns (IReputationToken) {\n        return reputationToken;\n    }\n\n    function correctSize() public returns (bool) {\n        require(IMarket(msg.sender) == market);\n        size = getStake();\n        return true;\n    }\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/reporting/IDisputeOverloadToken.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/reporting/BaseReportingParticipant.sol';\nimport 'ROOT/libraries/Initializable.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/IAugur.sol';\n\n\ncontract DisputeCrowdsourcer is VariableSupplyToken, BaseReportingParticipant, IDisputeCrowdsourcer, Initializable {\n    IUniverse internal universe;\n    IDisputeOverloadToken disputeOverloadToken;\n\n    string constant public name = \"Dispute Crowdsourcer Token\";\n    string constant public symbol = \"DISP\";\n\n    function initialize(IAugur _augur, IMarket _market, uint256 _size, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, IDisputeOverloadToken _disputeOverloadToken, address _erc820RegistryAddress) public beforeInitialized returns (bool) {\n        endInitialization();\n        augur = _augur;\n        market = _market;\n        universe = market.getUniverse();\n        reputationToken = market.getReputationToken();\n        size = _size;\n        payoutNumerators = _payoutNumerators;\n        payoutDistributionHash = _payoutDistributionHash;\n        disputeOverloadToken = _disputeOverloadToken;\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n        return true;\n    }\n\n    function redeem(address _redeemer) public returns (bool) {\n        bool _isDisavowed = isDisavowed();\n        if (!_isDisavowed && !market.isFinalized()) {\n            market.finalize();\n        }\n        uint256 _amount = balances[_redeemer];\n        uint256 _overloadAmount = disputeOverloadToken.balanceOf(_redeemer);\n        uint256 _totalAmount = _amount.add(_overloadAmount);\n\n        if (_totalAmount == 0) {\n            return true;\n        }\n\n        uint256 _reputationShare = _totalAmount;\n\n        uint256 _totalRep = reputationToken.balanceOf(address(this));\n\n        if (_totalRep == 0) {\n            return true;\n        }\n\n        uint256 _excessRep = _totalRep.sub(getStake());\n        uint256 _excessRepAvailableForBaseContributions = _excessRep.min(totalSupply().mul(2) / 5);\n        uint256 _excessRepAvailableForOverloadContributions = _excessRep.sub(_excessRepAvailableForBaseContributions);\n\n        if (_overloadAmount > 0) {\n            _reputationShare = _reputationShare.add(_excessRepAvailableForOverloadContributions.mul(_overloadAmount) / disputeOverloadToken.totalSupply());\n            disputeOverloadToken.trustedBurn(_redeemer, _overloadAmount);\n        }\n        if (_amount > 0) {\n            _reputationShare = _reputationShare.add(_excessRepAvailableForBaseContributions.mul(_amount) / totalSupply());\n            burn(_redeemer, _amount);\n        }\n\n        require(reputationToken.transfer(_redeemer, _reputationShare));\n\n        augur.logDisputeCrowdsourcerRedeemed(universe, _redeemer, address(market), _totalAmount, _reputationShare, payoutNumerators);\n        return true;\n    }\n\n    function contribute(address _participant, uint256 _amount, bool _overload) public returns (uint256) {\n        require(IMarket(msg.sender) == market);\n        uint256 _curStake = getStake();\n        uint256 _baseAmount = _amount.min(size.sub(_curStake));\n        uint256 _totalAmount = _baseAmount;\n        if (_overload) {\n            uint256 _overloadAmount = _amount.min(universe.getDisputeThresholdForDisputePacing().sub(_curStake)).sub(_baseAmount);\n            _totalAmount = _totalAmount.add(_overloadAmount);\n            disputeOverloadToken.trustedMint(_participant, _overloadAmount);\n        }\n        if (_totalAmount == 0) {\n            return 0;\n        }\n        reputationToken.trustedReportingParticipantTransfer(_participant, address(this), _totalAmount);\n        if (_baseAmount > 0) {\n            mint(_participant, _baseAmount);\n        }\n        assert(reputationToken.balanceOf(address(this)) >= getStake());\n        return _totalAmount;\n    }\n\n    function forkAndRedeem() public returns (bool) {\n        fork();\n        redeem(msg.sender);\n        return true;\n    }\n\n    function getRemainingToFill() public view returns (uint256) {\n        return size.sub(getStake());\n    }\n\n    function getStake() public view returns (uint256) {\n        return totalSupply().add(disputeOverloadToken.totalSupply());\n    }\n\n    function setSize(uint256 _size) public returns (bool) {\n        require(IMarket(msg.sender) == market);\n        size = _size;\n        return true;\n    }\n\n    function getDisputeOverloadToken() public returns (IDisputeOverloadToken) {\n        return disputeOverloadToken;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logDisputeCrowdsourcerTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logDisputeCrowdsourcerTokensMinted(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logDisputeCrowdsourcerTokensBurned(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function getReputationToken() public view returns (IReputationToken) {\n        return reputationToken;\n    }\n\n    function correctSize() public returns (bool) {\n        require(IMarket(msg.sender) == market);\n        size = getStake();\n        return true;\n    }\n}"
    }
  ]
}