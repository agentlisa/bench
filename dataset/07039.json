{
  "Title": "[G-02] Revert on no-op",
  "Content": "\nUnfortunately it can be common for users to accidentally fire the same transaction multiple times. This can result from an unclear app experience, or users misunderstanding speed up / replace transaction. When this occurs the duplicate transaction should be a no-op, ideally reverting as early as possible to limit gas costs. Reverting in the case of a duplicate may also prevent the redundant transaction from being broadcasted at all since apps and wallets typically estimate gas before broadcasting and that would show that it's expected to revert if the original has already been mined.\n\nIn `register` consider reverting if the provided `_cidNFTID` is already registered by that user. \n\nThis is similar to the pattern already used [in `remove`, which reverts with `NoCIDNFTRegisteredForUser` when the call would otherwise be a no-op](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L54) (and this is not strictly necessary). \n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-canto-identity-protocol-contest",
  "Code": [
    {
      "filename": "src/AddressRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC721.sol\";\n\n/// @title Address Registry\n/// @notice Allows users to register their CID NFT\ncontract AddressRegistry {\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address of the CID NFT\n    address public immutable cidNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Stores the mappings of users to their CID NFT\n    mapping(address => uint256) private cidNFTs;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event CIDNFTAdded(address indexed user, uint256 indexed cidNFTID);\n    event CIDNFTRemoved(address indexed user, uint256 indexed cidNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error NFTNotOwnedByUser(uint256 cidNFTID, address caller);\n    error NoCIDNFTRegisteredForUser(address caller);\n\n    /// @param _cidNFT Address of the CID NFT contract\n    constructor(address _cidNFT) {\n        cidNFT = _cidNFT;\n    }\n\n    /// @notice Register a CID NFT to the address of the caller. NFT has to be owned by the caller\n    /// @dev Will overwrite existing registration if any exists\n    function register(uint256 _cidNFTID) external {\n        if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender)\n            // We only guarantee that a CID NFT is owned by the user at the time of registration\n            // ownerOf reverts if non-existing ID is provided\n            revert NFTNotOwnedByUser(_cidNFTID, msg.sender);\n        cidNFTs[msg.sender] = _cidNFTID;\n        emit CIDNFTAdded(msg.sender, _cidNFTID);\n    }\n\n    /// @notice Remove the current registration of the caller\n    function remove() external {\n        uint256 cidNFTID = cidNFTs[msg.sender];\n        if (cidNFTID == 0) revert NoCIDNFTRegisteredForUser(msg.sender);\n        delete cidNFTs[msg.sender];\n        emit CIDNFTRemoved(msg.sender, cidNFTID);\n    }\n\n    /// @notice Get the CID NFT ID that is registered for the provided user\n    /// @param _user Address to query\n    /// @return cidNFTID The registered CID NFT ID. 0 when no CID NFT is registered for the given address\n    function getCID(address _user) external view returns (uint256 cidNFTID) {\n        cidNFTID = cidNFTs[_user];\n    }\n}"
    }
  ]
}