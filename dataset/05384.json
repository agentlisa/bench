{
  "Title": "[11] Unutilized function",
  "Content": "`CultureIndex.hasVoted`:\n\nhttps://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/CultureIndex.sol#L250-L258\n\n```solidity\n    /**\n     * @notice Checks if a specific voter has already voted for a given art piece.\n     * @param pieceId The ID of the art piece.\n     * @param voter The address of the voter.\n     * @return A boolean indicating if the voter has voted for the art piece.\n     */\n    function hasVoted(uint256 pieceId, address voter) external view returns (bool) {\n        return votes[pieceId][voter].voterAddress != address(0);\n    }\n``` \ncould have been used in the following require statement:\n\nhttps://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/CultureIndex.sol#L311\n\n```diff\n-        require(!(votes[pieceId][voter].voterAddress != address(0)), \"Already voted\");\n+        require(!(hasVoted(pieceId, voter)), \"Already voted\");\n```\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/CultureIndex.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { ERC20VotesUpgradeable } from \"./base/erc20/ERC20VotesUpgradeable.sol\";\nimport { MaxHeap } from \"./MaxHeap.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\n\nimport { ERC721CheckpointableUpgradeable } from \"./base/ERC721CheckpointableUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract CultureIndex is\n    ICultureIndex,\n    VersionedContract,\n    UUPS,\n    Ownable2StepUpgradeable,\n    ReentrancyGuardUpgradeable,\n    EIP712Upgradeable\n{\n    /// @notice The EIP-712 typehash for gasless votes\n    bytes32 public constant VOTE_TYPEHASH =\n        keccak256(\"Vote(address from,uint256[] pieceIds,uint256 nonce,uint256 deadline)\");\n\n    /// @notice An account's nonce for gasless votes\n    mapping(address => uint256) public nonces;\n\n    // The MaxHeap data structure used to keep track of the top-voted piece\n    MaxHeap public maxHeap;\n\n    // The ERC20 token used for voting\n    ERC20VotesUpgradeable public erc20VotingToken;\n\n    // The ERC721 token used for voting\n    ERC721CheckpointableUpgradeable public erc721VotingToken;\n\n    // The weight of the 721 voting token\n    uint256 public erc721VotingTokenWeight;\n\n    /// @notice The maximum settable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 6_000; // 6,000 basis points or 60%\n\n    /// @notice The minimum vote weight required in order to vote\n    uint256 public minVoteWeight;\n\n    /// @notice The basis point number of votes in support of a art piece required in order for a quorum to be reached and for an art piece to be dropped.\n    uint256 public quorumVotesBPS;\n\n    /// @notice The name of the culture index\n    string public name;\n\n    /// @notice A description of the culture index - can include rules or guidelines\n    string public description;\n\n    // The list of all pieces\n    mapping(uint256 => ArtPiece) public pieces;\n\n    // The internal piece ID tracker\n    uint256 public _currentPieceId;\n\n    // The mapping of all votes for a piece\n    mapping(uint256 => mapping(address => Vote)) public votes;\n\n    // The total voting weight for a piece\n    mapping(uint256 => uint256) public totalVoteWeights;\n\n    // Constant for max number of creators\n    uint256 public constant MAX_NUM_CREATORS = 100;\n\n    // The address that is allowed to drop art pieces\n    address public dropperAdmin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes a token's metadata descriptor\n     * @param _erc20VotingToken The address of the ERC20 voting token, commonly referred to as \"points\"\n     * @param _erc721VotingToken The address of the ERC721 voting token, commonly the dropped art pieces\n     * @param _initialOwner The owner of the contract, allowed to drop pieces. Commonly updated to the AuctionHouse\n     * @param _maxHeap The address of the max heap contract\n     * @param _dropperAdmin The address that can drop new art pieces\n     * @param _cultureIndexParams The CultureIndex settings\n     */\n    function initialize(\n        address _erc20VotingToken,\n        address _erc721VotingToken,\n        address _initialOwner,\n        address _maxHeap,\n        address _dropperAdmin,\n        IRevolutionBuilder.CultureIndexParams memory _cultureIndexParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        require(_cultureIndexParams.quorumVotesBPS <= MAX_QUORUM_VOTES_BPS, \"invalid quorum bps\");\n        require(_cultureIndexParams.erc721VotingTokenWeight > 0, \"invalid erc721 voting token weight\");\n        require(_erc721VotingToken != address(0), \"invalid erc721 voting token\");\n        require(_erc20VotingToken != address(0), \"invalid erc20 voting token\");\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(_cultureIndexParams.name, \" CultureIndex\"), \"1\");\n\n        __ReentrancyGuard_init();\n\n        erc20VotingToken = ERC20VotesUpgradeable(_erc20VotingToken);\n        erc721VotingToken = ERC721CheckpointableUpgradeable(_erc721VotingToken);\n        erc721VotingTokenWeight = _cultureIndexParams.erc721VotingTokenWeight;\n        name = _cultureIndexParams.name;\n        description = _cultureIndexParams.description;\n        quorumVotesBPS = _cultureIndexParams.quorumVotesBPS;\n        minVoteWeight = _cultureIndexParams.minVoteWeight;\n        dropperAdmin = _dropperAdmin;\n\n        emit QuorumVotesBPSSet(quorumVotesBPS, _cultureIndexParams.quorumVotesBPS);\n\n        // Create maxHeap\n        maxHeap = MaxHeap(_maxHeap);\n    }\n\n    ///                                                          ///\n    ///                         MODIFIERS                        ///\n    ///                                                          ///\n\n    /**\n     *  Validates the media type and associated data.\n     * @param metadata The metadata associated with the art piece.\n     *\n     * Requirements:\n     * - The media type must be one of the defined types in the MediaType enum.\n     * - The corresponding media data must not be empty.\n     */\n    function validateMediaType(ArtPieceMetadata calldata metadata) internal pure {\n        require(uint8(metadata.mediaType) > 0 && uint8(metadata.mediaType) <= 5, \"Invalid media type\");\n\n        if (metadata.mediaType == MediaType.IMAGE)\n            require(bytes(metadata.image).length > 0, \"Image URL must be provided\");\n        else if (metadata.mediaType == MediaType.ANIMATION)\n            require(bytes(metadata.animationUrl).length > 0, \"Animation URL must be provided\");\n        else if (metadata.mediaType == MediaType.TEXT)\n            require(bytes(metadata.text).length > 0, \"Text must be provided\");\n    }\n\n    /**\n     * @notice Checks the total basis points from an array of creators and returns the length\n     * @param creatorArray An array of Creator structs containing address and basis points.\n     * @return Returns the total basis points calculated from the array of creators.\n     *\n     * Requirements:\n     * - The `creatorArray` must not contain any zero addresses.\n     * - The function will return the length of the `creatorArray`.\n     */\n    function validateCreatorsArray(CreatorBps[] calldata creatorArray) internal pure returns (uint256) {\n        uint256 creatorArrayLength = creatorArray.length;\n        //Require that creatorArray is not more than MAX_NUM_CREATORS to prevent gas limit issues\n        require(creatorArrayLength <= MAX_NUM_CREATORS, \"Creator array must not be > MAX_NUM_CREATORS\");\n\n        uint256 totalBps;\n        for (uint i; i < creatorArrayLength; i++) {\n            require(creatorArray[i].creator != address(0), \"Invalid creator address\");\n            totalBps += creatorArray[i].bps;\n        }\n\n        require(totalBps == 10_000, \"Total BPS must sum up to 10,000\");\n\n        return creatorArrayLength;\n    }\n\n    /**\n     * @notice Creates a new piece of art with associated metadata and creators.\n     * @param metadata The metadata associated with the art piece, including name, description, image, and optional animation URL.\n     * @param creatorArray An array of creators who contributed to the piece, along with their respective basis points that must sum up to 10,000.\n     * @return Returns the unique ID of the newly created art piece.\n     *\n     * Emits a {PieceCreated} event for the newly created piece.\n     * Emits a {PieceCreatorAdded} event for each creator added to the piece.\n     *\n     * Requirements:\n     * - `metadata` must include name, description, and image. Animation URL is optional.\n     * - `creatorArray` must not contain any zero addresses.\n     * - The sum of basis points in `creatorArray` must be exactly 10,000.\n     */\n    function createPiece(\n        ArtPieceMetadata calldata metadata,\n        CreatorBps[] calldata creatorArray\n    ) public returns (uint256) {\n        uint256 creatorArrayLength = validateCreatorsArray(creatorArray);\n\n        // Validate the media type and associated data\n        validateMediaType(metadata);\n\n        uint256 pieceId = _currentPieceId++;\n\n        /// @dev Insert the new piece into the max heap\n        maxHeap.insert(pieceId, 0);\n\n        ArtPiece storage newPiece = pieces[pieceId];\n\n        newPiece.pieceId = pieceId;\n        newPiece.totalVotesSupply = _calculateVoteWeight(\n            erc20VotingToken.totalSupply(),\n            erc721VotingToken.totalSupply()\n        );\n        newPiece.totalERC20Supply = erc20VotingToken.totalSupply();\n        newPiece.metadata = metadata;\n        newPiece.sponsor = msg.sender;\n        newPiece.creationBlock = block.number;\n        newPiece.quorumVotes = (quorumVotesBPS * newPiece.totalVotesSupply) / 10_000;\n\n        for (uint i; i < creatorArrayLength; i++) {\n            newPiece.creators.push(creatorArray[i]);\n        }\n\n        emit PieceCreated(pieceId, msg.sender, metadata, newPiece.quorumVotes, newPiece.totalVotesSupply);\n\n        // Emit an event for each creator\n        for (uint i; i < creatorArrayLength; i++) {\n            emit PieceCreatorAdded(pieceId, creatorArray[i].creator, msg.sender, creatorArray[i].bps);\n        }\n\n        return newPiece.pieceId;\n    }\n\n    /**\n     * @notice Checks if a specific voter has already voted for a given art piece.\n     * @param pieceId The ID of the art piece.\n     * @param voter The address of the voter.\n     * @return A boolean indicating if the voter has voted for the art piece.\n     */\n    function hasVoted(uint256 pieceId, address voter) external view returns (bool) {\n        return votes[pieceId][voter].voterAddress != address(0);\n    }\n\n    /**\n     * @notice Returns the voting power of a voter at the current block.\n     * @param account The address of the voter.\n     * @return The voting power of the voter.\n     */\n    function getVotes(address account) external view override returns (uint256) {\n        return _getVotes(account);\n    }\n\n    /**\n     * @notice Returns the voting power of a voter at the current block.\n     * @param account The address of the voter.\n     * @return The voting power of the voter.\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view override returns (uint256) {\n        return _getPastVotes(account, blockNumber);\n    }\n\n    /**\n     * @notice Calculates the vote weight of a voter.\n     * @param erc20Balance The ERC20 balance of the voter.\n     * @param erc721Balance The ERC721 balance of the voter.\n     * @return The vote weight of the voter.\n     */\n    function _calculateVoteWeight(uint256 erc20Balance, uint256 erc721Balance) internal view returns (uint256) {\n        return erc20Balance + (erc721Balance * erc721VotingTokenWeight * 1e18);\n    }\n\n    function _getVotes(address account) internal view returns (uint256) {\n        return _calculateVoteWeight(erc20VotingToken.getVotes(account), erc721VotingToken.getVotes(account));\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256) {\n        return\n            _calculateVoteWeight(\n                erc20VotingToken.getPastVotes(account, blockNumber),\n                erc721VotingToken.getPastVotes(account, blockNumber)\n            );\n    }\n\n    /**\n     * @notice Cast a vote for a specific ArtPiece.\n     * @param pieceId The ID of the ArtPiece to vote for.\n     * @param voter The address of the voter.\n     * @dev Requires that the pieceId is valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a VoteCast event upon successful execution.\n     */\n    function _vote(uint256 pieceId, address voter) internal {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        require(voter != address(0), \"Invalid voter address\");\n        require(!pieces[pieceId].isDropped, \"Piece has already been dropped\");\n        require(!(votes[pieceId][voter].voterAddress != address(0)), \"Already voted\");\n\n        uint256 weight = _getPastVotes(voter, pieces[pieceId].creationBlock);\n        require(weight > minVoteWeight, \"Weight must be greater than minVoteWeight\");\n\n        votes[pieceId][voter] = Vote(voter, weight);\n        totalVoteWeights[pieceId] += weight;\n\n        uint256 totalWeight = totalVoteWeights[pieceId];\n\n        // TODO add security consideration here based on block created to prevent flash attacks on drops?\n        maxHeap.updateValue(pieceId, totalWeight);\n        emit VoteCast(pieceId, voter, weight, totalWeight);\n    }\n\n    /**\n     * @notice Cast a vote for a specific ArtPiece.\n     * @param pieceId The ID of the ArtPiece to vote for.\n     * @dev Requires that the pieceId is valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a VoteCast event upon successful execution.\n     */\n    function vote(uint256 pieceId) public nonReentrant {\n        _vote(pieceId, msg.sender);\n    }\n\n    /**\n     * @notice Cast a vote for a list of ArtPieces.\n     * @param pieceIds The IDs of the ArtPieces to vote for.\n     * @dev Requires that the pieceIds are valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a series of VoteCast event upon successful execution.\n     */\n    function voteForMany(uint256[] calldata pieceIds) public nonReentrant {\n        _voteForMany(pieceIds, msg.sender);\n    }\n\n    /**\n     * @notice Cast a vote for a list of ArtPieces pieceIds.\n     * @param pieceIds The IDs of the ArtPieces to vote for.\n     * @param from The address of the voter.\n     * @dev Requires that the pieceIds are valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a series of VoteCast event upon successful execution.\n     */\n    function _voteForMany(uint256[] calldata pieceIds, address from) internal {\n        uint256 len = pieceIds.length;\n        for (uint256 i; i < len; i++) {\n            _vote(pieceIds[i], from);\n        }\n    }\n\n    /// @notice Execute a vote via signature\n    /// @param from Vote from this address\n    /// @param pieceIds Vote on this list of pieceIds\n    /// @param deadline Deadline for the signature to be valid\n    /// @param v V component of signature\n    /// @param r R component of signature\n    /// @param s S component of signature\n    function voteForManyWithSig(\n        address from,\n        uint256[] calldata pieceIds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant {\n        bool success = _verifyVoteSignature(from, pieceIds, deadline, v, r, s);\n\n        if (!success) revert INVALID_SIGNATURE();\n\n        _voteForMany(pieceIds, from);\n    }\n\n    /// @notice Execute a batch of votes via signature, each with their own signature\n    /// @param from Vote from these addresses\n    /// @param pieceIds Vote on these lists of pieceIds\n    /// @param deadline Deadlines for the signature to be valid\n    /// @param v V component of signatures\n    /// @param r R component of signatures\n    /// @param s S component of signatures\n    function batchVoteForManyWithSig(\n        address[] memory from,\n        uint256[][] calldata pieceIds,\n        uint256[] memory deadline,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external nonReentrant {\n        uint256 len = from.length;\n        require(\n            len == pieceIds.length && len == deadline.length && len == v.length && len == r.length && len == s.length,\n            \"Array lengths must match\"\n        );\n\n        for (uint256 i; i < len; i++) {\n            if (!_verifyVoteSignature(from[i], pieceIds[i], deadline[i], v[i], r[i], s[i])) revert INVALID_SIGNATURE();\n        }\n\n        for (uint256 i; i < len; i++) {\n            _voteForMany(pieceIds[i], from[i]);\n        }\n    }\n\n    /// @notice Utility function to verify a signature for a specific vote\n    /// @param from Vote from this address\n    /// @param pieceIds Vote on this pieceId\n    /// @param deadline Deadline for the signature to be valid\n    /// @param v V component of signature\n    /// @param r R component of signature\n    /// @param s S component of signature\n    function _verifyVoteSignature(\n        address from,\n        uint256[] calldata pieceIds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal returns (bool success) {\n        require(deadline >= block.timestamp, \"Signature expired\");\n\n        bytes32 voteHash;\n\n        voteHash = keccak256(abi.encode(VOTE_TYPEHASH, from, pieceIds, nonces[from]++, deadline));\n\n        bytes32 digest = _hashTypedDataV4(voteHash);\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        // Ensure to address is not 0\n        if (from == address(0)) revert ADDRESS_ZERO();\n\n        // Ensure signature is valid\n        if (recoveredAddress == address(0) || recoveredAddress != from) revert INVALID_SIGNATURE();\n\n        return true;\n    }\n\n    /**\n     * @notice Fetch an art piece by its ID.\n     * @param pieceId The ID of the art piece.\n     * @return The ArtPiece struct associated with the given ID.\n     */\n    function getPieceById(uint256 pieceId) public view returns (ArtPiece memory) {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        return pieces[pieceId];\n    }\n\n    /**\n     * @notice Fetch the list of votes for a given art piece.\n     * @param pieceId The ID of the art piece.\n     * @return An array of Vote structs for the given art piece ID.\n     */\n    function getVote(uint256 pieceId, address voter) public view returns (Vote memory) {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        return votes[pieceId][voter];\n    }\n\n    /**\n     * @notice Fetch the top-voted art piece.\n     * @return The ArtPiece struct of the top-voted art piece.\n     */\n    function getTopVotedPiece() public view returns (ArtPiece memory) {\n        return pieces[topVotedPieceId()];\n    }\n\n    /**\n     * @notice Fetch the number of pieces\n     * @return The number of pieces\n     */\n    function pieceCount() external view returns (uint256) {\n        return _currentPieceId;\n    }\n\n    /**\n     * @notice Fetch the top-voted pieceId\n     * @return The top-voted pieceId\n     */\n    function topVotedPieceId() public view returns (uint256) {\n        require(maxHeap.size() > 0, \"Culture index is empty\");\n        //slither-disable-next-line unused-return\n        (uint256 pieceId, ) = maxHeap.getMax();\n        return pieceId;\n    }\n\n    /**\n     * @notice Admin function for setting the quorum votes basis points\n     * @dev newQuorumVotesBPS must be greater than the hardcoded min\n     * @param newQuorumVotesBPS new art piece drop threshold\n     */\n    function _setQuorumVotesBPS(uint256 newQuorumVotesBPS) external onlyOwner {\n        require(newQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS, \"CultureIndex::_setQuorumVotesBPS: invalid quorum bps\");\n        emit QuorumVotesBPSSet(quorumVotesBPS, newQuorumVotesBPS);\n\n        quorumVotesBPS = newQuorumVotesBPS;\n    }\n\n    /**\n     * @notice Current quorum votes using ERC721 Total Supply, ERC721 Vote Weight, and ERC20 Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function quorumVotes() public view returns (uint256) {\n        return\n            (quorumVotesBPS * _calculateVoteWeight(erc20VotingToken.totalSupply(), erc721VotingToken.totalSupply())) /\n            10_000;\n    }\n\n    /**\n     * @notice Pulls and drops the top-voted piece.\n     * @return The top voted piece\n     */\n    function dropTopVotedPiece() public nonReentrant returns (ArtPiece memory) {\n        require(msg.sender == dropperAdmin, \"Only dropper can drop pieces\");\n\n        ICultureIndex.ArtPiece memory piece = getTopVotedPiece();\n        require(totalVoteWeights[piece.pieceId] >= piece.quorumVotes, \"Does not meet quorum votes to be dropped.\");\n\n        //set the piece as dropped\n        pieces[piece.pieceId].isDropped = true;\n\n        //slither-disable-next-line unused-return\n        maxHeap.extractMax();\n\n        emit PieceDropped(piece.pieceId, msg.sender);\n\n        return pieces[piece.pieceId];\n    }\n\n    ///                                                          ///\n    ///                   CULTURE INDEX UPGRADE                  ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/CultureIndex.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { ERC20VotesUpgradeable } from \"./base/erc20/ERC20VotesUpgradeable.sol\";\nimport { MaxHeap } from \"./MaxHeap.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\n\nimport { ERC721CheckpointableUpgradeable } from \"./base/ERC721CheckpointableUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract CultureIndex is\n    ICultureIndex,\n    VersionedContract,\n    UUPS,\n    Ownable2StepUpgradeable,\n    ReentrancyGuardUpgradeable,\n    EIP712Upgradeable\n{\n    /// @notice The EIP-712 typehash for gasless votes\n    bytes32 public constant VOTE_TYPEHASH =\n        keccak256(\"Vote(address from,uint256[] pieceIds,uint256 nonce,uint256 deadline)\");\n\n    /// @notice An account's nonce for gasless votes\n    mapping(address => uint256) public nonces;\n\n    // The MaxHeap data structure used to keep track of the top-voted piece\n    MaxHeap public maxHeap;\n\n    // The ERC20 token used for voting\n    ERC20VotesUpgradeable public erc20VotingToken;\n\n    // The ERC721 token used for voting\n    ERC721CheckpointableUpgradeable public erc721VotingToken;\n\n    // The weight of the 721 voting token\n    uint256 public erc721VotingTokenWeight;\n\n    /// @notice The maximum settable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 6_000; // 6,000 basis points or 60%\n\n    /// @notice The minimum vote weight required in order to vote\n    uint256 public minVoteWeight;\n\n    /// @notice The basis point number of votes in support of a art piece required in order for a quorum to be reached and for an art piece to be dropped.\n    uint256 public quorumVotesBPS;\n\n    /// @notice The name of the culture index\n    string public name;\n\n    /// @notice A description of the culture index - can include rules or guidelines\n    string public description;\n\n    // The list of all pieces\n    mapping(uint256 => ArtPiece) public pieces;\n\n    // The internal piece ID tracker\n    uint256 public _currentPieceId;\n\n    // The mapping of all votes for a piece\n    mapping(uint256 => mapping(address => Vote)) public votes;\n\n    // The total voting weight for a piece\n    mapping(uint256 => uint256) public totalVoteWeights;\n\n    // Constant for max number of creators\n    uint256 public constant MAX_NUM_CREATORS = 100;\n\n    // The address that is allowed to drop art pieces\n    address public dropperAdmin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes a token's metadata descriptor\n     * @param _erc20VotingToken The address of the ERC20 voting token, commonly referred to as \"points\"\n     * @param _erc721VotingToken The address of the ERC721 voting token, commonly the dropped art pieces\n     * @param _initialOwner The owner of the contract, allowed to drop pieces. Commonly updated to the AuctionHouse\n     * @param _maxHeap The address of the max heap contract\n     * @param _dropperAdmin The address that can drop new art pieces\n     * @param _cultureIndexParams The CultureIndex settings\n     */\n    function initialize(\n        address _erc20VotingToken,\n        address _erc721VotingToken,\n        address _initialOwner,\n        address _maxHeap,\n        address _dropperAdmin,\n        IRevolutionBuilder.CultureIndexParams memory _cultureIndexParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        require(_cultureIndexParams.quorumVotesBPS <= MAX_QUORUM_VOTES_BPS, \"invalid quorum bps\");\n        require(_cultureIndexParams.erc721VotingTokenWeight > 0, \"invalid erc721 voting token weight\");\n        require(_erc721VotingToken != address(0), \"invalid erc721 voting token\");\n        require(_erc20VotingToken != address(0), \"invalid erc20 voting token\");\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(_cultureIndexParams.name, \" CultureIndex\"), \"1\");\n\n        __ReentrancyGuard_init();\n\n        erc20VotingToken = ERC20VotesUpgradeable(_erc20VotingToken);\n        erc721VotingToken = ERC721CheckpointableUpgradeable(_erc721VotingToken);\n        erc721VotingTokenWeight = _cultureIndexParams.erc721VotingTokenWeight;\n        name = _cultureIndexParams.name;\n        description = _cultureIndexParams.description;\n        quorumVotesBPS = _cultureIndexParams.quorumVotesBPS;\n        minVoteWeight = _cultureIndexParams.minVoteWeight;\n        dropperAdmin = _dropperAdmin;\n\n        emit QuorumVotesBPSSet(quorumVotesBPS, _cultureIndexParams.quorumVotesBPS);\n\n        // Create maxHeap\n        maxHeap = MaxHeap(_maxHeap);\n    }\n\n    ///                                                          ///\n    ///                         MODIFIERS                        ///\n    ///                                                          ///\n\n    /**\n     *  Validates the media type and associated data.\n     * @param metadata The metadata associated with the art piece.\n     *\n     * Requirements:\n     * - The media type must be one of the defined types in the MediaType enum.\n     * - The corresponding media data must not be empty.\n     */\n    function validateMediaType(ArtPieceMetadata calldata metadata) internal pure {\n        require(uint8(metadata.mediaType) > 0 && uint8(metadata.mediaType) <= 5, \"Invalid media type\");\n\n        if (metadata.mediaType == MediaType.IMAGE)\n            require(bytes(metadata.image).length > 0, \"Image URL must be provided\");\n        else if (metadata.mediaType == MediaType.ANIMATION)\n            require(bytes(metadata.animationUrl).length > 0, \"Animation URL must be provided\");\n        else if (metadata.mediaType == MediaType.TEXT)\n            require(bytes(metadata.text).length > 0, \"Text must be provided\");\n    }\n\n    /**\n     * @notice Checks the total basis points from an array of creators and returns the length\n     * @param creatorArray An array of Creator structs containing address and basis points.\n     * @return Returns the total basis points calculated from the array of creators.\n     *\n     * Requirements:\n     * - The `creatorArray` must not contain any zero addresses.\n     * - The function will return the length of the `creatorArray`.\n     */\n    function validateCreatorsArray(CreatorBps[] calldata creatorArray) internal pure returns (uint256) {\n        uint256 creatorArrayLength = creatorArray.length;\n        //Require that creatorArray is not more than MAX_NUM_CREATORS to prevent gas limit issues\n        require(creatorArrayLength <= MAX_NUM_CREATORS, \"Creator array must not be > MAX_NUM_CREATORS\");\n\n        uint256 totalBps;\n        for (uint i; i < creatorArrayLength; i++) {\n            require(creatorArray[i].creator != address(0), \"Invalid creator address\");\n            totalBps += creatorArray[i].bps;\n        }\n\n        require(totalBps == 10_000, \"Total BPS must sum up to 10,000\");\n\n        return creatorArrayLength;\n    }\n\n    /**\n     * @notice Creates a new piece of art with associated metadata and creators.\n     * @param metadata The metadata associated with the art piece, including name, description, image, and optional animation URL.\n     * @param creatorArray An array of creators who contributed to the piece, along with their respective basis points that must sum up to 10,000.\n     * @return Returns the unique ID of the newly created art piece.\n     *\n     * Emits a {PieceCreated} event for the newly created piece.\n     * Emits a {PieceCreatorAdded} event for each creator added to the piece.\n     *\n     * Requirements:\n     * - `metadata` must include name, description, and image. Animation URL is optional.\n     * - `creatorArray` must not contain any zero addresses.\n     * - The sum of basis points in `creatorArray` must be exactly 10,000.\n     */\n    function createPiece(\n        ArtPieceMetadata calldata metadata,\n        CreatorBps[] calldata creatorArray\n    ) public returns (uint256) {\n        uint256 creatorArrayLength = validateCreatorsArray(creatorArray);\n\n        // Validate the media type and associated data\n        validateMediaType(metadata);\n\n        uint256 pieceId = _currentPieceId++;\n\n        /// @dev Insert the new piece into the max heap\n        maxHeap.insert(pieceId, 0);\n\n        ArtPiece storage newPiece = pieces[pieceId];\n\n        newPiece.pieceId = pieceId;\n        newPiece.totalVotesSupply = _calculateVoteWeight(\n            erc20VotingToken.totalSupply(),\n            erc721VotingToken.totalSupply()\n        );\n        newPiece.totalERC20Supply = erc20VotingToken.totalSupply();\n        newPiece.metadata = metadata;\n        newPiece.sponsor = msg.sender;\n        newPiece.creationBlock = block.number;\n        newPiece.quorumVotes = (quorumVotesBPS * newPiece.totalVotesSupply) / 10_000;\n\n        for (uint i; i < creatorArrayLength; i++) {\n            newPiece.creators.push(creatorArray[i]);\n        }\n\n        emit PieceCreated(pieceId, msg.sender, metadata, newPiece.q"
    }
  ]
}