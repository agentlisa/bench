{
  "Title": "[01] Callers/buyers can control `protocolRewardsRecipients` to receive self-rebates",
  "Content": "The `ERC20TokenEmitter.buyToken()` function is designed in such a way that the caller (or buyer) can fully control the `protocolRewardsRecipients` parameter, which includes the `builder`, `purchaseReferral`, and `deployer` addresses. This design allows the caller to potentially assign all these addresses to themselves.\n\nhttps://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/ERC20TokenEmitter.sol#L152-L170\n\n```solidity\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        //prevent treasury from paying itself\n        require(msg.sender != treasury && msg.sender != creatorsAddress, \"Funds recipient cannot buy tokens\");\n\n        require(msg.value > 0, \"Must send ether\");\n        // ensure the same number of addresses and bps\n        require(addresses.length == basisPointSplits.length, \"Parallel arrays required\");\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n```\nGiven this setup, if a caller assigns all three addresses (builder, purchaseReferral, deployer) to themselves, they could indeed benefit from the rewards percentages assigned to each of these roles. In the code, the basis points (BPS) for each reward are defined as constants:\n\nhttps://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/protocol-rewards/src/abstract/RewardSplits.sol#L17-L21\n\n- BUILDER\\_REWARD\\_BPS = 100 BPS (0.1%)\n- PURCHASE\\_REFERRAL\\_BPS = 50 BPS (0.05%)\n- DEPLOYER\\_REWARD\\_BPS = 25 BPS (0.025%)\n\nWhen summed up, these total to 1.75% (175 BPS). So, if the buyer sets themselves as the recipient for all these rewards, they would effectively be receiving a 1.75% reward on their purchase value.\n\nThis could be a feature or a vulnerability, depending on the intended use and design of the contract:\n\n1. **Feature**: If this mechanism is intentional, it might be designed to incentivize certain behaviors, like encouraging users to participate more actively in the ecosystem or rewarding them for different roles they play.\n2. **Vulnerability**: If this was not an intended use case, it could be exploited by users to unjustly reward themselves, undermining the fairness of the reward distribution system.\n\nTo address this, if it's deemed a vulnerability, the smart contract could be updated to include checks that prevent the same address from being used for all these roles or to implement a more robust system for assigning these rewards. This requires careful consideration of the contract's intended economics and security implications.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/ERC20TokenEmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { TokenEmitterRewards } from \"@collectivexyz/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport { VRGDAC } from \"./libs/VRGDAC.sol\";\nimport { toDaysWadUnsafe } from \"./libs/SignedWadMath.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { NontransferableERC20Votes } from \"./NontransferableERC20Votes.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract ERC20TokenEmitter is\n    IERC20TokenEmitter,\n    ReentrancyGuardUpgradeable,\n    TokenEmitterRewards,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable\n{\n    // treasury address to pay funds to\n    address public treasury;\n\n    // The token that is being minted.\n    NontransferableERC20Votes public token;\n\n    // The VRGDA contract\n    VRGDAC public vrgdac;\n\n    // solhint-disable-next-line not-rely-on-time\n    uint256 public startTime;\n\n    /**\n     * @notice A running total of the amount of tokens emitted.\n     */\n    int256 public emittedTokenWad;\n\n    // The split of the purchase that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The split of (purchase proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The account or contract to pay the creator reward to\n    address public creatorsAddress;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _protocolRewards The protocol rewards contract address\n    /// @param _protocolFeeRecipient The protocol fee recipient address\n    constructor(\n        address _manager,\n        address _protocolRewards,\n        address _protocolFeeRecipient\n    ) payable TokenEmitterRewards(_protocolRewards, _protocolFeeRecipient) initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the token emitter\n     * @param _initialOwner The initial owner of the token emitter\n     * @param _erc20Token The ERC-20 token contract address\n     * @param _vrgdac The VRGDA contract address\n     * @param _treasury The treasury address to pay funds to\n     * @param _creatorsAddress The address to pay the creator reward to\n     */\n    function initialize(\n        address _initialOwner,\n        address _erc20Token,\n        address _treasury,\n        address _vrgdac,\n        address _creatorsAddress\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        require(_treasury != address(0), \"Invalid treasury address\");\n\n        // Set up ownable\n        __Ownable_init(_initialOwner);\n\n        treasury = _treasury;\n        creatorsAddress = _creatorsAddress;\n        vrgdac = VRGDAC(_vrgdac);\n        token = NontransferableERC20Votes(_erc20Token);\n        startTime = block.timestamp;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        token.mint(_to, _amount);\n    }\n\n    function totalSupply() public view returns (uint) {\n        // returns total supply issued so far\n        return token.totalSupply();\n    }\n\n    function decimals() public view returns (uint8) {\n        // returns decimals\n        return token.decimals();\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        // returns balance of address\n        return token.balanceOf(_owner);\n    }\n\n    /**\n     * @notice Pause the contract.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the token emitter.\n     * @dev This function can only be called by the owner when the\n     * contract is paused.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice A payable function that allows a user to buy tokens for a list of addresses and a list of basis points to split the token purchase between.\n     * @param addresses The addresses to send purchased tokens to.\n     * @param basisPointSplits The basis points of the purchase to send to each address.\n     * @param protocolRewardsRecipients The addresses to pay the builder, purchaseRefferal, and deployer rewards to\n     * @return tokensSoldWad The amount of tokens sold in wad units.\n     */\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        //prevent treasury from paying itself\n        require(msg.sender != treasury && msg.sender != creatorsAddress, \"Funds recipient cannot buy tokens\");\n\n        require(msg.value > 0, \"Must send ether\");\n        // ensure the same number of addresses and bps\n        require(addresses.length == basisPointSplits.length, \"Parallel arrays required\");\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n        uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n        uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to buyers\n        int totalTokensForBuyers = toPayTreasury > 0 ? getTokenQuoteForEther(toPayTreasury) : int(0);\n\n        //Transfer ETH to treasury and update emitted\n        emittedTokenWad += totalTokensForBuyers;\n        if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n\n        //Deposit funds to treasury\n        (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0));\n        require(success, \"Transfer failed.\");\n\n        //Transfer ETH to creators\n        if (creatorDirectPayment > 0) {\n            (success, ) = creatorsAddress.call{ value: creatorDirectPayment }(new bytes(0));\n            require(success, \"Transfer failed.\");\n        }\n\n        //Mint tokens for creators\n        if (totalTokensForCreators > 0 && creatorsAddress != address(0)) {\n            _mint(creatorsAddress, uint256(totalTokensForCreators));\n        }\n\n        uint256 bpsSum = 0;\n\n        //Mint tokens to buyers\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (totalTokensForBuyers > 0) {\n                // transfer tokens to address\n                _mint(addresses[i], uint256((totalTokensForBuyers * int(basisPointSplits[i])) / 10_000));\n            }\n            bpsSum += basisPointSplits[i];\n        }\n\n        require(bpsSum == 10_000, \"bps must add up to 10_000\");\n\n        emit PurchaseFinalized(\n            msg.sender,\n            msg.value,\n            toPayTreasury,\n            msg.value - msgValueRemaining,\n            uint256(totalTokensForBuyers),\n            uint256(totalTokensForCreators),\n            creatorDirectPayment\n        );\n\n        return uint256(totalTokensForBuyers);\n    }\n\n    /**\n     * @notice Returns the amount of wei that would be spent to buy an amount of tokens. Does not take into account the protocol rewards.\n     * @param amount the amount of tokens to buy.\n     * @return spentY The cost in wei of the token purchase.\n     */\n    function buyTokenQuote(uint256 amount) public view returns (int spentY) {\n        require(amount > 0, \"Amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.xToY({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(amount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for an amount of wei. Does not take into account the protocol rewards.\n     * @param etherAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForEther(uint256 etherAmount) public view returns (int gainedX) {\n        require(etherAmount > 0, \"Ether amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(etherAmount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for the payment amount, taking into account the protocol rewards.\n     * @param paymentAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForPayment(uint256 paymentAmount) external view returns (int gainedX) {\n        require(paymentAmount > 0, \"Payment amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(((paymentAmount - computeTotalReward(paymentAmount)) * (10_000 - creatorRateBps)) / 10_000)\n            });\n    }\n\n    /**\n     * @notice Set the split of (purchase * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        emit EntropyRateBpsUpdated(entropyRateBps = _entropyRateBps);\n    }\n\n    /**\n     * @notice Set the split of the payment that is reserved for creators in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n\n        emit CreatorRateBpsUpdated(creatorRateBps = _creatorRateBps);\n    }\n\n    /**\n     * @notice Set the creators address to pay the creatorRate to. Can be a contract.\n     * @dev Only callable by the owner.\n     */\n    function setCreatorsAddress(address _creatorsAddress) external override onlyOwner nonReentrant {\n        require(_creatorsAddress != address(0), \"Invalid address\");\n\n        emit CreatorsAddressUpdated(creatorsAddress = _creatorsAddress);\n    }\n}"
    },
    {
      "filename": "packages/protocol-rewards/src/abstract/RewardSplits.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport { IRevolutionProtocolRewards } from \"../interfaces/IRevolutionProtocolRewards.sol\";\n\nstruct RewardsSettings {\n    uint256 builderReferralReward;\n    uint256 purchaseReferralReward;\n    uint256 deployerReward;\n    uint256 revolutionReward;\n}\n\n/// @notice Common logic for Revolution ERC20TokenEmitter contracts for protocol reward splits & deposits\nabstract contract RewardSplits {\n    error INVALID_ETH_AMOUNT();\n\n    // 2.5% total\n    uint256 internal constant DEPLOYER_REWARD_BPS = 25;\n    uint256 internal constant REVOLUTION_REWARD_BPS = 75;\n    uint256 internal constant BUILDER_REWARD_BPS = 100;\n    uint256 internal constant PURCHASE_REFERRAL_BPS = 50;\n\n    uint256 public constant minPurchaseAmount = 0.0000001 ether;\n    uint256 public constant maxPurchaseAmount = 50_000 ether;\n\n    address internal immutable revolutionRewardRecipient;\n    IRevolutionProtocolRewards internal immutable protocolRewards;\n\n    constructor(address _protocolRewards, address _revolutionRewardRecipient) payable {\n        if (_protocolRewards == address(0) || _revolutionRewardRecipient == address(0)) revert(\"Invalid Address Zero\");\n\n        protocolRewards = IRevolutionProtocolRewards(_protocolRewards);\n        revolutionRewardRecipient = _revolutionRewardRecipient;\n    }\n\n    /*\n     * @notice Sometimes has rounding errors vs. compute purchase rewards, use externally.\n     * @param _paymentAmountWei The amount of ETH being paid for the purchase\n     */\n    function computeTotalReward(uint256 paymentAmountWei) public pure returns (uint256) {\n        if (paymentAmountWei <= minPurchaseAmount || paymentAmountWei >= maxPurchaseAmount) revert INVALID_ETH_AMOUNT();\n\n        return\n            (paymentAmountWei * BUILDER_REWARD_BPS) /\n            10_000 +\n            (paymentAmountWei * PURCHASE_REFERRAL_BPS) /\n            10_000 +\n            (paymentAmountWei * DEPLOYER_REWARD_BPS) /\n            10_000 +\n            (paymentAmountWei * REVOLUTION_REWARD_BPS) /\n            10_000;\n    }\n\n    function computePurchaseRewards(uint256 paymentAmountWei) public pure returns (RewardsSettings memory, uint256) {\n        return (\n            RewardsSettings({\n                builderReferralReward: (paymentAmountWei * BUILDER_REWARD_BPS) / 10_000,\n                purchaseReferralReward: (paymentAmountWei * PURCHASE_REFERRAL_BPS) / 10_000,\n                deployerReward: (paymentAmountWei * DEPLOYER_REWARD_BPS) / 10_000,\n                revolutionReward: (paymentAmountWei * REVOLUTION_REWARD_BPS) / 10_000\n            }),\n            computeTotalReward(paymentAmountWei)\n        );\n    }\n\n    function _depositPurchaseRewards(\n        uint256 paymentAmountWei,\n        address builderReferral,\n        address purchaseReferral,\n        address deployer\n    ) internal returns (uint256) {\n        (RewardsSettings memory settings, uint256 totalReward) = computePurchaseRewards(paymentAmountWei);\n\n        if (builderReferral == address(0)) builderReferral = revolutionRewardRecipient;\n\n        if (deployer == address(0)) deployer = revolutionRewardRecipient;\n\n        if (purchaseReferral == address(0)) purchaseReferral = revolutionRewardRecipient;\n\n        protocolRewards.depositRewards{ value: totalReward }(\n            builderReferral,\n            settings.builderReferralReward,\n            purchaseReferral,\n            settings.purchaseReferralReward,\n            deployer,\n            settings.deployerReward,\n            revolutionRewardRecipient,\n            settings.revolutionReward\n        );\n\n        return totalReward;\n    }\n}"
    }
  ]
}