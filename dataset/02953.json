{
  "Title": "Protocol administrator needs to handle external tokens",
  "Content": "The protocol administrator is one of the most critical roles with immense privilege in the operation of the entire protocol. For example, only the administrator can [re-initialize](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Protocol.sol#L78) the protocol, [grant key access control roles](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Protocol.sol#L283-L287), as well as set up all [staking](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Staking/StakingPoolBase.sol#L45) and [bonding](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Bond/BondPoolBase.sol#L54) pools.\n\n\nHowever, when [setting up a staking pool](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Staking/StakingPoolBase.sol#L36-L46), a [non-zero amount](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L120) of reward tokens are required to be pre-transferred to the administrator account and [pulled to the contract](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L170). This implies that the administrator needs to receive and approve the transaction a priori. This increases the attack surface and may not fit the intended security assumptions for a critical role.\n\n\nConsider either using a less critical role to perform staking pool initialization or allowing pool initialization without any token transfer.\n\n\n**Update:** *Fixed as of commit `71fd05996061b9c438c557c92cd888f4f4c9c542` in [pull request #173](https://github.com/neptune-mutual-blue/protocol/pull/173). The Liquidity Manager must now initialise and manage the staking pools. They must also set up the Bond pools.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/Protocol.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../interfaces/IStore.sol\";\nimport \"../interfaces/IProtocol.sol\";\nimport \"../libraries/ProtoUtilV1.sol\";\nimport \"../libraries/StoreKeyUtil.sol\";\nimport \"./ProtoBase.sol\";\n\ncontract Protocol is IProtocol, ProtoBase {\n  using ProtoUtilV1 for bytes;\n  using RegistryLibV1 for IStore;\n  using ProtoUtilV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using StoreKeyUtil for IStore;\n\n  bool public initialized = false;\n\n  constructor(IStore store) ProtoBase(store) {} // solhint-disable-line\n\n  /**\n   * @dev Initializes the protocol once. There is only one instance of the protocol\n   * that can function.\n   *\n   * @custom:suppress-acl Can only be called by the deployer or an admin\n   * @custom:suppress-initialization Can only be initialized by the deployer or an admin\n   * @custom:note Burner isn't necessarily the zero address. The tokens to be burned are sent to an address,\n   * bridged back to the Ethereum mainnet (if on a different chain), and burned on a period but random basis.\n   *\n   *\n   * @param addresses[0] burner\n   * @param addresses[1] uniswapV2RouterLike\n   * @param addresses[2] uniswapV2FactoryLike\n   * @param addresses[3] npm\n   * @param addresses[4] treasury\n   * @param addresses[5] npm price oracle\n   * @param values[0] coverCreationFee\n   * @param values[1] minCoverCreationStake\n   * @param values[2] firstReportingStake\n   * @param values[3] claimPeriod\n   * @param values[4] reportingBurnRate\n   * @param values[5] governanceReporterCommission\n   * @param values[6] claimPlatformFee\n   * @param values[7] claimReporterCommission\n   * @param values[8] flashLoanFee\n   * @param values[9] flashLoanFeeProtocol\n   * @param values[10] resolutionCoolDownPeriod\n   * @param values[11] state and liquidity update interval\n   * @param values[12] max lending ratio\n   */\n  function initialize(address[] calldata addresses, uint256[] calldata values) external override nonReentrant whenNotPaused {\n    s.mustBeProtocolMember(msg.sender);\n\n    require(addresses[0] != address(0), \"Invalid Burner\");\n    // require(addresses[1] != address(0), \"Invalid Uniswap V2 Router\");\n    // require(addresses[2] != address(0), \"Invalid Uniswap V2 Factory\");\n    // require(addresses[3] != address(0), \"Invalid NPM\"); // @note: check validation below\n    require(addresses[4] != address(0), \"Invalid Treasury\");\n    // require(addresses[5] != address(0), \"Invalid NPM Price Oracle\");\n\n    // @suppress-zero-value-check @suppress-accidental-zero Some zero values are allowed\n    // These checks are disabled as this function is only accessible to an admin\n    // require(values[0] > 0, \"Invalid cover creation fee\");\n    // require(values[1] > 0, \"Invalid cover creation stake\");\n    // require(values[2] > 0, \"Invalid first reporting stake\");\n    // require(values[3] > 0, \"Invalid claim period\");\n    // require(values[4] > 0, \"Invalid reporting burn rate\");\n    // require(values[5] > 0, \"Invalid reporter income: NPM\");\n    // require(values[6] > 0, \"Invalid platform fee: claims\");\n    // require(values[7] > 0, \"Invalid reporter income: claims\");\n    // require(values[8] > 0, \"Invalid vault fee: flashloan\");\n    // require(values[9] > 0, \"Invalid platform fee: flashloan\");\n    // require(values[10] >= 24 hours, \"Invalid cooldown period\");\n    // require(values[11] > 0, \"Invalid state update interval\");\n    // require(values[12] > 0, \"Invalid max lending ratio\");\n\n    if (initialized == true) {\n      AccessControlLibV1.mustBeAdmin(s);\n      require(addresses[3] == address(0), \"Can't change NPM\");\n    } else {\n      require(addresses[3] != address(0), \"Invalid NPM\");\n\n      s.setAddressByKey(ProtoUtilV1.CNS_CORE, address(this));\n      s.setBoolByKeys(ProtoUtilV1.NS_CONTRACTS, address(this), true);\n\n      s.setAddressByKey(ProtoUtilV1.CNS_NPM, addresses[3]);\n    }\n\n    s.setAddressByKey(ProtoUtilV1.CNS_BURNER, addresses[0]);\n\n    s.setAddressByKey(ProtoUtilV1.CNS_UNISWAP_V2_ROUTER, addresses[1]);\n    s.setAddressByKey(ProtoUtilV1.CNS_UNISWAP_V2_FACTORY, addresses[2]);\n    s.setAddressByKey(ProtoUtilV1.CNS_TREASURY, addresses[4]);\n    s.setAddressByKey(ProtoUtilV1.CNS_NPM_PRICE_ORACLE, addresses[5]);\n\n    s.setUintByKey(ProtoUtilV1.NS_COVER_CREATION_FEE, values[0]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_CREATION_MIN_STAKE, values[1]);\n    s.setUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTING_MIN_FIRST_STAKE, values[2]);\n    s.setUintByKey(ProtoUtilV1.NS_CLAIM_PERIOD, values[3]);\n    s.setUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTING_BURN_RATE, values[4]);\n    s.setUintByKey(ProtoUtilV1.NS_GOVERNANCE_REPORTER_COMMISSION, values[5]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_PLATFORM_FEE, values[6]);\n    s.setUintByKey(ProtoUtilV1.NS_CLAIM_REPORTER_COMMISSION, values[7]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_LIQUIDITY_FLASH_LOAN_FEE, values[8]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_LIQUIDITY_FLASH_LOAN_FEE_PROTOCOL, values[9]);\n    s.setUintByKey(ProtoUtilV1.NS_RESOLUTION_COOL_DOWN_PERIOD, values[10]);\n    s.setUintByKey(ProtoUtilV1.NS_LIQUIDITY_STATE_UPDATE_INTERVAL, values[11]);\n    s.setUintByKey(ProtoUtilV1.NS_COVER_LIQUIDITY_MAX_LENDING_RATIO, values[12]);\n    s.setUintByKey(ProtoUtilV1.NS_COVERAGE_LAG, 1 days);\n\n    initialized = true;\n    emit Initialized(addresses, values);\n  }\n\n  /**\n   * @dev Adds member to the protocol\n   *\n   * A member is a trusted EOA or a contract that was added to the protocol using `addContract`\n   * function. When a contract is removed using `upgradeContract` function, the membership of previous\n   * contract is also removed.\n   *\n   * @custom:warning Warning:\n   *\n   * This feature is only accessible to an upgrade agent.\n   * Since adding member to the protocol is a highy risky activity,\n   * the role `Upgrade Agent` is considered to be one of the most `Critical` roles.\n   *\n   * Using Tenderly War Rooms/Web3 Actions or OZ Defender, the protocol needs to be paused\n   * when this function is invoked.\n   *\n   * @custom:suppress-address-trust-issue The address `member` can be trusted because this can only come from upgrade agents.\n   *\n   * @param member Enter an address to add as a protocol member\n   */\n  function addMember(address member) external override nonReentrant whenNotPaused {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeUpgradeAgent(s);\n\n    AccessControlLibV1.addMemberInternal(s, member);\n    emit MemberAdded(member);\n  }\n\n  /**\n   * @dev Removes a member from the protocol. This function is only accessible\n   * to an upgrade agent.\n   *\n   * @custom:suppress-address-trust-issue The address `member` can be trusted because of the ACL requirement.\n   *\n   * @param member Enter an address to remove as a protocol member\n   */\n  function removeMember(address member) external override nonReentrant whenNotPaused {\n    ProtoUtilV1.mustBeProtocolMember(s, member);\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeUpgradeAgent(s);\n\n    AccessControlLibV1.removeMemberInternal(s, member);\n    emit MemberRemoved(member);\n  }\n\n  /**\n   * @dev Adds a contract to the protocol. See `addContractWithKey` for more info.\n   * @custom:suppress-acl This function is just an intermediate\n   * @custom:suppress-pausable This function is just an intermediate\n   */\n  function addContract(bytes32 namespace, address contractAddress) external override {\n    addContractWithKey(namespace, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY, contractAddress);\n  }\n\n  /**\n   * @dev Adds a contract to the protocol using a namespace and key.\n   *\n   * The contracts that are added using this function are also added as protocol members.\n   * Each contract you add to the protocol needs to also specify the namespace and also\n   * key if applicable. The key is useful when multiple instances of a contract can\n   * be deployed. For example, multiple instances of cxTokens and Vaults can be deployed on demand.\n   *\n   * Tip: find out how the `getVaultFactoryContract().deploy` function is being used.\n   *\n   * @custom:warning Warning:\n   *\n   * This feature is only accessible to an upgrade agent.\n   * Since adding member to the protocol is a highy risky activity,\n   * the role `Upgrade Agent` is considered to be one of the most `Critical` roles.\n   *\n   * Using Tenderly War Rooms/Web3 Actions or OZ Defender, the protocol needs to be paused\n   * when this function is invoked.\n   *\n   * @custom:suppress-address-trust-issue Although the `contractAddress` can't be trusted,\n   * an upgrade admin has to check the contract code manually.\n   *\n   * @param namespace Enter a unique namespace for this contract\n   * @param key Enter a key if this contract has siblings\n   * @param contractAddress Enter the contract address to add.\n   *\n   */\n  function addContractWithKey(\n    bytes32 namespace,\n    bytes32 key,\n    address contractAddress\n  ) public override nonReentrant whenNotPaused {\n    require(contractAddress != address(0), \"Invalid contract\");\n\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeUpgradeAgent(s);\n    address current = s.getProtocolContract(namespace);\n\n    require(current == address(0), \"Please upgrade contract\");\n\n    AccessControlLibV1.addContractInternal(s, namespace, key, contractAddress);\n    emit ContractAdded(namespace, key, contractAddress);\n  }\n\n  /**\n   * @dev Upgrades a contract at the given namespace. See `upgradeContractWithKey` for more info.\n   *\n   * @custom:suppress-acl This function is just an intermediate\n   * @custom:suppress-pausable This function is just an intermediate\n   *\n   */\n  function upgradeContract(\n    bytes32 namespace,\n    address previous,\n    address current\n  ) external override {\n    upgradeContractWithKey(namespace, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY, previous, current);\n  }\n\n  /**\n   * @dev Upgrades a contract at the given namespace and key.\n   *\n   * The previous contract's protocol membership is revoked and\n   * the current immediately starts assuming responsbility of\n   * whatever the contract needs to do at the supplied namespace and key.\n   *\n   * @custom:warning Warning:\n   *\n   * This feature is only accessible to an upgrade agent.\n   * Since adding member to the protocol is a highy risky activity,\n   * the role `Upgrade Agent` is considered to be one of the most `Critical` roles.\n   *\n   * Using Tenderly War Rooms/Web3 Actions or OZ Defender, the protocol needs to be paused\n   * when this function is invoked.\n   *\n   * @custom:suppress-address-trust-issue Can only be invoked by an upgrade agent.\n   *\n   * @param namespace Enter a unique namespace for this contract\n   * @param key Enter a key if this contract has siblings\n   * @param previous Enter the existing contract address at this namespace and key.\n   * @param current Enter the contract address which will replace the previous contract.\n   */\n  function upgradeContractWithKey(\n    bytes32 namespace,\n    bytes32 key,\n    address previous,\n    address current\n  ) public override nonReentrant whenNotPaused {\n    require(current != address(0), \"Invalid contract\");\n\n    ProtoUtilV1.mustBeProtocolMember(s, previous);\n    ProtoUtilV1.mustBeExactContract(s, namespace, key, previous);\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeUpgradeAgent(s);\n\n    AccessControlLibV1.upgradeContractInternal(s, namespace, key, previous, current);\n    emit ContractUpgraded(namespace, key, previous, current);\n  }\n\n  /**\n   * @dev Grants roles to the protocol.\n   *\n   * Individual Neptune Mutual protocol contracts inherit roles\n   * defined to this contract. Meaning, the `AccessControl` logic\n   * here is used everywhere else.\n   *\n   * @custom:warning Warning:\n   *\n   * This feature is only accessible to an admin. Adding any kind of role to the protocol is immensely risky.\n   *\n   * Using Tenderly War Rooms/Web3 Actions or OZ Defender, the protocol needs to be paused\n   * when this function is invoked.\n   *\n   */\n  function grantRoles(AccountWithRoles[] calldata detail) external override nonReentrant whenNotPaused {\n    // @suppress-zero-value-check Checked\n    require(detail.length > 0, \"Invalid args\");\n    AccessControlLibV1.mustBeAdmin(s);\n\n    for (uint256 i = 0; i < detail.length; i++) {\n      for (uint256 j = 0; j < detail[i].roles.length; j++) {\n        _grantRole(detail[i].roles[j], detail[i].account);\n      }\n    }\n  }\n\n  /**\n   * @dev Version number of this contract\n   */\n  function version() external pure override returns (bytes32) {\n    return \"v0.1\";\n  }\n\n  /**\n   * @dev Name of this contract\n   */\n  function getName() external pure override returns (bytes32) {\n    return ProtoUtilV1.CNAME_PROTOCOL;\n  }\n}"
    },
    {
      "filename": "contracts/pool/Staking/StakingPoolBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"../../interfaces/IStore.sol\";\nimport \"../../interfaces/IStakingPools.sol\";\nimport \"../../libraries/AccessControlLibV1.sol\";\nimport \"../../libraries/ValidationLibV1.sol\";\nimport \"../../libraries/StoreKeyUtil.sol\";\nimport \"../../libraries/StakingPoolCoreLibV1.sol\";\nimport \"../../libraries/StakingPoolLibV1.sol\";\nimport \"../../core/Recoverable.sol\";\n\nabstract contract StakingPoolBase is IStakingPools, Recoverable {\n  using AccessControlLibV1 for IStore;\n  using ValidationLibV1 for IStore;\n  using StoreKeyUtil for IStore;\n  using StakingPoolCoreLibV1 for IStore;\n\n  constructor(IStore s) Recoverable(s) {} //solhint-disable-line\n\n  /**\n   * @dev Adds or edits the pool by key\n   * @param key Enter the key of the pool you want to create or edit\n   * @param name Enter a name for this pool\n   * @param poolType Specify the pool type: TokenStaking or PODStaking\n   * @param addresses[0] stakingToken The token which is staked in this pool\n   * @param addresses[1] uniStakingTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   * @param addresses[2] rewardToken The token which is rewarded in this pool\n   * @param addresses[3] uniRewardTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   * @param values[0] stakingTarget Specify the target amount in the staking token. You can not exceed the target.\n   * @param values[1] maxStake Specify the maximum amount that can be staken at a time.\n   * @param values[2] platformFee Enter the platform fee which is deducted on reward and on the reward token\n   * @param values[3] rewardPerBlock Specify the amount of reward token awarded per block\n   * @param values[4] lockupPeriodInBlocks Enter a lockup period during when the staked tokens can't be withdrawn\n   * @param values[5] rewardTokenDeposit Enter the value of reward token you are depositing in this transaction.\n   */\n  function addOrEditPool(\n    bytes32 key,\n    string calldata name,\n    StakingPoolType poolType,\n    address[] calldata addresses,\n    uint256[] calldata values\n  ) external override nonReentrant {\n    // @suppress-zero-value-check The uint values are checked in the function `addOrEditPoolInternal`\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeAdmin(s);\n\n    s.addOrEditPoolInternal(key, name, addresses, values);\n    emit PoolUpdated(key, name, poolType, addresses[0], addresses[1], addresses[2], addresses[3], values[5], values[1], values[3], values[4], values[2]);\n  }\n\n  function closePool(bytes32 key) external override nonReentrant {\n    s.mustNotBePaused();\n    AccessControlLibV1.mustBeAdmin(s);\n    require(s.getBoolByKeys(StakingPoolCoreLibV1.NS_POOL, key), \"Unknown Pool\");\n\n    s.deleteBoolByKeys(StakingPoolCoreLibV1.NS_POOL, key);\n    emit PoolClosed(key, s.getStringByKeys(StakingPoolCoreLibV1.NS_POOL, key));\n  }\n\n  /**\n   * @dev Version number of this contract\n   */\n  function version() external pure override returns (bytes32) {\n    return \"v0.1\";\n  }\n\n  /**\n   * @dev Name of this contract\n   */\n  function getName() external pure override returns (bytes32) {\n    return ProtoUtilV1.CNAME_STAKING_POOL;\n  }\n}"
    }
  ]
}