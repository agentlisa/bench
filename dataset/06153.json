{
  "Title": "[M-03] `RemoteAddressValidator` can incorrectly convert addresses to lowercase",
  "Content": "\nThe `validateSender` and `addTrustedAddress` functions of `RemoteAddressValidator` can incorrectly handle the passed address arguments, which will result in false negatives. E.g. a valid sender address may be invalidated.\n\n### Proof of Concept\n\nThe [RemoteAddressValidator.\\_lowerCase](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/remote-address-validator/RemoteAddressValidator.sol#L54) function is used to convert an address to lowercase. Since the protocol is expected to support different EVM and non-EVM chains, account addresses may have different format, thus the necessity to convert them to strings and to convert the strings to lowercase when comparing them. However, the function only converts the hexadecimal letters, i.e. the characters in ranges A-F:\n\n```solidity\nif ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n```\n\nHere, `65` corresponds to `A`, and `70` corresponds to `F`. But, since different EVM and non-EVM chains are supported, addresses can contain other characters. For example, [Cosmos uses bech32 addresses](https://docs.cosmos.network/main/spec/addresses/bech32) and [Evmos supports both hexadecimal and bech32 addresses](https://docs.evmos.org/protocol/concepts/accounts#address-formats-for-clients).\n\nIf not all alphabetical characters of an address are converted to lowercase, then the address comparison in the [validateSender](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/remote-address-validator/RemoteAddressValidator.sol#L69) can fail and result in a false revert.\n\n### Recommended Mitigation Steps\n\nIn the `_lowerCase` function, consider converting all alphabetical characters to lowercase, e.g.:\n\n```diff\ndiff --git a/contracts/its/remote-address-validator/RemoteAddressValidator.sol b/contracts/its/remote-address-validator/RemoteAddressValidator.sol\nindex bb101e5..e83431b 100644\n--- a/contracts/its/remote-address-validator/RemoteAddressValidator.sol\n+++ b/contracts/its/remote-address-validator/RemoteAddressValidator.sol\n@@ -55,7 +55,7 @@ contract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n         uint256 length = bytes(s).length;\n         for (uint256 i; i < length; i++) {\n             uint8 b = uint8(bytes(s)[i]);\n-            if ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n+            if ((b >= 65) && (b <= 90)) bytes(s)[i] = bytes1(b + uint8(32));\n         }\n         return s;\n     }\n```\n\n**[deanamiel (Axelar) disagreed with severity and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/323#issuecomment-1695942282):**\n> Corrected Severity: QA\n>\n> This was originally meant to cover the EVM addresses, but we implemented a fix to account for non-EVM addresses as well.\n>\n> Public PR link:\n> https://github.com/axelarnetwork/interchain-token-service/pull/96\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/323#issuecomment-1702641616):**\n > I'm maintaining the medium severity for this issue as it prevents using any non-EVM addresses.\n\n**[milapsheth (Axelar) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/323#issuecomment-1801759103):**\n> We consider this finding QA or Low severity since the scope of the implementation is for EVM chains (even though Axelar's cross-chain messaging API is generic). Non EVM chains require further consideration that wasn't the focus for this version.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/remote-address-validator/RemoteAddressValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { AddressToString } from '../../gmp-sdk/util/AddressString.sol';\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\n\n/**\n * @title RemoteAddressValidator\n * @dev Manages and validates remote addresses, keeps track of addresses supported by the Axelar gateway contract\n */\ncontract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n    using AddressToString for address;\n\n    mapping(string => bytes32) public remoteAddressHashes;\n    mapping(string => string) public remoteAddresses;\n    address public immutable interchainTokenServiceAddress;\n    bytes32 public immutable interchainTokenServiceAddressHash;\n    mapping(string => bool) public supportedByGateway;\n\n    bytes32 private constant CONTRACT_ID = keccak256('remote-address-validator');\n\n    /**\n     * @dev Constructs the RemoteAddressValidator contract, both array parameters must be equal in length\n     * @param _interchainTokenServiceAddress Address of the interchain token service\n     */\n    constructor(address _interchainTokenServiceAddress) {\n        if (_interchainTokenServiceAddress == address(0)) revert ZeroAddress();\n        interchainTokenServiceAddress = _interchainTokenServiceAddress;\n        interchainTokenServiceAddressHash = keccak256(bytes(_lowerCase(interchainTokenServiceAddress.toString())));\n    }\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    function _setup(bytes calldata params) internal override {\n        (string[] memory trustedChainNames, string[] memory trustedAddresses) = abi.decode(params, (string[], string[]));\n        uint256 length = trustedChainNames.length;\n        if (length != trustedAddresses.length) revert LengthMismatch();\n        for (uint256 i; i < length; ++i) {\n            addTrustedAddress(trustedChainNames[i], trustedAddresses[i]);\n        }\n    }\n\n    /**\n     * @dev Converts a string to lower case\n     * @param s Input string to be converted\n     * @return string lowercase version of the input string\n     */\n    function _lowerCase(string memory s) internal pure returns (string memory) {\n        uint256 length = bytes(s).length;\n        for (uint256 i; i < length; i++) {\n            uint8 b = uint8(bytes(s)[i]);\n            if ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n        }\n        return s;\n    }\n\n    /**\n     * @dev Validates that the sender is a valid interchain token service address\n     * @param sourceChain Source chain of the transaction\n     * @param sourceAddress Source address of the transaction\n     * @return bool true if the sender is validated, false otherwise\n     */\n    function validateSender(string calldata sourceChain, string calldata sourceAddress) external view returns (bool) {\n        string memory sourceAddressLC = _lowerCase(sourceAddress);\n        bytes32 sourceAddressHash = keccak256(bytes(sourceAddressLC));\n        if (sourceAddressHash == interchainTokenServiceAddressHash) {\n            return true;\n        }\n        return sourceAddressHash == remoteAddressHashes[sourceChain];\n    }\n\n    /**\n     * @dev Adds a trusted interchain token service address for the specified chain\n     * @param chain Chain name of the interchain token service\n     * @param addr Interchain token service address to be added\n     */\n    function addTrustedAddress(string memory chain, string memory addr) public onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        if (bytes(addr).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = keccak256(bytes(_lowerCase(addr)));\n        remoteAddresses[chain] = addr;\n        emit TrustedAddressAdded(chain, addr);\n    }\n\n    /**\n     * @dev Removes a trusted interchain token service address\n     * @param chain Chain name of the interchain token service to be removed\n     */\n    function removeTrustedAddress(string calldata chain) external onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = bytes32(0);\n        remoteAddresses[chain] = '';\n        emit TrustedAddressRemoved(chain);\n    }\n\n    /**\n     * @dev Adds chains that are supported by the Axelar gateway\n     * @param chainNames List of chain names to be added as supported\n     */\n    function addGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = true;\n            emit GatewaySupportedChainAdded(chainName);\n        }\n    }\n\n    /**\n     * @dev Removes chains that are no longer supported by the Axelar gateway\n     * @param chainNames List of chain names to be removed as supported\n     */\n    function removeGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = false;\n            emit GatewaySupportedChainRemoved(chainName);\n        }\n    }\n\n    /**\n     * @dev Fetches the interchain token service address for the specified chain\n     * @param chainName Name of the chain\n     * @return remoteAddress Interchain token service address for the specified chain\n     */\n    function getRemoteAddress(string calldata chainName) external view returns (string memory remoteAddress) {\n        remoteAddress = remoteAddresses[chainName];\n        if (bytes(remoteAddress).length == 0) {\n            remoteAddress = interchainTokenServiceAddress.toString();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/its/remote-address-validator/RemoteAddressValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { AddressToString } from '../../gmp-sdk/util/AddressString.sol';\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\n\n/**\n * @title RemoteAddressValidator\n * @dev Manages and validates remote addresses, keeps track of addresses supported by the Axelar gateway contract\n */\ncontract RemoteAddressValidator is IRemoteAddressValidator, Upgradable {\n    using AddressToString for address;\n\n    mapping(string => bytes32) public remoteAddressHashes;\n    mapping(string => string) public remoteAddresses;\n    address public immutable interchainTokenServiceAddress;\n    bytes32 public immutable interchainTokenServiceAddressHash;\n    mapping(string => bool) public supportedByGateway;\n\n    bytes32 private constant CONTRACT_ID = keccak256('remote-address-validator');\n\n    /**\n     * @dev Constructs the RemoteAddressValidator contract, both array parameters must be equal in length\n     * @param _interchainTokenServiceAddress Address of the interchain token service\n     */\n    constructor(address _interchainTokenServiceAddress) {\n        if (_interchainTokenServiceAddress == address(0)) revert ZeroAddress();\n        interchainTokenServiceAddress = _interchainTokenServiceAddress;\n        interchainTokenServiceAddressHash = keccak256(bytes(_lowerCase(interchainTokenServiceAddress.toString())));\n    }\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    function _setup(bytes calldata params) internal override {\n        (string[] memory trustedChainNames, string[] memory trustedAddresses) = abi.decode(params, (string[], string[]));\n        uint256 length = trustedChainNames.length;\n        if (length != trustedAddresses.length) revert LengthMismatch();\n        for (uint256 i; i < length; ++i) {\n            addTrustedAddress(trustedChainNames[i], trustedAddresses[i]);\n        }\n    }\n\n    /**\n     * @dev Converts a string to lower case\n     * @param s Input string to be converted\n     * @return string lowercase version of the input string\n     */\n    function _lowerCase(string memory s) internal pure returns (string memory) {\n        uint256 length = bytes(s).length;\n        for (uint256 i; i < length; i++) {\n            uint8 b = uint8(bytes(s)[i]);\n            if ((b >= 65) && (b <= 70)) bytes(s)[i] = bytes1(b + uint8(32));\n        }\n        return s;\n    }\n\n    /**\n     * @dev Validates that the sender is a valid interchain token service address\n     * @param sourceChain Source chain of the transaction\n     * @param sourceAddress Source address of the transaction\n     * @return bool true if the sender is validated, false otherwise\n     */\n    function validateSender(string calldata sourceChain, string calldata sourceAddress) external view returns (bool) {\n        string memory sourceAddressLC = _lowerCase(sourceAddress);\n        bytes32 sourceAddressHash = keccak256(bytes(sourceAddressLC));\n        if (sourceAddressHash == interchainTokenServiceAddressHash) {\n            return true;\n        }\n        return sourceAddressHash == remoteAddressHashes[sourceChain];\n    }\n\n    /**\n     * @dev Adds a trusted interchain token service address for the specified chain\n     * @param chain Chain name of the interchain token service\n     * @param addr Interchain token service address to be added\n     */\n    function addTrustedAddress(string memory chain, string memory addr) public onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        if (bytes(addr).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = keccak256(bytes(_lowerCase(addr)));\n        remoteAddresses[chain] = addr;\n        emit TrustedAddressAdded(chain, addr);\n    }\n\n    /**\n     * @dev Removes a trusted interchain token service address\n     * @param chain Chain name of the interchain token service to be removed\n     */\n    function removeTrustedAddress(string calldata chain) external onlyOwner {\n        if (bytes(chain).length == 0) revert ZeroStringLength();\n        remoteAddressHashes[chain] = bytes32(0);\n        remoteAddresses[chain] = '';\n        emit TrustedAddressRemoved(chain);\n    }\n\n    /**\n     * @dev Adds chains that are supported by the Axelar gateway\n     * @param chainNames List of chain names to be added as supported\n     */\n    function addGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = true;\n            emit GatewaySupportedChainAdded(chainName);\n        }\n    }\n\n    /**\n     * @dev Removes chains that are no longer supported by the Axelar gateway\n     * @param chainNames List of chain names to be removed as supported\n     */\n    function removeGatewaySupportedChains(string[] calldata chainNames) external onlyOwner {\n        uint256 length = chainNames.length;\n        for (uint256 i; i < length; ++i) {\n            string calldata chainName = chainNames[i];\n            supportedByGateway[chainName] = false;\n            emit GatewaySupportedChainRemoved(chainName);\n        }\n    }\n\n    /**\n     * @dev Fetches the interchain token service address for the specified chain\n     * @param chainName Name of the chain\n     * @return remoteAddress Interchain token service address for the specified chain\n     */\n    function getRemoteAddress(string calldata chainName) external view returns (string memory remoteAddress) {\n        remoteAddress = remoteAddresses[chainName];\n        if (bytes(remoteAddress).length == 0) {\n            remoteAddress = interchainTokenServiceAddress.toString();\n        }\n    }\n}"
    }
  ]
}