{
  "Title": "[M-12] yIntercept of public vaults can overflow",
  "Content": "\nThe yIntercept of a public vault can overflow due to an unchecked addition. As a result, totalAsset will be a lot lower than the actual amount, which prevents liquidity providers from withdrawing a large fraction of their assets.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L323-L325>\n\nThe amount of assets required for this to happen is barely feasible for a regular 18 decimal ERC20 token, but can happen with ease for tokens with higher precision.\n\n### Proof of Concept\n\n    pragma solidity =0.8.17;\n\n    import \"forge-std/Test.sol\";\n\n    import {Authority} from \"solmate/auth/Auth.sol\";\n    import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n    import {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\n    import {\n      MultiRolesAuthority\n    } from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\n\n    import {ERC721} from \"gpl/ERC721.sol\";\n    import {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n    import {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\";\n    import {VaultImplementation} from \"../VaultImplementation.sol\";\n    import {PublicVault} from \"../PublicVault.sol\";\n    import {TransferProxy} from \"../TransferProxy.sol\";\n    import {WithdrawProxy} from \"../WithdrawProxy.sol\";\n\n    import {Strings2} from \"./utils/Strings2.sol\";\n\n    import \"./TestHelpers.t.sol\";\n    import {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\n\n    contract AstariaTest is TestHelpers {\n      using FixedPointMathLib for uint256;\n      using CollateralLookup for address;\n      using SafeCastLib for uint256;\n\n      event NonceUpdated(uint256 nonce);\n      event VaultShutdown();\n\n      function testYinterceptOverflow() public {\n        \n        address publicVault = _createPublicVault({\n          strategist: strategistOne,\n          delegate: strategistTwo,\n          epochLength: 14 days\n        });\n        _lendToVault(\n          Lender({addr: address(1), amountToLend: 309000000 ether}),\n          publicVault\n        );\n        _lendToVault(\n          Lender({addr: address(2), amountToLend: 10000000 ether}),\n          publicVault\n        );\n        assertTrue(PublicVault(publicVault).totalAssets() < 10000000 ether);\n        \n      }\n    }\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nRemove the unchecked block.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/PublicVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {ERC20Cloned} from \"gpl/ERC20-Cloned.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {WithdrawProxy} from \"core/WithdrawProxy.sol\";\n\nimport {Math} from \"core/utils/Math.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\n\n/*\n * @title PublicVault\n * @author androolloyd\n * @notice\n */\ncontract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n\n  uint256 private constant PUBLIC_VAULT_SLOT =\n    uint256(keccak256(\"xyz.astaria.PublicVault.storage.location\")) - 1;\n\n  function asset()\n    public\n    pure\n    virtual\n    override(IAstariaVaultBase, AstariaVaultBase, ERC4626Cloned)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function decimals()\n    public\n    pure\n    virtual\n    override(IERC20Metadata)\n    returns (uint8)\n  {\n    return 18;\n  }\n\n  function name()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-Vault-\", ERC20(asset()).symbol()));\n  }\n\n  function symbol()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-V-\", ERC20(asset()).symbol()));\n  }\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    if (ERC20(asset()).decimals() == uint8(18)) {\n      return 100 gwei;\n    } else {\n      return 10**(ERC20(asset()).decimals() - 1);\n    }\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in the next epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 assets) {\n    VaultData storage s = _loadStorageSlot();\n    assets = _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 shares) {\n    shares = previewWithdraw(assets);\n\n    VaultData storage s = _loadStorageSlot();\n\n    _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    return\n      _redeemFutureEpoch(_loadStorageSlot(), shares, receiver, owner, epoch);\n  }\n\n  function _redeemFutureEpoch(\n    VaultData storage s,\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) internal virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not in the past\n\n    ERC20Data storage es = _loadERC20Slot();\n\n    if (msg.sender != owner) {\n      uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        es.allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    if (epoch < s.currentEpoch) {\n      revert InvalidState(InvalidStates.EPOCH_TOO_LOW);\n    }\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n    // check for rounding error since we round down in previewRedeem.\n\n    //this will underflow if not enough balance\n    es.balanceOf[owner] -= shares;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      es.balanceOf[address(this)] += shares;\n    }\n\n    emit Transfer(owner, address(this), shares);\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(s, epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);\n  }\n\n  function getWithdrawProxy(uint64 epoch) public view returns (WithdrawProxy) {\n    return WithdrawProxy(_loadStorageSlot().epochData[epoch].withdrawProxy);\n  }\n\n  function getCurrentEpoch() public view returns (uint64) {\n    return _loadStorageSlot().currentEpoch;\n  }\n\n  function getSlope() public view returns (uint256) {\n    return uint256(_loadStorageSlot().slope);\n  }\n\n  function getWithdrawReserve() public view returns (uint256) {\n    return uint256(_loadStorageSlot().withdrawReserve);\n  }\n\n  function getLiquidationWithdrawRatio() public view returns (uint256) {\n    return uint256(_loadStorageSlot().liquidationWithdrawRatio);\n  }\n\n  function getYIntercept() public view returns (uint256) {\n    return uint256(_loadStorageSlot().yIntercept);\n  }\n\n  function _deployWithdrawProxyIfNotDeployed(VaultData storage s, uint64 epoch)\n    internal\n  {\n    if (s.epochData[epoch].withdrawProxy == address(0)) {\n      s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),\n        abi.encodePacked(\n          address(ROUTER()), // router is the beacon\n          uint8(IAstariaRouter.ImplementationType.WithdrawProxy),\n          asset(), // token\n          address(this), // vault\n          epoch + 1 // claimable epoch\n        )\n      );\n    }\n  }\n\n  function mint(uint256 shares, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n    return super.mint(shares, receiver);\n  }\n\n  /**\n   * @notice Deposit funds into the PublicVault.\n   * @param amount The amount of funds to deposit.\n   * @param receiver The receiver of the resulting VaultToken shares.\n   */\n  function deposit(uint256 amount, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n\n    uint256 assets = totalAssets();\n\n    return super.deposit(amount, receiver);\n  }\n\n  /**\n   * @notice Retrieve the domain separator.\n   * @return The domain separator.\n   */\n  function computeDomainSeparator() internal view override returns (bytes32) {\n    return super.domainSeparator();\n  }\n\n  function processEpoch() public {\n    // check to make sure epoch is over\n    if (timeToEpochEnd() > 0) {\n      revert InvalidState(InvalidStates.EPOCH_NOT_OVER);\n    }\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > 0) {\n      revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);\n    }\n\n    WithdrawProxy currentWithdrawProxy = WithdrawProxy(\n      s.epochData[s.currentEpoch].withdrawProxy\n    );\n\n    // split funds from previous WithdrawProxy with PublicVault if hasn't been already\n    if (s.currentEpoch != 0) {\n      WithdrawProxy previousWithdrawProxy = WithdrawProxy(\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      if (\n        address(previousWithdrawProxy) != address(0) &&\n        previousWithdrawProxy.getFinalAuctionEnd() != 0\n      ) {\n        previousWithdrawProxy.claim();\n      }\n    }\n\n    if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n      revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n    }\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    s.liquidationWithdrawRatio = 0;\n\n    // check if there are LPs withdrawing this epoch\n    if ((address(currentWithdrawProxy) != address(0))) {\n      uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n      s.liquidationWithdrawRatio = proxySupply\n        .mulDivDown(1e18, totalSupply())\n        .safeCastTo88();\n\n      currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n      uint256 expected = currentWithdrawProxy.getExpected();\n\n      unchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n      _setYIntercept(\n        s,\n        s.yIntercept -\n          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n      );\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n    }\n\n    // increment epoch\n    unchecked {\n      s.currentEpoch++;\n    }\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    pure\n    override(IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IPublicVault).interfaceId ||\n      interfaceId == type(ERC4626Cloned).interfaceId ||\n      interfaceId == type(ERC4626).interfaceId ||\n      interfaceId == type(ERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  function transferWithdrawReserve() public {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.currentEpoch == uint64(0)) {\n      return;\n    }\n\n    address currentWithdrawProxy = s\n      .epochData[s.currentEpoch - 1]\n      .withdrawProxy;\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));\n\n      // prevent transfer of more assets then are available\n      if (s.withdrawReserve <= withdrawBalance) {\n        withdrawBalance = s.withdrawReserve;\n        s.withdrawReserve = 0;\n      } else {\n        unchecked {\n          s.withdrawReserve -= withdrawBalance.safeCastTo88();\n        }\n      }\n\n      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        withdrawBalance\n      );\n      emit WithdrawReserveTransferred(withdrawBalance);\n    }\n\n    address withdrawProxy = s.epochData[s.currentEpoch].withdrawProxy;\n    if (\n      s.withdrawReserve > 0 &&\n      timeToEpochEnd() == 0 &&\n      withdrawProxy != address(0)\n    ) {\n      address currentWithdrawProxy = s\n        .epochData[s.currentEpoch - 1]\n        .withdrawProxy;\n      uint256 drainBalance = WithdrawProxy(withdrawProxy).drain(\n        s.withdrawReserve,\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      unchecked {\n        s.withdrawReserve -= drainBalance.safeCastTo88();\n      }\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        drainBalance\n      );\n    }\n  }\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata params)\n    internal\n    virtual\n    override(VaultImplementation)\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > uint256(0)) {\n      transferWithdrawReserve();\n    }\n    if (timeToEpochEnd() == uint256(0)) {\n      processEpoch();\n    }\n  }\n\n  function _loadStorageSlot() internal pure returns (VaultData storage s) {\n    uint256 slot = PUBLIC_VAULT_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @dev Hook for updating the slope of the PublicVault after a LienToken is issued.\n   * @param lienId The ID of the lien.\n   */\n  function _afterCommitToLien(\n    uint40 lienEnd,\n    uint256 lienId,\n    uint256 lienSlope\n  ) internal virtual override {\n    VaultData storage s = _loadStorageSlot();\n\n    // increment slope for the new lien\n    _accrue(s);\n    unchecked {\n      uint48 newSlope = s.slope + lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n\n    uint64 epoch = getLienEpoch(lienEnd);\n\n    _increaseOpenLiens(s, epoch);\n    emit LienOpen(lienId, epoch);\n  }\n\n  event SlopeUpdated(uint48 newSlope);\n\n  function accrue() public returns (uint256) {\n    return _accrue(_loadStorageSlot());\n  }\n\n  function _accrue(VaultData storage s) internal returns (uint256) {\n    unchecked {\n      s.yIntercept = (_totalAssets(s)).safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n    emit YInterceptChanged(s.yIntercept);\n\n    return s.yIntercept;\n  }\n\n  /**\n   * @notice Computes the implied value of this PublicVault. This includes interest payments that have not yet been made.\n   * @return The implied value for this PublicVault.\n   */\n  function totalAssets()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    VaultData storage s = _loadStorageSlot();\n    return _totalAssets(s);\n  }\n\n  function _totalAssets(VaultData storage s) internal view returns (uint256) {\n    uint256 delta_t = block.timestamp - s.last;\n    return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);\n  }\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(IERC20, ERC20Cloned)\n    returns (uint256)\n  {\n    return\n      _loadERC20Slot()._totalSupply +\n      _loadStorageSlot().strategistUnclaimedShares;\n  }\n\n  function claim() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VaultData storage s = _loadStorageSlot();\n    uint256 unclaimed = s.strategistUnclaimedShares;\n    s.strategistUnclaimedShares = 0;\n    _mint(msg.sender, unclaimed);\n  }\n\n  function beforePayment(BeforePaymentParams calldata params)\n    external\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n    _accrue(s);\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n    _handleStrategistInterestReward(s, params.interestOwed, params.amount);\n  }\n\n  function _setSlope(VaultData storage s, uint48 newSlope) internal {\n    s.slope = newSlope;\n    emit SlopeUpdated(newSlope);\n  }\n\n  function decreaseEpochLienCount(uint64 epoch) public onlyLienToken {\n    _decreaseEpochLienCount(_loadStorageSlot(), epoch);\n  }\n\n  function _decreaseEpochLienCount(VaultData storage s, uint64 epoch) internal {\n    s.epochData[epoch].liensOpenForEpoch--;\n    emit LiensOpenForEpochRemaining(\n      epoch,\n      s.epochData[epoch].liensOpenForEpoch\n    );\n  }\n\n  function getLienEpoch(uint64 end) public pure returns (uint64) {\n    return\n      uint256(Math.ceilDiv(end - uint64(START()), EPOCH_LENGTH()) - 1)\n        .safeCastTo64();\n  }\n\n  function getEpochEnd(uint256 epoch) public pure returns (uint64) {\n    return uint256(START() + (epoch + 1) * EPOCH_LENGTH()).safeCastTo64();\n  }\n\n  function _increaseOpenLiens(VaultData storage s, uint64 epoch) internal {\n    unchecked {\n      s.epochData[epoch].liensOpenForEpoch++;\n    }\n  }\n\n  function afterPayment(uint256 computedSlope) public onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    unchecked {\n      s.slope += computedSlope.safeCastTo48();\n    }\n    emit SlopeUpdated(s.slope);\n  }\n\n  /**\n   * @notice After-deposit hook to update the yIntercept of the PublicVault to reflect a capital contribution.\n   * @param assets The amount of assets deposited to the PublicVault.\n   * @param shares The resulting amount of VaultToken shares that were issued.\n   */\n  function afterDeposit(uint256 assets, uint256 shares)\n    internal\n    virtual\n    override\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      s.yIntercept += assets.safeCastTo88();\n    }\n    VIData storage v = _loadVISlot();\n    if (v.depositCap != 0 && totalAssets() >= v.depositCap) {\n      revert InvalidState(InvalidStates.DEPOSIT_CAP_EXCEEDED);\n    }\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  /**\n   * @dev Handles the dilutive fees (on lien repayments) for strategists in VaultTokens.\n   * @param interestOwing the owingInterest for the lien\n   * @param amount The amount that was paid.\n   */\n  function _handleStrategistInterestReward(\n    VaultData storage s,\n    uint256 interestOwing,\n    uint256 amount\n  ) internal virtual {\n    if (VAULT_FEE() != uint256(0)) {\n      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\n      uint88 feeInShares = convertToShares(fee).safeCastTo88();\n      s.strategistUnclaimedShares += feeInShares;\n      emit StrategistFee(feeInShares);\n    }\n  }\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    return ROUTER().LIEN_TOKEN();\n  }\n\n  function handleBuyoutLien(BuyoutLienParams calldata params)\n    public\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n      s.yIntercept += params.increaseYIntercept.safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n\n    _decreaseEpochLienCount(s, getLienEpoch(params.lienEnd.safeCastTo64()));\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  function updateAfterLiquidationPayment(\n    LiquidationPaymentParams calldata params\n  ) external onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    if (params.remaining > 0)\n      _setYIntercept(s, s.yIntercept - params.remaining);\n  }\n\n  function updateVaultAfterLiquidation(\n    uint256 maxAuctionWindow,\n    AfterLiquidationParams calldata params\n  ) public onlyLienToken returns (address withdrawProxyIfNearBoundary) {\n    VaultData storage s = _loadStorageSlot();\n\n    _accrue(s);\n    unchecked {\n      _setSlope(s, s.slope - params.lienSlope.safeCastTo48());\n    }\n\n    if (s.currentEpoch != 0) {\n      transferWithdrawReserve();\n    }\n    uint64 lienEpoch = getLienEpoch(params.lienEnd);\n    _decreaseEpochLienCount(s, lienEpoch);\n\n    uint256 timeToEnd = timeToEpochEnd(lienEpoch);\n    if (timeToEnd < maxAuctionWindow) {\n      _deployWithdrawProxyIfNotDeployed(s, lienEpoch);\n      withdrawProxyIfNearBoundary = s.epochData[lienEpoch].withdrawProxy;\n\n      WithdrawProxy(withdrawProxyIfNearBoundary).handleNewLiquidation(\n        params.newAmount,\n        maxAuctionWindow\n      );\n    }\n  }\n\n  function increaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&\n        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n    );\n    _setYIntercept(s, s.yIntercept + amount);\n  }\n\n  modifier onlyLienToken() {\n    require(msg.sender == address(LIEN_TOKEN()));\n    _;\n  }\n\n  function decreaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&\n        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n    );\n    _setYIntercept(s, s.yIntercept - amount);\n  }\n\n  function _setYIntercept(VaultData storage s, uint256 newYIntercept) internal {\n    s.yIntercept = newYIntercept.safeCastTo88();\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  function timeToEpochEnd() public view returns (uint256) {\n    return timeToEpochEnd(_loadStorageSlot().currentEpoch);\n  }\n\n  function timeToEpochEnd(uint256 epoch) public view returns (uint256) {\n    uint256 epochEnd = START() + ((epoch + 1) * EPOCH_LENGTH());\n\n    if (block.timestamp >= epochEnd) {\n      return uint256(0);\n    }\n\n    return epochEnd - block.timestamp;\n  }\n\n  function _timeToSecondEndIfPublic()\n    internal\n    view\n    override\n    returns (uint256 timeToSecondEpochEnd)\n  {\n    return timeToEpochEnd() + EPOCH_LENGTH();\n  }\n\n  function timeToSecondEpochEnd() public view returns (uint256) {\n    return _timeToSecondEndIfPublic();\n  }\n}"
    }
  ]
}