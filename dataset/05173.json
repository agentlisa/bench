{
  "Title": "[M-09] Constraints of `dailyAllowanceReplenishTime` and `allowanceRemaining` during `mint()` can be bypassed by using alias accounts & `safeTransferFrom()`",
  "Content": "\nThe [mint()](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/GameItems.sol#L158-L161) function in `GameItems.sol` constraints a user from minting more than 10 game items in 1 day. This constraint can easily be bypassed since a similar check is missing inside the [safeTransferFrom()](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/GameItems.sol#L291-L303) function:\n\n<details>\n\n```js\n  File: src/GameItems.sol\n\n  147:              function mint(uint256 tokenId, uint256 quantity) external {\n  148:                  require(tokenId < _itemCount);\n  149:                  uint256 price = allGameItemAttributes[tokenId].itemPrice * quantity;\n  150:                  require(_neuronInstance.balanceOf(msg.sender) >= price, \"Not enough NRN for purchase\");\n  151:                  require(\n  152:                      allGameItemAttributes[tokenId].finiteSupply == false || \n  153:                      (\n  154:                          allGameItemAttributes[tokenId].finiteSupply == true && \n  155:                          quantity <= allGameItemAttributes[tokenId].itemsRemaining\n  156:                      )\n  157:                  );\n  158: @--->            require(\n  159: @--->                dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp || \n  160: @--->                quantity <= allowanceRemaining[msg.sender][tokenId]\n  161:                  );\n  162:          \n  163:                  _neuronInstance.approveSpender(msg.sender, price);\n  164:                  bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, price);\n  165:                  if (success) {\n  166:                      if (dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp) {\n  167:                          _replenishDailyAllowance(tokenId);\n  168:                      }\n  169:                      allowanceRemaining[msg.sender][tokenId] -= quantity;\n  170:                      if (allGameItemAttributes[tokenId].finiteSupply) {\n  171:                          allGameItemAttributes[tokenId].itemsRemaining -= quantity;\n  172:                      }\n  173:                      _mint(msg.sender, tokenId, quantity, bytes(\"random\"));\n  174:                      emit BoughtItem(msg.sender, tokenId, quantity);\n  175:                  }\n  176:              }\n```\n</details>\n\nMissing check:\n\n```js\n  File: src/GameItems.sol\n\n  291:              function safeTransferFrom(\n  292:                  address from, \n  293:                  address to, \n  294:                  uint256 tokenId,\n  295:                  uint256 amount,\n  296:                  bytes memory data\n  297:              ) \n  298:                  public \n  299:                  override(ERC1155)\n  300:              {\n  301:                  require(allGameItemAttributes[tokenId].transferable);\n  302:                  super.safeTransferFrom(from, to, tokenId, amount, data);\n  303:              }\n```\n\n**Note:** This could also lead to a situation where a NRN whale having enough funds can buy the complete supply of the game items within minutes by using his multiple alias accounts.\n\n### Proof of Concept\n\n*   Alice *(ownerAddress)* buys 10 batteries. She can't buy anymore until 1 day has passed.\n*   Alice transfers some of her NRN to Bob *(Alice's alternate account)*.\n*   Bob buys 10 batteries and transfers them to Alice, bypassing the constraints.\n\nAdd the following inside `test/GameItems.t.sol` and run with `forge test --mt test_MintGameItems_FromMultipleAccs_ThenTransfer -vv`:\n\n```js\n    function test_MintGameItems_FromMultipleAccs_ThenTransfer() public {\n        // _ownerAddress's alternate account\n        address aliasAccount1 = makeAddr(\"aliasAccount1\");\n\n        _fundUserWith4kNeuronByTreasury(_ownerAddress);\n        _gameItemsContract.mint(0, 10); //paying 10 $NRN for 10 batteries\n        assertEq(_gameItemsContract.balanceOf(_ownerAddress, 0), 10);\n        \n        // transfer some $NRN to alias Account\n        _neuronContract.transfer(aliasAccount1, 10 * 10 ** 18);\n\n        vm.startPrank(aliasAccount1);\n        _gameItemsContract.mint(0, 10); //paying 10 $NRN for 10 batteries\n        assertEq(_gameItemsContract.balanceOf(aliasAccount1, 0), 10);\n\n        // transfer these game items to _ownerAddress\n        _gameItemsContract.safeTransferFrom(aliasAccount1, _ownerAddress, 0, 10, \"\");\n\n        assertEq(_gameItemsContract.balanceOf(_ownerAddress, 0), 20);\n    }\n```\n\n### Tools used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nAdd the same check inside `safeTransferFrom()` too:\n\n```diff\n  File: src/GameItems.sol\n\n  291:              function safeTransferFrom(\n  292:                  address from, \n  293:                  address to, \n  294:                  uint256 tokenId,\n  295:                  uint256 amount,\n  296:                  bytes memory data\n  297:              ) \n  298:                  public \n  299:                  override(ERC1155)\n  300:              {\n  301:                  require(allGameItemAttributes[tokenId].transferable);\n+                       require(dailyAllowanceReplenishTime[to][tokenId] <= block.timestamp || amount <= allowanceRemaining[to][tokenId], \"Cannot bypass constraints via alias accounts\");  \n  302:                  super.safeTransferFrom(from, to, tokenId, amount, data);\n  303:              }\n```\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/43#issuecomment-1982315463):**\n > Agree with the issue. The main impact is about bypassing replenishing / minting limits for **a specific account** by minting batteries / redeeming passes with multiple accounts & transferring all to that 1 account for consumption || transferring fighter NFTs back and forth across multiple wallets.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/GameItems.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { Neuron } from \"./Neuron.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\n/// @title GameItems\n/// @author ArenaX Labs Inc.\n/// @notice This contract represents a collection of game items used in AI Arena.\ncontract GameItems is ERC1155 {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when a game item is bought.\n    /// @param buyer The address of the buyer.\n    /// @param tokenId The id of the game item.\n    /// @param quantity The quantity of the game item.\n    event BoughtItem(address buyer, uint256 tokenId, uint256 quantity);\n\n    /// @notice Event emitted when an item is locked and thus cannot be traded.\n    /// @param tokenId The id of the game item.\n    event Locked(uint256 tokenId);\n\n    /// @notice Event emitted when an item is unlocked and can be traded.\n    /// @param tokenId The id of the game item.\n    event Unlocked(uint256 tokenId);\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n    \n    /// @notice Struct for game item attributes\n    struct GameItemAttributes {\n        string name;\n        bool finiteSupply;\n        bool transferable;\n        uint256 itemsRemaining;\n        uint256 itemPrice;\n        uint256 dailyAllowance;\n    }  \n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name of this smart contract.\n    string public name = \"AI Arena Game Items\";\n\n    /// @notice The symbol for this smart contract.\n    string public symbol = \"AGI\";\n\n    /// @notice List of all gameItemAttribute structs representing all game items.\n    GameItemAttributes[] public allGameItemAttributes;\n\n    /// @notice The address that recieves funds of purchased game items.\n    address public treasuryAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// Total number of game items.\n    uint256 _itemCount = 0;    \n\n    /// @dev The Neuron contract instance.\n    Neuron _neuronInstance;\n    \n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/ \n\n    /// @notice Mapping of address to tokenId to get remaining allowance.\n    mapping(address => mapping(uint256 => uint256)) public allowanceRemaining;\n\n    /// @notice Mapping of address to tokenId to get replenish timestamp.\n    mapping(address => mapping(uint256 => uint256)) public dailyAllowanceReplenishTime;\n\n    /// @notice Mapping tracking addresses allowed to burn game items.\n    mapping(address => bool) public allowedBurningAddresses;\n\n    /// @notice Mapping tracking addresses allowed to manage game items.\n    mapping(address => bool) public isAdmin;\n\n    /// @notice Mapping of token id to the token URI\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the owner address and the isAdmin mapping to true for the owner address.\n    /// @param ownerAddress Address of contract deployer.\n    /// @param treasuryAddress_ Address of admin signer for messages.\n    constructor(address ownerAddress, address treasuryAddress_) ERC1155(\"https://ipfs.io/ipfs/\") {\n        _ownerAddress = ownerAddress;\n        treasuryAddress = treasuryAddress_;\n        isAdmin[_ownerAddress] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }  \n\n    /// @notice Adjusts whether the game item can be transferred or not\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param tokenId The token id for the specific game item being adjusted.\n    /// @param transferable Whether the game item is transferable or not\n    function adjustTransferability(uint256 tokenId, bool transferable) external {\n        require(msg.sender == _ownerAddress);\n        allGameItemAttributes[tokenId].transferable = transferable;\n        if (transferable) {\n          emit Unlocked(tokenId);\n        } else {\n          emit Locked(tokenId);\n        }\n    }\n\n    /// @notice Sets the Neuron contract address and instantiates the contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param nrnAddress The address of the Neuron contract.\n    function instantiateNeuronContract(address nrnAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(nrnAddress);\n    }\n\n    /// @notice Mints game items and assigns them to the caller.\n    /// @param tokenId The ID of the game item to mint.\n    /// @param quantity The quantity of game items to mint.\n    function mint(uint256 tokenId, uint256 quantity) external {\n        require(tokenId < _itemCount);\n        uint256 price = allGameItemAttributes[tokenId].itemPrice * quantity;\n        require(_neuronInstance.balanceOf(msg.sender) >= price, \"Not enough NRN for purchase\");\n        require(\n            allGameItemAttributes[tokenId].finiteSupply == false || \n            (\n                allGameItemAttributes[tokenId].finiteSupply == true && \n                quantity <= allGameItemAttributes[tokenId].itemsRemaining\n            )\n        );\n        require(\n            dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp || \n            quantity <= allowanceRemaining[msg.sender][tokenId]\n        );\n\n        _neuronInstance.approveSpender(msg.sender, price);\n        bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, price);\n        if (success) {\n            if (dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp) {\n                _replenishDailyAllowance(tokenId);\n            }\n            allowanceRemaining[msg.sender][tokenId] -= quantity;\n            if (allGameItemAttributes[tokenId].finiteSupply) {\n                allGameItemAttributes[tokenId].itemsRemaining -= quantity;\n            }\n            _mint(msg.sender, tokenId, quantity, bytes(\"random\"));\n            emit BoughtItem(msg.sender, tokenId, quantity);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Sets the allowed burning addresses.\n    /// @dev Only the admins are authorized to call this function.\n    /// @param newBurningAddress The address to allow for burning.\n    function setAllowedBurningAddresses(address newBurningAddress) public {\n        require(isAdmin[msg.sender]);\n        allowedBurningAddresses[newBurningAddress] = true;\n    }\n\n    /// @notice Sets the token URI for a game item\n    /// @dev Only the admins are authorized to call this function.\n    /// @param tokenId The token id for the specific game item being queried.    \n    /// @param _tokenURI The token id to be set\n    function setTokenURI(uint256 tokenId, string memory _tokenURI) public {\n        require(isAdmin[msg.sender]);\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /// @notice Creates a new game item with the specified attributes.\n    /// @dev Only the admins are authorized to call this function.\n    /// @param name_ The name of the game item.\n    /// @param tokenURI The URI of the game item.\n    /// @param finiteSupply Determines if the game item has a finite supply.\n    /// @param transferable Boolean of whether or not the game item can be transferred\n    /// @param itemsRemaining The number of remaining items for the game item.\n    /// @param itemPrice The price of the game item.\n    /// @param dailyAllowance The daily allowance for the game item.\n    function createGameItem(\n        string memory name_,\n        string memory tokenURI,\n        bool finiteSupply,\n        bool transferable,\n        uint256 itemsRemaining,\n        uint256 itemPrice,\n        uint16 dailyAllowance\n    ) \n        public \n    {\n        require(isAdmin[msg.sender]);\n        allGameItemAttributes.push(\n            GameItemAttributes(\n                name_,\n                finiteSupply,\n                transferable,\n                itemsRemaining,\n                itemPrice,\n                dailyAllowance\n            )\n        );\n        if (!transferable) {\n          emit Locked(_itemCount);\n        }\n        setTokenURI(_itemCount, tokenURI);\n        _itemCount += 1;\n    }\n\n    /// @notice Burns a specified amount of game items from an account.\n    /// @dev Only addresses listed in allowedBurningAddresses are authorized to call this function.\n    /// @param account The account from which the game items will be burned.\n    /// @param tokenId The ID of the game item.\n    /// @param amount The amount of game items to burn.\n    function burn(address account, uint256 tokenId, uint256 amount) public {\n        require(allowedBurningAddresses[msg.sender]);\n        _burn(account, tokenId, amount);\n    }\n\n    /// @notice Returns the URI where the contract metadata is stored.\n    /// @return URI where the contract metadata is stored.\n    function contractURI() public pure returns (string memory) {\n        return \"ipfs://bafybeih3witscmml3padf4qxbea5jh4rl2xp67aydqvqsxmyuzipwtpnii\";\n    }\n\n    /// @notice Override the uri function to return the custom URI for each token\n    /// @param tokenId The token id for the specific game item being queried.\n    /// @return tokenURI The URI for the game item metadata.\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        string memory customURI = _tokenURIs[tokenId];\n        if (bytes(customURI).length > 0) {\n            return customURI;\n        }\n        return super.uri(tokenId);\n    }        \n\n    /// @notice Gets the amount of a game item that a user is still able to mint for the day\n    /// @param owner The user's address.\n    /// @param tokenId The token id for the specific game item being queried.\n    /// @return remaining number of items that can be minted for the day.\n    function getAllowanceRemaining(address owner, uint256 tokenId) public view returns (uint256) {\n        uint256 remaining = allowanceRemaining[owner][tokenId];\n        if (dailyAllowanceReplenishTime[owner][tokenId] <= block.timestamp) {\n            remaining = allGameItemAttributes[tokenId].dailyAllowance;\n        }\n        return remaining;\n    }\n\n    /// @notice Returns the remaining supply of a game item with the specified tokenId.\n    /// @param tokenId The ID of the game item.\n    /// @return Remaining items for the queried token ID.\n    function remainingSupply(uint256 tokenId) public view returns (uint256) {\n        return allGameItemAttributes[tokenId].itemsRemaining;\n    }\n\n    /// @notice Returns the total number of unique game tokens outstanding.\n    /// @return Total number of unique game tokens.\n    function uniqueTokensOutstanding() public view returns (uint256) {\n        return allGameItemAttributes.length;\n    }\n\n    /// @notice Safely transfers an NFT from one address to another.\n    /// @dev Added a check to see if the game item is transferable.\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    ) \n        public \n        override(ERC1155)\n    {\n        require(allGameItemAttributes[tokenId].transferable);\n        super.safeTransferFrom(from, to, tokenId, amount, data);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Replenishes the daily allowance for the specified game item token.\n    /// @dev This function is called when a user buys a game item after the replenish interval has passed.\n    /// @param tokenId The ID of the game item token.\n    function _replenishDailyAllowance(uint256 tokenId) private {\n        allowanceRemaining[msg.sender][tokenId] = allGameItemAttributes[tokenId].dailyAllowance;\n        dailyAllowanceReplenishTime[msg.sender][tokenId] = uint32(block.timestamp + 1 days);\n    }    \n}"
    }
  ]
}