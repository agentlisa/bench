{
  "Title": "Redundant parameter in `P2pSsvProxy.registerValidators` function",
  "Content": "##### Description\nThis issue is found in the [`registerValidators`](https://github.com/p2p-org/p2p-ssv-proxy/blob/9dd4728002d9c275e29e8ba38bcf7d90efc7531b/src/p2pSsvProxy/P2pSsvProxy.sol#L180) function if the `P2pSsvProxy` contract.\nThis function, which is only accessible from the `factory`, is invoked within the [`P2pSsvProxyFactory._registerValidators`](https://github.com/p2p-org/p2p-ssv-proxy/blob/9dd4728002d9c275e29e8ba38bcf7d90efc7531b/src/p2pSsvProxyFactory/P2pSsvProxyFactory.sol#L462-L465) function. Before this invocation, a validation check confirms that the `P2pSsvProxy` has been created with a specific `feeDistributorInstance`. This fee distributor is immutable and is assigned as the [`s_feeDistributor`](https://github.com/p2p-org/p2p-ssv-proxy/blob/9dd4728002d9c275e29e8ba38bcf7d90efc7531b/src/p2pSsvProxy/P2pSsvProxy.sol#L141) storage variable within `P2pSsvProxy`. Given this setup, explicitly passing the `feeDistributor` parameter to `registerValidators` is unnecessary.\n\n##### Recommendation\nWe recommend removing the `feeDistributor` parameter from the `registerValidators` function and utilizing the existing `s_feeDistributor` storage variable instead.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/p2pSsvProxy/P2pSsvProxy.sol",
      "content": "// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport \"../@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../constants/P2pConstants.sol\";\nimport \"../interfaces/ssv/ISSVNetwork.sol\";\nimport \"../interfaces/IDepositContract.sol\";\nimport \"../interfaces/p2p/IFeeDistributorFactory.sol\";\nimport \"../access/OwnableWithOperator.sol\";\nimport \"../assetRecovering/OwnableAssetRecoverer.sol\";\nimport \"../structs/P2pStructs.sol\";\nimport \"../p2pSsvProxyFactory/IP2pSsvProxyFactory.sol\";\nimport \"./IP2pSsvProxy.sol\";\n\n\n/// @notice _referenceFeeDistributor should implement IFeeDistributor interface\n/// @param _passedAddress passed address for _referenceFeeDistributor\nerror P2pSsvProxy__NotFeeDistributor(address _passedAddress);\n\n/// @notice Should be a P2pSsvProxyFactory contract\n/// @param _passedAddress passed address that does not support IP2pSsvProxyFactory interface\nerror P2pSsvProxy__NotP2pSsvProxyFactory(address _passedAddress);\n\n/// @notice Throws if called by any account other than the client.\n/// @param _caller address of the caller\n/// @param _client address of the client\nerror P2pSsvProxy__CallerNotClient(address _caller, address _client);\n\n/// @notice The caller was neither operator nor owner\n/// @param _caller address of the caller\n/// @param _operator address of the operator\n/// @param _owner address of the owner\nerror P2pSsvProxy__CallerNeitherOperatorNorOwner(address _caller, address _operator, address _owner);\n\n/// @notice The caller was neither operator nor owner nor client\n/// @param _caller address of the caller\nerror P2pSsvProxy__CallerNeitherOperatorNorOwnerNorClient(address _caller);\n\n/// @notice Only factory can call `initialize`.\n/// @param _msgSender sender address.\n/// @param _actualFactory the actual factory address that can call `initialize`.\nerror P2pSsvProxy__NotP2pSsvProxyFactoryCalled(address _msgSender, IP2pSsvProxyFactory _actualFactory);\n\n/// @notice _pubkeys and _operatorIds arrays should have the same lengths\nerror P2pSsvProxy__AmountOfParametersError();\n\n/// @notice Selector is not allowed for the caller.\n/// @param _caller caller address\n/// @param _selector function selector to be called on SSVNetwork\nerror P2pSsvProxy__SelectorNotAllowed(address _caller, bytes4 _selector);\n\n/// @title Proxy for SSVNetwork calls.\n/// @dev Each instance of P2pSsvProxy corresponds to 1 FeeDistributor instance.\n/// Thus, client to P2pSsvProxy instances is a 1-to-many relation.\n/// SSV tokens are managed by P2P.\n/// Clients cover the costs of SSV tokens by EL rewards via FeeDistributor instance.\ncontract P2pSsvProxy is OwnableAssetRecoverer, ERC165, IP2pSsvProxy {\n\n    /// @notice P2pSsvProxyFactory address\n    IP2pSsvProxyFactory private immutable i_p2pSsvProxyFactory;\n\n    /// @notice SSVNetwork address\n    ISSVNetwork private immutable i_ssvNetwork;\n\n    /// @notice SSV token (ERC-20) address\n    IERC20 private immutable i_ssvToken;\n\n    /// @notice FeeDistributor instance address\n    IFeeDistributor private s_feeDistributor;\n\n    /// @notice If caller is not client, revert\n    modifier onlyClient() {\n        address clientAddress = getClient();\n\n        if (clientAddress != msg.sender) {\n            revert P2pSsvProxy__CallerNotClient(msg.sender, clientAddress);\n        }\n        _;\n    }\n\n    /// @notice If caller is neither operator nor owner, revert\n    modifier onlyOperatorOrOwner() {\n        address currentOwner = owner();\n        address currentOperator = operator();\n\n        if (currentOperator != msg.sender && currentOwner != msg.sender) {\n            revert P2pSsvProxy__CallerNeitherOperatorNorOwner(msg.sender, currentOperator, currentOwner);\n        }\n\n        _;\n    }\n\n    /// @notice If caller is neither operator nor owner nor client, revert\n    modifier onlyOperatorOrOwnerOrClient() {\n        address operator_ = operator();\n        address owner_ = owner();\n        address client_ = getClient();\n\n        if (operator_ != msg.sender && owner_ != msg.sender && client_ != msg.sender) {\n            revert P2pSsvProxy__CallerNeitherOperatorNorOwnerNorClient(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice If caller is not factory, revert\n    modifier onlyP2pSsvProxyFactory() {\n        if (msg.sender != address(i_p2pSsvProxyFactory)) {\n            revert P2pSsvProxy__NotP2pSsvProxyFactoryCalled(msg.sender, i_p2pSsvProxyFactory);\n        }\n        _;\n    }\n\n    /// @dev Set values that are constant, common for all clients, known at the initial deploy time.\n    /// @param _p2pSsvProxyFactory address of P2pSsvProxyFactory\n    constructor(\n        address _p2pSsvProxyFactory\n    ) {\n        if (!ERC165Checker.supportsInterface(_p2pSsvProxyFactory, type(IP2pSsvProxyFactory).interfaceId)) {\n            revert P2pSsvProxy__NotP2pSsvProxyFactory(_p2pSsvProxyFactory);\n        }\n        i_p2pSsvProxyFactory = IP2pSsvProxyFactory(_p2pSsvProxyFactory);\n\n        i_ssvNetwork = (block.chainid == 1)\n            ? ISSVNetwork(0xDD9BC35aE942eF0cFa76930954a156B3fF30a4E1)\n            : ISSVNetwork(0xC3CD9A0aE89Fff83b71b58b6512D43F8a41f363D);\n\n        i_ssvToken = (block.chainid == 1)\n            ? IERC20(0x9D65fF81a3c488d585bBfb0Bfe3c7707c7917f54)\n            : IERC20(0x3a9f01091C446bdE031E39ea8354647AFef091E7);\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function initialize(\n        address _feeDistributor\n    ) external onlyP2pSsvProxyFactory {\n        s_feeDistributor = IFeeDistributor(_feeDistributor);\n\n        i_ssvToken.approve(address(i_ssvNetwork), type(uint256).max);\n\n        emit P2pSsvProxy__Initialized(_feeDistributor);\n    }\n\n    /// @dev Access any SSVNetwork function as cluster owner (this P2pSsvProxy instance)\n    /// Each selector access is managed by P2pSsvProxyFactory roles (owner, operator, client)\n    fallback() external {\n        address caller = msg.sender;\n        bytes4 selector = msg.sig;\n\n        bool isAllowed = msg.sender == owner() ||\n            (msg.sender == operator() && i_p2pSsvProxyFactory.isOperatorSelectorAllowed(selector)) ||\n            (msg.sender == getClient() && i_p2pSsvProxyFactory.isClientSelectorAllowed(selector));\n\n        if (!isAllowed) {\n            revert P2pSsvProxy__SelectorNotAllowed(caller, selector);\n        }\n\n        (bool success, bytes memory data) = address(i_ssvNetwork).call(msg.data);\n        if (success) {\n            emit P2pSsvProxy__SuccessfullyCalledViaFallback(caller, selector);\n\n            assembly {\n                return(add(data, 0x20), mload(data))\n            }\n        } else {\n            emit P2pSsvProxy__CallingViaFallbackFailed(caller, selector);\n\n            // Decode the reason from the error data returned from the call and revert with it.\n            revert(string(data));\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function registerValidators(\n        SsvPayload calldata _ssvPayload,\n        address _feeDistributorInstance\n    ) external onlyP2pSsvProxyFactory {\n        (\n            uint64[] memory operatorIds,\n            uint64 clusterIndex\n        ) = _getOperatorIdsAndClusterIndex(_ssvPayload.ssvOperators);\n\n        uint256 ssvSlot0 = uint256(_ssvPayload.ssvSlot0);\n\n        // see https://github.com/bloxapp/ssv-network/blob/1e61c35736578d4b03bacbff9da2128ad12a5620/contracts/libraries/ProtocolLib.sol#L15\n        uint64 currentNetworkFeeIndex = uint64(ssvSlot0 >> 192) + uint64(block.number - uint32(ssvSlot0)) * uint64(ssvSlot0 >> 128);\n\n        uint256 balance = _getBalance(_ssvPayload.cluster, clusterIndex, currentNetworkFeeIndex, _ssvPayload.tokenAmount);\n\n        i_ssvNetwork.registerValidator(\n            _ssvPayload.ssvValidators[0].pubkey,\n            operatorIds,\n            _ssvPayload.ssvValidators[0].sharesData,\n            _ssvPayload.tokenAmount,\n            _ssvPayload.cluster\n        );\n\n        for (uint256 i = 1; i < _ssvPayload.ssvValidators.length;) {\n            _registerValidator(\n                i,\n                operatorIds,\n                _ssvPayload.cluster,\n                clusterIndex,\n                _ssvPayload.ssvValidators[i].pubkey,\n                _ssvPayload.ssvValidators[i].sharesData,\n                currentNetworkFeeIndex,\n                balance\n            );\n\n            unchecked {++i;}\n        }\n\n        i_ssvNetwork.setFeeRecipientAddress(_feeDistributorInstance);\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function removeValidators(\n        bytes[] calldata _pubkeys,\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external onlyOperatorOrOwnerOrClient {\n        uint256 validatorCount = _pubkeys.length;\n\n        if (!(\n            _clusters.length == validatorCount\n        )) {\n            revert P2pSsvProxy__AmountOfParametersError();\n        }\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.removeValidator(_pubkeys[i], _operatorIds, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function liquidate(\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external onlyOperatorOrOwner {\n        address clusterOwner = address(this);\n        uint256 validatorCount = _clusters.length;\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.liquidate(clusterOwner, _operatorIds, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function reactivate(\n        uint256 _tokenAmount,\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external onlyOperatorOrOwner {\n        uint256 tokenPerValidator = _tokenAmount / _clusters.length;\n        uint256 validatorCount = _clusters.length;\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.reactivate(_operatorIds, tokenPerValidator, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function depositToSSV(\n        uint256 _tokenAmount,\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external {\n        address clusterOwner = address(this);\n        uint256 validatorCount = _clusters.length;\n        uint256 tokenPerValidator = _tokenAmount / validatorCount;\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.deposit(clusterOwner, _operatorIds, tokenPerValidator, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function withdrawFromSSV(\n        uint256 _tokenAmount,\n        uint64[] calldata _operatorIds,\n        ISSVNetwork.Cluster[] calldata _clusters\n    ) external onlyOperatorOrOwner {\n        uint256 tokenPerValidator = _tokenAmount / _clusters.length;\n        uint256 validatorCount = _clusters.length;\n\n        for (uint256 i = 0; i < validatorCount;) {\n            i_ssvNetwork.withdraw(_operatorIds, tokenPerValidator, _clusters[i]);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function withdrawSSVTokens(\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        i_ssvToken.transfer(_to, _amount);\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function setFeeRecipientAddress(\n        address _feeRecipientAddress\n    ) external onlyOperatorOrOwner {\n        i_ssvNetwork.setFeeRecipientAddress(_feeRecipientAddress);\n    }\n\n    /// @notice Extract operatorIds and clusterIndex out of SsvOperator list\n    /// @param _ssvOperators list of SSV operator data\n    /// @return operatorIds list of SSV operator IDs, clusterIndex updated cluster index\n    function _getOperatorIdsAndClusterIndex(\n        SsvOperator[] calldata _ssvOperators\n    ) private view returns(\n        uint64[] memory operatorIds,\n        uint64 clusterIndex\n    ) {\n        // clusterIndex updating logic reflects\n        // https://github.com/bloxapp/ssv-network/blob/fe3b9b178344dd723b19792d01ab5010dfd2dcf9/contracts/modules/SSVClusters.sol#L77\n\n        clusterIndex = 0;\n        uint256 operatorCount = _ssvOperators.length;\n        operatorIds = new uint64[](operatorCount);\n        for (uint256 i = 0; i < operatorCount;) {\n            operatorIds[i] = _ssvOperators[i].id;\n\n            uint256 snapshot = uint256(_ssvOperators[i].snapshot);\n\n            // see https://github.com/bloxapp/ssv-network/blob/6ae5903a5c99c8d75b59fc0d35574d87f82e5861/contracts/libraries/OperatorLib.sol#L13\n            clusterIndex += uint64(snapshot >> 32) + (uint32(block.number) - uint32(snapshot)) * uint64(_ssvOperators[i].fee / 10_000_000);\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @notice Calculate the balance for the subsequent cluster values in a batch\n    /// @param _cluster cluster value before the 1st validator registration\n    /// @param _newIndex clusterIndex value after the 1st validator registration\n    /// @param _currentNetworkFeeIndex currentNetworkFeeIndex from ssvSlot0\n    /// @param _tokenAmount amount of SSV tokens deposited along with the 1st validator registration\n    /// @return balance updated balance after the 1st validator registration\n    function _getBalance(\n        ISSVNetwork.Cluster calldata _cluster,\n        uint64 _newIndex,\n        uint64 _currentNetworkFeeIndex,\n        uint256 _tokenAmount\n    ) private pure returns(uint256 balance) {\n        uint256 balanceBefore = _cluster.balance + _tokenAmount;\n\n        // see https://github.com/bloxapp/ssv-network/blob/1e61c35736578d4b03bacbff9da2128ad12a5620/contracts/libraries/ClusterLib.sol#L16\n        uint64 networkFee = uint64(_currentNetworkFeeIndex - _cluster.networkFeeIndex) * _cluster.validatorCount;\n        uint64 usage = (_newIndex - _cluster.index) * _cluster.validatorCount + networkFee;\n        uint256 expandedUsage = usage * 10_000_000;\n        balance = expandedUsage > balanceBefore? 0 : balanceBefore - expandedUsage;\n    }\n\n    /// @notice Register subsequent validators after the 1st one\n    /// @param i validator index in calldata\n    /// @param _operatorIds list of SSV operator IDs\n    /// @param _cluster cluster value before the 1st registration\n    /// @param _clusterIndex calculated clusterIndex after the 1st registration\n    /// @param _pubkey validator pubkey\n    /// @param _sharesData validator SSV sharesData\n    /// @param _currentNetworkFeeIndex currentNetworkFeeIndex from ssvSlot0\n    /// @param _balance cluster balance after the 1st validator registration\n    function _registerValidator(\n        uint256 i,\n        uint64[] memory _operatorIds,\n        ISSVNetwork.Cluster calldata _cluster,\n        uint64 _clusterIndex,\n        bytes calldata _pubkey,\n        bytes calldata _sharesData,\n        uint64 _currentNetworkFeeIndex,\n        uint256 _balance\n    ) private {\n        ISSVClusters.Cluster memory cluster = ISSVClusters.Cluster({\n            validatorCount: uint32(_cluster.validatorCount + i),\n            networkFeeIndex: _currentNetworkFeeIndex,\n            index: _clusterIndex,\n            active: true,\n            balance: _balance\n        });\n\n        i_ssvNetwork.registerValidator(\n            _pubkey,\n            _operatorIds,\n            _sharesData,\n            0,\n            cluster\n        );\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function getClient() public view returns (address) {\n        return s_feeDistributor.client();\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function getFactory() external view returns (address) {\n        return address(i_p2pSsvProxyFactory);\n    }\n\n    /// @inheritdoc IOwnable\n    function owner() public view override(OwnableBase, IOwnable) returns (address) {\n        return i_p2pSsvProxyFactory.owner();\n    }\n\n    /// @inheritdoc IOwnableWithOperator\n    function operator() public view returns (address) {\n        return i_p2pSsvProxyFactory.operator();\n    }\n\n    /// @inheritdoc IP2pSsvProxy\n    function getFeeDistributor() external view returns (address) {\n        return address(s_feeDistributor);\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IP2pSsvProxy).interfaceId || super.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "src/p2pSsvProxyFactory/P2pSsvProxyFactory.sol",
      "content": "// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport \"../@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"../interfaces/IDepositContract.sol\";\nimport \"../interfaces/p2p/IFeeDistributor.sol\";\nimport \"../interfaces/p2p/IFeeDistributorFactory.sol\";\nimport \"../interfaces/ssv/ISSVViews.sol\";\n\nimport \"../assetRecovering/OwnableAssetRecoverer.sol\";\nimport \"../access/OwnableWithOperator.sol\";\nimport \"../p2pSsvProxy/P2pSsvProxy.sol\";\nimport \"../structs/P2pStructs.sol\";\nimport \"./IP2pSsvProxyFactory.sol\";\n\n/// @notice Passed address is not a valid FeeDistributorFactory\n/// @param _passedAddress Passed address\nerror P2pSsvProxyFactory__NotFeeDistributorFactory(address _passedAddress);\n\n/// @notice Passed address is not a valid FeeDistributor\n/// @param _passedAddress Passed address\nerror P2pSsvProxyFactory__NotFeeDistributor(address _passedAddress);\n\n/// @notice Passed address is not a valid P2pSsvProxy\n/// @param _passedAddress Passed address\nerror P2pSsvProxyFactory__NotP2pSsvProxy(address _passedAddress);\n\n/// @notice Caller in not an allowed SSV operator owner\n/// @param _caller Caller address\nerror P2pSsvProxyFactory__NotAllowedSsvOperatorOwner(address _caller);\n\n/// @notice Cannot add an already existing SSV operator owner address\n/// @param _ssvOperatorOwner an already existing SSV operator owner address\nerror P2pSsvProxyFactory__SsvOperatorOwnerAlreadyExists(address _ssvOperatorOwner);\n\n/// @notice Cannot remove a nonexisting SSV operator owner address\n/// @param _ssvOperatorOwner a nonexisting SSV operator owner address\nerror P2pSsvProxyFactory__SsvOperatorOwnerDoesNotExist(address _ssvOperatorOwner);\n\n/// @notice This SSV operator ID is not allowed. Check both the operator owner address and the ID for being allowed\n/// @param _ssvOperatorOwner operator owner address\n/// @param _ssvOperatorId operator ID\nerror P2pSsvProxyFactory__SsvOperatorNotAllowed(address _ssvOperatorOwner, uint64 _ssvOperatorId);\n\n/// @notice All operators should belong to different owners\n/// @param _ssvOperatorOwner operator owner who owns at least 2 of the passed operator IDs\n/// @param _ssvOperatorId1 passed operator ID owned by the same owner\n/// @param _ssvOperatorId2 passed operator ID owned by the same owner\nerror P2pSsvProxyFactory__DuplicateOperatorOwnersNotAllowed(\n    address _ssvOperatorOwner,\n    uint64 _ssvOperatorId1,\n    uint64 _ssvOperatorId2\n);\n\n/// @notice All the SSV operator IDs must be unique\n/// @param _ssvOperatorId duplicated operator ID\nerror P2pSsvProxyFactory__DuplicateIdsNotAllowed(uint64 _ssvOperatorId);\n\n/// @notice ETH value passed with the transaction must be equal to the needed value\n/// @param _needed needed ETH value\n/// @param _paid actually sent ETH value\nerror P2pSsvProxyFactory__NotEnoughEtherPaidToCoverSsvFees(uint256 _needed, uint256 _paid);\n\n/// @notice ETH value passed with the transaction must be equal to 32 times validator count\n/// @param _actualEthValue actually sent ETH value\nerror P2pSsvProxyFactory__EthValueMustBe32TimesValidatorCount(uint256 _actualEthValue);\n\n/// @dev We assume, SSV won't either drop 7539x or soar higher than 100 ETH.\n/// If it does, this contract won't be operational and another contract will have to be deployed.\nerror P2pSsvProxyFactory__SsvPerEthExchangeRateDividedByWeiOutOfRange();\n\n/// @notice SSV per ETH exchange rate has not been set. Cannot register validators without it.\nerror P2pSsvProxyFactory__SsvPerEthExchangeRateDividedByWeiNotSet();\n\n/// @notice This SSV operator ID does not belong to the passed owner\n/// @param _operatorId SSV operator ID\n/// @param _passedOwner passed address for SSV operator owner\n/// @param _actualOwner actual SSV operator owner address\nerror P2pSsvProxyFactory__SsvOperatorIdDoesNotBelongToOwner(\n    uint64 _operatorId,\n    address _passedOwner,\n    address _actualOwner\n);\n\n/// @notice Should pass at least 1 selector\nerror P2pSsvProxyFactory__CannotSetZeroSelectors();\n\n/// @notice Should pass at least 1 SSV operator owner\nerror P2pSsvProxyFactory__CannotSetZeroAllowedSsvOperatorOwners();\n\n/// @notice Should pass at least 1 SSV operator owner\nerror P2pSsvProxyFactory__CannotRemoveZeroAllowedSsvOperatorOwners();\n\n/// @notice There should equal number of pubkeys, signatures, and depositDataRoots\n/// @param _ssvValidatorsLength validators list length\n/// @param _signaturesLength signatures list length\n/// @param _depositDataRootsLength depositDataRoots list length\nerror P2pSsvProxyFactory__DepositDataArraysShouldHaveTheSameLength(\n    uint256 _ssvValidatorsLength,\n    uint256 _signaturesLength,\n    uint256 _depositDataRootsLength\n);\n\n/// @title Entry point for SSV validator registration\n/// @dev Deploys P2pSsvProxy instances\ncontract P2pSsvProxyFactory is OwnableAssetRecoverer, OwnableWithOperator, ERC165, IP2pSsvProxyFactory {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Beacon Deposit Contract\n    IDepositContract private immutable i_depositContract;\n\n    /// @notice FeeDistributorFactory\n    IFeeDistributorFactory private immutable i_feeDistributorFactory;\n\n    /// @notice SSV ERC-20 token\n    IERC20 private immutable i_ssvToken;\n\n    /// @notice SSVNetworkViews\n    ISSVViews private immutable i_ssvViews;\n\n    /// @notice Template set by P2P to be used for new FeeDistributor instances.\n    /// @dev Can be changed by P2P at any time. It will only affect the new clusters.\n    /// Existing clusters will keep their existing FeeDistributor instance.\n    address private s_referenceFeeDistributor;\n\n    /// @notice Template set by P2P to be used for new P2pSsvProxy instances.\n    /// @dev Can be changed by P2P at any time. It will only affect the new clusters.\n    /// Existing clusters will keep their existing P2pSsvProxy instance.\n    P2pSsvProxy private s_referenceP2pSsvProxy;\n\n    /// @notice a set of addresses of SSV operator owners (both P2P and partners).\n    /// @dev Only P2P can add or remove addresses from the set.\n    EnumerableSet.AddressSet private s_allowedSsvOperatorOwners;\n\n    /// @notice a mapping of (operator owner address → SSV operator IDs list).\n    /// @dev The list of allowed SSV operator IDs for each address is limited to 8 IDs.\n    /// The operator owner can update only their list. P2P can update lists of any owners.\n    mapping(address => uint64[MAX_ALLOWED_SSV_OPERATOR_IDS]) private s_allowedSsvOperatorIds;\n\n    /// @notice a mapping of (client address → a list of addresses of the deployed client P2pSsvProxy instances).\n    /// @dev Updated automatically during P2pSsvProxy instance deployment.\n    mapping(address => address[]) private s_allClientP2pSsvProxies;\n\n    /// @notice a list of all ever deployed client P2pSsvProxy instances.\n    /// @dev Updated automatically during P2pSsvProxy instance deployment.\n    address[] private s_allP2pSsvProxies;\n\n    /// @notice a mapping to check if a certain selector (function signature) is allowed for clients to call on SSVNetwork via P2pSsvProxy.\n    mapping(bytes4 => bool) private s_clientSelectors;\n\n    /// @notice a mapping to check if a certain selector (function signature) is allowed for a P2P operator to call on SSVNetwork via P2pSsvProxy.\n    mapping(bytes4 => bool) private s_operatorSelectors;\n\n    /// @notice Exchange rate between SSV and ETH set by P2P.\n    /// @dev (If 1 SSV = 0.007539 ETH, it should be 0.007539 * 10^18 = 7539000000000000).\n    /// Only used during validator registration without ETH deposits to cover SSV token costs with client ETH.\n    /// SSV tokens exchanged with this rate cannot be withdrawn by the client.\n    /// P2P is willing to tolarate potential discrepancies with the market exchange rate for the sake of simplicity.\n    /// The client agrees to this rate when calls `registerValidators` function.\n    uint256 private s_ssvPerEthExchangeRateDividedByWei;\n\n    /// @notice If the given _ssvOperatorOwner is not allowed, revert\n    modifier onlyAllowedSsvOperatorOwner(address _ssvOperatorOwner) {\n        bool isAllowed = s_allowedSsvOperatorOwners.contains(_ssvOperatorOwner);\n        if (!isAllowed) {\n            revert P2pSsvProxyFactory__NotAllowedSsvOperatorOwner(_ssvOperatorOwner);\n        }\n        _;\n    }\n\n    /// @notice If the msg.sender is not an allowed SSV operator owner, revert\n    modifier onlySsvOperatorOwner() {\n        bool isAllowed = s_allowedSsvOperatorOwners.contains(msg.sender);\n        if (!isAllowed) {\n            revert P2pSsvProxyFactory__NotAllowedSsvOperatorOwner(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Revert if either 1) one of the operator IDs is not allowed 2) at least 2 operator IDs belong to the same owner\n    modifier onlyAllowedOperators(SsvOperator[] calldata _operators) {\n        uint256 operatorCount = _operators.length;\n        for (uint256 i = 0; i < operatorCount;) {\n            address currentOperatorOwner = _operators[i].owner;\n\n            uint64[MAX_ALLOWED_SSV_OPERATOR_IDS] memory allowedIds = s_allowedSsvOperatorIds[currentOperatorOwner];\n\n            bool isAllowed;\n            for (uint256 j = 0; j < MAX_ALLOWED_SSV_OPERATOR_IDS;) {\n                if (allowedIds[j] == _operators[i].id) {\n                    isAllowed = true;\n                    break;\n                }\n\n                unchecked {++j;}\n            }\n            if (!isAllowed) {\n                revert P2pSsvProxyFactory__SsvOperatorNotAllowed(currentOperatorOwner, _operators[i].id);\n            }\n\n            for (uint256 k = 0; k < operatorCount;) {\n                if (i != k && currentOperatorOwner == _operators[k].owner) {\n                    revert P2pSsvProxyFactory__DuplicateOperatorOwnersNotAllowed(\n                        currentOperatorOwner,\n                        _operators[i].id,\n                        _operators[k].id\n                    );\n                }\n\n                unchecked {++k;}\n            }\n\n            unchecked {++i;}\n        }\n\n        _;\n    }\n\n    /// @dev Set values that are constant, common for all clients, known at the initial deploy time.\n    /// @param _feeDistributorFactory FeeDistributorFactory address\n    /// @param _referenceFeeDistributor reference FeeDistributor address\n    constructor(\n        address _feeDistributorFactory,\n        address _referenceFeeDistributor\n    ) {\n        if (!ERC165Checker.supportsInterface(_feeDistributorFactory, type(IFeeDistributorFactory).interfaceId)) {\n            revert P2pSsvProxyFactory__NotFeeDistributorFactory(_feeDistributorFactory);\n        }\n        i_feeDistributorFactory = IFeeDistributorFactory(_feeDistributorFactory);\n\n        if (!ERC165Checker.supportsInterface(_referenceFeeDistributor, type(IFeeDistributor).interfaceId)) {\n            revert P2pSsvProxyFactory__NotFeeDistributor(_referenceFeeDistributor);\n        }\n\n        s_referenceFeeDistributor = _referenceFeeDistributor;\n        emit P2pSsvProxyFactory__ReferenceFeeDistributorSet(_referenceFeeDistributor);\n\n        i_depositContract = (block.chainid == 1)\n            ? IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa)\n            : IDepositContract(0xff50ed3d0ec03aC01D4C79aAd74928BFF48a7b2b);\n\n        i_ssvToken = (block.chainid == 1)\n            ? IERC20(0x9D65fF81a3c488d585bBfb0Bfe3c7707c7917f54)\n            : IERC20(0x3a9f01091C446bdE031E39ea8354647AFef091E7);\n\n        i_ssvViews = (block.chainid == 1)\n            ? ISSVViews(0xafE830B6Ee262ba11cce5F32fDCd760FFE6a66e4)\n            : ISSVViews(0xAE2C84c48272F5a1746150ef333D5E5B51F68763);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setSsvPerEthExchangeRateDividedByWei(uint256 _ssvPerEthExchangeRateDividedByWei) external onlyOwner {\n        if (_ssvPerEthExchangeRateDividedByWei < 10 ** 12 || _ssvPerEthExchangeRateDividedByWei > 10 ** 20) {\n            revert P2pSsvProxyFactory__SsvPerEthExchangeRateDividedByWeiOutOfRange();\n        }\n\n        s_ssvPerEthExchangeRateDividedByWei = _ssvPerEthExchangeRateDividedByWei;\n        emit P2pSsvProxyFactory__SsvPerEthExchangeRateDividedByWeiSet(_ssvPerEthExchangeRateDividedByWei);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setReferenceP2pSsvProxy(address _referenceP2pSsvProxy) external onlyOwner {\n        if (!ERC165Checker.supportsInterface(_referenceP2pSsvProxy, type(IP2pSsvProxy).interfaceId)) {\n            revert P2pSsvProxyFactory__NotP2pSsvProxy(_referenceP2pSsvProxy);\n        }\n\n        s_referenceP2pSsvProxy = P2pSsvProxy(_referenceP2pSsvProxy);\n        emit P2pSsvProxyFactory__ReferenceP2pSsvProxySet(_referenceP2pSsvProxy);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setAllowedSelectorsForClient(bytes4[] calldata _selectors) external onlyOwner {\n        uint256 count = _selectors.length;\n\n        if (count == 0) {\n            revert P2pSsvProxyFactory__CannotSetZeroSelectors();\n        }\n\n        for (uint256 i = 0; i < count;) {\n            s_clientSelectors[_selectors[i]] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit P2pSsvProxyFactory__AllowedSelectorsForClientSet(_selectors);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setAllowedSelectorsForOperator(bytes4[] calldata _selectors) external onlyOwner {\n        uint256 count = _selectors.length;\n\n        if (count == 0) {\n            revert P2pSsvProxyFactory__CannotSetZeroSelectors();\n        }\n\n        for (uint256 i = 0; i < count;) {\n            s_operatorSelectors[_selectors[i]] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit P2pSsvProxyFactory__AllowedSelectorsForOperatorSet(_selectors);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setReferenceFeeDistributor(\n        address _referenceFeeDistributor\n    ) external onlyOperatorOrOwner {\n        if (!ERC165Checker.supportsInterface(_referenceFeeDistributor, type(IFeeDistributor).interfaceId)) {\n            revert P2pSsvProxyFactory__NotFeeDistributor(_referenceFeeDistributor);\n        }\n\n        s_referenceFeeDistributor = _referenceFeeDistributor;\n        emit P2pSsvProxyFactory__ReferenceFeeDistributorSet(_referenceFeeDistributor);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setAllowedSsvOperatorOwners(\n        address[] calldata _allowedSsvOperatorOwners\n    ) external onlyOperatorOrOwner {\n        uint256 count = _allowedSsvOperatorOwners.length;\n\n        if (count == 0) {\n            revert P2pSsvProxyFactory__CannotSetZeroAllowedSsvOperatorOwners();\n        }\n\n        for (uint256 i = 0; i < count;) {\n            address allowedSsvOperatorOwner = _allowedSsvOperatorOwners[i];\n\n            if (!s_allowedSsvOperatorOwners.add(allowedSsvOperatorOwner)) {\n                revert P2pSsvProxyFactory__SsvOperatorOwnerAlreadyExists(allowedSsvOperatorOwner);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit P2pSsvProxyFactory__AllowedSsvOperatorOwnersSet(_allowedSsvOperatorOwners);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function removeAllowedSsvOperatorOwners(\n        address[] calldata _allowedSsvOperatorOwnersToRemove\n    ) external onlyOperatorOrOwner {\n        uint256 count = _allowedSsvOperatorOwnersToRemove.length;\n\n        if (count == 0) {\n            revert P2pSsvProxyFactory__CannotRemoveZeroAllowedSsvOperatorOwners();\n        }\n\n        for (uint256 i = 0; i < count;) {\n            address allowedSsvOperatorOwnersToRemove = _allowedSsvOperatorOwnersToRemove[i];\n\n            if (!s_allowedSsvOperatorOwners.remove(allowedSsvOperatorOwnersToRemove)) {\n                revert P2pSsvProxyFactory__SsvOperatorOwnerDoesNotExist(allowedSsvOperatorOwnersToRemove);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit P2pSsvProxyFactory__AllowedSsvOperatorOwnersRemoved(_allowedSsvOperatorOwnersToRemove);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setSsvOperatorIds(\n        uint64[MAX_ALLOWED_SSV_OPERATOR_IDS] calldata _operatorIds\n    ) external onlySsvOperatorOwner {\n        _setSsvOperatorIds(_operatorIds, msg.sender);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setSsvOperatorIds("
    }
  ]
}