{
  "Title": "[H-02] Missing check on helper contract allows arbitrary actions and theft of assets",
  "Content": "\nThe `MagnetarOptionModule` contract implements the `exitPositionAndRemoveCollateral` function which allows users to do a series of operations which is irrelevant to the issue. The user passes in the variable `data`, and later, `data.externalData` is used to extract out relevant contract addresses. These are then checked against a whitelist.\n\n```solidity\nif (data.externalData.bigBang != address(0)) {\n    if (!cluster.isWhitelisted(0, data.externalData.bigBang)) {\n        revert Magnetar_TargetNotWhitelisted(data.externalData.bigBang);\n    }\n}\nif (data.externalData.singularity != address(0)) {\n    if (!cluster.isWhitelisted(0, data.externalData.singularity)) {\n        revert Magnetar_TargetNotWhitelisted(data.externalData.singularity);\n    }\n}\n```\n\nThe main issue is that the `data.externalData` also has a `marketHelper` field which is not checked against a whitelist and ends up being used.\n\n```solidity\n(Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper).repay(\n    address(this), data.user, false, data.removeAndRepayData.repayAmount\n);\n(bool[] memory successes, bytes[] memory results) = bigBang_.execute(modules, calls, true);\n```\n\nThe helper contracts are used to construct the calldata for market operations. In the above snippet, the helper contract is passed in some data, and it is expected to create a calldata out of the passed in data. The expected output is the repay module and a `call` value which when executed, will repay for the `data.user`'s account.\n\nHowever, since the `marketHelper` contract is never checked against a whitelist, malicious user can pass in any address in that place. So the above call can return any data payload, and the `bigBang_.execute` will execute it without any checks. This means the malicious helper contract can return a `borrow` payload of some random user, and the contract will end up borrowing USDO against that user's position. The Magnetar contract is assumed to have approval for market operations, and thus the Magnetar's approval is essentially exploited by the attacker to perform arbitrary actions on any user's account.\n\nThis can be used by any user to steal collateral from other user's bigbang position, or borrow out usdo tokens on their position. Since this is direct theft, this is a high severity issue.\n\n### Proof of Concept\n\nThe absence of checks is evident from the code snippet. Assuming `marketHelper` contract is malicious, we see that is used in 2 places to create payloads, which must also be deemed malicious.\n\n```solidity\n(Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper).repay(\n    address(this), data.user, false, data.removeAndRepayData.repayAmount\n);\n```\n\n```solidity\n(Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper)\n    .removeCollateral(data.user, removeCollateralTo, collateralShare);\n```\n\nThese are then executed, and the Magnetar is assumed to have approvals from users, so these are obviously malicious interactions.\n\nIn the other module contracts, the `marketHelper` is checked against a whitelist, but not in this module. This is a clear oversight. Below is the example from the `MagnetarMintCommonModule`:\n\n```solidity\nif (!cluster.isWhitelisted(0, marketHelper)) {\n    revert Magnetar_TargetNotWhitelisted(marketHelper);\n}\n```\n\n### Recommended Mitigation Steps\n\nCheck the helper contract against a whitelist.\n\n**[cryptotechmaker (Tapioca) disagreed with severity and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/179#issuecomment-2009630642):**\n > Low/Invalid; even if the market helper is not checked (and I agree it's ok to add that verification) the module which is going to be executed is checked on the BB/SGL side and the action that's being performed also checks the allowances\n\n**[ladboy233 (warden) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/179#issuecomment-2046304018):**\n> I think the severity is not inflated and the severity is high and the issue clearly leads to theft of fund.\n> \n> 1. Magnatar is a like a router contract and help user compose multicall.\n> 2. User calls magnetar function -> [delegate calls Option Module](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/Magnetar.sol#L143).\n> \n> ```solidity\n>  /// @dev Modules will not return result data.\n>             if (_action.id == MagnetarAction.OptionModule) {\n>                 _executeModule(MagnetarModule.OptionModule, _action.call);\n>                 continue; // skip the rest of the loop\n>             }\n> ```\n> \n> 3. User needs to give a lot of approve for magnetar contract to allow magnetar contract pull fund out of user's account to complete transaction.\n> \n> 4. To prevent abuse of allowance, this check is [made in-place](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarOptionModule.sol#L60).\n> \n> ```solidity\n>    function exitPositionAndRemoveCollateral(ExitPositionAndRemoveCollateralData memory data) public payable {\n>         // Check sender\n>         _checkSender(data.user);\n> ```\n> \n> Which calls:\n> \n> ```solidity\n>  function _checkSender(address _from) internal view {\n>         if (_from != msg.sender && !cluster.isWhitelisted(0, msg.sender)) {\n>             revert Magnetar_NotAuthorized(msg.sender, _from);\n>         }\n>     }\n> ```\n> \n> The from `!= msg.sender` is super important, otherwise.\n> \n> If user A gives allowance to magnetar contract, user B can set `data.user` to user A and steal fund from user A directly.\n> \n> 5. Lack of validation of market helper allows malicious actor executes arbitrary multicall. See [here](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarOptionModule.sol#L173).\n> \n> ```solidity\n>  (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper).repay(\n>                 address(this), data.user, false, data.removeAndRepayData.repayAmount\n>             );\n>             (bool[] memory successes, bytes[] memory results) = bigBang_.execute(modules, calls, true);\n> ```\n> \n> As for sponsor comments:\n> \n> > The module which is going to be executed is checked on the BB/SGL side and the action that's being performed also checks the allowances.\n> \n> This is the code in BBCollateral module:\n> \n> `bigBang_.execute` multicall to `bigBang` module and one of the module is BBCollateral module:\n> \n> ```\n>    function removeCollateral(address from, address to, uint256 share)\n>         external\n>         optionNotPaused(PauseType.RemoveCollateral)\n>         solvent(from, false)\n>         notSelf(to)\n>         allowedBorrow(from, share)\n>     {\n>         _removeCollateral(from, to, share);\n>     }\n> ```\n> \n> The validation that sponsor mentions is in the modifier:\n> \n> ```solidity\n>  allowedBorrow(from, share)\n> ```\n> \n> Which calls:\n> \n> ```solidity\n>   function _allowedBorrow(address from, uint256 share) internal virtual override {\n>         if (from != msg.sender) {\n>             // TODO review risk of using this\n>             (uint256 pearlmitAllowed,) = penrose.pearlmit().allowance(from, msg.sender, address(yieldBox), collateralId);\n>             require(allowanceBorrow[from][msg.sender] >= share || pearlmitAllowed >= share, \"Market: not approved\");\n>             if (allowanceBorrow[from][msg.sender] != type(uint256).max) {\n>                 allowanceBorrow[from][msg.sender] -= share;\n>             }\n>         }\n>     }\n> ```\n> \n> Obviously \"from\" is not `msg.sender`, but `msg.sender` is the magnetar contract that hold user's allowance.\n> \n> 6. Protocol fix the lack of market helper validation in the other part of the codebase, see [here](https://github.com/Tapioca-DAO/TapiocaZ/pull/180/files). The exact same issue should be fixed in Option module as well.\n> \n> 7. Other way to abuse pending allowance is marked as high severity [here](https://github.com/code-423n4/2024-02-tapioca-findings/issues/100).\n> \n> 8. Abuse this issue is not fixed [here](https://hacken.io/discover/sushi-hack-explained/).\n> \n> This type of exploit can occur:\n> \n> 1. User approves spending allowance to sushi router.\n> 2. Funds sit idle in users wallet.\n> 3. Attacker triggers `transferFrom` from victim address to hacker address -> exploit.\n> \n> In this case:\n> \n> 1. User approves spending allowance to magnetar.\n> 2. Funds sit idle in users wallet.\n> 3. Attacker bypasses the `_checkSender` and constructs multicall to remove collateral from user's account directly.\n\n**[carrotsmuggler (warden) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/179#issuecomment-2047008870):**\n > This should be valid. According to the sponsor, `even if the market helper is not checked the module which is going to be executed is checked on the BB/SGL side`. \n> \n> This is true. However the bigbang/sgl markets do the check on `msg.sender`, which is the magnetar contract itself, which is expected to have allowance from the users. Checks are not done on the initiator of this transaction. This is highlighted [here](https://github.com/Tapioca-DAO/Tapioca-bar/blob/b1a30b07ec1fd2626a0256f0393edac1e5055ebd/contracts/markets/Market.sol#L419-L430) and below.\n> \n> ```solidity\n> function _allowedBorrow(address from, uint256 share) internal virtual override {\n>         if (from != msg.sender) {\n>             if (share == 0) revert AllowanceNotValid();\n> \n>             // TODO review risk of using this\n>             (uint256 pearlmitAllowed,) = penrose.pearlmit().allowance(from, msg.sender, address(yieldBox), collateralId);\n>             require(allowanceBorrow[from][msg.sender] >= share || pearlmitAllowed >= share, \"Market: not approved\");\n>             if (allowanceBorrow[from][msg.sender] != type(uint256).max) {\n>                 allowanceBorrow[from][msg.sender] -= share;\n>             }\n>         }\n>     }\n> ```\n> \n> Magnetar is a privileged contract, and this function allows other users to abuse this privilege. This is basically approval hijacking, and so is high severity.\n\n**[0xRektora (Tapioca) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/179#issuecomment-2051922427):**\n > @LSDan, this can be approved as a high risk.\n> \n> While we switched the model to use \"atomic\" approvals using Pearlmit, it's better to be safe than sorry. The reviewed code also still has an obsolete `allowanceBorrow` which could help initiate this attack.\n\n**[0xWeiss (Tapioca) confirmed](https://github.com/code-423n4/2024-02-tapioca-findings/issues/179#issuecomment-2125586073)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/Magnetar.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External \nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Tapioca\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {MagnetarAction, MagnetarModule, MagnetarCall} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IMagnetarModuleExtender} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPermitAll} from \"tapioca-periph/interfaces/common/IPermitAll.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IPermit} from \"tapioca-periph/interfaces/common/IPermit.sol\";\nimport {IMarket} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseMagnetar} from \"./BaseMagnetar.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Magnetar\n * @author TapiocaDAO\n * @notice Magnetar helper contract\n */\ncontract Magnetar is BaseMagnetar {\n    error Magnetar_ValueMismatch(uint256 expected, uint256 received); // Value mismatch in the total value asked and the msg.value in burst\n    error Magnetar_ActionNotValid(MagnetarAction action, bytes actionCalldata); // Burst did not find what to execute\n\n    constructor(\n        ICluster _cluster,\n        address _owner,\n        address payable _assetModule,\n        address payable _assetXChainModule,\n        address payable _collateralModule,\n        address payable _mintModule,\n        address payable _mintXChainModule,\n        address payable _optionModule,\n        address payable _yieldBoxModule,\n        IPearlmit _pearlmit\n    ) BaseMagnetar(_cluster, _pearlmit, _owner) {\n        modules[MagnetarModule.AssetModule] = _assetModule;\n        modules[MagnetarModule.AssetXChainModule] = _assetXChainModule;\n        modules[MagnetarModule.CollateralModule] = _collateralModule;\n        modules[MagnetarModule.MintModule] = _mintModule;\n        modules[MagnetarModule.MintXChainModule] = _mintXChainModule;\n        modules[MagnetarModule.OptionModule] = _optionModule;\n        modules[MagnetarModule.YieldBoxModule] = _yieldBoxModule;\n    }\n\n    /// =====================\n    /// Public\n    /// =====================\n    /**\n     * @notice Batch multiple calls together\n     * @param calls The list of actions to perform\n     */\n    function burst(MagnetarCall[] calldata calls) external payable {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n\n        for (uint256 i; i < length; i++) {\n            MagnetarCall calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\"Magnetar: Missing call for action with index\", string(abi.encode(i)))\n                );\n            }\n            valAccumulator += _action.value;\n\n            /// @dev Permit on YB, or an SGL/BB market\n            if (_action.id == MagnetarAction.Permit) {\n                _processPermitOperation(_action.target, _action.call, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Wrap/unwrap singular operations\n            if (_action.id == MagnetarAction.Wrap) {\n                _processWrapOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Market singular operations\n            if (_action.id == MagnetarAction.Market) {\n                _processMarketOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Tap singular operations\n            if (_action.id == MagnetarAction.TapToken) {\n                _processTapTokenOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetModule) {\n                _executeModule(MagnetarModule.AssetModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetXChainModule) {\n                _executeModule(MagnetarModule.AssetXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.CollateralModule) {\n                _executeModule(MagnetarModule.CollateralModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintModule) {\n                _executeModule(MagnetarModule.MintModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintXChainModule) {\n                _executeModule(MagnetarModule.MintXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.OptionModule) {\n                _executeModule(MagnetarModule.OptionModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.YieldBoxModule) {\n                _executeModule(MagnetarModule.YieldBoxModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            if (_action.id == MagnetarAction.OFT) {\n                _processOFTOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            // If no valid action was found, use the Magnetar module extender. Only if the action is valid.\n            if (\n                address(magnetarModuleExtender) != address(0)\n                    && magnetarModuleExtender.isValidActionId(uint8(_action.id))\n            ) {\n                bytes memory callData = abi.encodeWithSelector(IMagnetarModuleExtender.handleAction.selector, _action);\n                (bool success, bytes memory returnData) = address(magnetarModuleExtender).delegatecall(callData);\n                if (!success) {\n                    _getRevertMsg(returnData);\n                }\n            } else {\n                // If no valid action was found, revert\n                revert Magnetar_ActionNotValid(_action.id, _action.call);\n            }\n        }\n\n        if (msg.value != valAccumulator) revert Magnetar_ValueMismatch(msg.value, valAccumulator);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    /**\n     * @dev Process a permit operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processPermitOperation(address _target, bytes calldata _actionCalldata, bool _allowFailure) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // permitAction(bytes,uint16)\n        // permit(address owner...)\n        // revoke(address owner...)\n        // permitAll(address from,..)\n        // permit(address from,...)\n        // setApprovalForAll(address from,...)\n        // setApprovalForAsset(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IPermitAll.permitAll.selector || funcSig == IPermitAll.revokeAll.selector\n                || funcSig == IPermit.permit.selector || funcSig == IPermit.revoke.selector\n                || funcSig == IYieldBox.setApprovalForAll.selector || funcSig == IYieldBox.setApprovalForAsset.selector \n                || funcSig == IERC20.approve.selector || funcSig == IPearlmit.approve.selector\n                || funcSig == IERC721.approve.selector \n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            // No need to send value on permit\n            _executeCall(_target, _actionCalldata, 0, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Permit, _actionCalldata);\n    }\n\n    //TODO: decide\n    /**\n     * @dev Process a TOFT operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processWrapOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // wrap(address from,...)\n        // unwrap(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n\n        if (funcSig == ITOFT.wrap.selector || funcSig == ITOFT.unwrap.selector) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Wrap, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a market operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processMarketOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // addCollateral(address from,...)\n        // borrow(address from,...)\n        // addAsset(address from,...)\n        // repay(address _from,...)\n        // buyCollateral(address from,...)\n        // sellCollateral(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IMarket.execute.selector || funcSig == ISingularity.addAsset.selector\n                || funcSig == ISingularity.removeAsset.selector\n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Market, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a TapToken operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processTapTokenOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == ITapiocaOptionBroker.exerciseOption.selector\n                || funcSig == ITapiocaOptionBroker.participate.selector\n                || funcSig == ITapiocaOptionBroker.exitPosition.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.lock.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.unlock.selector\n        ) {\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.TapToken, _actionCalldata);\n    }\n\n    /**\n     * @dev Process an OFT operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender. MsgType is sanitized by the OFT\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processOFTOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n        _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n    }\n\n    /**\n     * @dev Executes a call to an address, optionally reverting on failure. Make sure to sanitize prior to calling.\n     */\n    function _executeCall(address _target, bytes calldata _actionCalldata, uint256 _actionValue, bool _allowFailure)\n        private\n    {\n        bool success;\n        bytes memory returnData;\n\n        if (_actionValue > 0) {\n            (success, returnData) = _target.call{value: _actionValue}(_actionCalldata);\n        } else {\n            (success, returnData) = _target.call(_actionCalldata);\n        }\n\n        if (!success && !_allowFailure) {\n            _getRevertMsg(returnData);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/modules/MagnetarOptionModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {\n    ExitPositionAndRemoveCollateralData, MagnetarWithdrawData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOption} from \"tapioca-periph/interfaces/tap-token/ITapiocaOption.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {MagnetarBaseModule} from \"./MagnetarBaseModule.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarOptionModule\n * @author TapiocaDAO\n * @notice Magnetar options related operations\n */\ncontract MagnetarOptionModule is MagnetarBaseModule {\n    using SafeERC20 for IERC20;\n\n    error Magnetar_ActionParamsMismatch();\n    error Magnetar_tOLPTokenMismatch();\n    error Magnetar_MarketCallFailed(bytes call);\n\n    /**\n     * @notice helper to exit from  tOB, unlock from tOLP, remove from SGL, repay on BB, remove collateral from BB and withdraw\n     * @dev all steps are optional:\n     *         - if `removeAndRepayData.exitData.exit` is false, the exit operation is skipped\n     *         - if `removeAndRepayData.unlockData.unlock` is false, the unlock operation is skipped\n     *         - if `removeAndRepayData.removeAssetFromSGL` is false, the removeAsset operation is skipped\n     *         - if `!removeAndRepayData.assetWithdrawData.withdraw && removeAndRepayData.repayAssetOnBB`, the repay operation is performed\n     *         - if `removeAndRepayData.removeCollateralFromBB` is false, the rmeove collateral is skipped\n     *     - the helper can either stop at the remove asset from SGL step or it can continue until is removes & withdraws collateral from BB\n     *         - removed asset can be withdrawn by providing `removeAndRepayData.assetWithdrawData`\n     *     - BB collateral can be removed by providing `removeAndRepayData.collateralWithdrawData`\n     */\n    function exitPositionAndRemoveCollateral(ExitPositionAndRemoveCollateralData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        // Check whitelisted\n        if (data.externalData.bigBang != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.bigBang)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.bigBang);\n            }\n        }\n        if (data.externalData.singularity != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.singularity)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.singularity);\n            }\n        }\n\n        IMarket bigBang_ = IMarket(data.externalData.bigBang);\n        ISingularity singularity_ = ISingularity(data.externalData.singularity);\n        IYieldBox yieldBox_ = IYieldBox(singularity_.yieldBox());\n\n        // if `removeAndRepayData.exitData.exit` the following operations are performed\n        //      - if ownerOfTapTokenId is user, transfers the oTAP token id to this contract\n        //      - tOB.exitPosition\n        //      - if `!removeAndRepayData.unlockData.unlock`, transfer the obtained tokenId to the user\n        uint256 tOLPId = 0;\n        if (data.removeAndRepayData.exitData.exit) {\n            if (data.removeAndRepayData.exitData.oTAPTokenID == 0) revert Magnetar_ActionParamsMismatch();\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.exitData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.exitData.target);\n            }\n\n            address oTapAddress = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).oTAP();\n            (, ITapiocaOption.TapOption memory oTAPPosition) =\n                ITapiocaOption(oTapAddress).attributes(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            tOLPId = oTAPPosition.tOLP;\n\n            address ownerOfTapTokenId = IERC721(oTapAddress).ownerOf(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            if (ownerOfTapTokenId != data.user && ownerOfTapTokenId != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n            if (ownerOfTapTokenId == data.user) {\n                // IERC721(oTapAddress).safeTransferFrom(\n                //     data.user, address(this), data.removeAndRepayData.exitData.oTAPTokenID, \"0x\"\n                // );\n                bool isErr = pearlmit.transferFromERC721(\n                    data.user, address(this), oTapAddress, data.removeAndRepayData.exitData.oTAPTokenID\n                );\n                if (isErr) revert Magnetar_ExtractTokenFail();\n            }\n            ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).exitPosition(\n                data.removeAndRepayData.exitData.oTAPTokenID\n            );\n\n            if (!data.removeAndRepayData.unlockData.unlock) {\n                address tOLPContract = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).tOLP();\n\n                //transfer tOLP to the data.user\n                IERC721(tOLPContract).safeTransferFrom(address(this), data.user, tOLPId, \"0x\");\n            }\n        }\n\n        // performs a tOLP.unlock operation\n        if (data.removeAndRepayData.unlockData.unlock) {\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.unlockData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.unlockData.target);\n            }\n\n            if (data.removeAndRepayData.unlockData.tokenId != 0) {\n                if (tOLPId != 0) {\n                    if (tOLPId != data.removeAndRepayData.unlockData.tokenId) {\n                        revert Magnetar_tOLPTokenMismatch();\n                    }\n                }\n                tOLPId = data.removeAndRepayData.unlockData.tokenId;\n            }\n\n            address ownerOfTOLP = IERC721(data.removeAndRepayData.unlockData.target).ownerOf(tOLPId);\n\n            if (ownerOfTOLP != data.user && ownerOfTOLP != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n\n            ITapiocaOptionLiquidityProvision(data.removeAndRepayData.unlockData.target).unlock(\n                tOLPId, data.externalData.singularity, data.user\n            );\n        }\n\n        // if `data.removeAndRepayData.removeAssetFromSGL` performs the follow operations:\n        //      - removeAsset from SGL\n        //      - if `data.removeAndRepayData.assetWithdrawData.withdraw` withdraws by using the `withdrawTo` operation\n        uint256 _removeAmount = data.removeAndRepayData.removeAmount;\n        if (data.removeAndRepayData.removeAssetFromSGL) {\n            uint256 _assetId = singularity_.assetId();\n            uint256 share = yieldBox_.toShare(_assetId, _removeAmount, false);\n\n            address removeAssetTo = data.removeAndRepayData.assetWithdrawData.withdraw\n                || data.removeAndRepayData.repayAssetOnBB ? address(this) : data.user;\n\n            singularity_.removeAsset(data.user, removeAssetTo, share);\n\n            //withdraw\n            if (data.removeAndRepayData.assetWithdrawData.withdraw) {\n                uint256 computedAmount = yieldBox_.toAmount(_assetId, share, false);\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.amountLD = computedAmount;\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.minAmountLD = computedAmount;\n                _withdrawToChain(data.removeAndRepayData.assetWithdrawData);\n            }\n        }\n\n        // performs a BigBang repay operation\n        if (!data.removeAndRepayData.assetWithdrawData.withdraw && data.removeAndRepayData.repayAssetOnBB) {\n            _setApprovalForYieldBox(address(bigBang_), yieldBox_);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper).repay(\n                address(this), data.user, false, data.removeAndRepayData.repayAmount\n            );\n            (bool[] memory successes, bytes[] memory results) = bigBang_.execute(modules, calls, true);\n\n            if (!successes[0]) revert Magnetar_MarketCallFailed(calls[0]);\n            uint256 repayed = IMarketHelper(data.externalData.marketHelper).repayView(results[0]);\n            // transfer excess amount to the data.user\n            if (repayed < _removeAmount) {\n                uint256 bbAssetId = bigBang_.assetId();\n                yieldBox_.transfer(\n                    address(this), data.user, bbAssetId, yieldBox_.toShare(bbAssetId, _removeAmount - repayed, false)\n                );\n            }\n        }\n\n        // performs a BigBang removeCollateral operation\n        // if `data.removeAndRepayData.collateralWithdrawData.withdraw` withdraws by using the `withdrawTo` method\n        if (data.removeAndRepayData.removeCollateralFromBB) {\n            uint256 _collateralId = bigBang_.collateralId();\n            uint256 collateralShare = yieldBox_.toShare(_collateralId, data.removeAndRepayData.collateralAmount, false);\n            address removeCollateralTo =\n                data.removeAndRepayData.collateralWithdrawData.withdraw ? address(this) : data.user;\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper)\n                .removeCollateral(data.user, removeCollateralTo, collateralShare);\n            bigBang_.execute(modules, calls, true);\n\n            //withdraw\n            if (data.removeAndRepayData.collateralWithdrawData.withdraw) {\n                uint256 computedAmount = yieldBox_.toAmount(_collateralId, collateralShare, false);\n                data.removeAndRepayData.collateralWithdrawData.lzSendParams.sendParam.amountLD = computedAmount;\n                data.removeAndRepayData.collateralWithdrawData.lzSendParams.sendParam.minAmountLD = computedAmount;\n                _withdrawToChain(data.removeAndRepayData.collateralWithdrawData);\n            }\n        }\n        _revertYieldBoxApproval(address(bigBang_), yieldBox_);\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/modules/MagnetarOptionModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {\n    ExitPositionAndRemoveCollateralData, MagnetarWithdrawData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOption} from \"tapioca-periph/interfaces/tap-token/ITapiocaOption.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {MagnetarBaseModule} from \"./MagnetarBaseModule.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarOptionModule\n * @author TapiocaDAO\n * @notice Magnetar options related operations\n */\ncontract MagnetarOptionModule is MagnetarBaseModule {\n    using SafeERC20 for IERC20;\n\n    error Magnetar_ActionParamsMismatch();\n    error Magnetar_tOLPTokenMismatch();\n    error Magnetar_MarketCallFailed(bytes call);\n\n    /**\n     * @notice helper to exit from  tOB, unlock from tOLP, remove from SGL, repay on BB, remove collateral from BB and withdraw\n     * @dev all steps are optional:\n     *         - if `removeAndRepayData.exitData.exit` is false, the exit operation is skipped\n     *         - if `removeAndRepayData.unlockData.unlock` is false, the unlock operation is skipped\n     *         - if `removeAndRepayData.removeAssetFromSGL` is false, the removeAsset operation is skipped\n     *         - if `!removeAndRepayData.assetWithdrawData.withdraw && removeAndRepayData.repayAssetOnBB`, the repay operation is performed\n     *         - if `removeAndRepayData.removeCollateralFromBB` is false, the rmeove collateral is skipped\n     *     - the helper can either stop at the remove asset from SGL step or it can continue until is removes & withdraws collateral from BB\n     *         - removed asset can be withdrawn by providing `removeAndRepayData.assetWithdrawData`\n     *     - BB collateral can be removed by providing `removeAndRepayData.collateralWithdrawData`\n     */\n    function exitPositionAndRemoveCollateral(ExitPositionAndRemoveCollateralData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        // Check whitelisted\n        if (data.externalData.bigBang != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.bigBang)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.bigBang);\n            }\n        }\n        if (data.externalData.singularity != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.singularity)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.singularity);\n            }\n        }\n\n        IMarket bigBang_ = IMarket(data.externalData.bigBang);\n        ISingularity singularity_ = ISingularity(data.externalData.singularity);\n        IYieldBox yieldBox_ = IYieldBox(singularity_.yieldBox());\n\n        // if `removeAndRepayData.exitData.exit` the following operations are performed\n        //      - if ownerOfTapTokenId is user, transfers the oTAP token id to this contract\n        //      - tOB.exitPosition\n        //      - if `!removeAndRepayData.unlockData.unlock`, transfer the obtained tokenId to the user\n        uint256 tOLPId = 0;\n        if (data.removeAndRepayData.exitData.exit) {\n            if (data.removeAndRepayData.exitData.oTAPTokenID == 0) revert Magnetar_ActionParamsMismatch();\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.exitData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.exitData.target);\n            }\n\n            address oTapAddress = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).oTAP();\n            (, ITapiocaOption.TapOption memory oTAPPosition) =\n                ITapiocaOption(oTapAddress).attributes(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            tOLPId = oTAPPosition.tOLP;\n\n            address ownerOfTapTokenId = IERC721(oTapAddress).ownerOf(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            if (ownerOfTapTokenId != data.user && ownerOfTapTokenId != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n            if (ownerOfTapTokenId == data.user) {\n                // IERC721(oTapAddress).safeTransferFrom(\n                //     data.user, address(this), data.removeAndRepayData.exitData.oTAPTokenID, \"0x\"\n                // );\n                bool isErr = pearlmit.transferFromERC721(\n                    data.user, address(this), oTapAddress, data.removeAndRepayData.exitData.oTAPTokenID\n                );\n                if (isErr) revert Magnetar_ExtractTokenFail();\n            }\n            ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).exitPosition(\n                data.removeAndRepayData.exitData.oTAPTokenID\n            );\n\n            if (!data.removeAndRepayData.unlockData.unlock) {\n                address tOLPContract = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).tOLP();\n\n                //transfer tOLP to the data.user\n                IERC721(tOLPContract).safeTransferFrom(address(this), data.user, tOLPId, \"0x\");\n            }\n        }\n\n        // performs a tOLP.unlock operation\n        if (data.removeAndRepayData.unlockData.unlock) {\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.unlockData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.unlockData.target);"
    }
  ]
}