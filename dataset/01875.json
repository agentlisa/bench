{
  "Title": "`getInnerRewardsGrowth` can be called for non-existed ticks",
  "Content": "##### Description\nThere are no checks in the `getInnerRewardsGrowth` function that `bottomTick` and `topTick` were added to the tick tree.\nhttps://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/tokenomics/contracts/farmings/EternalVirtualPool.sol#L64-L67\n\n##### Recommendation\nWe recommend adding checks that ticks were added to restrict external calls with incorrect input parameters.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/tokenomics/contracts/farmings/EternalVirtualPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.17;\n\nimport '@cryptoalgebra/core/contracts/libraries/FullMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\nimport '@cryptoalgebra/core/contracts/libraries/TickMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/LiquidityMath.sol';\n\nimport '../libraries/VirtualTickManagement.sol';\n\nimport '../base/VirtualTickStructure.sol';\n\n/// @title Algebra eternal virtual pool\n/// @notice used to track active liquidity in farming and distribute rewards\ncontract EternalVirtualPool is VirtualTickStructure {\n  using VirtualTickManagement for mapping(int24 => VirtualTickManagement.Tick);\n\n  address public immutable farmingCenterAddress;\n  address public immutable farmingAddress;\n  address public immutable pool;\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  uint128 public override currentLiquidity;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  int24 public override globalTick;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  uint32 public override prevTimestamp;\n\n  int24 internal globalPrevInitializedTick;\n\n  uint128 internal rewardRate0;\n  uint128 internal rewardRate1;\n\n  uint128 internal rewardReserve0;\n  uint128 internal rewardReserve1;\n\n  uint256 public totalRewardGrowth0 = 1;\n  uint256 public totalRewardGrowth1 = 1;\n\n  modifier onlyFromFarming() {\n    _checkIsFromFarming();\n    _;\n  }\n\n  constructor(address _farmingCenterAddress, address _farmingAddress, address _pool) {\n    globalPrevInitializedTick = TickMath.MIN_TICK;\n    farmingCenterAddress = _farmingCenterAddress;\n    farmingAddress = _farmingAddress;\n    pool = _pool;\n    prevTimestamp = uint32(block.timestamp);\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function rewardReserves() external view override returns (uint128 reserve0, uint128 reserve1) {\n    return (rewardReserve0, rewardReserve1);\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function rewardRates() external view override returns (uint128 rate0, uint128 rate1) {\n    return (rewardRate0, rewardRate1);\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function getInnerRewardsGrowth(\n    int24 bottomTick,\n    int24 topTick\n  ) external view override returns (uint256 rewardGrowthInside0, uint256 rewardGrowthInside1) {\n    unchecked {\n      uint32 timeDelta = uint32(block.timestamp) - prevTimestamp;\n      (uint256 _totalRewardGrowth0, uint256 _totalRewardGrowth1) = (totalRewardGrowth0, totalRewardGrowth1);\n\n      if (timeDelta > 0) {\n        // update rewards\n        uint128 _currentLiquidity = currentLiquidity;\n        if (_currentLiquidity > 0) {\n          (uint256 reward0, uint256 reward1) = (rewardRate0 * timeDelta, rewardRate1 * timeDelta);\n          (uint256 _rewardReserve0, uint256 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n\n          if (reward0 > _rewardReserve0) reward0 = _rewardReserve0;\n          if (reward1 > _rewardReserve1) reward1 = _rewardReserve1;\n\n          if (reward0 > 0) _totalRewardGrowth0 += FullMath.mulDiv(reward0, Constants.Q128, _currentLiquidity);\n          if (reward1 > 0) _totalRewardGrowth1 += FullMath.mulDiv(reward1, Constants.Q128, _currentLiquidity);\n        }\n      }\n\n      return ticks.getInnerFeeGrowth(bottomTick, topTick, globalTick, _totalRewardGrowth0, _totalRewardGrowth1);\n    }\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function addRewards(uint128 token0Amount, uint128 token1Amount) external override onlyFromFarming {\n    _applyRewardsDelta(true, token0Amount, token1Amount);\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function decreaseRewards(uint128 token0Amount, uint128 token1Amount) external override onlyFromFarming {\n    _applyRewardsDelta(false, token0Amount, token1Amount);\n  }\n\n  /// @inheritdoc IAlgebraVirtualPool\n  function crossTo(int24 targetTick, bool zeroToOne) external override returns (bool) {\n    if (msg.sender != farmingCenterAddress && msg.sender != pool) revert onlyPool();\n    _distributeRewards(uint32(block.timestamp));\n\n    int24 previousTick = globalPrevInitializedTick;\n    uint128 _currentLiquidity = currentLiquidity;\n    int24 _globalTick = globalTick;\n\n    (uint256 rewardGrowth0, uint256 rewardGrowth1) = (totalRewardGrowth0, totalRewardGrowth1);\n    // The set of active ticks in the virtual pool must be a subset of the active ticks in the real pool\n    // so this loop will cross no more ticks than the real pool\n    if (zeroToOne) {\n      while (_globalTick != TickMath.MIN_TICK) {\n        if (targetTick >= previousTick) break;\n        unchecked {\n          _currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, -ticks.cross(previousTick, rewardGrowth0, rewardGrowth1, 0));\n          _globalTick = previousTick - 1; // safe since tick index range is narrower than the data type\n          previousTick = ticks[previousTick].prevTick;\n          if (_globalTick < TickMath.MIN_TICK) _globalTick = TickMath.MIN_TICK;\n        }\n      }\n    } else {\n      while (_globalTick != TickMath.MAX_TICK - 1) {\n        int24 nextTick = ticks[previousTick].nextTick;\n        if (targetTick < nextTick) break;\n\n        _currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, ticks.cross(nextTick, rewardGrowth0, rewardGrowth1, 0));\n        (_globalTick, previousTick) = (nextTick, nextTick);\n      }\n    }\n\n    globalTick = targetTick;\n    currentLiquidity = _currentLiquidity;\n    globalPrevInitializedTick = previousTick;\n    return true;\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function distributeRewards(uint32 currentTimestamp) external override onlyFromFarming {\n    _distributeRewards(currentTimestamp);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function applyLiquidityDeltaToPosition(\n    uint32 currentTimestamp,\n    int24 bottomTick,\n    int24 topTick,\n    int128 liquidityDelta,\n    int24 currentTick\n  ) external override onlyFromFarming {\n    globalTick = currentTick;\n\n    if (currentTimestamp > prevTimestamp) {\n      _distributeRewards(currentTimestamp);\n    }\n\n    if (liquidityDelta != 0) {\n      // if we need to update the ticks, do it\n      bool flippedBottom;\n      bool flippedTop;\n\n      if (_updateTick(bottomTick, currentTick, liquidityDelta, false)) {\n        flippedBottom = true;\n      }\n\n      if (_updateTick(topTick, currentTick, liquidityDelta, true)) {\n        flippedTop = true;\n      }\n\n      if (currentTick >= bottomTick && currentTick < topTick) {\n        currentLiquidity = LiquidityMath.addDelta(currentLiquidity, liquidityDelta);\n      }\n\n      if (flippedBottom || flippedTop) {\n        int24 previousTick = globalPrevInitializedTick;\n        if (flippedBottom) {\n          previousTick = _insertOrRemoveTick(bottomTick, currentTick, previousTick, liquidityDelta < 0);\n        }\n        if (flippedTop) {\n          previousTick = _insertOrRemoveTick(topTick, currentTick, previousTick, liquidityDelta < 0);\n        }\n        globalPrevInitializedTick = previousTick;\n      }\n    }\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function setRates(uint128 rate0, uint128 rate1) external override onlyFromFarming {\n    _distributeRewards(uint32(block.timestamp));\n    (rewardRate0, rewardRate1) = (rate0, rate1);\n  }\n\n  function _checkIsFromFarming() internal view {\n    if (msg.sender != farmingAddress) revert onlyFarming();\n  }\n\n  function _applyRewardsDelta(bool add, uint128 token0Delta, uint128 token1Delta) private {\n    _distributeRewards(uint32(block.timestamp));\n    if (token0Delta | token1Delta != 0) {\n      (uint128 _rewardReserve0, uint128 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n      _rewardReserve0 = add ? _rewardReserve0 + token0Delta : _rewardReserve0 - token0Delta;\n      _rewardReserve1 = add ? _rewardReserve1 + token1Delta : _rewardReserve1 - token1Delta;\n      (rewardReserve0, rewardReserve1) = (_rewardReserve0, _rewardReserve1);\n    }\n  }\n\n  function _distributeRewards(uint32 currentTimestamp) internal {\n    unchecked {\n      uint256 timeDelta = currentTimestamp - prevTimestamp; // safe until timedelta > 136 years\n      if (timeDelta == 0) return; // only once per block\n\n      uint256 _currentLiquidity = currentLiquidity; // currentLiquidity is uint128\n      if (_currentLiquidity > 0) {\n        (uint256 reward0, uint256 reward1) = (rewardRate0 * timeDelta, rewardRate1 * timeDelta);\n        (uint128 _rewardReserve0, uint128 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n\n        if (reward0 > _rewardReserve0) reward0 = _rewardReserve0;\n        if (reward1 > _rewardReserve1) reward1 = _rewardReserve1;\n\n        if (reward0 | reward1 != 0) {\n          _rewardReserve0 = uint128(_rewardReserve0 - reward0);\n          _rewardReserve1 = uint128(_rewardReserve1 - reward1);\n\n          if (reward0 > 0) totalRewardGrowth0 += FullMath.mulDiv(reward0, Constants.Q128, _currentLiquidity);\n          if (reward1 > 0) totalRewardGrowth1 += FullMath.mulDiv(reward1, Constants.Q128, _currentLiquidity);\n\n          (rewardReserve0, rewardReserve1) = (_rewardReserve0, _rewardReserve1);\n        }\n      }\n    }\n\n    prevTimestamp = currentTimestamp;\n    return;\n  }\n\n  function _updateTick(int24 tick, int24 currentTick, int128 liquidityDelta, bool isTopTick) internal returns (bool updated) {\n    return ticks.update(tick, currentTick, liquidityDelta, totalRewardGrowth0, totalRewardGrowth1, 0, isTopTick);\n  }\n}"
    }
  ]
}