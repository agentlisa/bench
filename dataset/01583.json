{
  "Title": "M-3: Spot dex cant handle fee-on-transfer tokens",
  "Content": "# Issue M-3: Spot dex cant handle fee-on-transfer tokens \n\nSource: https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/40 \n\n## Found by \n0x4non, 0xStalin, kutugu, twicek\n## Summary\n\n`Dca.vy`, `LimitOrder.vy` and `TrailingStopDex.vy` does not properly support tokens that implement a fee on transfer. These types of tokens deduct a fee from any transfer of tokens, resulting in the recipient receiving less than the original amount sent. \n\n## Vulnerability Detail\n\nThe specific issue lies in the ERC20 token transfer.\n\nLests analyze the method `execute_limit_order` focus on lines [LimitOrders.vy#L160-L161](https://github.com/sherlock-audit/2023-06-unstoppable/blob/main/unstoppable-dex-audit/contracts/spot-dex/LimitOrders.vy#L160-L161), this code assumes that the full `order.amount_in` will be transferred to `self`. This assumption is incorrect when the token in question implements a fee on transfer. When a fee is deducted, `self` will receive less tokens than `order.amount_in`. The subsequent call to `approve` and `ExactInputSingleParams` could therefore potentially fail as they rely on `self` having a balance of `order.amount_in`.\n\n## Impact\n\nThis vulnerability could potentially halt token swaps midway if the token involved deducts a transfer fee. This can result in an unsuccessful token swap, which in turn could lock funds and possibly lead to financial loss for the user. \n\n## Code Snippet\n\n- [Dca.vy#L200-L201](https://github.com/sherlock-audit/2023-06-unstoppable/blob/main/unstoppable-dex-audit/contracts/spot-dex/Dca.vy#L200-L201)\n- [LimitOrders.vy#L160-L161](https://github.com/sherlock-audit/2023-06-unstoppable/blob/main/unstoppable-dex-audit/contracts/spot-dex/LimitOrders.vy#L160-L161)\n- [TrailingStopDex.vy#L170-L171](https://github.com/sherlock-audit/2023-06-unstoppable/blob/main/unstoppable-dex-audit/contracts/spot-dex/TrailingStopDex.vy#L170-L171)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo rectify this vulnerability, it's recommended to replace `order.amount_in` with the account of balance of `ERC20(order.token_in)` after the swap minus before the transferFrom call. This ensures that the correct balance (after any potential fees) is used for the approve call and the ExactInputSingleParams. It's also advised to add error handling for unsuccessful transfers and approvals.\n\nExample:\n```vy\n    balance_before: uint256 = ERC20(order.token_in).balanceOf(self)\n    \n    # transfer token_in from user to self\n    ERC20(order.token_in).transferFrom(order.account, self, order.amount_in)\n\n    correct_amount: uint256 = ERC20(order.token_in).balanceOf(self) - balance_before\n\n    # approve UNISWAP_ROUTER to spend token_in\n    ERC20(order.token_in).approve(UNISWAP_ROUTER, correct_amount)\n\n    # Use correct_amount instead of order.amount_in\n```\n\n\n\n## Discussion\n\n**dot-pengun**\n\nEscalate\n\nThe contest page states that only tokens supported by uniswap v3 can be used, as shown below.\n> The Spot contracts need to be able to interact with any pool/token, we don’t want to have a centralized whitelist, we want it to work with any Uniswap v3 pool (and later others but this is probably out of scope).\n\nAccording to the [uniswap V3 docs](https://docs.uniswap.org/concepts/protocol/integration-issues), uniswap do not support fee-on-transfer tokens, so I believe this issue is invalid.\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> The contest page states that only tokens supported by uniswap v3 can be used, as shown below.\n> > The Spot contracts need to be able to interact with any pool/token, we don’t want to have a centralized whitelist, we want it to work with any Uniswap v3 pool (and later others but this is probably out of scope).\n> \n> According to the [uniswap V3 docs](https://docs.uniswap.org/concepts/protocol/integration-issues), uniswap do not support fee-on-transfer tokens, so I believe this issue is invalid.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**twicek**\n\nEscalate for 10 USDC\nThis sentence implies that any token could be interacted with in the spot contracts:\n> The Spot contracts need to be able to interact with any pool/token, we don’t want to have a centralized whitelist, we want it to work with any Uniswap v3 pool (and later others but this is probably out of scope).\n\nThe sponsor didn't know that fee-on-transfer tokens couldn't be used in UniswapV3 when writing the README in which fee-on-transfer token related issues are explicitly in scope for the spot dex:\n\n> Q: Are there any FEE-ON-TRANSFER tokens interacting with the smart contracts?\nMargin: no Spot: possibly\n\nInformation acquired after the beginning of the contest and not explicitly mentioned in the README shouldn't supersede the README information.\n\n**sherlock-admin2**\n\n > Escalate for 10 USDC\n> This sentence implies that any token could be interacted with in the spot contracts:\n> > The Spot contracts need to be able to interact with any pool/token, we don’t want to have a centralized whitelist, we want it to work with any Uniswap v3 pool (and later others but this is probably out of scope).\n> \n> The sponsor didn't know that fee-on-transfer tokens couldn't be used in UniswapV3 when writing the README in which fee-on-transfer token related issues are explicitly in scope for the spot dex:\n> \n> > Q: Are there any FEE-ON-TRANSFER tokens interacting with the smart contracts?\n> Margin: no Spot: possibly\n> \n> Information acquired after the beginning of the contest and not explicitly mentioned in the README shouldn't supersede the README information.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**141345**\n\nRecommendation: \nkeep the original judging.\n\n> Escalate\n> \n> The contest page states that only tokens supported by uniswap v3 can be used, as shown below.\n> \n> > The Spot contracts need to be able to interact with any pool/token, we don’t want to have a centralized whitelist, we want it to work with any Uniswap v3 pool (and later others but this is probably out of scope).\n> \n> According to the [uniswap V3 docs](https://docs.uniswap.org/concepts/protocol/integration-issues), uniswap do not support fee-on-transfer tokens, so I believe this issue is invalid.\n\nThe README is a little ambiguous.\n\nThe designed behavior seems to be compatible with fee on transfer token. And the POC demonstrates that the current codebase needs improvement for this purpose. \n\n**141345**\n\n> The README is a little ambiguous.\n> \n> The designed behavior seems to be compatible with fee on transfer token. And the POC demonstrates that the current codebase needs improvement for this purpose.\n\nsame as above\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/unstoppable-dex-audit/pull/10\n\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAgree with the Lead judge's comment below:\n> The README is a little ambiguous.\n> The designed behavior seems to be compatible with fee on transfer token. And the POC demonstrates that the current codebase needs improvement for this purpose.\n\nAccepting the escalation because it is understandable that it could be confusing, but will keep the issue valid medium. \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [dot-pengun](https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/40/#issuecomment-1643428684): accepted\n- [twicek](https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/40/#issuecomment-1643812283): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/95",
  "Code": [
    {
      "filename": "unstoppable-dex-audit/contracts/spot-dex/LimitOrders.vy",
      "content": "# @version ^0.3.7\n\nfrom vyper.interfaces import ERC20\n\n###################################################################\n#\n# @title Unstoppable Spot DEX - Limit Orders\n# @license GNU AGPLv3\n# @author unstoppable.ooo\n#\n# @custom:security-contact team@unstoppable.ooo\n#\n# @notice\n#    This contract is part of the Unstoppable Spot DEX.\n#    It provides the infrastructure for placing permissionless,\n#    self-custodial limit orders for Uni v3 pairs.\n#\n#    This is an early ALPHA release, use at your own risk!\n#\n###################################################################\n\n\n# struct ExactInputParams {\n#     bytes path;\n#     address recipient;\n#     uint256 deadline;\n#     uint256 amountIn;\n#     uint256 amountOutMinimum;\n# }\nstruct ExactInputParams:\n    path: Bytes[66]\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n\n\n# function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\ninterface UniswapV3SwapRouter:\n    def exactInput(_params: ExactInputParams) -> uint256: payable\n\n\nUNISWAP_ROUTER: constant(address) = 0xE592427A0AEce92De3Edee1F18E0157C05861564\n\n# owner\nowner: public(address)\nsuggested_owner: public(address)\n\n# Limit Orders\nstruct LimitOrder:\n    uid: bytes32\n    account: address\n    token_in: address\n    token_out: address\n    amount_in: uint256\n    min_amount_out: uint256\n    valid_until: uint256\n\n# user address -> position UID\nlimit_order_uids: public(HashMap[address, DynArray[bytes32, 1024]])\n# UID -> position\nlimit_orders: public(HashMap[bytes32, LimitOrder])\nposition_nonce: uint256\n\nis_paused: public(bool)\nis_accepting_new_orders: public(bool)\n\n@external\ndef __init__():\n    self.owner = msg.sender\n\n\nevent LimitOrderPosted:\n    uid: bytes32\n    token_in: indexed(address)\n    token_out: indexed(address)\n    amount_in: uint256\n    min_amount_out: uint256\n    valid_until: uint256\n    \n@external\ndef post_limit_order(\n        _token_in: address,\n        _token_out: address,\n        _amount_in: uint256,\n        _min_amount_out: uint256,\n        _valid_until: uint256\n    ):\n\n    assert not self.is_paused, \"paused\"\n    assert self.is_accepting_new_orders, \"not accepting new orders\"\n\n    # validate\n    assert _valid_until >= block.timestamp, \"invalid timestamp\"\n\n    # check msg.sender approved contract to spend amount token_in\n    allowance: uint256 = ERC20(_token_in).allowance(msg.sender, self)\n    assert allowance >= _amount_in, \"insufficient allowance\"\n    \n    order: LimitOrder = LimitOrder({\n        uid: empty(bytes32),\n        account: msg.sender,\n        token_in: _token_in,\n        token_out: _token_out,\n        amount_in: _amount_in,\n        min_amount_out: _min_amount_out,\n        valid_until: _valid_until\n    })\n\n    uid: bytes32 = self._generate_uid()\n    order.uid = uid\n\n    self.limit_orders[uid] = order\n    self.limit_order_uids[msg.sender].append(uid)\n\n    log LimitOrderPosted(uid, _token_in, _token_out, _amount_in, _min_amount_out, _valid_until)\n\n\n\nevent LimitOrderExecuted:\n    uid: bytes32\n    account: indexed(address)\n\nevent LimitOrderFailed:\n    uid: bytes32\n    account: indexed(address)\n    reason: String[32]\n\n@external\ndef execute_limit_order(_uid: bytes32, _path: DynArray[address, 3], _uni_pool_fees: DynArray[uint24, 2], _share_profit: bool):\n    assert not self.is_paused, \"paused\"\n\n    order: LimitOrder = self.limit_orders[_uid]\n    # TODO how to clean up expired orders?\n    assert order.valid_until >= block.timestamp, \"order expired\"\n\n    # ensure path is valid\n    assert len(_path) in [2, 3], \"[path] invlid path\"\n    assert len(_uni_pool_fees) == len(_path)-1, \"[path] invalid fees\"\n    assert _path[0] == order.token_in, \"[path] invalid token_in\"\n    assert _path[len(_path)-1] == order.token_out, \"[path] invalid token_out\"\n\n    # ensure user has enough token_in\n    account_balance: uint256 = ERC20(order.token_in).balanceOf(order.account)\n    if account_balance < order.amount_in:\n        log LimitOrderFailed(_uid, order.account, \"insufficient balance\")\n        self._cancel_limit_order(_uid)\n        return\n\n    # ensure self has enough allowance to spend amount token_in\n    account_allowance: uint256 = ERC20(order.token_in).allowance(order.account, self)\n    if account_allowance < order.amount_in:\n        log LimitOrderFailed(_uid, order.account, \"insufficient allowance\")\n        self._cancel_limit_order(_uid)\n        return\n\n    # cleanup storage\n    self._cleanup_order(_uid)\n\n    # transfer token_in from user to self\n    self._safe_transfer_from(order.token_in, order.account, self, order.amount_in)\n\n    # approve UNISWAP_ROUTER to spend amount token_in\n    ERC20(order.token_in).approve(UNISWAP_ROUTER, order.amount_in)\n\n    path: Bytes[66] = empty(Bytes[66])\n    if(len(_path) == 2):\n        path = concat(convert(_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_path[1], bytes20))\n    elif(len(_path) == 3):\n        path = concat(convert(_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_path[1], bytes20), convert(_uni_pool_fees[1], bytes3), convert(_path[2], bytes20))\n    \n\n    uni_params: ExactInputParams = ExactInputParams({\n        path: path,\n        recipient: self,\n        deadline: block.timestamp,\n        amountIn: order.amount_in,\n        amountOutMinimum: order.min_amount_out\n    })\n    amount_out: uint256 = UniswapV3SwapRouter(UNISWAP_ROUTER).exactInput(uni_params)\n\n    # transfer min_amount_out of token_out from self back to user\n    # anything > min_amount_out stays in contract as profit\n    self._safe_transfer(order.token_out, order.account, order.min_amount_out)\n\n    # allows searchers to execute for 50% of profits\n    if _share_profit:\n        profit: uint256 = amount_out - order.min_amount_out\n        self._safe_transfer(order.token_out, msg.sender, profit/2)\n    \n    log LimitOrderExecuted(_uid, order.account)\n\n\n\nevent LimitOrderCanceled:\n    uid: bytes32\n\n@external\ndef cancel_limit_order(_uid: bytes32):\n    order: LimitOrder = self.limit_orders[_uid]\n    assert order.account == msg.sender, \"unauthorized\"\n    self._cancel_limit_order(_uid)\n\n@internal\ndef _cancel_limit_order(_uid: bytes32):\n    self._cleanup_order(_uid)\n    log LimitOrderCanceled(_uid)\n\n\nevent OrderCleanedUp:\n    uid: bytes32\n    account: indexed(address)\n\n@internal\ndef _cleanup_order(_uid: bytes32):\n    order: LimitOrder = self.limit_orders[_uid]\n    self.limit_orders[_uid] = empty(LimitOrder)\n\n    uids: DynArray[bytes32, 1024] = self.limit_order_uids[order.account]\n    for i in range(1024):\n        if uids[i] == _uid:\n            uids[i] = uids[len(uids) - 1]\n            uids.pop()\n            break\n        if i == len(uids)-1:\n            raise\n    self.limit_order_uids[order.account] = uids\n    \n    log OrderCleanedUp(_uid, order.account)\n\n# TODO def cleanup_exired(_uids: bytes32[])\n\n\n@view\n@external\ndef get_all_open_positions(_account: address) -> DynArray[LimitOrder, 1024]:\n    uids: DynArray[bytes32, 1024] = self.limit_order_uids[_account]\n    orders: DynArray[LimitOrder, 1024] = empty(DynArray[LimitOrder, 1024])\n\n    for uid in uids:\n        orders.append(self.limit_orders[uid])\n\n    return orders\n\n\n@external\ndef withdraw_fees(_token: address):\n    amount: uint256 = ERC20(_token).balanceOf(self)\n    assert amount > 0, \"zero balance\"\n\n    self._safe_transfer(_token, self.owner, amount)\n\n\n@internal\ndef _generate_uid() -> bytes32:\n    uid: bytes32 = keccak256(_abi_encode(chain.id, self.position_nonce, block.timestamp))\n    self.position_nonce += 1\n    return uid\n\n\n@internal\ndef _safe_transfer(_token: address, _to: address, _amount: uint256) -> bool:\n    res: Bytes[32] = raw_call(\n        _token,\n        concat(\n            method_id(\"transfer(address,uint256)\"),\n            convert(_to, bytes32),\n            convert(_amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(res) > 0:\n        assert convert(res, bool), \"transfer failed\"\n\n    return True\n\n\n@internal\ndef _safe_transfer_from(\n    _token: address, _from: address, _to: address, _amount: uint256\n):\n    res: Bytes[32] = raw_call(\n        _token,\n        concat(\n            method_id(\"transferFrom(address,address,uint256)\"),\n            convert(_from, bytes32),\n            convert(_to, bytes32),\n            convert(_amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(res) > 0:\n        assert convert(res, bool), \"transfer failed\"\n\n\n#############################\n#\n#           ADMIN\n#\n#############################\n\nevent Paused: \n    is_paused: bool\n\n@external\ndef pause(_is_paused: bool):\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _is_paused != self.is_paused, \"already in state\"\n\n    self.is_paused = _is_paused\n    log Paused(_is_paused)\n\n\nevent AcceptingNewOrders: \n    is_accepting_new_orders: bool\n\n@external\ndef set_is_accepting_new_orders(_is_accepting_new_orders: bool):\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _is_accepting_new_orders != self.is_accepting_new_orders, \"already in state\"\n\n    self.is_accepting_new_orders = _is_accepting_new_orders\n    log AcceptingNewOrders(_is_accepting_new_orders)\n\n\nevent NewOwnerSuggested:\n    new_owner: indexed(address)\n    suggested_by: indexed(address)\n\n@external\ndef suggest_owner(_new_owner: address):\n    \"\"\"\n    @notice\n        Step 1 of the 2 step process to transfer ownership.\n        Current owner suggests a new owner.\n        Requires the new owner to accept ownership in step 2.\n    @param _new_owner\n        The address of the new owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _new_owner != empty(address), \"cannot set owner to zero address\"\n    self.suggested_owner = _new_owner\n    log NewOwnerSuggested(_new_owner, msg.sender)\n\n\nevent OwnershipTransferred:\n    new_owner: indexed(address)\n    promoted_by: indexed(address)\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @notice\n        Step 2 of the 2 step process to transfer ownership.\n        The suggested owner accepts the transfer and becomes the\n        new owner.\n    \"\"\"\n    assert msg.sender == self.suggested_owner, \"unauthorized\"\n    prev_owner: address = self.owner\n    self.owner = self.suggested_owner\n    log OwnershipTransferred(self.owner, prev_owner)"
    },
    {
      "filename": "unstoppable-dex-audit/contracts/spot-dex/Dca.vy",
      "content": "# @version ^0.3.7\n\n###################################################################\n#\n# @title Unstoppable Spot DEX - DCA (Dollar-Cost-Average)\n# @license GNU AGPLv3\n# @author unstoppable.ooo\n#\n# @custom:security-contact team@unstoppable.ooo\n#\n# @notice\n#    This contract is part of the Unstoppable Spot DEX.\n#    It provides the infrastructure for placing permissionless,\n#    self-custodial DCA orders for Uni v3 pairs.\n#\n#    This is an early ALPHA release, use at your own risk!\n#\n###################################################################\n\nfrom vyper.interfaces import ERC20\nfrom vyper.interfaces import ERC20Detailed\n\n# struct ExactInputParams {\n#     bytes path;\n#     address recipient;\n#     uint256 deadline;\n#     uint256 amountIn;\n#     uint256 amountOutMinimum;\n# }\nstruct ExactInputParams:\n    path: Bytes[66]\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n\n\n# function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\ninterface UniswapV3SwapRouter:\n    def exactInput(_params: ExactInputParams) -> uint256: payable\n\ninterface Univ3Twap:\n    def getTwap(_path: DynArray[address, 3], _fees: DynArray[uint24, 2], _twapLength: uint32) -> uint256: view\n\nPRECISISON: constant(uint256) = 10**18\n\nUNISWAP_ROUTER: constant(address) = 0xE592427A0AEce92De3Edee1F18E0157C05861564\n\nTWAP: constant(address) = 0xFa64f316e627aD8360de2476aF0dD9250018CFc5 \n\nFEE_BASE: constant(uint256) = 1000000 # 100 percent\nfee: public(uint256) # = 1000 # 0.1%\n\nMAX_SLIPPAGE: constant(uint256) = 10000 # 1 percent\n\n# owner\nowner: public(address)\nsuggested_owner: public(address)\n\n# DCA Orders\nstruct DcaOrder:\n    uid: bytes32\n    account: address\n    token_in: address\n    token_out: address\n    amount_in_per_execution: uint256\n    seconds_between_executions: uint256\n    max_number_of_executions: uint8\n    max_slippage: uint256\n    twap_length: uint32\n    number_of_executions: uint8\n    last_execution: uint256\n    \n\n# user address -> DcaOrder UID\ndca_order_uids: public(HashMap[address, DynArray[bytes32, 1024]])\n# UID -> DcaOrder\ndca_orders: public(HashMap[bytes32, DcaOrder])\nposition_nonce: uint256\n\nis_paused: public(bool)\nis_accepting_new_orders: public(bool)\n\n@external\ndef __init__():\n    self.owner = msg.sender\n    self.fee = 1000 # 0.1%\n\n\nevent DcaOrderPosted:\n    uid: bytes32\n    account: indexed(address)\n    token_in: indexed(address)\n    token_out: indexed(address)\n    amount_in_per_execution: uint256\n    seconds_between_executions: uint256\n    max_number_of_executions: uint8\n    twap_length: uint32\n    \n@external\ndef post_dca_order(\n        _token_in: address,\n        _token_out: address,\n        _amount_in_per_execution: uint256,\n        _seconds_between_executions: uint256,\n        _max_number_of_executions: uint8,\n        _max_slippage: uint256,\n        _twap_length: uint32\n    ):\n\n    assert not self.is_paused, \"paused\"\n    assert self.is_accepting_new_orders, \"not accepting new orders\"\n\n    # check msg.sender approved contract to spend amount token_in\n    total: uint256 = convert(_max_number_of_executions, uint256) * _amount_in_per_execution\n    allowance: uint256 = ERC20(_token_in).allowance(msg.sender, self)\n    assert allowance >= total, \"insufficient allowance\"\n\n    max_slippage: uint256 = _max_slippage\n    if max_slippage == 0:\n        max_slippage = MAX_SLIPPAGE\n    \n    order: DcaOrder = DcaOrder({\n        uid: empty(bytes32),\n        account: msg.sender,\n        token_in: _token_in,\n        token_out: _token_out,\n        amount_in_per_execution: _amount_in_per_execution,\n        seconds_between_executions: _seconds_between_executions,\n        max_number_of_executions: _max_number_of_executions,\n        max_slippage: _max_slippage,\n        twap_length: _twap_length,\n        number_of_executions: 0,\n        last_execution: 0\n    })\n\n    uid: bytes32 = self._generate_uid()\n    order.uid = uid\n\n    self.dca_orders[uid] = order\n    self.dca_order_uids[msg.sender].append(uid)\n\n    log DcaOrderPosted(uid, msg.sender, _token_in, _token_out, _amount_in_per_execution, _seconds_between_executions, _max_number_of_executions, _twap_length)\n\n\n\nevent DcaOrderExecuted:\n    uid: bytes32\n    account: indexed(address)\n    execution_number: uint8\n    amount_in: uint256\n    amount_out: uint256\n\nevent DcaOrderFailed:\n    uid: bytes32\n    account: indexed(address)\n    reason: String[32]\n\nevent DcaCompleted:\n    uid: bytes32\n    account: indexed(address)\n\n@external\n@nonreentrant('lock')\ndef execute_dca_order(_uid: bytes32, _uni_hop_path: DynArray[address, 3], _uni_pool_fees: DynArray[uint24, 2], _share_profit: bool):\n    assert not self.is_paused, \"paused\"\n\n    order: DcaOrder = self.dca_orders[_uid]\n    \n    # validate\n    assert order.number_of_executions < order.max_number_of_executions, \"max executions completed\"\n    assert order.last_execution + order.seconds_between_executions < block.timestamp, \"too soon\"\n\n    # ensure path is valid\n    assert len(_uni_hop_path) in [2, 3], \"[path] invlid path\"\n    assert len(_uni_pool_fees) == len(_uni_hop_path)-1, \"[path] invalid fees\"\n    assert _uni_hop_path[0] == order.token_in, \"[path] invalid token_in\"\n    assert _uni_hop_path[len(_uni_hop_path)-1] == order.token_out, \"[path] invalid token_out\"\n\n    # effects\n    order.last_execution = block.timestamp\n    order.number_of_executions += 1\n\n    self.dca_orders[_uid] = order\n\n    # ensure user has enough token_in\n    account_balance: uint256 = ERC20(order.token_in).balanceOf(order.account)\n    if account_balance < order.amount_in_per_execution:\n        log DcaOrderFailed(_uid, order.account, \"insufficient balance\")\n        self._cancel_dca_order(_uid, \"insufficient balance\")\n        return\n\n    # ensure self has enough allowance to spend amount token_in\n    account_allowance: uint256 = ERC20(order.token_in).allowance(order.account, self)\n    if account_allowance < order.amount_in_per_execution:\n        log DcaOrderFailed(_uid, order.account, \"insufficient allowance\")\n        self._cancel_dca_order(_uid, \"insufficient allowance\")\n        return\n\n    # transfer token_in from user to self\n    self._safe_transfer_from(order.token_in, order.account, self, order.amount_in_per_execution)\n\n    # approve UNISWAP_ROUTER to spend amount token_in\n    ERC20(order.token_in).approve(UNISWAP_ROUTER, order.amount_in_per_execution)\n\n    # Vyper way to accommodate abi.encode_packed\n    path: Bytes[66] = empty(Bytes[66])\n    if(len(_uni_hop_path) == 2):\n        path = concat(convert(_uni_hop_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_uni_hop_path[1], bytes20))\n    elif(len(_uni_hop_path) == 3):\n        path = concat(convert(_uni_hop_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_uni_hop_path[1], bytes20), convert(_uni_pool_fees[1], bytes3), convert(_uni_hop_path[2], bytes20))\n    \n    min_amount_out: uint256 = self._calc_min_amount_out(order.amount_in_per_execution, _uni_hop_path, _uni_pool_fees, order.twap_length, order.max_slippage)\n\n    uni_params: ExactInputParams = ExactInputParams({\n        path: path,\n        recipient: self,\n        deadline: block.timestamp,\n        amountIn: order.amount_in_per_execution,\n        amountOutMinimum: min_amount_out\n    })\n    amount_out: uint256 = UniswapV3SwapRouter(UNISWAP_ROUTER).exactInput(uni_params)\n\n    # transfer amount_out - fee to user \n    amount_minus_fee: uint256 = amount_out * (FEE_BASE - self.fee) / FEE_BASE\n    self._safe_transfer(order.token_out, order.account, amount_minus_fee)\n\n    # allows searchers to execute for 50% of profits\n    if _share_profit:\n        profit: uint256 = amount_out - amount_minus_fee\n        self._safe_transfer(order.token_out, msg.sender, profit/2)\n    \n    log DcaOrderExecuted(_uid, order.account, order.number_of_executions, order.amount_in_per_execution, amount_minus_fee)\n\n    if order.number_of_executions == order.max_number_of_executions:\n        self._cleanup_order(_uid)\n        log DcaCompleted(_uid, order.account)\n\n\n@view\n@external\ndef calc_min_amount_out(\n    _amount_in: uint256, \n    _path: DynArray[address, 3], \n    _fees: DynArray[uint24, 2], \n    _twap_length: uint32, \n    _max_slippage: uint256\n    ) -> uint256:\n    \n    return self._calc_min_amount_out(_amount_in, _path, _fees, _twap_length, _max_slippage)\n\n\n@view\n@internal\ndef _calc_min_amount_out(\n    _amount_in: uint256, \n    _path: DynArray[address, 3], \n    _fees: DynArray[uint24, 2], \n    _twap_length: uint32, \n    _max_slippage: uint256\n    ) -> uint256:\n\n    uni_fees_total: uint256 = 0\n    for fee in _fees:\n        uni_fees_total += convert(fee, uint256)\n\n    token_in_decimals: uint256 = convert(ERC20Detailed(_path[0]).decimals(), uint256)\n    twap_value: uint256 = Univ3Twap(TWAP).getTwap(_path, _fees, _twap_length)\n\n    min_amount_out: uint256 = _amount_in * PRECISISON \n    min_amount_out = min_amount_out * twap_value\n    min_amount_out = (min_amount_out * (FEE_BASE - uni_fees_total - _max_slippage)) / FEE_BASE\n    min_amount_out = min_amount_out / 10**token_in_decimals\n    min_amount_out = min_amount_out / PRECISISON\n\n    return min_amount_out\n\n\nevent DcaOrderCanceled:\n    uid: bytes32\n    reason: String[32]\n\n@external\ndef cancel_dca_order(_uid: bytes32):\n    order: DcaOrder = self.dca_orders[_uid]\n    assert order.account == msg.sender, \"unauthorized\"\n    self._cancel_dca_order(_uid, \"user canceled\")\n\n@internal\ndef _cancel_dca_order(_uid: bytes32, _reason: String[32]):\n    self._cleanup_order(_uid)\n    log DcaOrderCanceled(_uid, _reason)\n\n\nevent OrderCleanedUp:\n    uid: bytes32\n    account: indexed(address)\n\n@internal\ndef _cleanup_order(_uid: bytes32):\n    order: DcaOrder = self.dca_orders[_uid]\n    self.dca_orders[_uid] = empty(DcaOrder)\n\n    uids: DynArray[bytes32, 1024] = self.dca_order_uids[order.account]\n    for i in range(1024):\n        if uids[i] == _uid:\n            uids[i] = uids[len(uids) - 1]\n            uids.pop()\n            break\n        if i == len(uids)-1:\n            raise\n    self.dca_order_uids[order.account] = uids\n    \n    log OrderCleanedUp(_uid, order.account)\n\n\n@view\n@external\ndef get_all_open_positions(_account: address) -> DynArray[DcaOrder, 1024]:\n    uids: DynArray[bytes32, 1024] = self.dca_order_uids[_account]\n    orders: DynArray[DcaOrder, 1024] = empty(DynArray[DcaOrder, 1024])\n\n    for uid in uids:\n        orders.append(self.dca_orders[uid])\n\n    return orders\n\n\n@external\ndef withdraw_fees(_token: address):\n    amount: uint256 = ERC20(_token).balanceOf(self)\n    assert amount > 0, \"zero balance\"\n\n    ERC20(_token).transfer(self.owner, amount)\n\n\n@internal\ndef _generate_uid() -> bytes32:\n    uid: bytes32 = keccak256(_abi_encode(chain.id, self.position_nonce, block.timestamp))\n    self.position_nonce += 1\n    return uid\n\n\n\n@internal\ndef _safe_transfer(_token: address, _to: address, _amount: uint256) -> bool:\n    res: Bytes[32] = raw_call(\n        _token,\n        concat(\n            method_id(\"transfer(address,uint256)\"),\n            convert(_to, bytes32),\n            convert(_amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(res) > 0:\n        assert convert(res, bool), \"transfer failed\"\n\n    return True\n\n\n@internal\ndef _safe_transfer_from(\n    _token: address, _from: address, _to: address, _amount: uint256\n):\n    res: Bytes[32] = raw_call(\n        _token,\n        concat(\n            method_id(\"transferFrom(address,address,uint256)\"),\n            convert(_from, bytes32),\n            convert(_to, bytes32),\n            convert(_amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(res) > 0:\n        assert convert(res, bool), \"transfer failed\"\n\n\n#############################\n#\n#           ADMIN\n#\n#############################\n\nevent Paused: \n    is_paused: bool\n\n@external\ndef pause(_is_paused: bool):\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _is_paused != self.is_paused, \"already in state\"\n\n    self.is_paused = _is_paused\n    log Paused(_is_paused)\n\n\nevent AcceptingNewOrders: \n    is_accepting_new_orders: bool\n\n@external\ndef set_is_accepting_new_orders(_is_accepting_new_orders: bool):\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _is_accepting_new_orders != self.is_accepting_new_orders, \"already in state\"\n\n    self.is_accepting_new_orders = _is_accepting_new_orders\n    log AcceptingNewOrders(_is_accepting_new_orders)\n\n\nevent NewOwnerSuggested:\n    new_owner: indexed(address)\n    suggested_by: indexed(address)\n\n@external\ndef suggest_owner(_new_owner: address):\n    \"\"\"\n    @notice\n        Step 1 of the 2 step process to transfer ownership.\n        Current owner suggests a new owner.\n        Requires the new owner to accept ownership in step 2.\n    @param _new_owner\n        The address of the new owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _new_owner != empty(address), \"cannot set owner to zero address\"\n    self.suggested_owner = _new_owner\n    log NewOwnerSuggested(_new_owner, msg.sender)\n\n\nevent OwnershipTransferred:\n    new_owner: indexed(address)\n    promoted_by: indexed(address)\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @notice\n        Step 2 of the 2 step process to transfer ownership.\n        The suggested owner accepts the transfer and becomes the\n        new owner.\n    \"\"\"\n    assert msg.sender == self.suggested_owner, \"unauthorized\"\n    prev_owner: address = self.owner\n    self.owner = self.suggested_owner\n    log OwnershipTransferred(self.owner, prev_owner)\n\n\nevent FeeUpdated:\n    new_fee: uint256\n\n@external\ndef set_fee(_fee: uint256):\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _fee < FEE_BASE, \"invalid fee\"\n    assert _fee != self.fee, \"new fee cannot be same as old fee\"\n    self.fee = _fee\n    log FeeUpdated(_fee)"
    },
    {
      "filename": "unstoppable-dex-audit/contracts/spot-dex/LimitOrders.vy",
      "content": "# @version ^0.3.7\n\nfrom vyper.interfaces import ERC20\n\n###################################################################\n#\n# @title Unstoppable Spot DEX - Limit Orders\n# @license GNU AGPLv3\n# @author unstoppable.ooo\n#\n# @custom:security-contact team@unstoppable.ooo\n#\n# @notice\n#    This contract is part of the Unstoppable Spot DEX.\n#    It provides the infrastructure for placing permissionless,\n#    self-custodial limit orders for Uni v3 pairs.\n#\n#    This is an early ALPHA release, use at your own risk!\n#\n###################################################################\n\n\n# struct ExactInputParams {\n#     bytes path;\n#     address recipient;\n#     uint256 deadline;\n#     uint256 amountIn;\n#     uint256 amountOutMinimum;\n# }\nstruct ExactInputParams:\n    path: Bytes[66]\n    recipient: address\n    deadline: uint256\n    amountIn: uint256\n    amountOutMinimum: uint256\n\n\n# function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\ninterface UniswapV3SwapRouter:\n    def exactInput(_params: ExactInputParams) -> uint256: payable\n\n\nUNISWAP_ROUTER: constant(address) = 0xE592427A0AEce92De3Edee1F18E0157C05861564\n\n# owner\nowner: public(address)\nsuggested_owner: public(address)\n\n# Limit Orders\nstruct LimitOrder:\n    uid: bytes32\n    account: address\n    token_in: address\n    token_out: address\n    amount_in: uint256\n    min_amount_out: uint256\n    valid_until: uint256\n\n# user address -> position UID\nlimit_order_uids: public(HashMap[address, DynArray[bytes32, 1024]])\n# UID -> position\nlimit_orders: public(HashMap[bytes32, LimitOrder])\nposition_nonce: uint256\n\nis_paused: public(bool)\nis_accepting_new_orders: public(bool)\n\n@external\ndef __init__():\n    self.owner = msg.sender\n\n\nevent LimitOrderPosted:\n    uid: bytes32\n    token_in: indexed(address)\n    token_out: indexed(address)\n    amount_in: uint256\n    min_amount_out: uint256\n    valid_until: uint256\n    \n@external\ndef post_limit_order(\n        _token_in: address,\n        _token_out: address,\n        _amount_in: uint256,\n        _min_amount_out: uint256,\n        _valid_until: uint256\n    ):\n\n    assert not self.is_paused, \"paused\"\n    assert self.is_accepting_new_orders, \"not accepting new orders\"\n\n    # validate\n    assert _valid_until >= block.timestamp, \"invalid timestamp\"\n\n    # check msg.sender approved contract to spend amount token_in\n    allowance: uint256 = ERC20(_token_in).allowance(msg.sender, self)\n    assert allowance >= _amount_in, \"insufficient allowance\"\n    \n    order: LimitOrder = LimitOrder({\n        uid: empty(bytes32),\n        account: msg.sender,\n        token_in: _token_in,\n        token_out: _token_out,\n        amount_in: _amount_in,\n        min_amount_out: _min_amount_out,\n        valid_until: _valid_until\n    })\n\n    uid: bytes32 = self._generate_uid()\n    order.uid = uid\n\n    self.limit_orders[uid] = order\n    self.limit_order_uids[msg.sender].append(uid)\n\n    log LimitOrderPosted(uid, _token_in, _token_out, _amount_in, _min_amount_out, _valid_until)\n\n\n\nevent LimitOrderExecuted:\n    uid: bytes32\n    account: indexed(address)\n\nevent LimitOrderFailed:\n    uid: bytes32\n    account: indexed(address)\n    reason: String[32]\n\n@external\ndef execute_limit_order(_uid: bytes32, _path: DynArray[address, 3], _uni_pool_fees: DynArray[uint24, 2], _share_profit: bool):\n    assert not self.is_paused, \"paused\"\n\n    order: LimitOrder = self.limit_orders[_uid]\n    # TODO how to clean up expired orders?\n    assert order.valid_until >= block.timestamp, \"order expired\"\n\n    # ensure path is valid\n    assert len(_path) in [2, 3], \"[path] invlid path\"\n    assert len(_uni_pool_fees) == len(_path)-1, \"[path] invalid fees\"\n    assert _path[0] == order.token_in, \"[path] invalid token_in\"\n    assert _path[len(_path)-1] == order.token_out, \"[path] invalid token_out\"\n\n    # ensure user has enough token_in\n    account_balance: uint256 = ERC20(order.token_in).balanceOf(order.account)\n    if account_balance < order.amount_in:\n        log LimitOrderFailed(_uid, order.account, \"insufficient balance\")\n        self._cancel_limit_order(_uid)\n        return\n\n    # ensure self has enough allowance to spend amount token_in\n    account_allowance: uint256 = ERC20(order.token_in).allowance(order.account, self)\n    if account_allowance < order.amount_in:\n        log LimitOrderFailed(_uid, order.account, \"insufficient allowance\")\n        self._cancel_limit_order(_uid)\n        return\n\n    # cleanup storage\n    self._cleanup_order(_uid)\n\n    # transfer token_in from user to self\n    self._safe_transfer_from(order.token_in, order.account, self, order.amount_in)\n\n    # approve UNISWAP_ROUTER to spend amount token_in\n    ERC20(order.token_in).approve(UNISWAP_ROUTER, order.amount_in)\n\n    path: Bytes[66] = empty(Bytes[66])\n    if(len(_path) == 2):\n        path = concat(convert(_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_path[1], bytes20))\n    elif(len(_path) == 3):\n        path = concat(convert(_path[0], bytes20), convert(_uni_pool_fees[0], bytes3), convert(_path[1], bytes20), convert(_uni_pool_fees[1], bytes3), convert(_path[2], bytes20))\n    \n\n    uni_params: ExactInputParams = ExactInputParams({\n        path: path,\n        recipient: self,\n        deadline: block.timestamp,\n        amountIn: order.amount_in,\n        amountOutMinimum: order.min_amount_out\n    })\n    amount_out: uint256 = UniswapV3SwapRouter(UNISWAP_ROUTER).exactInput(uni_params)\n\n    # transfer min_amount_out of token_out from self back to user\n    # anything > min_amount_out stays in contract as profit\n    self._safe_transfer(order.token_out, order.account, order.min_amount_out)\n\n    # allows searchers to execute for 50% of profits\n    if _share_profit:\n        profit: uint256 = amount_out - order.min_amount_out\n        self._safe_transfer(order.token_out, msg.sender, profit/2)\n    \n    log LimitOrderExecuted(_uid, order.account)\n\n\n\nevent LimitOrderCanceled:\n    uid: bytes32\n\n@external\ndef cancel_limit_order(_uid: bytes32):\n    order: LimitOrder = self.limit_orders[_uid]\n    assert order.account == msg.sender, \"unauthorized\"\n    self._cancel_limit_order(_uid)\n\n@internal\ndef _cancel_limit_order(_uid: bytes32):\n    self._cleanup_order(_uid)\n    log LimitOrderCanceled(_uid)\n\n\nevent OrderCleanedUp:\n    uid: bytes32\n    account: indexed(address)\n\n@internal\ndef _cleanup_order(_uid: bytes32):\n    order: LimitOrder = self.limit_orders[_uid]\n    self.limit_orders[_uid] = empty(LimitOrder)\n\n    uids: DynArray[bytes32, 1024] = self.limit_order_uids[order.account]\n    for i in range(1024):\n        if uids[i] == _uid:\n            uids[i] = uids[len(uids) - 1]\n            uids.pop()\n            break\n        if i == len(uids)-1:\n            raise\n    self.limit_order_uids[order.account] = uids\n    \n    log OrderCleanedUp(_uid, order.account)\n\n# TODO def cleanup_exired(_uids: bytes32[])\n\n\n@view\n@external\ndef get_all_open_positions(_account: address) -> DynArray[LimitOrder, 1024]:\n    uids: DynArray[bytes32, 1024] = self.limit_order_uids[_account]\n    orders: DynArray[LimitOrder, 1024] = empty(DynArray[LimitOrder, 1024])\n\n    for uid in uids:\n        orders.append(self.limit_orders[uid])\n\n    return orders\n\n\n@external\ndef withdraw_fees(_token: address):\n    amount: uint256 = ERC20(_token).balanceOf(self)\n    assert amount > 0, \"zero balance\"\n\n    self._safe_transfer(_token, self.owner, amount)\n\n\n@internal\ndef _generate_uid() -> bytes32:\n    uid: bytes32 = keccak256(_abi_encode(chain.id, self.position_nonce, block.timestamp))\n    self.position_nonce += 1\n    return uid\n\n\n@internal\ndef _safe_transfer(_token: address, _to: address, _amount: uint256) -> bool:\n    res: Bytes[32] = raw_call(\n        _token,\n        concat(\n            method_id(\"transfer(address,uint256)\"),\n            convert(_to, bytes32),\n            convert(_amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(res) > 0:\n        assert convert(res, bool), \"transfer failed\"\n\n    return True\n\n\n@internal\ndef _safe_transfer_from(\n    _token: address, _from: address, _to: address, _amount: uint256\n):\n    res: Bytes[32] = raw_call(\n        _token,\n        concat(\n            method_id(\"transferFrom(address,address,uint256)\"),\n            convert(_from, bytes32),\n            convert(_to, bytes32),\n            convert(_amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(res) > 0:\n        assert convert(res, bool), \"transfer failed\"\n\n\n#############################\n#\n#           ADMIN\n#\n#############################\n\nevent Paused: \n    is_paused: bool\n\n@"
    }
  ]
}