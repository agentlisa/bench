{
  "Title": "Insufficient Access Controls",
  "Content": "The `Linea_SpokePool` contract receives cross-chain messages from the HubPool via the [`claimMessage` function](https://github.com/Consensys/linea-contracts/blob/3cf85529fd4539eb06ba998030c37e47f98c528a/contracts/messageService/l2/L2MessageService.sol#L135-L180) of the Linea message service. The function sets the [`sender`](https://github.com/Consensys/linea-contracts/blob/3cf85529fd4539eb06ba998030c37e47f98c528a/contracts/messageService/l2/L2MessageService.sol#L190-L196) for the duration of the call. This might be problematic if the HubPool ever sends a cross-chain message to an attacker-controlled contract on Linea. This is because in this case, the attacker-controlled contract can make calls to `Linea_SpokePool` and bypass the [access controls](https://github.com/UMAprotocol/across-contracts-v2-private/blob/8595081d0edf6aa265fc5e0d04437e9aa07efbcd/contracts/Linea_SpokePool.sol#L238-L240) because the `sender` is set to the HubPool.\n\n\nConsider checking both that `sender` is the HubPool and that the immediate caller is the [Linea message service](https://github.com/UMAprotocol/across-contracts-v2-private/blob/8595081d0edf6aa265fc5e0d04437e9aa07efbcd/contracts/Linea_SpokePool.sol#L93).\n\n\n***Update:** Resolved in [pull request #19](https://github.com/UMAprotocol/across-contracts-v2-private/pull/19/files) at commit [e6bb797](https://github.com/UMAprotocol/across-contracts-v2-private/commit/e6bb797167241fc54689f4fa8c3ed24d99fa01b3).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/messageService/l2/L2MessageService.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.19;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { IMessageService } from \"../../interfaces/IMessageService.sol\";\nimport { IGenericErrors } from \"../../interfaces/IGenericErrors.sol\";\nimport { RateLimiter } from \"../lib/RateLimiter.sol\";\nimport { L2MessageManager } from \"./L2MessageManager.sol\";\n\n/**\n * @title Contract to manage cross-chain messaging on L2.\n * @author ConsenSys Software Inc.\n * @custom:security-contact security-report@linea.build\n */\ncontract L2MessageService is\n  Initializable,\n  RateLimiter,\n  L2MessageManager,\n  ReentrancyGuardUpgradeable,\n  IMessageService,\n  IGenericErrors\n{\n  // Keep free storage slots for future implementation updates to avoid storage collision.\n  // @dev NB: Take note that this is at the beginning of the file where other storage gaps,\n  // are at the end of files. Be careful with how storage is adjusted on upgrades.\n  uint256[50] private __gap_L2MessageService;\n\n  bytes32 public constant MINIMUM_FEE_SETTER_ROLE = keccak256(\"MINIMUM_FEE_SETTER_ROLE\");\n\n  address private _messageSender;\n\n  // @dev initialise to save user cost with existing slot.\n  uint256 public nextMessageNumber;\n\n  // @dev initialise minimumFeeInWei variable.\n  uint256 public minimumFeeInWei;\n\n  // @dev adding these should not affect storage as they are constants and are stored in bytecode.\n  uint256 private constant REFUND_OVERHEAD_IN_GAS = 47500;\n\n  address private constant DEFAULT_SENDER_ADDRESS = address(123456789);\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initialises underlying message service dependencies.\n   * @param _securityCouncil The address owning the security council role.\n   * @param _l1l2MessageSetter The address owning the add L1L2MessageHashes functionality.\n   * @param _rateLimitPeriod The period to rate limit against.\n   * @param _rateLimitAmount The limit allowed for withdrawing the period.\n   */\n  function initialize(\n    address _securityCouncil,\n    address _l1l2MessageSetter,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) public initializer {\n    if (_securityCouncil == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_l1l2MessageSetter == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n    __L2MessageManager_init(_l1l2MessageSetter);\n\n    nextMessageNumber = 1;\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _securityCouncil);\n    _grantRole(MINIMUM_FEE_SETTER_ROLE, _securityCouncil);\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _securityCouncil);\n    _grantRole(PAUSE_MANAGER_ROLE, _securityCouncil);\n\n    _messageSender = DEFAULT_SENDER_ADDRESS;\n  }\n\n  /**\n   * @notice Adds a message for sending cross-chain and emits a relevant event.\n   * @dev The message number is preset and only incremented at the end if successful for the next caller.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _calldata The calldata to pass to the recipient.\n   */\n  function sendMessage(address _to, uint256 _fee, bytes calldata _calldata) external payable {\n    _requireTypeNotPaused(L2_L1_PAUSE_TYPE);\n    _requireTypeNotPaused(GENERAL_PAUSE_TYPE);\n\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 coinbaseFee = minimumFeeInWei;\n\n    if (_fee < coinbaseFee) {\n      revert FeeTooLow();\n    }\n\n    uint256 postmanFee;\n    uint256 valueSent;\n\n    unchecked {\n      postmanFee = _fee - coinbaseFee;\n      valueSent = msg.value - _fee;\n    }\n\n    uint256 messageNumber = nextMessageNumber;\n    /// @dev Rate limit and revert is in the rate limiter.\n    _addUsedAmount(valueSent + postmanFee);\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, postmanFee, valueSent, messageNumber, _calldata));\n\n    nextMessageNumber++;\n\n    (bool success, ) = block.coinbase.call{ value: coinbaseFee }(\"\");\n    if (!success) {\n      revert FeePaymentFailed(block.coinbase);\n    }\n\n    emit MessageSent(msg.sender, _to, postmanFee, valueSent, messageNumber, _calldata, messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev _feeRecipient Can be set to address(0) to receive as msg.sender.\n   * @dev messageSender Is set temporarily when claiming and reset post.\n   * @param _from The address of the original sender.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _value The value to be transferred to the destination address.\n   * @param _feeRecipient The recipient for the fee.\n   * @param _calldata The calldata to pass to the recipient.\n   * @param _nonce The unique auto generated message number used when sending the message.\n   */\n  function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external nonReentrant distributeFees(_fee, _to, _calldata, _feeRecipient) {\n    _requireTypeNotPaused(L1_L2_PAUSE_TYPE);\n    _requireTypeNotPaused(GENERAL_PAUSE_TYPE);\n\n    bytes32 messageHash = keccak256(abi.encode(_from, _to, _fee, _value, _nonce, _calldata));\n\n    /// @dev Status check and revert is in the message manager.\n    _updateL1L2MessageStatusToClaimed(messageHash);\n\n    _messageSender = _from;\n\n    (bool callSuccess, bytes memory returnData) = _to.call{ value: _value }(_calldata);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_to);\n      }\n    }\n\n    _messageSender = DEFAULT_SENDER_ADDRESS;\n    emit MessageClaimed(messageHash);\n  }\n\n  /**\n   * @notice The Fee Manager sets a minimum fee to address DOS protection.\n   * @param _feeInWei New minimum fee in Wei.\n   */\n  function setMinimumFee(uint256 _feeInWei) external onlyRole(MINIMUM_FEE_SETTER_ROLE) {\n    minimumFeeInWei = _feeInWei;\n  }\n\n  /**\n   * @dev The _messageSender address is set temporarily when claiming.\n   * @return _messageSender address.\n   */\n  function sender() external view returns (address) {\n    return _messageSender;\n  }\n\n  /**\n   * @notice Function to receive funds for liquidity purposes.\n   */\n  receive() external payable virtual {}\n\n  /**\n   * @notice The unspent fee is refunded if applicable.\n   * @param _feeInWei The fee paid for delivery in Wei.\n   * @param _to The recipient of the message and gas refund.\n   * @param _calldata The calldata of the message.\n   */\n  modifier distributeFees(\n    uint256 _feeInWei,\n    address _to,\n    bytes calldata _calldata,\n    address _feeRecipient\n  ) {\n    //pre-execution\n    uint256 startingGas = gasleft();\n    _;\n    //post-execution\n\n    // we have a fee\n    if (_feeInWei > 0) {\n      // default postman fee\n      uint256 deliveryFee = _feeInWei;\n\n      // do we have empty calldata?\n      if (_calldata.length == 0) {\n        bool isDestinationEOA;\n\n        assembly {\n          isDestinationEOA := iszero(extcodesize(_to))\n        }\n\n        // are we calling an EOA\n        if (isDestinationEOA) {\n          // initial + cost to call and refund minus gasleft\n          deliveryFee = (startingGas + REFUND_OVERHEAD_IN_GAS - gasleft()) * tx.gasprice;\n\n          if (_feeInWei > deliveryFee) {\n            payable(_to).send(_feeInWei - deliveryFee);\n          } else {\n            deliveryFee = _feeInWei;\n          }\n        }\n      }\n\n      address feeReceiver = _feeRecipient == address(0) ? msg.sender : _feeRecipient;\n\n      bool callSuccess = payable(feeReceiver).send(deliveryFee);\n      if (!callSuccess) {\n        revert FeePaymentFailed(feeReceiver);\n      }\n    }\n  }\n}"
    }
  ]
}