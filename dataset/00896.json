{
  "Title": "M-3: `BalancerWeightedAuraVault.sol` wrongly assumes that all of the weighted pools uses `totalSupply`",
  "Content": "# Issue M-3: `BalancerWeightedAuraVault.sol` wrongly assumes that all of the weighted pools uses `totalSupply` \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/36 \n\n## Found by \nVagner\n## Summary\n`BalancerWeightedAuraVault.sol` which is used specifically for weighted balancer pools wrongly uses `totalSupply` all the time to get the total supply of the pool, but this would not be true for newer weighted pools.\n## Vulnerability Detail\nBalancer pools have different methods to get their total supply of minted LP tokens, which is also specified in the docs here \nhttps://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#getting-bpt-supply .\nThe docs specifies the fact that `totalSupply` is only used for older stable and weighted pools, and should not be used without checking it first, since the newer pools have pre-minted BPT and `getActualSupply` should be used in that case. Most of the time, the assumption would be that only the new composable stable pools uses the `getActualSupply`, but that is not the case, since even the newer weighted pools have and uses the `getActualSupply`. To give you few examples of newer weighted pools that uses `getActualSupply` \nhttps://etherscan.io/address/0x9f9d900462492d4c21e9523ca95a7cd86142f298\nhttps://etherscan.io/address/0x3ff3a210e57cfe679d9ad1e9ba6453a716c56a2e\nhttps://etherscan.io/address/0xcf7b51ce5755513d4be016b0e28d6edeffa1d52a\nthe last one also being on Aura finance. Because of that, the interaction with newer weighted pools and also the future weighted pools would not be accurate since the wrong total supply is used and calculations like `_mintVaultShares` and `_calculateLPTokenValue` would both be inaccurate, which would hurt the protocol and the users.\n## Impact\nImpact is a high one since the calculation of shares and the value of the LP tokens is very important for the protocol, and any miscalculations could hurt the protocol and the users a lot.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/BalancerWeightedAuraVault.sol#L1-L94\n## Tool used\n\nManual Review\n\n## Recommendation\nSince the protocol would want to interact with multiple weighted pools, try to check first if the weighted pool you are interacting with is a newer one and uses the `getActualSupply` or if it is an older one and uses `totalSupply`, in that way the protocol could interact with multiple pools in the long run.\n\n\n\n## Discussion\n\n**jeffywu**\n\nThanks, good finding.\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/69\n\n**gstoyanovbg**\n\nAs I read the report, I left with the impression that the getActualSupply function should be used because there is some amount of pre-minted BPT tokens. However, this is not true in the case of weighted pools. In those cases, we don't have pre-minted tokens, and consequently, there is no virtual supply. This is evident from the links to the contracts provided in the description. This is the code of the getActualSupply function.\n\n```solidity\n    /**\n     * @notice Returns the effective BPT supply.\n     *\n     * @dev This would be the same as `totalSupply` however the Pool owes debt to the Protocol in the form of unminted\n     * BPT, which will be minted immediately before the next join or exit. We need to take these into account since,\n     * even if they don't yet exist, they will effectively be included in any Pool operation that involves BPT.\n     *\n     * In the vast majority of cases, this function should be used instead of `totalSupply()`.\n     *\n     * **IMPORTANT NOTE**: calling this function within a Vault context (i.e. in the middle of a join or an exit) is\n     * potentially unsafe, since the returned value is manipulable. It is up to the caller to ensure safety.\n     *\n     * This is because this function calculates the invariant, which requires the state of the pool to be in sync\n     * with the state of the Vault. That condition may not be true in the middle of a join or an exit.\n     *\n     * To call this function safely, attempt to trigger the reentrancy guard in the Vault by calling a non-reentrant\n     * function before calling `getActualSupply`. That will make the transaction revert in an unsafe context.\n     * (See `whenNotInVaultContext` in `WeightedPool`).\n     *\n     * See https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345 for reference.\n     */\n    function getActualSupply() external view returns (uint256) {\n        uint256 supply = totalSupply();\n\n        (uint256 protocolFeesToBeMinted, ) = _getPreJoinExitProtocolFees(\n            getInvariant(),\n            _getNormalizedWeights(),\n            supply\n        );\n\n        return supply.add(protocolFeesToBeMinted);\n    }\n```\n\nFrom the comment, it is apparent that this function should be used because the pool owes debt to the Protocol in the form of unminted BPT, which should be taken into consideration. Despite the incorrect reason, I agree that getActualSupply should be used instead of totalSupply. I'm not entirely sure about the impact, and I won't comment on it. I'm writing this comment because the report will be read by people after the contest, and they would receive incorrect information.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/BalancerWeightedAuraVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {BalancerSpotPrice} from \"./balancer/BalancerSpotPrice.sol\";\nimport {\n    AuraStakingMixin,\n    AuraVaultDeploymentParams,\n    DeploymentParams\n} from \"./balancer/mixins/AuraStakingMixin.sol\";\nimport {IComposablePool} from \"../../interfaces/balancer/IBalancerPool.sol\";\nimport {IBalancerVault} from \"../../interfaces/balancer/IBalancerVault.sol\";\n\ncontract BalancerWeightedAuraVault is AuraStakingMixin {\n    /// @notice Helper singleton contract for calculating spot prices\n    BalancerSpotPrice immutable SPOT_PRICE;\n\n    constructor(\n        NotionalProxy notional_,\n        AuraVaultDeploymentParams memory params,\n        BalancerSpotPrice _spotPrice\n    ) AuraStakingMixin(notional_, params) {\n        // BPT_INDEX is not defined for WeightedPool\n        require(BPT_INDEX == NOT_FOUND);\n        // Only two token pools are supported\n        require(NUM_TOKENS() == 2);\n        SPOT_PRICE = _spotPrice;\n    }\n\n    /// @notice strategy identifier\n    function strategy() external override pure returns (bytes4) {\n        return bytes4(keccak256(\"BalancerWeightedAuraVault\"));\n    }\n\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal override returns (uint256 lpTokens) {\n        bytes memory customData = abi.encode(\n            IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amounts,\n            minPoolClaim\n        );\n\n        lpTokens = _joinPoolExactTokensIn(amounts, customData);\n\n        // Transfer token to Aura protocol for boosted staking\n        bool success = AURA_BOOSTER.deposit(AURA_POOL_ID, lpTokens, true);\n        require(success);\n    }\n\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal override returns (uint256[] memory exitBalances) {\n        bool success = AURA_REWARD_POOL.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n        require(success);\n\n        bytes memory customData;\n        if (isSingleSided) {\n            uint256 primaryIndex = PRIMARY_INDEX();\n            customData = abi.encode(\n                IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n                poolClaim,\n                primaryIndex\n            );\n        } else {\n            customData = abi.encode(\n                IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                poolClaim\n            );\n        }\n\n        exitBalances = _exitPoolExactBPTIn(minAmounts, customData);\n    }\n \n    function _checkPriceAndCalculateValue() internal view override returns (uint256) {\n        (/* */, uint8[] memory decimals) = TOKENS();\n\n        (uint256[] memory balances, uint256[] memory spotPrices) = SPOT_PRICE.getWeightedSpotPrices(\n            BALANCER_POOL_ID,\n            address(BALANCER_POOL_TOKEN),\n            PRIMARY_INDEX(),\n            decimals[PRIMARY_INDEX()]\n        );\n\n        // Spot prices are returned in native decimals, convert them all to POOL_PRECISION\n        // as required in the _calculateLPTokenValue method.\n        for (uint256 i; i < spotPrices.length; i++) {\n            spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n        }\n\n        return _calculateLPTokenValue(balances, spotPrices);\n    }\n}"
    }
  ]
}