{
  "Title": "[M-27] Inconsistent behavior for canary claims in the `claimer`",
  "Content": "\n### Proof of Concept\n\nWhenever a `claimer` claims prizes they compute fees per `claim` without considering canary claims.\n\n```solidity\n  function claimPrizes(\n    Vault vault,\n    uint8 tier,\n    address[] calldata winners,\n    uint32[][] calldata prizeIndices,\n    address _feeRecipient\n  ) external returns (uint256 totalFees) {\n    uint256 claimCount;\n    for (uint i = 0; i < winners.length; i++) {\n      claimCount += prizeIndices[i].length;\n    }\n\n    uint96 feePerClaim = uint96(\n      _computeFeePerClaim(\n        _computeMaxFee(tier, prizePool.numberOfTiers()),\n        claimCount,\n        prizePool.claimCount()\n      )\n    );\n\n    vault.claimPrizes(tier, winners, prizeIndices, feePerClaim, _feeRecipient);\n\n    return feePerClaim * claimCount;\n  }\n```\n\n[src/Claimer.sol#L76](https://github.com/GenerationSoftware/pt-v5-claimer/blob/57a381aef690a27c9198f4340747155a71cae753/src/Claimer.sol#L76)\n\n### Recommended Mitigation Steps\n\nConsider canary as a `claim`.\n\n```diff\n    uint96 feePerClaim = uint96(\n      _computeFeePerClaim(\n        _computeMaxFee(tier, prizePool.numberOfTiers()),\n        claimCount,\n-        prizePool.claimCount()\n+        prizePool.claimCount() + prizePool.canaryClaimCount()\n      )\n    );\n\n```\n\n### Assessed type\n\nError\n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/61#issuecomment-1641093811)**\n\n**[PoolTogether mitigated](https://github.com/code-423n4/2023-08-pooltogether-mitigation#individual-prs):**\n> Unified standard and canary tier.<br>\n> PR: https://github.com/GenerationSoftware/pt-v5-prize-pool/pull/17\n\n**Status**: Mitigation confirmed. Full details in report from [rvierdiiev](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/66), [dirk\\_y](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/103) and [0xStalin](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/94).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-pooltogether",
  "Code": [
    {
      "filename": "src/Claimer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { SD59x18 } from \"prb-math/SD59x18.sol\";\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { UD60x18 } from \"prb-math/UD60x18.sol\";\nimport { PrizePool } from \"v5-prize-pool/PrizePool.sol\";\nimport { Multicall } from \"openzeppelin/utils/Multicall.sol\";\n\nimport { LinearVRGDALib } from \"./libraries/LinearVRGDALib.sol\";\nimport { Vault } from \"v5-vault/Vault.sol\";\n\n/// @title Variable Rate Gradual Dutch Auction (VRGDA) Claimer\n/// @author PoolTogether Inc. Team\n/// @notice This contract uses a variable rate gradual dutch auction to inventivize prize claims on behalf of others\ncontract Claimer is Multicall {\n  /// @notice The Prize Pool that this Claimer is claiming prizes for\n  PrizePool public immutable prizePool;\n\n  /// @notice The maximum fee that can be charged as a portion of the smallest prize size. Fixed point 18 number\n  UD2x18 public immutable maxFeePortionOfPrize;\n\n  /// @notice The VRGDA decay constant computed in the constructor\n  SD59x18 public immutable decayConstant;\n\n  /// @notice The minimum fee that will be charged\n  uint256 public immutable minimumFee;\n\n  uint256 public immutable timeToReachMaxFee;\n\n  /// @notice Constructs a new Claimer\n  /// @param _prizePool The prize pool to claim for\n  /// @param _minimumFee The minimum fee that should be charged\n  /// @param _maximumFee The maximum fee that should be charged\n  /// @param _timeToReachMaxFee The time it should take to reach the maximum fee (for example should be the draw period in seconds)\n  /// @param _maxFeePortionOfPrize The maximum fee that can be charged as a portion of the smallest prize size. Fixed point 18 number\n  constructor(\n    PrizePool _prizePool,\n    uint256 _minimumFee,\n    uint256 _maximumFee,\n    uint256 _timeToReachMaxFee,\n    UD2x18 _maxFeePortionOfPrize\n  ) {\n    prizePool = _prizePool;\n    maxFeePortionOfPrize = _maxFeePortionOfPrize;\n    decayConstant = LinearVRGDALib.getDecayConstant(\n      LinearVRGDALib.getMaximumPriceDeltaScale(_minimumFee, _maximumFee, _timeToReachMaxFee)\n    );\n    minimumFee = _minimumFee;\n    timeToReachMaxFee = _timeToReachMaxFee;\n  }\n\n  /// @notice Allows the call to claim prizes on behalf of others.\n  /// @param vault The vault to claim from\n  /// @param tier The tier to claim for\n  /// @param winners The array of winners to claim for\n  /// @param prizeIndices The array of prize indices to claim for each winner (length should match winners)\n  /// @param _feeRecipient The address to receive the claim fees\n  /// @return totalFees The total fees collected across all successful claims\n  function claimPrizes(\n    Vault vault,\n    uint8 tier,\n    address[] calldata winners,\n    uint32[][] calldata prizeIndices,\n    address _feeRecipient\n  ) external returns (uint256 totalFees) {\n    uint256 claimCount;\n    for (uint i = 0; i < winners.length; i++) {\n      claimCount += prizeIndices[i].length;\n    }\n\n    uint96 feePerClaim = uint96(\n      _computeFeePerClaim(\n        _computeMaxFee(tier, prizePool.numberOfTiers()),\n        claimCount,\n        prizePool.claimCount()\n      )\n    );\n\n    vault.claimPrizes(tier, winners, prizeIndices, feePerClaim, _feeRecipient);\n\n    return feePerClaim * claimCount;\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @return The total fees for those claims\n  function computeTotalFees(uint8 _tier, uint _claimCount) external view returns (uint256) {\n    return\n      _computeFeePerClaim(\n        _computeMaxFee(_tier, prizePool.numberOfTiers()),\n        _claimCount,\n        prizePool.claimCount()\n      ) * _claimCount;\n  }\n\n  /// @notice Computes the total fees for the given number of claims if a number of claims have already been made.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for those claims\n  function computeTotalFees(\n    uint8 _tier,\n    uint _claimCount,\n    uint _claimedCount\n  ) external view returns (uint256) {\n    return\n      _computeFeePerClaim(\n        _computeMaxFee(_tier, prizePool.numberOfTiers()),\n        _claimCount,\n        _claimedCount\n      ) * _claimCount;\n  }\n\n  /// @notice Computes the fees for several claims.\n  /// @param _maxFee the maximum fee that can be charged\n  /// @param _claimCount the number of claims to check\n  /// @return The fees for the claims\n  function computeFeePerClaim(uint256 _maxFee, uint _claimCount) external view returns (uint256) {\n    return _computeFeePerClaim(_maxFee, _claimCount, prizePool.claimCount());\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _maxFee The maximum fee\n  /// @param _claimCount The number of claims to check\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for the claims\n  function _computeFeePerClaim(\n    uint256 _maxFee,\n    uint _claimCount,\n    uint _claimedCount\n  ) internal view returns (uint256) {\n    if (_claimCount == 0) {\n      return 0;\n    }\n    SD59x18 perTimeUnit = LinearVRGDALib.getPerTimeUnit(\n      prizePool.estimatedPrizeCount(),\n      timeToReachMaxFee\n    );\n    uint256 elapsed = block.timestamp - (prizePool.lastClosedDrawAwardedAt());\n    uint256 fee;\n\n    for (uint i = 0; i < _claimCount; i++) {\n      fee += _computeFeeForNextClaim(\n        minimumFee,\n        decayConstant,\n        perTimeUnit,\n        elapsed,\n        _claimedCount + i,\n        _maxFee\n      );\n    }\n\n    return fee / _claimCount;\n  }\n\n  /// @notice Computes the maximum fee that can be charged.\n  /// @param _tier The tier to compute the max fee for\n  /// @return The maximum fee that can be charged\n  function computeMaxFee(uint8 _tier) public view returns (uint256) {\n    return _computeMaxFee(_tier, prizePool.numberOfTiers());\n  }\n\n  /// @notice Computes the max fee given the tier and number of tiers.\n  /// @param _tier The tier to compute the max fee for\n  /// @param _numTiers The total number of tiers\n  /// @return The maximum fee that will be charged for a prize claim for the given tier\n  function _computeMaxFee(uint8 _tier, uint8 _numTiers) internal view returns (uint256) {\n    uint8 _canaryTier = _numTiers - 1;\n    if (_tier != _canaryTier) {\n      // canary tier\n      return _computeMaxFee(prizePool.getTierPrizeSize(_canaryTier - 1));\n    } else {\n      return _computeMaxFee(prizePool.getTierPrizeSize(_canaryTier));\n    }\n  }\n\n  /// @notice Computes the maximum fee that can be charged.\n  /// @param _prize The prize to compute the max fee for\n  /// @return The maximum fee that can be charged\n  function _computeMaxFee(uint256 _prize) internal view returns (uint256) {\n    // compute the maximum fee that can be charged\n    return UD60x18.unwrap(maxFeePortionOfPrize.intoUD60x18().mul(UD60x18.wrap(_prize)));\n  }\n\n  /// @notice Computes the fee for the next claim.\n  /// @param _minimumFee The minimum fee that should be charged\n  /// @param _decayConstant The VRGDA decay constant\n  /// @param _perTimeUnit The num to be claimed per second\n  /// @param _elapsed The number of seconds that have elapsed\n  /// @param _sold The number of prizes that were claimed\n  /// @param _maxFee The maximum fee that can be charged\n  /// @return The fee to charge for the next claim\n  function _computeFeeForNextClaim(\n    uint256 _minimumFee,\n    SD59x18 _decayConstant,\n    SD59x18 _perTimeUnit,\n    uint256 _elapsed,\n    uint256 _sold,\n    uint256 _maxFee\n  ) internal pure returns (uint256) {\n    uint256 fee = LinearVRGDALib.getVRGDAPrice(\n      _minimumFee,\n      _elapsed,\n      _sold,\n      _perTimeUnit,\n      _decayConstant\n    );\n    return fee > _maxFee ? _maxFee : fee;\n  }\n}"
    }
  ]
}