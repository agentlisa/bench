{
  "Title": "H-1: UserManager's cancelVouchInternal breaks up voucher accounting on voucher removal",
  "Content": "# Issue H-1: UserManager's cancelVouchInternal breaks up voucher accounting on voucher removal \n\nSource: https://github.com/sherlock-audit/2023-02-union-judging/issues/41 \n\n## Found by \nhyh, seyni\n\n## Summary\n\n_cancelVouchInternal() doesn't update `voucherIndices` array and incorrectly updates `vouchees` array (using `voucherIndexes` for `vouchees`, which are unrelated index-wise), messing up the vouchers accounting as a result.\n\n## Vulnerability Detail\n\nCurrently _cancelVouchInternal() gets voucher array index from `voucherIndexes`, name it `voucheeIdx` and apply to `vouchees`, which isn't correct as those are different arrays, their indices are independent, so such addressing messes up the accounting data.\n\nAlso, proper update isn't carried out for voucher indices themselves, although it is required for the future referencing which is used in all voucher related activities of the protocol.\n\n## Impact\n\nImmediate impact is unavailability of vouch accounting logic for the borrower-staker combination that was this last element cancelVouch() moved.\n\nFurthermore, if a new entry is placed, which is a high probability event being a part of normal activity, then old entry will point to incorrect staked/locked amount, and a various violations of the related constrains become possible.\n\nSome examples are: trust can be updated via updateTrust() to be less then real locked amount; vouch cancellation can become blocked (say new voucher borrower gains a long-term lock and old lock with misplaced index cannot be cancelled until new lock be fully cleared, i.e. potentially for a long time).\n\nThe total impact is up to freezing the corresponding staker's funds as this opens up a way for various exploitations, for example a old entry's borrower can use the situation of unremovable trust and utilize this trust that staker would remove in a normal course of operations, locking extra funds of the staker this way.\n\nThe whole issue is a violation of the core UNION vouch accounting logic, with misplaced indices potentially piling up. Placing overall severity to be high.\n\n## Code Snippet\n\n_cancelVouchInternal() correctly treats `vouchee` entry removal update, but fails to do the same for `vouchers` case (first in the code):\n\nhttps://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L583-L620\n\n```solidity\n    function _cancelVouchInternal(address staker, address borrower) internal {\n        Index memory removeVoucherIndex = voucherIndexes[borrower][staker];\n        if (!removeVoucherIndex.isSet) revert VoucherNotFound();\n\n        // Check that the locked amount for this vouch is 0\n        Vouch memory vouch = vouchers[borrower][removeVoucherIndex.idx];\n        if (vouch.locked > 0) revert LockedStakeNonZero();\n\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        {\n            // Cache the last voucher\n            Vouch memory lastVoucher = vouchers[borrower][vouchers[borrower].length - 1];\n            // Move the lastVoucher to the index of the voucher we are removing\n            vouchers[borrower][removeVoucherIndex.idx] = lastVoucher;\n            // Pop the last vouch off the end of the vouchers array\n            vouchers[borrower].pop();\n            // Delete the voucher index for this borrower => staker pair\n            delete voucherIndexes[borrower][staker];\n            // Update the last vouchers coresponsing Vouchee item\n            uint128 voucheeIdx = voucherIndexes[borrower][lastVoucher.staker].idx;\n            vouchees[staker][voucheeIdx].voucherIndex = removeVoucherIndex.idx.toUint96();\n        }\n\n        // Update the vouchee entry for this borrower => staker pair\n        {\n            Index memory removeVoucheeIndex = voucheeIndexes[borrower][staker];\n            // Cache the last vouchee\n            Vouchee memory lastVouchee = vouchees[staker][vouchees[staker].length - 1];\n            // Move the last vouchee to the index of the removed vouchee\n            vouchees[staker][removeVoucheeIndex.idx] = lastVouchee;\n            // Pop the last vouchee off the end of the vouchees array\n            vouchees[staker].pop();\n            // Delete the vouchee index for this borrower => staker pair\n            delete voucheeIndexes[borrower][staker];\n            // Update the vouchee indexes to the new vouchee index\n            voucheeIndexes[lastVouchee.borrower][staker].idx = removeVoucheeIndex.idx;\n        }\n```\n\nNamely, `voucherIndexes` to be updated as `lastVoucher` has been moved and entries for its old position to be corrected on the spot. `vouchees` to be updated as well, but using correct `voucheeIndexes` index reference.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider setting both `voucherIndexes` and `vouchees` items for the last staker:\n\nhttps://github.com/sherlock-audit/2023-02-union/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L591-L605\n\n```solidity\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        {\n            // Cache the last voucher\n            Vouch memory lastVoucher = vouchers[borrower][vouchers[borrower].length - 1];\n            // Move the lastVoucher to the index of the voucher we are removing\n            vouchers[borrower][removeVoucherIndex.idx] = lastVoucher;\n            // Pop the last vouch off the end of the vouchers array\n            vouchers[borrower].pop();\n            // Delete the voucher index for this borrower => staker pair\n            delete voucherIndexes[borrower][staker];\n-           // Update the last vouchers coresponsing Vouchee item\n-           uint128 voucheeIdx = voucherIndexes[borrower][lastVoucher.staker].idx;\n-           vouchees[staker][voucheeIdx].voucherIndex = removeVoucherIndex.idx.toUint96();\n+           // Update the last vouchers coresponsing Vouchee item\n+           vouchees[lastVoucher.staker][voucheeIndexes[borrower][lastVoucher.staker]].voucherIndex = removeVoucherIndex.idx.toUint96();\n+           // Update the voucher indexes of the moved pair to the new voucher index\n+           voucherIndexes[borrower][lastVoucher.staker].idx = removeVoucherIndex.idx;\n        }\n```\n\n## Discussion\n\n**kingjacob**\n\nIs this not also a dupe of #4 ?\n\n**dmitriia**\n\n> Is this not also a dupe of #4 ?\n\n#4 and #39 look to be partial reports of the #41/#31 issue, which basically has 2 parts.\n\n#4 says '`vouchees[staker][voucheeIdx].voucherIndex = removeVoucherIndex.idx.toUint96()` doesn't look to be correct', not seeing the original `voucherIndexes` issue and not suggesting the proper fix for the `vouchees` one.\n\n#39, on the other hand, only observes and suggests the fix for the `voucherIndexes` part, failing to notice the `vouchees` issue.\n\nThe most correct way to reflect this, as I see it, is to mark #4 and #39 as Mediums and non-dups as they are pointing to the not really related issues.\n\n#41/#31 looks to be full dups and High as both investigate the situation fully (as I see it at the moment), providing fixes for the both parts.\n\n**hrishibhat**\n\n@kingjacob \nAgree with the @dmitriia . \nConsidering #4 & #39 as separate mediums. \n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/44",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/user/UserManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IUnionToken} from \"../interfaces/IUnionToken.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\n/**\n * @title UserManager Contract\n * @dev Manages the Union members stake and vouches.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeCastUpgradeable for uint256;\n    using SafeCastUpgradeable for uint128;\n\n    /* -------------------------------------------------------------------\n      Storage Types \n    ------------------------------------------------------------------- */\n\n    struct Vouch {\n        // staker recieveing the vouch\n        address staker;\n        // trust amount\n        uint96 trust;\n        // amount of stake locked by this vouch\n        uint96 locked;\n        // block number of last update\n        uint64 lastUpdated;\n    }\n\n    struct Staker {\n        bool isMember;\n        uint96 stakedAmount;\n        uint96 locked;\n        // block number of last stakedAmount update\n        uint64 lastUpdated;\n        uint256 stakedCoinAge;\n        uint256 lockedCoinAge;\n    }\n\n    struct Index {\n        bool isSet;\n        uint128 idx;\n    }\n\n    struct Vouchee {\n        address borrower;\n        uint96 voucherIndex;\n    }\n\n    /* -------------------------------------------------------------------\n      Memory Types \n    ------------------------------------------------------------------- */\n\n    struct CoinAge {\n        uint256 stakedCoinAge;\n        uint256 lockedCoinAge;\n        uint256 frozenCoinAge;\n        uint256 lastWithdrawRewards;\n        uint256 diff;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Max amount that can be staked of the staking token\n     */\n    uint96 public maxStakeAmount;\n\n    /**\n     *  @dev The staking token that is staked in the comptroller\n     */\n    address public stakingToken;\n\n    /**\n     *  @dev Address of the UNION token contract\n     */\n    address public unionToken;\n\n    /**\n     *  @dev Address of the asset manager contract\n     */\n    address public assetManager;\n\n    /**\n     *  @dev uToken contract\n     */\n    IUToken public uToken;\n\n    /**\n     *  @dev Comptroller contract\n     */\n    IComptroller public comptroller;\n\n    /**\n     * @dev Number of vouches needed to become a member\n     */\n    uint256 public effectiveCount;\n\n    /**\n     *  @dev New member fee\n     */\n    uint256 public newMemberFee;\n\n    /**\n     *  @dev Total amount of staked staked token\n     */\n    uint256 public totalStaked;\n\n    /**\n     *  @dev Total amount of stake frozen\n     */\n    uint256 public totalFrozen;\n\n    /**\n     *  @dev Max blocks can be overdue for\n     */\n    uint256 public maxOverdueBlocks;\n\n    /**\n     * @dev Max voucher limit\n     */\n    uint256 public maxVouchers;\n\n    /**\n     * @dev Max vouchees limit\n     */\n    uint256 public maxVouchees;\n\n    /**\n     *  @dev Union Stakers\n     */\n    mapping(address => Staker) public stakers;\n\n    /**\n     *  @dev Borrower (borrower) mapped to received vouches (staker)\n     */\n    mapping(address => Vouch[]) public vouchers;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vouchers array\n     */\n    mapping(address => mapping(address => Index)) public voucherIndexes;\n\n    /**\n     *  @dev Staker (staker) mapped to vouches given (borrower)\n     */\n    mapping(address => Vouchee[]) public vouchees;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vochee array\n     */\n    mapping(address => mapping(address => Index)) public voucheeIndexes;\n\n    /**\n     * @dev Stakers frozen amounts\n     */\n    mapping(address => uint256) public memberFrozen;\n\n    /**\n     * @dev Stakers mapped to frozen coin age\n     */\n    mapping(address => uint256) public frozenCoinAge;\n\n    /**\n     * @dev Staker mapped to last time they withdrew rewards\n     */\n    mapping(address => uint256) public getLastWithdrawRewards;\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error AuthFailed();\n    error ErrorSelfVouching();\n    error TrustAmountLtLocked();\n    error NoExistingMember();\n    error NotEnoughStakers();\n    error StakeLimitReached();\n    error AssetManagerDepositFailed();\n    error AssetManagerWithdrawFailed();\n    error InsufficientBalance();\n    error LockedStakeNonZero();\n    error NotOverdue();\n    error ExceedsLocked();\n    error AmountZero();\n    error LockedRemaining();\n    error VoucherNotFound();\n    error VouchWhenOverdue();\n    error MaxVouchers();\n    error MaxVouchees();\n    error InvalidParams();\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Add new member event\n     *  @param member New member address\n     */\n    event LogAddMember(address member);\n\n    /**\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /**\n     *  @dev New member application event\n     *  @param account New member's voucher address\n     *  @param borrower New member address\n     */\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Cancel vouching for other member event\n     *  @param account New member's voucher address\n     *  @param borrower The address gets vouched for\n     */\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Stake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev Unstake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to unstake\n     */\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev DebtWriteOff event\n     *  @param staker The staker's address\n     *  @param borrower The borrower's address\n     *  @param amount The amount of write off\n     */\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    /**\n     *  @dev set utoken address\n     *  @param uToken new uToken address\n     */\n    event LogSetUToken(address uToken);\n\n    /**\n     *  @dev set new member fee\n     *  @param oldMemberFee old member fee\n     *  @param newMemberFee new member fee\n     */\n    event LogSetNewMemberFee(uint256 oldMemberFee, uint256 newMemberFee);\n\n    /**\n     *  @dev set max stake amount\n     *  @param oldMaxStakeAmount Old amount\n     *  @param newMaxStakeAmount New amount\n     */\n    event LogSetMaxStakeAmount(uint256 oldMaxStakeAmount, uint256 newMaxStakeAmount);\n\n    /**\n     *  @dev set max overdue blocks\n     *  @param oldMaxOverdueBlocks Old value\n     *  @param newMaxOverdueBlocks New value\n     */\n    event LogSetMaxOverdueBlocks(uint256 oldMaxOverdueBlocks, uint256 newMaxOverdueBlocks);\n\n    /**\n     *  @dev set effective count\n     *  @param oldEffectiveCount Old value\n     *  @param newEffectiveCount New value\n     */\n    event LogSetEffectiveCount(uint256 oldEffectiveCount, uint256 newEffectiveCount);\n\n    /**\n     * @dev Set max voucher\n     * @param maxVouchers new max voucher limit\n     */\n    event LogSetMaxVouchers(uint256 maxVouchers);\n\n    /**\n     * @dev Set max vouchees\n     * @param maxVouchees new max voucher limit\n     */\n    event LogSetMaxVouchees(uint256 maxVouchees);\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address comptroller_,\n        address admin_,\n        uint256 maxOverdueBlocks_,\n        uint256 effectiveCount_,\n        uint256 maxVouchers_,\n        uint256 maxVouchees_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1 ether;\n        maxStakeAmount = 10_000e18;\n        maxOverdueBlocks = maxOverdueBlocks_;\n        effectiveCount = effectiveCount_;\n        maxVouchers = maxVouchers_;\n        maxVouchees = maxVouchees_;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyMember(address account) {\n        if (!checkIsMember(account)) revert AuthFailed();\n        _;\n    }\n\n    modifier onlyMarket() {\n        if (address(uToken) != msg.sender) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the max amount that a user can stake\n     * Emits {LogSetMaxStakeAmount} event\n     * @param maxStakeAmount_ The max stake amount\n     */\n    function setMaxStakeAmount(uint96 maxStakeAmount_) external onlyAdmin {\n        uint96 oldMaxStakeAmount = maxStakeAmount;\n        maxStakeAmount = maxStakeAmount_;\n        emit LogSetMaxStakeAmount(uint256(oldMaxStakeAmount), uint256(maxStakeAmount));\n    }\n\n    /**\n     * @dev set the UToken contract address\n     * Emits {LogSetUToken} event\n     * @param uToken_ UToken contract address\n     */\n    function setUToken(address uToken_) external onlyAdmin {\n        uToken = IUToken(uToken_);\n        emit LogSetUToken(uToken_);\n    }\n\n    /**\n     * @dev set New Member fee\n     * @dev The amount of UNION an account must burn to become a member\n     * Emits {LogSetNewMemberFee} event\n     * @param amount New member fee amount\n     */\n    function setNewMemberFee(uint256 amount) external onlyAdmin {\n        uint256 oldMemberFee = newMemberFee;\n        newMemberFee = amount;\n        emit LogSetNewMemberFee(oldMemberFee, amount);\n    }\n\n    /**\n     * @dev set New max overdue blocks\n     * Emits {LogSetMaxOverdueBlocks} event\n     * @param _maxOverdueBlocks New maxOverdueBlocks value\n     */\n    function setMaxOverdueBlocks(uint256 _maxOverdueBlocks) external onlyAdmin {\n        uint256 oldMaxOverdueBlocks = maxOverdueBlocks;\n        maxOverdueBlocks = _maxOverdueBlocks;\n        emit LogSetMaxOverdueBlocks(oldMaxOverdueBlocks, _maxOverdueBlocks);\n    }\n\n    /**\n     * @dev set New effective count\n     * @dev this is the number of vouches an account needs in order\n     *      to register as a member\n     * Emits {LogSetEffectiveCount} event\n     * @param _effectiveCount New effectiveCount value\n     */\n    function setEffectiveCount(uint256 _effectiveCount) external onlyAdmin {\n        uint256 oldEffectiveCount = effectiveCount;\n        effectiveCount = _effectiveCount;\n        emit LogSetEffectiveCount(oldEffectiveCount, _effectiveCount);\n    }\n\n    function setMaxVouchers(uint256 _maxVouchers) external onlyAdmin {\n        maxVouchers = _maxVouchers;\n        emit LogSetMaxVouchers(_maxVouchers);\n    }\n\n    function setMaxVouchees(uint256 _maxVouchees) external onlyAdmin {\n        maxVouchees = _maxVouchees;\n        emit LogSetMaxVouchees(_maxVouchees);\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     */\n    function checkIsMember(address account) public view returns (bool) {\n        return stakers[account].isMember;\n    }\n\n    /**\n     *  @dev  Get the member's available credit limit\n     *  @dev  IMPORTANT: This function can take up a tonne of gas as the vouchers[address] array\n     *        grows in size. the maxVoucher limit will ensure this function can always run within a\n     *        single block but it is intended only to be used as a view function called from a UI\n     *  @param borrower Member address\n     *  @return total Credit line amount\n     */\n    function getCreditLimit(address borrower) external view returns (uint256 total) {\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch memory vouch = vouchers[borrower][i];\n            Staker memory staker = stakers[vouch.staker];\n            total += _min(staker.stakedAmount - staker.locked, vouch.trust - vouch.locked);\n        }\n    }\n\n    /**\n     *  @dev  Get the count of vouchers\n     *        Vouchers are addresses that this borrower is receiving a vouch from.\n     *  @param borrower Address of borrower\n     */\n    function getVoucherCount(address borrower) external view returns (uint256) {\n        return vouchers[borrower].length;\n    }\n\n    /**\n     *  @dev  Get the count of vouchees\n     *        Vouchers are addresses that this staker is vouching for\n     *  @param staker Address of staker\n     */\n    function getVoucheeCount(address staker) external view returns (uint256) {\n        return vouchees[staker].length;\n    }\n\n    /**\n     *  @dev Get the user's deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) external view returns (uint256) {\n        return stakers[account].stakedAmount;\n    }\n\n    /**\n     *  @dev Get Total locked stake\n     *  @param staker Staker address\n     */\n    function getTotalLockedStake(address staker) external view returns (uint256) {\n        return stakers[staker].locked;\n    }\n\n    /**\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     */\n    function getLockedStake(address staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][staker];\n        if (!index.isSet) return 0;\n        return vouchers[borrower][index.idx].locked;\n    }\n\n    /**\n     *  @dev Get vouching amount\n     *  @param _staker Staker address\n     *  @param borrower Borrower address\n     */\n    function getVouchingAmount(address _staker, address borrower) external view returns (uint256) {\n        Index memory index = voucherIndexes[borrower][_staker];\n        Staker memory staker = stakers[_staker];\n        if (!index.isSet) return 0;\n        uint96 trustAmount = vouchers[borrower][index.idx].trust;\n        return trustAmount < staker.stakedAmount ? trustAmount : staker.stakedAmount;\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Manually add union members and bypass all the requirements of `registerMember`\n     *  Only accepts calls from the admin\n     *  Emit {LogAddMember} event\n     *  @param account Member address\n     */\n    function addMember(address account) external onlyAdmin {\n        stakers[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /**\n     *  @dev  Update the trust amount for existing members.\n     *  @dev  Trust is the amount of the underlying token you would in theory be\n     *        happy to lend to another member. Vouch is derived from trust and stake.\n     *        Vouch is the minimum of trust and staked amount.\n     *  Emits {LogUpdateTrust} event\n     *  @param borrower Account address\n     *  @param trustAmount Trust amount\n     */\n    function updateTrust(address borrower, uint96 trustAmount) external onlyMember(msg.sender) whenNotPaused {\n        address staker = msg.sender;\n        if (borrower == staker) revert ErrorSelfVouching();\n\n        // Check if this staker is already vouching for this borrower\n        // If they are already vouching then update the existing vouch record\n        // If this is a new vouch then insert a new Vouch record\n        Index memory index = voucherIndexes[borrower][staker];\n        if (index.isSet) {\n            // Update existing record checking that the new trust amount is\n            // not less than the amount of stake currently locked by the borrower\n            Vouch storage vouch = vouchers[borrower][index.idx];\n            if (trustAmount < vouch.locked) revert TrustAmountLtLocked();\n            vouch.trust = trustAmount;\n        } else {\n            // If the member is overdue they cannot create new vouches they can\n            // only update existing vouches\n            if (uToken.checkIsOverdue(staker)) revert VouchWhenOverdue();\n\n            // This is a new vouch so we need to check that the\n            // member has not reached the max voucher limit\n            uint256 voucheeIndex = vouchees[staker].length;\n            if (voucheeIndex >= maxVouchees) revert MaxVouchees();\n\n            // Get the new index that this vouch is going to be inserted at\n            // Then update the voucher indexes for this borrower as well as\n            // Adding the Vouch the the vouchers array for this staker\n            uint256 voucherIndex = vouchers[borrower].length;\n            if (voucherIndex >= maxVouchers) revert MaxVouchers();\n            voucherIndexes[borrower][staker] = Index(true, voucherIndex.toUint128());\n            vouchers[borrower].push(Vouch(staker, trustAmount, 0, 0));\n\n            // Add the voucherIndex of this new vouch to the vouchees array for this\n            // staker then update the voucheeIndexes with the voucheeIndex\n            vouchees[staker].push(Vouchee(borrower, voucherIndex.toUint96()));\n            voucheeIndexes[borrower][staker] = Index(true, voucheeIndex.toUint128());\n        }\n\n        emit LogUpdateTrust(staker, borrower, trustAmount);\n    }\n\n    /**\n     *  @dev Remove voucher for member\n     *  Can be called by either the borrower or the staker. It will remove the voucher from\n     *  the voucher array by replacing it with the last item of the array and resting the array\n     *  size to -1 by popping off the last item\n     *  Only callable by a member when the contract is not paused\n     *  Emit {LogCancelVouch} event\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function _cancelVouchInternal(address staker, address borrower) internal {\n        Index memory removeVoucherIndex = voucherIndexes[borrower][staker];\n        if (!removeVoucherIndex.isSet) revert VoucherNotFound();\n\n        // Check that the locked amount for this vouch is 0\n        Vouch memory vouch = vouchers[borrower][removeVoucherIndex.idx];\n        if (vouch.locked > 0) revert LockedStakeNonZero();\n\n        // Remove borrower from vouchers array by moving the last item into the position\n        // of the index being removed and then poping the last item off the array\n        {\n            // Cache the last voucher\n            Vouch memory lastVoucher = vouchers[borrower][vouchers[borrower].length - 1];\n            // Move the lastVoucher to the index of the voucher we are removing\n            vouchers[borrower][removeVoucherIndex.idx] = lastVoucher;\n            // Pop the last vouch off the end of the vouchers array\n            vouchers[borrower].pop();\n            // Delete the voucher index for this borrower => staker pair\n            delete voucherIndexes[borrower][staker];\n            // Update the last vouchers coresponsing Vouchee item\n            uint128 voucheeIdx = voucherIndexes[borrower][lastVoucher.staker].idx;\n            vouchees[staker][voucheeIdx].voucherIndex = removeVoucherIndex.idx.toUint96();\n        }\n\n        // Update the vouchee entry for this borrower => staker pair\n        {\n            Index memory removeVoucheeIndex = voucheeIndexes[borrower][staker];\n            // Cache the last vouchee\n            Vouchee memory lastVouchee = vouchees[staker][vouchees[staker].length - 1];\n            // Move the last vouchee to the index of the removed vouchee\n            vouchees[staker][removeVoucheeIndex.idx] = lastVouchee;\n            // Pop the last vouchee off the end of the vouchees array\n            vouchees[staker].pop();\n            // Delete the vouchee index for this borrower => staker pair\n            delete voucheeIndexes[borrower][staker];\n            // Update the vouchee indexes to the new vouchee index\n            voucheeIndexes[lastVouchee.borrower][staker].idx = removeVoucheeIndex.idx;\n        }\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    /**\n     *  Cancels a vouch between a staker and a borrower.\n     *  @dev The function can only be called by a member of the stakers list.\n     *  @param staker The address of the staker who made the vouch.\n     *  @param borrower The address of the borrower who received the vouch.\n     */\n    function cancelVouch(address staker, address borrower) public onlyMember(msg.sender) whenNotPaused {\n        if (staker != msg.sender && borrower != msg.sender) revert AuthFailed();\n        _cancelVouchInternal(staker, borrower);\n    }\n\n    /**\n     *  @notice Register a a member using a signed permit\n     *  @dev See registerMember\n     *  @param newMember New member address\n     *  @param value Amount approved by permit\n     *  @param deadline Timestamp for when the permit expires\n     *  @param v secp256k1 signature part\n     *  @param r secp256k1 signature part\n     *  @param s secp256k1 signature part\n     */\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused {\n        IUnionToken(unionToken).permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /**\n     *  @notice Register a a member, and burn the application fee\n     *  @dev    In order to register as a member an address must be receiving x amount\n     *          of vouches greater than 0 from stakers. x is defined by `effectiveCount`\n     *          Emits {LogRegisterMember} event\n     *  @param newMember New member address\n     */\n    function registerMember(address newMember) public virtual whenNotPaused {\n        _validateNewMember(newMember);\n\n        IUnionToken(unionToken).burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    /**\n     *  @notice Stake staking tokens\n     *  @dev    Stake is used to underwrite loans and becomes locked if a\n     *          member a staker has vouched for borrows against it.\n     *          Stake also earns rewards from the comptroller\n     *  Emits a {LogStake} event.\n     *  @param amount Amount to stake\n     */\n    function stake(uint96 amount) public whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        Staker storage staker = stakers[msg.sender];\n\n        if (staker.stakedAmount + amount > maxStakeAmount) revert StakeLimitReached();\n\n        _updateStakedCoinAge(msg.sender, staker);\n        staker.stakedAmount += amount;\n        totalStaked += amount;\n\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 currentAllowance = erc20Token.allowance(address(this), assetManager);\n        if (currentAllowance < amount) {\n            erc20Token.safeIncreaseAllowance(assetManager, amount - currentAllowance);\n        }\n\n        if (!IAssetManager(assetManager).deposit(stakingToken, amount)) revert AssetManagerDepositFailed();\n        emit LogStake(msg.sender, amount);\n    }\n\n    /**\n     *  @notice Unstake staking token\n     *  @dev    Tokens can only be unstaked if they are not locked. ie a\n     *          vouchee is not borrowing against them.\n     *  Emits {LogUnstake} event\n     *  @param amount Amount to unstake\n     */\n    function unstake(uint96 amount) external whenNotPaused nonReentrant {\n        Staker storage staker = stakers[msg.sender];\n\n        // Stakers can only unstaked stake balance that is unlocked. Stake balance\n        // becomes locked when it is used to underwrite a borrow.\n        if (staker.stakedAmount - staker.locked < amount) revert InsufficientBalance();\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 remaining = IAssetManager(assetManager).withdraw(stakingToken, msg.sender, amount);\n        if (uint96(remaining) > amount) {\n            revert AssetManagerWithdrawFailed();\n        }\n        uint96 actualAmount = amount - uint96(remaining);\n\n        _updateStakedCoinAge(msg.sender, staker);\n        staker.stakedAmount -= actualAmount;\n        totalStaked -= actualAmount;\n\n        emit LogUnstake(msg.sender, actualAmount);\n    }\n\n    /**\n     *  @dev collect staker rewards from the comptroller\n     */\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n    }\n\n    /**\n     *  @notice Write off a borrowers debt\n     *  @dev    Used the stakers locked stake to write off the loan, transferring the\n     *          Stake to the AssetManager and adjusting balances in the AssetManager\n     *          and the UToken to repay the principal\n     *  @dev    Emits {LogDebtWriteOff} event\n     *  @param stakerAddress address of staker\n     *  @param borrowerAddress address of borrower\n     *  @param amount amount to writeoff\n     */\n    function debtWriteOff(\n        address stakerAddress,\n        address borrowerAddress,\n        uint96 amount\n    ) external {\n        if (amount == 0) revert AmountZero();\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 lastRepay = uToken.getLastRepay(borrowerAddress);\n\n        // This function is only callable by the public if the loan is overdue by\n        // overdue blocks + maxOverdueBlocks. This stops the system being left with\n        // debt that is overdue indefinitely and no ability to do anything about it.\n        if (block.number <= lastRepay + overdueBlocks + maxOverdueBlocks) {\n            if (stakerAddress != msg.sender) revert AuthFailed();\n        }\n\n        Index memory index = voucherIndexes[borrowerAddress][stakerAddress];\n        if (!index.isSet) revert VoucherNotFound();\n        Vouch storage vouch = vouchers[borrowerAddress][index.idx];\n\n        if (amount > vouch.locked) revert ExceedsLocked();\n\n        // update staker staked amount\n        Staker storage staker = stakers[stakerAddress];\n        _updateStakedCoinAge(stakerAddress, staker);\n        staker.stakedAmount -= amount;\n        staker.locked -= amount;\n        totalStaked -= amount;\n\n        // update vouch trust amount\n        vouch.trust -= amount;\n        vouch.locked -= amount;\n\n        // Update total frozen and member frozen. We don't want to move th\n        // burden of calling updateFrozenInfo into this function as it is quite\n        // gas intensive. Instead we just want to remove the amount that was\n        // frozen which is now being written off. However, it is possible that\n        // member frozen has not been updated prior to calling debtWriteOff and\n        // the amount being written off could be greater than the amount frozen.\n        // To avoid an underflow here we need to check this condition\n        uint256 stakerFrozen = memberFrozen[stakerAddress];\n        if (amount > stakerFrozen) {\n            // The amount being written off is more than the amount that has\n            // been previously frozen for this staker. Reset their frozen stake\n            // to zero and adjust totalFrozen\n            memberFrozen[stakerAddress] = 0;\n            totalFrozen -= stakerFrozen;\n        } else {\n            totalFrozen -= amount;\n            memberFrozen[stakerAddress] -= amount;\n        }\n\n        if (vouch.trust == 0) {\n            _cancelVouchInternal(stakerAddress, borrowerAddress);\n        }\n\n        // Notify the AssetManager and the UToken market of the debt write off\n        // so they can adjust their balances accordingly\n        IAssetManager(assetManager).debtWriteOff(stakingToken, uint256(amount));\n        uToken.debtWriteOff(borrowerAddress, uint256(amount));\n\n        comptroller.updateTotalStaked(stakingToken, totalStaked - totalFrozen);\n\n        emit LogDebtWriteOff(msg.sender, borrowerAddress, uint256(amount));\n    }\n\n    /**\n     *  @notice Borrowing from the market\n     *  @dev    Locks/Unlocks the borrowers stakers staked amounts in a first in\n     *          First out order. Meaning the members that vouched for this borrower\n     *          first will be the first members to get their stake locked or unlocked\n     *          following a borrow or repayment.\n     *  @param borrower The address of the borrower\n     *  @param amount Lock/Unlock amount\n     *  @param lock If the amount is being locked or unlocked\n     */\n    function updateLocked(\n        address borrower,\n        uint96 amount,\n        bool lock\n    ) external onlyMarket {\n        uint96 remaining = amount;\n\n        uint256 vouchersLength = vouchers[borrower].length;\n        for (uint256 i = 0; i < vouchersLength; i++) {\n            Vouch storage vouch = vouchers[borrower][i];\n            uint96 innerAmount;\n\n            uint256 lastWithdrawRewards = getLastWithdrawRewards[vouch.staker];\n            stakers[vouch.staker].lockedCoinAge +=\n                (block.number - _max(lastWithdrawRewards, uint256(vouch.lastUpdated))) *\n                uint256(vouch.locked);\n            if (lock) {\n                // Look up the staker and determine how much unlock stake they\n                // have available for the borrower to borrow. If there is 0\n                // then continue to the next voucher in the array\n                uint96 stakerLocked = stakers[vouch.staker].locked;\n                uint96 stakerStakedAmount = stakers[vouch.staker].stakedAmount;\n                uint96 availableStake = stakerStakedAmount - stakerLocked;\n                uint96 lockAmount = _min(availableStake, vouch.trust - vouch.locked);\n                if (lockAmount == 0) continue;\n                // Calculate the amount to add to the lock then\n                // add the extra amount to lock to the stakers locked amount\n                // and also update the vouches locked amount and lastUpdated block\n                innerAmount = _min(remaining, lockAmount);\n                stakers[vouch.staker].locked = stakerLocked + innerAmount;\n                vouch.locked += innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            } else {\n                // Look up how much this vouch has locked. If it is 0 then\n                // continue to the next voucher. Then calculate the amount to\n                // unlock which is the min of the vouches lock and what is\n                // remaining to unlock\n                uint96 locked = vouch.locked;\n                if (locked == 0) continue;\n                innerAmount = _min(locked, remaining);\n                // Update the stored locked values and last updated block\n                stakers[vouch.staker].locked -= innerAmount;\n                vouch.locked -= innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            }\n\n            remaining -= innerAmount;\n            // If there is no remaining amount to lock/unlock\n            // we can stop looping through vouchers\n            if (remaining <= 0) break;\n        }\n\n        // If we have looped through all the avai"
    }
  ]
}