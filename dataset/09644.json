{
  "Title": "[G-10] `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
  "Content": "\n1.  File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279))\n\n```solidity\n        for (uint256 i = 0; i < _amount; i++) {\n```\n\n2.  File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79))\n\n```solidity\n    for (uint256 i; i < _collections.length; i++) {\n```\n\n3.  File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50))\n\n```solidity\n        for (uint256 i = 0; i < currentWindow; i++) {\n```\n\n4.  File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274))\n\n```solidity\n        for (uint256 i = 0; i < proof.length; i++) {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-03-joyn-contest",
  "Code": [
    {
      "filename": "core-contracts/contracts/CoreCollection.sol",
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\r\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\r\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\r\n\r\ncontract CoreCollection is\r\n    Ownable,\r\n    ERC721Claimable,\r\n    ERC721Enumerable,\r\n    ERC721Payable\r\n{\r\n    bool public initialized;\r\n    string private _name;\r\n    string private _symbol;\r\n    string private _baseUri;\r\n    uint256 public maxSupply;\r\n    uint256 public startingIndex;\r\n    uint256 public startingIndexBlock;\r\n    string public HASHED_PROOF = \"\";\r\n\r\n    event ClaimInitialized(bytes32 root);\r\n    event NewCollectionMeta(string name, string symbol);\r\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\r\n    event StartingIndexSet(uint256 index);\r\n    event RoyaltyVaultInitialized(address royaltyVault);\r\n    event NewHashedProof(string proof);\r\n    event NewWithdrawal(address to, uint256 amount);\r\n\r\n    constructor() ERC721(\"\", \"\") {}\r\n\r\n    // ----------------- MODIFIER -----------------\r\n\r\n    modifier onlyInitialized() {\r\n        require(initialized, \"CoreCollection: Not initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnInitialized() {\r\n        require(!initialized, \"CoreCollection: Already initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidSupply(uint256 _maxSupply) {\r\n        require(\r\n            _maxSupply > 0,\r\n            \"CoreCollection: Max supply should be greater than 0\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier tokenExists(uint256 _tokenId) {\r\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\r\n        _;\r\n    }\r\n\r\n    // ----------------- EXTERNAL -----------------\r\n\r\n    /**\r\n     * @notice Initializes the collection\r\n     * @dev This method is being called from the CoreFactory contract\r\n     * @param _collectionName Name of the collection\r\n     * @param _collectionSymbol Symbol of the collection\r\n     * @param _collectionURI Base URI for the collection\r\n     * @param _maxSupply The maximum number of tokens that can be minted\r\n     * @param _mintFee The price of a token in this collection\r\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\r\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\r\n     * @param _splitFactory base URI for the collection\r\n     */\r\n    function initialize(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol,\r\n        string memory _collectionURI,\r\n        uint256 _maxSupply,\r\n        uint256 _mintFee,\r\n        address _payableToken,\r\n        bool _isForSale,\r\n        address _splitFactory\r\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        _baseUri = _collectionURI;\r\n        maxSupply = _maxSupply;\r\n        mintFee = _mintFee;\r\n        payableToken = IERC20(_payableToken);\r\n        isForSale = _isForSale;\r\n        splitFactory = _splitFactory;\r\n        initialized = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to airdrop tokens\r\n     * @dev The Merkle tree defines for each address how much token can be claimed\r\n     * @dev This method can only be called once\r\n     * @param _root A Merkle root\r\n     */\r\n    function initializeClaims(bytes32 _root)\r\n        external\r\n        onlyOwner\r\n        onlyNotClaimableSet\r\n        onlyValidRoot(_root)\r\n    {\r\n        _setMerkelRoot(_root);\r\n        emit ClaimInitialized(_root);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to change the collection's name and symbol\r\n     * @dev This function is only callable by the collection's owner\r\n     * @param _collectionName A collection name\r\n     * @param _collectionSymbol A collection symbol\r\n     */\r\n    function setCollectionMeta(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol\r\n    ) external onlyOwner {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called to mint tokens from this ERC721 collection\r\n     * @dev The collection must be initialized first\r\n     * @param to Token recipient\r\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\r\n     * @param claimableAmount The amount of tokens the user has been airdropped\r\n     * @param amount The amount of tokens the user wants to mint\r\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\r\n     */\r\n    function mintToken(\r\n        address to,\r\n        bool isClaim,\r\n        uint256 claimableAmount,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) external onlyInitialized {\r\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\r\n        require(\r\n            totalSupply() + amount <= maxSupply,\r\n            \"CoreCollection: Over Max Supply\"\r\n        );\r\n\r\n        if (isClaim) {\r\n            require(claimableSet(), \"CoreCollection: No claimable\");\r\n            require(\r\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\r\n                \"CoreCollection: Can't claim\"\r\n            );\r\n            _claim(msg.sender, amount);\r\n        } else {\r\n            require(isForSale, \"CoreCollection: Not for sale\");\r\n            if (mintFee > 0) {\r\n                _handlePayment(mintFee * amount);\r\n            }\r\n        }\r\n\r\n        batchMint(to, amount, isClaim);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\r\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        uint256 amount = payableToken.balanceOf(address(this));\r\n        payableToken.transferFrom(address(this), msg.sender, amount);\r\n        emit NewWithdrawal(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set royalty vault address for collection\r\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \r\n     * from the collection are transferred to the vault when the vault is initialized\r\n     * @param _royaltyVault The address of the royalty vault\r\n     */\r\n    function setRoyaltyVault(address _royaltyVault)\r\n        external\r\n        onlyVaultUninitialized\r\n    {\r\n        require(\r\n            msg.sender == splitFactory || msg.sender == owner(),\r\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\r\n        );\r\n        royaltyVault = _royaltyVault;\r\n        emit RoyaltyVaultInitialized(_royaltyVault);\r\n    }\r\n\r\n    /**\r\n     * @notice Set a provenance hash\r\n     * @dev This hash is used to verify the minting ordering of a collection (Ã  la BAYC)\r\n     * This hash is generated off-chain\r\n     * @param _proof The SHA256 generated hash\r\n     */\r\n    function setHashedProof(string calldata _proof) external onlyOwner {\r\n        require(\r\n            bytes(HASHED_PROOF).length == 0,\r\n            \"CoreCollection: Hashed Proof is set\"\r\n        );\r\n\r\n        HASHED_PROOF = _proof;\r\n        emit NewHashedProof(_proof);\r\n    }\r\n\r\n    // ----------------- PUBLIC -----------------\r\n\r\n    /**\r\n     * @notice Set the mint starting index\r\n     * @dev The starting index can only be generated once\r\n     */\r\n    function setStartingIndex() public {\r\n        require(\r\n            startingIndex == 0,\r\n            \"CoreCollection: Starting index is already set\"\r\n        );\r\n\r\n        startingIndex =\r\n            (uint256(\r\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\r\n            ) % maxSupply) +\r\n            1;\r\n        startingIndexBlock = uint256(block.number);\r\n        emit StartingIndexSet(startingIndex);\r\n    }\r\n\r\n    // ---------------- VIEW ----------------\r\n\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function baseURI() public view returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    // ---------------- PRIVATE ----------------\r\n\r\n    /**\r\n     * @notice Mint token\r\n     * @dev A starting index is calculated at the time of first mint\r\n     * returns a tokenId\r\n     * @param _to Token recipient\r\n     */\r\n    function mint(address _to) private returns (uint256 tokenId) {\r\n        if (startingIndex == 0) {\r\n            setStartingIndex();\r\n        }\r\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\r\n        _mint(_to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint tokens in batch\r\n     * @param _to Token recipient\r\n     * @param _amount Number of tokens to include in batch\r\n     * @param _isClaim Whether the batch mint is an airdrop or not\r\n     */\r\n    function batchMint(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _isClaim\r\n    ) private {\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            uint256 tokenId = mint(_to);\r\n            if (_isClaim) {\r\n                emit NewClaim(msg.sender, _to, tokenId);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ---------------- INTERNAL ----------------\r\n\r\n    /**\r\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\r\n     * @dev The split contract is a contract that allows a team to share revenue together\r\n     * @param _from Transfer sender\r\n     * @param _to Transfer recipient\r\n     * @param _tokenId TokenId of token being transferred\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(_from, _to, _tokenId);\r\n\r\n        if (\r\n            royaltyVault != address(0) &&\r\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\r\n        ) {\r\n            IRoyaltyVault(royaltyVault).sendToSplitter();\r\n        }\r\n    }\r\n}"
    },
    {
      "filename": "core-contracts/contracts/CoreFactory.sol",
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport {CoreProxy} from './CoreProxy.sol';\r\nimport './utils/structs/Collection.sol';\r\nimport {CoreCollection} from './CoreCollection.sol';\r\nimport {ICoreCollection} from '../interfaces/ICoreCollection.sol';\r\n\r\ncontract CoreFactory {\r\n  struct Project {\r\n    string id;\r\n    address creator;\r\n  }\r\n\r\n  event NewProject(string id, address creator);\r\n  event NewCollection(\r\n    string collectionId,\r\n    address collection,\r\n    string projectId\r\n  );\r\n\r\n  address public immutable collection;\r\n  address public immutable splitFactory;\r\n  mapping(string => Project) public projects;\r\n  mapping(string => address) public collections;\r\n\r\n  constructor(address _collection, address _splitFactory) {\r\n    collection = _collection;\r\n    splitFactory = _splitFactory;\r\n  }\r\n\r\n  // ---------------- MODIFIER ----------------\r\n\r\n  modifier onlyAvailableProject(string memory _projectId) {\r\n    require(\r\n      projects[_projectId].creator == address(0),\r\n      'CoreFactory: Unavailable project id'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyProjectOwner(string memory _projectId) {\r\n    require(\r\n      projects[_projectId].creator == msg.sender,\r\n      'CoreFactory: Not an owner of the project'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyAvailableCollection(string memory _collectionId) {\r\n    require(\r\n      collections[_collectionId] == address(0),\r\n      'CoreFactory: Unavailable collection id'\r\n    );\r\n    _;\r\n  }\r\n\r\n  // ---------------- EXTERNAL ----------------\r\n\r\n  /**\r\n   * @notice Allows to create a project as well as deploy its collection(s)\r\n   * For adding a collection to a project, use the addCollection() method.\r\n   * @dev Projects have unique identifiers.\r\n   * Collections are deployed using a proxy pattern. This is mainly for gas optimization purposes\r\n   * and to support future contract upgrades.\r\n   * Collections ownership are transferred to the caller.\r\n   * @param _projectId Project id which is a unique identifier\r\n   * @param _collections An array of Collection that needs to be deployed\r\n   */\r\n  function createProject(\r\n    string memory _projectId,\r\n    Collection[] memory _collections\r\n  ) external onlyAvailableProject(_projectId) {\r\n    require(\r\n      _collections.length > 0,\r\n      'CoreFactory: should have more at least one collection'\r\n    );\r\n\r\n    for (uint256 i; i < _collections.length; i++) {\r\n      Collection memory _collection = _collections[i];\r\n      address coreCollection = _createCollection(_collection);\r\n\r\n      if (_collection.claimsMerkleRoot != bytes32(0)) {\r\n        ICoreCollection(coreCollection).initializeClaims(\r\n          _collection.claimsMerkleRoot\r\n        );\r\n      }\r\n\r\n      emit NewCollection(_collection.id, coreCollection, _projectId);\r\n\r\n      ICoreCollection(coreCollection).transferOwnership(msg.sender);\r\n    }\r\n    Project memory project;\r\n    project.id = _projectId;\r\n    project.creator = msg.sender;\r\n    projects[_projectId] = project;\r\n\r\n    emit NewProject(_projectId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows to add a collection to a project\r\n   * @dev Can only be called by project creator\r\n   * Collection's ownership is transferred to the caller\r\n   * @param _projectId Project id which is a unique identifier\r\n   * @param _collection Collection that needs to be deployed\r\n   */\r\n  function addCollection(\r\n    string memory _projectId,\r\n    Collection memory _collection\r\n  ) external onlyProjectOwner(_projectId) returns (address) {\r\n    address coreCollection = _createCollection(_collection);\r\n\r\n    if (_collection.claimsMerkleRoot != bytes32(0)) {\r\n      ICoreCollection(coreCollection).initializeClaims(\r\n        _collection.claimsMerkleRoot\r\n      );\r\n    }\r\n\r\n    emit NewCollection(_collection.id, coreCollection, _projectId);\r\n\r\n    ICoreCollection(coreCollection).transferOwnership(msg.sender);\r\n    return coreCollection;\r\n  }\r\n\r\n  // ---------------- VIEW ----------------\r\n\r\n  function getProject(string memory _projectId)\r\n    external\r\n    view\r\n    returns (Project memory)\r\n  {\r\n    return projects[_projectId];\r\n  }\r\n\r\n  // ---------------- PRIVATE ----------------\r\n\r\n  /**\r\n   * @notice Instanciates/Deploys a collection\r\n   * @param _collection Collection that needs to be deployed\r\n   */\r\n  function _createCollection(Collection memory _collection)\r\n    private\r\n    onlyAvailableCollection(_collection.id)\r\n    returns (address)\r\n  {\r\n    address coreCollection = address(\r\n      new CoreProxy{salt: keccak256(abi.encodePacked(_collection.id))}(\r\n        collection\r\n      )\r\n    );\r\n\r\n    ICoreCollection(coreCollection).initialize(\r\n      _collection.name,\r\n      _collection.symbol,\r\n      _collection.baseURI,\r\n      _collection.maxSupply,\r\n      _collection.mintFee,\r\n      _collection.payableToken,\r\n      _collection.isForSale,\r\n      splitFactory\r\n    );\r\n\r\n    collections[_collection.id] = coreCollection;\r\n    return coreCollection;\r\n  }\r\n}"
    },
    {
      "filename": "splits/contracts/Splitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SplitStorage} from \"./SplitStorage.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Splitter\n * Building on the work from the Uniswap team at Uniswap and Mirror.xyz Team\n */\ncontract Splitter is SplitStorage {\n    /**** Mutable variables ****/\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;\n\n    // The TransferETH event is emitted after each eth transfer in the split is attempted.\n    event TransferETH(\n        // The account to which the transfer was attempted.\n        address account,\n        // The amount for transfer that was attempted.\n        uint256 amount,\n        // Whether or not the transfer succeeded.\n        bool success\n    );\n\n    // Emits when a window is incremented.\n    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);\n\n    /**\n     * @dev Claim the funds from the all windows.\n     * @param percentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claimForAllWindows(\n        uint256 percentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        // Make sure that the user has this allocation granted.\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, percentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < currentWindow; i++) {\n            if (!isClaimed(msg.sender, i)) {\n                setClaimed(msg.sender, i);\n\n                amount += scaleAmountByPercentage(\n                    balanceForWindow[i],\n                    percentageAllocation\n                );\n            }\n        }\n\n        transferSplitAsset(msg.sender, amount);\n    }\n\n    /**\n     * @dev get Node hash of given data.\n     * @param who {address} whitelisted user address\n     * @param percentageAllocation {uint256} percentage of allocation\n     * @return {bytes32} node hash\n     */\n    function getNode(\n        address who,\n        uint256 percentageAllocation\n    ) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    who,\n                    percentageAllocation\n                )\n            );\n    }\n\n    /**\n     * @dev get scaled amount from given amount and percentage.\n     * @param amount {uint256} amount\n     * @param scaledPercent {uint256} scaled percentage\n     * @return scaledAmount {uint256} scaled amount\n     */\n    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n        public\n        pure\n        returns (uint256 scaledAmount)\n    {\n        /*\n            Example:\n                If there is 100 ETH in the account, and someone has \n                an allocation of 2%, we call this with 100 as the amount, and 200\n                as the scaled percent.\n\n                To find out the amount we use, for example: (100 * 200) / (100 * 100)\n                which returns 2 -- i.e. 2% of the 100 ETH balance.\n         */\n        scaledAmount = (amount * scaledPercent) / (10000);\n    }\n\n    /**\n     * @dev claim for the given window.\n     * @param window {uint256} Window to claim\n     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claim(\n        uint256 window,\n        uint256 scaledPercentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(currentWindow > window, \"cannot claim for a future window\");\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n\n        setClaimed(msg.sender, window);\n\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, scaledPercentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        transferSplitAsset(\n            msg.sender,\n            // The absolute amount that's claimable.\n            scaleAmountByPercentage(\n                balanceForWindow[window],\n                scaledPercentageAllocation\n            )\n        );\n    }\n\n    /**\n     * @dev Function which handles increment window and puts amount to current window\n     * @param royaltyAmount {uint256} Amount needs to be added in window.\n     * @return {bool} Whether or not the window was incremented.\n     */\n    function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n        uint256 wethBalance;\n\n        require(\n            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n            \"Royalty Vault not supported\"\n        );\n        require(\n            IRoyaltyVault(msg.sender).getSplitter() == address(this),\n            \"Unauthorised to increment window\"\n        );\n\n        wethBalance = IERC20(splitAsset).balanceOf(address(this));\n        require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n        require(royaltyAmount > 0, \"No additional funds for window\");\n        balanceForWindow.push(royaltyAmount);\n        currentWindow += 1;\n        emit WindowIncremented(currentWindow, royaltyAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bool} Whether or not the window has been claimed.\n     */\n    function isClaimed(\n        address who,\n        uint256 window\n    ) public view returns (bool) {\n        return claimed[getClaimHash(who, window)];\n    }\n\n    /**** Private Functions ****/\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     */\n    function setClaimed(\n        address who,\n        uint256 window\n    ) private {\n        claimed[getClaimHash(who, window)] = true;\n    }\n\n    /**\n     * @dev Function which returns the hash of the given window, tokenId and membershipContract.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bytes32} Hash of the given window, tokenId and membershipContract.\n     */\n    function getClaimHash(\n        address who,\n        uint256 window\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(who, window));\n    }\n\n    /**\n     * @dev Function to convert output amount from percentages.\n     * @param amount {uint256} Amount for which percentage is to be calculated.\n     * @param percent {uint256} Percentage\n     * @return {uint256} Output amount.\n     */\n    function amountFromPercent(uint256 amount, uint32 percent)\n        private\n        pure\n        returns (uint256)\n    {\n        // Solidity 0.8.0 lets us do this without SafeMath.\n        return (amount * percent) / 100;\n    }\n\n    /**\n     * @dev Function to transfer split asset to the given address.\n     * @param to {address} Address to transfer the split asset to.\n     * @param value {uint256} Amount to transfer.\n     */\n    function transferSplitAsset(address to, uint256 value)\n        private\n        returns (bool didSucceed)\n    {\n        // Try to transfer ETH to the given recipient.\n        didSucceed = IERC20(splitAsset).transfer(to, value);\n        require(didSucceed, \"Failed to transfer ETH\");\n\n        emit TransferETH(to, value, didSucceed);\n    }\n\n    /**\n     * @dev transfer given amount of ETH in contract to the given address.\n     * @param to {address} Address to transfer asset\n     * @param value {uint256} Amount to transfer\n     * @return {bool} Whether or not the transfer was successful.\n     */\n    function attemptETHTransfer(address to, uint256 value)\n        private\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n        return success;\n    }\n\n    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol\n    /**\n     * @dev Function to verify the given proof.\n     * @param proof {bytes32[]} Proof to verify\n     * @param root {bytes32} Root of the Merkle tree\n     * @param leaf {bytes32} Leaf to verify\n     * @return {bool} Whether or not the proof is valid.\n     */\n    function verifyProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) private pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}"
    },
    {
      "filename": "splits/contracts/Splitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SplitStorage} from \"./SplitStorage.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Splitter\n * Building on the work from the Uniswap team at Uniswap and Mirror.xyz Team\n */\ncontract Splitter is SplitStorage {\n    /**** Mutable variables ****/\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;\n\n    // The TransferETH event is emitted after each eth transfer in the split is attempted.\n    event TransferETH(\n        // The account to which the transfer was attempted.\n        address account,\n        // The amount for transfer that was attempted.\n        uint256 amount,\n        // Whether or not the transfer succeeded.\n        bool success\n    );\n\n    // Emits when a window is incremented.\n    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);\n\n    /**\n     * @dev Claim the funds from the all windows.\n     * @param percentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claimForAllWindows(\n        uint256 percentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        // Make sure that the user has this allocation granted.\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, percentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < currentWindow; i++) {\n            if (!isClaimed(msg.sender, i)) {\n                setClaimed(msg.sender, i);\n\n                amount += scaleAmountByPercentage(\n                    balanceForWindow[i],\n                    percentageAllocation\n                );\n            }\n        }\n\n        transferSplitAsset(msg.sender, amount);\n    }\n\n    /**\n     * @dev get Node hash of given data.\n     * @param who {address} whitelisted user address\n     * @param percentageAllocation {uint256} percentage of allocation\n     * @return {bytes32} node hash\n     */\n    function getNode(\n        address who,\n        uint256 percentageAllocation\n    ) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    who,\n                    percentageAllocation\n                )\n            );\n    }\n\n    /**\n     * @dev get scaled amount from given amount and percentage.\n     * @param amount {uint256} amount\n     * @param scaledPercent {uint256} scaled percentage\n     * @return scaledAmount {uint256} scaled amount\n     */\n    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n        public\n        pure\n        returns (uint256 scaledAmount)\n    {\n        /*\n            Example:\n                If there is 100 ETH in the account, and someone has \n                an allocation of 2%, we call this with 100 as the amount, and 200\n                as the scaled percent.\n\n                To find out the amount we use, for example: (100 * 200) / (100 * 100)\n                which returns 2 -- i.e. 2% of the 100 ETH balance.\n         */\n        scaledAmount = (amount * scaledPercent) / (10000);\n    }\n\n    /**\n     * @dev claim for the given window.\n     * @param window {uint256} Window to claim\n     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claim(\n        uint256 window,\n        uint256 scaledPercentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(currentWindow > window, \"cannot claim for a future window\");\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n\n        setClaimed(msg.sender, window);\n\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, scaledPercentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        transferSplitAsset(\n            msg.sender,\n            // The absolute amount that's claimable.\n            scaleAmountByPercentage(\n                balanceForWindow[window],\n                scaledPercentageAllocation\n            )\n        );\n    }\n\n    /**\n     * @dev Function which handles increment window and puts amount to current window\n     * @param royaltyAmount {uint256} Amount needs to be added in window.\n     * @return {bool} Whether or not the window was incremented.\n     */\n    function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n        uint256 wethBalance;\n\n        require(\n            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n            \"Royalty Vault not supported\"\n        );\n        require(\n            IRoyaltyVault(msg.sender).getSplitter() == address(this),\n            \"Unauthorised to increment window\"\n        );\n\n        wethBalance = IERC20(splitAsset).balanceOf(address(this));\n        require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n        require(royaltyAmount > 0, \"No additional funds for window\");\n        balanceForWindow.push(royaltyAmount);\n        currentWindow += 1;\n        emit WindowIncremented(currentWindow, royaltyAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bool} Whether or not the window has been claimed.\n     */\n    function isClaimed(\n        address who,\n        uint256 window\n    ) public view returns (bool) {\n        return claimed[getClaimHash(who, window)];\n    }\n\n    /**** Private Functions ****/\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     */\n    function setClaimed(\n        address who,\n        uint256 window\n    ) private {\n        claimed[getClaimHash(who, window)] = true;\n    }\n\n    /**\n     * @dev Function which returns the hash of the given window, tokenId and membershipContract.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bytes32} Hash of the given window, tokenId and membershipContract.\n     */\n    function getClaimHash(\n        address who,\n        uint256 window\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(who, window));\n    }\n\n    /**\n     * @dev Function to convert output amount from percentages.\n     * @param amount {uint256} Amount for which percentage is to be calculated.\n     * @param percent {uint256} Percentage\n     * @return {uint256} Output amount.\n     */\n    function amountFromPercent(uint256 amount, uint32 percent)\n        private\n        pure\n        returns (uint256)\n    {\n        // Solidity 0.8.0 lets us do this without"
    }
  ]
}