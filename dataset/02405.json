{
  "Title": "Using ```memory``` instead of ```calldata```",
  "Content": "##### Description\nUsing ```memory``` instead of ```calldata``` for input arrays in external functions:\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/wallet/MinimalWallet.sol#L45\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/wallet/MinimalWallet.sol#L84\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/wallet/MinimalWallet.sol#L101\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/wallet/MinimalWallet.sol#L112\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/wallet/MinimalWallet.sol#L121\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/wallet/MinimalWallet.sol#L145\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/wallet/MinimalWallet.sol#L155\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/wallet/MinimalWallet.sol#L165\n##### Recommendation\nWe recommend replacing ```memory``` by ```calldata```.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/wallet/MinimalWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"../access/ACL.sol\";\nimport \"../access/Roles.sol\";\n\ncontract MinimalWallet is ACL, Roles, ERC721Holder, ERC1155Holder {\n    using SafeERC20 for IERC20;\n\n    enum Protocol {\n        ETH,\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n\n    struct TransferNote {\n        Protocol protocol;\n        address token;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    struct ApprovalNote {\n        Protocol protocol;\n        address token;\n        address[] operators;\n    }\n\n    error WithdrawFailed();\n    error InvalidArrayLength();\n\n    ////////////////////////////////////////////////////\n    // External functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    // @notice Withdraw an array of assets\n    // @dev Works for ETH, ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, array of ids and amounts\n    function withdraw(TransferNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        TransferNote memory note;\n        Protocol protocol;\n        uint256[] memory ids;\n        uint256[] memory amounts;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ETH) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawETH(amounts[0]);\n            } else if (protocol == Protocol.ERC20) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawERC20(IERC20(note.token), amounts[0]);\n            } else if (protocol == Protocol.ERC721) {\n                ids = note.ids;\n                _withdrawERC721s(IERC721(note.token), ids);\n            } else if (protocol == Protocol.ERC1155) {\n                ids = note.ids;\n                amounts = note.amounts;\n                _withdrawERC1155s(IERC1155(note.token), ids, amounts);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw ETH from this contract to the msg.sender\n    // @param amount The amount of ETH to be withdrawn\n    function withdrawETH(uint256 amount) external isPermitted(OWNER_ROLE) {\n        _withdrawETH(amount);\n    }\n\n    // @notice Withdraw ERC20s\n    // @param erc20s An array of erc20 addresses\n    // @param amounts An array of amounts for each erc20\n    function withdrawERC20s(\n        IERC20[] memory erc20s,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        uint256 length = erc20s.length;\n        if (amounts.length != length) revert InvalidArrayLength();\n        for (uint256 i; i < length; ) {\n            _withdrawERC20(erc20s[i], amounts[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw multiple ERC721 ids for a single ERC721 contract\n    // @param erc721 The address of the ERC721 contract\n    // @param ids An array of ids that are to be withdrawn\n    function withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC721s(erc721, ids);\n    }\n\n    // @notice Withdraw multiple ERC1155 ids for a single ERC1155 contract\n    // @param erc1155 The address of the ERC155 contract\n    // @param ids An array of ids that are to be withdrawn\n    // @param amounts An array of amounts per id\n    function withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC1155s(erc1155, ids, amounts);\n    }\n\n    // @notice Revoke approval on an array of assets and operators\n    // @dev Works for ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, and array of operators\n    function revokeApprovals(ApprovalNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        ApprovalNote memory note;\n        Protocol protocol;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ERC20) {\n                _revokeERC20Approvals(IERC20(note.token), note.operators);\n            } else if (protocol == Protocol.ERC721) {\n                _revokeERC721Approvals(IERC721(note.token), note.operators);\n            } else if (protocol == Protocol.ERC1155) {\n                _revokeERC1155Approvals(IERC1155(note.token), note.operators);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Revoke approval of an ERC20 for an array of operators\n    // @param erc20 The address of the ERC20 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC20Approvals(erc20, operators);\n    }\n\n    // @notice Revoke approval of an ERC721 for an array of operators\n    // @param erc721 The address of the ERC721 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC721Approvals(\n        IERC721 erc721,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC721Approvals(erc721, operators);\n    }\n\n    // @notice Revoke approval of an ERC1155 for an array of operators\n    // @param erc1155 The address of the ERC1155 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC1155Approvals(\n        IERC1155 erc1155,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC1155Approvals(erc1155, operators);\n    }\n\n    ////////////////////////////////////////////////////\n    // Internal functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    function _withdrawETH(uint256 amount) internal {\n        (bool success, ) = msg.sender.call{ value : amount }(\"\");\n        if (!success) revert WithdrawFailed();\n    }\n\n    function _withdrawERC20(\n        IERC20 erc20,\n        uint256 amount\n    ) internal {\n        erc20.safeTransfer(msg.sender, amount);\n    }\n\n    function _withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) internal {\n        uint256 length = ids.length;\n        for (uint256 i; i < length; ) {\n            erc721.safeTransferFrom(address(this), msg.sender, ids[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    function _withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        // safeBatchTransferFrom will validate the array lengths\n        erc1155.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n    }\n\n    function _revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc20.safeApprove(operators[i], 0);\n            unchecked { ++i; }\n        }\n    }\n\n    function _revokeERC721Approvals(\n        IERC721 erc721,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc721.setApprovalForAll(operators[i], false);\n            unchecked { ++i; }\n        }\n    }\n\n    function _revokeERC1155Approvals(\n        IERC1155 erc1155,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc1155.setApprovalForAll(operators[i], false);\n            unchecked { ++i; }\n        }\n    }\n\n    ////////////////////////////////////////////////////\n    // Fallback functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/wallet/MinimalWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"../access/ACL.sol\";\nimport \"../access/Roles.sol\";\n\ncontract MinimalWallet is ACL, Roles, ERC721Holder, ERC1155Holder {\n    using SafeERC20 for IERC20;\n\n    enum Protocol {\n        ETH,\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n\n    struct TransferNote {\n        Protocol protocol;\n        address token;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    struct ApprovalNote {\n        Protocol protocol;\n        address token;\n        address[] operators;\n    }\n\n    error WithdrawFailed();\n    error InvalidArrayLength();\n\n    ////////////////////////////////////////////////////\n    // External functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    // @notice Withdraw an array of assets\n    // @dev Works for ETH, ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, array of ids and amounts\n    function withdraw(TransferNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        TransferNote memory note;\n        Protocol protocol;\n        uint256[] memory ids;\n        uint256[] memory amounts;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ETH) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawETH(amounts[0]);\n            } else if (protocol == Protocol.ERC20) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawERC20(IERC20(note.token), amounts[0]);\n            } else if (protocol == Protocol.ERC721) {\n                ids = note.ids;\n                _withdrawERC721s(IERC721(note.token), ids);\n            } else if (protocol == Protocol.ERC1155) {\n                ids = note.ids;\n                amounts = note.amounts;\n                _withdrawERC1155s(IERC1155(note.token), ids, amounts);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw ETH from this contract to the msg.sender\n    // @param amount The amount of ETH to be withdrawn\n    function withdrawETH(uint256 amount) external isPermitted(OWNER_ROLE) {\n        _withdrawETH(amount);\n    }\n\n    // @notice Withdraw ERC20s\n    // @param erc20s An array of erc20 addresses\n    // @param amounts An array of amounts for each erc20\n    function withdrawERC20s(\n        IERC20[] memory erc20s,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        uint256 length = erc20s.length;\n        if (amounts.length != length) revert InvalidArrayLength();\n        for (uint256 i; i < length; ) {\n            _withdrawERC20(erc20s[i], amounts[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw multiple ERC721 ids for a single ERC721 contract\n    // @param erc721 The address of the ERC721 contract\n    // @param ids An array of ids that are to be withdrawn\n    function withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC721s(erc721, ids);\n    }\n\n    // @notice Withdraw multiple ERC1155 ids for a single ERC1155 contract\n    // @param erc1155 The address of the ERC155 contract\n    // @param ids An array of ids that are to be withdrawn\n    // @param amounts An array of amounts per id\n    function withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC1155s(erc1155, ids, amounts);\n    }\n\n    // @notice Revoke approval on an array of assets and operators\n    // @dev Works for ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, and array of operators\n    function revokeApprovals(ApprovalNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        ApprovalNote memory note;\n        Protocol protocol;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ERC20) {\n                _revokeERC20Approvals(IERC20(note.token), note.operators);\n            } else if (protocol == Protocol.ERC721) {\n                _revokeERC721Approvals(IERC721(note.token), note.operators);\n            } else if (protocol == Protocol.ERC1155) {\n                _revokeERC1155Approvals(IERC1155(note.token), note.operators);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Revoke approval of an ERC20 for an array of operators\n    // @param erc20 The address of the ERC20 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC20Approvals(erc20, operators);\n    }\n\n    // @notice Revoke approval of an ERC721 for an array of operators\n    // @param erc721 The address of the ERC721 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC721Approvals(\n        IERC721 erc721,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC721Approvals(erc721, operators);\n    }\n\n    // @notice Revoke approval of an ERC1155 for an array of operators\n    // @param erc1155 The address of the ERC1155 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC1155Approvals(\n        IERC1155 erc1155,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC1155Approvals(erc1155, operators);\n    }\n\n    ////////////////////////////////////////////////////\n    // Internal functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    function _withdrawETH(uint256 amount) internal {\n        (bool success, ) = msg.sender.call{ value : amount }(\"\");\n        if (!success) revert WithdrawFailed();\n    }\n\n    function _withdrawERC20(\n        IERC20 erc20,\n        uint256 amount\n    ) internal {\n        erc20.safeTransfer(msg.sender, amount);\n    }\n\n    function _withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) internal {\n        uint256 length = ids.length;\n        for (uint256 i; i < length; ) {\n            erc721.safeTransferFrom(address(this), msg.sender, ids[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    function _withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        // safeBatchTransferFrom will validate the array lengths\n        erc1155.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n    }\n\n    function _revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc20.safeApprove(operators[i], 0);\n            unchecked { ++i; }\n        }\n    }\n\n    function _revokeERC721Approvals(\n        IERC721 erc721,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc721.setApprovalForAll(operators[i], false);\n            unchecked { ++i; }\n        }\n    }\n\n    function _revokeERC1155Approvals(\n        IERC1155 erc1155,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc1155.setApprovalForAll(operators[i], false);\n            unchecked { ++i; }\n        }\n    }\n\n    ////////////////////////////////////////////////////\n    // Fallback functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/wallet/MinimalWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"../access/ACL.sol\";\nimport \"../access/Roles.sol\";\n\ncontract MinimalWallet is ACL, Roles, ERC721Holder, ERC1155Holder {\n    using SafeERC20 for IERC20;\n\n    enum Protocol {\n        ETH,\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n\n    struct TransferNote {\n        Protocol protocol;\n        address token;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    struct ApprovalNote {\n        Protocol protocol;\n        address token;\n        address[] operators;\n    }\n\n    error WithdrawFailed();\n    error InvalidArrayLength();\n\n    ////////////////////////////////////////////////////\n    // External functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    // @notice Withdraw an array of assets\n    // @dev Works for ETH, ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, array of ids and amounts\n    function withdraw(TransferNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        TransferNote memory note;\n        Protocol protocol;\n        uint256[] memory ids;\n        uint256[] memory amounts;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ETH) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawETH(amounts[0]);\n            } else if (protocol == Protocol.ERC20) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawERC20(IERC20(note.token), amounts[0]);\n            } else if (protocol == Protocol.ERC721) {\n                ids = note.ids;\n                _withdrawERC721s(IERC721(note.token), ids);\n            } else if (protocol == Protocol.ERC1155) {\n                ids = note.ids;\n                amounts = note.amounts;\n                _withdrawERC1155s(IERC1155(note.token), ids, amounts);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw ETH from this contract to the msg.sender\n    // @param amount The amount of ETH to be withdrawn\n    function withdrawETH(uint256 amount) external isPermitted(OWNER_ROLE) {\n        _withdrawETH(amount);\n    }\n\n    // @notice Withdraw ERC20s\n    // @param erc20s An array of erc20 addresses\n    // @param amounts An array of amounts for each erc20\n    function withdrawERC20s(\n        IERC20[] memory erc20s,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        uint256 length = erc20s.length;\n        if (amounts.length != length) revert InvalidArrayLength();\n        for (uint256 i; i < length; ) {\n            _withdrawERC20(erc20s[i], amounts[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw multiple ERC721 ids for a single ERC721 contract\n    // @param erc721 The address of the ERC721 contract\n    // @param ids An array of ids that are to be withdrawn\n    function withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC721s(erc721, ids);\n    }\n\n    // @notice Withdraw multiple ERC1155 ids for a single ERC1155 contract\n    // @param erc1155 The address of the ERC155 contract\n    // @param ids An array of ids that are to be withdrawn\n    // @param amounts An array of amounts per id\n    function withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC1155s(erc1155, ids, amounts);\n    }\n\n    // @notice Revoke approval on an array of assets and operators\n    // @dev Works for ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, and array of operators\n    function revokeApprovals(ApprovalNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        ApprovalNote memory note;\n        Protocol protocol;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ERC20) {\n                _revokeERC20Approvals(IERC20(note.token), note.operators);\n            } else if (protocol == Protocol.ERC721) {\n                _revokeERC721Approvals(IERC721(note.token), note.operators);\n            } else if (protocol == Protocol.ERC1155) {\n                _revokeERC1155Approvals(IERC1155(note.token), note.operators);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Revoke approval of an ERC20 for an array of operators\n    // @param erc20 The address of the ERC20 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC20Approvals(erc20, operators);\n    }\n\n    // @notice Revoke approval of an ERC721 for an array of operators\n    // @param erc721 The address of the ERC721 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC721Approvals(\n        IERC721 erc721,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC721Approvals(erc721, operators);\n    }\n\n    // @notice Revoke approval of an ERC1155 for an array of operators\n    // @param erc1155 The address of the ERC1155 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC1155Approvals(\n        IERC1155 erc1155,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC1155Approvals(erc1155, operators);\n    }\n\n    ////////////////////////////////////////////////////\n    // Internal functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    function _withdrawETH(uint256 amount) internal {\n        (bool success, ) = msg.sender.call{ value : amount }(\"\");\n        if (!success) revert WithdrawFailed();\n    }\n\n    function _withdrawERC20(\n        IERC20 erc20,\n        uint256 amount\n    ) internal {\n        erc20.safeTransfer(msg.sender, amount);\n    }\n\n    function _withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) internal {\n        uint256 length = ids.length;\n        for (uint256 i; i < length; ) {\n            erc721.safeTransferFrom(address(this), msg.sender, ids[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    function _withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        // safeBatchTransferFrom will validate the array lengths\n        erc1155.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n    }\n\n    function _revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc20.safeApprove(operators[i], 0);\n            unchecked { ++i; }\n        }\n    }\n\n    function _revokeERC721Approvals(\n        IERC721 erc721,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc721.setApprovalForAll(operators[i], false);\n            unchecked { ++i; }\n        }\n    }\n\n    function _revokeERC1155Approvals(\n        IERC1155 erc1155,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc1155.setApprovalForAll(operators[i], false);\n            unchecked { ++i; }\n        }\n    }\n\n    ////////////////////////////////////////////////////\n    // Fallback functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/wallet/MinimalWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"../access/ACL.sol\";\nimport \"../access/Roles.sol\";\n\ncontract MinimalWallet is ACL, Roles, ERC721Holder, ERC1155Holder {\n    using SafeERC20 for IERC20;\n\n    enum Protocol {\n        ETH,\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n\n    struct TransferNote {\n        Protocol protocol;\n        address token;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    struct ApprovalNote {\n        Protocol protocol;\n        address token;\n        address[] operators;\n    }\n\n    error WithdrawFailed();\n    error InvalidArrayLength();\n\n    ////////////////////////////////////////////////////\n    // External functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    // @notice Withdraw an array of assets\n    // @dev Works for ETH, ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, array of ids and amounts\n    function withdraw(TransferNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        TransferNote memory note;\n        Protocol protocol;\n        uint256[] memory ids;\n        uint256[] memory amounts;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ETH) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawETH(amounts[0]);\n            } else if (protocol == Protocol.ERC20) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawERC20(IERC20(note.token), amounts[0]);\n            } else if (protocol == Protocol.ERC721) {\n                ids = note.ids;\n                _withdrawERC721s(IERC721(note.token), ids);\n            } else if (protocol == Protocol.ERC1155) {\n                ids = note.ids;\n                amounts = note.amounts;\n                _withdrawERC1155s(IERC1155(note.token), ids, amounts);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw ETH from this contract to the msg.sender\n    // @param amount The amount of ETH to be withdrawn\n    function withdrawETH(uint256 amount) external isPermitted(OWNER_ROLE) {\n        _withdrawETH(amount);\n    }\n\n    // @notice Withdraw ERC20s\n    // @param erc20s An array of erc20 addresses\n    // @param amounts An array of amounts for each erc20\n    function withdrawERC20s(\n        IERC20[] memory erc20s,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        uint256 length = erc20s.length;\n        if (amounts.length != length) revert InvalidArrayLength();\n        for (uint256 i; i < length; ) {\n            _withdrawERC20(erc20s[i], amounts[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw multiple ERC721 ids for a single ERC721 contract\n    // @param erc721 The address of the ERC721 contract\n    // @param ids An array of ids that are to be withdrawn\n    function withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC721s(erc721, ids);\n    }\n\n    // @notice Withdraw multiple ERC1155 ids for a single ERC1155 contract\n    // @param erc1155 The address of the ERC155 contract\n    // @param ids An array of ids that are to be withdrawn\n    // @param amounts An array of amounts per id\n    function withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC1155s(erc1155, ids, amounts);\n    }\n\n    // @notice Revoke approval on an array of assets and operators\n    // @dev Works for ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, and array of operators\n    function revokeApprovals(ApprovalNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        ApprovalNote memory note;\n        Protocol protocol;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ERC20) {\n                _revokeERC20Approvals(IERC20(note.token), note.operators);\n            } else if (protocol == Protocol.ERC721) {\n                _revokeERC721Approvals(IERC721(note.token), note.operators);\n            } else if (protocol == Protocol.ERC1155) {\n                _revokeERC1155Approvals(IERC1155(note.token), note.operators);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Revoke approval of an ERC20 for an array of operators\n    // @param erc20 The address of the ERC20 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC20Approvals(erc20, operators);\n    }\n\n    // @notice Revoke approval of an ERC721 for an array of operators\n    // @param erc721 The address of the ERC721 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC721Approvals(\n        IERC721 erc721,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC721Approvals(erc721, operators);\n    }\n\n    // @notice Revoke approval of an ERC1155 for an array of operators\n    // @param erc1155 The address of the ERC1155 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC1155Approvals(\n        IERC1155 erc1155,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC1155Approvals(erc1155, operators);\n    }\n\n    ////////////////////////////////////////////////////\n    // Internal functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    function _withdrawETH(uint256 amount) internal {\n        (bool success, ) = msg.sender.call{ value : amount }(\"\");\n        if (!success) revert WithdrawFailed();\n    }\n\n    function _withdrawERC20(\n        IERC20 erc20,\n        uint256 amount\n    ) internal {\n        erc20.safeTransfer(msg.sender, amount);\n    }\n\n    function _withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) internal {\n        uint256 length = ids.length;\n        for (uint256 i; i < length; ) {\n            erc721.safeTransferFrom(address(this), msg.sender, ids[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    function _withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        // safeBatchTransferFrom will validate the array lengths\n        erc1155.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n    }\n\n    function _revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;"
    }
  ]
}