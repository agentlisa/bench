{
  "Title": "Some tokens may cause `GMXEmergency:emergencyWithdraw` to revert if the withdrawn amount is 0",
  "Content": "# Some tokens may cause `GMXEmergency:emergencyWithdraw` to revert if the withdrawn amount is 0\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXEmergency.sol#L162-L202\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXEmergency.sol#L162-L202</a>\n\n\n## Summary\n\nTokens that don't allow 0 amount transfers could cause `GMXEmergency:emergencyWithdraw` to misbehave.\n\n## Vulnerability Details\n\nWhen the vault is closed users may call `emergencyWithdraw` to withdraw a portion of tokenA/B from the vault based on their share balance.\n\nIf one of the tokens is a token that does not allow 0 amount transfers and the balance of the token in the vault is small enough to make amount to be withdrawn == 0 then `emergencyWithdraw` may revert and prevent the user from withdrawing.\n\nTokens may be sent to the vault directly so that the withdraw amount is more than 0 but unless the user is the last to withdraw, the tokens sent are shared among other users that hold shares.\n\n## Impact\n\nUsers may be unable to withdraw or need to send tokens to the vault and lose a portion of it so that withdrawing becomes possible.\n\n## Tools Used\n\n## Recommendations\n\nConsider checking that the amount to withdraw is > 0 before attempting to transfer the tokens.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    }
  ]
}