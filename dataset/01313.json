{
  "Title": "Retrieving Escrow Account Details via Signers Can Be Misleading",
  "Content": "The `[getEscrowAccountFromSignerAddress](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/blob/d8795c747d44da90f7717b3db9a08698e64a9b2f/src/Escrow.sol#L424)` function accepts a `signer` as its argument and subsequently infers the `sender` address to return the amount of `EscrowAccount` deposited by the `sender` to the `receiver`. If a signer is revoked by the sender, the function will return 0 despite the fact that there could be non-zero amounts in escrow left for the `receiver` by the `sender`.\n\n\nConsider reverting with an error message indicating that the signer is no longer authorized.\n\n\n***Update:** Resolved in [pull request #53](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/pull/53). The Graph's core developersÂ stated:*\n\n\n\n> *It was previously ambiguous as to whether `getEscrowAccountFromSignerAddress` returned zero values because the account is empty or the signer is not actually authorized (possibly revoked). This fixes that by reverting with a custom error if the signer is not authorized. The associated issue can be found [here](https://github.com/semiotic-ai/timeline-aggregation-protocol-contracts/issues/39).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/Escrow.sol",
      "content": "// Copyright 2023-, Semiotic AI, Inc.\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {TAPVerifier} from \"./TAPVerifier.sol\";\nimport {AllocationIDTracker} from \"./AllocationIDTracker.sol\";\nimport {IStaking} from \"./IStaking.sol\";\n\n/**\n * @title Escrow\n * @dev This contract allows `senders` to deposit escrow for specific `receivers`,\n *      which can later be redeemed using Receipt Aggregate Vouchers (`RAV`) signed\n *      by an authorized `signer`. `Senders` can deposit escrow for `receivers`,\n *      authorize `signers` to create signed `RAVs`, and withdraw escrow after a\n *      set `thawingPeriod` number of seconds. `Receivers` can redeem signed `RAVs` to\n *      claim escrow.\n * @notice This contract uses the `TAPVerifier` contract for recovering signer addresses\n *         from `RAVs`.\n */\ncontract Escrow {\n    using SafeERC20 for IERC20;\n\n    struct EscrowAccount {\n        uint256 balance; // Total escrow balance for a sender-receiver pair\n        uint256 amountThawing; // Amount of escrow currently being thawed\n        uint256 thawEndTimestamp; // Block number at which thawing period ends (zero if not thawing)\n    }\n\n    struct SenderAuthorization {\n        address sender; // Sender the signer is authorized to sign for\n        uint256 thawEndTimestamp; // Block number at which thawing period ends (zero if not thawing)\n    }\n\n    // Stores how much escrow each sender has deposited for each receiver, as well as thawing information\n    mapping(address sender => mapping(address reciever => EscrowAccount escrowAccount))\n        public escrowAccounts;\n    // Map of signer to authorized signer information\n    mapping(address signer => SenderAuthorization authorizedSigner)\n        public authorizedSigners;\n\n    // The ERC20 token used for escrow\n    IERC20 public immutable escrowToken;\n\n    // Graph staking contract\n    IStaking public immutable staking;\n\n    // The contract used for verifying receipt aggregate vouchers\n    TAPVerifier public immutable tapVerifier;\n\n    // The contract used for tracking used allocation IDs\n    AllocationIDTracker public immutable allocationIDTracker;\n\n    // The duration (in seconds) in which escrow funds are thawing before they can be withdrawn\n    uint256 public immutable withdrawEscrowThawingPeriod;\n\n    // The duration (in seconds) in which a signer is thawing before they can be revoked\n    uint256 public immutable revokeSignerThawingPeriod;\n\n    // Custom error to indicate insufficient escrow balance\n    error InsufficientEscrow(uint256 available, uint256 required);\n\n    // Custom error to indicate escrow is still thawing\n    error EscrowStillThawing(\n        uint256 currentTimestamp,\n        uint256 thawEndTimestamp\n    );\n\n    // Custom error to indicate escrow thawing has not been initiated\n    error EscrowNotThawing();\n\n    // Custom error to indicate invalid signer proof\n    error InvalidSignerProof();\n\n    // Custom error to indicate provided signer is not one of provided senders authorized signers\n    error SignerNotAuthorizedBySender(address signer, address sender);\n\n    // Custom error to indicate signer already authorized\n    error SignerAlreadyAuthorized(address signer, address authorizingSender);\n\n    // Custom error to indicate signer is still thawing\n    error SignerStillThawing(\n        uint256 currentTimestamp,\n        uint256 thawEndTimestamp\n    );\n\n    // Custom error to indicate signer thawing has not been initiated\n    error SignerNotThawing();\n\n    // Custom error to indicate invalid RAV signer\n    error InvalidRAVSigner();\n\n    /**\n     * @dev Emitted when escrow is deposited for a receiver.\n     */\n    event Deposit(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when escrow is redeemed by a receiver.\n     * @notice If the actual amount redeemed is less than the expected amount,\n     *         there was insufficient escrow available to redeem.\n     */\n    event Redeem(\n        address indexed sender,\n        address indexed receiver,\n        address indexed allocationID,\n        uint256 expectedAmount,\n        uint256 actualAmount\n    );\n\n    /**\n     * @dev Emitted when a thaw request is made for escrow.\n     */\n    event Thaw(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount,\n        uint256 totalAmountThawing,\n        uint256 thawEndTimestamp\n    );\n\n    /**\n     * @dev Emitted when a thaw request is made for authorized signer\n     */\n    event ThawSigner(\n        address indexed sender,\n        address indexed authorizedSigner,\n        uint256 thawEndTimestamp\n    );\n\n    /**\n     * @dev Emitted when a authorized signer has been revoked\n     */\n    event RevokeAuthorizedSigner(\n        address indexed sender,\n        address indexed authorizedSigner\n    );\n\n    /**\n     * @dev Emitted when thawed escrow is withdrawn by the sender.\n     */\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when a signer is authorized to sign RAVs for a sender.\n     */\n    event AuthorizeSigner(address indexed signer, address indexed sender);\n\n    constructor(\n        address escrowToken_,\n        address staking_,\n        address tapVerifier_,\n        address allocationIDTracker_,\n        uint256 withdrawEscrowThawingPeriod_,\n        uint256 revokeSignerThawingPeriod_\n    ) {\n        escrowToken = IERC20(escrowToken_);\n        staking = IStaking(staking_);\n        tapVerifier = TAPVerifier(tapVerifier_);\n        allocationIDTracker = AllocationIDTracker(allocationIDTracker_);\n        withdrawEscrowThawingPeriod = withdrawEscrowThawingPeriod_;\n        revokeSignerThawingPeriod = revokeSignerThawingPeriod_;\n    }\n\n    /**\n     * @notice Approve the staking contract to pull any amount of tokens from this contract.\n     * @dev Increased gas efficiency instead of approving on each voucher redeem\n     */\n    function approveAll() external {\n        escrowToken.approve(address(staking), type(uint256).max);\n    }\n\n    /**\n     * @dev Deposits escrow for a receiver.\n     * @param receiver Address of the receiver.\n     * @param amount Amount of escrow to deposit.\n     * @notice The escrow must be approved for transfer by the sender.\n     * @notice REVERT: this function will revert if the escrow transfer fails.\n     */\n    function deposit(address receiver, uint256 amount) external {\n        escrowAccounts[msg.sender][receiver].balance += amount;\n        escrowToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Deposit(msg.sender, receiver, amount);\n    }\n\n    /**\n     * @dev Requests to thaw a specific amount of escrow from a receiver's escrow account.\n     * @param receiver Address of the receiver the escrow account is for.\n     * @param amount Amount of escrow to thaw.\n     * @notice REVERT with error:\n     *               - InsufficientEscrow: if the sender receiver escrow account does\n     *                 not have enough escrow (greater than `amount`)\n     */\n    function thaw(address receiver, uint256 amount) external {\n        EscrowAccount storage account = escrowAccounts[msg.sender][\n            receiver\n        ];\n        uint256 totalThawingRequested = account.amountThawing + amount;\n\n        // Check if the escrow balance is sufficient\n        if (account.balance < totalThawingRequested) {\n            revert InsufficientEscrow({\n                available: account.balance,\n                required: totalThawingRequested\n            });\n        }\n\n        // Increase the amount being thawed\n        account.amountThawing = totalThawingRequested;\n        // Set when the thaw is complete (thawing period number of seconds after current timestamp)\n        account.thawEndTimestamp =\n            block.timestamp +\n            withdrawEscrowThawingPeriod;\n\n        emit Thaw(\n            msg.sender,\n            receiver,\n            amount,\n            account.amountThawing,\n            account.thawEndTimestamp\n        );\n    }\n\n    /**\n     * @dev Withdraws all thawed escrow from a receiver's escrow account.\n     * @param receiver Address of the receiver.\n     * @notice REVERT with error:\n     *               - EscrowNotThawing: There is no escrow currently thawing\n     *               - EscrowStillThawing: ThawEndTimestamp has not been reached\n     *                 for escrow currently thawing\n     */\n    function withdraw(address receiver) external {\n        EscrowAccount storage account = escrowAccounts[msg.sender][\n            receiver\n        ];\n        if (account.thawEndTimestamp == 0) {\n            revert EscrowNotThawing();\n        }\n\n        if (account.thawEndTimestamp > block.timestamp) {\n            revert EscrowStillThawing({\n                currentTimestamp: block.timestamp,\n                thawEndTimestamp: account.thawEndTimestamp\n            });\n        }\n\n        // Amount is the minimum between the amount being thawed and the actual balance\n        uint256 amount = account.amountThawing > account.balance\n            ? account.balance\n            : account.amountThawing;\n\n        unchecked {\n            account.balance -= amount; // Reduce the balance by the withdrawn amount (no underflow risk)\n        }\n        account.amountThawing = 0;\n        account.thawEndTimestamp = 0;\n        escrowToken.safeTransfer(msg.sender, amount);\n        emit Withdraw(msg.sender, receiver, amount);\n    }\n\n    /**\n     * @dev Authorizes a signer to sign RAVs for the sender.\n     * @param signer Address of the authorized signer.\n     * @param proof The proof provided by the signer to authorize the sender.\n     * @notice REVERT with error:\n     *               - SignerAlreadyAuthorized: Signer is currently authorized for a sender\n     *               - InvalidSignerProof: The provided signer proof is invalid\n     */\n    function authorizeSigner(address signer, bytes calldata proof) external {\n        if (authorizedSigners[signer].sender != address(0)) {\n            revert SignerAlreadyAuthorized(\n                signer,\n                authorizedSigners[signer].sender\n            );\n        }\n\n        verifyAuthorizedSignerProof(proof, signer);\n\n        authorizedSigners[signer].sender = msg.sender;\n        authorizedSigners[signer].thawEndTimestamp = 0;\n        emit AuthorizeSigner(signer, msg.sender);\n    }\n\n    /**\n     * @dev Starts thawing a signer to be removed from the authorized signers list.\n     * @param signer Address of the signer to remove.\n     * @notice REVERT with error:\n     *               - SignerNotAuthorizedBySender: The provided signer is either not authorized or\n     *                 authorized by a different sender\n     */\n    function thawSigner(address signer) external {\n        SenderAuthorization storage authorization = authorizedSigners[signer];\n\n        if (authorization.sender != msg.sender) {\n            revert SignerNotAuthorizedBySender(\n                signer,\n                authorizedSigners[signer].sender\n            );\n        }\n\n        authorization.thawEndTimestamp =\n            block.timestamp +\n            revokeSignerThawingPeriod;\n        emit ThawSigner(\n            authorization.sender,\n            signer,\n            authorization.thawEndTimestamp\n        );\n    }\n\n    /**\n     * @dev Revokes a signer from the authorized signers list if thawed.\n     * @param signer Address of the signer to remove.\n     * @notice REVERT with error:\n     *               - SignerNotAuthorizedBySender: The provided signer is either not authorized or\n     *                 authorized by a different sender\n     *               - SignerNotThawing: No thaw was initiated for the provided signer\n     *               - SignerStillThawing: ThawEndTimestamp has not been reached\n     *                 for provided signer\n     */\n    function revokeAuthorizedSigner(address signer) external {\n        SenderAuthorization storage authorization = authorizedSigners[signer];\n\n        if (authorization.sender != msg.sender) {\n            revert SignerNotAuthorizedBySender(\n                signer,\n                authorizedSigners[signer].sender\n            );\n        }\n\n        if (authorization.thawEndTimestamp == 0) {\n            revert SignerNotThawing();\n        }\n\n        if (authorization.thawEndTimestamp > block.timestamp) {\n            revert SignerStillThawing({\n                currentTimestamp: block.timestamp,\n                thawEndTimestamp: authorization.thawEndTimestamp\n            });\n        }\n\n        delete authorizedSigners[signer];\n        emit RevokeAuthorizedSigner(authorization.sender, signer);\n    }\n\n    /**\n     * @dev Redeems escrow (up to amount available in escrow) for a receiver using a signed RAV.\n     * @param signedRAV Signed RAV containing the receiver and escrow amount.\n     * @param allocationIDProof Proof of allocationID ownership.\n     * @notice REVERT: This function may revert if ECDSA.recover fails, check Open Zeppelin ECDSA library for details.\n     * @notice REVERT with error:\n     *               - InvalidRAVSigner: If the RAV is signed by a signer who is not authorized by any sender\n     *               - AllocationIDTracker.AllocationIDPreviouslyClaimed: If the allocation ID was previously claimed\n     *               - AllocationIDTracker.InvalidProof: If the allocation ID ownership proof is not valid\n     */\n    function redeem(\n        TAPVerifier.SignedRAV calldata signedRAV,\n        bytes calldata allocationIDProof\n    ) external {\n        address signer = tapVerifier.recoverRAVSigner(signedRAV);\n\n        if (authorizedSigners[signer].sender == address(0)) {\n            revert InvalidRAVSigner();\n        }\n\n        address sender = authorizedSigners[signer].sender;\n        address receiver = msg.sender;\n        address allocationId = signedRAV.rav.allocationId;\n\n        // Amount is the minimum between the amount owed on rav and the actual balance\n        uint256 amount = signedRAV.rav.valueAggregate >\n            escrowAccounts[sender][receiver].balance\n            ? escrowAccounts[sender][receiver].balance\n            : signedRAV.rav.valueAggregate;\n\n        unchecked {\n            escrowAccounts[sender][receiver].balance -= amount;\n        }\n\n        allocationIDTracker.useAllocationID(\n            sender,\n            allocationId,\n            allocationIDProof\n        );\n        staking.collect(amount, allocationId);\n        emit Redeem(\n            sender,\n            msg.sender,\n            signedRAV.rav.allocationId,\n            signedRAV.rav.valueAggregate,\n            amount\n        );\n    }\n\n    /**\n     * @dev Retrieves the amount of escrow deposited by a sender for a receiver.\n     * @param sender Address of the sender.\n     * @param receiver Address of the receiver.\n     * @return The amount of escrow deposited.\n     */\n    function getEscrowAmount(\n        address sender,\n        address receiver\n    ) external view returns (uint256) {\n        return escrowAccounts[sender][receiver].balance;\n    }\n\n    /**\n     * @dev Retrieves the escrow account details for a sender-receiver pair of the sender that a signer is authorized for.\n     * @param signer Address of the authorized signer.\n     * @param receiver Address of the receiver.\n     * @return The escrow account details.\n     */\n    function getEscrowAccountFromSignerAddress(\n        address signer,\n        address receiver\n    ) external view returns (EscrowAccount memory) {\n        return escrowAccounts[authorizedSigners[signer].sender][receiver];\n    }\n\n    /**\n     * @dev Verifies a proof that authorizes the sender to authorize the signer.\n     * @param proof The proof provided by the signer to authorize the sender.\n     * @param signer The address of the signer being authorized.\n     * @notice REVERT with error:\n     *               - InvalidSignerProof: If the given proof is not valid\n     */\n    function verifyAuthorizedSignerProof(\n        bytes calldata proof,\n        address signer\n    ) private view {\n        // Generate the hash of the sender's address\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender));\n\n        // Generate the digest to be signed by the signer\n        bytes32 digest = ECDSA.toEthSignedMessageHash(messageHash);\n\n        // Verify that the recovered signer matches the expected signer\n        if (ECDSA.recover(digest, proof) != signer) {\n            revert InvalidSignerProof();\n        }\n    }\n}"
    }
  ]
}