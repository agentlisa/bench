{
  "Title": "[N-03] Fragile check for contract order type",
  "Content": "\nThe `OrderType` enum defines five order types. Only one of these represents contract orders:\n\n[`ConsiderationEnums.sol`](https://github.com/horsefacts/seaport/blob/5de7302bc773d9821ba4759e47fc981680911ea0/contracts/lib/ConsiderationEnums.sol#L5-L20):\n\n```solidity\nenum OrderType {\n    // 0: no partial fills, anyone can execute\n    FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    PARTIAL_RESTRICTED,\n\n    // 4: contract order type\n    CONTRACT\n}\n```\n\n[`OrderCombiner#_validateOrdersAndPrepareToFulfill`](https://github.com/horsefacts/seaport/blob/5de7302bc773d9821ba4759e47fc981680911ea0/contracts/lib/OrderCombiner.sol#L286-L295) defines non-contract orders as any order with a type less than 4:\n\n```solidity\n                {\n                    // Create a variable indicating if the order is not a\n                    // contract order. Cache in scratch space to avoid stack\n                    // depth errors.\n                    OrderType orderType = advancedOrder.parameters.orderType;\n                    assembly {\n                        let isNonContract := lt(orderType, 4)\n                        mstore(0, isNonContract)\n                    }\n                }\n```\n\nThis is fine for now, but could be fragile: if an additional type is added in the future, it may break this implicit assumption. Consider checking for an exact match against order type 4, which is more robust:\n\n```solidity\n                {\n                    // Create a variable indicating if the order is not a\n                    // contract order. Cache in scratch space to avoid stack\n                    // depth errors.\n                    OrderType orderType = advancedOrder.parameters.orderType;\n                    assembly {\n                        let isNonContract := iszero(eq(orderType, 4))\n                        mstore(0, isNonContract)\n                    }\n                }\n```\n\n[`OrderFulfiller#_applyFractionsAndTransferEach`](https://github.com/horsefacts/seaport/blob/5de7302bc773d9821ba4759e47fc981680911ea0/contracts/lib/OrderFulfiller.sol#L258-L271) performs a similar check using `lt(orderType, 4)`:\n\n```solidity\n            // If non-contract order has native offer items, throw InvalidNativeOfferItem.\n            {\n                OrderType orderType = orderParameters.orderType;\n                uint256 invalidNativeOfferItem;\n                assembly {\n                    invalidNativeOfferItem := and(\n                        lt(orderType, 4),\n                        anyNativeItems\n                    )\n                }\n                if (invalidNativeOfferItem != 0) {\n                    _revertInvalidNativeOfferItem();\n                }\n            }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-opensea",
  "Code": [
    {
      "filename": "contracts/lib/ConsiderationEnums.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n// prettier-ignore\nenum OrderType {\n    // 0: no partial fills, anyone can execute\n    FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    PARTIAL_RESTRICTED,\n\n    // 4: contract order type\n    CONTRACT\n}\n\n// prettier-ignore\nenum BasicOrderType {\n    // 0: no partial fills, anyone can execute\n    ETH_TO_ERC721_FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    ETH_TO_ERC721_PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC721_FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 4: no partial fills, anyone can execute\n    ETH_TO_ERC1155_FULL_OPEN,\n\n    // 5: partial fills supported, anyone can execute\n    ETH_TO_ERC1155_PARTIAL_OPEN,\n\n    // 6: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC1155_FULL_RESTRICTED,\n\n    // 7: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 8: no partial fills, anyone can execute\n    ERC20_TO_ERC721_FULL_OPEN,\n\n    // 9: partial fills supported, anyone can execute\n    ERC20_TO_ERC721_PARTIAL_OPEN,\n\n    // 10: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC721_FULL_RESTRICTED,\n\n    // 11: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 12: no partial fills, anyone can execute\n    ERC20_TO_ERC1155_FULL_OPEN,\n\n    // 13: partial fills supported, anyone can execute\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\n\n    // 14: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\n\n    // 15: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 16: no partial fills, anyone can execute\n    ERC721_TO_ERC20_FULL_OPEN,\n\n    // 17: partial fills supported, anyone can execute\n    ERC721_TO_ERC20_PARTIAL_OPEN,\n\n    // 18: no partial fills, only offerer or zone can execute\n    ERC721_TO_ERC20_FULL_RESTRICTED,\n\n    // 19: partial fills supported, only offerer or zone can execute\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\n\n    // 20: no partial fills, anyone can execute\n    ERC1155_TO_ERC20_FULL_OPEN,\n\n    // 21: partial fills supported, anyone can execute\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\n\n    // 22: no partial fills, only offerer or zone can execute\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\n\n    // 23: partial fills supported, only offerer or zone can execute\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\n}\n\n// prettier-ignore\nenum BasicOrderRouteType {\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\n    ETH_TO_ERC721,\n\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\n    ETH_TO_ERC1155,\n\n    // 2: provide ERC20 item to receive offered ERC721 item.\n    ERC20_TO_ERC721,\n\n    // 3: provide ERC20 item to receive offered ERC1155 item.\n    ERC20_TO_ERC1155,\n\n    // 4: provide ERC721 item to receive offered ERC20 item.\n    ERC721_TO_ERC20,\n\n    // 5: provide ERC1155 item to receive offered ERC20 item.\n    ERC1155_TO_ERC20\n}\n\n// prettier-ignore\nenum ItemType {\n    // 0: ETH on mainnet, MATIC on polygon, etc.\n    NATIVE,\n\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n    ERC20,\n\n    // 2: ERC721 items\n    ERC721,\n\n    // 3: ERC1155 items\n    ERC1155,\n\n    // 4: ERC721 items where a number of tokenIds are supported\n    ERC721_WITH_CRITERIA,\n\n    // 5: ERC1155 items where a number of ids are supported\n    ERC1155_WITH_CRITERIA\n}\n\n// prettier-ignore\nenum Side {\n    // 0: Items that can be spent\n    OFFER,\n\n    // 1: Items that must be received\n    CONSIDERATION\n}"
    },
    {
      "filename": "contracts/lib/OrderCombiner.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Side, ItemType, OrderType } from \"./ConsiderationEnums.sol\";\n\nimport {\n    OfferItem,\n    ConsiderationItem,\n    ReceivedItem,\n    OrderParameters,\n    Fulfillment,\n    FulfillmentComponent,\n    Execution,\n    Order,\n    AdvancedOrder,\n    CriteriaResolver\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderFulfiller } from \"./OrderFulfiller.sol\";\n\nimport { FulfillmentApplier } from \"./FulfillmentApplier.sol\";\n\nimport \"./ConsiderationErrors.sol\";\n\n/**\n * @title OrderCombiner\n * @author 0age\n * @notice OrderCombiner contains logic for fulfilling combinations of orders,\n *         either by matching offer items to consideration items or by\n *         fulfilling orders where available.\n */\ncontract OrderCombiner is OrderFulfiller, FulfillmentApplier {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderFulfiller(conduitController) {}\n\n    /**\n     * @notice Internal function to attempt to fill a group of orders, fully or\n     *         partially, with an arbitrary number of items for offer and\n     *         consideration per order alongside criteria resolvers containing\n     *         specific token identifiers and associated proofs. Any order that\n     *         is not currently active, has already been fully filled, or has\n     *         been cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or a conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used (and\n     *                                  direct approvals set on Consideration).\n     * @param recipient                 The intended recipient for all received\n     *                                  items.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        FulfillmentComponent[][] memory offerFulfillments,\n        FulfillmentComponent[][] memory considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        internal\n        returns (\n            bool[] memory /* availableOrders */,\n            Execution[] memory /* executions */\n        )\n    {\n        // Validate orders, apply amounts, & determine if they utilize conduits.\n        bytes32[] memory orderHashes = _validateOrdersAndPrepareToFulfill(\n            advancedOrders,\n            criteriaResolvers,\n            false, // Signifies that invalid orders should NOT revert.\n            maximumFulfilled,\n            recipient\n        );\n\n        // Aggregate used offer and consideration items and execute transfers.\n        return\n            _executeAvailableFulfillments(\n                advancedOrders,\n                offerFulfillments,\n                considerationFulfillments,\n                fulfillerConduitKey,\n                recipient,\n                orderHashes\n            );\n    }\n\n    /**\n     * @dev Internal function to validate a group of orders, update their\n     *      statuses, reduce amounts by their previously filled fractions, apply\n     *      criteria resolvers, and emit OrderFulfilled events. Note that this\n     *      function needs to be called before\n     *      _aggregateValidFulfillmentConsiderationItems to set the memory\n     *      layout that _aggregateValidFulfillmentConsiderationItems depends on.\n     *\n     * @param advancedOrders    The advanced orders to validate and reduce by\n     *                          their previously filled amounts.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          a root of zero indicates that any transferable\n     *                          token identifier is valid and that no proof\n     *                          needs to be supplied.\n     * @param revertOnInvalid   A boolean indicating whether to revert on any\n     *                          order being invalid; setting this to false will\n     *                          instead cause the invalid order to be skipped.\n     * @param maximumFulfilled  The maximum number of orders to fulfill.\n     * @param recipient         The intended recipient for all items that do not\n     *                          already have a designated recipient and are not\n     *                          already used as part of a provided fulfillment.\n     *\n     * @return orderHashes      The hashes of the orders being fulfilled.\n     */\n    function _validateOrdersAndPrepareToFulfill(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        bool revertOnInvalid,\n        uint256 maximumFulfilled,\n        address recipient\n    ) internal returns (bytes32[] memory orderHashes) {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard(true); // Native tokens accepted during execution.\n\n        // Declare an error buffer indicating status of any native offer items.\n        // Note that contract orders may still designate native offer items.\n        // {00} == 0 => In a match function, no native offer items: allow.\n        // {01} == 1 => In a match function, some native offer items: allow.\n        // {10} == 2 => Not in a match function, no native offer items: allow.\n        // {11} == 3 => Not in a match function, some native offer items: THROW.\n        uint256 invalidNativeOfferItemErrorBuffer;\n\n        // Use assembly to set the value for the second bit of the error buffer.\n        assembly {\n            /**\n             * Use the 231st bit of the error buffer to indicate whether the\n             * current function is not matchAdvancedOrders or matchOrders.\n             *\n             * sig                                func\n             * -----------------------------------------------------------------\n             * 1010100000010111010001000 0 000100 matchOrders\n             * 1111001011010001001010110 0 010010 matchAdvancedOrders\n             * 1110110110011000101001010 1 110100 fulfillAvailableOrders\n             * 1000011100100000000110110 1 000001 fulfillAvailableAdvancedOrders\n             *                           ^ 7th bit\n             */\n            invalidNativeOfferItemErrorBuffer := and(\n                NonMatchSelector_MagicMask,\n                calldataload(0)\n            )\n        }\n\n        // Declare variables for later use.\n        AdvancedOrder memory advancedOrder;\n        uint256 terminalMemoryOffset;\n\n        unchecked {\n            // Read length of orders array and place on the stack.\n            uint256 totalOrders = advancedOrders.length;\n\n            // Track the order hash for each order being fulfilled.\n            orderHashes = new bytes32[](totalOrders);\n\n            // Determine the memory offset to terminate on during loops.\n            terminalMemoryOffset = (totalOrders + 1) * 32;\n        }\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Declare inner variables.\n            OfferItem[] memory offer;\n            ConsiderationItem[] memory consideration;\n\n            // Iterate over each order.\n            for (uint256 i = 32; i < terminalMemoryOffset; i += 32) {\n                // Retrieve order using assembly to bypass out-of-range check.\n                assembly {\n                    advancedOrder := mload(add(advancedOrders, i))\n                }\n\n                // Determine if max number orders have already been fulfilled.\n                if (maximumFulfilled == 0) {\n                    // Mark fill fraction as zero as the order will not be used.\n                    advancedOrder.numerator = 0;\n\n                    // Continue iterating through the remaining orders.\n                    continue;\n                }\n\n                // Validate it, update status, and determine fraction to fill.\n                (\n                    bytes32 orderHash,\n                    uint256 numerator,\n                    uint256 denominator\n                ) = _validateOrderAndUpdateStatus(\n                        advancedOrder,\n                        revertOnInvalid\n                    );\n\n                // Do not track hash or adjust prices if order is not fulfilled.\n                if (numerator == 0) {\n                    // Mark fill fraction as zero if the order is not fulfilled.\n                    advancedOrder.numerator = 0;\n\n                    // Continue iterating through the remaining orders.\n                    continue;\n                }\n\n                // Otherwise, track the order hash in question.\n                assembly {\n                    mstore(add(orderHashes, i), orderHash)\n                }\n\n                // Decrement the number of fulfilled orders.\n                // Skip underflow check as the condition before\n                // implies that maximumFulfilled > 0.\n                maximumFulfilled--;\n\n                // Place the start time for the order on the stack.\n                uint256 startTime = advancedOrder.parameters.startTime;\n\n                // Place the end time for the order on the stack.\n                uint256 endTime = advancedOrder.parameters.endTime;\n\n                // Retrieve array of offer items for the order in question.\n                offer = advancedOrder.parameters.offer;\n\n                // Read length of offer array and place on the stack.\n                uint256 totalOfferItems = offer.length;\n\n                {\n                    // Create a variable indicating if the order is not a\n                    // contract order. Cache in scratch space to avoid stack\n                    // depth errors.\n                    OrderType orderType = advancedOrder.parameters.orderType;\n                    assembly {\n                        let isNonContract := lt(orderType, 4)\n                        mstore(0, isNonContract)\n                    }\n                }\n\n                // Iterate over each offer item on the order.\n                for (uint256 j = 0; j < totalOfferItems; ++j) {\n                    // Retrieve the offer item.\n                    OfferItem memory offerItem = offer[j];\n\n                    {\n                        assembly {\n                            // If the offer item is for the native token and the\n                            // order type is not a contract order type, set the\n                            // first bit of the error buffer to true.\n                            invalidNativeOfferItemErrorBuffer := or(\n                                invalidNativeOfferItemErrorBuffer,\n                                lt(mload(offerItem), mload(0))\n                            )\n                        }\n                    }\n\n                    // Apply order fill fraction to offer item end amount.\n                    uint256 endAmount = _getFraction(\n                        numerator,\n                        denominator,\n                        offerItem.endAmount\n                    );\n\n                    // Reuse same fraction if start and end amounts are equal.\n                    if (offerItem.startAmount == offerItem.endAmount) {\n                        // Apply derived amount to both start and end amount.\n                        offerItem.startAmount = endAmount;\n                    } else {\n                        // Apply order fill fraction to offer item start amount.\n                        offerItem.startAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            offerItem.startAmount\n                        );\n                    }\n\n                    // Adjust offer amount using current time; round down.\n                    uint256 currentAmount = _locateCurrentAmount(\n                        offerItem.startAmount,\n                        endAmount,\n                        startTime,\n                        endTime,\n                        false // round down\n                    );\n\n                    // Update amounts in memory to match the current amount.\n                    // Note that the end amount is used to track spent amounts.\n                    offerItem.startAmount = currentAmount;\n                    offerItem.endAmount = currentAmount;\n                }\n\n                // Retrieve array of consideration items for order in question.\n                consideration = (advancedOrder.parameters.consideration);\n\n                // Read length of consideration array and place on the stack.\n                uint256 totalConsiderationItems = consideration.length;\n\n                // Iterate over each consideration item on the order.\n                for (uint256 j = 0; j < totalConsiderationItems; ++j) {\n                    // Retrieve the consideration item.\n                    ConsiderationItem memory considerationItem = (\n                        consideration[j]\n                    );\n\n                    // Apply fraction to consideration item end amount.\n                    uint256 endAmount = _getFraction(\n                        numerator,\n                        denominator,\n                        considerationItem.endAmount\n                    );\n\n                    // Reuse same fraction if start and end amounts are equal.\n                    if (\n                        considerationItem.startAmount ==\n                        considerationItem.endAmount\n                    ) {\n                        // Apply derived amount to both start and end amount.\n                        considerationItem.startAmount = endAmount;\n                    } else {\n                        // Apply fraction to consideration item start amount.\n                        considerationItem.startAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            considerationItem.startAmount\n                        );\n                    }\n\n                    // Adjust consideration amount using current time; round up.\n                    uint256 currentAmount = (\n                        _locateCurrentAmount(\n                            considerationItem.startAmount,\n                            endAmount,\n                            startTime,\n                            endTime,\n                            true // round up\n                        )\n                    );\n\n                    considerationItem.startAmount = currentAmount;\n\n                    // Utilize assembly to manually \"shift\" the recipient value,\n                    // then to copy the start amount to the recipient.\n                    // Note that this sets up the memory layout that is\n                    // subsequently relied upon by\n                    // _aggregateValidFulfillmentConsiderationItems.\n                    assembly {\n                        // Derive the pointer to the recipient using the item\n                        // pointer along with the offset to the recipient.\n                        let considerationItemRecipient := add(\n                            considerationItem,\n                            ConsiderationItem_recipient_offset // recipient\n                        )\n\n                        // Write recipient to endAmount, as endAmount is not\n                        // used from this point on and can be repurposed to fit\n                        // the layout of a ReceivedItem.\n                        mstore(\n                            add(\n                                considerationItem,\n                                ReceivedItem_recipient_offset // old endAmount\n                            ),\n                            mload(considerationItemRecipient)\n                        )\n\n                        // Write startAmount to recipient, as recipient is not\n                        // used from this point on and can be repurposed to\n                        // track received amounts.\n                        mstore(considerationItemRecipient, currentAmount)\n                    }\n                }\n            }\n        }\n\n        // If the first bit is set, a native offer item was encountered. If the\n        // second bit is set in the error buffer, the current function is not\n        // matchOrders or matchAdvancedOrders. If the value is three, both the\n        // first and second bits were set; in that case, revert with an error.\n        if (\n            invalidNativeOfferItemErrorBuffer ==\n            NonMatchSelector_InvalidErrorValue\n        ) {\n            _revertInvalidNativeOfferItem();\n        }\n\n        // Apply criteria resolvers to each order as applicable.\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\n\n        // Emit an event for each order signifying that it has been fulfilled.\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            bytes32 orderHash;\n\n            // Iterate over each order.\n            for (uint256 i = 32; i < terminalMemoryOffset; i += 32) {\n                assembly {\n                    orderHash := mload(add(orderHashes, i))\n                }\n\n                // Do not emit an event if no order hash is present.\n                if (orderHash == bytes32(0)) {\n                    continue;\n                }\n\n                // Retrieve order using assembly to bypass out-of-range check.\n                assembly {\n                    advancedOrder := mload(add(advancedOrders, i))\n                }\n\n                // Retrieve parameters for the order in question.\n                OrderParameters memory orderParameters = (\n                    advancedOrder.parameters\n                );\n\n                // Emit an OrderFulfilled event.\n                _emitOrderFulfilledEvent(\n                    orderHash,\n                    orderParameters.offerer,\n                    orderParameters.zone,\n                    recipient,\n                    orderParameters.offer,\n                    orderParameters.consideration\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to fulfill a group of validated orders, fully or\n     *      partially, with an arbitrary number of items for offer and\n     *      consideration per order and to execute transfers. Any order that is\n     *      not currently active, has already been fully filled, or has been\n     *      cancelled will be omitted. Remaining offer and consideration items\n     *      will then be aggregated where possible as indicated by the supplied\n     *      offer and consideration component arrays and aggregated items will\n     *      be transferred to the fulfiller or to each intended recipient,\n     *      respectively. Note that a failing item transfer or an issue with\n     *      order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or the conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on Consideration.\n     * @param recipient                 The intended recipient for all items\n     *                                  that do not already have a designated\n     *                                  recipient and are not already used as\n     *                                  part of a provided fulfillment.\n     * @param orderHashes               An array of order hashes for each order.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _executeAvailableFulfillments(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[][] memory offerFulfillments,\n        FulfillmentComponent[][] memory considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        bytes32[] memory orderHashes\n    )\n        internal\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Retrieve length of offer fulfillments array and place on the stack.\n        uint256 totalOfferFulfillments = offerFulfillments.length;\n\n        // Retrieve length of consideration fulfillments array & place on stack.\n        uint256 totalConsiderationFulfillments = (\n            considerationFulfillments.length\n        );\n\n        // Allocate an execution for each offer and consideration fulfillment.\n        executions = new Execution[](\n            totalOfferFulfillments + totalConsiderationFulfillments\n        );\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Track number of filtered executions.\n            uint256 totalFilteredExecutions = 0;\n\n            // Iterate over each offer fulfillment.\n            for (uint256 i = 0; i < totalOfferFulfillments; ) {\n                // Derive aggregated execution corresponding with fulfillment.\n                Execution memory execution = _aggregateAvailable(\n                    advancedOrders,\n                    Side.OFFER,\n                    offerFulfillments[i],\n                    fulfillerConduitKey,\n                    recipient\n                );\n\n                // If offerer and recipient on the execution are the same...\n                if (\n                    _unmaskedAddressComparison(\n                        execution.item.recipient,\n                        execution.offerer\n                    )\n                ) {\n                    // Increment total filtered executions.\n                    ++totalFilteredExecutions;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[i - totalFilteredExecutions] = execution;\n                }\n\n                // Increment iterator.\n                ++i;\n            }\n\n            // Iterate over each consideration fulfillment.\n            for (uint256 i = 0; i < totalConsiderationFulfillments; ) {\n                // Derive aggregated execution corresponding with fulfillment.\n                Execution memory execution = _aggregateAvailable(\n                    advanc"
    }
  ]
}