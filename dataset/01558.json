{
  "Title": "M-5: Use A's staked token balance can be used to mint option token as reward for User B if the payout token equals to the stake token",
  "Content": "# Issue M-5: Use A's staked token balance can be used to mint option token as reward for User B if the payout token equals to the stake token \n\nSource: https://github.com/sherlock-audit/2023-06-bond-judging/issues/83 \n\n## Found by \nctf\\_sec\n## Summary\n\nUser's staked token balance can be used to mint option token as reward if the payout token equals to the stake token, can cause user to loss fund\n\n## Vulnerability Detail\n\nIn OTLM, user can stake stakeToken in exchange for the option token minted from the payment token\n\nwhen staking, we [transfer the stakedToken](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L334) in the OTLM token\n\n```solidity\n// Increase the user's stake balance and the total balance\nstakeBalance[msg.sender] = userBalance + amount_;\ntotalBalance += amount_;\n\n// Transfer the staked tokens from the user to this contract\nstakedToken.safeTransferFrom(msg.sender, address(this), amount_);\n```\n\nbefore the stake or unstake or when we are calling claimReward\n\nwe are calling _claimRewards -> _claimEpochRewards -> we use payout token to mint and [create option token as reward](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L508)\n\n```solidity\n\tpayoutToken.approve(address(optionTeller), rewards);\n\toptionTeller.create(optionToken, rewards);\n\n\t// Transfer rewards to sender\n\tERC20(address(optionToken)).safeTransfer(msg.sender, rewards);\n```\n\nthe problem is, if the stake token and the payout token are the same token, the protocol does not distingush the balance of the stake token and the balance of payout token\n\n**suppose both stake token and payout token are USDC**\n\nsuppose user A stake 100 USDC\n\nsuppose user B stake 100 USDC\n\ntime passed, user B accure 10 token unit reward\n\nnow user B can claimRewards, \n\nthe protocol user 10 USDC to mint option token for B\n\nthe OTLM has 190 USDC \n\nif user A and user B both call emergencyUnstakeAll, whoeve call this function later will suffer a revert and he is not able to even give up the reward and claim their staked balance back\n\nbecause a part of the his staked token balance is treated as the payout token to mint option token reward for other user\n\n## Impact\n\nIf there are insufficient payout token in the OTLM, the expected behavior is that the transaction revert when claim the reward and when the code use payout token to mint option token\n\nand in the worst case, user can call emergencyUnstakeAll to get their original staked balane back and give up their reward\n\nhowever, if the staked token is the same as the payout token,\n\na part of the user staked token can be mistakenly and constantly mint as option token reward for his own or for other user and eventually when user call emergencyUnstakeAll, there will be insufficient token balance and transaction revert\n\nso user will not able to get their staked token back\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L334\n\nhttps://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L508\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSeperate the accounting of the staked user and the payout token or check that staked token is not payout token when creating the OTLM.sol\n\n\n\n## Discussion\n\n**Oighty**\n\nAgree with this issue. We'll explore both the recommendations.\n\n**ctf-sec**\n\nIn the beginning\n\nhttps://github.com/sherlock-audit/2023-06-bond-judging/issues/85\n\nthe issue #85  is considered as a separate medium \n\nroot cause is the code does not really distinguish the payout token and the staking token balance\n\nleads to two issue\n\n1. user's own staked balance is minted as reward (this even lead to lose of fund but only in the case of staking token equals to payment token, which I see a very likely supported use case, the core invariant that user should always call emergencyUnstakeAll is broken)\n\n2. owner that should not remove the user fund can remove the user's fund as payment token\n\nbut for issue #85 \n\nit requires admin owner mistake although the code is not designed to owner remove staking token\n\n but sherlock rules still apply:\n\nhttps://docs.sherlock.xyz/audits/judging/judging#duplication-rules\n\n```\n Issues identifying a core vulnerability can be considered duplicates. \n Scenario 1:\nThere is a root cause/error/vulnerability A in the code. This vulnerability A -> leads to two attacks paths:\n  -> high severity path\n-> medium severity attack path/just identifying the vulnerability.\n```\n\nso after internal discussion, issue #85 close and not rewarded just to be fair.\n\n**berndartmueller**\n\nEscalate\n\nDisagree with the validity of the issue. This is not a valid medium finding\n\nDue to relying on the contract owner not providing sufficient payout tokens used as rewards, this is considered an admin error and thus not eligible for medium severity.\n\nIt is assumed that the trusted contract owner of the `OTLM` contract supplies a sufficient amount of payout tokens, even supplying more than anticipated (based on the reward rate). \"Unused\" payout tokens topped up by the owner can always be withdrawn via the `withdrawPayoutTokens` function.\n\nIn the case that insufficient payout tokens have been supplied by the contract owner, thus utilizing the deposited payout tokens from the users, the owner can always add additional payout token capital to the contract, ensuring that calls to `emergencyUnstakeAll` succeed. \n\n**sherlock-admin**\n\n > Escalate\n> \n> Disagree with the validity of the issue. This is not a valid medium finding\n> \n> Due to relying on the contract owner not providing sufficient payout tokens used as rewards, this is considered an admin error and thus not eligible for medium severity.\n> \n> It is assumed that the trusted contract owner of the `OTLM` contract supplies a sufficient amount of payout tokens, even supplying more than anticipated (based on the reward rate). \"Unused\" payout tokens topped up by the owner can always be withdrawn via the `withdrawPayoutTokens` function.\n> \n> In the case that insufficient payout tokens have been supplied by the contract owner, thus utilizing the deposited payout tokens from the users, the owner can always add additional payout token capital to the contract, ensuring that calls to `emergencyUnstakeAll` succeed. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Oot2k**\n\nI think the escalation is valid. More of admin input.\n\n**JeffCX**\n\nI already invalidate my finding #85, which is more fair to the reward pot\n\nInvalid this finding is not fair to me :) here is the argument\n\nSponsor DM is only for reference\n\n![image](https://github.com/sherlock-audit/2023-06-bond-judging/assets/25846666/bb136915-214f-4dfc-9716-4ef1b56eebe7)\n\nWe need to refer to the doc and read me\n\nhttps://github.com/sherlock-audit/2023-06-bond/tree/fce1809f83728561dc75078d41ead6d60e15d065/options#otlmsol\n\n![image](https://github.com/sherlock-audit/2023-06-bond-judging/assets/25846666/ed7b249b-6b46-4b3c-948c-a6fe5a6a9499)\n\nIn the doc, I don't see the doc saying the the owner has to provide the payout token so not providing payout token is not an admin error.\n\nplus\n\n> It is assumed that the trusted contract owner of the OTLM contract supplies a sufficient amount of payout tokens, even supplying more than anticipated (based on the reward rate). \"Unused\" payout tokens topped up by the owner can always be withdrawn via the withdrawPayoutTokens function.\n\nIn normal yield farming protocol and staking protocol, the owner can add payment token or he can choose not to,\n\nEven Sushiswap Master Chef has a [emergency unstaking](https://github.com/1coinswap/core/blob/fdc2da0cc82b6ce6f287432cd6772ecdc63fda79/contracts/MasterChefV2.sol#L313) to make sure the insufficient reward does not block user's staking fund\n\n> In the case that insufficient payout tokens have been supplied by the contract owner, thus utilizing the deposited payout tokens from the users, the owner can always add additional payout token capital to the contract, ensuring that calls to emergencyUnstakeAll succeed.\n\nEven we use the assumption the admin has to provide the payout token, it is not possible, he can't just provide payout token forever,\n\ntoken has a limited total supply\n\nThe only case the admin can provide payout token forever is he can control the token minting.\n\nThe claim reward and stake toward is designed to let user make money, not lose money\n\nthe emergency unstake is designed to protect user's which should always not reverting.\n\nStill feel like leave #85 as invalid and leave this one as medium is a very reasonable severity categorization.\n\n**Oot2k**\n\nI agree that emergency unstake should never revert. I also agree with that the admin cant provide tokens forever. \nEven if the root cause here is that there is not enough supply provided, I think the impact is severe and quit likely to happen.\n\nSherlock should keep this in mind when reviewing the escaltion. \n\n**berndartmueller**\n\n> Even we use the assumption the admin has to provide the payout token, it is not possible, he can't just provide payout token forever,\n> \n> token has a limited total supply\n> \n> The only case the admin can provide payout token forever is he can control the token minting.\n\nThat depends on the used token. Many tokens allow minting additional funds by the owner, and many protocols have large token reserves.\n\nAdditionally, if rewards should be stopped, the owner can use the `setRewardRate` function to reset the reward rate to 0, **before** running out of payout tokens (payout tokens which were topped up by the owner to be used for minting option rewards).\n\n\n**JeffCX**\n\n> That depends on the used token. Many tokens allow minting additional funds by the owner, and many protocols have large token reserves.\n\nIn the case when the admin owner can do that, this is not a issue\n\nMany protocol don't allow token minting and has a fixed supply, it is very common to hardcode the total supply.\n\nSetting the reward rate to zero don't seem to help\n\nBecause in the current codebase, setting the reward rate to zero will only stop the reward from accuring [in the current and future epoch](https://github.com/sherlock-audit/2023-06-bond/blob/fce1809f83728561dc75078d41ead6d60e15d065/options/src/fixed-strike/liquidity-mining/OTLM.sol#L591)\n\n```solidity\n    function setRewardRate(\n        uint256 rewardRate_\n    ) external onlyOwner requireInitialized updateRewards {\n        // Check if a new epoch needs to be started\n        // We do this to avoid bad state if the reward rate is changed when a new epoch should have started\n        if (block.timestamp >= epochStart + epochDuration) _startNewEpoch();\n\n        // Set the reward rate\n        rewardRate = rewardRate_;\n    }\n```\n\nbut the reward earned from past epoch is still for user to claim\n\nIf not payout token balance, user's staked balance is used as reward o(╥﹏╥)o\n\n\n**Oighty**\n\nI tend to side with the submitter on this one. The main reason being that staking contracts have often been used in the past with the staked token == payout token and others may want to use the contracts in that way. They also often work that rewards are halted if the owner does not add more funds to them (vs. having direct minting) as a safety measure. With that configuration, one user's stake could be used to pay rewards to another, which would be very bad. \n\nSince the protocol is permissionless, anyone can create an OTLM pool. Therefore, the input isn't \"admin\" from the protocol perspective. I did message submitter that I thought this was a valuable find. The high likelihood that someone would try to use this configuration (based on past staking contract use) and users would lose funds make this a medium issue.\n\n**Oighty**\n\nFix implemented at https://github.com/Bond-Protocol/options/pull/9\n\n**ctf-sec**\n\nTo support the use case when payout token is staking token, the contract would need to distinguish the payout token and staking token balance, which add more complexity \n\nthe current fix make sure the staking token is not the same as the payout token when deploying the OTLM contract, fix looks good!\n\n**berndartmueller**\n\n> I tend to side with the submitter on this one. The main reason being that staking contracts have often been used in the past with the staked token == payout token and others may want to use the contracts in that way. They also often work that rewards are halted if the owner does not add more funds to them (vs. having direct minting) as a safety measure. With that configuration, one user's stake could be used to pay rewards to another, which would be very bad.\n> \n> Since the protocol is permissionless, anyone can create an OTLM pool. Therefore, the input isn't \"admin\" from the protocol perspective. I did message submitter that I thought this was a valuable find. The high likelihood that someone would try to use this configuration (based on past staking contract use) and users would lose funds make this a medium issue.\n\nIf the deployer of the permissionless OTML contract is not considered an admin, all issues which have their severity lowered, due to considering them as “admin issues”, should be re-evaluated IMHO (e.g., https://github.com/sherlock-audit/2023-06-bond-judging/issues/55#issuecomment-1632426869). Or alternatively, the OTML owner is considered an admin. \n\nHappy to hear everyone’s thoughts!\n\n**SilentYuki**\n\n@berndartmueller does have a point here, by the sponsor comment:\n\n`Since the protocol is permissionless, anyone can create an OTLM pool. Therefore, the input isn't \"admin\" from the protocol perspective.`\n\nSome of the other issues are judged as lows based on counting the owner of the OTLM as a trusted authority.\n\n**juntzhan**\n\nIt was confirmed by sponsor that OTLM owner is trusted.\n<img width=\"702\" alt=\"截屏2023-08-04 11 49 44\" src=\"https://github.com/sherlock-audit/2023-06-bond-judging/assets/16879758/b0adcc0f-3faf-48df-990b-787091d694bb\">\nhttps://discord.com/channels/812037309376495636/1125440840333013073/1126125997675249674\n\nThe dispute is if `not providing payout token is not an admin error` rather than if OTLM owner is admin.\n\n**Oighty**\n\n> Since the protocol is permissionless, anyone can create an OTLM pool. Therefore, the input isn't \"admin\" from the protocol perspective.\n\nSorry if this was confusing. I do think the OTLM owner is considered trusted.  As stated before though, it's likely that someone would try to setup with this configuration and the impact is severe (user's lose deposited principal if it is used to fund rewards). Therefore, I view this as a bigger issue than more standard \"misconfigurations\", which do not put user principal at risk. \n\nTo phrase differently, I don't think it would be obvious to OTLM owners deploying the contract that this could happen. Therefore, the system should not allow this to happen.\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid issue based on the points raised in the final comments from the Sponsor here. \nThe information provided in the readme was not sufficient to understand the core functioning. Sherlock will make sure to avoid such situations in the future. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [berndartmueller](https://github.com/sherlock-audit/2023-06-bond-judging/issues/83/#issuecomment-1634747980): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/99",
  "Code": [
    {
      "filename": "options/src/fixed-strike/liquidity-mining/OTLM.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {IBondOracle} from \"src/interfaces/IBondOracle.sol\";\nimport {IAllowlist} from \"src/interfaces/IAllowlist.sol\";\n\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\nimport {IFixedStrikeOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\n\n/// @dev The purpose of Option Token Liquidity Mining is to allow the protocol to\n///      re-capture some of the value from liquidity mining rewards when LPs realize profit.\n///      Additionally, it can cap the amount of sell pressure on a protocols token in a down\n///      market by limiting the profitability of exercising option tokens to above the strike price.\n///\n///      The OTLM contract implements a version of this using fixed strike call options.\n///      Protocols can deploy an OTLM contract with their specific configuration of staked\n///      token and option paramters. The contract implements epoch-based staking rewards to\n///      issue new option tokens at fixed time intervals and at a new strike price based on\n///      the configuration when an epoch transitions. The owner of the contract can update\n///      various staking and option token parameters over time to adjust their rewards program.\n///      The owner can also optionally designate an Allowlist contract to limit which users can\n///      can stake in the contract. The allowlist should conform to the IAllowlist interface.\n///\n///      Users can deposit the configured stakedToken into the contract to earn rewards.\n///      Rewards are continuously accrued based on the configured reward rate and the total\n///      balance of staked tokens in the contract. Any user action updates the reward calculations.\n///      Additionally, user actions can trigger a new epoch start, which will earn them additional\n///      option tokens in the form of the epoch transition reward for paying the extra gas.\n///      Users can claim their outstanding rewards from all epochs or from the next unclaimed epoch.\n///      If the option token for a specific epoch has expired, the user will not receive any rewards\n///      for that period since they are now worthless.\nabstract contract OTLM is Owned, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    /* ========== ERRORS ========== */\n    error OTLM_InvalidParams();\n    error OTLM_InvalidAmount();\n    error OTLM_InvalidEpoch();\n    error OTLM_ZeroBalance();\n    error OTLM_PreviousUnclaimedEpoch();\n    error OTLM_AlreadyInitialized();\n    error OTLM_NotInitialized();\n    error OTLM_DepositsDisabled();\n    error OTLM_NotAllowed();\n\n    /* ========== EVENTS ========== */\n    event NewEpoch(uint48 indexed epoch_, FixedStrikeOptionToken optionToken_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Staking parameters\n    /// @notice Token that is staked in the OTLM contract\n    ERC20 public immutable stakedToken;\n    uint8 internal immutable stakedTokenDecimals;\n\n    /// @notice Whether users can deposit staking tokens into the OTLM contract at the current time\n    bool public depositsEnabled;\n\n    /// @notice Whether the OTLM contract has been initialized\n    /// @dev    No settings can be changed or tokens deposited before the OTLM contract is initialized\n    bool public initialized;\n\n    // Allowlist\n    /// @notice (Optional) Address of the allowlist contract which determines which addresses are allowed to interact with the OTLM contract\n    IAllowlist public allowlist;\n\n    // Option Token Parameters\n    /// @notice Option Teller contract that is used to deploy and create option tokens\n    IFixedStrikeOptionTeller public immutable optionTeller;\n\n    /// @notice Token that stakers receive call options for\n    ERC20 public immutable payoutToken;\n\n    /// @notice Token that stakers must pay to exercise the call options they receive\n    ERC20 public quoteToken;\n\n    /// @notice Amount of time (in seconds) from option token deployment to when it can be exercised\n    uint48 public timeUntilEligible;\n\n    /// @notice Amount of time (in seconds) from when the option token is eligible to when it expires\n    uint48 public eligibleDuration;\n\n    /// @notice Address that will receive the quote tokens when an option is exercised\n    address public receiver;\n\n    // Staking epochs\n\n    /// @notice Current staking epoch\n    uint48 public epoch;\n\n    /// @notice Staking epoch duration\n    uint48 public epochDuration;\n\n    /// @notice Timestamp of the start of the current staking epoch\n    uint48 public epochStart;\n\n    // Staking rewards\n\n    /// @notice Amount of time (in seconds) that the reward rate is distributed over\n    uint48 public constant REWARD_PERIOD = uint48(1 days);\n\n    /// @notice Timestamp when the stored rewards per token was last updated\n    uint48 public lastRewardUpdate;\n\n    /// @notice Amount of option tokens rewarded per reward period\n    uint256 public rewardRate;\n\n    /// @notice Global reward distribution variable, used to calculate user rewards\n    uint256 public rewardsPerTokenStored;\n\n    /// @notice Amount of option tokens that are rewarded for starting a new epoch\n    uint256 public epochTransitionReward;\n\n    /// @notice Rewards Per Token value at the start of each epoch\n    mapping(uint48 => uint256) public epochRewardsPerTokenStart;\n\n    // Stake balances\n\n    /// @notice Total amount of staked tokens currently in the contract\n    uint256 public totalBalance;\n\n    /// @notice Mapping of staker address to their staked balance\n    mapping(address => uint256) public stakeBalance;\n\n    /// @notice Mapping of staker address to the rewards per token they have claimed\n    mapping(address => uint256) public rewardsPerTokenClaimed;\n\n    /// @notice Mapping of staker address to the last epoch they claimed rewards for\n    mapping(address => uint48) public lastEpochClaimed;\n\n    /// @notice Mapping of epochs to the option tokens that was rewarded for that epoch\n    mapping(uint48 => FixedStrikeOptionToken) public epochOptionTokens;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @param owner_        Address of the owner of the OTLM contract\n    /// @param stakedToken_  Token that is staked in the OTLM contract\n    /// @param optionTeller_ Option Teller contract that is used by the OTLM contract to deploy and create option tokens\n    /// @param payoutToken_  Token that stakers receive call options for\n    constructor(\n        address owner_,\n        ERC20 stakedToken_,\n        IFixedStrikeOptionTeller optionTeller_,\n        ERC20 payoutToken_\n    ) Owned(owner_) {\n        // Validate parameters\n        if (\n            owner_ == address(0) ||\n            address(stakedToken_) == address(0) ||\n            address(stakedToken_).code.length == 0 ||\n            address(optionTeller_) == address(0) ||\n            address(optionTeller_).code.length == 0 ||\n            address(payoutToken_) == address(0) ||\n            address(payoutToken_).code.length == 0\n        ) revert OTLM_InvalidParams();\n\n        // Set staking token parameters\n        stakedToken = stakedToken_;\n        stakedTokenDecimals = stakedToken_.decimals();\n\n        // Set option token parameters\n        optionTeller = optionTeller_;\n        payoutToken = payoutToken_;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /// @notice Modifier that updates the stored rewards per token before a function is executed\n    /// @dev    This modifier should be placed on any function where rewards are claimed or staked tokens are deposited/withdrawn.\n    /// @dev    Additionally, it should be placed on any functions that modify the reward parameters of the OTLM contract.\n    modifier updateRewards() {\n        // Update the rewards per token and last reward timestamp\n        if (lastRewardUpdate != uint48(block.timestamp)) {\n            rewardsPerTokenStored = currentRewardsPerToken();\n            lastRewardUpdate = uint48(block.timestamp);\n        }\n        _;\n    }\n\n    /// @notice Modifier that tries to start a new epoch before a function is executed and rewards the caller for doing so\n    modifier tryNewEpoch() {\n        // If the epoch has ended, try to start a new one\n        if (uint48(block.timestamp) >= epochStart + epochDuration) {\n            _startNewEpoch();\n            // Issue reward to caller for starting the new epoch\n            payoutToken.approve(address(optionTeller), epochTransitionReward);\n            FixedStrikeOptionToken optionToken = epochOptionTokens[epoch];\n            optionTeller.create(optionToken, epochTransitionReward);\n            ERC20(address(optionToken)).safeTransfer(msg.sender, epochTransitionReward);\n        }\n        _;\n    }\n\n    /// @notice Modifier that requires the OTLM contract to be initialized before a function is executed\n    modifier requireInitialized() {\n        if (!initialized) revert OTLM_NotInitialized();\n        _;\n    }\n\n    /* ========== INITIALIZATION ========== */\n\n    /// @notice Initializes the OTLM contract\n    /// @notice Only owner\n    /// @dev    This function can only be called once.\n    /// @dev    When the function completes, the contract is live. Users can start staking and claiming rewards.\n    /// @param quoteToken_            Token that stakers must pay to exercise the call options they receive\n    /// @param timeUntilEligible_     Amount of time (in seconds) from option token deployment to when it can be exercised\n    /// @param eligibleDuration_      Amount of time (in seconds) from when the option token is eligible to when it expires\n    /// @param receiver_              Address that will receive the quote tokens when an option is exercised\n    ///                               IMPORTANT: receiver is the only address that can retrieve payout token collateral from expired options.\n    ///                               It must be able to call the `reclaim` function on the Option Teller contract.\n    /// @param epochDuration_         Staking epoch duration (in seconds)\n    /// @param epochTransitionReward_ Amount of option tokens that are rewarded for starting a new epoch\n    /// @param rewardRate_            Amount of option tokens rewarded per reward period (1 day)\n    /// @param allowlist_             Address of the allowlist contract that can be used to restrict who can stake in the OTLM contract.\n    ///                               If the zero address, then no allow list is used.\n    /// @param allowlistParams_       Parameters that are passed to the allowlist contract when this contract registers with it\n    /// @param other_                 Additional parameters that are required by specific implementations of the OTLM contract\n    function initialize(\n        ERC20 quoteToken_,\n        uint48 timeUntilEligible_,\n        uint48 eligibleDuration_,\n        address receiver_,\n        uint48 epochDuration_,\n        uint256 epochTransitionReward_,\n        uint256 rewardRate_,\n        IAllowlist allowlist_,\n        bytes calldata allowlistParams_,\n        bytes calldata other_\n    ) external onlyOwner {\n        // Revert if already initialized\n        if (initialized) revert OTLM_AlreadyInitialized();\n\n        // Validate parameters\n        // Quote token must be a contract and not the zero address\n        if (address(quoteToken_) == address(0) || address(quoteToken_).code.length == 0)\n            revert OTLM_InvalidParams();\n\n        // The eligible duration must be greater than the minimum option duration on the teller to be a valid option token\n        if (eligibleDuration_ < optionTeller.minOptionDuration()) revert OTLM_InvalidParams();\n\n        // The option token expiry must be greater than the epoch duration\n        if (timeUntilEligible_ + eligibleDuration_ < epochDuration_) revert OTLM_InvalidParams();\n\n        // The receiver cannot be the zero address\n        if (receiver_ == address(0)) revert OTLM_InvalidParams();\n\n        // If the allowlist is not the zero address, assume it's being used and register the contract\n        if (address(allowlist_) != address(0)) {\n            // Since an allowlist is being used, we must confirm it is a contract\n            if (address(allowlist_).code.length == 0) revert OTLM_InvalidParams();\n\n            // Store allowlist\n            allowlist = allowlist_;\n\n            // Register contract on allowlist, catch error if fails\n            try allowlist.register(allowlistParams_) {} catch {\n                revert OTLM_InvalidParams();\n            }\n        }\n\n        // Set option token parameters\n        quoteToken = quoteToken_;\n        timeUntilEligible = timeUntilEligible_;\n        eligibleDuration = eligibleDuration_;\n        receiver = receiver_;\n\n        // Set staking epoch parameters\n        epochDuration = epochDuration_;\n        epochTransitionReward = epochTransitionReward_;\n\n        // Set initial staking variables\n        // totalBalance = 0; // don't have to initialize to zero\n        // rewardsPerTokenStored = 0; // don't have to initialize to zero\n        depositsEnabled = true;\n        lastRewardUpdate = uint48(block.timestamp);\n        rewardRate = rewardRate_;\n\n        // Set initialized to true\n        initialized = true;\n\n        // Pass other parameters to initialize function for implementation specific logic\n        _initialize(other_);\n\n        // Starts the first epoch\n        _startNewEpoch();\n    }\n\n    // Override this function to add implementation specific initialization logic\n    function _initialize(bytes calldata params_) internal virtual;\n\n    /* ========== STAKING FUNCTIONS ========== */\n\n    /// @notice Deposit staking tokens into the contract to earn rewards\n    /// @notice Only callable if deposits are enabled\n    /// @notice Only callable if the user is allowed to stake per the allowlist\n    /// @notice May receive reward if calling triggers new epoch\n    /// @param amount_ Amount of staking tokens to deposit\n    /// @param proof_  Optional proof data for specific allowlist implementations\n    function stake(\n        uint256 amount_,\n        bytes calldata proof_\n    ) external nonReentrant requireInitialized updateRewards tryNewEpoch {\n        // Revert if deposits are disabled\n        if (!depositsEnabled) revert OTLM_DepositsDisabled();\n\n        // If allowlist configured, check if user is allowed to stake\n        if (address(allowlist) != address(0)) {\n            if (!allowlist.isAllowed(msg.sender, proof_)) revert OTLM_NotAllowed();\n        }\n\n        // Revert if deposit amount is zero to avoid zero transfers\n        if (amount_ == 0) revert OTLM_InvalidAmount();\n\n        // Get user balance, if non-zero, claim rewards before increasing stake\n        uint256 userBalance = stakeBalance[msg.sender];\n        if (userBalance > 0) {\n            // Claim outstanding rewards, this will update the rewards per token claimed\n            _claimRewards();\n        } else {\n            // Initialize the rewards per token claimed for the user to the stored rewards per token\n            rewardsPerTokenClaimed[msg.sender] = rewardsPerTokenStored;\n        }\n\n        // Increase the user's stake balance and the total balance\n        stakeBalance[msg.sender] = userBalance + amount_;\n        totalBalance += amount_;\n\n        // Transfer the staked tokens from the user to this contract\n        stakedToken.safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /// @notice Withdraw staking tokens from the contract\n    /// @notice May receive reward if calling triggers new epoch\n    /// @param amount_ Amount of staking tokens to withdraw\n    function unstake(uint256 amount_) external nonReentrant updateRewards tryNewEpoch {\n        // Get user balance and check that it's not zero\n        uint256 userBalance = stakeBalance[msg.sender];\n        if (userBalance == 0) revert OTLM_ZeroBalance();\n\n        // Check that amount_ is valid\n        if (amount_ > userBalance || amount_ == 0) revert OTLM_InvalidAmount();\n\n        // Claim rewards before decreasing stake\n        _claimRewards();\n\n        // Decrease the user's stake balance and the total balance\n        // Total balance cannot revert if the user value is valid\n        stakeBalance[msg.sender] = userBalance - amount_;\n        totalBalance -= amount_;\n\n        // Transfer the staked tokens from this contract to the user\n        stakedToken.safeTransfer(msg.sender, amount_);\n    }\n\n    /// @notice Withdraw entire balance of staking tokens from the contract\n    /// @notice May receive reward if calling triggers new epoch\n    function unstakeAll() external nonReentrant updateRewards tryNewEpoch {\n        // Get user balance and check that it's not zero\n        uint256 userBalance = stakeBalance[msg.sender];\n        if (userBalance == 0) revert OTLM_ZeroBalance();\n\n        // Claim rewards before decreasing stake\n        _claimRewards();\n\n        // Decrease the user's stake balance and the total balance\n        // Total balance cannot revert since all user balances are less than or equal to the total\n        stakeBalance[msg.sender] = 0;\n        totalBalance -= userBalance;\n\n        // Transfer the staked tokens from this contract to the user\n        stakedToken.safeTransfer(msg.sender, userBalance);\n    }\n\n    /// @notice Withdraw entire balance of staking tokens without updating or claiming outstanding rewards.\n    /// @notice Rewards will be lost if stake is withdrawn using this function. Only for emergency use.\n    function emergencyUnstakeAll() external nonReentrant {\n        // Get user balance and check that it's not zero\n        uint256 userBalance = stakeBalance[msg.sender];\n        if (userBalance == 0) revert OTLM_ZeroBalance();\n\n        // Rewards are not claimed and lost\n\n        // Decrease the user's stake balance and the total balance\n        // Total balance cannot revert since all user balances are less than or equal to the total\n        stakeBalance[msg.sender] = 0;\n        totalBalance -= userBalance;\n\n        // Transfer the staked tokens from this contract to the user\n        stakedToken.safeTransfer(msg.sender, userBalance);\n    }\n\n    /* ========== REWARD FUNCTIONS ========== */\n\n    /// @notice Claim all outstanding rewards for the user across epochs\n    function claimRewards() external nonReentrant updateRewards tryNewEpoch returns (uint256) {\n        // Revert if user has no stake\n        if (stakeBalance[msg.sender] == 0) revert OTLM_ZeroBalance();\n\n        // Claim all outstanding rewards\n        return _claimRewards();\n    }\n\n    function _claimRewards() internal returns (uint256) {\n        // Claims all outstanding rewards for the user across epochs\n        // If there are unclaimed rewards from epochs where the option token has expired, the rewards are lost\n\n        // Get the last epoch claimed by the user\n        uint48 userLastEpoch = lastEpochClaimed[msg.sender];\n\n        // If the last epoch claimed is equal to the current epoch, then only try to claim for the current epoch\n        if (userLastEpoch == epoch) return _claimEpochRewards(epoch);\n\n        // If not, then the user has not claimed all rewards\n        // Start at the last claimed epoch because they may not have completely claimed that epoch\n        uint256 totalRewardsClaimed;\n        for (uint48 i = userLastEpoch; i <= epoch; i++) {\n            // For each epoch that the user has not claimed rewards for, claim the rewards\n            totalRewardsClaimed += _claimEpochRewards(i);\n        }\n\n        return totalRewardsClaimed;\n    }\n\n    /// @notice Claim all outstanding rewards for the user for the next unclaimed epoch (and any remaining rewards from the previously claimed epoch)\n    function claimNextEpochRewards()\n        external\n        nonReentrant\n        updateRewards\n        tryNewEpoch\n        returns (uint256)\n    {\n        // Claims all outstanding rewards for the user on their next unclaimed epoch. Allows moving through epochs one txn at a time if desired or to avoid gas issues if a large number of epochs have passed.\n\n        // Revert if user has no stake\n        if (stakeBalance[msg.sender] == 0) revert OTLM_ZeroBalance();\n\n        // Get the last epoch claimed by the user\n        uint48 userLastEpoch = lastEpochClaimed[msg.sender];\n\n        // If the last epoch claimed is equal to the current epoch, then try to claim for the current epoch\n        if (userLastEpoch == epoch) return _claimEpochRewards(epoch);\n\n        // If not, then the user has not claimed rewards from the next epoch\n        // Check if the user has claimed all rewards from the last epoch first\n        uint256 userClaimedRewardsPerToken = rewardsPerTokenClaimed[msg.sender];\n        uint256 rewardsPerTokenEnd = epochRewardsPerTokenStart[userLastEpoch + 1];\n        if (userClaimedRewardsPerToken < rewardsPerTokenEnd) {\n            // If not, then claim the remaining rewards from the last epoch\n            uint256 remainingLastEpochRewards = _claimEpochRewards(userLastEpoch);\n            uint256 nextEpochRewards = _claimEpochRewards(userLastEpoch + 1);\n            return remainingLastEpochRewards + nextEpochRewards;\n        } else {\n            // If so, then claim the rewards from the next epoch\n            return _claimEpochRewards(userLastEpoch + 1);\n        }\n    }\n\n    function _claimEpochRewards(uint48 epoch_) internal returns (uint256) {\n        // Claims all outstanding rewards for the user for the specified epoch\n        // If the option token for the epoch has expired, the rewards are lost\n\n        // Check that the epoch is valid\n        if (epoch_ > epoch) revert OTLM_InvalidEpoch();\n\n        // Get the rewards per token claimed by the user\n        uint256 userRewardsClaimed = rewardsPerTokenClaimed[msg.sender];\n\n        // Get the rewards per token at the start of the epoch and the rewards per token at the end of the epoch (start of the next one)\n        // If the epoch is the current epoch, the rewards per token at the end of the epoch is the current rewards per token stored\n        uint256 rewardsPerTokenStart = epochRewardsPerTokenStart[epoch_];\n        uint256 rewardsPerTokenEnd = epoch_ == epoch\n            ? rewardsPerTokenStored\n            : epochRewardsPerTokenStart[epoch_ + 1];\n\n        // If the user hasn't claimed the rewards up to the start of this epoch, then they have a previous unclaimed epoch\n        // External functions protect against this by their ordering, but this makes it explicit\n        if (userRewardsClaimed < rewardsPerTokenStart) revert OTLM_PreviousUnclaimedEpoch();\n\n        // If user rewards claimed is greater than or equal to the rewards per token at the end of the epoch, then the user has already claimed all rewards for the epoch\n        if (userRewardsClaimed >= rewardsPerTokenEnd) return 0;\n\n        // If not, then the user has not claimed all rewards for the epoch\n\n        // Set the rewards per token claimed by the user to the rewards per token at the end of the epoch\n        rewardsPerTokenClaimed[msg.sender] = rewardsPerTokenEnd;\n        lastEpochClaimed[msg.sender] = epoch_;\n\n        // Get the option token for the epoch\n        FixedStrikeOptionToken optionToken = epochOptionTokens[epoch_];\n        // If the option token has expired, then the rewards are zero\n        if (uint256(optionToken.expiry()) < block.timestamp) return 0;\n\n        // If the option token is still valid, we need to issue rewards\n        uint256 rewards = ((rewardsPerTokenEnd - userRewardsClaimed) * stakeBalance[msg.sender]) /\n            10 ** stakedTokenDecimals;\n\n        // Mint the option token on the teller\n        // This transfers the reward amount of payout tokens to the option teller in exchange for the amount of option tokens\n        payoutToken.approve(address(optionTeller), rewards);\n        optionTeller.create(optionToken, rewards);\n\n        // Transfer rewards to sender\n        ERC20(address(optionToken)).safeTransfer(msg.sender, rewards);\n\n        // Return the amount of rewards claimed\n        return rewards;\n    }\n\n    function _startNewEpoch() internal {\n        // Starts a new epoch, assumes that a check has been performed that the epoch can start and that rewards were updated prior to calling\n        epoch++;\n        epochStart = uint48(block.timestamp);\n        epochRewardsPerTokenStart[epoch] = rewardsPerTokenStored;\n\n        // Deploy new option token and store against the epoch\n        FixedStrikeOptionToken optionToken = optionTeller.deploy(\n            payoutToken,\n            quoteToken,\n            uint48(block.timestamp) + timeUntilEligible,\n            uint48(block.timestamp) + timeUntilEligible + eligibleDuration,\n            receiver,\n            true,\n            nextStrikePrice()\n        );\n        epochOptionTokens[epoch] = optionToken;\n\n        // Emit event\n        emit NewEpoch(epoch, optionToken);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @notice Returns the current rewards per token value updated to the second\n    function currentRewardsPerToken() public view returns (uint256) {\n        // Rewards do not accrue if the total balance is zero\n        if (totalBalance == 0) return rewardsPerTokenStored;\n\n        // The number of rewards to apply is based on the reward rate and the amount of time that has passed since the last reward update\n        uint256 rewardsToApply = ((block.timestamp - lastRewardUpdate) * rewardRate) /\n            REWARD_PERIOD;\n\n        // The rewards per token is the current rewards per token plus the rewards to apply divided by the total staked balance\n        return rewardsPerTokenStored + (rewardsToApply * 10 ** stakedTokenDecimals) / totalBalance;\n    }\n\n    /// @notice Returns the strike price that would be used if a new epoch started right now\n    function nextStrikePrice() public view virtual returns (uint256);\n\n    /* ========== ADMIN FUNCTIONS ========== */\n\n    // Staking management\n\n    /// @notice Toggle whether deposits are enabled\n    /// @notice Only owner\n    /// @param depositsEnabled_ Whether deposits should be enabled\n    function setDepositsEnabled(bool depositsEnabled_) external onlyOwner requireInitialized {\n        // Set whether deposits are enabled\n        depositsEnabled = depositsEnabled_;\n    }\n\n    /// @notice Manually start a new epoch\n    /// @notice Only owner\n    function triggerNextEpoch() external onlyOwner requireInitialized updateRewards {\n        // Triggers the next epoch, allowing the owner to move through epochs manually if desired.\n        // This allows fixing configuration issues or adjusting for severe market events.\n        _startNewEpoch();\n    }\n\n    /// @notice Withdraw payout tokens that were deposited to the contract for rewards\n    /// @notice Only owner\n    /// @param to_     The address to withdraw to\n    /// @param amount_ The amount to withdraw\n    function withdrawPayoutTokens(address to_, uint256 amount_) external onlyOwner {\n        // Revert if the amount is greater than the balance\n        // Transfer will check this, but we provide a more helpful error message\n        if (amount_ > payoutToken.balanceOf(address(this)) || amount_ == 0)\n            revert OTLM_InvalidAmount();\n\n        // Withdraws payout tokens from the contract\n        payoutToken.safeTransfer(to_, amount_);\n    }\n\n    /// @notice Set the staking reward rate\n    /// @notice Only owner\n    /// @param rewardRate_ Amount of option tokens rewarded per reward period (1 day)\n    function setRewardRate(\n        uint256 rewardRate_\n    ) external onlyOwner requireInitialized updateRewards {\n        // Check if a new epoch needs to be started\n        // We do this to avoid bad state if the reward rate is changed when a new epoch should have started\n        if (block.timestamp >= epochStart + epochDuration) _startNewEpoch();\n\n        // Set the reward rate\n        rewardRate = rewardRate_;\n    }\n\n    /// @notice Set the epoch duration\n    /// @notice Only owner\n    /// @param epochDuration_ Staking epoch duration (in seconds)\n    function setEpochDuration(uint48 epochDuration_) external onlyOwner requireInitialized {\n        // The option token expiry must be greater than the epoch duration\n        if (timeUntilEligible + eligibleDuration < epochDuration_) revert OTLM_InvalidParams();\n\n        // Set the epoch duration\n        epochDuration = epochDuration_;\n    }\n\n    // Option token parameters\n\n    /// @notice Set the option receiver\n    /// @notice Only owner\n    /// @param receiver_ Address that will receive the quote tokens when an option is exercised\n    /// IMPORTANT: receiver is the only address that can retrieve payout token collateral from expired options.\n    /// It must be able to call the `reclaim` function on the Option Teller contract.\n    function setOptionReceiver(address receiver_) external onlyOwner requireInitialized {\n        // Set the receiver\n        receiver = receiver_;\n    }\n\n    /// @notice Set the option duration\n    /// @notice Only owner\n    /// @param timeUntilEligible_ Amount of time (in seconds) from option token deployment to when it can be exercised\n    /// @param eligibleDuration_  Amount of time (in seconds) from when the option token is eligible to when it expire\n    function setOptionDuration(\n        uint48 timeUntilEligible_,\n        uint48 eligibleDuration_\n    ) external onlyOwner requireInitialized {\n        // Validate parameters\n        // The eligible duration must be greater than the minimum option duration to be a valid option token\n        if (eligibleDuration_ < optionTeller.minOptionDuration()) revert OTLM_InvalidParams();\n\n        // The option token expiry must be greater than the epoch duration\n        if (timeUntilEligible_ + eligibleDuration_ < epochDuration) revert OTLM_InvalidParams();\n\n        // Set the time until eligible and the eligible duration\n        timeUntilEligible = timeUntilEligible_;\n        eligibleDuration = eligibleDuration_;\n    }\n\n    /// @notice Set the quote token that is used for the option tokens\n    /// @notice Only owner\n    /// @param quoteToken_ Token that stakers must pay to exercise the call options they receive\n    function setQuoteToken(ERC20 quoteToken_) external virtual onlyOwner requireInitialized {\n        // Revert if the quote token is the zero address or not a contract\n        if (address(quoteToken_) == address(0) || address(quoteToken_).code.length == 0)\n            revert OTLM_InvalidParams();\n\n        // Set the quote token\n        quoteToken = quoteToken_;\n    }\n\n    function setAllowlist(\n        IAllowlist allowlist_,\n        bytes calldata allowlistParams_\n    ) external onlyOwner requireInitialized {\n        // If the allowlist is not the zero address, assume it's being used and register the contract\n        if (address(allowlist_) != address(0)) {\n            // Since an allowlist is being used, we must confirm it is a contract\n            if (address(allowlist_).code.length == 0) revert OTLM_InvalidParams();\n\n            // Store allowlist\n            allowlist = allowlist_;\n\n            // Register contract on allowlist, catch error if fails\n            try allowlist.register(allowlistParams_) {} catch {\n                revert OTLM_InvalidParams();\n            }\n        } else {\n            // If the allowlist is the zero address, then remove the current allowlist\n            allowlist = IAllowlist(address(0));\n        }\n    }\n}\n\n// Implementations of different strike price setting mechanisms\n\n/// @title Manual Strike Option Token Liquidity Mining (OTLM)\n/// @dev The Manual Strike OTLM contract allows the owner to manually set the strike price that new option tokens are created with on epoch transition.\n/// @author Bond Protocol\ncontract ManualStrikeOTLM is OTLM {\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Strike price to be used for new option tokens\n    uint256 public strikePrice;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @param owner_        Address of the owner of the OTLM contract\n    /// @param stakedToken_  Token that is staked in the OTLM contract\n    /// @param optionTeller_ Option Teller contract that is used by the OTLM contract to deploy and create option tokens\n    /// @param payoutToken_  Token that stakers receive call options for\n    constructor(\n        address owner_,\n        ERC20 stakedToken_,\n        IFixedStrikeOptionTeller optionTeller_,\n        ERC20 payoutToken_\n    ) OTLM(owner_, stakedToken_, optionTeller_, payoutToken_) {}\n\n    /* ========== INITIALIZE ========== */\n\n    // Additional initialization logic for the manual strike price OTLM\n    /// @param params_"
    }
  ]
}