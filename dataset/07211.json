{
  "Title": "[G-14] Using unchecked blocks to save gas - Increments in for loop can be unchecked  ( save 30-40 gas per loop iteration)",
  "Content": "The majority of Solidity for loops increment a uint256 variable that starts at 0. These increment operations never need to be checked for over/underflow because the variable will never reach the max number of uint256 (will run out of gas long before that happens). The default over/underflow check wastes gas in every iteration of virtually every for loop . eg.\n\ne.g Let's work with a sample loop below.\n\n```solidity\nfor(uint256 i; i < 10; i++){\n//doSomething\n}\n\n```\ncan be written as shown below.\n```solidity\nfor(uint256 i; i < 10;) {\n  // loop logic\n  unchecked { i++; }\n}\n```\n\nWe can also write  it as an inlined function like below.\n\n```solidity\nfunction inc(i) internal pure returns (uint256) {\n  unchecked { return i + 1; }\n}\nfor(uint256 i; i < 10; i = inc(i)) {\n  // doSomething\n}\n```\n\n**Affected code**<br>\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/factory/CashFactory.sol#L127-L133\n```solidity\nFile: /contracts/cash/factory/CashFactory.sol\n127:    for (uint256 i = 0; i < exCallData.length; ++i) {\n128:      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n129:        value: exCallData[i].value\n130:      }(exCallData[i].data);\n131:      require(success, \"Call Failed\");\n132:      results[i] = ret;\n133:    }\n```\nThe above should be modified to:\n\n```diff\ndiff --git a/contracts/cash/factory/CashFactory.sol b/contracts/cash/factory/CashFactory.sol\nindex 24b67ba..84bb244 100644\n--- a/contracts/cash/factory/CashFactory.sol\n+++ b/contracts/cash/factory/CashFactory.sol\n@@ -124,12 +124,15 @@ contract CashFactory is IMulticall {\n     ExCallData[] calldata exCallData\n   ) external payable override onlyGuardian returns (bytes[] memory results) {\n     results = new bytes[](exCallData.length);\n-    for (uint256 i = 0; i < exCallData.length; ++i) {\n+    for (uint256 i = 0; i < exCallData.length;) {\n       (bool success, bytes memory ret) = address(exCallData[i].target).call{\n         value: exCallData[i].value\n       }(exCallData[i].data);\n       require(success, \"Call Failed\");\n       results[i] = ret;\n+      unchecked {\n+        ++i;\n+      }\n     }\n   }\n```\n\n**Other Instances to modify**\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/factory/CashKYCSenderFactory.sol#L137\n```solidity\nFile: /contracts/cash/factory/CashKYCSenderFactory.sol\n137:    for (uint256 i = 0; i < exCallData.length; ++i) {\n```\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/factory/CashKYCSenderReceiverFactory.sol#L137\n```solidity\nFile: /contracts/cash/factory/CashKYCSenderReceiverFactory.sol\n137:    for (uint256 i = 0; i < exCallData.length; ++i) {\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/kyc/KYCRegistry.sol#L163\n```solidity\nFile: /contracts/cash/kyc/KYCRegistry.sol\n163:    for (uint256 i = 0; i < length; i++) {\n\n180:    for (uint256 i = 0; i < length; i++) {\n\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L750\n```solidity\nFile: /contracts/cash/CashManager.sol\n750:    for (uint256 i = 0; i < size; ++i) {\n\n786:    for (uint256 i = 0; i < size; ++i) {\n\n933:    for (uint256 i = 0; i < size; ++i) {\n\n961:    for (uint256 i = 0; i < exCallData.length; ++i) {\n```\n[see resource](https://github.com/ethereum/solidity/issues/10695)\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/cash/factory/CashFactory.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n// Proxy admin contract used in OZ upgrades plugin\nimport \"contracts/cash/external/openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"contracts/cash/Proxy.sol\";\nimport \"contracts/cash/token/Cash.sol\";\nimport \"contracts/cash/interfaces/IMulticall.sol\";\n\n/**\n * @title CashFactory\n * @author Ondo Finance\n * @notice This contract serves as a Factory for the upgradable CASH token contract.\n *         Upon calling `deployCash` the `guardian` address (set in constructor) will\n *         deploy the following:\n *         1) cash - The implementation contract, ERC20 contract with the initializer disabled\n *         2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\n *                         @notice Owner is set to `guardian` address.\n *         3) TransparentUpgradeableProxy - OZ, proxy contract. Admin is set to `address(proxyAdmin)`.\n *                                          `_logic' is set to `address(cash)`.\n *\n *         Following the above mentioned deployment, the address of the CashFactory contract will:\n *         i) Grant the `DEFAULT_ADMIN_ROLE` & PAUSER_ROLE to the `guardian` address\n *         ii) Revoke the `MINTER_ROLE`, `PAUSER_ROLE` & `DEFAULT_ADMIN_ROLE` from address(this).\n *         iii) Transfer ownership of the ProxyAdmin to that of the `guardian` address.\n *\n * @notice `guardian` address in constructor is a msig.\n */\ncontract CashFactory is IMulticall {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant DEFAULT_ADMIN_ROLE = bytes32(0);\n\n  address internal immutable guardian;\n  Cash public cashImplementation;\n  ProxyAdmin public cashProxyAdmin;\n  TokenProxy public cashProxy;\n\n  constructor(address _guardian) {\n    guardian = _guardian;\n  }\n\n  /**\n   * @dev This function will deploy an upgradable instance of Cash\n   *\n   * @param name   The name of the token we want to deploy.\n   * @param ticker The ticker for the token we want to deploy.\n   *\n   * @return address The address of the proxy contract.\n   * @return address The address of the proxyAdmin contract.\n   * @return address The address of the implementation contract.\n   *\n   * @notice 1) Will automatically revoke all deployer roles granted to\n   *            address(this).\n   *         2) Will grant DEFAULT_ADMIN & PAUSER_ROLE(S) to `guardian`\n   *            address specified in constructor.\n   *         3) Will transfer ownership of the proxyAdmin to guardian\n   *            address.\n   *\n   */\n  function deployCash(\n    string calldata name,\n    string calldata ticker\n  ) external onlyGuardian returns (address, address, address) {\n    cashImplementation = new Cash();\n    cashProxyAdmin = new ProxyAdmin();\n    cashProxy = new TokenProxy(\n      address(cashImplementation),\n      address(cashProxyAdmin),\n      \"\"\n    );\n    Cash cashProxied = Cash(address(cashProxy));\n    cashProxied.initialize(name, ticker);\n\n    cashProxied.grantRole(DEFAULT_ADMIN_ROLE, guardian);\n    cashProxied.grantRole(PAUSER_ROLE, guardian);\n\n    cashProxied.revokeRole(MINTER_ROLE, address(this));\n    cashProxied.revokeRole(PAUSER_ROLE, address(this));\n    cashProxied.revokeRole(DEFAULT_ADMIN_ROLE, address(this));\n\n    cashProxyAdmin.transferOwnership(guardian);\n    assert(cashProxyAdmin.owner() == guardian);\n    emit CashDeployed(\n      address(cashProxied),\n      address(cashProxyAdmin),\n      address(cashImplementation),\n      name,\n      ticker\n    );\n    return (\n      address(cashProxied),\n      address(cashProxyAdmin),\n      address(cashImplementation)\n    );\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyGuardian returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /**\n   * @dev Event emitted when upgradable cash is deployed\n   *\n   * @param proxy             The address for the proxy contract\n   * @param proxyAdmin        The address for the proxy admin contract\n   * @param implementation    The address for the implementation contract\n   */\n  event CashDeployed(\n    address proxy,\n    address proxyAdmin,\n    address implementation,\n    string name,\n    string ticker\n  );\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"CashFactory: You are not the Guardian\");\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/cash/factory/CashKYCSenderFactory.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n// Proxy admin contract used in OZ upgrades plugin\nimport \"contracts/cash/external/openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"contracts/cash/Proxy.sol\";\nimport \"contracts/cash/token/CashKYCSender.sol\";\nimport \"contracts/cash/interfaces/IMulticall.sol\";\n\n/**\n * @title CashKYCSenderFactory\n * @author Ondo Finance\n * @notice This contract serves as a Factory for the upgradable CashKYCSender token contract.\n *         Upon calling `deployCashKYCSender` the `guardian` address (set in constructor) will\n *         deploy the following:\n *         1) CashKYCSender - The implementation contract, ERC20 contract with the initializer disabled\n *         2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\n *                         @notice Owner is set to `guardian` address.\n *         3) TransparentUpgradeableProxy - OZ, proxy contract. Admin is set to `address(proxyAdmin)`.\n *                                          `_logic' is set to `address(cash)`.\n *\n *         Following the above mentioned deployment, the address of the CashFactory contract will:\n *         i) Grant the `DEFAULT_ADMIN_ROLE` & PAUSER_ROLE to the `guardian` address\n *         ii) Revoke the `MINTER_ROLE`, `PAUSER_ROLE` & `DEFAULT_ADMIN_ROLE` from address(this).\n *         iii) Transfer ownership of the ProxyAdmin to that of the `guardian` address.\n *\n * @notice `guardian` address in constructor is a msig.\n */\ncontract CashKYCSenderFactory is IMulticall {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant DEFAULT_ADMIN_ROLE = bytes32(0);\n\n  address internal immutable guardian;\n  CashKYCSender public cashKYCSenderImplementation;\n  ProxyAdmin public cashKYCSenderProxyAdmin;\n  TokenProxy public cashKYCSenderProxy;\n\n  constructor(address _guardian) {\n    guardian = _guardian;\n  }\n\n  /**\n   * @dev This function will deploy an upgradable instance of CashKYCSender\n   *\n   * @param name   The name of the token we want to deploy.\n   * @param ticker The ticker for the token we want to deploy.\n   *\n   * @return address The address of the proxy contract.\n   * @return address The address of the proxyAdmin contract.\n   * @return address The address of the implementation contract.\n   *\n   * @notice 1) Will automatically revoke all deployer roles granted to\n   *            address(this).\n   *         2) Will grant DEFAULT_ADMIN & PAUSER_ROLE(S) to `guardian`\n   *            address specified in constructor.\n   *         3) Will transfer ownership of the proxyAdmin to guardian\n   *            address.\n   *\n   */\n  function deployCashKYCSender(\n    string calldata name,\n    string calldata ticker,\n    address registry,\n    uint256 kycRequirementGroup\n  ) external onlyGuardian returns (address, address, address) {\n    cashKYCSenderImplementation = new CashKYCSender();\n    cashKYCSenderProxyAdmin = new ProxyAdmin();\n    cashKYCSenderProxy = new TokenProxy(\n      address(cashKYCSenderImplementation),\n      address(cashKYCSenderProxyAdmin),\n      \"\"\n    );\n    CashKYCSender cashKYCSenderProxied = CashKYCSender(\n      address(cashKYCSenderProxy)\n    );\n    cashKYCSenderProxied.initialize(\n      name,\n      ticker,\n      registry,\n      kycRequirementGroup\n    );\n\n    cashKYCSenderProxied.grantRole(DEFAULT_ADMIN_ROLE, guardian);\n    cashKYCSenderProxied.grantRole(PAUSER_ROLE, guardian);\n\n    cashKYCSenderProxied.revokeRole(MINTER_ROLE, address(this));\n    cashKYCSenderProxied.revokeRole(PAUSER_ROLE, address(this));\n    cashKYCSenderProxied.revokeRole(DEFAULT_ADMIN_ROLE, address(this));\n\n    cashKYCSenderProxyAdmin.transferOwnership(guardian);\n    assert(cashKYCSenderProxyAdmin.owner() == guardian);\n    emit CashKYCSenderDeployed(\n      address(cashKYCSenderProxied),\n      address(cashKYCSenderProxyAdmin),\n      address(cashKYCSenderImplementation),\n      name,\n      ticker,\n      registry\n    );\n    return (\n      address(cashKYCSenderProxied),\n      address(cashKYCSenderProxyAdmin),\n      address(cashKYCSenderImplementation)\n    );\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyGuardian returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /**\n   * @dev Event emitted when upgradable CashKYCSender is deployed\n   *\n   * @param proxy             The address for the proxy contract\n   * @param proxyAdmin        The address for the proxy admin contract\n   * @param implementation    The address for the implementation contract\n   */\n  event CashKYCSenderDeployed(\n    address proxy,\n    address proxyAdmin,\n    address implementation,\n    string name,\n    string ticker,\n    address registry\n  );\n\n  modifier onlyGuardian() {\n    require(\n      msg.sender == guardian,\n      \"CashKYCSenderFactory: You are not the Guardian\"\n    );\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/cash/factory/CashKYCSenderReceiverFactory.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n// Proxy admin contract used in OZ upgrades plugin\nimport \"contracts/cash/external/openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"contracts/cash/Proxy.sol\";\nimport \"contracts/cash/token/CashKYCSenderReceiver.sol\";\nimport \"contracts/cash/interfaces/IMulticall.sol\";\n\n/**\n * @title CashKYCSenderReceiverFactory\n * @author Ondo Finance\n * @notice This contract serves as a Factory for the upgradable CashKYCSenderReceiver token contract.\n *         Upon calling `deployCashKYCSenderReceiver` the `guardian` address (set in constructor) will\n *         deploy the following:\n *         1) CashKYCSenderReceiver - The implementation contract, ERC20 contract with the initializer disabled\n *         2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\n *                         @notice Owner is set to `guardian` address.\n *         3) TransparentUpgradeableProxy - OZ, proxy contract. Admin is set to `address(proxyAdmin)`.\n *                                          `_logic' is set to `address(cash)`.\n *\n *         Following the above mentioned deployment, the address of the CashFactory contract will:\n *         i) Grant the `DEFAULT_ADMIN_ROLE` & PAUSER_ROLE to the `guardian` address\n *         ii) Revoke the `MINTER_ROLE`, `PAUSER_ROLE` & `DEFAULT_ADMIN_ROLE` from address(this).\n *         iii) Transfer ownership of the ProxyAdmin to that of the `guardian` address.\n *\n * @notice `guardian` address in constructor is a msig.\n */\ncontract CashKYCSenderReceiverFactory is IMulticall {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant DEFAULT_ADMIN_ROLE = bytes32(0);\n\n  address internal immutable guardian;\n  CashKYCSenderReceiver public cashKYCSenderReceiverImplementation;\n  ProxyAdmin public cashKYCSenderReceiverProxyAdmin;\n  TokenProxy public cashKYCSenderReceiverProxy;\n\n  constructor(address _guardian) {\n    guardian = _guardian;\n  }\n\n  /**\n   * @dev This function will deploy an upgradable instance of CashKYCSenderReceiver\n   *\n   * @param name   The name of the token we want to deploy.\n   * @param ticker The ticker for the token we want to deploy.\n   *\n   * @return address The address of the proxy contract.\n   * @return address The address of the proxyAdmin contract.\n   * @return address The address of the implementation contract.\n   *\n   * @notice 1) Will automatically revoke all deployer roles granted to\n   *            address(this).\n   *         2) Will grant DEFAULT_ADMIN & PAUSER_ROLE(S) to `guardian`\n   *            address specified in constructor.\n   *         3) Will transfer ownership of the proxyAdmin to guardian\n   *            address.\n   *\n   */\n  function deployCashKYCSenderReceiver(\n    string calldata name,\n    string calldata ticker,\n    address registry,\n    uint256 kycRequirementGroup\n  ) external onlyGuardian returns (address, address, address) {\n    cashKYCSenderReceiverImplementation = new CashKYCSenderReceiver();\n    cashKYCSenderReceiverProxyAdmin = new ProxyAdmin();\n    cashKYCSenderReceiverProxy = new TokenProxy(\n      address(cashKYCSenderReceiverImplementation),\n      address(cashKYCSenderReceiverProxyAdmin),\n      \"\"\n    );\n    CashKYCSenderReceiver cashKYCSenderReceiverProxied = CashKYCSenderReceiver(\n      address(cashKYCSenderReceiverProxy)\n    );\n    cashKYCSenderReceiverProxied.initialize(\n      name,\n      ticker,\n      registry,\n      kycRequirementGroup\n    );\n\n    cashKYCSenderReceiverProxied.grantRole(DEFAULT_ADMIN_ROLE, guardian);\n    cashKYCSenderReceiverProxied.grantRole(PAUSER_ROLE, guardian);\n\n    cashKYCSenderReceiverProxied.revokeRole(MINTER_ROLE, address(this));\n    cashKYCSenderReceiverProxied.revokeRole(PAUSER_ROLE, address(this));\n    cashKYCSenderReceiverProxied.revokeRole(DEFAULT_ADMIN_ROLE, address(this));\n\n    cashKYCSenderReceiverProxyAdmin.transferOwnership(guardian);\n    assert(cashKYCSenderReceiverProxyAdmin.owner() == guardian);\n    emit CashKYCSenderReceiverDeployed(\n      address(cashKYCSenderReceiverProxied),\n      address(cashKYCSenderReceiverProxyAdmin),\n      address(cashKYCSenderReceiverImplementation),\n      name,\n      ticker,\n      registry\n    );\n    return (\n      address(cashKYCSenderReceiverProxied),\n      address(cashKYCSenderReceiverProxyAdmin),\n      address(cashKYCSenderReceiverImplementation)\n    );\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyGuardian returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /**\n   * @dev Event emitted when upgradable CashKYCSenderReceiver is deployed\n   *\n   * @param proxy             The address for the proxy contract\n   * @param proxyAdmin        The address for the proxy admin contract\n   * @param implementation    The address for the implementation contract\n   */\n  event CashKYCSenderReceiverDeployed(\n    address proxy,\n    address proxyAdmin,\n    address implementation,\n    string name,\n    string ticker,\n    address registry\n  );\n\n  modifier onlyGuardian() {\n    require(\n      msg.sender == guardian,\n      \"CashKYCSenderReceiverFactory: You are not the Guardian\"\n    );\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/cash/kyc/KYCRegistry.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/cash/interfaces/IKYCRegistry.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/cash/external/chainalysis/ISanctionsList.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title KYCRegistry\n * @author Ondo Finance\n * @notice This contract manages KYC status for addresses that interact with\n *         Ondo products.\n */\ncontract KYCRegistry is AccessControlEnumerable, IKYCRegistry, EIP712 {\n  bytes32 public constant _APPROVAL_TYPEHASH =\n    keccak256(\n      \"KYCApproval(uint256 kycRequirementGroup,address user,uint256 deadline)\"\n    );\n  // Admin role that has permission to add/remove KYC related roles\n  bytes32 public constant REGISTRY_ADMIN = keccak256(\"REGISTRY_ADMIN\");\n\n  // {<KYCLevel> => {<user account address> => is user KYC approved}\n  mapping(uint256 => mapping(address => bool)) public kycState;\n\n  // Represents which roles msg.sender must have in order to change\n  // KYC state at that group.\n  /// @dev Default admin role of 0x00... will be able to set all group roles\n  ///      that are unset.\n  mapping(uint256 => bytes32) public kycGroupRoles;\n\n  // Chainalysis sanctions list\n  ISanctionsList public immutable sanctionsList;\n\n  /// @notice constructor\n  constructor(\n    address admin,\n    address _sanctionsList\n  ) EIP712(\"OndoKYCRegistry\", \"1\") {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(REGISTRY_ADMIN, admin);\n    sanctionsList = ISanctionsList(_sanctionsList);\n  }\n\n  /**\n   * @notice Add a provided user to the registry at a specified\n   *         `kycRequirementGroup`. In order to sucessfully call this function,\n   *         An external caller must provide a signature signed by an address\n   *         with the role `kycGroupRoles[kycRequirementGroup]`.\n   *\n   * @param kycRequirementGroup KYC requirement group to modify `user`'s\n   *                            KYC status for\n   * @param user                User address to change KYC status for\n   * @param deadline            Deadline for which the signature-auth based\n   *                            operations with the signature become invalid\n   * @param v                   Recovery ID (See EIP 155)\n   * @param r                   Part of ECDSA signature representation\n   * @param s                   Part of ECDSA signature representation\n   *\n   * @dev Please note that ecrecover (which the Registry uses) requires V be\n   *      27 or 28, so a conversion must be applied before interacting with\n   *      `addKYCAddressViaSignature`\n   */\n  function addKYCAddressViaSignature(\n    uint256 kycRequirementGroup,\n    address user,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n    require(\n      !kycState[kycRequirementGroup][user],\n      \"KYCRegistry: user already verified\"\n    );\n    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n    bytes32 structHash = keccak256(\n      abi.encode(_APPROVAL_TYPEHASH, kycRequirementGroup, user, deadline)\n    );\n    // https://eips.ethereum.org/EIPS/eip-712 compliant\n    bytes32 expectedMessage = _hashTypedDataV4(structHash);\n\n    // `ECDSA.recover` reverts if signer is address(0)\n    address signer = ECDSA.recover(expectedMessage, v, r, s);\n    _checkRole(kycGroupRoles[kycRequirementGroup], signer);\n\n    kycState[kycRequirementGroup][user] = true;\n\n    emit KYCAddressAddViaSignature(\n      msg.sender,\n      user,\n      signer,\n      kycRequirementGroup,\n      deadline\n    );\n  }\n\n  /// @notice Getter for EIP 712 Domain separator.\n  function DOMAIN_SEPARATOR() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /**\n   * @notice Get KYC status of `account` for the provided\n   *         `kycRequirementGroup`. In order to return true, `account`'s state\n   *         in this contract must be true and additionally pass a\n   *         `sanctionsList` check.\n   *\n   * @param kycRequirementGroup KYC group to check KYC status for\n   * @param account             Addresses to check KYC status for\n   */\n  function getKYCStatus(\n    uint256 kycRequirementGroup,\n    address account\n  ) external view override returns (bool) {\n    return\n      kycState[kycRequirementGroup][account] &&\n      !sanctionsList.isSanctioned(account);\n  }\n\n  /**\n   * @notice Assigns a role to specified `kycRequirementGroup` to gate changes\n   *         to that group's KYC state\n   *\n   * @param kycRequirementGroup KYC group to set role for\n   * @param role                The role being assigned to a group\n   */\n  function assignRoletoKYCGroup(\n    uint256 kycRequirementGroup,\n    bytes32 role\n  ) external onlyRole(REGISTRY_ADMIN) {\n    kycGroupRoles[kycRequirementGroup] = role;\n    emit RoleAssignedToKYCGroup(kycRequirementGroup, role);\n  }\n\n  /**\n   * @notice Add addresses to KYC list for specified `kycRequirementGroup`\n   *\n   * @param kycRequirementGroup KYC group associated with `addresses`\n   * @param addresses           List of addresses to grant KYC'd status\n   */\n  function addKYCAddresses(\n    uint256 kycRequirementGroup,\n    address[] calldata addresses\n  ) external onlyRole(kycGroupRoles[kycRequirementGroup]) {\n    uint256 length = addresses.length;\n    for (uint256 i = 0; i < length; i++) {\n      kycState[kycRequirementGroup][addresses[i]] = true;\n    }\n    emit KYCAddressesAdded(msg.sender, kycRequirementGroup, addresses);\n  }\n\n  /**\n   * @notice Remove addresses from KYC list\n   *\n   * @param kycRequirementGroup KYC group associated with `addresses`\n   * @param addresses           List of addresses to revoke KYC'd status\n   */\n  function removeKYCAddresses(\n    uint256 kycRequirementGroup,\n    address[] calldata addresses\n  ) external onlyRole(kycGroupRoles[kycRequirementGroup]) {\n    uint256 length = addresses.length;\n    for (uint256 i = 0; i < length; i++) {\n      kycState[kycRequirementGroup][addresses[i]] = false;\n    }\n    emit KYCAddressesRemoved(msg.sender, kycRequirementGroup, addresses);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Events\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @dev Event emitted when a role is assigned to a KYC group\n   *\n   * @param kycRequirementGroup The KYC group\n   * @param role                The role being assigned\n   */\n  event RoleAssignedToKYCGroup(\n    uint256 indexed kycRequirementGroup,\n    bytes32 indexed role\n  );\n\n  /**\n   * @dev Event emitted when addresses are added to KYC requirement group\n   *\n   * @param sender              Sender of the transaction\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param addresses           Array of addresses being added as elligible\n   */\n  event KYCAddressesAdded(\n    address indexed sender,\n    uint256 indexed kycRequirementGroup,\n    address[] addresses\n  );\n\n  /**\n   * @dev Event emitted when a user is added to the KYCRegistry\n   *      by an external caller through signature-auth\n   *\n   * @param sender              Sender of the transaction\n   * @param user                User being added to registry\n   * @param signer              Digest signer\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param deadline            Expiration constraint on signature\n   */\n  event KYCAddressAddViaSignature(\n    address indexed sender,\n    address indexed user,\n    address indexed signer,\n    uint256 kycRequirementGroup,\n    uint256 deadline\n  );\n\n  /**\n   * @dev Event emitted when addresses are removed from KYC requirement group\n   *\n   * @param sender              Sender of the transaction\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param addresses           Array of addresses being added as elligible\n   */\n  event KYCAddressesRemoved(\n    address indexed sender,\n    uint256 indexed kycRequirementGroup,\n    address[] addresses\n  );\n}"
    },
    {
      "filename": "contracts/cash/CashManager.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\nimport \"contracts/cash/interfaces/ICashManager.sol\";\nimport \"contracts/cash/interfaces/IMulticall.sol\";\nimport \"contracts/cash/token/Cash.sol\";\nimport \"contracts/cash/kyc/KYCRegistryClientConstructable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/SafeERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract CashManager is\n  ICashManager,\n  IMulticall,\n  AccessControlEnumerable,\n  KYCRegistryClientConstructable,\n  Pausable,\n  ReentrancyGuard\n{\n  using SafeERC20 for IERC20;\n\n  /// @dev Tokens\n  // ERC20 token used to Mint CASH with\n  IERC20 public immutable collateral;\n\n  // CASH contract\n  Cash public immutable cash;\n\n  /// @dev Collateral Recipients\n  // The address to which the `collateral` is sent\n  address public assetRecipient;\n\n  // The address to which fees are sent\n  address public feeRecipient;\n\n  // The address from which redemptions are processed\n  address public assetSender;\n\n  /// @dev Mint/Redeem Parameters\n  // Minimum amount that must be deposited to mint CASH\n  // Denoted in decimals of `collateral`\n  uint256 public minimumDepositAmount = 10_000;\n\n  // Minimum amount that must be redeemed for a withdraw request\n  uint256 public minimumRedeemAmount;\n\n  // Minting fee specified in basis points\n  uint256 public mintFee = 0;\n\n  // Limit for how far `exchangeRate` can stray from\n  // `lastSetMintExchangeRate` within an epoch (in basis points)\n  uint256 public exchangeRateDeltaLimit = 100;\n\n  // Struct representing all redemption requests in an epoch\n  struct RedemptionRequests {\n    // Total CASH burned in the epoch\n    uint256 totalBurned;\n    // Mapping from address to amount of CASH address burned\n    mapping(address => uint256) addressToBurnAmt;\n  }\n\n  // Mapping from epoch to redemption info struct for that epoch\n  mapping(uint256 => RedemptionRequests) public redemptionInfoPerEpoch;\n\n  // Mapping used for getting the exchange rate during a given epoch\n  mapping(uint256 => uint256) public epochToExchangeRate;\n\n  // Nested mapping containing mint requests for an epoch\n  // { <epoch> : {<user> : <collateralAmount> }\n  mapping(uint256 => mapping(address => uint256)) public mintRequestsPerEpoch;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Decimal multiplier representing the difference between `CASH` decimals\n  // In `collateral` token decimals\n  uint256 public immutable decimalsMultiplier;\n\n  /// @dev Epoch Parameters\n  // Epoch that contract is currently in\n  uint256 public currentEpoch;\n\n  // Duration of an epoch in seconds\n  uint256 public epochDuration;\n\n  // Timestamp of the start of `currentEpoch`\n  uint256 public currentEpochStartTimestamp;\n\n  // `exchangeRate` at start of `currentEpoch`\n  uint256 public lastSetMintExchangeRate = 1e6;\n\n  /// @dev Mint/Redeem Limit Parameters\n  // Maximum amount that can be minted during an epoch\n  uint256 public mintLimit;\n\n  // Amount already minted during the `currentEpoch`\n  uint256 public currentMintAmount;\n\n  // Maximum amount that can be redeemed during an epoch\n  uint256 public redeemLimit;\n\n  // Amount already redeemed during the `currentEpoch`\n  uint256 public currentRedeemAmount;\n\n  /// @dev Role Based Access control members\n  bytes32 public constant MANAGER_ADMIN = keccak256(\"MANAGER_ADMIN\");\n  bytes32 public constant PAUSER_ADMIN = keccak256(\"PAUSER_ADMIN\");\n  bytes32 public constant SETTER_ADMIN = keccak256(\"SETTER_ADMIN\");\n\n  /// @notice constructor\n  constructor(\n    address _collateral,\n    address _cash,\n    address managerAdmin,\n    address pauser,\n    address _assetRecipient,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _mintLimit,\n    uint256 _redeemLimit,\n    uint256 _epochDuration,\n    address _kycRegistry,\n    uint256 _kycRequirementGroup\n  ) KYCRegistryClientConstructable(_kycRegistry, _kycRequirementGroup) {\n    if (_collateral == address(0)) {\n      revert CollateralZeroAddress();\n    }\n    if (_cash == address(0)) {\n      revert CashZeroAddress();\n    }\n    if (_assetRecipient == address(0)) {\n      revert AssetRecipientZeroAddress();\n    }\n    if (_assetSender == address(0)) {\n      revert AssetSenderZeroAddress();\n    }\n    if (_feeRecipient == address(0)) {\n      revert FeeRe"
    }
  ]
}