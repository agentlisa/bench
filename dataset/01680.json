{
  "Title": "Invalid Entries Remain in _addressToRoles Array",
  "Content": "The function [`removeRoleFrom`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/PermissionsRegistry.sol#L110) of the [`PermissionsRegistry`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/PermissionsRegistry.sol) contract revokes a role from the specified `address` and is supposed to appropriately update the arrays `_roleToAddresses` and `_addressToRoles`.\n\n\nHowever, because of a [typographical error](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/PermissionsRegistry.sol#L125-L126), the code never loops over the `_addressToRoles` array, resulting in invalid remaining entries.\n\n\nConsider fixing the typographical error so that no invalid entries remain in the array.\n\n\n***Update:** Resolved in [pull request #5](https://github.com/ThenafiBNB/THENA-Contracts/pull/5) at commit [95d8d25](https://github.com/ThenafiBNB/THENA-Contracts/pull/5/commits/95d8d25d27acceea16755ae973f1bf034e9171a7).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/PermissionsRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\n\n/*\n    This contract handles the accesses to the various Thena contracts.\n*/\n\ncontract PermissionsRegistry {\n\n    /// @notice Control this contract \n    address public thenaMultisig;\n\n    /// @notice Control this contract \n    address public thenaTeamMultisig;\n\n    /// @notice Control emergency functions (set to multisig)\n    address public emergencyCouncil;\n\n    /// @notice Check if caller has a role active   (role -> caller -> true/false)\n    mapping(bytes => mapping(address => bool)) public hasRole;\n    mapping(bytes => bool) internal _checkRole;\n\n    mapping(bytes => address[]) internal _roleToAddresses;\n    mapping(address => bytes[]) internal _addressToRoles;\n\n    /// @notice Roles array\n    bytes[] internal _roles;\n\n\n    constructor() {\n        thenaTeamMultisig = msg.sender;\n        thenaMultisig = msg.sender;\n        emergencyCouncil = msg.sender;\n\n\n        _roles.push(bytes(\"GOVERNANCE\"));\n        _checkRole[(bytes(\"GOVERNANCE\"))] = true;\n\n        _roles.push(bytes(\"VOTER_ADMIN\"));\n        _checkRole[(bytes(\"VOTER_ADMIN\"))] = true;\n\n        _roles.push(bytes(\"GAUGE_ADMIN\"));\n        _checkRole[(bytes(\"GAUGE_ADMIN\"))] = true;\n\n        _roles.push(bytes(\"BRIBE_ADMIN\"));\n        _checkRole[(bytes(\"BRIBE_ADMIN\"))] = true;\n        \n        _roles.push(bytes(\"FEE_MANAGER\"));\n        _checkRole[(bytes(\"FEE_MANAGER\"))] = true;\n\n        _roles.push(bytes(\"CL_FEES_VAULT_ADMIN\"));\n        _checkRole[(bytes(\"CL_FEES_VAULT_ADMIN\"))] = true;\n\n    }\n\n    modifier onlyThenaMultisig() {\n        require(msg.sender == thenaMultisig);\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    ROLES SETTINGS\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice add a new role\n    /// @param  role    new role's string (eg role = \"GAUGE_ADMIN\")\n    function addRole(string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(!_checkRole[_role], 'is a role');\n        _checkRole[_role] = true;\n        _roles.push(_role);\n    }\n\n    /// @notice Remove a role\n    /// @dev    set last one to i_th position then .pop()\n    function removeRole(string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n\n        for(uint i = 0; i < _roles.length; i++){\n            if(keccak256(_roles[i]) == keccak256(_role)){\n                _roles[i] = _roles[_roles.length -1];\n                _roles.pop();\n                _checkRole[_role] = false;\n                break; \n            }\n        }\n    }\n\n\n    \n    /// @notice Set a role for an address\n    function setRoleFor(address c, string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n        require(!hasRole[_role][c], 'assigned');\n\n        hasRole[_role][c] = true;\n\n        _roleToAddresses[_role].push(c);\n        _addressToRoles[c].push(_role);\n\n    }\n\n    \n    /// @notice remove a role from an address\n    function removeRoleFrom(address c, string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n        require(hasRole[_role][c], 'not assigned');\n\n        hasRole[_role][c] = false;\n\n        address[] storage rta = _roleToAddresses[_role];\n        for(uint i = 0; i < rta.length; i++){\n            if(rta[i] == c){\n                rta[i] = rta[rta.length -1];\n                rta.pop();\n            }\n        }\n\n        bytes[] storage atr = _addressToRoles[c];\n        for(uint i = 0; i < rta.length; i++){\n            if(keccak256(atr[i]) == keccak256(_role)){\n                atr[i] = atr[atr.length -1];\n                atr.pop();\n            }\n        }\n        \n    }\n\n    \n\n  \n\n    /************************************************************\n                                VIEW\n    *************************************************************/\n    \n    /// @notice Read roles and return strings\n    function rolesToString() external view returns(string[] memory __roles){\n        __roles = new string[](_roles.length);\n        for(uint i = 0; i < _roles.length; i++){\n            __roles[i] = string(_roles[i]);\n        }\n    }\n\n    \n    /// @notice Read roles array and return bytes\n    function roles() external view returns(bytes[] memory){\n        return _roles;\n    }\n\n    /// @notice Read roles length\n    function rolesLength() external view returns(uint){\n        return _roles.length;\n    }\n\n     /// @notice Return addresses for a given role\n    function roleToAddresses(string memory role) external view returns(address[] memory _addresses){\n        return _roleToAddresses[bytes(role)];\n    }\n\n    /// @notice Return roles for a given address\n    function addressToRole(address _user) external view returns(string[] memory){\n        string[] memory _temp = new string[](_addressToRoles[_user].length);\n        uint i = 0;\n        for(i; i < _temp.length; i++){\n            _temp[i] = string(_addressToRoles[_user][i]);\n        }\n        return _temp;\n    }\n\n    \n    /************************************************************\n                                HELPERS\n    *************************************************************/\n\n    /// @notice Helper function to get bytes from a string\n    function __helper_stringToBytes(string memory _input) public pure returns(bytes memory){\n        return bytes(_input);\n    }\n\n    /// @notice Helper function to get string from bytes\n    function __helper_bytesToString(bytes memory _input) public pure returns(string memory){\n        return string(_input);\n    }\n\n\n  \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                EMERGENCY AND MULTISIG\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n\n    /// @notice set emergency counsil\n    /// @param _new new address    \n    function setEmergencyCouncil(address _new) external {\n        require(msg.sender == emergencyCouncil || msg.sender == thenaMultisig);\n        require(_new != address(0));\n        require(_new != emergencyCouncil);\n        emergencyCouncil = _new;\n    }\n\n\n    /// @notice set thena team multisig\n    /// @param _new new address    \n    function setThenaTeamMultisig(address _new) external {\n        require(msg.sender == thenaTeamMultisig);\n        require(_new != address(0));\n        require(_new != thenaTeamMultisig);\n        thenaTeamMultisig = _new;\n    }\n\n    /// @notice set thena multisig\n    /// @param _new new address    \n    function setThenaMultisig(address _new) external {\n        require(msg.sender == thenaMultisig);\n        require(_new != address(0));\n        require(_new != thenaMultisig);\n        thenaMultisig = _new;\n    }\n    \n\n\n}"
    },
    {
      "filename": "contracts/PermissionsRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\n\n/*\n    This contract handles the accesses to the various Thena contracts.\n*/\n\ncontract PermissionsRegistry {\n\n    /// @notice Control this contract \n    address public thenaMultisig;\n\n    /// @notice Control this contract \n    address public thenaTeamMultisig;\n\n    /// @notice Control emergency functions (set to multisig)\n    address public emergencyCouncil;\n\n    /// @notice Check if caller has a role active   (role -> caller -> true/false)\n    mapping(bytes => mapping(address => bool)) public hasRole;\n    mapping(bytes => bool) internal _checkRole;\n\n    mapping(bytes => address[]) internal _roleToAddresses;\n    mapping(address => bytes[]) internal _addressToRoles;\n\n    /// @notice Roles array\n    bytes[] internal _roles;\n\n\n    constructor() {\n        thenaTeamMultisig = msg.sender;\n        thenaMultisig = msg.sender;\n        emergencyCouncil = msg.sender;\n\n\n        _roles.push(bytes(\"GOVERNANCE\"));\n        _checkRole[(bytes(\"GOVERNANCE\"))] = true;\n\n        _roles.push(bytes(\"VOTER_ADMIN\"));\n        _checkRole[(bytes(\"VOTER_ADMIN\"))] = true;\n\n        _roles.push(bytes(\"GAUGE_ADMIN\"));\n        _checkRole[(bytes(\"GAUGE_ADMIN\"))] = true;\n\n        _roles.push(bytes(\"BRIBE_ADMIN\"));\n        _checkRole[(bytes(\"BRIBE_ADMIN\"))] = true;\n        \n        _roles.push(bytes(\"FEE_MANAGER\"));\n        _checkRole[(bytes(\"FEE_MANAGER\"))] = true;\n\n        _roles.push(bytes(\"CL_FEES_VAULT_ADMIN\"));\n        _checkRole[(bytes(\"CL_FEES_VAULT_ADMIN\"))] = true;\n\n    }\n\n    modifier onlyThenaMultisig() {\n        require(msg.sender == thenaMultisig);\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    ROLES SETTINGS\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice add a new role\n    /// @param  role    new role's string (eg role = \"GAUGE_ADMIN\")\n    function addRole(string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(!_checkRole[_role], 'is a role');\n        _checkRole[_role] = true;\n        _roles.push(_role);\n    }\n\n    /// @notice Remove a role\n    /// @dev    set last one to i_th position then .pop()\n    function removeRole(string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n\n        for(uint i = 0; i < _roles.length; i++){\n            if(keccak256(_roles[i]) == keccak256(_role)){\n                _roles[i] = _roles[_roles.length -1];\n                _roles.pop();\n                _checkRole[_role] = false;\n                break; \n            }\n        }\n    }\n\n\n    \n    /// @notice Set a role for an address\n    function setRoleFor(address c, string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n        require(!hasRole[_role][c], 'assigned');\n\n        hasRole[_role][c] = true;\n\n        _roleToAddresses[_role].push(c);\n        _addressToRoles[c].push(_role);\n\n    }\n\n    \n    /// @notice remove a role from an address\n    function removeRoleFrom(address c, string memory role) external onlyThenaMultisig {\n        bytes memory _role = bytes(role);\n        require(_checkRole[_role], 'not a role');\n        require(hasRole[_role][c], 'not assigned');\n\n        hasRole[_role][c] = false;\n\n        address[] storage rta = _roleToAddresses[_role];\n        for(uint i = 0; i < rta.length; i++){\n            if(rta[i] == c){\n                rta[i] = rta[rta.length -1];\n                rta.pop();\n            }\n        }\n\n        bytes[] storage atr = _addressToRoles[c];\n        for(uint i = 0; i < rta.length; i++){\n            if(keccak256(atr[i]) == keccak256(_role)){\n                atr[i] = atr[atr.length -1];\n                atr.pop();\n            }\n        }\n        \n    }\n\n    \n\n  \n\n    /************************************************************\n                                VIEW\n    *************************************************************/\n    \n    /// @notice Read roles and return strings\n    function rolesToString() external view returns(string[] memory __roles){\n        __roles = new string[](_roles.length);\n        for(uint i = 0; i < _roles.length; i++){\n            __roles[i] = string(_roles[i]);\n        }\n    }\n\n    \n    /// @notice Read roles array and return bytes\n    function roles() external view returns(bytes[] memory){\n        return _roles;\n    }\n\n    /// @notice Read roles length\n    function rolesLength() external view returns(uint){\n        return _roles.length;\n    }\n\n     /// @notice Return addresses for a given role\n    function roleToAddresses(string memory role) external view returns(address[] memory _addresses){\n        return _roleToAddresses[bytes(role)];\n    }\n\n    /// @notice Return roles for a given address\n    function addressToRole(address _user) external view returns(string[] memory){\n        string[] memory _temp = new string[](_addressToRoles[_user].length);\n        uint i = 0;\n        for(i; i < _temp.length; i++){\n            _temp[i] = string(_addressToRoles[_user][i]);\n        }\n        return _temp;\n    }\n\n    \n    /************************************************************\n                                HELPERS\n    *************************************************************/\n\n    /// @notice Helper function to get bytes from a string\n    function __helper_stringToBytes(string memory _input) public pure returns(bytes memory){\n        return bytes(_input);\n    }\n\n    /// @notice Helper function to get string from bytes\n    function __helper_bytesToString(bytes memory _input) public pure returns(string memory){\n        return string(_input);\n    }\n\n\n  \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                EMERGENCY AND MULTISIG\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n\n    /// @notice set emergency counsil\n    /// @param _new new address    \n    function setEmergencyCouncil(address _new) external {\n        require(msg.sender == emergencyCouncil || msg.sender == thenaMultisig);\n        require(_new != address(0));\n        require(_new != emergencyCouncil);\n        emergencyCouncil = _new;\n    }\n\n\n    /// @notice set thena team multisig\n    /// @param _new new address    \n    function setThenaTeamMultisig(address _new) external {\n        require(msg.sender == thenaTeamMultisig);\n        require(_new != address(0));\n        require(_new != thenaTeamMultisig);\n        thenaTeamMultisig = _new;\n    }\n\n    /// @notice set thena multisig\n    /// @param _new new address    \n    function setThenaMultisig(address _new) external {\n        require(msg.sender == thenaMultisig);\n        require(_new != address(0));\n        require(_new != thenaMultisig);\n        thenaMultisig = _new;\n    }\n    \n\n\n}"
    }
  ]
}