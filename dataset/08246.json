{
  "Title": "[G-03] Avoid emitting a storage variable when a memory value is available",
  "Content": "\nWhen they are the same, consider emitting the memory value instead of the storage value:\n\n*   [NFTDropCollection.sol#L242](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTDropCollection.sol#L242)\n\n```diff\nFile: NFTDropCollection.sol\n232:   function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n233:     external\n234:     validBaseURI(_baseURI)\n235:     onlyWhileUnrevealed\n236:     onlyAdmin\n237:   {\n238:     require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n239: \n240:     postRevealBaseURIHash = _postRevealBaseURIHash;\n241:     baseURI = _baseURI;\n- 242:     emit URIUpdated(baseURI, postRevealBaseURIHash);\n+ 242:     emit URIUpdated(_baseURI, _postRevealBaseURIHash);\n243:   }\n```\n\n*   [NFTDropMarketFixedPriceSale.sol#L156](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L156)\n\n```diff\nFile: NFTDropMarketFixedPriceSale.sol\n152:     // Save the sale details.\n153:     saleConfig.seller = payable(msg.sender);\n154:     saleConfig.price = price;\n155:     saleConfig.limitPerAccount = limitPerAccount;\n- 156:     emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n+ 156:     emit CreateFixedPriceSale(nftContract, payable(msg.sender), price, limitPerAccount);\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-foundation-drop-contest",
  "Code": [
    {
      "filename": "contracts/NFTDropCollection.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTDropCollectionMint.sol\";\n\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/roles/AdminRole.sol\";\nimport \"./mixins/roles/MinterRole.sol\";\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A contract to batch mint a collection of NFTs.\n * @notice A 10% royalty to the creator is included which may be split with collaborators.\n * @dev A collection can have up to 4,294,967,295 (2^32-1) tokens\n */\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  AdminRole,\n  MinterRole,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using Strings for uint256;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address to pay the proceeds/royalties for the collection.\n   * @dev If this is set to address(0) then the proceeds go to the creator.\n   */\n  address payable private paymentAddress;\n  // 96 bits free space\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `<tokenId>.json` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for `tokenId`: \"1\" with `baseURI`: \"ipfs://foo/\" is \"ipfs://foo/1.json\".\n   * @return The base URI used by this collection.\n   */\n  string public baseURI;\n\n  /****** Slot 2 ******/\n  /**\n   * @notice The hash of the revealed baseURI for the collection.\n   * @dev This can be used to verify that the content was not changed after NFTs were minted.\n   * @return bytes32(0) if the content has been revealed.\n   * In pre-reveal state this is set to bytes32(1) when the final content is unknown\n   * otherwise set to keccak256(finalContentBaseURI).\n   */\n  bytes32 public postRevealBaseURIHash;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the collection is revealed.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  event URIUpdated(string baseURI, bytes32 postRevealBaseURIHash);\n\n  modifier validBaseURI(string calldata _baseURI) {\n    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\n    _;\n  }\n\n  modifier onlyWhileUnrevealed() {\n    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * This account is the default admin for this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   * @param _baseURI The base URI for the collection.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param _maxTokenId The max token id for this collection.\n   * @param _approvedMinter An optional address to grant the MINTER_ROLE.\n   * Set to address(0) if only admins should be granted permission to mint.\n   * @param _paymentAddress The address that will receive royalties and mint payments.\n   */\n  function initialize(\n    address payable _creator,\n    string calldata _name,\n    string calldata _symbol,\n    string calldata _baseURI,\n    bytes32 _postRevealBaseURIHash,\n    uint32 _maxTokenId,\n    address _approvedMinter,\n    address payable _paymentAddress\n  ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n\n    // Initialize the NFT\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, _maxTokenId);\n\n    // Initialize royalties\n    if (_paymentAddress != address(0)) {\n      // If no payment address was defined, use the creator's address.\n      paymentAddress = _paymentAddress;\n    }\n\n    // Initialize URI\n    baseURI = _baseURI;\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n\n    // Initialize access control\n    AdminRole._initializeAdminRole(_creator);\n    if (_approvedMinter != address(0)) {\n      MinterRole._initializeMinterRole(_approvedMinter);\n    }\n  }\n\n  /**\n   * @notice Allows the collection admin to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyAdmin` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyAdmin {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint `count` number of NFTs for the `to` address.\n   * @dev This is only callable by an address with either the MINTER_ROLE or the DEFAULT_ADMIN_ROLE.\n   * @param count The number of NFTs to mint.\n   * @param to The address to mint the NFTs for.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   */\n  function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n    unchecked {\n      // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n      firstTokenId = latestTokenId + 1;\n    }\n    latestTokenId = latestTokenId + count;\n    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n    for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n      _mint(to, i);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a collection admin to reveal the collection's final content.\n   * @dev Once revealed, the collection's content is immutable.\n   * Use `updatePreRevealContent` to update content while unrevealed.\n   * @param _baseURI The base URI of the final content for this collection.\n   */\n  function reveal(string calldata _baseURI) external onlyAdmin validBaseURI(_baseURI) onlyWhileUnrevealed {\n    // `postRevealBaseURIHash` == 0 indicates that the collection has been revealed.\n    delete postRevealBaseURIHash;\n\n    // Set the new base URI.\n    baseURI = _baseURI;\n    emit URIUpdated(_baseURI, \"\");\n  }\n\n  /**\n   * @notice Allows a collection admin to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyAdmin {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyAdmin {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  /**\n   * @notice Allows a collection admin to update the pre-reveal content.\n   * @dev Use `reveal` to reveal the final content for this collection.\n   * @param _baseURI The base URI of the pre-reveal content.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n    external\n    validBaseURI(_baseURI)\n    onlyWhileUnrevealed\n    onlyAdmin\n  {\n    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n    baseURI = _baseURI;\n    emit URIUpdated(baseURI, postRevealBaseURIHash);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(\n    uint256 /* tokenId */\n  ) public view override returns (address payable creatorPaymentAddress) {\n    creatorPaymentAddress = paymentAddress;\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @notice Returns whether the collection has been revealed.\n   * @dev Once revealed, the collection's content is immutable.\n   * @return revealed True if the collection has been revealed.\n   */\n  function isRevealed() external view returns (bool revealed) {\n    revealed = postRevealBaseURIHash == bytes32(0);\n  }\n\n  /**\n   * @notice Get the number of tokens which can still be minted.\n   * @return count The max number of additional NFTs that can be minted by this collection.\n   */\n  function numberOfTokensAvailableToMint() external view returns (uint256 count) {\n    // Mint ensures that latestTokenId is always <= maxTokenId\n    unchecked {\n      count = maxTokenId - latestTokenId;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    if (interfaceId == type(INFTDropCollectionMint).interfaceId) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    _requireMinted(tokenId);\n\n    return string.concat(baseURI, tokenId.toString(), \".json\");\n  }\n}"
    },
    {
      "filename": "contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/INFTDropCollectionMint.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/MarketFees.sol\";\n\n/// @param limitPerAccount The limit of tokens an account can purchase.\nerror NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(uint256 limitPerAccount);\nerror NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\nerror NFTDropMarketFixedPriceSale_Mint_Permission_Required();\nerror NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\nerror NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\nerror NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\nerror NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\nerror NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\nerror NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n/// @param mintCost The total cost for this purchase.\nerror NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(uint256 mintCost);\n\n/**\n * @title Allows creators to list a drop collection for sale at a fixed price point.\n * @dev Listing a collection for sale in this market requires the collection to implement\n * the functions in `INFTDropCollectionMint` and to register that interface with ERC165.\n * Additionally the collection must implement access control, or more specifically:\n * `hasRole(bytes32(0), msg.sender)` must return true when called from the creator or admin's account\n * and `hasRole(keccak256(\"MINTER_ROLE\", address(this)))` must return true for this market's address.\n */\nabstract contract NFTDropMarketFixedPriceSale is MarketFees {\n  using AddressUpgradeable for address;\n  using AddressUpgradeable for address payable;\n  using ERC165Checker for address;\n\n  /**\n   * @notice Configuration for the terms of the sale.\n   * @dev This structure is packed in order to consume just a single slot.\n   */\n  struct FixedPriceSaleConfig {\n    /**\n     * @notice The seller for the drop.\n     */\n    address payable seller;\n    /**\n     * @notice The fixed price per NFT in the collection.\n     * @dev The maximum price that can be set on an NFT is ~1.2M (2^80/10^18) ETH.\n     */\n    uint80 price;\n    /**\n     * @notice The max number of NFTs an account may have while minting.\n     */\n    uint16 limitPerAccount;\n  }\n\n  /**\n   * @notice Stores the current sale information for all drop contracts.\n   */\n  mapping(address => FixedPriceSaleConfig) private nftContractToFixedPriceSaleConfig;\n\n  /**\n   * @notice The `role` type used to validate drop collections have granted this market access to mint.\n   * @return `keccak256(\"MINTER_ROLE\")`\n   */\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @notice Emitted when a collection is listed for sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @param seller The address for the seller which listed this for sale.\n   * @param price The price per NFT minted.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   */\n  event CreateFixedPriceSale(\n    address indexed nftContract,\n    address indexed seller,\n    uint256 price,\n    uint256 limitPerAccount\n  );\n\n  /**\n   * @notice Emitted when NFTs are minted from the drop.\n   * @dev The total price paid by the buyer is `totalFees + creatorRev`.\n   * @param nftContract The address of the NFT drop collection.\n   * @param buyer The address of the buyer.\n   * @param firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @param count The number of NFTs minted.\n   * @param totalFees The amount of ETH that was sent to Foundation & referrals for this sale.\n   * @param creatorRev The amount of ETH that was sent to the creator for this sale.\n   */\n  event MintFromFixedPriceDrop(\n    address indexed nftContract,\n    address indexed buyer,\n    uint256 indexed firstTokenId,\n    uint256 count,\n    uint256 totalFees,\n    uint256 creatorRev\n  );\n\n  /**\n   * @notice Create a fixed price sale drop.\n   * @param nftContract The address of the NFT drop collection.\n   * @param price The price per NFT minted.\n   * Set price to 0 for a first come first serve airdrop-like drop.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   * @dev Notes:\n   *   a) The sale is final and can not be updated or canceled.\n   *   b) The sale is immediately kicked off.\n   *   c) Any collection that abides by `INFTDropCollectionMint` and `IAccessControl` is supported.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function createFixedPriceSale(\n    address nftContract,\n    uint80 price,\n    uint16 limitPerAccount\n  ) external {\n    // Confirm the drop collection is supported\n    if (!nftContract.supportsInterface(type(INFTDropCollectionMint).interfaceId)) {\n      revert NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\n    }\n    if (INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\n    }\n\n    // Use the AccessControl interface to confirm the msg.sender has permissions to list.\n    if (!IAccessControl(nftContract).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n      revert NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n    }\n    // And that this contract has permission to mint.\n    if (!IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this))) {\n      revert NFTDropMarketFixedPriceSale_Mint_Permission_Required();\n    }\n\n    // Validate input params.\n    if (limitPerAccount == 0) {\n      revert NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\n    }\n    // Any price is supported, including 0.\n\n    // Confirm this collection has not already been listed.\n    FixedPriceSaleConfig storage saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n    if (saleConfig.seller != payable(0)) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\n    }\n\n    // Save the sale details.\n    saleConfig.seller = payable(msg.sender);\n    saleConfig.price = price;\n    saleConfig.limitPerAccount = limitPerAccount;\n    emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n  }\n\n  /**\n   * @notice Used to mint `count` number of NFTs from the collection.\n   * @param nftContract The address of the NFT drop collection.\n   * @param count The number of NFTs to mint.\n   * @param buyReferrer The address which referred this purchase, or address(0) if n/a.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @dev This call may revert if the collection has sold out, has an insufficient number of tokens available,\n   * or if the market's minter permissions were removed.\n   * If insufficient msg.value is included, the msg.sender's available FETH token balance will be used.\n   */\n  function mintFromFixedPriceSale(\n    address nftContract,\n    uint16 count,\n    address payable buyReferrer\n  ) external payable returns (uint256 firstTokenId) {\n    // Validate input params.\n    if (count == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\n    }\n\n    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n\n    // Confirm that the buyer will not exceed the limit specified after minting.\n    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\n      if (saleConfig.limitPerAccount == 0) {\n        // Provide a more targeted error if the collection has not been listed.\n        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n      }\n      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n    }\n\n    // Calculate the total cost, considering the `count` requested.\n    uint256 mintCost;\n    unchecked {\n      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.\n      mintCost = uint256(saleConfig.price) * count;\n    }\n\n    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.\n    if (msg.value > mintCost) {\n      // Since price is known ahead of time, if too much ETH is sent then something went wrong.\n      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);\n    }\n    // Withdraw from the user's available FETH balance if insufficient msg.value was included.\n    _tryUseFETHBalance(mintCost, false);\n\n    // Mint the NFTs.\n    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n\n    // Distribute revenue from this sale.\n    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(\n      nftContract,\n      firstTokenId,\n      saleConfig.seller,\n      mintCost,\n      buyReferrer\n    );\n\n    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);\n  }\n\n  /**\n   * @notice Returns the max number of NFTs a given account may mint.\n   * @param nftContract The address of the NFT drop collection.\n   * @param user The address of the user which will be minting.\n   * @return numberThatCanBeMinted How many NFTs the user can mint.\n   */\n  function getAvailableCountFromFixedPriceSale(address nftContract, address user)\n    external\n    view\n    returns (uint256 numberThatCanBeMinted)\n  {\n    (, , uint256 limitPerAccount, uint256 numberOfTokensAvailableToMint, bool marketCanMint) = getFixedPriceSale(\n      nftContract\n    );\n    if (!marketCanMint) {\n      // No one can mint in the current state.\n      return 0;\n    }\n    uint256 currentBalance = IERC721(nftContract).balanceOf(user);\n    if (currentBalance >= limitPerAccount) {\n      // User has exhausted their limit.\n      return 0;\n    }\n\n    uint256 availableToMint = limitPerAccount - currentBalance;\n    if (availableToMint > numberOfTokensAvailableToMint) {\n      // User has more tokens available than the collection has available.\n      return numberOfTokensAvailableToMint;\n    }\n\n    return availableToMint;\n  }\n\n  /**\n   * @notice Returns details for a drop collection's fixed price sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @return seller The address of the seller which listed this drop for sale.\n   * This value will be address(0) if the collection is not listed or has sold out.\n   * @return price The price per NFT minted.\n   * @return limitPerAccount The max number of NFTs an account may have while minting.\n   * @return numberOfTokensAvailableToMint The total number of NFTs that may still be minted.\n   * @return marketCanMint True if this contract has permissions to mint from the given collection.\n   */\n  function getFixedPriceSale(address nftContract)\n    public\n    view\n    returns (\n      address payable seller,\n      uint256 price,\n      uint256 limitPerAccount,\n      uint256 numberOfTokensAvailableToMint,\n      bool marketCanMint\n    )\n  {\n    try INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() returns (uint256 count) {\n      if (count != 0) {\n        try IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this)) returns (bool hasRole) {\n          marketCanMint = hasRole;\n        } catch {\n          // The contract is not supported - return default values.\n          return (payable(0), 0, 0, 0, false);\n        }\n\n        FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n        seller = saleConfig.seller;\n        price = saleConfig.price;\n        limitPerAccount = saleConfig.limitPerAccount;\n        numberOfTokensAvailableToMint = count;\n      }\n      // Else minted completed -- return default values.\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Contract not supported or self destructed - return default values\n    }\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns the seller for a collection if listed and not already sold out.\n   */\n  function _getSellerOf(\n    address nftContract,\n    uint256 /* tokenId */\n  ) internal view virtual override returns (address payable seller) {\n    (seller, , , , ) = getFixedPriceSale(nftContract);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}"
    }
  ]
}