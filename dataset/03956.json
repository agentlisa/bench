{
  "Title": "[M08] The reveal process can get stuck for a proposer",
  "Content": "The [`Random` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol) provides randomness functions for the block proposer. To prevent the randomness from being known in advance, the contract uses a commit and reveal process for the upcoming block. In this way, the contract [stores the last commitment under the `commitments` mapping](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L84), and [at the beginning of a new block](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L51), this `commitment` is revealed.\n\n\nThe [`revealAndCommit` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L56) is in charge of this process. It is only [callable by the VM](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L57), and redirects the functionality to [the internal `_revealAndCommit` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L67). There, it [checks if the proposer had submitted a commitment in the past](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L69), and if that condition is `true`, [it will check if the revealed randomness was zero or not](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L70). If the revealed randomness is zero, the transaction will revert.\n\n\nThe problem might occur if the function call from the VM passes a `commitment` derived from a zero randomness as a parameter. As the hash of `bytes32(0)` is not zero, if in the first `revealAndCommit` call the `newCommitment` parameter was `0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563` (the `bytes32(0)` hash), then in the following call, when the randomness is revealed, [the requirement in L70](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L70) will revert although the stored commitment corresponds to the input randomness.\n\n\nThese calls are made by the node client twice: when [the client checks that the randomness is correct](https://github.com/celo-org/celo-blockchain/blob/a90c7a46da23be12b0d6e930948a4bae25714abd/core/state_processor.go#L71) and when [the proposer reveals the randomness](https://github.com/celo-org/celo-blockchain/blob/a90c7a46da23be12b0d6e930948a4bae25714abd/miner/worker.go#L1007). In both cases, when the transaction reverts, both the `process` and `commitNewWork` functions from the blockchain client will return an error.\n\n\n***Update:** Fixed in [pull request #2795](https://github.com/celo-org/celo-monorepo/pull/2795). Now [a commitment of 0 randomness will revert](https://github.com/celo-org/celo-monorepo/pull/2795/files#diff-d166a1977227386b1d65de4aba036f85R68).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/identity/Random.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"./interfaces/IRandom.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"../common/Initializable.sol\";\n\n/**\n * @title Provides randomness for verifier selection\n */\ncontract Random is IRandom, Ownable, Initializable {\n  using SafeMath for uint256;\n\n  /* Stores most recent commitment per address */\n  mapping(address => bytes32) public commitments;\n\n  uint256 public randomnessBlockRetentionWindow = 256;\n\n  mapping(uint256 => bytes32) private history;\n  uint256 private historyFirst;\n  uint256 private historySize;\n\n  event RandomnessBlockRetentionWindowSet(uint256 value);\n\n  /**\n   * @notice Initializes the contract with initial parameters.\n   * @param _randomnessBlockRetentionWindow Number of old random blocks whose randomness\n   * values can be queried.\n   */\n  function initialize(uint256 _randomnessBlockRetentionWindow) external initializer {\n    _transferOwnership(msg.sender);\n    setRandomnessBlockRetentionWindow(_randomnessBlockRetentionWindow);\n  }\n\n  /**\n   * @notice Sets the number of old random blocks whose randomness values can be queried.\n   * @param value Number of old random blocks whose randomness values can be queried.\n   */\n  function setRandomnessBlockRetentionWindow(uint256 value) public onlyOwner {\n    require(value > 0, \"randomnessBlockRetetionWindow cannot be zero\");\n    randomnessBlockRetentionWindow = value;\n    emit RandomnessBlockRetentionWindowSet(value);\n  }\n\n  /**\n   * @notice Implements step of the randomness protocol.\n   * @param randomness Bytes that will be added to the entropy pool.\n   * @param newCommitment The hash of randomness that will be revealed in the future.\n   * @param proposer Address of the block proposer.\n   * @dev If the Random contract is pointed to by the Registry, the first transaction in a block\n   * should be a special transaction to address 0x0 with 64 bytes of data - the concatenated\n   * `randomness` and `newCommitment`. Before running regular transactions, this function should be\n   * called.\n   */\n  function revealAndCommit(bytes32 randomness, bytes32 newCommitment, address proposer) external {\n    require(msg.sender == address(0), \"only VM can call\");\n    _revealAndCommit(randomness, newCommitment, proposer);\n  }\n\n  /**\n   * @notice Implements step of the randomness protocol.\n   * @param randomness Bytes that will be added to the entropy pool.\n   * @param newCommitment The hash of randomness that will be revealed in the future.\n   * @param proposer Address of the block proposer.\n   */\n  function _revealAndCommit(bytes32 randomness, bytes32 newCommitment, address proposer) internal {\n    // ensure revealed randomness matches previous commitment\n    if (commitments[proposer] != 0) {\n      require(randomness != 0, \"randomness cannot be zero if there is a previous commitment\");\n      bytes32 expectedCommitment = computeCommitment(randomness);\n      require(\n        expectedCommitment == commitments[proposer],\n        \"commitment didn't match the posted randomness\"\n      );\n    } else {\n      require(randomness == 0, \"randomness should be zero if there is no previous commitment\");\n    }\n\n    // add entropy\n    uint256 blockNumber = block.number == 0 ? 0 : block.number.sub(1);\n    addRandomness(block.number, keccak256(abi.encodePacked(history[blockNumber], randomness)));\n\n    commitments[proposer] = newCommitment;\n  }\n\n  /**\n   * @notice Add a value to the randomness history.\n   * @param blockNumber Current block number.\n   * @param randomness The new randomness added to history.\n   * @dev The calls to this function should be made so that on the next call, blockNumber will\n   * be the previous one, incremented by one.\n   */\n  function addRandomness(uint256 blockNumber, bytes32 randomness) internal {\n    history[blockNumber] = randomness;\n    if (historySize == 0) {\n      historyFirst = block.number;\n      historySize = 1;\n    } else if (historySize > randomnessBlockRetentionWindow) {\n      delete history[historyFirst];\n      delete history[historyFirst + 1];\n      historyFirst += 2;\n      historySize--;\n    } else if (historySize == randomnessBlockRetentionWindow) {\n      delete history[historyFirst];\n      historyFirst++;\n    } else {\n      // historySize < randomnessBlockRetentionWindow\n      historySize++;\n    }\n  }\n\n  /**\n   * @notice Compute the commitment hash for a given randomness value.\n   * @param randomness The value for which the commitment hash is computed.\n   * @return Commitment parameter.\n   */\n  function computeCommitment(bytes32 randomness) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(randomness));\n  }\n\n  /**\n   * @notice Querying the current randomness value.\n   * @return Returns the current randomness value.\n   */\n  function random() external view returns (bytes32) {\n    return _getBlockRandomness(block.number, block.number);\n  }\n\n  /**\n   * @notice Get randomness values of previous blocks.\n   * @param blockNumber The number of block whose randomness value we want to know.\n   * @return The associated randomness value.\n   */\n  function getBlockRandomness(uint256 blockNumber) external view returns (bytes32) {\n    return _getBlockRandomness(blockNumber, block.number);\n  }\n\n  /**\n   * @notice Get randomness values of previous blocks.\n   * @param blockNumber The number of block whose randomness value we want to know.\n   * @param cur Number of the current block.\n   * @return The associated randomness value.\n   */\n  function _getBlockRandomness(uint256 blockNumber, uint256 cur) internal view returns (bytes32) {\n    require(blockNumber <= cur, \"Cannot query randomness of future blocks\");\n    require(\n      blockNumber > cur.sub(historySize) &&\n        (randomnessBlockRetentionWindow >= cur ||\n          blockNumber > cur.sub(randomnessBlockRetentionWindow)),\n      \"Cannot query randomness older than the stored history\"\n    );\n    return history[blockNumber];\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/identity/Random.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"./interfaces/IRandom.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"../common/Initializable.sol\";\n\n/**\n * @title Provides randomness for verifier selection\n */\ncontract Random is IRandom, Ownable, Initializable {\n  using SafeMath for uint256;\n\n  /* Stores most recent commitment per address */\n  mapping(address => bytes32) public commitments;\n\n  uint256 public randomnessBlockRetentionWindow = 256;\n\n  mapping(uint256 => bytes32) private history;\n  uint256 private historyFirst;\n  uint256 private historySize;\n\n  event RandomnessBlockRetentionWindowSet(uint256 value);\n\n  /**\n   * @notice Initializes the contract with initial parameters.\n   * @param _randomnessBlockRetentionWindow Number of old random blocks whose randomness\n   * values can be queried.\n   */\n  function initialize(uint256 _randomnessBlockRetentionWindow) external initializer {\n    _transferOwnership(msg.sender);\n    setRandomnessBlockRetentionWindow(_randomnessBlockRetentionWindow);\n  }\n\n  /**\n   * @notice Sets the number of old random blocks whose randomness values can be queried.\n   * @param value Number of old random blocks whose randomness values can be queried.\n   */\n  function setRandomnessBlockRetentionWindow(uint256 value) public onlyOwner {\n    require(value > 0, \"randomnessBlockRetetionWindow cannot be zero\");\n    randomnessBlockRetentionWindow = value;\n    emit RandomnessBlockRetentionWindowSet(value);\n  }\n\n  /**\n   * @notice Implements step of the randomness protocol.\n   * @param randomness Bytes that will be added to the entropy pool.\n   * @param newCommitment The hash of randomness that will be revealed in the future.\n   * @param proposer Address of the block proposer.\n   * @dev If the Random contract is pointed to by the Registry, the first transaction in a block\n   * should be a special transaction to address 0x0 with 64 bytes of data - the concatenated\n   * `randomness` and `newCommitment`. Before running regular transactions, this function should be\n   * called.\n   */\n  function revealAndCommit(bytes32 randomness, bytes32 newCommitment, address proposer) external {\n    require(msg.sender == address(0), \"only VM can call\");\n    _revealAndCommit(randomness, newCommitment, proposer);\n  }\n\n  /**\n   * @notice Implements step of the randomness protocol.\n   * @param randomness Bytes that will be added to the entropy pool.\n   * @param newCommitment The hash of randomness that will be revealed in the future.\n   * @param proposer Address of the block proposer.\n   */\n  function _revealAndCommit(bytes32 randomness, bytes32 newCommitment, address proposer) internal {\n    // ensure revealed randomness matches previous commitment\n    if (commitments[proposer] != 0) {\n      require(randomness != 0, \"randomness cannot be zero if there is a previous commitment\");\n      bytes32 expectedCommitment = computeCommitment(randomness);\n      require(\n        expectedCommitment == commitments[proposer],\n        \"commitment didn't match the posted randomness\"\n      );\n    } else {\n      require(randomness == 0, \"randomness should be zero if there is no previous commitment\");\n    }\n\n    // add entropy\n    uint256 blockNumber = block.number == 0 ? 0 : block.number.sub(1);\n    addRandomness(block.number, keccak256(abi.encodePacked(history[blockNumber], randomness)));\n\n    commitments[proposer] = newCommitment;\n  }\n\n  /**\n   * @notice Add a value to the randomness history.\n   * @param blockNumber Current block number.\n   * @param randomness The new randomness added to history.\n   * @dev The calls to this function should be made so that on the next call, blockNumber will\n   * be the previous one, incremented by one.\n   */\n  function addRandomness(uint256 blockNumber, bytes32 randomness) internal {\n    history[blockNumber] = randomness;\n    if (historySize == 0) {\n      historyFirst = block.number;\n      historySize = 1;\n    } else if (historySize > randomnessBlockRetentionWindow) {\n      delete history[historyFirst];\n      delete history[historyFirst + 1];\n      historyFirst += 2;\n      historySize--;\n    } else if (historySize == randomnessBlockRetentionWindow) {\n      delete history[historyFirst];\n      historyFirst++;\n    } else {\n      // historySize < randomnessBlockRetentionWindow\n      historySize++;\n    }\n  }\n\n  /**\n   * @notice Compute the commitment hash for a given randomness value.\n   * @param randomness The value for which the commitment hash is computed.\n   * @return Commitment parameter.\n   */\n  function computeCommitment(bytes32 randomness) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(randomness));\n  }\n\n  /**\n   * @notice Querying the current randomness value.\n   * @return Returns the current randomness value.\n   */\n  function random() external view returns (bytes32) {\n    return _getBlockRandomness(block.number, block.number);\n  }\n\n  /**\n   * @notice Get randomness values of previous blocks.\n   * @param blockNumber The number of block whose randomness value we want to know.\n   * @return The associated randomness value.\n   */\n  function getBlockRandomness(uint256 blockNumber) external view returns (bytes32) {\n    return _getBlockRandomness(blockNumber, block.number);\n  }\n\n  /**\n   * @notice Get randomness values of previous blocks.\n   * @param blockNumber The number of block whose randomness value we want to know.\n   * @param cur Number of the current block.\n   * @return The associated randomness value.\n   */\n  function _getBlockRandomness(uint256 blockNumber, uint256 cur) internal view returns (bytes32) {\n    require(blockNumber <= cur, \"Cannot query randomness of future blocks\");\n    require(\n      blockNumber > cur.sub(historySize) &&\n        (randomnessBlockRetentionWindow >= cur ||\n          blockNumber > cur.sub(randomnessBlockRetentionWindow)),\n      \"Cannot query randomness older than the stored history\"\n    );\n    return history[blockNumber];\n  }\n}"
    },
    {
      "filename": "core/state_processor.go",
      "content": "// Copyright 2015 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage core\n\nimport (\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/consensus\"\n\t\"github.com/ethereum/go-ethereum/consensus/misc\"\n\t\"github.com/ethereum/go-ethereum/contract_comm/random\"\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/ethereum/go-ethereum/params\"\n)\n\n// StateProcessor is a basic Processor, which takes care of transitioning\n// state from one point to another.\n//\n// StateProcessor implements Processor.\ntype StateProcessor struct {\n\tconfig *params.ChainConfig // Chain configuration options\n\tbc     *BlockChain         // Canonical block chain\n\tengine consensus.Engine    // Consensus engine used for block rewards\n}\n\n// NewStateProcessor initialises a new StateProcessor.\nfunc NewStateProcessor(config *params.ChainConfig, bc *BlockChain, engine consensus.Engine) *StateProcessor {\n\treturn &StateProcessor{\n\t\tconfig: config,\n\t\tbc:     bc,\n\t\tengine: engine,\n\t}\n}\n\n// Process processes the state changes according to the Ethereum rules by running\n// the transaction messages using the statedb and applying any rewards to both\n// the processor (coinbase) and any included uncles.\n//\n// Process returns the receipts and logs accumulated during the process and\n// returns the amount of gas that was used in the process. If any of the\n// transactions failed to execute due to insufficient gas it will return an error.\nfunc (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, uint64, error) {\n\tvar (\n\t\treceipts types.Receipts\n\t\tusedGas  = new(uint64)\n\t\theader   = block.Header()\n\t\tallLogs  []*types.Log\n\t\tgp       = new(GasPool).AddGas(block.GasLimit())\n\t)\n\t// Mutate the block and state according to any hard-fork specs\n\tif p.config.DAOForkSupport && p.config.DAOForkBlock != nil && p.config.DAOForkBlock.Cmp(block.Number()) == 0 {\n\t\tmisc.ApplyDAOHardFork(statedb)\n\t}\n\n\tif random.IsRunning() {\n\t\terr := random.RevealAndCommit(block.Randomness().Revealed, block.Randomness().Committed, header.Coinbase, header, statedb)\n\t\tif err != nil {\n\t\t\treturn nil, nil, 0, err\n\t\t}\n\t}\n\t// Iterate over and process the individual transactions\n\tfor i, tx := range block.Transactions() {\n\t\tstatedb.Prepare(tx.Hash(), block.Hash(), i)\n\t\treceipt, _, err := ApplyTransaction(p.config, p.bc, nil, gp, header, statedb, tx, usedGas, cfg)\n\t\tif err != nil {\n\t\t\treturn nil, nil, 0, err\n\t\t}\n\t\treceipts = append(receipts, receipt)\n\t\tallLogs = append(allLogs, receipt.Logs...)\n\t}\n\t// Finalize the block, applying any consensus engine specific extras (e.g. block rewards)\n\tstatedb.Prepare(common.Hash{}, block.Hash(), len(block.Transactions()))\n\tp.engine.Finalize(p.bc, header, statedb, block.Transactions(), block.Uncles(), receipts, block.Randomness())\n\n\tif len(statedb.GetLogs(common.Hash{})) > 0 {\n\t\treceipt := types.NewReceipt(nil, false, 0)\n\t\treceipt.Logs = statedb.GetLogs(common.Hash{})\n\t\treceipt.Bloom = types.CreateBloom(types.Receipts{receipt})\n\t\tfor i := range receipt.Logs {\n\t\t\treceipt.Logs[i].TxIndex = uint(len(receipts))\n\t\t\treceipt.Logs[i].TxHash = block.Hash()\n\t\t}\n\t\treceipts = append(receipts, receipt)\n\t}\n\n\treturn receipts, allLogs, *usedGas, nil\n}\n\n// ApplyTransaction attempts to apply a transaction to the given state database\n// and uses the input parameters for its environment. It returns the receipt\n// for the transaction, gas used and an error if the transaction failed,\n// indicating the block was invalid.\nfunc ApplyTransaction(config *params.ChainConfig, bc vm.ChainContext, author *common.Address, gp *GasPool, header *types.Header, statedb *state.StateDB, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, uint64, error) {\n\tmsg, err := tx.AsMessage(types.MakeSigner(config, header.Number))\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\t// Create a new context to be used in the EVM environment\n\tcontext := vm.NewEVMContext(msg, header, bc, author)\n\t// Create a new environment which holds all relevant information\n\t// about the transaction and calling mechanisms.\n\tvmenv := vm.NewEVM(context, statedb, config, cfg)\n\n\t// Apply the transaction to the current state (included in the env)\n\t_, gas, failed, err := ApplyMessage(vmenv, msg, gp)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\t// Update the state with pending changes\n\tvar root []byte\n\tif config.IsByzantium(header.Number) {\n\t\tstatedb.Finalise(true)\n\t} else {\n\t\troot = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes()\n\t}\n\t*usedGas += gas\n\n\t// Create a new receipt for the transaction, storing the intermediate root and gas used by the tx\n\t// based on the eip phase, we're passing whether the root touch-delete accounts.\n\treceipt := types.NewReceipt(root, failed, *usedGas)\n\treceipt.TxHash = tx.Hash()\n\treceipt.GasUsed = gas\n\t// if the transaction created a contract, store the creation address in the receipt.\n\tif msg.To() == nil {\n\t\treceipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())\n\t}\n\t// Set the receipt logs and create a bloom for filtering\n\treceipt.Logs = statedb.GetLogs(tx.Hash())\n\treceipt.Bloom = types.CreateBloom(types.Receipts{receipt})\n\treturn receipt, gas, err\n}"
    }
  ]
}