{
  "Title": "H-1: \"Votes\" balance can be increased indefinitely in multiple contracts",
  "Content": "# Issue H-1: \"Votes\" balance can be increased indefinitely in multiple contracts \n\nSource: https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/41 \n\n## Found by \n0xDanielH, 0xDjango, 0xbranded, 0xlx, AkshaySrivastav, BenRai, Czar102, Musaka, VAD37, Yuki, caventa, dany.armstrong90, jah, jkoppel, kutugu, magellanXtrachev, ni8mare, p-tsanev, p12473, pengun, r0bert, stopthecap, twicek, y1cunhui\n## Summary\nThe \"voting power\" can be easily manipulated in the following contracts:\n- `ContinuousVestingMerkle`\n- `PriceTierVestingMerkle`\n- `PriceTierVestingSale_2_0`\n- `TrancheVestingMerkle`\n- `CrosschainMerkleDistributor`\n- `CrosschainContinuousVestingMerkle`\n- `CrosschainTrancheVestingMerkle`\n- All the contracts inheriting from the contracts listed above\n\nThis is caused by the public `initializeDistributionRecord()` function that can be recalled multiple times without any kind of access control:\n```solidity\n  function initializeDistributionRecord(\n    uint32 _domain, // the domain of the beneficiary\n    address _beneficiary, // the address that will receive tokens\n    uint256 _amount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  ) external validMerkleProof(_getLeaf(_beneficiary, _amount, _domain), merkleProof) {\n    _initializeDistributionRecord(_beneficiary, _amount);\n  }\n```\n\n## Vulnerability Detail\nThe `AdvancedDistributor` abstract contract which inherits from the `ERC20Votes`, `ERC20Permit` and `ERC20` contracts, distributes tokens to beneficiaries with voting-while-vesting and administrative controls. Basically, before the tokens are vested/claimed by a certain group of users, these users can use these ERC20 tokens to vote. These tokens are minted through the `_initializeDistributionRecord()` function:\n```solidity\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n```\nAs mentioned in the [Tokensoft Discord channel](https://discord.com/channels/812037309376495636/1130514276570906685/1130577295539707995) these ERC20 tokens minted are used to track an address's unvested token balance, so that other projects can utilize 'voting while vesting'.\n\nA user can simply call as many times as he wishes the `initializeDistributionRecord()` function with a valid merkle proof. With each call, the `totalAmount` of tokens will be minted. Then, the user simply can call `delegate()` and delegate those votes to himself, \"recording\" the inflated voting power.\n\n## Impact\nThe issue totally breaks the 'voting while vesting' design. Any DAO/project using these contracts to determine their voting power could be easily manipulated/exploited.\n\n## Code Snippet\n- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/ContinuousVestingMerkle.sol#L43-L53\n- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/PriceTierVestingMerkle.sol#L49-L59\n- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/PriceTierVestingSale_2_0.sol#L91-L95\n- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/TrancheVestingMerkle.sol#L39-L49\n- https://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/CrosschainMerkleDistributor.sol#L46-L53\n\n## Tool used\nManual Review\n\n## Recommendation\nOnly allow users to call once the `initializeDistributionRecord()` function. Consider using a mapping to store if the function was called previously or not. Keep also in mind that fully vested and claimed users should not be able to call this function and if they do, the total amount of tokens that should be minted should be 0 or proportional/related to the amount of tokens that they have already claimed.\n\n\n\n## Discussion\n\n**cr-walker**\n\nGreat find! We need to preserve the ability to re-initialize distribution records (e.g. if a merkle root changes), so I believe something like this is the best fix:\n\n```\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    uint256 currentVotes = balanceOf(beneficiary);\n    uint256 newVotes = tokensToVotes(totalAmount);\n\n    if (currentVotes > newVotes) {\n      // reduce voting power through ERC20Votes extension\n      _burn(beneficiary, currentVotes - newVotes);\n    } else if (currentVotes < newVotes) {\n      // increase voting power through ERC20Votes extension\n      _mint(beneficiary, newVotes - currentVotes);\n    }\n  }\n  ```\n\n**cr-walker**\n\nFixed: https://github.com/SoftDAO/contracts/pull/9\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/100",
  "Code": [
    {
      "filename": "contracts/contracts/claim/ContinuousVestingMerkle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport { ContinuousVesting } from './abstract/ContinuousVesting.sol';\nimport { MerkleSet } from './abstract/MerkleSet.sol';\n\ncontract ContinuousVestingMerkle is ContinuousVesting, MerkleSet {\n  constructor(\n    IERC20 _token, // the token being claimed\n    uint256 _total, // the total claimable by all users\n    string memory _uri, // information on the sale (e.g. merkle proofs)\n    uint256 _voteFactor, // votes have this weight\n    uint256 _start, // vesting clock starts at this time\n    uint256 _cliff, // claims open at this time\n    uint256 _end, // vesting clock ends and this time\n    bytes32 _merkleRoot, // the merkle root for claim membership (also used as salt for the fair queue delay time),\n    uint160 _maxDelayTime // the maximum delay time for the fair queue\n  )\n    ContinuousVesting(\n      _token,\n      _total,\n      _uri,\n      _voteFactor,\n      _start,\n      _cliff,\n      _end,\n      _maxDelayTime,\n      uint160(uint256(_merkleRoot))\n    )\n    MerkleSet(_merkleRoot)\n  {}\n\n  function NAME() external pure override returns (string memory) {\n    return 'ContinuousVestingMerkle';\n  }\n\n  function VERSION() external pure override returns (uint256) {\n    return 3;\n  }\n\n  function initializeDistributionRecord(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 amount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  )\n    external\n    validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, amount)), merkleProof)\n  {\n    _initializeDistributionRecord(beneficiary, amount);\n  }\n\n  function claim(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 totalAmount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  )\n    external\n    validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, totalAmount)), merkleProof)\n    nonReentrant\n  {\n    // effects\n    uint256 claimedAmount = super._executeClaim(beneficiary, totalAmount);\n    // interactions\n    super._settleClaim(beneficiary, claimedAmount);\n  }\n\n  function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n    _setMerkleRoot(_merkleRoot);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/PriceTierVestingMerkle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { AggregatorV3Interface } from '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport { PriceTierVesting, PriceTier } from './abstract/PriceTierVesting.sol';\nimport { MerkleSet } from './abstract/MerkleSet.sol';\n\ncontract PriceTierVestingMerkle is PriceTierVesting, MerkleSet {\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri, // information on the sale (e.g. merkle proofs)\n    uint256 _voteFactor,\n    // when price tier vesting opens (seconds past epoch)\n    uint256 _start,\n    // when price tier vesting ends (seconds past epoch) and all tokens are unlocked\n    uint256 _end,\n    // source for pricing info\n    AggregatorV3Interface _oracle,\n    PriceTier[] memory _priceTiers,\n    bytes32 _merkleRoot,\n    uint160 _maxDelayTime // the maximum delay time for the fair queue\n  )\n    PriceTierVesting(\n      _token,\n      _total,\n      _uri,\n      _voteFactor,\n      _start,\n      _end,\n      _oracle,\n      _priceTiers,\n      _maxDelayTime,\n      uint160(uint256(_merkleRoot))\n    )\n    MerkleSet(_merkleRoot)\n  {}\n\n  function NAME() external pure override returns (string memory) {\n    return 'PriceTierVestingMerkle';\n  }\n\n  function VERSION() external pure override returns (uint256) {\n    return 3;\n  }\n\n  function initializeDistributionRecord(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 amount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  )\n    external\n    validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, amount)), merkleProof)\n  {\n    _initializeDistributionRecord(beneficiary, amount);\n  }\n\n  function claim(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 totalAmount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  )\n    external\n    validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, totalAmount)), merkleProof)\n    nonReentrant\n  {\n    // effects\n    uint256 claimedAmount = _executeClaim(beneficiary, totalAmount);\n    // interactions\n    _settleClaim(beneficiary, claimedAmount);\n  }\n\n  function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n    _setMerkleRoot(_merkleRoot);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/PriceTierVestingSale_2_0.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { AggregatorV3Interface } from '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol';\n\nimport { DistributionRecord } from '../interfaces/IDistributor.sol';\nimport { PriceTierVesting, PriceTier } from './abstract/PriceTierVesting.sol';\nimport { MerkleSet } from './abstract/MerkleSet.sol';\nimport { FlatPriceSale } from '../sale/v2/FlatPriceSale.sol';\n\ncontract PriceTierVestingSale_2_0 is PriceTierVesting {\n  FlatPriceSale public immutable sale;\n  uint256 public immutable price;\n  uint8 public immutable soldTokenDecimals;\n\n  modifier validSaleParticipant(address beneficiary) {\n    require(sale.buyerTotal(beneficiary) != 0, 'no purchases found');\n\n    _;\n  }\n\n  constructor(\n    FlatPriceSale _sale, // where the purchase occurred\n    IERC20 _token, // the purchased token\n    uint8 _soldTokenDecimals, // the number of decimals used by the purchased token\n    // the price of the purchased token denominated in the sale's base currency with 8 decimals\n    // e.g. if the sale was selling $FOO at $0.55 per token, price = 55000000\n    uint256 _price,\n    // when price tier vesting opens (seconds past epoch)\n    uint256 _start,\n    // when price tier vesting ends (seconds past epoch) and all tokens are unlocked\n    uint256 _end,\n    // source for pricing info\n    AggregatorV3Interface _oracle,\n    PriceTier[] memory priceTiers, // vesting PriceTiers\n    uint256 _voteFactor, // the factor for voting power in basis points (e.g. 15000 means users have a 50% voting bonus for unclaimed tokens)\n    string memory _uri // information on the sale (e.g. merkle proofs)\n  )\n    PriceTierVesting(\n      _token,\n      (_sale.total() * 10 ** _soldTokenDecimals) / _price,\n      _uri,\n      _voteFactor,\n      _start,\n      _end,\n      _oracle,\n      priceTiers,\n      0, // no delay\n      0 // no salt\n    )\n  {\n    require(address(_sale) != address(0), 'sale is address(0)');\n\n    // previously deployed v2.0 sales did not implement the isOver() method\n    (, , , , , , uint256 endTime, , ) = _sale.config();\n    require(endTime < block.timestamp, 'sale not over yet');\n    require(_price != 0, 'price is 0');\n\n    sale = _sale;\n    soldTokenDecimals = _soldTokenDecimals;\n    price = _price;\n  }\n\n  function NAME() external pure virtual override returns (string memory) {\n    return 'PriceTierVestingSale_2_0';\n  }\n\n  // File specific version - starts at 1, increments on every solidity diff\n  function VERSION() external pure virtual override returns (uint256) {\n    return 3;\n  }\n\n  function getPurchasedAmount(address buyer) public view returns (uint256) {\n    /**\n    Get the quantity purchased from the sale and convert it to native tokens\n  \n    Example: if a user buys $1.11 of a FOO token worth $0.50 each, the purchased amount will be 2.22 FOO\n    - buyer total: 111000000 ($1.11 with 8 decimals)\n    - decimals: 6 (the token being purchased has 6 decimals)\n    - price: 50000000 ($0.50 with 8 decimals)\n\n    Calculation: 111000000 * 1000000 / 50000000\n\n    Returns purchased amount: 2220000 (2.22 with 6 decimals)\n    */\n    return (sale.buyerTotal(buyer) * (10 ** soldTokenDecimals)) / price;\n  }\n\n  function initializeDistributionRecord(\n    address beneficiary // the address that will receive tokens\n  ) external validSaleParticipant(beneficiary) {\n    _initializeDistributionRecord(beneficiary, getPurchasedAmount(beneficiary));\n  }\n\n  function claim(\n    address beneficiary // the address that will receive tokens\n  ) external validSaleParticipant(beneficiary) nonReentrant {\n    uint256 claimableAmount = getClaimableAmount(beneficiary);\n    uint256 purchasedAmount = getPurchasedAmount(beneficiary);\n\n    // effects\n    uint256 claimedAmount = super._executeClaim(beneficiary, purchasedAmount);\n\n    // interactions\n    super._settleClaim(beneficiary, claimedAmount);\n  }\n\n  function getDistributionRecord(\n    address beneficiary\n  ) external view virtual override returns (DistributionRecord memory) {\n    DistributionRecord memory record = records[beneficiary];\n\n    // workaround prior to initialization\n    if (!record.initialized) {\n      record.total = uint120(getPurchasedAmount(beneficiary));\n    }\n    return record;\n  }\n\n  // get the number of tokens currently claimable by a specific user\n  function getClaimableAmount(address beneficiary) public view override returns (uint256) {\n    if (records[beneficiary].initialized) return super.getClaimableAmount(beneficiary);\n\n    // we can get the claimable amount prior to initialization\n    return\n      (getPurchasedAmount(beneficiary) * getVestedFraction(beneficiary, block.timestamp)) /\n      fractionDenominator;\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/TrancheVestingMerkle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport { TrancheVesting, Tranche } from './abstract/TrancheVesting.sol';\nimport { MerkleSet } from './abstract/MerkleSet.sol';\n\ncontract TrancheVestingMerkle is TrancheVesting, MerkleSet {\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri, // information on the sale (e.g. merkle proofs)\n    uint256 _voteFactor,\n    Tranche[] memory _tranches,\n    bytes32 _merkleRoot,\n    uint160 _maxDelayTime // the maximum delay time for the fair queue\n  )\n    TrancheVesting(\n      _token,\n      _total,\n      _uri,\n      _voteFactor,\n      _tranches,\n      _maxDelayTime,\n      uint160(uint256(_merkleRoot))\n    )\n    MerkleSet(_merkleRoot)\n  {}\n\n  function NAME() external pure override returns (string memory) {\n    return 'TrancheVestingMerkle';\n  }\n\n  function VERSION() external pure override returns (uint256) {\n    return 3;\n  }\n\n  function initializeDistributionRecord(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 amount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  )\n    external\n    validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, amount)), merkleProof)\n  {\n    _initializeDistributionRecord(beneficiary, amount);\n  }\n\n  function claim(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 totalAmount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  )\n    external\n    validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, totalAmount)), merkleProof)\n    nonReentrant\n  {\n    // effects\n    uint256 claimedAmount = _executeClaim(beneficiary, totalAmount);\n    // interactions\n    _settleClaim(beneficiary, claimedAmount);\n  }\n\n  function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n    _setMerkleRoot(_merkleRoot);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/abstract/CrosschainMerkleDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ICrosschain } from '../../interfaces/ICrosschain.sol';\nimport { CrosschainDistributor } from './CrosschainDistributor.sol';\nimport { AdvancedDistributor } from './AdvancedDistributor.sol';\nimport { Distributor } from './Distributor.sol';\nimport { MerkleSet } from './MerkleSet.sol';\nimport { IConnext } from '../../interfaces/IConnext.sol';\nimport { IDistributor } from '../../interfaces/IDistributor.sol';\nimport { ECDSA } from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\n/**\n * @title CrosschainMerkleDistributor\n * @author\n * @notice Distributes funds to beneficiaries listed in a merkle proof on Connext-compatible chains. Every beneficiary\n * must be included in exactly one merkle leaf.\n *\n * @dev There are three ways to claim funds from this contract:\n *\n * 1. `claimBySignature` allows any address to claim funds on behalf of an EOA beneficiary to any Connext domain and recipient address (including recipients and domains not in the merkle leaf) by providing a merkle proof and beneficiary signature\n * 2. `claimByMerkleProof` allows any address to claim funds on behalf of a beneficiary to the Connext domain and address specified in the merkle leaf by providing a merkle proof\n * 3. `xReceive` allows any address on another Connext domain to claim funds on behalf of a beneficiary to the connext domain and address specified in the merkle leaf by providing a merkle proof\n *\n * A note on the merkle tree structure:\n *\n * The leaf structure used is: `hash(beneficiary, total, beneficiaryDomain)`.\n *\n * The contract is designed to support claims by both EOAs and contracts. If the beneficiary\n * is a contract, the merkle leaf domain must match the contract domain. In this case, you can only guarantee the beneficiary\n * controls their address on the domain the claim was initiated from (contracts do not share\n * addresses across chains). Including the domain context in the leaf allows the contract to\n * enforce this assertion via merkle proofs instead of using an authorized call (see:\n * https://docs.connext.network/developers/guides/authentication).\n */\nabstract contract CrosschainMerkleDistributor is CrosschainDistributor, MerkleSet {\n  event Foo(address bar);\n  constructor(\n    IConnext _connext,\n    bytes32 _merkleRoot,\n    uint256 _total\n  ) CrosschainDistributor(_connext, _total) MerkleSet(_merkleRoot) {}\n\n  /// @dev public method to initialize a distribution record: requires a valid merkle proof\n  function initializeDistributionRecord(\n    uint32 _domain, // the domain of the beneficiary\n    address _beneficiary, // the address that will receive tokens\n    uint256 _amount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  ) external validMerkleProof(_getLeaf(_beneficiary, _amount, _domain), merkleProof) {\n    _initializeDistributionRecord(_beneficiary, _amount);\n  }\n\n  /**\n   * @notice Used for cross-chain claims via Satellite, which triggers claims through Connext.\n   * @dev This method is only callable by Connext, but anyone on any other Connext domain can\n   * trigger this method call on behalf of a beneficiary. Claimed funds will always be sent to\n   * the beneficiary address and beneficiary domain set in the merkle proof.\n   * @param _callData Calldata from origin initiator (Satellite). Should include proof, leaf information, and recipient\n   * information\n   */\n  function xReceive(\n    bytes32, // _transferId,\n    uint256, // _amount,\n    address, // _asset,\n    address, // _originSender,\n    uint32, // _origin,\n    bytes calldata _callData\n  ) external onlyConnext returns (bytes memory) {\n    // Decode the data\n    (address beneficiary, uint32 beneficiaryDomain, uint256 totalAmount, bytes32[] memory proof) = abi\n      .decode(_callData, (address, uint32, uint256, bytes32[]));\n    _verifyMembership(_getLeaf(beneficiary, totalAmount, beneficiaryDomain), proof);\n\n    // effects\n    uint256 claimedAmount =  _executeClaim(beneficiary, totalAmount);\n\n    // interactions\n    _settleClaim(beneficiary, beneficiary, beneficiaryDomain, claimedAmount);\n\n    return bytes('');\n  }\n\n  /**\n   * @notice Claim tokens for a beneficiary using a merkle proof\n   * @dev This method can be called by anyone, but claimed funds will always be sent to the\n   * beneficiary address and domain set in the merkle proof.\n   * @param _beneficiary The address of the beneficiary\n   * @param _total The total claimable amount for this beneficiary\n   * @param _proof The merkle proof\n   */\n  function claimByMerkleProof(\n    address _beneficiary,\n    uint256 _total,\n    bytes32[] calldata _proof\n  ) external {\n    _verifyMembership(_getLeaf(_beneficiary, _total, domain), _proof);\n    // effects\n    uint256 claimedAmount = _executeClaim(_beneficiary, _total);\n\n    // interactions\n    _settleClaim(_beneficiary, _beneficiary, domain, claimedAmount);\n  }\n\n  /**\n   * @notice Claim tokens for a beneficiary using a merkle proof and beneficiary signature. The beneficiary\n   * may specify any Connext domain and recipient address to receive the tokens. Will validate\n   * the proof and beneficiary signature, track the claim, and forward the funds to the designated\n   * recipient on the designated chain.\n   * @param _recipient The address to receive the claimed tokens\n   * @param _recipientDomain The domain of the recipient\n   * @param _beneficiary The address eligible to claim tokens based on a merkle leaf\n   * @param _beneficiaryDomain The domain of the beneficiary set in a merkle leaf\n   * @param _total The total quantity of tokens the beneficiary is eligible to claim\n   * @param _signature The signature of the beneficiary on the leaf\n   * @param _proof The merkle proof of the beneficiary leaf\n   */\n  function claimBySignature(\n    address _recipient,\n    uint32 _recipientDomain,\n    address _beneficiary,\n    uint32 _beneficiaryDomain,\n    uint256 _total,\n    bytes calldata _signature,\n    bytes32[] calldata _proof\n  ) external {\n    // Recover the signature by beneficiary\n    bytes32 _signed = keccak256(\n      abi.encodePacked(_recipient, _recipientDomain, _beneficiary, _beneficiaryDomain, _total)\n    );\n    address recovered = _recoverSignature(_signed, _signature);\n    require(recovered == _beneficiary, '!recovered');\n\n    // Validate the claim\n    _verifyMembership(_getLeaf(_beneficiary, _total, _beneficiaryDomain), _proof);\n    uint256 claimedAmount = _executeClaim(_beneficiary, _total);\n\n    _settleClaim(_beneficiary, _recipient, _recipientDomain, claimedAmount);\n  }\n\n  /**\n   * @notice Allows the owner update the merkle root\n   * @param _merkleRoot The new merkle root\n   */\n  function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n    _setMerkleRoot(_merkleRoot);\n  }\n\n  /**\n   * @notice Recover the signing address from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed.\n   * @param _sig The signature from which we will recover the signer.\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Generates the leaf from plaintext\n   * @param _domain Beneficiary domain\n   * @param _beneficiary Beneficiary address on domain\n   * @param _total Total claim amount for the beneficiary\n   */\n  function _getLeaf(\n    address _beneficiary, // the address that will receive tokens\n    uint256 _total,\n    uint32 _domain // the domain of the recipient\n  ) internal pure returns (bytes32 _leaf) {\n    _leaf = keccak256(abi.encodePacked(_beneficiary, _total, _domain));\n  }\n}"
    }
  ]
}