{
  "Title": "M-2: Can register a non-allowed collateral as collateral",
  "Content": "# Issue M-2: Can register a non-allowed collateral as collateral \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/029-M \n## Found by \nLambda, Bahurum, kirk-baird, bin2chen, xiaoming90, GalloDaSballo\n\n## Summary\nSome external interactions send tokens to the account, and the token address is not checked before being registered as a collateral for the account. This allows using an arbitrary token as a collateral as long as there is a corresponding oracle. \n\n## Vulnerability Detail\nIn the following controllers, at the line referenced\n\n[UniV2Controller.sol #L189](https://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/uniswap/UniV2Controller.sol#L189)  \n[AaveV2Controller.sol #L91](https://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/aave/AaveV2Controller.sol#L91)  \n[AaveV3Controller.sol #L79](https://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/aave/AaveV3Controller.sol#L79)  \n[BalancerController.sol#L137](https://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/balancer/BalancerController.sol#L137)  \n\nThere is an operation with a return value that can be an arbitrary token. No check is made to verify that the tokens in `tokensIn` are activated in `controllerFacade.isTokenAllowed`. No check is made either in `AccountManager.exec()` when calling `_updateTokensIn()` ([AccountManager.sol#L305](https://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/AccountManager.sol#L305)), so the tokens are added as a collateral as long as the oracle for the token in `OracleFacade` is active.\n\nThis can be clarified with an example using `UniV2Controller.sol`:  \n1. Admin sets the oracle for token XYZ, but does not activate yet the token in `controllerFacade.isTokenAllowed` or in `AccountManager.isCollateralAllowed` waiting to clear some security concerns with the token (vulnerabilities, high volatility, low liquidity, ...)\n2. Attacker opens an account\n3. Attacker provides liquidity to XYZ / ETH pool on UniswapV2\n4. Attacker transfers the LP to the account\n5. Attacker removes liquidity from the UniswapV2 pool through the account by calling `AccountManager.exec`. Note that there is no check to control whether tokens exiting the account are allowed ([UniV2Controller.sol#L175-L190](https://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/uniswap/UniV2Controller.sol#L175-L190)). No checks are performed on tokens sent from the pool to the account, so account receives WETH + XYZ and also XYZ is registered as an account collateral ([AccountManager.sol#L305](https://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/AccountManager.sol#L305)). An oracle was set for XYZ so the call to `riskEngine.isAccountHealthy(account)`([AccountManager.sol#L310](https://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/AccountManager.sol#L310)) does not revert and the transaction succeeds.\n6. Attacker can take advantage of the aforementioned security concerns to manipulate the price of XYZ, inflate his collateral balance and drain funds from the protocol.\n\nThe same behaviour can be reproduced with the other integrations listed above by transfering LP tokens of that particular protocol directly to an account and then removing liquidity through `AccountManager.exec()` to get the pair tokens registered into the account as collateral.\n\n## Impact\nSee point 6. of section above.\n\n## Code Snippet\n[UniV2Controller.sol #L189](https://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/uniswap/UniV2Controller.sol#L189)  \n[AaveV2Controller.sol #L91](https://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/aave/AaveV2Controller.sol#L91)  \n[AaveV3Controller.sol #L79](https://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/aave/AaveV3Controller.sol#L79)  \n[BalancerController.sol#L137](https://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/balancer/BalancerController.sol#L137)  \n[AccountManager.sol#L347](https://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/AccountManager.sol#L347)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck if tokens are allowed as collateral in `_updateTokensIn`  ([AccountManager.sol#L347-L355](https://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/AccountManager.sol#L347-L355))\n\n```diff\n    function _updateTokensIn(address account, address[] memory tokensIn)\n        internal\n    {\n        uint tokensInLen = tokensIn.length;\n        for(uint i; i < tokensInLen; ++i) {\n+           if (!isCollateralAllowed[tokensIn[i]])\n+               revert Errors.CollateralTypeRestricted();\n            if (IAccount(account).hasAsset(tokensIn[i]) == false)\n                IAccount(account).addAsset(tokensIn[i]);\n        }\n    }\n```\n\nThis way no asset can be added as collateral without being allowed.\n\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/controller/pull/40) and [here](https://github.com/sentimentxyz/controller/pull/43).\n\n## Lead Senior Watson\nConfirmed fix. If there are non-whitelisted tokens in the tokensIn list from a controller, it seems like the system should not reject the call, but not to add these tokens (ignore these tokens).\n\nThis issue is more obvious for the case of claim rewards from 3rd party protocols, which may include non-whitelisted tokens, but that doesn't mean it should not be allowed to claim these rewards.\n\n## Sentiment Team\nWe intend to track rewards as well and hence will be required to add them in the tokensIn list, all rewards will be whitelisted and only those integrations will be enabled. For rewards that we don't want to use as collateral in the system, we plan to add them to the assets and point them to the zero oracle.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "src/uniswap/UniV2Controller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IControllerFacade} from \"../core/IControllerFacade.sol\";\nimport {IUniV2Factory} from \"./IUniV2Factory.sol\";\n\n/**\n    @title Uniswap V2 Controller\n    @notice Controller for uniswap v2 interaction\n    eth:0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n*/\ncontract UniV2Controller is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\tfunction signature\n    bytes4 constant SWAP_EXACT_TOKENS_FOR_TOKENS = 0x38ed1739;\n\n    /// @notice swapTokensForExactTokens(uint256,uint256,address[],address,uint256)\tfunction signature\n    bytes4 constant SWAP_TOKENS_FOR_EXACT_TOKENS = 0x8803dbee;\n\n    /// @notice swapExactETHForTokens(uint256,address[],address,uint256) function signature\n    bytes4 constant SWAP_EXACT_ETH_FOR_TOKENS = 0x7ff36ab5;\n\n    /// @notice swapTokensForExactETH(uint256,uint256,address[],address,uint256) function signature\n    bytes4 constant SWAP_TOKENS_FOR_EXACT_ETH = 0x4a25d94a;\n\n    /// @notice swapExactTokensForETH(uint256,uint256,address[],address,uint256) function signature\n    bytes4 constant SWAP_EXACT_TOKENS_FOR_ETH = 0x18cbafe5;\n\n    /// @notice swapETHForExactTokens(uint256,address[],address,uint256) function signature\n    bytes4 constant SWAP_ETH_FOR_EXACT_TOKENS = 0xfb3bdb41;\n\n    /// @notice addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256) function signature\n    bytes4 constant ADD_LIQUIDITY = 0xe8e33700;\n\n    /// @notice removeLiquidity(address,address,uint256,uint256,uint256,address,uint256) function signature\n    bytes4 constant REMOVE_LIQUIDITY = 0xbaa2abde;\n\n    /// @notice addLiquidityETH(address,uint256,uint256,uint256,address,uint256) function signature\n    bytes4 constant ADD_LIQUIDITY_ETH = 0xf305d719;\n\n    /// @notice removeLiquidityETH(address,uint256,uint256,uint256,address,uint256) function signature\n    bytes4 constant REMOVE_LIQUIDITY_ETH = 0x02751cec;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice WETH address\n    address public immutable WETH;\n\n    /// @notice Uniswap v2 factory\n    IUniV2Factory public immutable UNIV2_FACTORY;\n\n    /// @notice IControllerFacade\n    IControllerFacade public immutable controller;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _WETH WETH address\n        @param _uniV2Factory Uniswap V2 Factory address\n        @param _controller Controller Facade\n    */\n    constructor(\n        address _WETH,\n        IUniV2Factory _uniV2Factory,\n        IControllerFacade _controller\n    ) {\n        WETH = _WETH;\n        UNIV2_FACTORY = _uniV2Factory;\n        controller = _controller;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        // Swap Functions\n        if (sig == SWAP_EXACT_TOKENS_FOR_TOKENS || sig == SWAP_TOKENS_FOR_EXACT_TOKENS)\n            return swapErc20ForErc20(data[4:]); // ERC20 -> ERC20\n        if (sig == SWAP_EXACT_ETH_FOR_TOKENS || sig == SWAP_ETH_FOR_EXACT_TOKENS)\n            return swapEthForErc20(data[4:]); // ETH -> ERC20\n        if (sig == SWAP_TOKENS_FOR_EXACT_ETH || sig == SWAP_EXACT_TOKENS_FOR_ETH)\n            return swapErc20ForEth(data[4:]); // ERC20 -> ETH\n\n        // LP Functions\n        if (sig == ADD_LIQUIDITY) return addLiquidity(data[4:]);\n        if (sig == REMOVE_LIQUIDITY) return removeLiquidity(data[4:]);\n        if (sig == ADD_LIQUIDITY_ETH) return addLiquidityEth(data[4:]);\n        if (sig == REMOVE_LIQUIDITY_ETH) return removeLiquidityEth(data[4:]);\n\n        return(false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Evaluates whether liquidity can be added\n        @param data calldata for adding liquidity\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function addLiquidity(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address tokenA, address tokenB) = abi.decode(data, (address, address));\n\n        address[] memory tokensOut = new address[](2);\n        tokensOut[0] = tokenA;\n        tokensOut[1] = tokenB;\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = UNIV2_FACTORY.getPair(tokenA, tokenB);\n\n        return(controller.isTokenAllowed(tokensIn[0]), tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether liquidity can be added\n        @param data calldata for adding liquidity\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function addLiquidityEth(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address token = abi.decode(data, (address));\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = token;\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = UNIV2_FACTORY.getPair(token, WETH);\n\n        return(controller.isTokenAllowed(tokensIn[0]), tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether liquidity can be removed\n        @param data calldata for removing liquidity\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function removeLiquidity(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address tokenA, address tokenB) = abi.decode(data, (address, address));\n\n        address[] memory tokensIn = new address[](2);\n        tokensIn[0] = tokenA;\n        tokensIn[1] = tokenB;\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = UNIV2_FACTORY.getPair(tokenA, tokenB);\n\n        return(true, tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether liquidity can be removed\n        @param data calldata for removing liquidity\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function removeLiquidityEth(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address token) = abi.decode(data, (address));\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = token;\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = UNIV2_FACTORY.getPair(token, WETH);\n\n        return(true, tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether swap can be performed\n        @param data calldata for swapping tokens\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function swapErc20ForErc20(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (,, address[] memory path,,)\n                = abi.decode(data, (uint, uint, address[], address, uint));\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = path[0];\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = path[path.length - 1];\n\n        return(\n            controller.isTokenAllowed(tokensIn[0]),\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    /**\n        @notice Evaluates whether swap can be performed\n        @param data calldata for swapping tokens\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function swapEthForErc20(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (, address[] memory path,,)\n                = abi.decode(data, (uint, address[], address, uint));\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = path[path.length - 1];\n\n        return (\n            controller.isTokenAllowed(tokensIn[0]),\n            tokensIn,\n            new address[](0)\n        );\n    }\n\n    /**\n        @notice Evaluates whether swap can be performed\n        @param data calldata for swapping tokens\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function swapErc20ForEth(bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (,, address[] memory path)\n                = abi.decode(data, (uint, uint, address[]));\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = path[0];\n\n        return (true, new address[](0), tokensOut);\n    }\n}"
    },
    {
      "filename": "src/aave/AaveV2Controller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IControllerFacade} from \"../core/IControllerFacade.sol\";\nimport {IProtocolDataProvider} from \"./IProtocolDataProvider.sol\";\n\n/**\n    @title Aave V2 controller\n    @notice Controller for aave v2 interaction\n    eth:0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9\n*/\ncontract AaveV2Controller is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice deposit(address,uint256,address,uint16)\tfunction signature\n    bytes4 public constant DEPOSIT = 0xe8eda9df;\n\n    /// @notice withdraw(address,uint256,address) function signature\n    bytes4 public constant WITHDRAW = 0x69328dec;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE_VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice IProtocolDataProvider\n        @dev https://docs.aave.com/developers/v/2.0/the-core-protocol/protocol-data-provider/iprotocoldataprovider\n    */\n    IProtocolDataProvider public immutable dataProvider;\n\n    /// @notice IControllerFacade\n    IControllerFacade public immutable controllerFacade;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _controller address of controller Facade\n        @param _dataProvider address of aave v2 data provider\n    */\n    constructor(\n        IControllerFacade _controller,\n        IProtocolDataProvider _dataProvider\n    )\n    {\n        controllerFacade = _controller;\n        dataProvider = _dataProvider;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n        if (sig == DEPOSIT) {\n            address asset = abi.decode(\n                data[4:],\n                (address)\n            );\n            address[] memory tokensIn = new address[](1);\n            address[] memory tokensOut = new address[](1);\n            (tokensIn[0],,) = dataProvider.getReserveTokensAddresses(asset);\n            tokensOut[0] = asset;\n            return (\n                controllerFacade.isTokenAllowed(tokensIn[0]),\n                tokensIn,\n                tokensOut\n            );\n        }\n        if (sig == WITHDRAW) {\n            address asset = abi.decode(\n                data[4:],\n                (address)\n            );\n            address[] memory tokensIn = new address[](1);\n            address[] memory tokensOut = new address[](1);\n            tokensIn[0] = asset;\n            (tokensOut[0],,) = dataProvider.getReserveTokensAddresses(asset);\n            return (true, tokensIn, tokensOut);\n        }\n        return (false, new address[](0), new address[](0));\n    }\n}"
    },
    {
      "filename": "src/aave/AaveV3Controller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IControllerFacade} from \"../core/IControllerFacade.sol\";\nimport {IPoolV3} from \"./IPoolV3.sol\";\n\n/**\n    @title Aave V3 controller\n    @notice Controller for aave v3 interaction\n    arbi:0x794a61358D6845594F94dc1DB02A252b5b4814aD\n*/\ncontract AaveV3Controller is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice supply(address,uint256,address,uint16) function signature\n    bytes4 public constant SUPPLY = 0x617ba037;\n\n    /// @notice withdraw(address,uint256,address) function signature\n    bytes4 public constant WITHDRAW = 0x69328dec;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice IControllerFacade\n    IControllerFacade public immutable controllerFacade;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract Constructor\n        @param _controller Address of controller facade\n    */\n    constructor(IControllerFacade _controller) {\n        controllerFacade = _controller;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n        if (sig == SUPPLY) {\n            address asset = abi.decode(\n                data[4:],\n                (address)\n            );\n            address[] memory tokensIn = new address[](1);\n            address[] memory tokensOut = new address[](1);\n            tokensIn[0] = IPoolV3(target).getReserveData(asset).aTokenAddress;\n            tokensOut[0] = asset;\n            return (\n                controllerFacade.isTokenAllowed(tokensIn[0]),\n                tokensIn,\n                tokensOut\n            );\n        }\n        if (sig == WITHDRAW) {\n            address asset = abi.decode(\n                data[4:],\n                (address)\n            );\n            address[] memory tokensIn = new address[](1);\n            address[] memory tokensOut = new address[](1);\n            tokensIn[0] = asset;\n            tokensOut[0] = IPoolV3(target).getReserveData(asset).aTokenAddress;\n            return (true, tokensIn, tokensOut);\n        }\n        return (false, new address[](0), new address[](0));\n    }\n}"
    },
    {
      "filename": "src/balancer/BalancerController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IControllerFacade} from \"../core/IControllerFacade.sol\";\nimport {IVault} from \"./IVault.sol\";\n\n/**\n    @title Balancer V2 Controller\n    @notice Balance v2 controller for join/exit/swap/batchSwap (multiHop)\n*/\ncontract BalancerController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant JOIN = 0xb95cac28;\n\n    /// @notice exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant EXIT = 0x8bdb3913;\n\n    /// @notice swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)\n    bytes4 constant SWAP = 0x52bbbe29;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE_VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    IControllerFacade immutable controllerFacade;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _controller Controller Facade\n    */\n    constructor(IControllerFacade _controller) {\n        controllerFacade = _controller;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              EXTERNAL FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool useEth, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == JOIN)\n            return canJoin(target, useEth, data[4:]);\n        if (sig == EXIT)\n            return canExit(target, useEth, data[4:]);\n        if (sig == SWAP)\n            return canSwap(target, useEth, data[4:]);\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canJoin(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.JoinPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.JoinPoolRequest\n            )\n        );\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (\n                request.maxAmountsIn[i] > 0 &&\n                address(request.assets[i]) != address(0)\n            )\n                tokensOut[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensOut, j) }\n\n        (tokensIn[0],) = IVault(target).getPool(poolId);\n\n        return (\n            controllerFacade.isTokenAllowed(tokensIn[0]),\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canExit(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.ExitPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.ExitPoolRequest\n            )\n        );\n        address[] memory tokensOut = new address[](1);\n        address[] memory tokensIn = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (\n                request.minAmountsOut[i] > 0 &&\n                address(request.assets[i]) != address(0)\n            )\n                tokensIn[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensIn, j) }\n\n        (tokensOut[0],) = IVault(target).getPool(poolId);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canSwap(address, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            IVault.SingleSwap memory swap,\n            ,\n            ,\n        ) = abi.decode(data, (\n                IVault.SingleSwap, IVault.FundManagement, uint256, uint256\n            )\n        );\n\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n\n        if (address(swap.assetIn) == address(0)) {\n            tokensIn = new address[](1);\n            tokensIn[0] = address(swap.assetOut);\n            return (\n                controllerFacade.isTokenAllowed(tokensIn[0]),\n                tokensIn,\n                new address[](0)\n            );\n        }\n\n        if (address(swap.assetOut) == address(0)) {\n            tokensOut = new address[](1);\n            tokensOut[0] = address(swap.assetIn);\n            return (\n                true,\n                new address[](0),\n                tokensOut\n            );\n        }\n\n        tokensIn = new address[](1);\n        tokensOut = new address[](1);\n        tokensOut[0] = address(swap.assetIn);\n        tokensIn[0] = address(swap.assetOut);\n\n        return (\n            controllerFacade.isTokenAllowed(tokensIn[0]),\n            tokensIn,\n            tokensOut\n        );\n    }\n}"
    },
    {
      "filename": "src/core/AccountManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRiskEngine} from \"../interface/core/IRiskEngine.sol\";\nimport {IAccountFactory} from \"../interface/core/IAccountFactory.sol\";\nimport {IAccountManager} from \"../interface/core/IAccountManager.sol\";\nimport {IControllerFacade} from \"controller/core/IControllerFacade.sol\";\n\n/**\n    @title Account Manager\n    @notice Sentiment Account Manager,\n        All account interactions go via the account manager\n*/\ncontract AccountManager is Pausable, IAccountManager {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE_VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Risk Engine\n    IRiskEngine public riskEngine;\n\n    /// @notice Controller Facade\n    IControllerFacade public controller;\n\n    /// @notice Account Factory\n    IAccountFactory public accountFactory;\n\n    /// @notice List of inactive accounts per user\n    mapping(address => address[]) public inactiveAccountsOf;\n\n    /// @notice Mapping of collateral enabled tokens\n    mapping(address => bool) public isCollateralAllowed;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier onlyOwner(address account) {\n        if (registry.ownerFor(account) != msg.sender)\n            revert Errors.AccountOwnerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Initializes contract\n        @dev Can only be invoked once\n        @param _registry Address of Registry\n    */\n    function init(IRegistry _registry) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n        initialized = true;\n        initPausable(msg.sender);\n        registry = _registry;\n    }\n\n    /// @notice Initializes external dependencies\n    function initDep() external adminOnly {\n        riskEngine = IRiskEngine(registry.getAddress('RISK_ENGINE'));\n        controller = IControllerFacade(registry.getAddress('CONTROLLER'));\n        accountFactory =\n            IAccountFactory(registry.getAddress('ACCOUNT_FACTORY'));\n    }\n\n    /**\n        @notice Opens a new account for a user\n        @dev Creates a new account if there are no inactive accounts otherwise\n            reuses an already inactive account\n            Emits AccountAssigned(account, owner) event\n        @param owner Owner of the newly opened account\n    */\n    function openAccount(address owner) external whenNotPaused {\n        if (owner == address(0)) revert Errors.ZeroAddress();\n        address account;\n        uint length = inactiveAccountsOf[owner].length;\n        if (length == 0) {\n            account = accountFactory.create(address(this));\n            IAccount(account).init(address(this));\n            registry.addAccount(account, owner);\n        } else {\n            account = inactiveAccountsOf[owner][length - 1];\n            inactiveAccountsOf[owner].pop();\n            registry.updateAccount(account, owner);\n        }\n        IAccount(account).activate();\n        emit AccountAssigned(account, owner);\n    }\n\n    /**\n        @notice Closes a specified account for a user\n        @dev Account can only be closed when the account has no debt\n            Emits AccountClosed(account, owner) event\n        @param _account Address of account to be closed\n    */\n    function closeAccount(address _account) public onlyOwner(_account) {\n        IAccount account = IAccount(_account);\n        if (account.activationBlock() == block.number)\n            revert Errors.AccountDeactivationFailure();\n        if (!account.hasNoDebt()) revert Errors.OutstandingDebt();\n        account.deactivate();\n        registry.closeAccount(_account);\n        inactiveAccountsOf[msg.sender].push(_account);\n        account.sweepTo(msg.sender);\n        emit AccountClosed(_account, msg.sender);\n    }\n\n    /**\n        @notice Transfers Eth from owner to account\n        @param account Address of account\n    */\n    function depositEth(address account)\n        external\n        payable\n        whenNotPaused\n        onlyOwner(account)\n    {\n        account.safeTransferEth(msg.value);\n    }\n\n    /**\n        @notice Transfers Eth from the account to owner\n        @dev Eth can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param amt Amount of Eth to withdraw\n    */\n    function withdrawEth(address account, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if(!riskEngine.isWithdrawAllowed(account, address(0), amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdrawEth(msg.sender, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the owner\n            to the account\n        @dev Token must be accepted as collateral by the protocol\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to deposit\n    */\n    function deposit(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (!isCollateralAllowed[token])\n            revert Errors.CollateralTypeRestricted();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        token.safeTransferFrom(msg.sender, account, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the account\n            to the owner of the account\n        @dev Amount of token can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to withdraw\n    */\n    function withdraw(address account, address token, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if (!riskEngine.isWithdrawAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdraw(msg.sender, token, amt);\n        if (token.balanceOf(account) == 0)\n            IAccount(account).removeAsset(token);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the LP to the account\n        @dev Specified token must have a LP\n            Account must remain healthy after the borrow, otherwise tx is reverted\n            Emits Borrow(account, msg.sender, token, amount) event\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n    */\n    function borrow(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (registry.LTokenFor(token) == address(0))\n            revert Errors.LTokenUnavailable();\n        if (!riskEngine.isBorrowAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        if (ILToken(registry.LTokenFor(token)).lendTo(account, amt))\n            IAccount(account).addBorrow(token);\n        emit Borrow(account, msg.sender, token, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the accou"
    }
  ]
}