{
  "Title": "M-2: `slash` calls can be blocked, allowing malicious users to bypass the slashing mechanism.",
  "Content": "# Issue M-2: `slash` calls can be blocked, allowing malicious users to bypass the slashing mechanism. \n\nSource: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/54 \n\n## Found by \nTricko, dipp\n\n## Summary\nA malicious user can block slashing by frontrunning `slash` with a call to `stake(1)` at the same block, allowing him to keep blocking calls to `slash` while waiting for his withdraw delay, effectively bypassing the slashing mechanism.\n\n## Vulnerability Detail\n`StakingModule`'s `checkpointProtection` modifier reverts certain actions, like claims, if the accounts' stake was previously modified in the same block. A malicious user can exploit this to intentionally block calls to `slash`.\n\nConsider the following scenario, where Alice has `SLASHER_ROLE` and Bob is the malicious user.\n1. Alice calls `slash` on Bob's account.\n2. Bob sees the transaction on the mempool and tries to frontrun it by staking 1 TEL.\n(See Proof of Concept section below for a simplified example of this scenario)\n\nIf Bob stake call is processed first (he can pay more gas to increase his odds of being placed before than Alice), his new stake is pushed to `_stakes[address(Bob)]`, and his latest checkpoint (`_stakes[address(Bob)]._checkpoints[numCheckpoints - 1]`) `blockNumber` field is updated to the current `block.number`. So when `slash` is being processed in the same block and calls internally `_claimAndExit` it will revert due to the `checkpointProtection` modifier check (See code snippet below).\n\n```javascript\nmodifier checkpointProtection(address account) {\n    uint256 numCheckpoints = _stakes[account]._checkpoints.length;\n    require(numCheckpoints == 0 || _stakes[account]._checkpoints[numCheckpoints - 1]._blockNumber != block.number, \"StakingModule: Cannot exit in the same block as another stake or exit\");\n    _;\n}\n```\nBob can do this indefinitely, eventually becoming a gas war between Alice and Bob or until Alice tries to use Flashbots Protect or similar services to avoid the public mempool. More importantly, this can be leverage to block all `slash` attempts while waiting the time required to withdraw, so the malicious user could call `requestWithdrawal()`, then keep blocking all future `slash` calls while waiting for his `withdrawalDelay`, then proceed to withdraws his stake when `block.timestamp > withdrawalRequestTimestamps[msg.sender] + withdrawalDelay`. Therefore bypassing the slashing mechanism.\n\nIn this modified scenario \n1. Alice calls `slash` on Bob's account.\n2. Bob sees the transaction on the mempool and tries to frontrun it by staking 1 TEL.\n3. Bob requests his withdraw (`requestWithdrawal()`)\n4. Bob keeps monitoring the mempool for future calls to `slash` against his account, trying to frontrun each one of them.\n5. When enough time has passed so that his withdraw is available, Bob calls `exit` or `fullClaimAndExit`\n\n## Impact\nSlashing calls can be blocked by malicious user, allowing him to request his withdraw, wait until withdraw delay has passed (while blocking further calls to `slash`) and then withdraw his funds.\n\nClassify this one as medium severity, because even though there are ways to avoid being frontrunned, like paying much more gas or using services like Flashbots Protect, none is certain to work because the malicious user can use the same methods to their advantage.  And if the malicious user is successful, this would result in loss of funds to the protocol (i.e funds that should have been slashed, but user managed to withdraw them)\n\n## Proof of Concept\nThe POC below shows that staking prevents any future call to `slash` on the same block. To reproduce this POC just copy the code to a file on the test/ folder and run it.\n```javascript\nconst { expect } = require(\"chai\")\nconst { ethers, upgrades } = require(\"hardhat\")\n\nconst emptyBytes = []\n\ndescribe(\"POC\", () => {\n  let deployer\n  let alice\n  let bob\n  let telContract\n  let stakingContract\n  let SLASHER_ROLE\n\n  beforeEach(\"setup\", async () => {\n    [deployer, alice, bob] = await ethers.getSigners()\n\n    //Deployments\n    const TELFactory = await ethers.getContractFactory(\"TestTelcoin\", deployer)\n    const StakingModuleFactory = await ethers.getContractFactory(\n      \"StakingModule\",\n      deployer\n    )\n    telContract = await TELFactory.deploy(deployer.address)\n    await telContract.deployed()\n    stakingContract = await upgrades.deployProxy(StakingModuleFactory, [\n      telContract.address,\n      3600,\n      10\n    ])\n\n    //Grant SLASHER_ROLE to Alice\n    SLASHER_ROLE = await stakingContract.SLASHER_ROLE()\n    await stakingContract\n      .connect(deployer)\n      .grantRole(SLASHER_ROLE, alice.address)\n\n    //Send some TEL tokens to Bob\n    await telContract.connect(deployer).transfer(bob.address, 1)\n\n    //Setup approvals\n    await telContract\n      .connect(bob)\n      .approve(stakingContract.address, 1)\n  })\n\n  describe(\"POC\", () => {\n    it(\"should revert during slash\", async () => {\n      //Disable auto-mining and set interval to 0 necessary to guarantee both transactions\n      //below are mined in the same block, reproducing the frontrunning scenario.\n      await network.provider.send(\"evm_setAutomine\", [false]);\n      await network.provider.send(\"evm_setIntervalMining\", [0]);\n\n      //Bob stakes 1 TEL\n      await stakingContract\n        .connect(bob)\n        .stake(1)\n\n      //Turn on the auto-mining, so that after the next transaction is sent, the block is mined.\n      await network.provider.send(\"evm_setAutomine\", [true]);\n      \n      //Alice tries to slash Bob, but reverts.\n      await expect(stakingContract\n        .connect(alice)\n        .slash(bob.address, 1, stakingContract.address, emptyBytes)).to.be.revertedWith(\n          \"StakingModule: Cannot exit in the same block as another stake or exit\"\n        )\n    })\n  })\n})\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L109-L113\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L510-L513\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L460-L483\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider implementing a specific version of `_claimAndExit` without the `checkpointProtection` modifier, to be used inside the `slash` function. \n\n## Discussion\n\n**amshirif**\n\nTwo different issues are in the same PR because they both stem from the same modifier.\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/6\n\n**dmitriia**\n\nLooks ok\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/49",
  "Code": [
    {
      "filename": "telcoin-audit/contracts/staking/StakingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"../interfaces/IPlugin.sol\";\n\n// TODO: improve require messages\n\n/// @title Staking Module\n/// @notice Users interact directly with this contract to participate in staking. \n/// @dev This contract holds user funds. It does not accrue any staking yield on its own, it must have one or more `IPlugin` contracts \"connected\" to it.\ncontract StakingModule is ReentrancyGuardUpgradeable, AccessControlEnumerableUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.History;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using BytesLib for bytes;\n\n    /// @notice This role grants the ability to slash users' stakes at its own discretion\n    bytes32 public constant SLASHER_ROLE = keccak256(\"SLASHER_ROLE\");\n    /// @notice This role grants the ability to add and remove IPlugin contracts\n    bytes32 public constant PLUGIN_EDITOR_ROLE = keccak256(\"PLUGIN_EDITOR_ROLE\");\n    /// @notice This role grants the ability to rescue ERC20 tokens that do not rightfully belong to this contract\n    bytes32 public constant RECOVERY_ROLE = keccak256(\"RECOVERY_ROLE\");\n    /// @notice This role grants the ability to migrate user funds\n    bytes32 public constant MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    /// @notice The amount of time a user has to withdraw once the withdrawal delay has elapsed after requesting withdrawal\n    uint256 public withdrawalWindow;\n    /// @notice The withdrawal delay for preventing slash frontrunning\n    uint256 public withdrawalDelay;\n    /// @notice Maximum allowable withdrawal delay\n    /// @dev If there was no maximum, the delay could be very large which would prevent users from withdrawing\n    uint256 public maxWithdrawalDelay;\n    /// @notice Minimum allowable difference between withdrawal window and withdrawal delay\n    /// @dev If there was no minimum, the window could be set to 0 which would prevent users from withdrawing\n    uint256 public minWithdrawalWindow;\n\n    /// @notice TEL ERC20 address\n    address public tel;\n\n    /// @notice Array of all connected IPlugin contracts\n    address[] public plugins;\n\n    /// @notice Number of currently connected Plugins\n    uint256 public nPlugins;\n\n    /// @notice Maps a Plugin to whether or not it is included in `plugins`\n    /// @dev This allows duplicate plugins to be prevented\n    mapping(address => bool) public pluginsMapping;\n\n    /// @notice Maps a plugin to its index in the plugins array\n    /// @dev A plugin that is not in the plugins array does not necessarily map to 0\n    mapping(address => uint256) public pluginIndicies;\n\n    /// @notice Maps an account to a timestamp when they can call any withdrawal function. If zero, then a withdrawal hasn't been requested.\n    /// @dev If withdrawalDelay is zero, then the user does not need to request a withdrawal first\n    mapping(address => uint256) public withdrawalRequestTimestamps;\n\n    /// @notice Total TEL staked by users in this contract\n    uint256 private _totalStaked;\n    /// @notice Maps an account to its staked amount history\n    mapping(address => CheckpointsUpgradeable.History) private _stakes;\n\n    /// @dev The header of an auxData payload is an array of HeaderItem's\n    /// @dev The purpose of the HeaderItem(s) is to mark which parts of the data payload are for which plugins\n    struct AuxDataHeaderItem {\n        address addr;\n        uint256 start;\n        uint256 len;\n    }\n\n    /// @notice An event that's emitted when a account's stake changes (deposit/withdraw/slash)\n    event StakeChanged(address indexed account, uint256 oldStake, uint256 newStake);\n    /// @notice An event that's emitted when an account claims some yield\n    event Claimed(address indexed account, uint256 amount);\n    /// @notice An event that's emitted when an account's stake is slashed\n    event Slashed(address indexed account, uint256 amount);\n\n    /// @notice An event that's emitted when a plugin is added\n    event PluginAdded(address indexed plugin, uint256 nPlugins);\n    /// @notice An event that's emitted when a plugin is removed\n    event PluginRemoved(address indexed plugin, uint256 nPlugins);\n\n    /// @notice An event that's emitted when a call to a plugin's claim function reverts\n    event PluginClaimFailed(address indexed plugin);\n\n    /// @notice An event that's emitted when a call to a plugin's notifyStakeChange function reverts\n    event StakeChangeNotificationFailed(address indexed plugin);\n\n    function initialize(address _telAddress, uint256 _maxWithdrawalDelay, uint256 _minWithdrawalWindow) public initializer {\n        tel = _telAddress;\n        maxWithdrawalDelay = _maxWithdrawalDelay;\n        minWithdrawalWindow = _minWithdrawalWindow;\n\n        // initialize OZ stuff\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained();\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init_unchained();\n\n        // set deployer as ADMIN\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier checkpointProtection(address account) {\n        uint256 numCheckpoints = _stakes[account]._checkpoints.length;\n        require(numCheckpoints == 0 || _stakes[account]._checkpoints[numCheckpoints - 1]._blockNumber != block.number, \"StakingModule: Cannot exit in the same block as another stake or exit\");\n        _;\n    }\n\n    modifier delayedWithdrawal() {\n        require(withdrawalDelay == 0 || (\n                withdrawalRequestTimestamps[msg.sender] + withdrawalDelay <= block.timestamp &&\n                block.timestamp <= withdrawalRequestTimestamps[msg.sender] + withdrawalDelay + withdrawalWindow\n            ), \n            \"StakingModule: Withdrawal not requested yet or it is too early/late to withdraw\"\n        );\n        withdrawalRequestTimestamps[msg.sender] = 0;\n        _;\n    }\n    \n    /************************************************\n    *   view functions\n    ************************************************/\n\n    /// @notice Parses auxiliary data into a bytes[] with length nPlugins\n    function parseAuxData(bytes calldata auxData) public view returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](nPlugins);\n\n        if (auxData.length == 0) {\n            return arr;\n        }\n        \n        (AuxDataHeaderItem[] memory header, bytes memory payload) = abi.decode(auxData, (AuxDataHeaderItem[], bytes));\n\n        for (uint256 i = 0; i < header.length; i++) {\n            require(pluginsMapping[header[i].addr], \"StakingModule: Invalid Plugin when parsing auxData\");\n            arr[pluginIndicies[header[i].addr]] = payload.slice(header[i].start, header[i].len);\n        }\n        \n        return arr;\n    }\n\n    /// @dev For some future Plugins not yet ideated, totalClaimable may be hard or impossible to implement. \n    /// @dev This would break `totalSupply`, but `totalSupply` is not strictly necessary anyway.\n    /// @return Total supply of staked TEL, including all yield\n    function totalSupply() external view returns (uint256) {\n        uint256 total;\n\n        // loop over all plugins and sum up totalClaimable\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).totalClaimable();\n        }\n        \n        // totalSupply is the total claimable from all plugins plus the total amount staked\n        return total + _totalStaked;\n    }\n\n    /// @return Balance of an account. This includes stake and claimable yield.\n    /// @param account Account to query balance of\n    /// @param auxData Auxiliary data to pass to plugins\n    function balanceOf(address account, bytes calldata auxData) public view returns (uint256) {\n        return _stakes[account].latest() + claimable(account, auxData);\n    }\n\n    /// @return Balance of an account at a specific block. This includes stake and claimable yield.\n    /// @param account Account to query balance of\n    /// @param blockNumber Block at which to query balance\n    /// @param auxData Auxiliary data to pass to plugins\n    function balanceOfAt(address account, uint256 blockNumber, bytes calldata auxData) external view returns (uint256) {\n        return stakedByAt(account, blockNumber) + claimableAt(account, blockNumber, auxData);\n    }\n\n    /// @return Total amount staked by all accounts\n    function totalStaked() external view returns (uint256) {\n        return _totalStaked;\n    }\n\n    /// @dev Checks `claimable(account)` of all Plugins and returns the total.\n    /// @param account Account to query balance of\n    /// @param auxData Auxiliary data to pass to plugins\n    /// @return Total amount claimable by an account\n    function claimable(address account, bytes calldata auxData) public view returns (uint256) {\n        uint256 total;\n        // loop over all plugins, sum claimable of account\n        bytes[] memory parsedAuxData = parseAuxData(auxData);\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claimable(account, parsedAuxData[i]);\n        }\n        return total;\n    }\n\n    /// @dev Checks `claimableAt(account, blockNumber)` of all Plugins.\n    /// @param account Account to query claimable amount\n    /// @param blockNumber Block at which to query claimable amount\n    /// @param auxData Auxiliary data to pass to plugins\n    /// @return Total amount claimable by an account at a specific block number.\n    function claimableAt(address account, uint256 blockNumber, bytes calldata auxData) public view returns (uint256) {\n        uint256 total;\n        // loop over all plugins, sum claimableAt of account\n        bytes[] memory parsedAuxData = parseAuxData(auxData);\n        for (uint256 i = 0; i < nPlugins; i++) {\n            total += IPlugin(plugins[i]).claimableAt(account, blockNumber, parsedAuxData[i]);\n        }\n        return total;\n    }\n\n    /// @return Amount staked by an account. This does not include claimable yield from plugins.\n    /// @param account Account to query staked amount\n    function stakedBy(address account) external view returns (uint256) {\n        return _stakes[account].latest();\n    }\n\n    /// @return Amount staked by an account at a specific block number excluding claimable yield.\n    /// @param account Account to query staked amount\n    /// @param blockNumber Block at which to query staked amount\n    function stakedByAt(address account, uint256 blockNumber) public view returns (uint256) {\n        return _stakes[account].getAtBlock(blockNumber);\n    }\n\n    /************************************************\n    *   external mutative functions\n    ************************************************/\n\n    /// @notice Request a withdrawal if withdrawalDelay is nonzero\n    /// @dev This is required to prevent users from frontrunning slashing\n    function requestWithdrawal() external {\n        require(withdrawalDelay > 0, \"StakingModule: Withdrawal delay is 0\");\n        require(block.timestamp > withdrawalRequestTimestamps[msg.sender] + withdrawalDelay + withdrawalWindow, \"StakingModule: Withdrawal already pending\");\n\n        withdrawalRequestTimestamps[msg.sender] = block.timestamp;\n    }\n\n    /// @notice Stakes some amount of TEL to earn potential rewards.\n    /// @param amount Amount to stake\n    function stake(uint256 amount) external nonReentrant {\n        _stake({\n            account: msg.sender, \n            from: msg.sender, \n            amount: amount\n        });\n    }\n\n    function partialExit(uint256 amount) external nonReentrant delayedWithdrawal {\n        _partialExit({\n            account: msg.sender, \n            to: msg.sender, \n            exitAmount: amount\n        });\n    }\n\n    /// @notice Withdraws staked TEL, does not claim any yield.\n    /// @return Amount withdrawn\n    function exit() external nonReentrant delayedWithdrawal returns (uint256) {\n        return _exit({\n            account: msg.sender, \n            to: msg.sender\n        });\n    }\n\n    /// @notice Claims yield from an individual plugin and sends it to calling account.\n    /// @param pluginAddress Address of desired plugin\n    /// @param auxData Auxiliary data for the plugin\n    /// @return Amount claimed\n    function claimFromIndividualPlugin(address pluginAddress, bytes calldata auxData) external nonReentrant delayedWithdrawal returns (uint256) {\n        return _claimFromIndividualPlugin({\n            account: msg.sender, \n            to: msg.sender, \n            pluginAddress: pluginAddress, \n            auxData: auxData\n        });\n    }\n\n    /// @notice Claims yield from all plugins and sends it to calling account.\n    /// @param auxData Auxiliary data for the plugins\n    /// @return Amount claimed\n    function claim(bytes calldata auxData) external nonReentrant delayedWithdrawal returns (uint256) {\n        return _claim({\n            account: msg.sender, \n            to: msg.sender, \n            auxData: auxData\n        });\n    }\n\n    /// @notice Claims all yield and withdraws all stake.\n    /// @param auxData Auxiliary data for the plugins\n    /// @return Amount claimed\n    /// @return Amount withdrawn\n    function fullClaimAndExit(bytes calldata auxData) external nonReentrant delayedWithdrawal returns (uint256, uint256) {\n        return (\n            _claim({ account: msg.sender, to: msg.sender, auxData: auxData }), \n            _exit(msg.sender, msg.sender)\n        );\n    }\n\n    /// @notice Claims yield and withdraws some of stake.\n    /// @param amount Amount to withdraw\n    /// @param auxData Auxiliary data for the plugins\n    function partialClaimAndExit(uint256 amount, bytes calldata auxData) external nonReentrant delayedWithdrawal {\n        _claimAndExit({\n            account: msg.sender, \n            amount: amount, \n            to: msg.sender,\n            auxData: auxData\n        });\n    }\n\n    \n\n    /************************************************\n    *   private mutative functions\n    ************************************************/\n\n    /// @notice Claims earned yield from an individual plugin\n    /// @param account Account to claim on behalf of.\n    /// @param to Address to send the claimed yield to.\n    /// @param pluginAddress Address of the desired plugin to claim from\n    /// @dev Calls `claim` on the desired plugin\n    /// @dev Checks to make sure the amount of tokens the plugins sent matches what the `claim` functions returned. (Probably unnecessary)\n    /// @return Amount claimed\n    function _claimFromIndividualPlugin(address account, address to, address pluginAddress, bytes calldata auxData) private returns (uint256) {\n        require(pluginsMapping[pluginAddress], \"StakingModule::_claimFromIndividualPlugin: Provided pluginAddress is invalid\");\n        \n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // xClaimed = \"amount of TEL claimed from the plugin\"\n        uint256 xClaimed = IPlugin(pluginAddress).claim(account, to, parseAuxData(auxData)[pluginIndicies[pluginAddress]]);\n\n        // we want to make sure the plugin did not return the wrong amount\n        require(IERC20Upgradeable(tel).balanceOf(to) - balBefore == xClaimed, \"The plugin did not send appropriate token amount\");\n\n        // only emit Claimed if anything was actually claimed\n        if (xClaimed > 0) {\n            emit Claimed(account, xClaimed);\n        }\n\n        return xClaimed;\n    }\n\n    /// @notice Claims earned yield\n    /// @param account Account to claim on behalf of.\n    /// @param to Address to send the claimed yield to.\n    /// @param auxData Auxiliary data for the plugins\n    /// @dev Iterates over all plugins and calls `claim`\n    /// @dev Checks to make sure the amount of tokens the plugins sent matches what the `claim` functions returned.\n    /// @dev If amount claimed is >0, emit Claimed\n    /// @return Amount claimed\n    function _claim(address account, address to, bytes calldata auxData) private returns (uint256) {\n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // call claim on all plugins and count the total amount claimed\n        uint256 total;\n        bytes[] memory parsedAuxData = parseAuxData(auxData);\n        for (uint256 i = 0; i < nPlugins; i++) {\n            try IPlugin(plugins[i]).claim(account, to, parsedAuxData[i]) returns (uint256 xClaimed) {\n                total += xClaimed;\n            } catch  {\n                emit PluginClaimFailed(plugins[i]);\n            }\n        }\n\n        // make sure `total` actually matches how much we've claimed\n        require(IERC20Upgradeable(tel).balanceOf(to) - balBefore == total, \"one or more plugins did not send appropriate token amount\");\n\n        // only emit Claimed if anything was actually claimed\n        if (total > 0) {\n            emit Claimed(account, total);\n        }\n\n        return total;\n    }\n\n    /// @notice Withdraws staked TEL to the specified `to` address, does not claim any yield.\n    /// @dev Notifies all plugins that account's stake is changing.\n    /// @dev Writes _stakes checkpoint. \n    /// @dev Decrements _totalStaked\n    /// @dev Transfers TEL\n    /// @dev Emits StakeChanged.\n    /// @param account Account to exit on behalf of.\n    /// @param to Address to send the withdrawn balance to.\n    /// @return Amount withdrawn\n    function _exit(address account, address to) private returns (uint256) {\n        uint256 stakedAmt = _stakes[account].latest();\n\n        _partialExit(account, to, stakedAmt);\n\n        return stakedAmt;\n    }\n\n    function _partialExit(address account, address to, uint256 exitAmount) private checkpointProtection(account) {\n        if (exitAmount == 0) {\n            return;\n        }\n\n        uint256 stakedAmt = _stakes[account].latest();\n\n        require(stakedAmt >= exitAmount, \"StakingMoudle: Cannot exit more than is staked\");\n\n        // notify plugins\n        _notifyStakeChangeAllPlugins(account, stakedAmt, stakedAmt - exitAmount);\n\n        // update checkpoints\n        _stakes[account].push(stakedAmt - exitAmount);\n\n        // update _totalStaked\n        _totalStaked -= exitAmount;\n\n        // move the tokens\n        IERC20Upgradeable(tel).safeTransfer(to, exitAmount);\n\n        emit StakeChanged(account, stakedAmt, stakedAmt - exitAmount);\n    }\n\n    /// @notice Stakes some amount of TEL to earn potential rewards.\n    /// @dev Notifies all plugins that account's stake is changing.\n    /// @dev Updates _stakes[account]\n    /// @dev Increments _totalStaked\n    /// @dev Transfers TEL\n    /// @dev Emits StakeChanged.\n    /// @param account Account to stake on behalf of\n    /// @param from Address to pull TEL from\n    /// @param amount Amount to stake\n    function _stake(address account, address from, uint256 amount) private {\n        require(amount > 0, \"Cannot stake 0\");\n\n        uint256 stakedBefore = _stakes[account].latest();\n        uint256 stakedAfter = stakedBefore + amount;\n\n        // notify plugins\n        _notifyStakeChangeAllPlugins(account, stakedBefore, stakedAfter);\n        \n        // update _stakes\n        _stakes[account].push(stakedAfter);\n\n        // update _totalStaked\n        _totalStaked += amount;\n\n        // move the tokens\n        IERC20Upgradeable(tel).safeTransferFrom(from, address(this), amount);\n\n        emit StakeChanged(account, stakedBefore, stakedAfter);\n    }\n\n    /// @notice Claims yield and withdraws some of stake. Everything leftover remains staked\n    /// @param account account\n    /// @param amount amount to withdraw\n    /// @param to account to send withdrawn funds to\n    /// @dev The yield of the account is claimed to this contract\n    /// @dev Call `notifyStakeChange` on all plugins\n    /// @dev Update _stakes[account]\n    /// @dev Update _totalStaked\n    /// @dev Transfer `amount` of tokens to `to`\n    /// @dev Emit StakeChanged\n    function _claimAndExit(address account, uint256 amount, address to, bytes calldata auxData) private checkpointProtection(account) {\n        require(amount <= balanceOf(account, auxData), \"Account has insufficient balance\");\n\n        // keep track of initial stake\n        uint256 oldStake = _stakes[account].latest();\n        // xClaimed = total amount claimed\n        uint256 xClaimed = _claim(account, address(this), auxData);\n\n        uint256 newStake = oldStake + xClaimed - amount;\n\n        // notify all plugins that account's stake has changed (if the plugin requires)\n        _notifyStakeChangeAllPlugins(account, oldStake, newStake);\n\n        // update _stakes\n        _stakes[account].push(newStake);\n\n        // decrement _totalStaked\n        _totalStaked = _totalStaked - oldStake + newStake;\n\n        // transfer the tokens to `to`\n        IERC20Upgradeable(tel).safeTransfer(to, amount);\n\n        emit StakeChanged(account, oldStake, newStake);\n    }\n\n    /// @dev Calls `notifyStakeChange` on all plugins that require it. This is done in case any given plugin needs to do some stuff when a user exits.\n    /// @param account Account that is exiting\n    function _notifyStakeChangeAllPlugins(address account, uint256 amountBefore, uint256 amountAfter) private {\n        // loop over all plugins\n        for (uint256 i = 0; i < nPlugins; i++) {\n            // only notify if the plugin requires\n            if (IPlugin(plugins[i]).requiresNotification()) {\n                try IPlugin(plugins[i]).notifyStakeChange(account, amountBefore, amountAfter) {}\n                catch {\n                    emit StakeChangeNotificationFailed(plugins[i]);\n                }\n            }\n        }\n    }\n\n\n    /************************************************\n    *   restricted functions\n    ************************************************/\n\n    /// @notice Slashes stake of an account.\n    /// @notice Only those holding the `SLASHER_ROLE` may call this.\n    /// @param account account to slash\n    /// @param amount amount to slash\n    /// @param to account to send slashed funds to\n    function slash(address account, uint amount, address to, bytes calldata auxData) external onlyRole(SLASHER_ROLE) nonReentrant {\n        _claimAndExit(account, amount, to, auxData);\n        emit Slashed(account, amount);\n    }\n\n    /// @notice Sets the withdrawal delay and window to prevent frontrunning slashes\n    function setWithdrawDelayAndWindow(uint256 delay, uint256 window) external onlyRole(SLASHER_ROLE) {\n        require(delay <= maxWithdrawalDelay, \"StakingModule: Desired delay is too long\");\n        require(window >= minWithdrawalWindow, \"StakingModule: Desired window is too short\");\n\n        // if window + delay is >= current time, then someone with a requestTimestamp of 0 will be able to withdraw (i.e. withdraw without requesting)\n        // when requestTimestamp = 0, the following must hold: t > d + w\n        require(window + delay < block.timestamp, \"StakingModule: Desired window + delay is too large\");\n\n        withdrawalDelay = delay;\n        withdrawalWindow = window;\n    }\n\n    /// @notice Adds a new plugin\n    function addPlugin(address plugin) external onlyRole(PLUGIN_EDITOR_ROLE) {\n        require(!IPlugin(plugin).deactivated(), \"StakingModule::addPlugin: Cannot add deactivated plugin\");\n        require(IERC165(plugin).supportsInterface(type(IPlugin).interfaceId), \"StakingModule::addPlugin: plugin does not support IPlugin\");\n        require(!pluginsMapping[plugin], \"StakingModule::addPlugin: Cannot add an existing plugin\");\n\n        plugins.push(plugin);\n        pluginsMapping[plugin] = true;\n        pluginIndicies[plugin] = nPlugins;\n        nPlugins++;\n\n        emit PluginAdded(plugin, nPlugins);\n    }\n\n    /// @notice Removes a plugin\n    function removePlugin(uint256 index) external onlyRole(PLUGIN_EDITOR_ROLE) {\n        address plugin = plugins[index];\n\n        require(IPlugin(plugin).deactivated(), \"StakingModule::removePlugin: Plugin is not deactivated\");\n\n        pluginsMapping[plugin] = false;\n        plugins[index] = plugins[nPlugins - 1];\n        pluginIndicies[plugins[index]] = index;\n        plugins.pop();\n        nPlugins--;\n\n        emit PluginRemoved(plugin, nPlugins);\n    }\n\n    /// @notice rescues any stuck erc20\n    /// @dev if the token is TEL, then it only allows maximum of balanceOf(this) - _totalStaked to be rescued\n    function rescueTokens(IERC20Upgradeable token, address to) external onlyRole(RECOVERY_ROLE) {\n        if (address(token) == tel) {\n            // if the token is TEL, only remove the extra amount that isn't staked\n            token.safeTransfer(to, token.balanceOf(address(this)) - _totalStaked);\n        }\n        else {\n            // if the token isn't TEL, remove all of it\n            token.safeTransfer(to, token.balanceOf(address(this)));\n        }\n    }\n\n    /// @notice claim and exit on behalf of a user\n    /// @dev This function is in case of a token migration\n    /// @dev We know this would be insanely gas intensive if there are a lot of users\n    function claimAndExitFor(address account, address to, bytes calldata auxData) external onlyRole(MIGRATOR_ROLE) nonReentrant returns (uint256, uint256) {\n        return (_claim(account, to, auxData), _exit(account, to));\n    }\n\n    /// @notice stake on behalf of a user\n    /// @dev This function is in case of a token migration\n    /// @dev We know this would be insanely gas intensive if there are a lot of users\n    function stakeFor(address account, uint256 amount) external onlyRole(MIGRATOR_ROLE) nonReentrant {\n        _stake(account, msg.sender, amount);\n    }\n}"
    },
    {
      "filename": "telcoin-audit/contracts/staking/StakingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"../interfaces/IPlugin.sol\";\n\n// TODO: improve require messages\n\n/// @title Staking Module\n/// @notice Users interact directly with this contract to participate in staking. \n/// @dev This contract holds user funds. It does not accrue any staking yield on its own, it must have one or more `IPlugin` contracts \"connected\" to it.\ncontract StakingModule is ReentrancyGuardUpgradeable, AccessControlEnumerableUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.History;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using BytesLib for bytes;\n\n    /// @notice This role grants the ability to slash users' stakes at its own discretion\n    bytes32 public constant SLASHER_ROLE = keccak256(\"SLASHER_ROLE\");\n    /// @notice This role grants the ability to add and remove IPlugin contracts\n    bytes32 public constant PLUGIN_EDITOR_ROLE = keccak256(\"PLUGIN_EDITOR_ROLE\");\n    /// @notice This role grants the ability to rescue ERC20 tokens that do not rightfully belong to this contract\n    bytes32 public constant RECOVERY_ROLE = keccak256(\"RECOVERY_ROLE\");\n    /// @notice This role grants the ability to migrate user funds\n    bytes32 public constant MIGRATOR_ROLE = keccak256(\"MIGRATOR_ROLE\");\n\n    /// @notice The amount of time a user has to withdraw once the withdrawal delay has elapsed after requesting withdrawal\n    uint256 public withdrawalWindow;\n    /// @notice The withdrawal delay for preventing slash frontrunning\n    uint256 public withdrawalDelay;\n    /// @notice Maximum allowable withdrawal delay\n    /// @dev If there was no maximum, the delay could be very large which would prevent users from withdrawing\n    uint256 public maxWithdrawalDelay;\n    /// @notice Minimum allowable difference between withdrawal window and withdrawal delay\n    /// @dev If there was no minimum, the window could be set to 0 which would prevent users from withdrawing\n    uint256 public minWithdrawalWindow;\n\n    /// @notice TEL ERC20 address\n    address public tel;\n\n    /// @notice Array of all connected IPlugin contracts\n    address[] public plugins;\n\n    /// @notice Number of currently connected Plugins\n    uint256 public nPlugins;\n\n    /// @notice Maps a Plugin to whether or not it is included in `plugins`\n    /// @dev This allows duplicate plugins to be prevented\n    mapping(address => bool) public pluginsMapping;\n\n    /// @notice Maps a plugin to its index in the plugins array\n    /// @dev A plugin that is not in the plugins array does not necessarily map to 0\n    mapping(address => uint256) public pluginIndicies;\n\n    /// @notice Maps an account to a timestamp when they can call any withdrawal function. If zero, then a withdrawal hasn't been requested.\n    /// @dev If withdrawalDelay is zero, then the user does not need to request a withdrawal first\n    mapping(address => uint256) public withdrawalRequestTimestamps;\n\n    /// @notice Total TEL staked by users in this contract\n    uint256 private _totalStaked;\n    /// @notice Maps an account to its staked amount history\n    mapping(address => CheckpointsUpgradeable.History) private _stakes;\n\n    /// @dev The header of an auxData payload is an array of HeaderItem's\n    /// @dev The purpose of the HeaderItem(s) is to mark which parts of the data payload are for which plugins\n    struct AuxDataHeaderItem {\n        address addr;\n        uint256 start;\n        uint256 len;\n    }\n\n    /// @notice An event that's emitted when a account's stake changes (deposit/withdraw/slash)\n    event StakeChanged(address indexed account, uint256 oldStake, uint256 newStake);\n    /// @notice An event that's emitted when an account claims some yield\n    event Claimed(address indexed account, uint256 amount);\n    /// @notice An event that's emitted when an account's stake is slashed\n    event Slashed(address indexed account, uint256 amount);\n\n    /// @notice An event that's emitted when a plugin is added\n    event PluginAdded(address indexed plugin, uint256 nPlugins);\n    /// @notice An event that's emitted when a plugin is removed\n    event PluginRemoved(address indexed plugin, uint256 nPlugins);\n\n    /// @notice An event that's emitted when a call to a plugin's claim function reverts\n    event PluginClaimFailed(address indexed plugin);\n\n    /// @notice An event that's emitted when a call to a plugin's notifyStakeChange function reverts\n    event StakeChangeNotificationFailed(address indexed plugin);\n\n    function initialize(address _telAddress, uint256 _maxWithdrawalDelay, uint256 _minWithdrawalWindow) public initializer {\n        tel = _telAddress;\n        maxWithdrawalDelay = _maxWithdrawalDelay;\n        minWithdrawalWindow = _minWithdrawalWindow;\n\n        // initialize OZ stuff\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained();\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init_unchained();\n\n        // set deployer as ADMIN\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier checkpointProtection(address account) {\n        uint256 numCheckpoints = _stakes[account]._checkpoints.length;\n        require(numCheckpoints == 0 || _stakes[account]._checkpoints[numCheckpoints - 1]._blockNumber != block.number, \"StakingModule: Cannot exit in the same block as another stake or exit\");\n        _;\n    }\n\n    modifier delayedWithdrawal() {\n        require(withdrawalDelay == 0 || (\n                withdrawalRequestTimestamps[msg.sender] + withdrawalDelay <= block.timestamp &&\n                block.timestamp <= withdrawalRequestTimestamps[msg.sender] + withdrawalDelay + withdrawalWindow\n            ), \n            \"StakingModule: Withdrawal not requested yet or it is too early/late to withdraw\"\n        );\n        withdrawalRequestTimestamps[msg.sender] = 0;\n        _;\n    }\n    \n    /************************************************\n    *   view functions\n    ************************************************/\n\n    /// @notice Parses auxiliary data into a bytes[] with length nPlugins\n    function parseAuxData(bytes calldata auxData) public view returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](nPlugins);\n\n        if (auxData.length == 0) {\n            return arr;\n        }\n        \n        (AuxDataHeaderItem[] memory header, bytes memory payload) = abi.decode(au"
    }
  ]
}