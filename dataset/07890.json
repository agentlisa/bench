{
  "Title": "[G-05]  ",
  "Content": "<h2 id=\"g-05--requirerevert-strings-longer-than-32-bytes-cost-extra-gas\" style=\"position:relative;\"><a href=\"#g-05--requirerevert-strings-longer-than-32-bytes-cost-extra-gas\" aria-label=\"g 05  requirerevert strings longer than 32 bytes cost extra gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-05]  <code>require()</code>/<code>revert()</code> strings longer than 32 bytes cost extra gas</h2>\n<p>Each extra memory word of bytes past the original 32 <a href=\"https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings\">incurs an MSTORE</a> which costs <strong>3 gas</strong></p>\n<p><em>There are 6 instances of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"25\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">gateway</span><span class=\"mtk1\">/</span><span class=\"mtk12\">GraphTokenGateway</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">19</span><span class=\"mtk1\">            </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">20</span><span class=\"mtk1\">                </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">controller</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getGovernor</span><span class=\"mtk1\">() || </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">pauseGuardian</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">21</span><span class=\"mtk1\">                </span><span class=\"mtk8\">\"Only Governor or Guardian can call\"</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">22</span><span class=\"mtk1\">:           );</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/GraphTokenGateway.sol#L19-L22\">https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/GraphTokenGateway.sol#L19-L22</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"26\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">governance</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Managed</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">53</span><span class=\"mtk1\">:           </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">controller</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getGovernor</span><span class=\"mtk1\">(), </span><span class=\"mtk8\">\"Caller must be Controller governor\"</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L53\">https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L53</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"27\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">upgrades</span><span class=\"mtk1\">/</span><span class=\"mtk12\">GraphProxy</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">105</span><span class=\"mtk1\">:          </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_newAdmin</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">\"Cannot change the admin of a proxy to the zero address\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">141</span><span class=\"mtk1\">:          </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">Address</span><span class=\"mtk1\">.</span><span class=\"mtk11\">isContract</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_pendingImplementation</span><span class=\"mtk1\">), </span><span class=\"mtk8\">\"Implementation must be a contract\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">142</span><span class=\"mtk1\">           </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">143</span><span class=\"mtk1\">               </span><span class=\"mtk12\">_pendingImplementation</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">) &amp;&amp; </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">_pendingImplementation</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">144</span><span class=\"mtk1\">               </span><span class=\"mtk8\">\"Caller must be the pending implementation\"</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">145</span><span class=\"mtk1\">:          );</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxy.sol#L105\">https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxy.sol#L105</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"28\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">upgrades</span><span class=\"mtk1\">/</span><span class=\"mtk12\">GraphUpgradeable</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">32</span><span class=\"mtk1\">:           </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">_implementation</span><span class=\"mtk1\">(), </span><span class=\"mtk8\">\"Caller must be the implementation\"</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphUpgradeable.sol#L32\">https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphUpgradeable.sol#L32</a></p>\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-the-graph-l2-bridge-contest",
  "Code": [
    {
      "filename": "contracts/gateway/GraphTokenGateway.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"../upgrades/GraphUpgradeable.sol\";\nimport \"../arbitrum/ITokenGateway.sol\";\nimport \"../governance/Pausable.sol\";\nimport \"../governance/Managed.sol\";\n\n/**\n * @title L1/L2 Graph Token Gateway\n * @dev This includes everything that's shared between the L1 and L2 sides of the bridge.\n */\nabstract contract GraphTokenGateway is GraphUpgradeable, Pausable, Managed, ITokenGateway {\n    /**\n     * @dev Check if the caller is the Controller's governor or this contract's pause guardian.\n     */\n    modifier onlyGovernorOrGuardian() {\n        require(\n            msg.sender == controller.getGovernor() || msg.sender == pauseGuardian,\n            \"Only Governor or Guardian can call\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Change the Pause Guardian for this contract\n     * @param _newPauseGuardian The address of the new Pause Guardian\n     */\n    function setPauseGuardian(address _newPauseGuardian) external onlyGovernor {\n        require(_newPauseGuardian != address(0), \"PauseGuardian must be set\");\n        _setPauseGuardian(_newPauseGuardian);\n    }\n\n    /**\n     * @dev Override the default pausing from Managed to allow pausing this\n     * particular contract instead of pausing from the Controller.\n     */\n    function _notPaused() internal view override {\n        require(!_paused, \"Paused (contract)\");\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @param _newPaused New value for the pause state (true means the transfers will be paused)\n     */\n    function setPaused(bool _newPaused) external onlyGovernorOrGuardian {\n        _setPaused(_newPaused);\n    }\n\n    /**\n     * @notice Getter to access paused state of this contract\n     */\n    function paused() external view returns (bool) {\n        return _paused;\n    }\n}"
    },
    {
      "filename": "contracts/governance/Managed.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"./IController.sol\";\n\nimport \"../curation/ICuration.sol\";\nimport \"../epochs/IEpochManager.sol\";\nimport \"../rewards/IRewardsManager.sol\";\nimport \"../staking/IStaking.sol\";\nimport \"../token/IGraphToken.sol\";\nimport \"../arbitrum/ITokenGateway.sol\";\n\n/**\n * @title Graph Managed contract\n * @dev The Managed contract provides an interface to interact with the Controller.\n * It also provides local caching for contract addresses. This mechanism relies on calling the\n * public `syncAllContracts()` function whenever a contract changes in the controller.\n *\n * Inspired by Livepeer:\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\n */\ncontract Managed {\n    // -- State --\n\n    // Controller that contract is registered with\n    IController public controller;\n    mapping(bytes32 => address) private addressCache;\n    uint256[10] private __gap;\n\n    // -- Events --\n\n    event ParameterUpdated(string param);\n    event SetController(address controller);\n\n    /**\n     * @dev Emitted when contract with `nameHash` is synced to `contractAddress`.\n     */\n    event ContractSynced(bytes32 indexed nameHash, address contractAddress);\n\n    // -- Modifiers --\n\n    function _notPartialPaused() internal view {\n        require(!controller.paused(), \"Paused\");\n        require(!controller.partialPaused(), \"Partial-paused\");\n    }\n\n    function _notPaused() internal view virtual {\n        require(!controller.paused(), \"Paused\");\n    }\n\n    function _onlyGovernor() internal view {\n        require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n    }\n\n    function _onlyController() internal view {\n        require(msg.sender == address(controller), \"Caller must be Controller\");\n    }\n\n    modifier notPartialPaused() {\n        _notPartialPaused();\n        _;\n    }\n\n    modifier notPaused() {\n        _notPaused();\n        _;\n    }\n\n    // Check if sender is controller.\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    // Check if sender is the governor.\n    modifier onlyGovernor() {\n        _onlyGovernor();\n        _;\n    }\n\n    // -- Functions --\n\n    /**\n     * @dev Initialize the controller.\n     */\n    function _initialize(address _controller) internal {\n        _setController(_controller);\n    }\n\n    /**\n     * @notice Set Controller. Only callable by current controller.\n     * @param _controller Controller contract address\n     */\n    function setController(address _controller) external onlyController {\n        _setController(_controller);\n    }\n\n    /**\n     * @dev Set controller.\n     * @param _controller Controller contract address\n     */\n    function _setController(address _controller) internal {\n        require(_controller != address(0), \"Controller must be set\");\n        controller = IController(_controller);\n        emit SetController(_controller);\n    }\n\n    /**\n     * @dev Return Curation interface.\n     * @return Curation contract registered with Controller\n     */\n    function curation() internal view returns (ICuration) {\n        return ICuration(_resolveContract(keccak256(\"Curation\")));\n    }\n\n    /**\n     * @dev Return EpochManager interface.\n     * @return Epoch manager contract registered with Controller\n     */\n    function epochManager() internal view returns (IEpochManager) {\n        return IEpochManager(_resolveContract(keccak256(\"EpochManager\")));\n    }\n\n    /**\n     * @dev Return RewardsManager interface.\n     * @return Rewards manager contract registered with Controller\n     */\n    function rewardsManager() internal view returns (IRewardsManager) {\n        return IRewardsManager(_resolveContract(keccak256(\"RewardsManager\")));\n    }\n\n    /**\n     * @dev Return Staking interface.\n     * @return Staking contract registered with Controller\n     */\n    function staking() internal view returns (IStaking) {\n        return IStaking(_resolveContract(keccak256(\"Staking\")));\n    }\n\n    /**\n     * @dev Return GraphToken interface.\n     * @return Graph token contract registered with Controller\n     */\n    function graphToken() internal view returns (IGraphToken) {\n        return IGraphToken(_resolveContract(keccak256(\"GraphToken\")));\n    }\n\n    /**\n     * @dev Return GraphTokenGateway (L1 or L2) interface.\n     * @return Graph token gateway contract registered with Controller\n     */\n    function graphTokenGateway() internal view returns (ITokenGateway) {\n        return ITokenGateway(_resolveContract(keccak256(\"GraphTokenGateway\")));\n    }\n\n    /**\n     * @dev Resolve a contract address from the cache or the Controller if not found.\n     * @return Address of the contract\n     */\n    function _resolveContract(bytes32 _nameHash) internal view returns (address) {\n        address contractAddress = addressCache[_nameHash];\n        if (contractAddress == address(0)) {\n            contractAddress = controller.getContractProxy(_nameHash);\n        }\n        return contractAddress;\n    }\n\n    /**\n     * @dev Cache a contract address from the Controller registry.\n     * @param _name Name of the contract to sync into the cache\n     */\n    function _syncContract(string memory _name) internal {\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\n        address contractAddress = controller.getContractProxy(nameHash);\n        if (addressCache[nameHash] != contractAddress) {\n            addressCache[nameHash] = contractAddress;\n            emit ContractSynced(nameHash, contractAddress);\n        }\n    }\n\n    /**\n     * @dev Sync protocol contract addresses from the Controller registry.\n     * This function will cache all the contracts using the latest addresses\n     * Anyone can call the function whenever a Proxy contract change in the\n     * controller to ensure the protocol is using the latest version\n     */\n    function syncAllContracts() external {\n        _syncContract(\"Curation\");\n        _syncContract(\"EpochManager\");\n        _syncContract(\"RewardsManager\");\n        _syncContract(\"Staking\");\n        _syncContract(\"GraphToken\");\n        _syncContract(\"GraphTokenGateway\");\n    }\n}"
    },
    {
      "filename": "contracts/upgrades/GraphProxy.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./GraphProxyStorage.sol\";\n\n/**\n * @title Graph Proxy\n * @dev Graph Proxy contract used to delegate call implementation contracts and support upgrades.\n * This contract should NOT define storage as it is managed by GraphProxyStorage.\n * This contract implements a proxy that is upgradeable by an admin.\n * https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#transparent-proxies-and-function-clashes\n */\ncontract GraphProxy is GraphProxyStorage {\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless\n     * the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless\n     * the sender is the admin or pending implementation.\n     */\n    modifier ifAdminOrPendingImpl() {\n        if (msg.sender == _admin() || msg.sender == _pendingImplementation()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Contract constructor.\n     * @param _impl Address of the initial implementation\n     * @param _admin Address of the proxy admin\n     */\n    constructor(address _impl, address _admin) {\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        assert(\n            IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        assert(\n            PENDING_IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.pendingImplementation\")) - 1)\n        );\n\n        _setAdmin(_admin);\n        _setPendingImplementation(_impl);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin and implementation can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdminOrPendingImpl returns (address) {\n        return _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdminOrPendingImpl returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Returns the current pending implementation.\n     *\n     * NOTE: Only the admin can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x9e5eddc59e0b171f57125ab86bee043d9128098c3a6b9adb4f2e86333c2f6f8c`\n     */\n    function pendingImplementation() external ifAdminOrPendingImpl returns (address) {\n        return _pendingImplementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * NOTE: Only the admin can call this function.\n     */\n    function setAdmin(address _newAdmin) external ifAdmin {\n        require(_newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n        _setAdmin(_newAdmin);\n    }\n\n    /**\n     * @dev Upgrades to a new implementation contract.\n     * @param _newImplementation Address of implementation contract\n     *\n     * NOTE: Only the admin can call this function.\n     */\n    function upgradeTo(address _newImplementation) external ifAdmin {\n        _setPendingImplementation(_newImplementation);\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function acceptUpgrade() external ifAdminOrPendingImpl {\n        _acceptUpgrade();\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function acceptUpgradeAndCall(bytes calldata data) external ifAdminOrPendingImpl {\n        _acceptUpgrade();\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _implementation().delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function _acceptUpgrade() internal {\n        address _pendingImplementation = _pendingImplementation();\n        require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n        require(\n            _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n            \"Caller must be the pending implementation\"\n        );\n\n        _setImplementation(_pendingImplementation);\n        _setPendingImplementation(address(0));\n    }\n\n    /**\n     * @dev Delegates the current call to implementation.\n     * This function does not return to its internal call site, it will return directly to the\n     * external caller.\n     */\n    function _fallback() internal {\n        require(msg.sender != _admin(), \"Cannot fallback to proxy target\");\n\n        assembly {\n            // (a) get free memory pointer\n            let ptr := mload(0x40)\n\n            // (b) get address of the implementation\n            let impl := and(sload(IMPLEMENTATION_SLOT), 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // (1) copy incoming call data\n            calldatacopy(ptr, 0, calldatasize())\n\n            // (2) forward call to logic contract\n            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n\n            // (3) retrieve return data\n            returndatacopy(ptr, 0, size)\n\n            // (4) forward return data back to caller\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to implementation. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to implementation. Will run if call data\n     * is empty.\n     */\n    receive() external payable {\n        _fallback();\n    }\n}"
    },
    {
      "filename": "contracts/upgrades/GraphUpgradeable.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"./IGraphProxy.sol\";\n\n/**\n * @title Graph Upgradeable\n * @dev This contract is intended to be inherited from upgradeable contracts.\n */\ncontract GraphUpgradeable {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Check if the caller is the proxy admin.\n     */\n    modifier onlyProxyAdmin(IGraphProxy _proxy) {\n        require(msg.sender == _proxy.admin(), \"Caller must be the proxy admin\");\n        _;\n    }\n\n    /**\n     * @dev Check if the caller is the implementation.\n     */\n    modifier onlyImpl() {\n        require(msg.sender == _implementation(), \"Caller must be the implementation\");\n        _;\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Accept to be an implementation of proxy.\n     */\n    function acceptProxy(IGraphProxy _proxy) external onlyProxyAdmin(_proxy) {\n        _proxy.acceptUpgrade();\n    }\n\n    /**\n     * @dev Accept to be an implementation of proxy and then call a function from the new\n     * implementation as specified by `_data`, which should be an encoded function call. This is\n     * useful to initialize new storage variables in the proxied contract.\n     */\n    function acceptProxyAndCall(IGraphProxy _proxy, bytes calldata _data)\n        external\n        onlyProxyAdmin(_proxy)\n    {\n        _proxy.acceptUpgradeAndCall(_data);\n    }\n}"
    }
  ]
}