{
  "Title": "[8] Incompatibility With Rebasing/Deflationary/Inflationary tokens",
  "Content": "\nPrePo protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.\n\n### Example Test\n\nDuring the lending, If the inflationary/deflationary tokens are used excepted amount will be lower than deposit.\n\n### Proof of Concept\n\nNavigate to the following contract.\n\nhttps://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L215<br>\n\n\n### Recommended Mitigation Steps\n\n*   Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation\n*   Add support in contracts for such tokens before accepting user-supplied tokens\n*   Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-illuminate",
  "Code": [
    {
      "filename": "lender/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol'; // library of market place specific constructs\nimport './Swivel.sol'; // library of swivel specific constructs\nimport './Element.sol'; // library of element specific constructs\nimport './Safe.sol';\nimport './Cast.sol';\n\n/// @title Lender.sol\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users. \n/// @notice The contract holds the principal tokens for each market and mints an ERC-5095 position to users to represent their lent positions.\ncontract Lender {\n    error Unauthorized();\n    error NotEqual(string);\n    error Exists(address);\n    error Invalid(string);\n\n    /// @notice minimum amount of time the admin must wait before executing a withdrawl\n    uint256 constant public HOLD = 3 days;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace.sol contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal may be used by a lender\n    mapping(uint8 => bool) public paused;\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping (address => uint256) public withdrawals;\n\n    /// @notice emitted upon executed lend\n    event Lend(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 returned);\n    /// @notice emitted upon minted ERC5095 to user\n    event Mint(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n    /// @notice emitted on token withdrawal scheduling\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted on token withdrawal blocking\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted on a change to the feenominators array\n\n    /// @notice initializes the Lender contract\n    /// @param s the swivel contract\n    /// @param p the pendle contract\n    /// @param t the tempus contract\n    constructor(\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u underlying token's address, used to define the market being approved\n    /// @param m maturity of the underlying token, used to define the market being approved\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful, false otherwise\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // max is the maximum integer value for a 256 unsighed integer\n        uint256 max = 2**256 - 1;\n\n        // approve the underlying for max per given principal\n        for (uint8 i; i < 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).markets(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses. \n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a) external authorized(admin) returns (bool) {\n        uint256 len = u.length;\n        if (len != a.length) {\n            revert NotEqual('array length');\n        }\n        uint256 max = 2**256 - 1;\n\n        for (uint256 i; i < len; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        feenominator = f;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists(marketPlace);\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on illuminate\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful, false otherwise\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public returns (bool) {\n        //use market interface to fetch the market for the given market pair\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        //use safe transfer lib and ERC interface...\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n        //use ERC5095 interface...\n        IERC5095(principalToken(u, m)).mint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method signature for both illuminate and yield\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y yieldspace pool that will execute the swap for the principal token\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y\n    ) public unpaused(p) returns (uint256) {\n        // check the principal is illuminate or yield\n        if (p != uint8(MarketPlace.Principals.Illuminate) && p != uint8(MarketPlace.Principals.Yield)) {\n            revert Invalid('principal');\n        }\n\n        // uses yield token interface...\n        IYield pool = IYield(y);\n\n        // the yield token must match the market pair\n        if (address(pool.base()) != u) {\n            revert NotEqual('underlying');\n        } else if (pool.maturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // transfer from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Purchase yield PTs to lender.sol (address(this))\n            uint256 returned = yield(u, y, a - calculateFee(a), address(this));\n            // Mint and distribute equivalent illuminate PTs\n            IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n            \n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n        else {\n            // Purchase illuminate PTs directly to msg.sender\n            uint256 returned = yield(u, y, a - calculateFee(a), msg.sender);\n\n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n    }\n\n    /// @notice lend method signature for swivel\n    /// @dev lends to yield pool. remaining balance is sent to the yield pool\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y yield pool\n    /// @param o array of swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        {\n            // returned represents the number of underlying tokens to lend to yield\n            uint256 returned;\n\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity > m) {\n                    revert NotEqual('maturity');\n                }\n\n                {\n                    uint256 amount = a[i];\n                    // Determine the fee\n                    uint256 fee = calculateFee(amount);\n                    // Track accumulated fees\n                    totalFee += fee;\n                    // Amount lent for this order\n                    uint256 amountLent = amount - fee;\n                    // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees\n                    lent += amountLent;\n                    // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)\n                    returned += amountLent * order.premium / order.principal;\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n      \n            // Track accumulated fee\n            fees[u] += totalFee;\n\n            // transfer underlying tokens from user to illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n            // fill the orders on swivel protocol\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            yield(u, y, returned, address(this));\n        }\n        emit Lend(p, u, m, lent);\n        return lent;\n    }\n\n    /// @notice lend method signature for element\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed deadline is a timestamp by which the swap must be executed\n    /// @param e element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) public unpaused(p) returns (uint256) {\n        // Get the principal token for this market for element\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // the element token must match the market pair\n        if (IElementToken(principal).underlying() != u) {\n            revert NotEqual('underlying');\n        } else if (IElementToken(principal).unlockTimestamp() > m) {\n            revert NotEqual('maturity');\n        }\n        // Transfer underlying token from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] += calculateFee(a);\n\n        uint256 purchased;\n        {\n            // Create the variables needed to execute an element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000',\n                poolId: i,\n                amount: a - calculateFee(a),\n                kind: Element.SwapKind.In,\n                assetIn: Any(u),\n                assetOut: Any(principal)\n            });\n\n            // Conduct the swap on element\n            purchased = IElement(e).swap(swap, fund, r, d);\n        }\n\n        emit Lend(p, u, m, purchased);\n        return purchased;\n    }\n\n    /// @notice lend method signature for pendle\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return, this puts a cap on allowed slippage\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) public unpaused(p) returns (uint256) {\n\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        IPendleToken token = IPendleToken(principal);\n\n        // confirm that we are in the correct market\n        if (token.yieldToken() != u) {\n            revert NotEqual('underlying');\n        } else if (token.expiry() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = calculateFee(a);\n            fees[u] += fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0];\n\n        }\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for tempus\n    /// @dev This method can be called before maturity to lend to Tempus while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param t tempus pool that houses the underlying principal tokens\n    /// @param x tempus amm that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address t,\n        address x\n    ) public unpaused(p) returns (uint256) {\n        {\n            // Instantiate market and tokens\n            address principal = IMarketPlace(marketPlace).markets(u, m, p);\n            if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u)) {\n                revert NotEqual('underlying');\n            } else if (ITempus(principal).maturityTime() > m) {\n                revert NotEqual('maturity');\n            }\n\n            // Get the underlying token\n            IERC20 underlyingToken = IERC20(u);\n\n            // Transfer funds from user to Illuminate, Scope to avoid stack limit\n            Safe.transferFrom(underlyingToken, msg.sender, address(this), a);\n        }\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Tempus Router using the provided market and params\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n        uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -\n            illuminateToken.balanceOf(address(this));\n\n        // Mint Illuminate zero coupons\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice lend method signature for sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r minimum number of tokens to lend (sets a limit on the order)\n    /// @param x amm that is used to conduct the swap\n    /// @param s contract that holds the principal token for this market\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        address s\n    ) public unpaused(p) returns (uint256) {\n\n        // Get the principal token for this market for this market\n        ISenseToken token = ISenseToken(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Verify that the underlying and maturity match up\n        if (token.underlying() != u) { // gauruntee the input token is the right token\n            revert NotEqual('underlying'); \n        } else if (ISense(s).pt() != address(token)) {\n            revert NotEqual('principal token'); \n        } else if (ISense(x).maturity() > m) { // gauruntee the input amm has the correct maturity\n            revert NotEqual('maturity');\n        }\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine lent amount after fees\n            lent = a - fee;\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Swap those tokens for the principal tokens\n        uint256 returned = ISense(x).swapUnderlyingForPTs(s, m, lent, r);\n\n        // Get the address of the ERC5095 token for this market\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n\n        // Mint the illuminate tokens based on the returned amount\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice this method can be called before maturity to lend to APWine while minting Illuminate tokens\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the minimum amount of zero-coupon tokens to return accounting for slippage\n    /// @param pool the address of a given APWine pool\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        address pool,\n        address aave,\n        uint256 i\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        if (IAPWineToken(principal).getUnderlyingOfIBTAddress() != u) {\n            revert NotEqual('underlying');\n        }\n        // Dont necessarily need to validate APWINE maturity (They have 1 maturity per underlying)\n        // Potentially add redundant implied maturity calculation\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Determine the fee\n            uint256 fee = calculateFee(a);\n\n            // Add the accumulated fees to the total\n            fees[u] += fee;\n\n            // Determine the amount lent after fees\n            lent = a - fee;\n        }\n\n        // Deposit into aave\n        IAave(aave).deposit(u, lent, address(this), 0);\n\n        // Swap on the APWine Pool using the provided market and params\n        uint256 returned = IAPWineRouter(pool).swapExactAmountIn(i, 1, lent, 0, r, address(this));\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @dev lend method signature for Notional\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public unpaused(p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        INotional token = INotional(principal);\n\n        // Verify that the underlying and maturity match up\n        (IERC20 underlying, ) = token.getUnderlyingToken();\n        if (address(underlying) != u) {\n            revert NotEqual('underlying');\n        } else if (token.getMaturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Notional Token wrapper\n        uint256 returned = token.deposit(a - fee, address(this));\n\n        // Mint Illuminate zero coupons\n        address illuminateToken = principalToken(u, m);(u, m);\n        IERC5095(illuminateToken).mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n\n    /// @notice transfers excess funds to yield pool after principal tokens have been lent out\n    /// @dev this method is only used by the yield, illuminate and swivel protocols\n    /// @param u address of an underlying asset\n    /// @param y the yield pool to lend to\n    /// @param a the amount of underlying tokens to lend\n    /// @param r the receiving address for PTs\n    /// @return uint256 the amount of tokens sent to the yield pool\n    function yield(\n        address u,\n        address y,\n        uint256 a,\n        address r\n    ) internal returns (uint256) {\n        // preview exact swap slippage on yield\n        uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));\n\n        // send the remaing amount to the given yield pool\n        Safe.transfer(IERC20(u), y, a);\n\n        // lend out the remaining tokens in the yield pool\n        IYield(y).sellBase(r, returned);\n\n        return returned;\n    }\n\n    /// @notice withdraws accumulated lending fees of the underlying token\n    /// @param e address of the underlying token to withdraw\n    /// @return bool true if successful\n    function withdrawFee(address e) external authorized(admin) returns (bool) {\n        // Get the token to be withdrawn\n        IERC20 token = IERC20(e);\n\n        // Get the balance to be transferred\n        uint256 balance = fees[e];\n\n        // Reset accumulated fees of the token to 0\n        fees[e] = 0;\n\n        // Transfer the accumulated fees to the admin\n        Safe.transfer(token, admin, balance);\n        return true;\n    }\n\n    /// @notice this method returns the fee based on the amount passed to it. If the feenominator is 0, then there is no fee.\n    /// @param a amount of underlying tokens to calculate the fee for\n    /// @return uint256 The total for for the given amount\n    function calculateFee(uint256 a) internal view returns (uint256) {\n        return feenominator > 0 ? a / feenominator : 0;\n    }\n\n    /// @notice allows the admin to schedule the withdrawal of tokens\n    /// @param e address of (erc20) token to withdraw\n    /// @return bool true if successful\n    function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n        uint256 when = block.timestamp + HOLD;\n        withdrawals[e] = when;\n\n        emit ScheduleWithdrawal(e, when);\n        return true;\n    }\n\n    /// @notice emergency function to block unplanned withdrawals\n    /// @param e address of token withdrawal to block\n    /// @return bool true if successful\n    function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n        withdrawals[e] = 0;\n\n        emit BlockWithdrawal(e);\n        return true;\n    }\n\n    /// @notice allows the admin to withdraw the given token, provided the holding period has been observed\n    /// @param e Address of token to withdraw\n    /// @return bool true if successful\n    function withdraw(address e) external authorized(admin) returns (bool) {\n        uint256 when = withdrawals[e];\n        require (when != 0, 'no withdrawal scheduled');\n  \n        require (block.timestamp >= when, 'withdrawal still on hold');\n  \n        withdrawals[e] = 0;\n  \n        IERC20 token = IERC20(e);\n        Safe.transfer(token, admin, token.balanceOf(address(this)));\n  \n        return true;\n    }\n\n    /// @notice retrieves the ERC5095 token for the given market\n    /// @param u address of the underlying\n    /// @param m uint256 representing the maturity of the market\n    /// @return address of the ERC5095 token for the market\n    function principalToken(address u, uint256 m) internal returns (address) {\n        return IMarketPlace(marketPlace).markets(u, m, 0);\n    }\n\n    /// @notice pauses a market and prevents execution of all lending for that market\n    /// @param p principal enum value\n    /// @param b bool representing whether to pause or unpause\n    /// @return bool true if successful\n    function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n        paused[p] = b;\n        return true;\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param p principal enum value\n    modifier unpaused(uint8 p) {\n        if (paused[p]) {\n            revert Invalid('paused');\n        }\n        _;\n    }\n}"
    }
  ]
}