{
  "Title": "[L07] The minimum gas price calculation differs from documentation",
  "Content": "The [documentation](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/docs/celo-codebase/protocol/transactions/gas-pricing.md) defines the gas price minimum as `gas_price_minimum' = gas_price_minimum * (1 + ((total_gas_used / block_gas_limit) âˆ’ target_density) * adjustment_speed)`.\n\n\nHowever, in [the code](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/GasPriceMinimum.sol#L117-L150) the gas price minimum is defined as `oldGasPriceMinimum * (1 + (adjustmentSpeed * (blockDensity - targetDensity))) + 1`.\n\n\nIt is not clear what the last unit added is nor why it is being used.\n\n\nConsider keeping your documentation updated to your current codebase and clearly stating how the gas price minimum is defined. For instance, consider adding the `+1` that exists in the code to the documentation version. Having accurate documentation will improve developer experience and project auditability.\n\n\n***Update:** Fixed in [pull request #2889](https://github.com/celo-org/celo-monorepo/pull/2889). The documentation has been updated.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/GasPriceMinimum.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./Initializable.sol\";\nimport \"./UsingRegistry.sol\";\nimport \"./FixidityLib.sol\";\nimport \"../stability/interfaces/ISortedOracles.sol\";\n\n/**\n * @title Stores and provides gas price minimum for various currencies.\n */\ncontract GasPriceMinimum is Ownable, Initializable, UsingRegistry {\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  event TargetDensitySet(uint256 targetDensity);\n  event GasPriceMinimumFloorSet(uint256 gasPriceMinimumFloor);\n  event AdjustmentSpeedSet(uint256 adjustmentSpeed);\n\n  uint256 public gasPriceMinimum;\n  uint256 public gasPriceMinimumFloor;\n\n  // Block congestion level targeted by the gas price minimum calculation.\n  FixidityLib.Fraction public targetDensity;\n\n  // Speed of gas price minimum adjustment due to congestion.\n  FixidityLib.Fraction public adjustmentSpeed;\n\n  modifier onlyVm() {\n    assert(msg.sender == address(0x0));\n    _;\n  }\n\n  function initialize(\n    address _registryAddress,\n    uint256 _gasPriceMinimumFloor,\n    uint256 _targetDensity,\n    uint256 _adjustmentSpeed\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(_registryAddress);\n    gasPriceMinimum = _gasPriceMinimumFloor;\n    setGasPriceMinimumFloor(_gasPriceMinimumFloor);\n    setTargetDensity(_targetDensity);\n    setAdjustmentSpeed(_adjustmentSpeed);\n  }\n\n  /**\n   * @notice Set a multiplier that impacts how quickly gas price minimum is adjusted.\n   * @dev Value is expected to be < 1.\n   */\n  function setAdjustmentSpeed(uint256 _adjustmentSpeed) public onlyOwner {\n    adjustmentSpeed = FixidityLib.wrap(_adjustmentSpeed);\n    require(adjustmentSpeed.lt(FixidityLib.fixed1()), \"adjustment speed must be smaller than 1\");\n    emit AdjustmentSpeedSet(_adjustmentSpeed);\n  }\n\n  /**\n   * @notice Set the block density targeted by the gas price minimum algorithm.\n   * @dev Value is expected to be < 1.\n   */\n  function setTargetDensity(uint256 _targetDensity) public onlyOwner {\n    targetDensity = FixidityLib.wrap(_targetDensity);\n    require(targetDensity.lt(FixidityLib.fixed1()), \"target density must be smaller than 1\");\n    emit TargetDensitySet(_targetDensity);\n  }\n\n  /**\n   * @notice Set the minimum gas price treshold.\n   * @dev Value is expected to be > 0.\n   */\n  function setGasPriceMinimumFloor(uint256 _gasPriceMinimumFloor) public onlyOwner {\n    require(_gasPriceMinimumFloor > 0, \"gas price minimum floor must be greater than zero\");\n    gasPriceMinimumFloor = _gasPriceMinimumFloor;\n    emit GasPriceMinimumFloorSet(_gasPriceMinimumFloor);\n  }\n\n  /**\n   * @notice Retrieve the current gas price minimum for a currency.\n   * @param tokenAddress The currency the gas price should be in (defaults to gold).\n   * @return current gas price minimum in the requested currency\n   */\n  function getGasPriceMinimum(address tokenAddress) external view returns (uint256) {\n    if (\n      tokenAddress == address(0) ||\n      tokenAddress == registry.getAddressForOrDie(GOLD_TOKEN_REGISTRY_ID)\n    ) {\n      return gasPriceMinimum;\n    } else {\n      ISortedOracles sortedOracles = ISortedOracles(\n        registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID)\n      );\n      uint256 rateNumerator;\n      uint256 rateDenominator;\n      (rateNumerator, rateDenominator) = sortedOracles.medianRate(tokenAddress);\n      return (gasPriceMinimum.mul(rateNumerator).div(rateDenominator));\n    }\n  }\n\n  /**\n   * @notice Adjust the gas price minimum based on governable parameters\n   * and block congestion.\n   * @param blockGasTotal The amount of gas in the most recent block.\n   * @param blockGasLimit The maxBlockGasLimit of the past block.\n   * @return result of the calculation (new gas price minimum)\n   */\n  function updateGasPriceMinimum(uint256 blockGasTotal, uint256 blockGasLimit)\n    external\n    onlyVm\n    returns (uint256)\n  {\n    gasPriceMinimum = getUpdatedGasPriceMinimum(blockGasTotal, blockGasLimit);\n    return gasPriceMinimum;\n  }\n\n  /**\n   * @notice Calculates the gas price minimum based on governable parameters\n   * and block congestion.\n   * @param blockGasTotal The amount of gas in the most recent block.\n   * @param blockGasLimit The maxBlockGasLimit of the past block.\n   * @return result of the calculation (new gas price minimum)\n   * @dev Calculate using the following formula:\n   * oldGasPriceMinimum * (1 + (adjustmentSpeed * (blockDensity - targetDensity))) + 1.\n   */\n  function getUpdatedGasPriceMinimum(uint256 blockGasTotal, uint256 blockGasLimit)\n    public\n    view\n    returns (uint256)\n  {\n    FixidityLib.Fraction memory blockDensity = FixidityLib.newFixedFraction(\n      blockGasTotal,\n      blockGasLimit\n    );\n    bool densityGreaterThanTarget = blockDensity.gt(targetDensity);\n    FixidityLib.Fraction memory densityDelta = densityGreaterThanTarget\n      ? blockDensity.subtract(targetDensity)\n      : targetDensity.subtract(blockDensity);\n    FixidityLib.Fraction memory adjustment = densityGreaterThanTarget\n      ? FixidityLib.fixed1().add(adjustmentSpeed.multiply(densityDelta))\n      : FixidityLib.fixed1().subtract(adjustmentSpeed.multiply(densityDelta));\n\n    uint256 newGasPriceMinimum = adjustment\n      .multiply(FixidityLib.newFixed(gasPriceMinimum))\n      .add(FixidityLib.fixed1())\n      .fromFixed();\n\n    return newGasPriceMinimum >= gasPriceMinimumFloor ? newGasPriceMinimum : gasPriceMinimumFloor;\n  }\n}"
    }
  ]
}