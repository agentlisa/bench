{
  "Title": "Stream sender is unable to cancel a stream with a pausable asset that is paused",
  "Content": "# Stream sender is unable to cancel a stream with a pausable asset that is paused\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/main/v2-core/src/abstracts/SablierV2Lockup.sol#L599\">https://github.com/Cyfrin/2024-05-Sablier/blob/main/v2-core/src/abstracts/SablierV2Lockup.sol#L599</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/tethercoin/USDT/blob/main/TetherToken.sol#L340\">https://github.com/tethercoin/USDT/blob/main/TetherToken.sol#L340</a>\n\n\n## Summary\n\nWhen the stream sender cancels a stream, we call the asset transfer method to reimburse the amount that is yet to be streamed to the sender. If this call reverts, then the call to cancel the stream reverts as well.\n\n## Vulnerability Details\n\nThere exists ERC20 tokens that are pausable.\nFor example [USDT on ethereum](https://github.com/tethercoin/USDT/blob/main/TetherToken.sol#L340) ( verifiable on etherscan )\nIf for whatever reason the stream asset is paused, then the stream Sender is unable to cancel the stream until the asset is unpaused.\n\n### POC\n\n<details>\n\t<summary>\n\t\tReplace the content of `v2-core/test/mocks/erc20/ERC20Mock.sol` with the below code block\n\t</summary>\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.22;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"forge-std/src/console.sol\";\n\ncontract ERC20Mock is ERC20, ERC20Pausable {\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) { }\n\n    function pause() public {\n        _pause();\n        console.log(\"Contract paused\");\n    }\n\n    function transfer(address to, uint256 value) override public whenNotPaused returns (bool) {\n       return super.transfer(to, value) ;\n    }\n\n    function _update(address from, address to, uint256 value)\n        internal\n        override(ERC20, ERC20Pausable)\n    {\n\n        super._update(from, to, value);\n    }\n}\n```\n</details>\n\n<details>\n\t<summary>\n\t\t Add the below codeblock in `v2-core/test/integration/concrete/lockup/cancel/cancel.t.sol` Notice the importation of the ERC20Mock file.\n\t</summary>\n\n```solidity\n\timport { ERC20Mock } from \"../../../../../test/mocks/erc20/ERC20Mock.sol\";\n\n    function test_CancelAssetPaused()\n        external\n        whenNotDelegateCalled\n        givenNotNull\n        givenStreamWarm\n        whenCallerAuthorized\n        givenStreamCancelable\n        givenStatusStreaming\n        givenRecipientContract\n        givenRecipientImplementsHook\n        whenRecipientDoesNotRevert\n        whenNoRecipientReentrancy\n    {\n        // Create the stream.\n        uint256 streamId = createDefaultStreamWithRecipient(address(goodRecipient));\n\n        // Pause the stream Asset\n        ERC20Mock(address(lockup.getAsset(defaultStreamId))).pause();\n\n        // Cancel the stream.\n        vm.expectRevert();\n        lockup.cancel(streamId);\n\n        // Assert that the stream's status is still \"STREAMING\".\n        Lockup.Status actualStatus = lockup.statusOf(streamId);\n        Lockup.Status expectedStatus = Lockup.Status.STREAMING;\n        assertEq(actualStatus, expectedStatus);\n\n        // Assert that the stream is still cancelable.\n        bool isCancelable = lockup.isCancelable(streamId);\n        assertTrue(isCancelable, \"isCancelable\");\n\n        // Assert that the refunded amount has not been updated.\n        uint128 actualRefundedAmount = lockup.getRefundedAmount(streamId);\n        uint128 expectedRefundedAmount = 0;\n        assertEq(actualRefundedAmount, expectedRefundedAmount, \"refundedAmount\");\n    }\n```\n</details>\n\nrun the below command in the terminal\n`forge test --mt test_CancelAssetPaused -vvv`\n\n\n## Impact\n\nThe stream sender is temporarily unable to cancel the stream which leads to a loss of funds as the stream will continue streaming the assets to the Stream Receiver. The impact of the loss of funds depends on how long the asset has been paused for, relative to how fast the asset is being streamed. For the sake of an example, imagine the asset is paused just as the stream is about to get past the Stream's cliff period and the sender wishes to cancel the stream.\n\nlikelihood: medium as assets are paused only under cases of force majeure but taking into account that Sablier supports all ERC20 assets on all EVM compatible chains, the probability of a pausing on an asset happening is not low.\n\nimpact: high as all cancelable asset streams effectively become uncancelable while the asset is paused. Knowing USDT's stature as one of the well respected and transacted stablecoins, this will translate to a lot of streams(without taking into account the other pausable assets on all the evm compatible chains where Sablier is/would be deployed).\n\n## Tools Used\n\nFuzzing with foundry\n\n## Recommendations\n\nSimilar to how when the Stream is canceled the Stream Receiver is expected to withdraw the streamed assets by himself in a call seperate to the call to cancel the stream, we should seperate the transfer of the Senders funds from the cancel funtion into a seperate function\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clvb9njmy00012dqjyaavpl44",
  "Code": [
    {
      "filename": "v2-core/src/abstracts/SablierV2Lockup.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.22;\n\nimport { IERC4906 } from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport { UD60x18 } from \"@prb/math/src/UD60x18.sol\";\n\nimport { ISablierV2Recipient } from \"../interfaces/hooks/ISablierV2Recipient.sol\";\nimport { ISablierV2Sender } from \"../interfaces/hooks/ISablierV2Sender.sol\";\nimport { ISablierV2Lockup } from \"../interfaces/ISablierV2Lockup.sol\";\nimport { ISablierV2NFTDescriptor } from \"../interfaces/ISablierV2NFTDescriptor.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { Lockup } from \"../types/DataTypes.sol\";\nimport { Adminable } from \"./Adminable.sol\";\nimport { NoDelegateCall } from \"./NoDelegateCall.sol\";\n\n/// @title SablierV2Lockup\n/// @notice See the documentation in {ISablierV2Lockup}.\nabstract contract SablierV2Lockup is\n    NoDelegateCall, // 0 inherited components\n    Adminable, // 1 inherited components\n    IERC4906, // 2 inherited components\n    ISablierV2Lockup, // 4 inherited components\n    ERC721 // 6 inherited components\n{\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  STATE VARIABLES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    UD60x18 public constant override MAX_BROKER_FEE = UD60x18.wrap(0.1e18);\n\n    /// @inheritdoc ISablierV2Lockup\n    uint256 public override nextStreamId;\n\n    /// @inheritdoc ISablierV2Lockup\n    ISablierV2NFTDescriptor public override nftDescriptor;\n\n    /// @dev Sablier V2 Lockup streams mapped by unsigned integers.\n    mapping(uint256 id => Lockup.Stream stream) internal _streams;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Emits a {TransferAdmin} event.\n    /// @param initialAdmin The address of the initial contract admin.\n    /// @param initialNFTDescriptor The address of the initial NFT descriptor.\n    constructor(address initialAdmin, ISablierV2NFTDescriptor initialNFTDescriptor) {\n        admin = initialAdmin;\n        nftDescriptor = initialNFTDescriptor;\n        emit TransferAdmin({ oldAdmin: address(0), newAdmin: initialAdmin });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      MODIFIERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks that `streamId` does not reference a null stream.\n    modifier notNull(uint256 streamId) {\n        if (!_streams[streamId].isStream) {\n            revert Errors.SablierV2Lockup_Null(streamId);\n        }\n        _;\n    }\n\n    /// @dev Emits an ERC-4906 event to trigger an update of the NFT metadata.\n    modifier updateMetadata(uint256 streamId) {\n        _;\n        emit MetadataUpdate({ _tokenId: streamId });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function getAsset(uint256 streamId) external view override notNull(streamId) returns (IERC20 asset) {\n        asset = _streams[streamId].asset;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getDepositedAmount(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 depositedAmount)\n    {\n        depositedAmount = _streams[streamId].amounts.deposited;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getEndTime(uint256 streamId) external view override notNull(streamId) returns (uint40 endTime) {\n        endTime = _streams[streamId].endTime;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getRecipient(uint256 streamId) external view override returns (address recipient) {\n        // Check the stream NFT exists and return the owner, which is the stream's recipient.\n        recipient = _requireOwned({ tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getRefundedAmount(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 refundedAmount)\n    {\n        refundedAmount = _streams[streamId].amounts.refunded;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getSender(uint256 streamId) external view override notNull(streamId) returns (address sender) {\n        sender = _streams[streamId].sender;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getStartTime(uint256 streamId) external view override notNull(streamId) returns (uint40 startTime) {\n        startTime = _streams[streamId].startTime;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function getWithdrawnAmount(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 withdrawnAmount)\n    {\n        withdrawnAmount = _streams[streamId].amounts.withdrawn;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isCancelable(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        if (_statusOf(streamId) != Lockup.Status.SETTLED) {\n            result = _streams[streamId].isCancelable;\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isCold(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.SETTLED || status == Lockup.Status.CANCELED || status == Lockup.Status.DEPLETED;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isDepleted(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        result = _streams[streamId].isDepleted;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isStream(uint256 streamId) external view override returns (bool result) {\n        result = _streams[streamId].isStream;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isTransferable(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        result = _streams[streamId].isTransferable;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isWarm(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.PENDING || status == Lockup.Status.STREAMING;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function refundableAmountOf(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 refundableAmount)\n    {\n        // These checks are needed because {_calculateStreamedAmount} does not look up the stream's status. Note that\n        // checking for `isCancelable` also checks if the stream `wasCanceled` thanks to the protocol invariant that\n        // canceled streams are not cancelable anymore.\n        if (_streams[streamId].isCancelable && !_streams[streamId].isDepleted) {\n            refundableAmount = _streams[streamId].amounts.deposited - _calculateStreamedAmount(streamId);\n        }\n        // Otherwise, the result is implicitly zero.\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function statusOf(uint256 streamId) external view override notNull(streamId) returns (Lockup.Status status) {\n        status = _statusOf(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function streamedAmountOf(uint256 streamId)\n        public\n        view\n        override\n        notNull(streamId)\n        returns (uint128 streamedAmount)\n    {\n        streamedAmount = _streamedAmountOf(streamId);\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256 streamId) public view override(IERC721Metadata, ERC721) returns (string memory uri) {\n        // Check: the stream NFT exists.\n        _requireOwned({ tokenId: streamId });\n\n        // Generate the URI describing the stream NFT.\n        uri = nftDescriptor.tokenURI({ sablier: this, streamId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function wasCanceled(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        result = _streams[streamId].wasCanceled;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawableAmountOf(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 withdrawableAmount)\n    {\n        withdrawableAmount = _withdrawableAmountOf(streamId);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function burn(uint256 streamId) external override noDelegateCall notNull(streamId) {\n        // Check: only depleted streams can be burned.\n        if (!_streams[streamId].isDepleted) {\n            revert Errors.SablierV2Lockup_StreamNotDepleted(streamId);\n        }\n\n        // Check:\n        // 1. NFT exists (see {IERC721.getApproved}).\n        // 2. `msg.sender` is either the owner of the NFT or an approved third party.\n        if (!_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Effect: burn the NFT.\n        _burn({ tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancel(uint256 streamId) public override noDelegateCall notNull(streamId) {\n        // Check: the stream is neither depleted nor canceled.\n        if (_streams[streamId].isDepleted) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (_streams[streamId].wasCanceled) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        }\n\n        // Check: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks, Effects and Interactions: cancel the stream.\n        _cancel(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancelMultiple(uint256[] calldata streamIds) external override noDelegateCall {\n        // Iterate over the provided array of stream IDs and cancel each stream.\n        uint256 count = streamIds.length;\n        for (uint256 i = 0; i < count; ++i) {\n            // Effects and Interactions: cancel the stream.\n            cancel(streamIds[i]);\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function renounce(uint256 streamId) external override noDelegateCall notNull(streamId) updateMetadata(streamId) {\n        // Check: the stream is not cold.\n        Lockup.Status status = _statusOf(streamId);\n        if (status == Lockup.Status.DEPLETED) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (status == Lockup.Status.CANCELED) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        } else if (status == Lockup.Status.SETTLED) {\n            revert Errors.SablierV2Lockup_StreamSettled(streamId);\n        }\n\n        // Check: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks and Effects: renounce the stream.\n        _renounce(streamId);\n\n        // Log the renouncement.\n        emit ISablierV2Lockup.RenounceLockupStream(streamId);\n\n        // Interaction: if the recipient is a contract, try to invoke the renounce hook on the recipient without\n        // reverting if the hook is not implemented, and also without bubbling up any potential revert.\n        address recipient = _ownerOf(streamId);\n        if (recipient.code.length > 0) {\n            try ISablierV2Recipient(recipient).onLockupStreamRenounced(streamId) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function setNFTDescriptor(ISablierV2NFTDescriptor newNFTDescriptor) external override onlyAdmin {\n        // Effect: set the NFT descriptor.\n        ISablierV2NFTDescriptor oldNftDescriptor = nftDescriptor;\n        nftDescriptor = newNFTDescriptor;\n\n        // Log the change of the NFT descriptor.\n        emit ISablierV2Lockup.SetNFTDescriptor({\n            admin: msg.sender,\n            oldNFTDescriptor: oldNftDescriptor,\n            newNFTDescriptor: newNFTDescriptor\n        });\n\n        // Refresh the NFT metadata for all streams.\n        emit BatchMetadataUpdate({ _fromTokenId: 1, _toTokenId: nextStreamId - 1 });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdraw(\n        uint256 streamId,\n        address to,\n        uint128 amount\n    )\n        public\n        override\n        noDelegateCall\n        notNull(streamId)\n        updateMetadata(streamId)\n    {\n        // Check: the stream is not depleted.\n        if (_streams[streamId].isDepleted) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        }\n\n        // Check: the withdrawal address is not zero.\n        if (to == address(0)) {\n            revert Errors.SablierV2Lockup_WithdrawToZeroAddress(streamId);\n        }\n\n        // Check: the withdraw amount is not zero.\n        if (amount == 0) {\n            revert Errors.SablierV2Lockup_WithdrawAmountZero(streamId);\n        }\n\n        // Retrieve the recipient from storage.\n        address recipient = _ownerOf(streamId);\n\n        // Check: if `msg.sender` is neither the stream's recipient nor an approved third party, the withdrawal address\n        // must be the recipient.\n        if (to != recipient && !_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_WithdrawalAddressNotRecipient(streamId, msg.sender, to);\n        }\n\n        // Check: the withdraw amount is not greater than the withdrawable amount.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (amount > withdrawableAmount) {\n            revert Errors.SablierV2Lockup_Overdraw(streamId, amount, withdrawableAmount);\n        }\n\n        // Retrieve the sender from storage.\n        address sender = _streams[streamId].sender;\n\n        // Effects and Interactions: make the withdrawal.\n        _withdraw(streamId, to, amount);\n\n        // Interaction: if `msg.sender` is not the recipient and the recipient is a contract, try to invoke the\n        // withdraw hook on it without reverting if the hook is not implemented, and also without bubbling up\n        // any potential revert.\n        if (msg.sender != recipient && recipient.code.length > 0) {\n            try ISablierV2Recipient(recipient).onLockupStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n\n        // Interaction: if `msg.sender` is not the sender, the sender is a contract and is different from the\n        // recipient, try to invoke the withdraw hook on it without reverting if the hook is not implemented, and also\n        // without bubbling up any potential revert.\n        if (msg.sender != sender && sender.code.length > 0 && sender != recipient) {\n            try ISablierV2Sender(sender).onLockupStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMax(uint256 streamId, address to) external override {\n        withdraw({ streamId: streamId, to: to, amount: _withdrawableAmountOf(streamId) });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMaxAndTransfer(\n        uint256 streamId,\n        address newRecipient\n    )\n        external\n        override\n        noDelegateCall\n        notNull(streamId)\n    {\n        // Check: the caller is the current recipient. This also checks that the NFT was not burned.\n        address currentRecipient = _ownerOf(streamId);\n        if (msg.sender != currentRecipient) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Skip the withdrawal if the withdrawable amount is zero.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (withdrawableAmount > 0) {\n            withdraw({ streamId: streamId, to: currentRecipient, amount: withdrawableAmount });\n        }\n\n        // Checks and Effects: transfer the NFT.\n        _transfer({ from: currentRecipient, to: newRecipient, tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMultiple(\n        uint256[] calldata streamIds,\n        uint128[] calldata amounts\n    )\n        external\n        override\n        noDelegateCall\n    {\n        // Check: there is an equal number of `streamIds` and `amounts`.\n        uint256 streamIdsCount = streamIds.length;\n        uint256 amountsCount = amounts.length;\n        if (streamIdsCount != amountsCount) {\n            revert Errors.SablierV2Lockup_WithdrawArrayCountsNotEqual(streamIdsCount, amountsCount);\n        }\n\n        // Iterate over the provided array of stream IDs, and withdraw from each stream to the recipient.\n        for (uint256 i = 0; i < streamIdsCount; ++i) {\n            // Checks, Effects and Interactions: check the parameters and make the withdrawal.\n            withdraw({ streamId: streamIds[i], to: _ownerOf(streamIds[i]), amount: amounts[i] });\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                             INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculates the streamed amount of the stream without looking up the stream's status.\n    /// @dev This function is implemented by child contracts, so the logic varies depending on the model.\n    function _calculateStreamedAmount(uint256 streamId) internal view virtual returns (uint128);\n\n    /// @notice Checks whether `msg.sender` is the stream's recipient or an approved third party.\n    /// @param streamId The stream ID for the query.\n    function _isCallerStreamRecipientOrApproved(uint256 streamId) internal view returns (bool) {\n        address recipient = _ownerOf(streamId);\n        return msg.sender == recipient || isApprovedForAll({ owner: recipient, operator: msg.sender })\n            || getApproved(streamId) == msg.sender;\n    }\n\n    /// @notice Checks whether `msg.sender` is the stream's sender.\n    /// @param streamId The stream ID for the query.\n    function _isCallerStreamSender(uint256 streamId) internal view returns (bool) {\n        return msg.sender == _streams[streamId].sender;\n    }\n\n    /// @dev Retrieves the stream's status without performing a null check.\n    function _statusOf(uint256 streamId) internal view returns (Lockup.Status) {\n        if (_streams[streamId].isDepleted) {\n            return Lockup.Status.DEPLETED;\n        } else if (_streams[streamId].wasCanceled) {\n            return Lockup.Status.CANCELED;\n        }\n\n        if (block.timestamp < _streams[streamId].startTime) {\n            return Lockup.Status.PENDING;\n        }\n\n        if (_calculateStreamedAmount(streamId) < _streams[streamId].amounts.deposited) {\n            return Lockup.Status.STREAMING;\n        } else {\n            return Lockup.Status.SETTLED;\n        }\n    }\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _streamedAmountOf(uint256 streamId) internal view returns (uint128) {\n        Lockup.Amounts memory amounts = _streams[streamId].amounts;\n\n        if (_streams[streamId].isDepleted) {\n            return amounts.withdrawn;\n        } else if (_streams[streamId].wasCanceled) {\n            return amounts.deposited - amounts.refunded;\n        }\n\n        return _calculateStreamedAmount(streamId);\n    }\n\n    /// @notice Overrides the {ERC-721._update} function to check that the stream is transferable, and emits an\n    /// ERC-4906 event.\n    /// @dev There are two cases when the transferable flag is ignored:\n    /// - If the current owner is 0, then the update is a mint and is allowed.\n    /// - If `to` is 0, then the update is a burn and is also allowed.\n    /// @param to The address of the new recipient of the stream.\n    /// @param streamId ID of the stream to update.\n    /// @param auth Optional parameter. If the value is not zero, the overridden implementation will check that\n    /// `auth` is either the recipient of the stream, or an approved third party.\n    /// @return The original recipient of the `streamId` before the update.\n    function _update(\n        address to,\n        uint256 streamId,\n        address auth\n    )\n        internal\n        override\n        updateMetadata(streamId)\n        returns (address)\n    {\n        address from = _ownerOf(streamId);\n\n        if (from != address(0) && to != address(0) && !_streams[streamId].isTransferable) {\n            revert Errors.SablierV2Lockup_NotTransferable(streamId);\n        }\n\n        return super._update(to, streamId, auth);\n    }\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _withdrawableAmountOf(uint256 streamId) internal view returns (uint128) {\n        return _streamedAmountOf(streamId) - _streams[streamId].amounts.withdrawn;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           INTERNAL NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _cancel(uint256 streamId) internal {\n        // Calculate the streamed amount.\n        uint128 streamedAmount = _calculateStreamedAmount(streamId);\n\n        // Retrieve the amounts from storage.\n        Lockup.Amounts memory amounts = _streams[streamId].amounts;\n\n        // Check: the stream is not settled.\n        if (streamedAmount >= amounts.deposited) {\n            revert Errors.SablierV2Lockup_StreamSettled(streamId);\n        }\n\n        // Check: the stream is cancelable.\n        if (!_streams[streamId].isCancelable) {\n            revert Errors.SablierV2Lockup_StreamNotCancelable(streamId);\n        }\n\n        // Calculate the sender's amount.\n        uint128 senderAmount;\n        unchecked {\n            senderAmount = amounts.deposited - streamedAmount;\n        }\n\n        // Calculate the recipient's amount.\n        uint128 recipientAmount = streamedAmount - amounts.withdrawn;\n\n        // Effect: mark the stream as canceled.\n        _streams[streamId].wasCanceled = true;\n\n        // Effect: make the stream not cancelable anymore, because a stream can only be canceled once.\n        _streams[streamId].isCancelable = false;\n\n        // Effect: if there are no assets left for the recipient to withdraw, mark the stream as depleted.\n        if (recipientAmount == 0) {\n            _streams[streamId].isDepleted = true;\n        }\n\n        // Effect: set the refunded amount.\n        _streams[streamId].amounts.refunded = senderAmount;\n\n        // Retrieve the sender and the recipient from storage.\n        address sender = _streams[streamId].sender;\n        address recipient = _ownerOf(streamId);\n\n        // Retrieve the ERC-20 asset from storage.\n        IERC20 asset = _streams[streamId].asset;\n\n        // Interaction: refund the sender.\n        asset.safeTransfer({ to: sender, value: senderAmount });\n\n        // Log the cancellation.\n        emit ISablierV2Lockup.CancelLockupStream(streamId, sender, recipient, asset, senderAmount, recipientAmount);\n\n        // Emits an ERC-4906 event to trigger an update of the NFT metadata.\n        emit MetadataUpdate({ _tokenId: streamId });\n\n        // Interaction: if the recipient is a contract, try to invoke the cancel hook on the recipient without\n        // reverting if the hook is not implemented, and without bubbling up any potential revert.\n        if (recipient.code.length > 0) {\n            try ISablierV2Recipient(recipient).onLockupStreamCanceled({\n                streamId: streamId,\n                sender: sender,\n                senderAmount: senderAmount,\n                recipientAmount: recipientAmount\n            }) { } catch { }\n        }\n    }\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _renounce(uint256 streamId) internal {\n        // Check: the stream is cancelable.\n        if (!_streams[streamId].isCancelable) {\n            revert Errors.SablierV2Lockup_StreamNotCancelable(streamId);\n        }\n\n        // Effect: renounce the stream by making it not cancelable.\n        _streams[streamId].isCancelable = false;\n    }\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _withdraw(uint256 streamId, address to, uint128 amount) internal {\n        // Effect: update the withdrawn amount.\n        _streams[streamId].amounts.withdrawn = _streams[streamId].amounts.withdrawn + amount;\n\n        // Retrieve the amounts from storage.\n        Lockup.Amounts memory amounts = _streams[streamId].amounts;\n\n        // Using \">=\" instead of \"==\" for additional safety reasons. In the event of an unforeseen increase in the\n        // withdrawn amount, the stream will still be marked as depleted.\n        if (amounts.withdrawn >= amounts.deposited - amounts.refunded) {\n            // Effect: mark the stream as depleted.\n            _streams[streamId].isDepleted = true;\n\n            // Effect: make the stream not cancelable anymore, because a depleted stream cannot be canceled.\n            _streams[streamId].isCancelable = false;\n        }\n\n        // Retrieve the ERC-20 asset from storage.\n        IERC20 asset = _streams[streamId].asset;\n\n        // Interaction: perform the ERC-20 transfer.\n        asset.safeTransfer({ to: to, value: amount });\n\n        // Log the withdrawal.\n        emit ISablierV2Lockup.WithdrawFromLockupStream(streamId, to, asset, amount);\n    }\n}"
    },
    {
      "filename": "TetherToken.sol",
      "content": "/**\n *Submitted for verification at Etherscan.io on 2017-11-28\n*/\n\npragma solidity ^0.4.17;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n    /**\n      * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n      * account.\n      */\n    function Ownable() public {\n        owner = msg.sender;\n    }\n\n    /**\n      * @dev Throws if called by any account other than the owner.\n      */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Basic {\n    uint public _totalSupply;\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address who) public constant returns (uint);\n    function transfer(address to, uint value) public;\n    event Transfer(address indexed from, address indexed to, uint value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender) public constant returns (uint);\n    function transferFrom(address from, address to, uint value) public;\n    function approve(address spender, uint value) public;\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is Ownable, ERC20Basic {\n    using SafeMath for uint;\n\n    mapping(address => uint) public balances;\n\n    // additional variables for use if transaction fees ever became necessary\n    uint public basisPointsRate = 0;\n    uint public maximumFee = 0;\n\n    /**\n    * @dev Fix for the ERC20 short address attack.\n    */\n    modifier onlyPayloadSize(uint size) {\n        require(!(msg.data.length < size + 4));\n        _;\n    }\n\n    /**\n    * @dev transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n        uint fee = (_value.mul(basisPointsRate)).div(10000);\n        if (fee > maximumFee) {\n            fee = maximumFee;\n        }\n        uint sendAmount = _value.sub(fee);\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(sendAmount);\n        if (fee > 0) {\n            balances[owner] = balances[owner].add(fee);\n            Transfer(msg.sender, owner, fee);\n        }\n        Transfer(msg.sender, _to, sendAmount);\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public constant returns (uint balance) {\n        return balances[_owner];\n    }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is BasicToken, ERC20 {\n\n    mapping (address => mapping (address => uint)) public allowed;\n\n    uint public constant MAX_UINT = 2**256 - 1;\n\n    /**\n    * @dev Transfer tokens from one address to another\n    * @param _from address The address which you want to send tokens from\n    * @param _to address The address which you want to transfer to\n    * @param _value uint the amount of tokens to be transferred\n    */\n    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n        var _allowance = allowed[_from][msg.sender];\n\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n        // if (_value > _allowance) throw;\n\n        uint fee = (_value.mul(basisPointsRate)).div(10000);\n        if (fee > maximumFee) {\n            fee = maximumFee;\n        }\n        if (_allowance < MAX_UINT) {\n            allowed[_from][msg.sender] = _allowance.sub(_value);\n        }\n        uint sendAmount = _value.sub(fee);\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(sendAmount);\n        if (fee > 0) {\n            balances[owner] = balances[owner].add(fee);\n            Transfer(_from, owner, fee);\n        }\n        Transfer(_from, _to, sendAmount);\n    }\n\n    /**\n    *"
    }
  ]
}