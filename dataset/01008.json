{
  "Title": "Validators Can Steal Refunds of EOA Users When Claiming Messages",
  "Content": "When a message with empty calldata and an EOA as a recipient is claimed on L1, part of the fees is [reimbursed](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l1/L1MessageService.sol#L199) to the destination address. This refund is computed as `_feeInWei - deliveryFee` where `deliveryFee = min(_feeInWei, (startingGas + REFUND_OVERHEAD_IN_GAS - gasleft()) * tx.gasprice)`.\n\n\nHowever, this way of computing the refund is vulnerable to validators claiming messages and inflating `tx.gasprice` by setting a high transaction tip. A validator could inflate the tip to where the `deliveryFee` is equal to the maximum fee set on the message. A user setting a high fee to ensure their transaction is picked up by a postman would effectively get their refund stolen.\n\n\nConsider documenting this behavior. Generally, users should not be encouraged to rely on the refund mechanism as it is susceptible to leaks from MEV.\n\n\n***Update:** Acknowledged, not resolved. The Linea team stated:*\n\n\n\n> *This will be a potential future enhancement. Documentation will be updated as per the recommendation.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/messageService/l1/L1MessageService.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IMessageService } from \"../../interfaces/IMessageService.sol\";\nimport { IGenericErrors } from \"../../interfaces/IGenericErrors.sol\";\nimport { PauseManager } from \"../lib/PauseManager.sol\";\nimport { RateLimiter } from \"../lib/RateLimiter.sol\";\nimport { L1MessageManager } from \"./L1MessageManager.sol\";\n\n/**\n * @title Contract to manage cross-chain messaging on L1.\n * @author ConsenSys Software Inc.\n */\nabstract contract L1MessageService is\n  Initializable,\n  RateLimiter,\n  L1MessageManager,\n  PauseManager,\n  IMessageService,\n  IGenericErrors\n{\n  // @dev This is initialised to save user cost with existing slot.\n  uint256 public nextMessageNumber;\n\n  address private _messageSender;\n\n  // Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap;\n\n  // @dev adding these should not affect storage as they are constants and are store in bytecode\n  uint256 private constant REFUND_OVERHEAD_IN_GAS = 40000;\n\n  /**\n   * @notice Initialises underlying message service dependencies.\n   * @dev _messageSender is initialised to a non-zero value for gas efficiency on claiming.\n   * @param _limitManagerAddress The address owning the rate limiting management role.\n   * @param _pauseManagerAddress The address owning the pause management role.\n   * @param _rateLimitPeriod The period to rate limit against.\n   * @param _rateLimitAmount The limit allowed for withdrawing the period.\n   **/\n  function __MessageService_init(\n    address _limitManagerAddress,\n    address _pauseManagerAddress,\n    uint256 _rateLimitPeriod,\n    uint256 _rateLimitAmount\n  ) internal onlyInitializing {\n    if (_limitManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_pauseManagerAddress == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    __ERC165_init();\n    __Context_init();\n    __AccessControl_init();\n    __RateLimiter_init(_rateLimitPeriod, _rateLimitAmount);\n\n    _grantRole(RATE_LIMIT_SETTER_ROLE, _limitManagerAddress);\n    _grantRole(PAUSE_MANAGER_ROLE, _pauseManagerAddress);\n\n    nextMessageNumber = 1;\n    _messageSender = address(123456789);\n  }\n\n  /**\n   * @notice Adds a message for sending cross-chain and emits MessageSent.\n   * @dev The message number is preset (nextMessageNumber) and only incremented at the end if successful for the next caller.\n   * @dev This function should be called with a msg.value = _value + _fee. The fee will be paid on the destination chain.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _calldata The calldata to pass to the recipient.\n   **/\n  function sendMessage(\n    address _to,\n    uint256 _fee,\n    bytes calldata _calldata\n  ) external payable whenTypeNotPaused(L1_L2_PAUSE_TYPE) whenTypeNotPaused(GENERAL_PAUSE_TYPE) {\n    if (_to == address(0)) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    if (_fee > msg.value) {\n      revert ValueSentTooLow();\n    }\n\n    uint256 messageNumber = nextMessageNumber;\n    uint256 valueSent = msg.value - _fee;\n\n    bytes32 messageHash = keccak256(abi.encode(msg.sender, _to, _fee, valueSent, messageNumber, _calldata));\n\n    // @dev Status check and revert is in the message manager\n    _addL1L2MessageHash(messageHash);\n\n    nextMessageNumber++;\n\n    emit MessageSent(msg.sender, _to, _fee, valueSent, messageNumber, _calldata, messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev _feeRecipient can be set to address(0) to receive as msg.sender.\n   * @dev _messageSender is set temporarily when claiming and reset post. Used in sender().\n   * @dev _messageSender is reset to address(123456789) to be more gas efficient.\n   * @param _from The address of the original sender.\n   * @param _to The address the message is intended for.\n   * @param _fee The fee being paid for the message delivery.\n   * @param _value The value to be transferred to the destination address.\n   * @param _feeRecipient The recipient for the fee.\n   * @param _calldata The calldata to pass to the recipient.\n   * @param _nonce The unique auto generated nonce used when sending the message.\n   **/\n  function claimMessage(\n    address _from,\n    address _to,\n    uint256 _fee,\n    uint256 _value,\n    address payable _feeRecipient,\n    bytes calldata _calldata,\n    uint256 _nonce\n  ) external distributeFees(_fee, _to, _calldata, _feeRecipient) {\n    _requireTypeNotPaused(L2_L1_PAUSE_TYPE);\n    _requireTypeNotPaused(GENERAL_PAUSE_TYPE);\n\n    bytes32 messageHash = keccak256(abi.encode(_from, _to, _fee, _value, _nonce, _calldata));\n\n    // @dev Status check and revert is in the message manager.\n    _updateL2L1MessageStatusToClaimed(messageHash);\n\n    _addUsedAmount(_fee + _value);\n\n    _messageSender = _from;\n\n    (bool callSuccess, bytes memory returnData) = _to.call{ value: _value }(_calldata);\n    if (!callSuccess) {\n      if (returnData.length > 0) {\n        assembly {\n          let data_size := mload(returnData)\n          revert(add(32, returnData), data_size)\n        }\n      } else {\n        revert MessageSendingFailed(_to);\n      }\n    }\n\n    _messageSender = address(123456789);\n\n    emit MessageClaimed(messageHash);\n  }\n\n  /**\n   * @notice Claims and delivers a cross-chain message.\n   * @dev _messageSender is set temporarily when claiming.\n   **/\n  function sender() external view returns (address) {\n    return _messageSender;\n  }\n\n  /**\n   * @notice Function to receive funds for liquidity purposes.\n   **/\n  receive() external payable virtual {}\n\n  /**\n   * @notice The unspent fee is refunded if applicable.\n   * @param _feeInWei The fee paid for delivery in Wei.\n   * @param _to The recipient of the message and gas refund.\n   * @param _calldata The calldata of the message.\n   **/\n  modifier distributeFees(\n    uint256 _feeInWei,\n    address _to,\n    bytes calldata _calldata,\n    address _feeRecipient\n  ) {\n    //pre-execution\n    uint256 startingGas = gasleft();\n    _;\n    //post-execution\n\n    // we have a fee\n    if (_feeInWei > 0) {\n      // default postman fee\n      uint256 deliveryFee = _feeInWei;\n\n      // do we have empty calldata?\n      if (_calldata.length == 0) {\n        bool isDestinationEOA;\n\n        assembly {\n          isDestinationEOA := iszero(extcodesize(_to))\n        }\n\n        // are we calling an EOA\n        if (isDestinationEOA) {\n          // initial + cost to call and refund minus gasleft\n          deliveryFee = (startingGas + REFUND_OVERHEAD_IN_GAS - gasleft()) * tx.gasprice;\n\n          if (_feeInWei > deliveryFee) {\n            _to.call{ value: (_feeInWei - deliveryFee) }(\"\");\n          } else {\n            deliveryFee = _feeInWei;\n          }\n        }\n      }\n\n      address feeReceiver = _feeRecipient == address(0) ? msg.sender : _feeRecipient;\n      (bool callSuccess, ) = feeReceiver.call{ value: deliveryFee }(\"\");\n      if (!callSuccess) {\n        revert FeePaymentFailed(feeReceiver);\n      }\n    }\n  }\n}"
    }
  ]
}