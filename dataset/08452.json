{
  "Title": "[M-11] Loss of funds in an underlying protocol would cause catostrophic loss of funds for swivel",
  "Content": "_Submitted by 0x52_\n\nLoss of all user funds.\n\n### Proof of Concept\n\nThis exploit stems from a quirk in the way that exchange rate is tracked for matured positions. We first need to breakdown how interest is calculate for a matured position.\n\n<https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/VaultTracker/VaultTracker.sol#L123-L132>\n\nIn L124 the yield for a matured position is calculated as the difference between the previous exchange ratio and the maturity rate. This counts on the fact the exchange rate of the underlying protocol never decreases, as it always set the previous exchange rate to the current exchange rate after yield is calculated regardless of whether it is mature or not. The assumption is that the current exchange rate will always be greater than or equal to the maturity exchange rate. If it is higher then L124 will revert due to underflow and if it is equal then L124 will return yield = 0. The issue comes in when this assumption is invalidated. This would happen were the underlying protocol to lose value (hacked, UST depeg, etc.). With the loss of value, the exchange rate would drop, allowing a user to repeatedly redeem their matured position until all funds from the affected protocol are drained.\n\nExample:\nImagine a yearn vault that takes USDC as the underlying token. It's current price per share is 1.25e6 (1.25 USDC per vault share). Swivel has a recently expired VaultTracker.sol for this yearn vault for which mature() is called, setting maturityRate = 1.25e6. Now let's imagine that one small strategy deployed by the vault is compromised and the vault loses 4% of it's USDC. Now the vault will return 1.2e6 as the price per share. When calling redeemInterest for the first time, vlt.exchangeRate will be updated to 1.2e6 in L132. The next time redeemInterest is called it will pay the difference between 1.25e6 (maturityRate) and 1.2e6 (vlt.exchangeRate). redeemInterest can be called repeatedly like this until all USDC deposited in the yearn vault by Swivel users has been drained.\n\nAdditionally the user in question would not even need to have an expired position before the loss of funds occurred. SplitUnderlying in Swivel.sol has no checks to keep a user from minting previously expired market. After the loss of funds occurred the malicious user could use SplitUnderlying to create nTokens for the expired market, then carry out the exploit\n\n### Recommended Mitigation Steps\n\nThe impact of such an event could be decreased with changes. In splitUnderlying add:\n\n`require(block.timestamp < m)`\n\nThis prevents nTokens from being created after expiration which dramatically reduces the ability to take advantage of the opportunity. As for redeemInterest, add the following line after L124:\n\n`vlt.notional = 0`\n\nThis would clear the notional balance of the user when redeeming after maturity, making it impossible to call repeatedly and reduces the chances that any users have a notional balance to exploit it should an event like this happen.\n\n**[JTraversa (Swivel) disputed, disagreed with severity and commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/71#issuecomment-1186008338):**\n > I'm unsure if this is a proper report / should be accepted given similar issues exist when you integrate nearly any DeFi primitive.\n> \n> You have risks that your integrated protocols could break, but make assumptions that they will not while placing failsafes like pause mechanism in your protocol.\n> \n> That said, the suggestions dont really solve anything, though we may end up taking them to heart? \n> \n> If the issue is that funds are lost when integrated protocol funds are lost and an attacker can then abuse these methods then the solutions provided just make someone spend more on gas in whatever flash loan tx they use to drain the protocol or slightly reduce the likelihood than an attacker will be in the correct position.\n\n**[bghughes (judge) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/71#issuecomment-1204013030):**\n > Note that this builds on [#79](https://github.com/code-423n4/2022-07-swivel-findings/issues/79) and I believe it is a good issue. The warden lays out a clear case in which Vault funds can be drained if these conditions occur:\n> - A market has matured\n> - The exchange rate of the underlying vault token drops below the set `maturityRate`.\n> \n> I agree that integrations can break @JTraversa, but given that Swivel aims to be the place people can go to deposit vault tokens and get ZCB + yield tokens (including allowing 4626 vaults) this is an attack vector IMO. Moreover, Yearn uses some discrete strategies in which the price per share realistically could reduce or even be manipulated in atomicity in a flash loan attack (which may seem counterintuitive bc generally lending vaults are supposed to be \"up only\").\n> \n> Confirming this as a High-Risk issue as an attack vector to drain all vault funds is present. Please let me know Sponsor if you have any questions.\n\n**[robrobbins (Swivel) resolved and commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/71#issuecomment-1205711627):**\n > Much of this is addressed with: https://github.com/Swivel-Finance/gost/pull/417 (cannot mint post maturity).\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/71#issuecomment-1227202390):**\n > Downgrading to Medium as it requires external factors for this situation to present itself and the attack to occur.  \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-swivel-v3-contest",
  "Code": [
    {
      "filename": "VaultTracker/VaultTracker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Compounding.sol';\n\ncontract VaultTracker {\n  /// @notice A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Vault {\n    uint256 notional;\n    uint256 redeemable;\n    uint256 exchangeRate;\n  }\n\n  mapping(address => Vault) public vaults;\n\n  address public immutable admin;\n  address public immutable cTokenAddr;\n  address public immutable swivel;\n  uint256 public immutable maturity;\n  uint256 public maturityRate;\n  uint8 public immutable protocol;\n\n  /// @param m Maturity timestamp associated with this vault\n  /// @param c Compounding Token address associated with this vault\n  /// @param s Address of the deployed swivel contract\n  constructor(uint8 p, uint256 m, address c, address s) {\n    admin = msg.sender;\n    protocol = p;\n    maturity = m;\n    cTokenAddr = c;\n    swivel = s;\n\n    // instantiate swivel's vault (unblocking transferNotionalFee)\n    vaults[s] = Vault({\n      notional: 0,\n      redeemable: 0,\n      exchangeRate: Compounding.exchangeRate(p, c)\n    });\n  }\n\n  /// @notice Adds notional to a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional added\n  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    Vault memory vlt = vaults[o];\n\n    if (vlt.notional > 0) {\n      uint256 yield;\n\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { // Calculate marginal interest\n        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n      }\n\n      uint256 interest = (yield * vlt.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      vlt.redeemable += interest;\n      vlt.notional += a;\n    } else {\n      vlt.notional = a;\n    }\n\n    vlt.exchangeRate = exchangeRate;\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Removes notional from a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional to remove\n  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n\n    Vault memory vlt = vaults[o];\n\n    if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    vlt.redeemable += interest;\n    vlt.notional -= a;\n    vlt.exchangeRate = exchangeRate;\n\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Redeem's interest accrued by a given address\n  /// @param o Address that owns a vault\n  function redeemInterest(address o) external authorized(admin) returns (uint256) {\n\n    Vault memory vlt = vaults[o];\n\n    uint256 redeemable = vlt.redeemable;\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n\n    vlt.exchangeRate = exchangeRate;\n    vlt.redeemable = 0;\n\n    vaults[o] = vlt;\n\n    // return adds marginal interest to previously accrued redeemable interest\n    return (redeemable + interest);\n  }\n\n  /// @notice Matures the vault\n  /// @param c The current cToken exchange rate\n  function matureVault(uint256 c) external authorized(admin) returns (bool) {\n    maturityRate = c;\n    return true;\n  }\n\n  /// @notice Transfers notional from one address to another\n  /// @param f Owner of the amount\n  /// @param t Recipient of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFrom(address f, address t, uint256 a) external authorized(admin) returns (bool) {\n    if (f == t) { revert Exception(32, 0, 0, f, t); }\n\n    Vault memory from = vaults[f];\n    Vault memory to = vaults[t];\n\n    if (a > from.notional) { revert Exception(31, a, from.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { \n      // calculate marginal interest\n      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;\n    } else {\n      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * from.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    from.redeemable += interest;\n    from.notional -= a;\n    from.exchangeRate = exchangeRate;\n\n    vaults[f] = from;\n\n    // transfer notional to address \"t\", calculate interest if necessary\n    if (to.notional > 0) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;\n      }\n\n      uint256 newVaultInterest = (yield * to.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      to.redeemable += newVaultInterest;\n      to.notional += a;\n    } else {\n      to.notional = a;\n    }\n\n    to.exchangeRate = exchangeRate;\n    vaults[t] = to;\n\n    return true;\n  }\n\n  /// @notice Transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFee(address f, uint256 a) external authorized(admin) returns(bool) {\n    Vault memory oVault = vaults[f];\n    Vault memory sVault = vaults[swivel];\n\n    // remove notional from its owner\n    oVault.notional -= a;\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate\n    uint256 yield;\n    if (sVault.exchangeRate != exchangeRate) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n          yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;\n      } else {\n          yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;\n      }\n      uint256 interest = (yield * sVault.notional) / 1e26;\n      // add interest and amount, reset cToken exchange rate\n      sVault.redeemable += interest;\n      sVault.exchangeRate = exchangeRate;\n    }\n    // add notional to swivel's vault\n    sVault.notional += a;\n    // store the adjusted vaults\n    vaults[swivel] = sVault;\n    vaults[f] = oVault;\n    return true;\n  }\n\n  /// @notice Returns both relevant balances for a given user's vault\n  /// @param o Address that owns a vault\n  function balancesOf(address o) external view returns (uint256, uint256) {\n    Vault memory vault = vaults[o];\n    return (vault.notional, vault.redeemable);\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n}"
    }
  ]
}