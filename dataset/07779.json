{
  "Title": "[M-01] `diamondCut` is not protected in case of governor's key leakage",
  "Content": "\nWhen the governor proposes a diamondCut, governor must wait for `upgradeNoticePeriod` to be passed, or security council members have to approve the proposal to bypass the notice period, so that the governor can execute the proposal.\n\n       require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n       require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n\nIf the governor's key is leaked and noticed by zkSync, the attacker must wait for the notice period to execute the already proposed diamondCut with the malicious `_calldata` based on the note below from zkSync, or to propose a new malicious diamondCut. For, both cases, the attacker loses time.\n\n> NOTE: proposeDiamondCut - commits data associated with an upgrade but does not execute it. While the upgrade is associated with facetCuts and (address \\_initAddress, bytes \\_calldata) the upgrade will be committed to the facetCuts and \\_initAddress. This is done on purpose, to leave some freedom to the governor to change calldata for the upgrade between proposing and executing it.\n\nSince, there is a notice period (as zkSync noticed the key leakage, security council member will not approve the proposal, so bypassing the notice period is not possible), there is enough time for zkSync to apply security measures (pausing any deposit/withdraw, reporting in media to not execute any transaction in zkSync, and so on).\n\nBut, the attacker can be smarter, just before the proposal be executed by the governor (i.e. the notice period is passed or security council members approved it), the attacker executes the proposal earlier than governor with the malicious `_calldata`. In other words, the attacker front runs the governor.\n\nTherefore, if zkSync notices the governor's key leakage beforehand, there is enough time to protect the project. But, if zkSync does not notice the governor's key leakage, the attacker can change the `_calldata` into a malicious one in the last moment so that it is not possible to protect the project.\n\n### Proof of Concept\n\n[Diamond.sol#L277](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Diamond.sol#L277)<br>\n[DiamondCut.sol#L46](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L46)\n\n### Recommended Mitigation Steps\n\n`_calldata` should be included in the proposed diamondCut:[DiamondCut.sol#L27](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L27).\n\nOr, at least one of the security council members should approve the `_calldata` during execution of the proposal.\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/46#issuecomment-1324267775):**\n > It is a valid issue, and the fix is going to be implemented, so we confirm the issue as medium! Thanks.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/46#issuecomment-1335849634):**\n > In contrast to other reports, this shows how a malicious proposal could be injected, bypassing the timelock protection, for this reason (after consulting with a second Judge), I agree with marking it as a distinct finding and agree with Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-zksync-v2-contest",
  "Code": [
    {
      "filename": "ethereum/contracts/zksync/libraries/Diamond.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author Matter Labs\n/// @notice The helper library for managing the EIP-2535 diamond proxy.\nlibrary Diamond {\n    /// @dev Magic value that should be returned by diamond cut initialize contracts.\n    /// @dev Used to distinguish calls to contracts that were supposed to be used as diamond initializer from other contracts.\n    bytes32 constant DIAMOND_INIT_SUCCESS_RETURN_VALUE =\n        0x33774e659306e47509050e97cb651e731180a42d458212294d30751925c551a2; // keccak256(\"diamond.zksync.init\") - 1\n\n    /// @dev Storage position of `DiamondStorage` structure.\n    bytes32 constant DIAMOND_STORAGE_POSITION = 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b; // keccak256(\"diamond.standard.diamond.storage\") - 1;\n\n    event DiamondCut(FacetCut[] facetCuts, address initAddress, bytes initCalldata);\n\n    /// @dev Utility struct that contains associated facet & meta information of selector\n    /// @param facetAddress address of the facet which is connected with selector\n    /// @param selectorPosition index in `FacetToSelectors.selectors` array, where is selector stored\n    /// @param isFreezable denotes whether the selector can be frozen.\n    struct SelectorToFacet {\n        address facetAddress;\n        uint16 selectorPosition;\n        bool isFreezable;\n    }\n\n    /// @dev Utility struct that contains associated selectors & meta information of facet\n    /// @param selectors list of all selectors that belong to the facet\n    /// @param facetPosition index in `DiamondStorage.facets` array, where is facet stored\n    struct FacetToSelectors {\n        bytes4[] selectors;\n        uint16 facetPosition;\n    }\n\n    /// @notice The structure that holds all diamond proxy associated parameters\n    /// @dev According to the EIP-2535 should be stored on a special storage key - `DIAMOND_STORAGE_POSITION`\n    /// @param selectorToFacet A mapping from the selector to the facet address and its meta information\n    /// @param facetToSelectors A mapping from facet address to its selector with meta information\n    /// @param facets The array of all unique facet addresses that belong to the diamond proxy\n    /// @param isFrozen Denotes whether the diamond proxy is frozen and all freezable facets are not accessible\n    struct DiamondStorage {\n        mapping(bytes4 => SelectorToFacet) selectorToFacet;\n        mapping(address => FacetToSelectors) facetToSelectors;\n        address[] facets;\n        bool isFrozen;\n    }\n\n    /// @dev Parameters for diamond changes that touch one of the facets\n    /// @param facet The address of facet that's affected by the cut\n    /// @param action The action that is made on the facet\n    /// @param isFreezable Denotes whether the facet & all their selectors can be frozen\n    /// @param selectors An array of unique selectors that belongs to the facet address\n    struct FacetCut {\n        address facet;\n        Action action;\n        bool isFreezable;\n        bytes4[] selectors;\n    }\n\n    /// @dev Structure of the diamond proxy changes\n    /// @param facetCuts The set of changes (adding/removing/replacement) of implementation contracts\n    /// @param initAddress The address that's dellegate called after setting up new facet changes\n    /// @param initCalldata Calldata for the delegete call to `initAddress`\n    struct DiamondCutData {\n        FacetCut[] facetCuts;\n        address initAddress;\n        bytes initCalldata;\n    }\n\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\n    enum Action {\n        Add,\n        Replace,\n        Remove\n    }\n\n    /// @return diamondStorage The pointer to the storage where all specific diamond proxy parameters stored\n    function getDiamondStorage() internal pure returns (DiamondStorage storage diamondStorage) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            diamondStorage.slot := position\n        }\n    }\n\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\n    function diamondCut(DiamondCutData memory _diamondCut) internal {\n        FacetCut[] memory facetCuts = _diamondCut.facetCuts;\n        address initAddress = _diamondCut.initAddress;\n        bytes memory initCalldata = _diamondCut.initCalldata;\n        uint256 facetCutsLength = facetCuts.length;\n        for (uint256 i = 0; i < facetCutsLength; ++i) {\n            Action action = facetCuts[i].action;\n            address facet = facetCuts[i].facet;\n            bool isFacetFreezable = facetCuts[i].isFreezable;\n            bytes4[] memory selectors = facetCuts[i].selectors;\n\n            require(selectors.length > 0, \"B\"); // no functions for diamond cut\n\n            if (action == Action.Add) {\n                _addFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Replace) {\n                _replaceFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Remove) {\n                _removeFunctions(facet, selectors);\n            } else {\n                revert(\"C\"); // undefined diamond cut action\n            }\n        }\n\n        _initializeDiamondCut(initAddress, initCalldata);\n        emit DiamondCut(facetCuts, initAddress, initCalldata);\n    }\n\n    /// @dev Add new functions to the diamond proxy\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _addFunctions(\n        address _facet,\n        bytes4[] memory _selectors,\n        bool _isFacetFreezable\n    ) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet != address(0), \"G\"); // facet with zero address cannot be added\n\n        // Add facet to the list of facets if the facet address is new one\n        _saveFacetIfNew(_facet);\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; ++i) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress == address(0), \"J\"); // facet for this selector already exists\n\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Change associated facets to already known function selectors\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _replaceFunctions(\n        address _facet,\n        bytes4[] memory _selectors,\n        bool _isFacetFreezable\n    ) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet != address(0), \"K\"); // cannot replace facet with zero address\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; ++i) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress != address(0), \"L\"); // it is impossible to replace the facet with zero address\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n            // Add facet to the list of facets if the facet address is a new one\n            _saveFacetIfNew(_facet);\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Remove association with function and facet\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _removeFunctions(address _facet, bytes4[] memory _selectors) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet == address(0), \"a1\"); // facet address must be zero\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; ++i) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress != address(0), \"a2\"); // Can't delete a non-existent facet\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n        }\n    }\n\n    /// @dev Add address to the list of known facets if it is not on the list yet\n    /// NOTE: should be called ONLY before adding a new selector associated with the address\n    function _saveFacetIfNew(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;\n        // If there are no selectors associated with facet then save facet as new one\n        if (selectorsLength == 0) {\n            ds.facetToSelectors[_facet].facetPosition = uint16(ds.facets.length);\n            ds.facets.push(_facet);\n        }\n    }\n\n    /// @dev Add one function to the already known facet\n    /// NOTE: It is expected but NOT enforced that:\n    /// - `_facet` is NON-ZERO address\n    /// - `_facet` is already stored address in `DiamondStorage.facets`\n    /// - `_selector` is NOT associated by another facet\n    function _addOneFunction(\n        address _facet,\n        bytes4 _selector,\n        bool _isSelectorFreezable\n    ) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint16 selectorPosition = uint16(ds.facetToSelectors[_facet].selectors.length);\n\n        // if selectorPosition is nonzero, it means it is not a new facet\n        // so the freezability of the first selector must be matched to _isSelectorFreezable\n        // so all the selectors in a facet will have the same freezability\n        if (selectorPosition != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            require(_isSelectorFreezable == ds.selectorToFacet[selector0].isFreezable, \"J1\");\n        }\n\n        ds.selectorToFacet[_selector] = SelectorToFacet({\n            facetAddress: _facet,\n            selectorPosition: selectorPosition,\n            isFreezable: _isSelectorFreezable\n        });\n        ds.facetToSelectors[_facet].selectors.push(_selector);\n    }\n\n    /// @dev Remove one associated function with facet\n    /// NOTE: It is expected but NOT enforced that `_facet` is NON-ZERO address\n    function _removeOneFunction(address _facet, bytes4 _selector) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `FacetToSelectors.selectors` of the selector and last element of array\n        uint256 selectorPosition = ds.selectorToFacet[_selector].selectorPosition;\n        uint256 lastSelectorPosition = ds.facetToSelectors[_facet].selectors.length - 1;\n\n        // If the selector is not at the end of the array then move the last element to the selector position\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetToSelectors[_facet].selectors[lastSelectorPosition];\n\n            ds.facetToSelectors[_facet].selectors[selectorPosition] = lastSelector;\n            ds.selectorToFacet[lastSelector].selectorPosition = uint16(selectorPosition);\n        }\n\n        // Remove last element from the selectors array\n        ds.facetToSelectors[_facet].selectors.pop();\n\n        // Finally, clean up the association with facet\n        delete ds.selectorToFacet[_selector];\n\n        // If there are no selectors for facet then remove the facet from the list of known facets\n        if (lastSelectorPosition == 0) {\n            _removeFacet(_facet);\n        }\n    }\n\n    /// @dev remove facet from the list of known facets\n    /// NOTE: It is expected but NOT enforced that there are no selectors associated wih `_facet`\n    function _removeFacet(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `DiamondStorage.facets` of the facet and last element of array\n        uint256 facetPosition = ds.facetToSelectors[_facet].facetPosition;\n        uint256 lastFacetPosition = ds.facets.length - 1;\n\n        // If the facet is not at the end of the array then move the last element to the facet position\n        if (facetPosition != lastFacetPosition) {\n            address lastFacet = ds.facets[lastFacetPosition];\n\n            ds.facets[facetPosition] = lastFacet;\n            ds.facetToSelectors[lastFacet].facetPosition = uint16(facetPosition);\n        }\n\n        // Remove last element from the facets array\n        ds.facets.pop();\n    }\n\n    /// @dev Delegates call to the initialization address with provided calldata\n    /// @dev Used as a final step of diamond cut to execute the logic of the initialization for changed facets\n    function _initializeDiamondCut(address _init, bytes memory _calldata) private {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"H\"); // Non-empty calldata for zero address\n        } else {\n            // Do not check whether `_init` is a contract since later we check that it returns data.\n            (bool success, bytes memory data) = _init.delegatecall(_calldata);\n            require(success, \"I\"); // delegatecall failed\n\n            // Check that called contract returns magic value to make sure that contract logic\n            // supposed to be used as diamond cut initializer.\n            require(data.length == 32, \"lp\");\n            require(abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, \"lp1\");\n        }\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/zksync/facets/DiamondCut.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../libraries/Diamond.sol\";\nimport \"../Config.sol\";\nimport \"./Base.sol\";\n\n/// @title DiamondCut contract responsible for the management of upgrades.\n/// @author Matter Labs\ncontract DiamondCutFacet is Base, IDiamondCut {\n    constructor() {\n        // Caution check for config value.\n        // Should be greater than 0, otherwise zero approvals will be enough to make an instant upgrade!\n        assert(SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE > 0);\n    }\n\n    /// @dev Starts the upgrade process. Only the current governor can propose an upgrade.\n    /// @param _facetCuts The set of proposed changes to the facets (adding/replacement/removing)\n    /// @param _initAddress Address of the fallback contract that will be called after the upgrade execution\n    function proposeDiamondCut(Diamond.FacetCut[] calldata _facetCuts, address _initAddress) external onlyGovernor {\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp == 0, \"a3\"); // proposal already exists\n\n        // NOTE: governor commits only to the `facetCuts` and `initAddress`, but not to the calldata on `initAddress` call.\n        // That means the governor can call `initAddress` with ANY calldata while executing the upgrade.\n        s.diamondCutStorage.proposedDiamondCutHash = keccak256(abi.encode(_facetCuts, _initAddress));\n        s.diamondCutStorage.proposedDiamondCutTimestamp = block.timestamp;\n        s.diamondCutStorage.currentProposalId += 1;\n\n        emit DiamondCutProposal(_facetCuts, _initAddress);\n    }\n\n    /// @notice Removes the upgrade proposal. Only current governor can remove proposal.\n    function cancelDiamondCutProposal() external onlyGovernor {\n        emit DiamondCutProposalCancelation(\n            s.diamondCutStorage.currentProposalId,\n            s.diamondCutStorage.proposedDiamondCutHash\n        );\n        require(_resetProposal(), \"g1\"); // failed cancel diamond cut\n    }\n\n    /// @notice Executes a proposed governor upgrade. Only the current governor can execute the upgrade.\n    /// NOTE: Governor can execute diamond cut ONLY with proposed `facetCuts` and `initAddress`.\n    /// `initCalldata` can be arbitrarily.\n    function executeDiamondCutProposal(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        bool approvedBySecurityCouncil = s.diamondCutStorage.securityCouncilEmergencyApprovals >=\n            SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE;\n\n        bool upgradeNoticePeriodPassed = block.timestamp >=\n            s.diamondCutStorage.proposedDiamondCutTimestamp + UPGRADE_NOTICE_PERIOD;\n\n        require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n        require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n        // should not be frozen or should have enough security council approvals\n\n        require(\n            s.diamondCutStorage.proposedDiamondCutHash ==\n                keccak256(abi.encode(_diamondCut.facetCuts, _diamondCut.initAddress)),\n            \"a4\"\n        ); // proposal should be created\n\n        require(_resetProposal(), \"a5\"); // failed reset proposal\n\n        if (diamondStorage.isFrozen) {\n            diamondStorage.isFrozen = false;\n            emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n        }\n\n        Diamond.diamondCut(_diamondCut);\n\n        emit DiamondCutProposalExecution(_diamondCut);\n    }\n\n    /// @notice Instantly pause the functionality of all freezable facets & their selectors\n    function emergencyFreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        _resetProposal();\n\n        diamondStorage.isFrozen = true;\n        // Limited-time freezing feature will be added in the future upgrades, so keeping this variable for simplification\n        s.diamondCutStorage.lastDiamondFreezeTimestamp = block.timestamp;\n\n        emit EmergencyFreeze();\n    }\n\n    /// @notice Unpause the functionality of all freezable facets & their selectors\n    function unfreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n\n        _resetProposal();\n\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n    }\n\n    /// @notice Gives another approval for the instant upgrade (diamond cut) by the security council member\n    /// @param _diamondCutHash The hash of the diamond cut that security council members want to approve. Needed to prevent unintentional approvals, including reorg attacks\n    function approveEmergencyDiamondCutAsSecurityCouncilMember(bytes32 _diamondCutHash) external {\n        require(s.diamondCutStorage.securityCouncilMembers[msg.sender], \"a9\"); // not a security council member\n        uint256 currentProposalId = s.diamondCutStorage.currentProposalId;\n        require(s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] < currentProposalId, \"ao\"); // already approved this proposal\n        s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] = currentProposalId;\n\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp != 0, \"f0\"); // there is no proposed diamond cut\n        require(s.diamondCutStorage.proposedDiamondCutHash == _diamondCutHash, \"f1\"); // proposed diamond cut do not match to the approved\n        uint256 securityCouncilEmergencyApprovals = s.diamondCutStorage.securityCouncilEmergencyApprovals;\n        s.diamondCutStorage.securityCouncilEmergencyApprovals = securityCouncilEmergencyApprovals + 1;\n\n        emit EmergencyDiamondCutApproved(\n            msg.sender,\n            currentProposalId,\n            securityCouncilEmergencyApprovals,\n            _diamondCutHash\n        );\n    }\n\n    /// @dev Set up the proposed diamond cut state to the default values\n    /// @return Whether the proposal is reset or it was already empty\n    function _resetProposal() private returns (bool) {\n        if (s.diamondCutStorage.proposedDiamondCutTimestamp == 0) {\n            return false;\n        }\n\n        delete s.diamondCutStorage.proposedDiamondCutHash;\n        delete s.diamondCutStorage.proposedDiamondCutTimestamp;\n        delete s.diamondCutStorage.securityCouncilEmergencyApprovals;\n\n        return true;\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/zksync/facets/DiamondCut.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../libraries/Diamond.sol\";\nimport \"../Config.sol\";\nimport \"./Base.sol\";\n\n/// @title DiamondCut contract responsible for the management of upgrades.\n/// @author Matter Labs\ncontract DiamondCutFacet is Base, IDiamondCut {\n    constructor() {\n        // Caution check for config value.\n        // Should be greater than 0, otherwise zero approvals will be enough to make an instant upgrade!\n        assert(SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE > 0);\n    }\n\n    /// @dev Starts the upgrade process. Only the current governor can propose an upgrade.\n    /// @param _facetCuts The set of proposed changes to the facets (adding/replacement/removing)\n    /// @param _initAddress Address of the fallback contract that will be called after the upgrade execution\n    function proposeDiamondCut(Diamond.FacetCut[] calldata _facetCuts, address _initAddress) external onlyGovernor {\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp == 0, \"a3\"); // proposal already exists\n\n        // NOTE: governor commits only to the `facetCuts` and `initAddress`, but not to the calldata on `initAddress` call.\n        // That means the governor can call `initAddress` with ANY calldata while executing the upgrade.\n        s.diamondCutStorage.proposedDiamondCutHash = keccak256(abi.encode(_facetCuts, _initAddress));\n        s.diamondCutStorage.proposedDiamondCutTimestamp = block.timestamp;\n        s.diamondCutStorage.currentProposalId += 1;\n\n        emit DiamondCutProposal(_facetCuts, _initAddress);\n    }\n\n    /// @notice Removes the upgrade proposal. Only current governor can remove proposal.\n    function cancelDiamondCutProposal() external onlyGovernor {\n        emit DiamondCutProposalCancelation(\n            s.diamondCutStorage.currentProposalId,\n            s.diamondCutStorage.proposedDiamondCutHash\n        );\n        require(_resetProposal(), \"g1\"); // failed cancel diamond cut\n    }\n\n    /// @notice Executes a proposed governor upgrade. Only the current governor can execute the upgrade.\n    /// NOTE: Governor can execute diamond cut ONLY with proposed `facetCuts` and `initAddress`.\n    /// `initCalldata` can be arbitrarily.\n    function executeDiamondCutProposal(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        bool approvedBySecurityCouncil = s.diamondCutStorage.securityCouncilEmergencyApprovals >=\n            SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE;\n\n        bool upgradeNoticePeriodPassed = block.timestamp >=\n            s.diamondCutStorage.proposedDiamondCutTimestamp + UPGRADE_NOTICE_PERIOD;\n\n        require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n        require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n        // should not be frozen or should have enough security council approvals\n\n        require(\n            s.diamondCutStorage.proposedDiamondCutHash ==\n                keccak256(abi.encode(_diamondCut.facetCuts, _diamondCut.initAddress)),\n            \"a4\"\n        ); // proposal should be created\n\n        require(_resetProposal(), \"a5\"); // failed reset proposal\n\n        if (diamondStorage.isFrozen) {\n            diamondStorage.isFrozen = false;\n            emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n        }\n\n        Diamond.diamondCut(_diamondCut);\n\n        emit DiamondCutProposalExecution(_diamondCut);\n    }\n\n    /// @notice Instantly pause the functionality of all freezable facets & their selectors\n    function emergencyFreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        _resetProposal();\n\n        diamondStorage.isFrozen = true;\n        // Limited-time freezing feature will be added in the future upgrades, so keeping this variable for simplification\n        s.diamondCutStorage.lastDiamondFreezeTimestamp = block.timestamp;\n\n        emit EmergencyFreeze();\n    }\n\n    /// @notice Unpause the functionality of all freezable facets & their selectors\n    function unfreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n\n        _resetProposal();\n\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n    }\n\n    /// @notice Gives another approval for the instant upgrade (diamond cut) by the security council member\n    /// @param _diamondCutHash The hash of the diamond cut that security council members want to approve. Needed to prevent unintentional approvals, including reorg attacks\n    function approveEmergencyDiamondCutAsSecurityCouncilMember(bytes32 _diamondCutHash) external {\n        require(s.diamondCutStorage.securityCouncilMembers[msg.sender], \"a9\"); // not a security council member\n        uint256 currentProposalId = s.diamondCutStorage.currentProposalId;\n        require(s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] < currentProposalId, \"ao\"); // already approved this proposal\n        s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] = currentProposalId;\n\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp != 0, \"f0\"); // there is no proposed diamond cut\n        require(s.diamondCutStorage.proposedDiamondCutHash == _diamondCutHash, \"f1\"); // proposed diamond cut do not match to the approved\n        uint256 securityCouncilEmergencyApprovals = s.diamondCutStorage.securityCouncilEmergencyApprovals;\n        s.diamondCutStorage.securityCouncilEmergencyApprovals = securityCouncilEmergencyApprovals + 1;\n\n        emit EmergencyDiamondCutApproved(\n            msg.sender,\n            currentProposalId,\n            securityCouncilEmergencyApprovals,\n            _diamondCutHash\n        );\n    }\n\n    /// @dev Set up the proposed diamond cut state to the default values\n    /// @return Whether the proposal is reset or it was already empty\n    function _resetProposal() private returns (bool) {\n        if (s.diamondCutStorage.proposedDiamondCutTimestamp == 0) {\n            return false;\n        }\n\n        delete s.diamondCutStorage.proposedDiamondCutHash;\n        delete s.diamondCutStorage.proposedDiamondCutTimestamp;\n        delete s.diamondCutStorage.securityCouncilEmergencyApprovals;\n\n        return true;\n    }\n}"
    }
  ]
}