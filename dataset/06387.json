{
  "Title": "[H-01] Pre-defined limit is different from the spec",
  "Content": "\n<https://github.com/code-423n4/2023-06-canto/blob/main/Canto/x/coinswap/keeper/swap.go#L212><br>\n<https://github.com/code-423n4/2023-06-canto/blob/main/Canto/x/coinswap/types/params.go#L34>\n\n### Impact\n\nIn the spec, the pre-defined limit of ETH is 0.01 ETHs. But the actual limit in the code is not 0.01 ETH which could result in misleading.\n\n### Proof of Concept\n\nIn the spec, it said that the pre-defined limit of ETH is 0.01 ETHs.<br>\n<https://github.com/code-423n4/2023-06-canto/blob/main/README.md#swap>\n\n> For risk management purposes, a swap will fail if the input coin amount exceeds a pre-defined limit (10 USDC, 10 USDT, 0.01 ETH) or if the swap amount limit is not defined.\n\nBut in `x/coinswap/types/params.go`, the actual limit of ETH is 1&ast;10e17 which is 0.1 ETH.\n\n```solidity\n// Parameter store keys\nvar (\n\tKeyFee                    = []byte(\"Fee\")                    // fee key\n\tKeyPoolCreationFee        = []byte(\"PoolCreationFee\")        // fee key\n\tKeyTaxRate                = []byte(\"TaxRate\")                // fee key\n\tKeyStandardDenom          = []byte(\"StandardDenom\")          // standard token denom key\n\tKeyMaxStandardCoinPerPool = []byte(\"MaxStandardCoinPerPool\") // max standard coin amount per pool\n\tKeyMaxSwapAmount          = []byte(\"MaxSwapAmount\")          // whitelisted denoms\n\n\tDefaultFee                    = sdk.NewDecWithPrec(0, 0)\n\tDefaultPoolCreationFee        = sdk.NewInt64Coin(sdk.DefaultBondDenom, 0)\n\tDefaultTaxRate                = sdk.NewDecWithPrec(0, 0)\n\tDefaultMaxStandardCoinPerPool = sdk.NewIntWithDecimal(10000, 18)\n\tDefaultMaxSwapAmount          = sdk.NewCoins(\n\t\tsdk.NewCoin(UsdcIBCDenom, sdk.NewIntWithDecimal(10, 6)),\n\t\tsdk.NewCoin(UsdtIBCDenom, sdk.NewIntWithDecimal(10, 6)),\n\t\tsdk.NewCoin(EthIBCDenom, sdk.NewIntWithDecimal(1, 17)),\n\t)\n)\n```\n\nThe limit is used in `swap.GetMaximumSwapAmount`. Wrong could harm the risk management. <br><https://github.com/code-423n4/2023-06-canto/blob/main/Canto/x/coinswap/keeper/swap.go#L212>\n\n```solidity\nfunc (k Keeper) GetMaximumSwapAmount(ctx sdk.Context, denom string) (sdk.Coin, error) {\n\tparams := k.GetParams(ctx)\n\tfor _, coin := range params.MaxSwapAmount {\n\t\tif coin.Denom == denom {\n\t\t\treturn coin, nil\n\t\t}\n\t}\n\treturn sdk.Coin{}, sdkerrors.Wrap(types.ErrInvalidDenom, fmt.Sprintf(\"invalid denom: %s, denom is not whitelisted\", denom))\n}\n```\n\n### Recommended Mitigation Steps\n\n0.01 ETH should be `sdk.NewIntWithDecimal(1, 16)`.\n\n### Assessed type\n\nError\n\n**[0xean (judge) increased severity to High](https://github.com/code-423n4/2023-06-canto-findings/issues/36#issuecomment-1619137392)**\n\n**[tkkwon1998 (Canto) confirmed and commented on duplicate issue 8](https://github.com/code-423n4/2023-06-canto-findings/issues/8#issuecomment-1611705902):**\n> Agreed, this issue is valid as limit is 10x higher than it should be. Although losses are still minimal (0.1 eth at most), I agree with high risk since funds can be lost if pools are manipulated.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-06-canto",
  "Code": [
    {
      "filename": "Canto/x/coinswap/keeper/swap.go",
      "content": "package keeper\n\nimport (\n\t\"fmt\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v6/x/coinswap/types\"\n)\n\nfunc (k Keeper) swapCoins(ctx sdk.Context, sender, recipient sdk.AccAddress, coinSold, coinBought sdk.Coin) error {\n\tlptDenom, err := k.GetLptDenomFromDenoms(ctx, coinSold.Denom, coinBought.Denom)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpoolAddr := types.GetReservePoolAddr(lptDenom)\n\tif err := k.bk.SendCoins(ctx, sender, poolAddr, sdk.NewCoins(coinSold)); err != nil {\n\t\treturn err\n\t}\n\n\tif recipient.Empty() {\n\t\trecipient = sender\n\t}\n\n\treturn k.bk.SendCoins(ctx, poolAddr, recipient, sdk.NewCoins(coinBought))\n}\n\n/*\n*\nCalculate the amount of another token to be received based on the exact amount of tokens sold\n@param exactSoldCoin : sold coin\n@param soldTokenDenom : received token's denom\n@return : amount of the token that will be received\n*/\nfunc (k Keeper) calculateWithExactInput(ctx sdk.Context, exactSoldCoin sdk.Coin, boughtTokenDenom string) (sdk.Int, error) {\n\tlptDenom, err := k.GetLptDenomFromDenoms(ctx, exactSoldCoin.Denom, boughtTokenDenom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\treservePoolAddress := types.GetReservePoolAddr(lptDenom).String()\n\treservePool, err := k.GetPoolBalances(ctx, reservePoolAddress)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tinputReserve := reservePool.AmountOf(exactSoldCoin.Denom)\n\toutputReserve := reservePool.AmountOf(boughtTokenDenom)\n\n\tif !inputReserve.IsPositive() {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrInsufficientFunds, fmt.Sprintf(\"reserve pool insufficient funds, actual [%s%s]\", inputReserve.String(), exactSoldCoin.Denom))\n\t}\n\tif !outputReserve.IsPositive() {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrInsufficientFunds, fmt.Sprintf(\"reserve pool insufficient funds, actual [%s%s]\", outputReserve.String(), boughtTokenDenom))\n\t}\n\tparam := k.GetParams(ctx)\n\n\tboughtTokenAmt := GetInputPrice(exactSoldCoin.Amount, inputReserve, outputReserve, param.Fee)\n\treturn boughtTokenAmt, nil\n}\n\n/*\n*\nSell exact amount of a token for buying another, one of them must be standard token\n@param input: exact amount of the token to be sold\n@param output: min amount of the token to be bought\n@param sender: address of the sender\n@param receipt: address of the receiver\n@return: actual amount of the token to be bought\n*/\nfunc (k Keeper) TradeExactInputForOutput(ctx sdk.Context, input types.Input, output types.Output) (sdk.Int, error) {\n\tboughtTokenAmt, err := k.calculateWithExactInput(ctx, input.Coin, output.Coin.Denom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\t// assert that the calculated amount is more than the\n\t// minimum amount the buyer is willing to buy.\n\tif boughtTokenAmt.LT(output.Coin.Amount) {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrConstraintNotMet, fmt.Sprintf(\"insufficient amount of %s, user expected: %s, actual: %s\", output.Coin.Denom, output.Coin.Amount.String(), boughtTokenAmt.String()))\n\t}\n\tboughtToken := sdk.NewCoin(output.Coin.Denom, boughtTokenAmt)\n\n\tinputAddress, err := sdk.AccAddressFromBech32(input.Address)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\toutputAddress, err := sdk.AccAddressFromBech32(output.Address)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tstandardDenom := k.GetStandardDenom(ctx)\n\tvar quoteCoinToSwap sdk.Coin\n\n\tif boughtToken.Denom != standardDenom {\n\t\tquoteCoinToSwap = boughtToken\n\t} else {\n\t\tquoteCoinToSwap = input.Coin\n\t}\n\n\tmaxSwapAmount, err := k.GetMaximumSwapAmount(ctx, quoteCoinToSwap.Denom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tif quoteCoinToSwap.Amount.GT(maxSwapAmount.Amount) {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrConstraintNotMet, fmt.Sprintf(\"expected swap amount %s%s exceeding swap amount limit %s%s\", quoteCoinToSwap.Amount.String(), quoteCoinToSwap.Denom, maxSwapAmount.Amount.String(), maxSwapAmount.Denom))\n\t}\n\n\tif err := k.swapCoins(ctx, inputAddress, outputAddress, input.Coin, boughtToken); err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\treturn boughtTokenAmt, nil\n}\n\n/*\n*\nCalculate the amount of the token to be paid based on the exact amount of the token to be bought\n@param exactBoughtCoin\n@param soldTokenDenom\n@return: actual amount of the token to be paid\n*/\nfunc (k Keeper) calculateWithExactOutput(ctx sdk.Context, exactBoughtCoin sdk.Coin, soldTokenDenom string) (sdk.Int, error) {\n\tlptDenom, err := k.GetLptDenomFromDenoms(ctx, exactBoughtCoin.Denom, soldTokenDenom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tpoolAddr := types.GetReservePoolAddr(lptDenom).String()\n\treservePool, err := k.GetPoolBalances(ctx, poolAddr)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\toutputReserve := reservePool.AmountOf(exactBoughtCoin.Denom)\n\tinputReserve := reservePool.AmountOf(soldTokenDenom)\n\n\tif !inputReserve.IsPositive() {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrInsufficientFunds, fmt.Sprintf(\"reserve pool insufficient balance: [%s%s]\", inputReserve.String(), soldTokenDenom))\n\t}\n\tif !outputReserve.IsPositive() {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrInsufficientFunds, fmt.Sprintf(\"reserve pool insufficient balance: [%s%s]\", outputReserve.String(), exactBoughtCoin.Denom))\n\t}\n\tif exactBoughtCoin.Amount.GTE(outputReserve) {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrInsufficientFunds, fmt.Sprintf(\"reserve pool insufficient balance of %s, user expected: %s, actual: %s\", exactBoughtCoin.Denom, exactBoughtCoin.Amount.String(), outputReserve.String()))\n\t}\n\tparam := k.GetParams(ctx)\n\n\tsoldTokenAmt := GetOutputPrice(exactBoughtCoin.Amount, inputReserve, outputReserve, param.Fee)\n\treturn soldTokenAmt, nil\n}\n\n/*\n*\nBuy exact amount of a token by specifying the max amount of another token, one of them must be standard token\n@param input : max amount of the token to be paid\n@param output : exact amount of the token to be bought\n@param sender : address of the sender\n@param receipt : address of the receiver\n@return : actual amount of the token to be paid\n*/\nfunc (k Keeper) TradeInputForExactOutput(ctx sdk.Context, input types.Input, output types.Output) (sdk.Int, error) {\n\tsoldTokenAmt, err := k.calculateWithExactOutput(ctx, output.Coin, input.Coin.Denom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\t// assert that the calculated amount is less than the\n\t// max amount the buyer is willing to pay.\n\tif soldTokenAmt.GT(input.Coin.Amount) {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrConstraintNotMet, fmt.Sprintf(\"insufficient amount of %s, user expected: %s, actual: %s\", input.Coin.Denom, input.Coin.Amount.String(), soldTokenAmt.String()))\n\t}\n\tsoldToken := sdk.NewCoin(input.Coin.Denom, soldTokenAmt)\n\n\tinputAddress, err := sdk.AccAddressFromBech32(input.Address)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\toutputAddress, err := sdk.AccAddressFromBech32(output.Address)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tstandardDenom := k.GetStandardDenom(ctx)\n\tvar quoteCoinToSwap sdk.Coin\n\n\tif soldToken.Denom != standardDenom {\n\t\tquoteCoinToSwap = soldToken\n\t} else {\n\t\tquoteCoinToSwap = output.Coin\n\t}\n\n\tmaxSwapAmount, err := k.GetMaximumSwapAmount(ctx, quoteCoinToSwap.Denom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tif quoteCoinToSwap.Amount.GT(maxSwapAmount.Amount) {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrConstraintNotMet, fmt.Sprintf(\"expected swap amount %s%s exceeding swap amount limit %s%s\", quoteCoinToSwap.Amount.String(), quoteCoinToSwap.Denom, maxSwapAmount.Amount.String(), maxSwapAmount.Denom))\n\t}\n\n\tif err := k.swapCoins(ctx, inputAddress, outputAddress, soldToken, output.Coin); err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\treturn soldTokenAmt, nil\n}\n\nfunc (k Keeper) GetMaximumSwapAmount(ctx sdk.Context, denom string) (sdk.Coin, error) {\n\tparams := k.GetParams(ctx)\n\tfor _, coin := range params.MaxSwapAmount {\n\t\tif coin.Denom == denom {\n\t\t\treturn coin, nil\n\t\t}\n\t}\n\treturn sdk.Coin{}, sdkerrors.Wrap(types.ErrInvalidDenom, fmt.Sprintf(\"invalid denom: %s, denom is not whitelisted\", denom))\n}\n\n// GetInputPrice returns the amount of coins bought (calculated) given the input amount being sold (exact)\n// The fee is included in the input coins being bought\n// https://github.com/runtimeverification/verified-smart-contracts/blob/uniswap/uniswap/x-y-k.pdf\nfunc GetInputPrice(inputAmt, inputReserve, outputReserve sdk.Int, fee sdk.Dec) sdk.Int {\n\tdeltaFee := sdk.OneDec().Sub(fee)\n\tinputAmtWithFee := inputAmt.Mul(sdk.NewIntFromBigInt(deltaFee.BigInt()))\n\tnumerator := inputAmtWithFee.Mul(outputReserve)\n\tdenominator := inputReserve.Mul(sdk.NewIntWithDecimal(1, sdk.Precision)).Add(inputAmtWithFee)\n\treturn numerator.Quo(denominator)\n}\n\n// GetOutputPrice returns the amount of coins sold (calculated) given the output amount being bought (exact)\n// The fee is included in the output coins being bought\nfunc GetOutputPrice(outputAmt, inputReserve, outputReserve sdk.Int, fee sdk.Dec) sdk.Int {\n\tdeltaFee := sdk.OneDec().Sub(fee)\n\tnumerator := inputReserve.Mul(outputAmt).Mul(sdk.NewIntWithDecimal(1, sdk.Precision))\n\tdenominator := (outputReserve.Sub(outputAmt)).Mul(sdk.NewIntFromBigInt(deltaFee.BigInt()))\n\treturn numerator.Quo(denominator).Add(sdk.OneInt())\n}"
    },
    {
      "filename": "Canto/x/coinswap/types/params.go",
      "content": "package types\n\nimport (\n\t\"fmt\"\n\n\t\"gopkg.in/yaml.v2\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tparamtypes \"github.com/cosmos/cosmos-sdk/x/params/types\"\n)\n\nconst (\n\tUsdcIBCDenom = \"ibc/17CD484EE7D9723B847D95015FA3EBD1572FD13BC84FB838F55B18A57450F25B\"\n\tUsdtIBCDenom = \"ibc/4F6A2DEFEA52CD8D90966ADCB2BD0593D3993AB0DF7F6AEB3EFD6167D79237B0\"\n\tEthIBCDenom  = \"ibc/DC186CA7A8C009B43774EBDC825C935CABA9743504CE6037507E6E5CCE12858A\"\n)\n\n// Parameter store keys\nvar (\n\tKeyFee                    = []byte(\"Fee\")                    // fee key\n\tKeyPoolCreationFee        = []byte(\"PoolCreationFee\")        // fee key\n\tKeyTaxRate                = []byte(\"TaxRate\")                // fee key\n\tKeyStandardDenom          = []byte(\"StandardDenom\")          // standard token denom key\n\tKeyMaxStandardCoinPerPool = []byte(\"MaxStandardCoinPerPool\") // max standard coin amount per pool\n\tKeyMaxSwapAmount          = []byte(\"MaxSwapAmount\")          // whitelisted denoms\n\n\tDefaultFee                    = sdk.NewDecWithPrec(0, 0)\n\tDefaultPoolCreationFee        = sdk.NewInt64Coin(sdk.DefaultBondDenom, 0)\n\tDefaultTaxRate                = sdk.NewDecWithPrec(0, 0)\n\tDefaultMaxStandardCoinPerPool = sdk.NewIntWithDecimal(10000, 18)\n\tDefaultMaxSwapAmount          = sdk.NewCoins(\n\t\tsdk.NewCoin(UsdcIBCDenom, sdk.NewIntWithDecimal(10, 6)),\n\t\tsdk.NewCoin(UsdtIBCDenom, sdk.NewIntWithDecimal(10, 6)),\n\t\tsdk.NewCoin(EthIBCDenom, sdk.NewIntWithDecimal(1, 17)),\n\t)\n)\n\n// NewParams is the coinswap params constructor\nfunc NewParams(fee, taxRate sdk.Dec, poolCreationFee sdk.Coin, maxStandardCoinPerPool sdk.Int, maxSwapAmount sdk.Coins) Params {\n\treturn Params{\n\t\tFee:                    fee,\n\t\tTaxRate:                taxRate,\n\t\tPoolCreationFee:        poolCreationFee,\n\t\tMaxStandardCoinPerPool: maxStandardCoinPerPool,\n\t\tMaxSwapAmount:          maxSwapAmount,\n\t}\n}\n\n// ParamKeyTable returns the TypeTable for coinswap module\nfunc ParamKeyTable() paramtypes.KeyTable {\n\treturn paramtypes.NewKeyTable().RegisterParamSet(&Params{})\n}\n\n// ParamSetPairs implements paramtypes.KeyValuePairs\nfunc (p *Params) ParamSetPairs() paramtypes.ParamSetPairs {\n\treturn paramtypes.ParamSetPairs{\n\t\tparamtypes.NewParamSetPair(KeyFee, &p.Fee, validateFee),\n\t\tparamtypes.NewParamSetPair(KeyPoolCreationFee, &p.PoolCreationFee, validatePoolCreationFee),\n\t\tparamtypes.NewParamSetPair(KeyTaxRate, &p.TaxRate, validateTaxRate),\n\t\tparamtypes.NewParamSetPair(KeyMaxStandardCoinPerPool, &p.MaxStandardCoinPerPool, validateMaxStandardCoinPerPool),\n\t\tparamtypes.NewParamSetPair(KeyMaxSwapAmount, &p.MaxSwapAmount, validateMaxSwapAmount),\n\t}\n}\n\n// DefaultParams returns the default coinswap module parameters\nfunc DefaultParams() Params {\n\treturn Params{\n\t\tFee:                    DefaultFee,\n\t\tPoolCreationFee:        DefaultPoolCreationFee,\n\t\tTaxRate:                DefaultTaxRate,\n\t\tMaxStandardCoinPerPool: DefaultMaxStandardCoinPerPool,\n\t\tMaxSwapAmount:          DefaultMaxSwapAmount,\n\t}\n}\n\n// String returns a human readable string representation of the parameters.\nfunc (p Params) String() string {\n\tout, _ := yaml.Marshal(p)\n\treturn string(out)\n}\n\n// Validate returns err if Params is invalid\nfunc (p Params) Validate() error {\n\tif p.Fee.IsNegative() || !p.Fee.LT(sdk.OneDec()) {\n\t\treturn fmt.Errorf(\"fee must be positive and less than 1: %s\", p.Fee.String())\n\t}\n\treturn nil\n}\n\nfunc validateFee(i interface{}) error {\n\tv, ok := i.(sdk.Dec)\n\tif !ok {\n\t\treturn fmt.Errorf(\"invalid parameter type: %T\", i)\n\t}\n\n\tif v.IsNegative() || !v.LT(sdk.OneDec()) {\n\t\treturn fmt.Errorf(\"fee must be positive and less than 1: %s\", v.String())\n\t}\n\n\treturn nil\n}\n\nfunc validatePoolCreationFee(i interface{}) error {\n\tv, ok := i.(sdk.Coin)\n\tif !ok {\n\t\treturn fmt.Errorf(\"invalid parameter type: %T\", i)\n\t}\n\n\tif v.IsNegative() {\n\t\treturn fmt.Errorf(\"poolCreationFee must be positive: %s\", v.String())\n\t}\n\treturn nil\n}\n\nfunc validateTaxRate(i interface{}) error {\n\tv, ok := i.(sdk.Dec)\n\tif !ok {\n\t\treturn fmt.Errorf(\"invalid parameter type: %T\", i)\n\t}\n\n\tif v.IsNegative() || !v.LT(sdk.OneDec()) {\n\t\treturn fmt.Errorf(\"fee must be positive and less than 1: %s\", v.String())\n\t}\n\treturn nil\n}\n\nfunc validateMaxStandardCoinPerPool(i interface{}) error {\n\tv, ok := i.(sdk.Int)\n\tif !ok {\n\t\treturn fmt.Errorf(\"invalid parameter type: %T\", i)\n\t}\n\n\tif !v.IsPositive() {\n\t\treturn fmt.Errorf(\"maxStandardCoinPerPool must be positive: %s\", v.String())\n\t}\n\treturn nil\n}\n\nfunc validateMaxSwapAmount(i interface{}) error {\n\tv, ok := i.(sdk.Coins)\n\tif !ok {\n\t\treturn fmt.Errorf(\"invalid parameter type: %T\", i)\n\t}\n\n\tif err := v.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, coin := range v {\n\t\t// do something with the coin object, such as print its denomination and amount\n\t\tif err := sdk.ValidateDenom(coin.Denom); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif coin.Amount.LT(sdk.ZeroInt()) {\n\t\t\treturn fmt.Errorf(\"coin amount must be positive\")\n\t\t}\n\t}\n\n\treturn nil\n}"
    },
    {
      "filename": "README.md",
      "content": "# Canto audit details\n- Total Prize Pool: $36,500 (Awards in your choice of USDC or CANTO)\n  - HM awards: $27,750 \n  - Analysis awards: $1,500 \n  - QA awards: $750 \n  - Gas awards: $0 \n  - Judge awards: $3,600 \n  - Lookout awards: $2,400\n  - Scout awards: $500 USDC \n- Join [C4 Discord](https://discord.gg/code4rena) to register\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-06-canto/submit)\n- [Read our guidelines for more details](https://docs.code4rena.com/roles/wardens)\n- Starts June 20, 2023 20:00 UTC \n- Ends June 23, 2023 20:00 UTC \n\n❗️Awarding Note for Wardens, Judges, and Lookouts: If you want to claim your awards in $ worth of CANTO, you must follow the steps outlined in this [thread](https://discord.com/channels/810916927919620096/1120698367287234642); otherwise you'll be paid out in USDC.\n\n# Overview of Onboarding Middleware\n\nThe `x/onboarding` module implements IBC middleware for users who don’t have Canto tokens for initial gas spending. Additionally, this module will also convert IBC assets to their ERC20 equivalent if the mapping is already registered using the `x/coinswap` module.\n\n## Background Information\nCanto is a layer-1 EVM built using Cosmos SDK. As such, IBC assets do not exist on the EVM unless an IBC <-> ERC20 mapping is registered. Once the mapping is created, users are able to convert between ERC20s (to use on the EVM) and IBC assets (to IBC elsewhere).  \n\n# Abstract\n\nWe introduce a new module called `onboarding` to help users outside of Canto onboard seamlessly.\n\nThe module automatically swaps a portion of the assets being transferred to Canto network via IBC transfer for Canto without the need for a manual process, and converts the remaining assets to ERC20 tokens on Canto.\n\n# Specification\n\nWhen users transfer assets to the Canto network through Gravity Bridge, the IBC transfer automatically triggers swap and conversion to Canto via IBC middleware. These actions are triggered only when transferred through a whitelisted channel.\n\n## User Flow\n\n- User transfers assets to the Canto network through Gravity Bridge\n- Check recipient address's Canto balance\n- If the balance is less than the minimum threshold (e.g. `4canto`), swap the assets to Canto using the coinswap module\n- If the remaining assets are registered as a ERC20, convert them to ERC20.\n\n`Example:`\n- User bridges 100 USDC to Canto using IBC transfer\n- A small portion of the USDC will be swapped so the user receives 4 Canto tokens\n- The remaining USDC will converted from an IBC asset to ERC20 representation automatically\n- Now users have Canto token to spend on gas fees and do not have to manually convert their USDC IBC asset to an ERC20\n\n\n## Module Parameters\n\n```go\nmessage Params {\n  bool enable_onboarding = 1;\n\n  string auto_swap_threshold = 3 [\n    (gogoproto.customtype) = \"github.com/cosmos/cosmos-sdk/types.Int\",\n    (gogoproto.nullable) = false\n  ];\n\n  repeated string whitelisted_channels = 4;\n}\n```\n\n- **`EnableOnboarding`:** If this value is `false`, then it will disable the auto swap and convert. (default value: `true`)\n- **`AutoSwapThreshold`:** the threshold of the amount of canto to be swapped. When the balance of canto is less than the threshold, the auto swap will be triggered. (default value: `4 canto`)\n- **`WhitelistedChannels`:** The list of channels that will be whitelisted for the auto swap and convert. When the channel is not in the list, the auto swap and convert will not be triggered. (default value: `[\"channel-0\"]` which is a channel for Gravity Bridge)\n\n## OnRecvPacket\n\nThe `onboarding` module implements an IBC Middleware in order to swap and convert IBC transferred assets to Canto and ERC20 tokens with `Keeper.OnRecvPacket` callback.\n\n1. A user performs an IBC transfer to the Canto network. This is done using a `FungibleTokenPacket` IBC packet.\n2. Check that the onboarding conditions are met and skip to the next middleware if any condition is not satisfied:\n   1. onboarding is enabled globally\n   2. channel is authorized\n   3. the recipient account is not a module account\n3. Check the recipient's Canto balance and if the balance is less than the `AutoSwapThreshold`, swap the assets to Canto. Amount of the swapped Canto is always equal to the `AutoSwapThreshold` and the price is determined by the liquidity pool.\n4. Check if the transferred asset is registered in the `x/erc20` module as a ERC20 token pair and the token pair is enabled. If so, convert the remaining assets to ERC20 tokens.\n\n```go\nfunc (k Keeper) OnRecvPacket(\n\tctx sdk.Context,\n\tpacket channeltypes.Packet,\n\tack exported.Acknowledgement,\n) exported.Acknowledgement {\n\t// It always returns original ACK if the packet was a ICS20 transfer.\n\t// Which means even if the swap or conversion fails, it does not revert IBC transfer.\n\t// The asset transferred to the Canto network will still remain in the Canto network.\n\tparams := k.GetParams(ctx)\n\tif !params.EnableOnboarding {\n\t\treturn ack\n\t}\n\t// check source channel is in the whitelist channels\n\tvar found bool\n\tfor _, s := range params.WhitelistedChannels {\n\t\tif s == packet.DestinationChannel {\n\t\t\tfound = true\n\t\t}\n\t}\n\tif !found {\n\t\treturn ack\n\t}\n\t// Get recipient addresses in `canto1` and the original bech32 format\n\t_, recipient, senderBech32, recipientBech32, err := ibc.GetTransferSenderRecipient(packet)\n\tif err != nil {\n\t\treturn channeltypes.NewErrorAcknowledgement(err.Error())\n\t}\n\taccount := k.accountKeeper.GetAccount(ctx, recipient)\n\t// onboarding is not supported for module accounts\n\tif _, isModuleAccount := account.(authtypes.ModuleAccountI); isModuleAccount {\n\t\treturn ack\n\t}\n\tstandardDenom := k.coinswapKeeper.GetStandardDenom(ctx)\n\tvar data transfertypes.FungibleTokenPacketData\n\tif err = transfertypes.ModuleCdc.UnmarshalJSON(packet.GetData(), &data); err != nil {\n\t\t// NOTE: shouldn't happen as the packet has already\n\t\t// been decoded on ICS20 transfer logic\n\t\terr = errorsmod.Wrapf(types.ErrInvalidType, \"cannot unmarshal ICS-20 transfer packet data\")\n\t\treturn channeltypes.NewErrorAcknowledgement(err.Error())\n\t}\n\n\t// parse the transferred denom\n\ttransferredCoin := ibc.GetReceivedCoin(\n\t\tpacket.SourcePort, packet.SourceChannel,\n\t\tpacket.DestinationPort, packet.DestinationChannel,\n\t\tdata.Denom, data.Amount,\n\t)\n\tautoSwapThreshold := k.GetParams(ctx).AutoSwapThreshold\n\tswapCoins := sdk.NewCoin(standardDenom, autoSwapThreshold)\n\tstandardCoinBalance := k.bankKeeper.SpendableCoins(ctx, recipient).AmountOf(standardDenom)\n\tswappedAmount := sdk.ZeroInt()\n\t// Swap for users who have less canto than the autoSwapThreshold.\n\tif standardCoinBalance.LT(autoSwapThreshold) {\n\t\tswappedAmount, err = k.coinswapKeeper.TradeInputForExactOutput(ctx, coinswaptypes.Input{Coin: transferredCoin, Address: recipient.String()}, coinswaptypes.Output{Coin: swapCoins, Address: recipient.String()})\n\t\tif err != nil {\n\t\t\t// no-op: proceed with the remaining logic regardless of \n      // whether the swap is successful or not.\n\t\t}\t\t\n\t}\n\n\t// convert coins to ERC20 token if denom is registered in erc20 module.\n\tpairID := k.erc20Keeper.GetTokenPairID(ctx, transferredCoin.Denom)\n\tif len(pairID) == 0 {\n\t\t// short-circuit: if the denom is not registered, conversion will fail\n\t\t// so we can continue with the rest of the stack\n\t\treturn ack\n\t}\n\tpair, _ := k.erc20Keeper.GetTokenPair(ctx, pairID)\n\tif !pair.Enabled {\n\t\t// no-op: continue with the rest of the stack without conversion\n\t\treturn ack\n\t}\n\tconvertCoin := sdk.NewCoin(transferredCoin.Denom, transferredCoin.Amount.Sub(swappedAmount))\n\t// Build MsgConvertCoin, from recipient to recipient since IBC transfer already occurred\n\tconvertMsg := erc20types.NewMsgConvertCoin(convertCoin, common.BytesToAddress(recipient.Bytes()), recipient)\n\n\t// NOTE: we don't use ValidateBasic the msg since we've already validated\n\t// the ICS20 packet data\n\t// Use MsgConvertCoin to convert the Cosmos Coin to an ERC20\n\tif _, err = k.erc20Keeper.ConvertCoin(sdk.WrapSDKContext(ctx), convertMsg); err != nil {\n\t\treturn ack\n\t}\n\n\t// return original acknowledgement\n\treturn ack\n}\n```\n\nIt is possible that the IBC transaction fails in any point of the stack execution and in that case the onboarding will not be triggered by the transaction, as it will rollback to the previous state. However, the onboarding process is non-atomic, meaning that even if the swap or conversion fails, it does not revert IBC transfer and the asset transferred to the Canto network will still remain in the Canto network.\n\n## Swap\n\nFor swap, we use a forked version of IRISNET's [Coinswap module v1.6](https://github.com/irisnet/irismod/tree/v1.6.0/modules/coinswap), which includes some modifications.\n\nIRISNET's Coinswap module uses an AMM-based swap. This means that onboarding swaps will be handled by AMM also. However, there are some modifications:\n\n- Only token pairs on the whitelist can be created as a pool.\n  - Pool creation fails if the token pair is not on the whitelist.\n  - Initial whitelist: `Canto/USDC.grv`, `Canto/USDT.grv`, `Canto/ETH.grv`\n- There is a limit on the number of Canto tokens for each pool.\n  - Deposits will fail if the amount of Canto for the pool exceeds 10,000 Canto.\n- Double swaps are disabled.\n\nFor risk management purposes, a swap will fail if the input coin amount exceeds a pre-defined limit (10 USDC, 10 USDT, 0.01 ETH) or if the swap amount limit is not defined.\n\n```go\n// Only those IBC denom tokens are allowed to convert to Canto.\nconst (\n\tUsdcIBCDenom = \"ibc/17CD484EE7D9723B847D95015FA3EBD1572FD13BC84FB838F55B18A57450F25B\"\n\tUsdtIBCDenom = \"ibc/4F6A2DEFEA52CD8D90966ADCB2BD0593D3993AB0DF7F6AEB3EFD6167D79237B0\"\n\tEthIBCDenom  = \"ibc/DC186CA7A8C009B43774EBDC825C935CABA9743504CE6037507E6E5CCE12858A\"\n)\n\n// Default parameters\nvar (\n\tDefaultFee                    = sdk.NewDecWithPrec(0, 0)\n\tDefaultPoolCreationFee        = sdk.NewInt64Coin(sdk.DefaultBondDenom, 0)\n\tDefaultTaxRate                = sdk.NewDecWithPrec(0, 0)\n\t// Limit the number of canto tokens for each pool.\n\tDefaultMaxStandardCoinPerPool = sdk.NewIntWithDecimal(10000, 18)\n\t// Pre-defined limits of swap amount for risk management purposes.\n\tDefaultMaxSwapAmount          = sdk.NewCoins(\n\t\tsdk.NewCoin(UsdcIBCDenom, sdk.NewIntWithDecimal(10, 6)),\n\t\tsdk.NewCoin(UsdtIBCDenom, sdk.NewIntWithDecimal(10, 6)),\n\t\tsdk.NewCoin(EthIBCDenom, sdk.NewIntWithDecimal(1, 17)),\n\t)\n)\n```\n\n## Middleware ordering\n\nThe IBC middleware adds custom logic between the core IBC and the underlying application. Middlewares are implemented as stacks so that applications can define multiple layers of custom behavior. Function calls from the IBC core to the application travel from the top-level middleware to the bottom middleware, and then to the application.\n\nFor Canto the middleware stack ordering is defined as follows (from top to bottom):\n\n1. IBC Transfer\n2. Recovery Middleware\n3. Onboarding Middleware\n\n```go\n// app.go\n// create IBC module from bottom to top of stack\nvar transferStack porttypes.IBCModule\n\ntransferStack = transfer.NewIBCModule(app.TransferKeeper)\ntransferStack = recovery.NewIBCMiddleware(*app.RecoveryKeeper, transferStack)\ntransferStack = onboarding.NewIBCMiddleware(*app.OnboardingKeeper, transferStack)\n```\n\nEach module implements their own custom logic in the packet callback `OnRecvPacket`. When a packet arrives from the IBC core, the IBC transfer will be executed first, followed by an attempted recovery, and finally the onboarding will be executed\n\n# Scope\n\n| Contract | SLOC | Purpose | Modules used |  \n| ----------- | ----------- | ----------- | ----------- |\n| [x/onboarding/keeper/ibc_callbacks.go](https://github.com/code-423n4/2023-06-canto/tree/main/Canto/x/onboarding/keeper/ibc_callbacks.go) | 55 | Contains core logic | [`x/coinswap`](https://github.com/code-423n4/2023-06-canto/tree/main/Canto/x/coinswap) |\n| [x/onboarding/types/params.go](https://github.com/code-423n4/2023-06-canto/tree/main/Canto/x/onboarding/types/params.go) | 47 | Contains params for onboarding module | [`x/coinswap`](https://github.com/code-423n4/2023-06-canto/tree/main/Canto/x/coinswap) |\n| [x/coinswap/keeper/pool.go](https://github.com/code-423n4/2023-06-canto/tree/main/Canto/x/coinswap/keeper/pool.go) | 85 | Contains logic for dex pools |  |\n| [x/coinswap/keeper/swap.go](https://github.com/code-423n4/2023-06-canto/tree/main/Canto/x/coinswap/keeper/swap.go) | 102 | Contains logic for dex swaps |  |\n\n## Out of scope\n\n*All other modules are out of scope*\n\n## Scoping Details \n```\n- If you have a public code repo, please share it here:  https://github.com/Canto-Network/Canto\n- How many contracts are in scope?:   0\n- Total SLoC for these contracts?:  349\n- How many external imports are there?: 3  \n- How many separate interfaces and struct definitions are there for the contracts within scope?:  0\n- Does most of your code generally use composition or inheritance?:   Composition\n- How many external calls?:   0\n- What is the overall line coverage percentage provided by your tests?:  100 for business logic\n- Is there a need to understand a separate part of the codebase / get context in order to audit this part of the protocol?: true  \n- Please describe required context:   This audit is for a Cosmos SDK module. Therefore, understanding of how Cosmos SDK blockchains work is required.\n- Does it use an oracle?:  No\n- Does the token conform to the ERC20 standard?:  true\n- Are there any novel or unique curve logic or mathematical models?: No\n- Does it use a timelock function?:  \n- Is it an NFT?: \n- Does it have an AMM?: true   \n- Is it a fork of a popular project?:   false\n- Does it use rollups?:   \n- Is it multi-chain?:  \n- Does it use a side-chain?: false\n- Describe any specific areas you would like addressed.: Our module involves IBC transfers and an AMM. We would like wardens to focus on these aspects.\n- Is this fresh code or have they been audited, if so by who?: Fresh code\n```\n\n# Tests\n### Testing Onboarding Middleware\n```bash\ncd Canto/x/onboarding\ngo test ./...\n```\n### Testing Coinswap Module\n```bash\ncd Canto/x/coinswap\ngo test ./...\n```"
    },
    {
      "filename": "Canto/x/coinswap/keeper/swap.go",
      "content": "package keeper\n\nimport (\n\t\"fmt\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v6/x/coinswap/types\"\n)\n\nfunc (k Keeper) swapCoins(ctx sdk.Context, sender, recipient sdk.AccAddress, coinSold, coinBought sdk.Coin) error {\n\tlptDenom, err := k.GetLptDenomFromDenoms(ctx, coinSold.Denom, coinBought.Denom)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpoolAddr := types.GetReservePoolAddr(lptDenom)\n\tif err := k.bk.SendCoins(ctx, sender, poolAddr, sdk.NewCoins(coinSold)); err != nil {\n\t\treturn err\n\t}\n\n\tif recipient.Empty() {\n\t\trecipient = sender\n\t}\n\n\treturn k.bk.SendCoins(ctx, poolAddr, recipient, sdk.NewCoins(coinBought))\n}\n\n/*\n*\nCalculate the amount of another token to be received based on the exact amount of tokens sold\n@param exactSoldCoin : sold coin\n@param soldTokenDenom : received token's denom\n@return : amount of the token that will be received\n*/\nfunc (k Keeper) calculateWithExactInput(ctx sdk.Context, exactSoldCoin sdk.Coin, boughtTokenDenom string) (sdk.Int, error) {\n\tlptDenom, err := k.GetLptDenomFromDenoms(ctx, exactSoldCoin.Denom, boughtTokenDenom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\treservePoolAddress := types.GetReservePoolAddr(lptDenom).String()\n\treservePool, err := k.GetPoolBalances(ctx, reservePoolAddress)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tinputReserve := reservePool.AmountOf(exactSoldCoin.Denom)\n\toutputReserve := reservePool.AmountOf(boughtTokenDenom)\n\n\tif !inputReserve.IsPositive() {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrInsufficientFunds, fmt.Sprintf(\"reserve pool insufficient funds, actual [%s%s]\", inputReserve.String(), exactSoldCoin.Denom))\n\t}\n\tif !outputReserve.IsPositive() {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrInsufficientFunds, fmt.Sprintf(\"reserve pool insufficient funds, actual [%s%s]\", outputReserve.String(), boughtTokenDenom))\n\t}\n\tparam := k.GetParams(ctx)\n\n\tboughtTokenAmt := GetInputPrice(exactSoldCoin.Amount, inputReserve, outputReserve, param.Fee)\n\treturn boughtTokenAmt, nil\n}\n\n/*\n*\nSell exact amount of a token for buying another, one of them must be standard token\n@param input: exact amount of the token to be sold\n@param output: min amount of the token to be bought\n@param sender: address of the sender\n@param receipt: address of the receiver\n@return: actual amount of the token to be bought\n*/\nfunc (k Keeper) TradeExactInputForOutput(ctx sdk.Context, input types.Input, output types.Output) (sdk.Int, error) {\n\tboughtTokenAmt, err := k.calculateWithExactInput(ctx, input.Coin, output.Coin.Denom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\t// assert that the calculated amount is more than the\n\t// minimum amount the buyer is willing to buy.\n\tif boughtTokenAmt.LT(output.Coin.Amount) {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrConstraintNotMet, fmt.Sprintf(\"insufficient amount of %s, user expected: %s, actual: %s\", output.Coin.Denom, output.Coin.Amount.String(), boughtTokenAmt.String()))\n\t}\n\tboughtToken := sdk.NewCoin(output.Coin.Denom, boughtTokenAmt)\n\n\tinputAddress, err := sdk.AccAddressFromBech32(input.Address)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\toutputAddress, err := sdk.AccAddressFromBech32(output.Address)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tstandardDenom := k.GetStandardDenom(ctx)\n\tvar quoteCoinToSwap sdk.Coin\n\n\tif boughtToken.Denom != standardDenom {\n\t\tquoteCoinToSwap = boughtToken\n\t} else {\n\t\tquoteCoinToSwap = input.Coin\n\t}\n\n\tmaxSwapAmount, err := k.GetMaximumSwapAmount(ctx, quoteCoinToSwap.Denom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tif quoteCoinToSwap.Amount.GT(maxSwapAmount.Amount) {\n\t\treturn sdk.ZeroInt(), sdkerrors.Wrap(types.ErrConstraintNotMet, fmt.Sprintf(\"expected swap amount %s%s exceeding swap amount limit %s%s\", quoteCoinToSwap.Amount.String(), quoteCoinToSwap.Denom, maxSwapAmount.Amount.String(), maxSwapAmount.Denom))\n\t}\n\n\tif err := k.swapCoins(ctx, inputAddress, outputAddress, input.Coin, boughtToken); err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\treturn boughtTokenAmt, nil\n}\n\n/*\n*\nCalculate the amount of the token to be paid based on the exact amount of the token to be bought\n@param exactBoughtCoin\n@param soldTokenDenom\n@return: actual amount of the token to be paid\n*/\nfunc (k Keeper) calculateWithExactOutput(ctx sdk.Context, exactBoughtCoin sdk.Coin, soldTokenDenom string) (sdk.Int, error) {\n\tlptDenom, err := k.GetLptDenomFromDenoms(ctx, exactBoughtCoin.Denom, soldTokenDenom)\n\tif err != nil {\n\t\treturn sdk.ZeroInt(), err\n\t}\n\n\tpoolAddr := types.GetReservePoolAddr(lptDen"
    }
  ]
}