{
  "Title": "M-7: Excess ETH will be stuck in the Fee Manager contract and not swept back to the users",
  "Content": "# Issue M-7: Excess ETH will be stuck in the Fee Manager contract and not swept back to the users \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/269 \n\n## Found by \n0rpse, 0x486776, 0xboriskataa, 1337, AlexCzm, ComposableSecurity, Dots, FastTiger, KupiaSec, Shaheen, Varun\\_05, Yu3H0, ZdravkoHr., alexzoid, ast3ros, cducrest-brainbot, cryptic, cu5t0mPe0, fugazzi, funkornaut, gladiator111, jecikpo, jennifer37, joicygiore, juan, kennedy1030, kn0t, merlinboii, mt030d, radin200, smbv-1923, techOptimizor, trachev, ubl4nk, valentin2304, xiaoming90, y4y, ydlee, zoyi\n## Summary\n\nExcess ETH will be stuck in the Fee Manager contract and not swept back to the users.\n\n## Vulnerability Detail\n\nPer Line 241 below, it is expected that there will be excess ETH residing on the contract at the end of the transaction. The `_refundExcess` function is implemented with the intention of sweeping excess ETH back to the caller of the `mint` function at the end of the transaction.\n\nAssume Bob transfers 0.05 ETH to the Edition contract, but the minting fee ends up being only 0.03 ETH. The _refundExcess function at the end of the function (Line 241 below) is expected to return the excess 0.02 ETH back to Bob.\n\nHowever, it was found that such a design does not work. When the `collectMintFee` function is executed on Line 236 below, the entire amount of ETH (0.05 ETH) will be forwarded to the Fee Manager contract. 0.03 ETH out of 0.05 ETH will be forwarded to the fee recipients, while the remaining 0.02 will be stuck in the Fee Manager contract. The excess 0.02 is not being returned to the Edition contract. Thus, when the `_refundExcess` function is triggered at the end of the function, no ETH will be returned to Bob.\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/editions/Edition.sol#L228\n\n```solidity\nFile: Edition.sol\n228:     function mint(\n229:         address to_,\n230:         uint256 tokenId_,\n231:         uint256 amount_,\n232:         address referrer_,\n233:         bytes calldata data_\n234:     ) external payable override {\n235:         // wake-disable-next-line reentrancy\n236:         FEE_MANAGER.collectMintFee{value: msg.value}(\n237:             this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy\n238:         );\n239: \n240:         _issue(to_, tokenId_, amount_, data_);\n241:         _refundExcess();\n242:     }\n```\n\n> [!IMPORTANT]\n>\n> This issue also affects the `Edition.mintWithComment` and `Edition.mintBatch` functions. The write-up is the same and is omitted for brevity.\n\nIn addition, the Contest's README mentioned that the protocol aims to aims to avoid any direct TVL in this release:\n\n> Please discuss any design choices you made.\n>\n> Fund Management: We chose to delegate fee payouts to 0xSplits v2. The protocol aims to avoid any direct TVL in this release.\n\nIn other words, this means that no assets should be locked within the protocol. However, as shown in the earlier scenario, some assets will be stored in the Fee Manager, breaking this requirement.\n\n## Impact\n\nExcess ETH will be stuck in the Fee Manager contract and not swept back to the users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/editions/Edition.sol#L228\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider forwarding only the required amount of the minting fee to the Fee Manager, so that any excess ETH can be sweeped by the `_refundExcess()` function at the end of the transaction.\n\n```diff\nfunction mint(\n    address to_,\n    uint256 tokenId_,\n    uint256 tokenId_,\n    address referrer_,\n    bytes calldata data_\n) external payable override {\n+\t\tuint256 mintFee = FEE_MANAGER.getMintFee(this, tokenId_, amount_);\n\n    // wake-disable-next-line reentrancy\n-   FEE_MANAGER.collectMintFee{value: msg.value}(\n+   FEE_MANAGER.collectMintFee{value: mintFee}(\n        this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy\n    );\n\n    _issue(to_, tokenId_, amount_, data_);\n    _refundExcess();\n}\n```\n\n\n\n## Discussion\n\n**pqseags**\n\nWill address\n\n**WangSecurity**\n\nFirstly, the `mintFee` is set by the publisher/creator of the work and can be changed at any time. It's safe to assume it's highly unlikely that they will change it every (few) block(s). Moreover, Edition contract has to functions to get the `mintFee` [here](https://github.com/sherlock-audit/2024-04-titles/blob/d7f60952df22da00b772db5d3a8272a988546089/wallflower-contract-v2/src/editions/Edition.sol#L217) and [here](https://github.com/sherlock-audit/2024-04-titles/blob/d7f60952df22da00b772db5d3a8272a988546089/wallflower-contract-v2/src/editions/Edition.sol#L209). Hence, the user may know exactly how much `msg.value` the need to send.\n\nHowever, it doesn't exclude the situation when the `mintFee` is change in the exact same block right before the user mints, resulting in the revert. But the user can mitigate it on their side: call `mintFee` and `mint` in the same call.\n\nTherefore, I believe medium severity is more appropriate here, planning to downgrade the issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "wallflower-contract-v2/src/editions/Edition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Ownable} from \"lib/solady/src/auth/Ownable.sol\";\nimport {ERC2981} from \"lib/solady/src/tokens/ERC2981.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\n\nimport {ERC1155} from \"solady/tokens/ERC1155.sol\";\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\nimport {Node, NodeType, Target, Strategy} from \"src/shared/Common.sol\";\n\nimport {\n    EDITION_MANAGER_ROLE,\n    EDITION_MINTER_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    Metadata,\n    Node,\n    Strategy,\n    Comment,\n    FeeStrategyUpdated,\n    MaxSupplyReached,\n    Minted,\n    NotImplemented,\n    NotOpen,\n    Published,\n    TimeframeUpdated,\n    WorkTransferred\n} from \"src/shared/Common.sol\";\n\n/// @title Edition\n/// @notice An ERC1155 contract representing a collection of related works. Each work is represented by a token ID.\ncontract Edition is IEdition, ERC1155, ERC2981, Initializable, OwnableRoles {\n    using SafeTransferLib for address;\n\n    /// @notice An individual work within the Edition.\n    /// @param creator The creator of the work.\n    /// @param maxSupply The maximum number of mintable tokens for the work.\n    /// @param totalSupply The total number of minted tokens for the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable. If `0`, there is no closing time.\n    /// @param strategy The fee strategy for the work.\n    struct Work {\n        address creator;\n        uint256 maxSupply;\n        uint256 totalSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n    }\n\n    /// @notice The total number of works in the Edition. Also the ID of the latest work.\n    uint256 public totalWorks;\n\n    /// @notice The collection of works in the Edition.\n    mapping(uint256 => Work) public works;\n\n    /// @notice The metadata for the Edition and its works.\n    /// @dev The Edition key is 0, while the work keys are the token IDs.\n    mapping(uint256 => Metadata) public _metadata;\n\n    /// @notice The fee manager contract.\n    FeeManager public FEE_MANAGER;\n\n    /// @notice The TitlesGraph contract.\n    TitlesGraph public GRAPH;\n\n    /// @notice Initialize the Edition contract.\n    /// @param feeManager_ The fee manager contract.\n    /// @param graph_ The TitlesGraph contract.\n    /// @param owner_ The owner of the Edition contract.\n    /// @param controller_ The controller of the Edition contract.\n    /// @dev This function is called by the {EditionFactory} when creating a new Edition to set the fee manager and owner.\n    /// @dev The controller is granted the {EDITION_MANAGER_ROLE} to allow management of the Edition contract.\n    function initialize(\n        FeeManager feeManager_,\n        TitlesGraph graph_,\n        address owner_,\n        address controller_,\n        Metadata calldata metadata_\n    ) external initializer {\n        _initializeOwner(owner_);\n        FEE_MANAGER = feeManager_;\n        GRAPH = graph_;\n\n        _grantRoles(controller_, EDITION_MANAGER_ROLE);\n        _grantRoles(owner_, EDITION_PUBLISHER_ROLE);\n\n        _metadata[0] = metadata_;\n    }\n\n    /// @notice Create a new work in the Edition.\n    /// @param creator_ The creator of the work.\n    /// @param maxSupply_ The maximum number of mintable tokens for the work.\n    /// @param opensAt_ The timestamp after which the work is mintable.\n    /// @param closesAt_ The timestamp after which the work is no longer mintable.\n    /// @param attributions_ The attributions for the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @param metadata_ The metadata for the work.\n    function publish(\n        address creator_,\n        uint256 maxSupply_,\n        uint64 opensAt_,\n        uint64 closesAt_,\n        Node[] calldata attributions_,\n        Strategy calldata strategy_,\n        Metadata calldata metadata_\n    ) external override onlyRoles(EDITION_MANAGER_ROLE) returns (uint256 tokenId) {\n        tokenId = ++totalWorks;\n\n        _metadata[tokenId] = metadata_;\n        works[tokenId] = Work({\n            creator: creator_,\n            totalSupply: 0,\n            maxSupply: maxSupply_,\n            opensAt: opensAt_,\n            closesAt: closesAt_,\n            strategy: FEE_MANAGER.validateStrategy(strategy_)\n        });\n\n        Node memory _node = node(tokenId);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            // wake-disable-next-line reentrancy, unchecked-return-value\n            GRAPH.createEdge(_node, attributions_[i], attributions_[i].data);\n        }\n\n        emit Published(address(this), tokenId);\n    }\n\n    /// @notice Get the name of the Edition.\n    /// @return The name of the Edition.\n    function name() public view override returns (string memory) {\n        return _metadata[0].label;\n    }\n\n    /// @notice Get the name for a given Work.\n    /// @param tokenId The ID of the work.\n    /// @return The name of the work.\n    function name(uint256 tokenId) public view returns (string memory) {\n        return _metadata[tokenId].label;\n    }\n\n    /// @notice Get the owner of the Edition.\n    /// @return The owner of the Edition.\n    /// @dev The owner of the Edition contract has the right to manage roles.\n    function owner() public view override(IEdition, Ownable) returns (address) {\n        return super.owner();\n    }\n\n    function uri() public view returns (string memory) {\n        return _metadata[0].uri;\n    }\n\n    /// @notice Get the URI for the given token ID.\n    /// @param tokenId_ The ID of the token.\n    /// @return The URI for the token.\n    function uri(uint256 tokenId_)\n        public\n        view\n        virtual\n        override(IEdition, ERC1155)\n        returns (string memory)\n    {\n        return _metadata[tokenId_].uri;\n    }\n\n    /// @notice Get the creator of the Edition. Alias for {owner}.\n    /// @return The creator of the Edition.\n    function creator() public view override returns (address) {\n        return owner();\n    }\n\n    /// @notice Get the creator of the given work.\n    /// @param tokenId The ID of the work.\n    /// @return The creator of the work.\n    function creator(uint256 tokenId) public view override returns (address) {\n        return works[tokenId].creator;\n    }\n\n    /// @notice Get the {Node} for the collection.\n    /// @return The node for the edition.\n    function node() public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.COLLECTION_ERC1155,\n            creator: Target({target: owner(), chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: \"\"\n        });\n    }\n\n    /// @notice Get the {Node} for the given work.\n    /// @param tokenId The token ID of the work.\n    /// @return The node for the work.\n    function node(uint256 tokenId) public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.TOKEN_ERC1155,\n            creator: Target({target: works[tokenId].creator, chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: abi.encode(tokenId)\n        });\n    }\n\n    /// @notice Get the mint fee for one token for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The mint fee for the token.\n    function mintFee(uint256 tokenId_) public view returns (uint256) {\n        return mintFee(tokenId_, 1);\n    }\n\n    /// @notice Get the mint fee for an `amount` of tokens for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param amount_ The amount of tokens to mint.\n    /// @return The mint fee for the tokens.\n    function mintFee(uint256 tokenId_, uint256 amount_) public view returns (uint256) {\n        if (tokenId_ == 0 || tokenId_ > totalWorks) return 0;\n        return FEE_MANAGER.getMintFee(works[tokenId_].strategy, amount_).amount;\n    }\n\n    /// @notice Mint a new token for the given work.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mint(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_\n    ) external payable override {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a new token for the given work with a public comment.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @param comment_ The public comment associated with the mint. Emitted as an event.\n    /// @dev This function is used to mint a token with a public comment, allowing the mint to be associated with a message which will be emitted as an event.\n    function mintWithComment(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_,\n        string calldata comment_\n    ) external payable {\n        Strategy memory strategy = works[tokenId_].strategy;\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n\n        emit Comment(address(this), tokenId_, to_, comment_);\n    }\n\n    /// @notice Mint multiple tokens for the given works.\n    /// @param to_ The address to mint the tokens to.\n    /// @param tokenIds_ The IDs of the works to mint.\n    /// @param amounts_ The amounts of each work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address to_,\n        uint256[] calldata tokenIds_,\n        uint256[] calldata amounts_,\n        bytes calldata data_\n    ) external payable {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            Work storage work = works[tokenIds_[i]];\n\n            // wake-disable-next-line reentrancy\n            FEE_MANAGER.collectMintFee{value: msg.value}(\n                this, tokenIds_[i], amounts_[i], msg.sender, address(0), work.strategy\n            );\n\n            _checkTime(work.opensAt, work.closesAt);\n            _updateSupply(work, amounts_[i]);\n        }\n\n        _batchMint(to_, tokenIds_, amounts_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a token to a set of receivers for the given work.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address[] calldata receivers_,\n        uint256 tokenId_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external payable {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, address(0), works[tokenId_].strategy\n        );\n\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, amount_, data_);\n        }\n\n        _refundExcess();\n    }\n\n    /// @notice Mint a token from the given work to a set of receivers.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @dev This function is used to mint one token for each receiver of a given work, bypassing mint fees. It is intended for promotional purposes.\n    function promoMint(address[] calldata receivers_, uint256 tokenId_, bytes calldata data_)\n        external\n        onlyOwnerOrRoles(EDITION_MANAGER_ROLE | EDITION_MINTER_ROLE)\n    {\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, 1, data_);\n        }\n    }\n\n    /// @notice Get the metadata for the given ID.\n    /// @param id_ The ID of the work, or `0` for the Edition.\n    /// @return The metadata for the ID.\n    function metadata(uint256 id_) external view returns (Metadata memory) {\n        return _metadata[id_];\n    }\n\n    /// @notice Get the maximum supply for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The maximum supply for the work.\n    function maxSupply(uint256 tokenId_) external view override returns (uint256) {\n        return works[tokenId_].maxSupply;\n    }\n\n    /// @notice Get the total supply for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The total supply for the work.\n    function totalSupply(uint256 tokenId_) external view override returns (uint256) {\n        return works[tokenId_].totalSupply;\n    }\n\n    /// @notice Get the fee strategy for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The fee strategy for the work.\n    function feeStrategy(uint256 tokenId_) external view override returns (Strategy memory) {\n        return works[tokenId_].strategy;\n    }\n\n    /// @notice Set the fee strategy for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @dev This function only updates the strategy locally and will NOT change the fee route.\n    function setFeeStrategy(uint256 tokenId_, Strategy calldata strategy_) external {\n        if (msg.sender != works[tokenId_].creator) revert Unauthorized();\n        works[tokenId_].strategy = FEE_MANAGER.validateStrategy(strategy_);\n    }\n\n    /// @notice Set the metadata for a given ID.\n    /// @param id_ The ID of the work, or `0` for the Edition\n    /// @param metadata_ The new metadata.\n    function setMetadata(uint256 id_, Metadata calldata metadata_) external {\n        // Only the owner can update the Edition metadata\n        if (id_ == 0 && msg.sender != owner()) revert Unauthorized();\n\n        // Only the creator can update the work metadata\n        if (id_ > 0 && msg.sender != works[id_].creator) revert Unauthorized();\n\n        _metadata[id_] = metadata_;\n    }\n\n    /// @notice Set the ERC2981 royalty target for the given work.\n    /// @param tokenId The ID of the work.\n    /// @param target The address to receive royalties.\n    function setRoyaltyTarget(uint256 tokenId, address target)\n        external\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _setTokenRoyalty(tokenId, target, works[tokenId].strategy.royaltyBps);\n    }\n\n    /// @notice Sets the open and close times for the given work.\n    /// @param tokenId The ID of the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable.\n    /// @dev Only the creator of the work can call this function.\n    function setTimeframe(uint256 tokenId, uint64 opensAt, uint64 closesAt) external {\n        Work storage work = works[tokenId];\n        if (msg.sender != work.creator) revert Unauthorized();\n\n        // Update the open and close times for the work\n        work.opensAt = opensAt;\n        work.closesAt = closesAt;\n\n        emit TimeframeUpdated(address(this), tokenId, opensAt, closesAt);\n    }\n\n    function transferWork(address to_, uint256 tokenId_) external {\n        Work storage work = works[tokenId_];\n        if (msg.sender != work.creator) revert Unauthorized();\n\n        // Transfer the work to the new creator\n        work.creator = to_;\n\n        emit WorkTransferred(address(this), tokenId_, to_);\n    }\n\n    /// @inheritdoc OwnableRoles\n    function grantRoles(address user_, uint256 roles_)\n        public\n        payable\n        override\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _grantRoles(user_, roles_);\n    }\n\n    /// @inheritdoc OwnableRoles\n    function revokeRoles(address user_, uint256 roles_)\n        public\n        payable\n        override\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _removeRoles(user_, roles_);\n    }\n\n    /// @notice Grant the publisher role to the given address, allowing it to publish new works within the Edition.\n    /// @param publisher_ The address to grant the role to.\n    /// @dev This function is used by the owner or manager to grant the {EDITION_PUBLISHER_ROLE} to an address, allowing it to publish new works within the Edition.\n    function grantPublisherRole(address publisher_)\n        external\n        onlyRolesOrOwner(EDITION_MANAGER_ROLE)\n    {\n        _grantRoles(publisher_, EDITION_PUBLISHER_ROLE);\n    }\n\n    /// @notice Revoke the publisher role from the given address, preventing it from publishing new works. Does not affect existing works.\n    /// @param publisher_ The address to revoke the role from.\n    /// @dev This function is used by the owner or manager to revoke the {EDITION_PUBLISHER_ROLE} from an address, preventing it from publishing new works within the Edition.\n    function revokePublisherRole(address publisher_)\n        external\n        onlyRolesOrOwner(EDITION_MANAGER_ROLE)\n    {\n        _removeRoles(publisher_, EDITION_PUBLISHER_ROLE);\n    }\n\n    /// @notice Check if the contract supports the given interface.\n    /// @param interfaceId The interface ID to check.\n    /// @return True if the contract supports the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(IEdition, ERC1155, ERC2981)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Issue tokens for the given work.\n    /// @param to_ The address to issue the tokens to.\n    /// @param tokenId_ The ID of the work to issue.\n    /// @param amount_ The amount of tokens to issue.\n    /// @param data_ The data associated with the issuance. Reserved for future use.\n    /// @dev This function is used by the {mint} and {mintBatch} functions to mint tokens and reverts if the new total supply would exceed the maximum supply.\n    function _issue(address to_, uint256 tokenId_, uint256 amount_, bytes calldata data_)\n        internal\n    {\n        Work storage work = works[tokenId_];\n        _checkTime(work.opensAt, work.closesAt);\n        _updateSupply(work, amount_);\n        _mint(to_, tokenId_, amount_, data_);\n        emit Minted(address(this), tokenId_, to_, amount_, data_);\n    }\n\n    /// @notice Update the total supply for the given work.\n    /// @param work The work to update.\n    /// @param amount_ The amount to add to the total supply.\n    /// @dev This function increments the total supply for a given work and reverts if the new total exceeds the maximum supply.\n    function _updateSupply(Work storage work, uint256 amount_) internal {\n        if ((work.totalSupply += amount_) > work.maxSupply) {\n            revert MaxSupplyReached();\n        }\n    }\n\n    /// @notice Checks that the current block time falls within the given range.\n    /// @param start_ The timestamp after which the work is mintable.\n    /// @param end_ The timestamp after which the work is no longer mintable.\n    /// @dev This function is used to check that the current block time falls within the given range and reverts if not.\n    function _checkTime(uint64 start_, uint64 end_) internal view {\n        if (block.timestamp < start_ || (end_ != 0 && block.timestamp > end_)) {\n            revert NotOpen(start_, end_);\n        }\n    }\n\n    /// @notice Refund any excess ETH sent to the contract.\n    /// @dev This function is called after minting tokens to refund any ETH left in the contract after all fees have been collected.\n    function _refundExcess() internal {\n        if (msg.value > 0 && address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n}"
    },
    {
      "filename": "wallflower-contract-v2/src/editions/Edition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Ownable} from \"lib/solady/src/auth/Ownable.sol\";\nimport {ERC2981} from \"lib/solady/src/tokens/ERC2981.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\n\nimport {ERC1155} from \"solady/tokens/ERC1155.sol\";\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\nimport {Node, NodeType, Target, Strategy} from \"src/shared/Common.sol\";\n\nimport {\n    EDITION_MANAGER_ROLE,\n    EDITION_MINTER_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    Metadata,\n    Node,\n    Strategy,\n    Comment,\n    FeeStrategyUpdated,\n    MaxSupplyReached,\n    Minted,\n    NotImplemented,\n    NotOpen,\n    Published,\n    TimeframeUpdated,\n    WorkTransferred\n} from \"src/shared/Common.sol\";\n\n/// @title Edition\n/// @notice An ERC1155 contract representing a collection of related works. Each work is represented by a token ID.\ncontract Edition is IEdition, ERC1155, ERC2981, Initializable, OwnableRoles {\n    using SafeTransferLib for address;\n\n    /// @notice An individual work within the Edition.\n    /// @param creator The creator of the work.\n    /// @param maxSupply The maximum number of mintable tokens for the work.\n    /// @param totalSupply The total number of minted tokens for the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable. If `0`, there is no closing time.\n    /// @param strategy The fee strategy for the work.\n    struct Work {\n        address creator;\n        uint256 maxSupply;\n        uint256 totalSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n    }\n\n    /// @notice The total number of works in the Edition. Also the ID of the latest work.\n    uint256 public totalWorks;\n\n    /// @notice The collection of works in the Edition.\n    mapping(uint256 => Work) public works;\n\n    /// @notice The metadata for the Edition and its works.\n    /// @dev The Edition key is 0, while the work keys are the token IDs.\n    mapping(uint256 => Metadata) public _metadata;\n\n    /// @notice The fee manager contract.\n    FeeManager public FEE_MANAGER;\n\n    /// @notice The TitlesGraph contract.\n    TitlesGraph public GRAPH;\n\n    /// @notice Initialize the Edition contract.\n    /// @param feeManager_ The fee manager contract.\n    /// @param graph_ The TitlesGraph contract.\n    /// @param owner_ The owner of the Edition contract.\n    /// @param controller_ The controller of the Edition contract.\n    /// @dev This function is called by the {EditionFactory} when creating a new Edition to set the fee manager and owner.\n    /// @dev The controller is granted the {EDITION_MANAGER_ROLE} to allow management of the Edition contract.\n    function initialize(\n        FeeManager feeManager_,\n        TitlesGraph graph_,\n        address owner_,\n        address controller_,\n        Metadata calldata metadata_\n    ) external initializer {\n        _initializeOwner(owner_);\n        FEE_MANAGER = feeManager_;\n        GRAPH = graph_;\n\n        _grantRoles(controller_, EDITION_MANAGER_ROLE);\n        _grantRoles(owner_, EDITION_PUBLISHER_ROLE);\n\n        _metadata[0] = metadata_;\n    }\n\n    /// @notice Create a new work in the Edition.\n    /// @param creator_ The creator of the work.\n    /// @param maxSupply_ The maximum number of mintable tokens for the work.\n    /// @param opensAt_ The timestamp after which the work is mintable.\n    /// @param closesAt_ The timestamp after which the work is no longer mintable.\n    /// @param attributions_ The attributions for the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @param metadata_ The metadata for the work.\n    function publish(\n        address creator_,\n        uint256 maxSupply_,\n        uint64 opensAt_,\n        uint64 closesAt_,\n        Node[] calldata attributions_,\n        Strategy calldata strategy_,\n        Metadata calldata metadata_\n    ) external override onlyRoles(EDITION_MANAGER_ROLE) returns (uint256 tokenId) {\n        tokenId = ++totalWorks;\n\n        _metadata[tokenId] = metadata_;\n        works[tokenId] = Work({\n            creator: creator_,\n            totalSupply: 0,\n            maxSupply: maxSupply_,\n            opensAt: opensAt_,\n            closesAt: closesAt_,\n            strategy: FEE_MANAGER.validateStrategy(strategy_)\n        });\n\n        Node memory _node = node(tokenId);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            // wake-disable-next-line reentrancy, unchecked-return-value\n            GRAPH.createEdge(_node, attributions_[i], attributions_[i].data);\n        }\n\n        emit Published(address(this), tokenId);\n    }\n\n    /// @notice Get the name of the Edition.\n    /// @return The name of the Edition.\n    function name() public view override returns (string memory) {\n        return _metadata[0].label;\n    }\n\n    /// @notice Get the name for a given Work.\n    /// @param tokenId The ID of the work.\n    /// @return The name of the work.\n    function name(uint256 tokenId) public view returns (string memory) {\n        return _metadata[tokenId].label;\n    }\n\n    /// @notice Get the owner of the Edition.\n    /// @return The owner of the Edition.\n    /// @dev The owner of the Edition contract has the right to manage roles.\n    function owner() public view override(IEdition, Ownable) returns (address) {\n        return super.owner();\n    }\n\n    function uri() public view returns (string memory) {\n        return _metadata[0].uri;\n    }\n\n    /// @notice Get the URI for the given token ID.\n    /// @param tokenId_ The ID of the token.\n    /// @return The URI for the token.\n    function uri(uint256 tokenId_)\n        public\n        view\n        virtual\n        override(IEdition, ERC1155)\n        returns (string memory)\n    {\n        return _metadata[tokenId_].uri;\n    }\n\n    /// @notice Get the creator of the Edition. Alias for {owner}.\n    /// @return The creator of the Edition.\n    function creator() public view override returns (address) {\n        return owner();\n    }\n\n    /// @notice Get the creator of the given work.\n    /// @param tokenId The ID of the work.\n    /// @return The creator of the work.\n    function creator(uint256 tokenId) public view override returns (address) {\n        return works[tokenId].creator;\n    }\n\n    /// @notice Get the {Node} for the collection.\n    /// @return The node for the edition.\n    function node() public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.COLLECTION_ERC1155,\n            creator: Target({target: owner(), chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: \"\"\n        });\n    }\n\n    /// @notice Get the {Node} for the given work.\n    /// @param tokenId The token ID of the work.\n    /// @return The node for the work.\n    function node(uint256 tokenId) public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.TOKEN_ERC1155,\n            creator: Target({target: works[tokenId].creator, chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: abi.encode(tokenId)\n        });\n    }\n\n    /// @notice Get the mint fee for one token for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The mint fee for the token.\n    function mintFee(uint256 tokenId_) public view returns (uint256) {\n        return mintFee(tokenId_, 1);\n    }\n\n    /// @notice Get the mint fee for an `amount` of tokens for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param amount_ The amount of tokens to mint.\n    /// @return The mint fee for the tokens.\n    function mintFee(uint256 tokenId_, uint256 amount_) public view returns (uint256) {\n        if (tokenId_ == 0 || tokenId_ > totalWorks) return 0;\n        return FEE_MANAGER.getMintFee(works[tokenId_].strategy, amount_).amount;\n    }\n\n    /// @notice Mint a new token for the given work.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mint(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_\n    ) external payable override {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a new token for the given work with a public comment.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @param comment_ The public comment associated with the mint. Emitted as an event.\n    /// @dev This function is used to mint a token with a public comment, allowing the mint to be associated with a message which will be emitted as an event.\n    function mintWithComment(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_,\n        string calldata comment_\n    ) external payable {\n        Strategy memory strategy = works[tokenId_].strategy;\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n\n        emit Comment(address(this), tokenId_, to_, comment_);\n    }\n\n    /// @notice Mint multiple tokens for the given works.\n    /// @param to_ The address to mint the tokens to.\n    /// @param tokenIds_ The IDs of the works to mint.\n    /// @param amounts_ The amounts of each work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address to_,\n        uint256[] calldata tokenIds_,\n        uint256[] calldata amounts_,\n        bytes calldata data_\n    ) external payable {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            Work storage work = works[tokenIds_[i]];\n\n            // wake-disable-next-line reentrancy\n            FEE_MANAGER.collectMintFee{value: msg.value}(\n                this, tokenIds_[i], amounts_[i], msg.sender, address(0), work.strategy\n            );\n\n            _checkTime(work.opensAt, work.closesAt);\n            _updateSupply(work, amounts_[i]);\n        }\n\n        _batchMint(to_, tokenIds_, amounts_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a token to a set of receivers for the given work.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address[] calldata receivers_,\n        uint256 tokenId_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external payable {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, address(0), works[tokenId_].strategy\n        );\n\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, amount_, data_);\n        }\n\n        _refundExcess();\n    }\n\n    /// @notice Mint a token from the giv"
    }
  ]
}