{
  "Title": "[M01] Deployment can be frontrun",
  "Content": "The [`deploy` function](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/MetaTransactionWalletDeployer.sol#L86-L99) of the [`MetaTransactionWalletDeployer` contract](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/MetaTransactionWalletDeployer.sol#L13) is fronturunnable by any address saved in the [`canDeploy` mapping](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/MetaTransactionWalletDeployer.sol#L23). By analyzing the mempool, allowed addresses will be able to send a transaction that will create a new `MetaTransactionWalletProxy` instance and assign it to the same owner as the original transaction. \n\n\nThis has two different outcomes:\n\n\n* The `owner` address can no longer be set as the owner of another address due to [this `require` statement](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/MetaTransactionWalletDeployer.sol#L90)\n* The attacker can call the proxy’s [`_setAndInitializeImplementation` function](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/Proxy.sol#L101-L111)  with any calldata they want by using the [`initCallData` parameter](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/MetaTransactionWalletDeployer.sol#L93), which will lead to the execution of a [`delegatecall`](https://github.com/celo-org/celo-monorepo/blob/af49272ef57a077ee6e704aad76d506c039798d3/packages/protocol/contracts/common/Proxy.sol#L109) from the `MetaTransactionWalletProxy` context, resulting in the possibility of dynamically loading code from a malicious wallet implementation at runtime.\n\n\nWe can conclude that using a MetaTransactionWallet deployed by a malicious third party via the `MetaTransactionWalletDeployer` is not safe.\n\n\nConsider modifying the `deploy` function to use an implementation address saved in storage by the owner of the `MetaTransactionWalletDeployer` contract and not using this value from untrusted sources such as the parameters of the function.\n\n\n**Update**: *Fixed in [PR#5683](https://github.com/celo-org/celo-monorepo/pull/5683). The `MetaTransationWalletDeployer` contract has been greatly simplified. Now the deployment of `MetaTransactionWalletProxy` proxy contracts is permissionless and does not depend on the deployer contract’s state.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/MetaTransactionWalletDeployer.sol",
      "content": "pragma solidity ^0.5.13;\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"./interfaces/ICeloVersionedContract.sol\";\nimport \"./interfaces/IMetaTransactionWalletDeployer.sol\";\nimport \"./proxies/MetaTransactionWalletProxy.sol\";\nimport \"./ExternalCall.sol\";\nimport \"./Initializable.sol\";\nimport \"./MetaTransactionWallet.sol\";\n\ncontract MetaTransactionWalletDeployer is\n  IMetaTransactionWalletDeployer,\n  ICeloVersionedContract,\n  Initializable,\n  Ownable\n{\n  using SafeMath for uint256;\n  using BytesLib for bytes;\n\n  mapping(address => address) public wallets;\n  mapping(address => bool) public canDeploy;\n\n  event WalletDeployed(address indexed owner, address indexed wallet, address implementation);\n  event DeployerStatusGranted(address indexed addr);\n  event DeployerStatusRevoked(address indexed addr);\n\n  /**\n     * @dev Verifies that the sender is allowed to deploy a wallet\n     */\n  modifier onlyCanDeploy() {\n    require(msg.sender == owner() || canDeploy[msg.sender], \"sender not allowed to deploy wallet\");\n    _;\n  }\n\n  /**\n     * @notice Returns the storage, major, minor, and patch version of the contract.\n     * @return The storage, major, minor, and patch version of the contract.\n     */\n  function getVersionNumber() public pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 0, 0);\n  }\n\n  /**\n     * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n     * @param initialDeployers a list of addresses that are allowed to deploy wallets\n     */\n  function initialize(address[] calldata initialDeployers) external initializer {\n    _transferOwnership(msg.sender);\n    for (uint256 i = 0; i < initialDeployers.length; i++) {\n      _changeDeployerPermission(initialDeployers[i], true);\n    }\n  }\n\n  /**\n     * @notice Change the permission of an address to deploy\n     * @param target The address to be allowed as a deployer\n     * @param allowedToDeploy toggle whether the address is allowed or not\n     */\n  function changeDeployerPermission(address target, bool allowedToDeploy) external onlyOwner {\n    _changeDeployerPermission(target, allowedToDeploy);\n  }\n\n  /**\n     * @notice Implementation of permission change\n     * @param target The address to be allowed as a deployer\n     * @param allowedToDeploy toggle whether the address is allowed or not\n     */\n  function _changeDeployerPermission(address target, bool allowedToDeploy) internal {\n    canDeploy[target] = allowedToDeploy;\n    if (allowedToDeploy) {\n      emit DeployerStatusGranted(target);\n    } else {\n      emit DeployerStatusRevoked(target);\n    }\n  }\n\n  /**\n     * @notice Used to deploy a MetaTransactionWalletProxy, set the implementation,\n     * initialize, transfer ownership and emit an event.\n     * @param owner The external account which will act as signer and owner of the proxy\n     * @param implementation The address of the implementation which the proxy will point to\n     * @param initCallData calldata pointing to a method on implementation used to initialize\n     */\n  function deploy(address owner, address implementation, bytes calldata initCallData)\n    external\n    onlyCanDeploy\n  {\n    require(wallets[owner] == address(0), \"wallet already deployed\");\n\n    MetaTransactionWalletProxy proxy = new MetaTransactionWalletProxy();\n    proxy._setAndInitializeImplementation(implementation, initCallData);\n    proxy._transferOwnership(owner);\n    wallets[owner] = address(proxy);\n\n    emit WalletDeployed(owner, address(proxy), implementation);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/MetaTransactionWalletDeployer.sol",
      "content": "pragma solidity ^0.5.13;\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"./interfaces/ICeloVersionedContract.sol\";\nimport \"./interfaces/IMetaTransactionWalletDeployer.sol\";\nimport \"./proxies/MetaTransactionWalletProxy.sol\";\nimport \"./ExternalCall.sol\";\nimport \"./Initializable.sol\";\nimport \"./MetaTransactionWallet.sol\";\n\ncontract MetaTransactionWalletDeployer is\n  IMetaTransactionWalletDeployer,\n  ICeloVersionedContract,\n  Initializable,\n  Ownable\n{\n  using SafeMath for uint256;\n  using BytesLib for bytes;\n\n  mapping(address => address) public wallets;\n  mapping(address => bool) public canDeploy;\n\n  event WalletDeployed(address indexed owner, address indexed wallet, address implementation);\n  event DeployerStatusGranted(address indexed addr);\n  event DeployerStatusRevoked(address indexed addr);\n\n  /**\n     * @dev Verifies that the sender is allowed to deploy a wallet\n     */\n  modifier onlyCanDeploy() {\n    require(msg.sender == owner() || canDeploy[msg.sender], \"sender not allowed to deploy wallet\");\n    _;\n  }\n\n  /**\n     * @notice Returns the storage, major, minor, and patch version of the contract.\n     * @return The storage, major, minor, and patch version of the contract.\n     */\n  function getVersionNumber() public pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 0, 0);\n  }\n\n  /**\n     * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n     * @param initialDeployers a list of addresses that are allowed to deploy wallets\n     */\n  function initialize(address[] calldata initialDeployers) external initializer {\n    _transferOwnership(msg.sender);\n    for (uint256 i = 0; i < initialDeployers.length; i++) {\n      _changeDeployerPermission(initialDeployers[i], true);\n    }\n  }\n\n  /**\n     * @notice Change the permission of an address to deploy\n     * @param target The address to be allowed as a deployer\n     * @param allowedToDeploy toggle whether the address is allowed or not\n     */\n  function changeDeployerPermission(address target, bool allowedToDeploy) external onlyOwner {\n    _changeDeployerPermission(target, allowedToDeploy);\n  }\n\n  /**\n     * @notice Implementation of permission change\n     * @param target The address to be allowed as a deployer\n     * @param allowedToDeploy toggle whether the address is allowed or not\n     */\n  function _changeDeployerPermission(address target, bool allowedToDeploy) internal {\n    canDeploy[target] = allowedToDeploy;\n    if (allowedToDeploy) {\n      emit DeployerStatusGranted(target);\n    } else {\n      emit DeployerStatusRevoked(target);\n    }\n  }\n\n  /**\n     * @notice Used to deploy a MetaTransactionWalletProxy, set the implementation,\n     * initialize, transfer ownership and emit an event.\n     * @param owner The external account which will act as signer and owner of the proxy\n     * @param implementation The address of the implementation which the proxy will point to\n     * @param initCallData calldata pointing to a method on implementation used to initialize\n     */\n  function deploy(address owner, address implementation, bytes calldata initCallData)\n    external\n    onlyCanDeploy\n  {\n    require(wallets[owner] == address(0), \"wallet already deployed\");\n\n    MetaTransactionWalletProxy proxy = new MetaTransactionWalletProxy();\n    proxy._setAndInitializeImplementation(implementation, initCallData);\n    proxy._transferOwnership(owner);\n    wallets[owner] = address(proxy);\n\n    emit WalletDeployed(owner, address(proxy), implementation);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/Proxy.sol",
      "content": "pragma solidity ^0.5.13;\n/* solhint-disable no-inline-assembly, no-complex-fallback, avoid-low-level-calls */\n\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\n\n/**\n * @title A Proxy utilizing the Unstructured Storage pattern.\n */\ncontract Proxy {\n  // Used to store the address of the owner.\n  bytes32 private constant OWNER_POSITION = bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n  // Used to store the address of the implementation contract.\n  bytes32 private constant IMPLEMENTATION_POSITION = bytes32(\n    uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n  );\n\n  event OwnerSet(address indexed owner);\n  event ImplementationSet(address indexed implementation);\n\n  constructor() public {\n    _setOwner(msg.sender);\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == _getOwner(), \"sender was not owner\");\n    _;\n  }\n\n  /**\n   * @notice Delegates calls to the implementation contract.\n   */\n  function() external payable {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n\n    address implementationAddress;\n\n    // Load the address of the implementation contract from an explicit storage slot.\n    assembly {\n      implementationAddress := sload(implementationPosition)\n    }\n\n    // Avoid checking if address is a contract or executing delegated call when\n    // implementation address is 0x0\n    require(implementationAddress != address(0), \"No Implementation set\");\n    require(Address.isContract(implementationAddress), \"Invalid contract address\");\n\n    assembly {\n      // Extract the position of the transaction data (i.e. function ID and arguments).\n      let newCallDataPosition := mload(0x40)\n      mstore(0x40, add(newCallDataPosition, calldatasize))\n      calldatacopy(newCallDataPosition, 0, calldatasize)\n\n      // Call the smart contract at `implementationAddress` in the context of the proxy contract,\n      // with the same msg.sender and value.\n      let delegatecallSuccess := delegatecall(\n        gas,\n        implementationAddress,\n        newCallDataPosition,\n        calldatasize,\n        0,\n        0\n      )\n\n      // Copy the return value of the call so it can be returned.\n      let returnDataSize := returndatasize\n      let returnDataPosition := mload(0x40)\n      mstore(0x40, add(returnDataPosition, returnDataSize))\n      returndatacopy(returnDataPosition, 0, returnDataSize)\n\n      // Revert or return depending on whether or not the call was successful.\n      switch delegatecallSuccess\n        case 0 {\n          revert(returnDataPosition, returnDataSize)\n        }\n        default {\n          return(returnDataPosition, returnDataSize)\n        }\n    }\n  }\n\n  /**\n   * @notice Transfers ownership of Proxy to a new owner.\n   * @param newOwner Address of the new owner account.\n   */\n  function _transferOwnership(address newOwner) external onlyOwner {\n    _setOwner(newOwner);\n  }\n\n  /**\n   * @notice Sets the address of the implementation contract and calls into it.\n   * @param implementation Address of the new target contract.\n   * @param callbackData The abi-encoded function call to perform in the implementation\n   * contract.\n   * @dev Throws if the initialization callback fails.\n   * @dev If the target contract does not need initialization, use\n   * setImplementation instead.\n   */\n  function _setAndInitializeImplementation(address implementation, bytes calldata callbackData)\n    external\n    payable\n    onlyOwner\n  {\n    _setImplementation(implementation);\n    bool success;\n    bytes memory returnValue;\n    (success, returnValue) = implementation.delegatecall(callbackData);\n    require(success, \"initialization callback failed\");\n  }\n\n  /**\n   * @notice Returns the implementation address.\n   */\n  function _getImplementation() external view returns (address implementation) {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n    // Load the address of the implementation contract from an explicit storage slot.\n    assembly {\n      implementation := sload(implementationPosition)\n    }\n  }\n\n  /**\n   * @notice Sets the address of the implementation contract.\n   * @param implementation Address of the new target contract.\n   * @dev If the target contract needs to be initialized, call\n   * setAndInitializeImplementation instead.\n   */\n  function _setImplementation(address implementation) public onlyOwner {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n\n    require(Address.isContract(implementation), \"Invalid contract address\");\n\n    // Store the address of the implementation contract in an explicit storage slot.\n    assembly {\n      sstore(implementationPosition, implementation)\n    }\n\n    emit ImplementationSet(implementation);\n  }\n\n  /**\n   * @notice Returns the Proxy owner's address.\n   */\n  function _getOwner() public view returns (address owner) {\n    bytes32 position = OWNER_POSITION;\n    // Load the address of the contract owner from an explicit storage slot.\n    assembly {\n      owner := sload(position)\n    }\n  }\n\n  function _setOwner(address newOwner) private {\n    require(newOwner != address(0), \"owner cannot be 0\");\n    bytes32 position = OWNER_POSITION;\n    // Store the address of the contract owner in an explicit storage slot.\n    assembly {\n      sstore(position, newOwner)\n    }\n    emit OwnerSet(newOwner);\n  }\n}"
    }
  ]
}