{
  "Title": "[05] NATSPEC on `OceanAdapter._convertDecimals` should be revised",
  "Content": "\nThe function `_convertDecimals()` from OceanAdapter.sol is an exact copy on Ocean.sol. However, the OceanAdapter version does not return the `truncatedAmount`.\n\n```\n(OceanAdapter.sol)\nfunction _convertDecimals(\n        uint8 decimalsFrom,\n        uint8 decimalsTo,\n        uint256 amountToConvert\n    )\n        internal\n        pure\n>       returns (uint256 convertedAmount)\n```\n\n```\n function _convertDecimals(\n        uint8 decimalsFrom,\n        uint8 decimalsTo,\n        uint256 amountToConvert\n    )\n        internal\n        pure\n>       returns (uint256 convertedAmount, uint256 truncatedAmount)\n```\n\nThe comments on OceanAdapter.sol should be revised accordingly to not reference the `truncatedAmount`.\n\n```\n     * @dev convert a uint256 from one fixed point decimal basis to another,\n     *   returning the truncated amount if a truncation occurs.\n```\n\n[OceanAdapter.sol#L129-L130](https://github.com/code-423n4/2023-11-shellprotocol/blob/485de7383cdf88284ee6bcf2926fb7c19e9fb257/src/adapters/OceanAdapter.sol#L129-L130)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-11-shellprotocol",
  "Code": [
    {
      "filename": "src/adapters/OceanAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Cowri Labs Inc.\n\npragma solidity 0.8.20;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../ocean/IOceanPrimitive.sol\";\nimport \"../ocean/Interactions.sol\";\n\n/**\n * @notice\n *   Helper contract for shell adapters\n */\nabstract contract OceanAdapter is IOceanPrimitive {\n    /// @notice normalized decimals to be compatible with the Ocean.\n    uint8 constant NORMALIZED_DECIMALS = 18;\n\n    /// @notice Ocean address.\n    address public immutable ocean;\n\n    /// @notice external primitive address.\n    address public immutable primitive;\n\n    /// @notice The underlying token address corresponding to the Ocean ID.\n    mapping(uint256 => address) public underlying;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /// @notice only initializing the immutables\n    constructor(address ocean_, address primitive_) {\n        ocean = ocean_;\n        primitive = primitive_;\n    }\n\n    /// @notice only allow the Ocean to call a method\n    modifier onlyOcean() {\n        require(msg.sender == ocean);\n        _;\n    }\n\n    /**\n     * @dev The Ocean must always know the input and output tokens in order to\n     *  do the accounting.  One of the token amounts is chosen by the user, and\n     *  the other amount is chosen by the primitive.  When computeOutputAmount is\n     *  called, the user provides the inputAmount, and the primitive uses this to\n     *  compute the outputAmount\n     * @param inputToken The user is giving this token to the primitive\n     * @param outputToken The primitive is giving this token to the user\n     * @param inputAmount The amount of the inputToken the user is giving to the primitive\n     * @param metadata a bytes32 value that the user provides the Ocean\n     * @dev the unused param is an address field called userAddress\n     */\n    function computeOutputAmount(\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        address,\n        bytes32 metadata\n    )\n        external\n        override\n        onlyOcean\n        returns (uint256 outputAmount)\n    {\n        unwrapToken(inputToken, inputAmount);\n\n        // handle the unwrap fee scenario\n        uint256 unwrapFee = inputAmount / IOceanInteractions(ocean).unwrapFeeDivisor();\n        uint256 unwrappedAmount = inputAmount - unwrapFee;\n\n        outputAmount = primitiveOutputAmount(inputToken, outputToken, unwrappedAmount, metadata);\n\n        wrapToken(outputToken, outputAmount);\n    }\n\n    /**\n     * @notice Not implemented for this primitive\n     */\n    function computeInputAmount(\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 outputAmount,\n        address userAddress,\n        bytes32 maximumInputAmount\n    )\n        external\n        override\n        onlyOcean\n        returns (uint256 inputAmount)\n    {\n        revert();\n    }\n\n    /**\n     * @notice used to fetch the Ocean interaction ID\n     */\n    function _fetchInteractionId(address token, uint256 interactionType) internal pure returns (bytes32) {\n        uint256 packedValue = uint256(uint160(token));\n        packedValue |= interactionType << 248;\n        return bytes32(abi.encode(packedValue));\n    }\n\n    /**\n     * @notice calculates Ocean ID for a underlying token\n     */\n    function _calculateOceanId(address tokenAddress, uint256 tokenId) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(tokenAddress, tokenId)));\n    }\n\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @notice returning 0 here since this primitive should not have any tokens\n     */\n    function getTokenSupply(uint256 tokenId) external view override returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev convert a uint256 from one fixed point decimal basis to another,\n     *   returning the truncated amount if a truncation occurs.\n     * @dev fn(from, to, a) => b\n     * @dev a = (x * 10**from) => b = (x * 10**to), where x is constant.\n     * @param amountToConvert the amount being converted\n     * @param decimalsFrom the fixed decimal basis of amountToConvert\n     * @param decimalsTo the fixed decimal basis of the returned convertedAmount\n     * @return convertedAmount the amount after conversion\n     */\n    function _convertDecimals(\n        uint8 decimalsFrom,\n        uint8 decimalsTo,\n        uint256 amountToConvert\n    )\n        internal\n        pure\n        returns (uint256 convertedAmount)\n    {\n        if (decimalsFrom == decimalsTo) {\n            // no shift\n            convertedAmount = amountToConvert;\n        } else if (decimalsFrom < decimalsTo) {\n            // Decimal shift left (add precision)\n            uint256 shift = 10 ** (uint256(decimalsTo - decimalsFrom));\n            convertedAmount = amountToConvert * shift;\n        } else {\n            // Decimal shift right (remove precision) -> truncation\n            uint256 shift = 10 ** (uint256(decimalsFrom - decimalsTo));\n            convertedAmount = amountToConvert / shift;\n        }\n    }\n\n    function primitiveOutputAmount(\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        bytes32 metadata\n    )\n        internal\n        virtual\n        returns (uint256 outputAmount);\n\n    function wrapToken(uint256 tokenId, uint256 amount) internal virtual;\n\n    function unwrapToken(uint256 tokenId, uint256 amount) internal virtual;\n}"
    }
  ]
}