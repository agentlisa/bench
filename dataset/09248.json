{
  "Title": "[M-01] SpeedBumpPriceGate.sol#addGate() Lack of input validation may casue div by 0 error",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/SpeedBumpPriceGate.sol#L43\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/SpeedBumpPriceGate.sol#L43\n\n```solidity\n    gate.priceIncreaseDenominator = priceIncreaseDenominator;\n```\n\nIf `priceIncreaseDenominator` is set to `0` when `addGate()`, in `passThruGate()` the tx will revert at L72 because of div by 0.\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/SpeedBumpPriceGate.sol#L71-L72\n\n```solidity\n    // multiply by the price increase factor\n    gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n```\n\n### Recommendation\n\nConsider adding a check in `addGate()` to require `priceIncreaseDenominator > 0`.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-factorydao-contest",
  "Code": [
    {
      "filename": "contracts/SpeedBumpPriceGate.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IPriceGate.sol\";\n\n/// @title A factory pattern for a price gate whose price increases exponentially on purchase and decays linearly thereafter\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract has no management key, anyone can add a gate\n/// @dev Note passing thru the gate forwards all gas, so beneficiary can be a contract, possibly malicious\ncontract SpeedBumpPriceGate is IPriceGate {\n\n    // this represents a single gate\n    struct Gate {\n        uint priceIncreaseFactor;\n        uint priceIncreaseDenominator;\n        uint lastPrice;\n        uint decayFactor;\n        uint priceFloor;\n        uint lastPurchaseBlock;\n        address beneficiary;\n    }\n\n    // array-like mapping of gate structs\n    mapping (uint => Gate) public gates;\n    // count the gates as they come in!\n    uint public numGates;\n\n    /// @notice Add a price gate to the list of available price gates\n    /// @dev Anyone can call this, but it must be connected to MerkleIdentity via priceGateIndex to be used\n    /// @dev The price increase factor is split into numerator and denominator to enable fractions (wow! I love fractions!)\n    /// @param priceFloor the starting price and the lowest price that can be reached via decay\n    /// @param priceDecay the per-block rate at which the price reduces until it hits the price floor\n    /// @param priceIncrease the numerator of the factor by which the price multiplies when a purchase occurs\n    /// @param priceIncreaseDenominator the denominator of the price increase factor\n    /// @param beneficiary who receives the proceeds from a purchase\n    function addGate(uint priceFloor, uint priceDecay, uint priceIncrease, uint priceIncreaseDenominator, address beneficiary) external {\n        // prefix operator increments then evaluates\n        Gate storage gate = gates[++numGates];\n        gate.priceFloor = priceFloor;\n        gate.decayFactor = priceDecay;\n        gate.priceIncreaseFactor = priceIncrease;\n        gate.priceIncreaseDenominator = priceIncreaseDenominator;\n        gate.beneficiary = beneficiary;\n    }\n\n    /// @notice Get the cost of passing thru this gate\n    /// @param index which gate are we talking about?\n    /// @return _ethCost the amount of ether required to pass thru this gate\n    function getCost(uint index) override public view returns (uint _ethCost) {\n        Gate memory gate = gates[index];\n        // compute the linear decay\n        uint decay = gate.decayFactor * (block.number - gate.lastPurchaseBlock);\n        // gate.lastPrice - decay < gate.priceFloor (left side could underflow)\n        if (gate.lastPrice < decay + gate.priceFloor) {\n            return gate.priceFloor;\n        } else {\n            return gate.lastPrice - decay;\n        }\n    }\n\n    /// @notice Pass thru this gate, should be called by MerkleIndex\n    /// @dev This can be called by anyone, devs can call it to test it on mainnet\n    /// @param index which gate are we passing thru?\n    function passThruGate(uint index, address) override external payable {\n        uint price = getCost(index);\n        require(msg.value >= price, 'Please send more ETH');\n\n        // bump up the price\n        Gate storage gate = gates[index];\n        // multiply by the price increase factor\n        gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n        // move up the reference\n        gate.lastPurchaseBlock = block.number;\n\n        // pass thru the ether\n        if (msg.value > 0) {\n            // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n            (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\");\n            require(sent, 'ETH transfer failed');\n        }\n    }\n}"
    }
  ]
}