{
  "Title": "[5] contracts/NFTCollectionFactory.sol",
  "Content": "\n### 5.1 `.isContract()`\n\nOn lines [182](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L182), and [203](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L203) instead of checking if `addr.isContract()` to avoid setting the addresses to EOA by mistake it would be best to pass the code hash instead and check the code hash at those addresses. So for example:\n\nBefore:\n\n```solidity\nconstructor(address _rolesContract) {\n\trequire(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\"); \n\n\trolesContract = IRoles(_rolesContract);\n}\n\n```\n\nAfter:\n\n```solidity\nconstructor(address _rolesContract, bytes32 codehash) {\n\trequire(_rolesContract.codehash == codehash, \"NFTCollectionFactory: RolesContract is not a contract\");\n\n\trolesContract = IRoles(_rolesContract);\n}\n```\n\nThis is a stronger requirement since it would guarantee that the addresses are contracts and also they have the required code hash. For the functions to pass the `require` statements you would need to make 2 mistakes, one for the address and the other for the code hash. The probability of making this mistake should be theoretically lower than just passing a wrong address.\n\n### 5.2 `versionNFTDropCollection`\n\nDoesn't have an initializer like `versionNFTCollection`.\n\n### 5.3 a better name  can be chosen for `rolesContract`\n\n`rolerManager` might be a better name for this immutable variable and would make it easier to remember what it does (ref. line [104](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L104)).\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-foundation",
  "Code": [
    {
      "filename": "contracts/NFTCollectionFactory.sol",
      "content": "/*\n  ･\n   *　★\n      ･ ｡\n        　･　ﾟ☆ ｡\n  　　　 *　★ ﾟ･｡ *  ｡\n          　　* ☆ ｡･ﾟ*.｡\n      　　　ﾟ *.｡☆｡★　･\n​\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *　\n      ･ ｡\n　　　　･　　ﾟ☆ ｡\n  　　　 *　★ ﾟ･｡ *  ｡\n          　　* ☆ ｡･ﾟ*.｡\n      　　　ﾟ *.｡☆｡★　･\n    *　　ﾟ｡·*･｡ ﾟ*\n  　　　☆ﾟ･｡°*. ﾟ\n　 ･ ﾟ*｡･ﾟ★｡\n　　･ *ﾟ｡　　 *\n　･ﾟ*｡★･\n ☆∴｡　*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./interfaces/ICollectionFactory.sol\";\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IRoles.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\nimport \"./mixins/shared/Gap10000.sol\";\n\n/**\n * @title A factory to create NFT collections.\n * @notice Call this factory to create NFT collections.\n * @dev This creates and initializes an ERC-1165 minimal proxy pointing to a NFT collection contract implementation.\n */\ncontract NFTCollectionFactory is ICollectionFactory, Initializable, Gap10000 {\n  using AddressUpgradeable for address;\n  using Clones for address;\n  using Strings for uint32;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address of the implementation all new NFTCollections will leverage.\n   * @dev When this is changed, `versionNFTCollection` is incremented.\n   * @return The implementation address for NFTCollection.\n   */\n  address public implementationNFTCollection;\n\n  /**\n   * @notice The implementation version of new NFTCollections.\n   * @dev This is auto-incremented each time `implementationNFTCollection` is changed.\n   * @return The current NFTCollection implementation version.\n   */\n  uint32 public versionNFTCollection;\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The address of the implementation all new NFTDropCollections will leverage.\n   * @dev When this is changed, `versionNFTDropCollection` is incremented.\n   * @return The implementation address for NFTDropCollection.\n   */\n  address public implementationNFTDropCollection;\n\n  /**\n   * @notice The implementation version of new NFTDropCollections.\n   * @dev This is auto-incremented each time `implementationNFTDropCollection` is changed.\n   * @return The current NFTDropCollection implementation version.\n   */\n  uint32 public versionNFTDropCollection;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice The contract address which manages common roles.\n   * @dev Defines a centralized admin role definition for permissioned functions below.\n   * @return The contract address with role definitions.\n   */\n  IRoles public immutable rolesContract;\n\n  /**\n   * @notice Emitted when the implementation of NFTCollection used by new collections is updated.\n   * @param implementation The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTCollectionUpdated(address indexed implementation, uint256 indexed version);\n\n  /**\n   * @notice Emitted when the implementation of NFTDropCollection used by new collections is updated.\n   * @param implementationNFTDropCollection The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTDropCollectionUpdated(\n    address indexed implementationNFTDropCollection,\n    uint256 indexed version\n  );\n\n  /**\n   * @notice Emitted when a new NFTCollection is created from this factory.\n   * @param collection The address of the new NFT collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param version The implementation version used by the new collection.\n   * @param name The name of the collection contract created.\n   * @param symbol The symbol of the collection contract created.\n   * @param nonce The nonce used by the creator when creating the collection,\n   * used to define the address of the collection.\n   */\n  event NFTCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    uint256 indexed version,\n    string name,\n    string symbol,\n    uint256 nonce\n  );\n\n  /**\n   * @notice Emitted when a new NFTDropCollection is created from this factory.\n   * @param collection The address of the new NFT drop collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max `tokenID` for this collection.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @param version The implementation version used by the new NFTDropCollection collection.\n   * @param nonce The nonce used by the creator to create this collection.\n   */\n  event NFTDropCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    address indexed approvedMinter,\n    string name,\n    string symbol,\n    string baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint256 maxTokenId,\n    address paymentAddress,\n    uint256 version,\n    uint256 nonce\n  );\n\n  modifier onlyAdmin() {\n    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\n    _;\n  }\n\n  /**\n   * @notice Defines requirements for the collection drop factory at deployment time.\n   * @param _rolesContract The address of the contract defining roles for collections to use.\n   */\n  constructor(address _rolesContract) {\n    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\n\n    rolesContract = IRoles(_rolesContract);\n  }\n\n  /**\n   * @notice Initializer called after contract creation.\n   * @dev This is used so that this factory will resume versions from where our original factory had left off.\n   * @param _versionNFTCollection The current implementation version for NFTCollections.\n   */\n  function initialize(uint32 _versionNFTCollection) external initializer {\n    versionNFTCollection = _versionNFTCollection;\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTCollection collection implementation address.\n   */\n  function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTCollection++;\n    }\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTCollectionInitializer(_implementation).initialize(\n      payable(address(rolesContract)),\n      string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n      string.concat(\"NFTv\", versionNFTCollection.toString())\n    );\n\n    emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTDropCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTDropCollection collection implementation address.\n   */\n  function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTDropCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTDropCollection++;\n    }\n\n    emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTDropCollectionInitializer(_implementation).initialize(\n      payable(address(this)),\n      string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n      string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n      \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n      0x1337000000000000000000000000000000000000000000000000000000001337,\n      1,\n      address(0),\n      payable(0)\n    );\n  }\n\n  /**\n   * @notice Create a new collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTCollection(\n    string calldata name,\n    string calldata symbol,\n    uint256 nonce\n  ) external returns (address collection) {\n    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\n\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n\n    emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n  }\n\n  /**\n   * @notice Create a new drop collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address.\n   * @dev All params other than `paymentAddress` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentAddress(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    address payable paymentAddress\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        paymentAddress != msg.sender ? paymentAddress : payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address derived from the factory.\n   * @dev All params other than `paymentAddressFactoryCall` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddressFactoryCall The contract call which will return the address to use for payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentFactory(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    CallWithoutValue memory paymentAddressFactoryCall\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        AddressLibrary.callAndReturnContractAddress(paymentAddressFactoryCall),\n        nonce\n      );\n  }\n\n  function _createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    address payable paymentAddress,\n    uint256 nonce\n  ) private returns (address collection) {\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTDropCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTDropCollectionInitializer(collection).initialize(\n      payable(msg.sender),\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      approvedMinter,\n      paymentAddress\n    );\n\n    emit NFTDropCollectionCreated(\n      collection,\n      msg.sender,\n      approvedMinter,\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      paymentAddress,\n      versionNFTDropCollection,\n      nonce\n    );\n  }\n\n  /**\n   * @notice Returns the address of a collection given the current implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  /**\n   * @notice Returns the address of a NFTDropCollection collection given the current\n   * implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTDropCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTDropCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  function _getSalt(address creator, uint256 nonce) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(creator, nonce));\n  }\n}"
    },
    {
      "filename": "contracts/NFTCollectionFactory.sol",
      "content": "/*\n  ･\n   *　★\n      ･ ｡\n        　･　ﾟ☆ ｡\n  　　　 *　★ ﾟ･｡ *  ｡\n          　　* ☆ ｡･ﾟ*.｡\n      　　　ﾟ *.｡☆｡★　･\n​\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *　\n      ･ ｡\n　　　　･　　ﾟ☆ ｡\n  　　　 *　★ ﾟ･｡ *  ｡\n          　　* ☆ ｡･ﾟ*.｡\n      　　　ﾟ *.｡☆｡★　･\n    *　　ﾟ｡·*･｡ ﾟ*\n  　　　☆ﾟ･｡°*. ﾟ\n　 ･ ﾟ*｡･ﾟ★｡\n　　･ *ﾟ｡　　 *\n　･ﾟ*｡★･\n ☆∴｡　*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./interfaces/ICollectionFactory.sol\";\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IRoles.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\nimport \"./mixins/shared/Gap10000.sol\";\n\n/**\n * @title A factory to create NFT collections.\n * @notice Call this factory to create NFT collections.\n * @dev This creates and initializes an ERC-1165 minimal proxy pointing to a NFT collection contract implementation.\n */\ncontract NFTCollectionFactory is ICollectionFactory, Initializable, Gap10000 {\n  using AddressUpgradeable for address;\n  using Clones for address;\n  using Strings for uint32;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address of the implementation all new NFTCollections will leverage.\n   * @dev When this is changed, `versionNFTCollection` is incremented.\n   * @return The implementation address for NFTCollection.\n   */\n  address public implementationNFTCollection;\n\n  /**\n   * @notice The implementation version of new NFTCollections.\n   * @dev This is auto-incremented each time `implementationNFTCollection` is changed.\n   * @return The current NFTCollection implementation version.\n   */\n  uint32 public versionNFTCollection;\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The address of the implementation all new NFTDropCollections will leverage.\n   * @dev When this is changed, `versionNFTDropCollection` is incremented.\n   * @return The implementation address for NFTDropCollection.\n   */\n  address public implementationNFTDropCollection;\n\n  /**\n   * @notice The implementation version of new NFTDropCollections.\n   * @dev This is auto-incremented each time `implementationNFTDropCollection` is changed.\n   * @return The current NFTDropCollection implementation version.\n   */\n  uint32 public versionNFTDropCollection;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice The contract address which manages common roles.\n   * @dev Defines a centralized admin role definition for permissioned functions below.\n   * @return The contract address with role definitions.\n   */\n  IRoles public immutable rolesContract;\n\n  /**\n   * @notice Emitted when the implementation of NFTCollection used by new collections is updated.\n   * @param implementation The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTCollectionUpdated(address indexed implementation, uint256 indexed version);\n\n  /**\n   * @notice Emitted when the implementation of NFTDropCollection used by new collections is updated.\n   * @param implementationNFTDropCollection The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTDropCollectionUpdated(\n    address indexed implementationNFTDropCollection,\n    uint256 indexed version\n  );\n\n  /**\n   * @notice Emitted when a new NFTCollection is created from this factory.\n   * @param collection The address of the new NFT collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param version The implementation version used by the new collection.\n   * @param name The name of the collection contract created.\n   * @param symbol The symbol of the collection contract created.\n   * @param nonce The nonce used by the creator when creating the collection,\n   * used to define the address of the collection.\n   */\n  event NFTCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    uint256 indexed version,\n    string name,\n    string symbol,\n    uint256 nonce\n  );\n\n  /**\n   * @notice Emitted when a new NFTDropCollection is created from this factory.\n   * @param collection The address of the new NFT drop collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max `tokenID` for this collection.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @param version The implementation version used by the new NFTDropCollection collection.\n   * @param nonce The nonce used by the creator to create this collection.\n   */\n  event NFTDropCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    address indexed approvedMinter,\n    string name,\n    string symbol,\n    string baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint256 maxTokenId,\n    address paymentAddress,\n    uint256 version,\n    uint256 nonce\n  );\n\n  modifier onlyAdmin() {\n    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\n    _;\n  }\n\n  /**\n   * @notice Defines requirements for the collection drop factory at deployment time.\n   * @param _rolesContract The address of the contract defining roles for collections to use.\n   */\n  constructor(address _rolesContract) {\n    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\n\n    rolesContract = IRoles(_rolesContract);\n  }\n\n  /**\n   * @notice Initializer called after contract creation.\n   * @dev This is used so that this factory will resume versions from where our original factory had left off.\n   * @param _versionNFTCollection The current implementation version for NFTCollections.\n   */\n  function initialize(uint32 _versionNFTCollection) external initializer {\n    versionNFTCollection = _versionNFTCollection;\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTCollection collection implementation address.\n   */\n  function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTCollection++;\n    }\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTCollectionInitializer(_implementation).initialize(\n      payable(address(rolesContract)),\n      string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n      string.concat(\"NFTv\", versionNFTCollection.toString())\n    );\n\n    emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTDropCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTDropCollection collection implementation address.\n   */\n  function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTDropCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTDropCollection++;\n    }\n\n    emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTDropCollectionInitializer(_implementation).initialize(\n      payable(address(this)),\n      string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n      string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n      \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n      0x1337000000000000000000000000000000000000000000000000000000001337,\n      1,\n      address(0),\n      payable(0)\n    );\n  }\n\n  /**\n   * @notice Create a new collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTCollection(\n    string calldata name,\n    string calldata symbol,\n    uint256 nonce\n  ) external returns (address collection) {\n    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\n\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n\n    emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n  }\n\n  /**\n   * @notice Create a new drop collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address.\n   * @dev All params other than `paymentAddress` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this col"
    }
  ]
}