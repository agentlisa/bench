{
  "Title": "[L-01] `migrate()` still does transfers when the transfer is to the same pool, and this can be done multiple times",
  "Content": "<h2 id=\"l-01-migrate-still-does-transfers-when-the-transfer-is-to-the-same-pool-and-this-can-be-done-multiple-times\" style=\"position:relative;\"><a href=\"#l-01-migrate-still-does-transfers-when-the-transfer-is-to-the-same-pool-and-this-can-be-done-multiple-times\" aria-label=\"l 01 migrate still does transfers when the transfer is to the same pool and this can be done multiple times permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] <code>migrate()</code> still does transfers when the transfer is to the same pool, and this can be done multiple times</h2>\n<p>There’s no check that the old address isn’t the same as the new address, and there’s no check that the migration has already happened</p>\n<p><em>There is 1 instance of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"28\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">protocol</span><span class=\"mtk1\">/</span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">zaps</span><span class=\"mtk1\">/</span><span class=\"mtk12\">PoolMigrationZap</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">   #</span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">52</span><span class=\"mtk1\">       </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">migrate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">oldPoolAddress_</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">53</span><span class=\"mtk1\">           </span><span class=\"mtk12\">ILiquidityPool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">oldPool_</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">ILiquidityPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">oldPoolAddress_</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">54</span><span class=\"mtk1\">           </span><span class=\"mtk12\">IERC20</span><span class=\"mtk1\"> </span><span class=\"mtk12\">lpToken_</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">oldPool_</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getLpToken</span><span class=\"mtk1\">());</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">55</span><span class=\"mtk1\">           </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">lpTokenAmount_</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">lpToken_</span><span class=\"mtk1\">.</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">56</span><span class=\"mtk1\">           </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">lpTokenAmount_</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">\"No LP Tokens\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">57</span><span class=\"mtk1\">           </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">oldPool_</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getWithdrawalFee</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">lpTokenAmount_</span><span class=\"mtk1\">) == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">\"withdrawal fee not 0\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">58</span><span class=\"mtk1\">:          </span><span class=\"mtk12\">lpToken_</span><span class=\"mtk1\">.</span><span class=\"mtk11\">safeTransferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">lpTokenAmount_</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52-L58\">https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52-L58</a></p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/zaps/PoolMigrationZap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/zaps/IPoolMigrationZap.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\n\n/**\n * This is a Zap contract to assist in the migration from the V1 Backd Pools to the new Backd Pools.\n */\ncontract PoolMigrationZap is IPoolMigrationZap {\n    using SafeERC20 for IERC20;\n\n    mapping(address => ILiquidityPool) internal _underlyingNewPools; // A mapping from underlyings to new pools\n\n    event Migrated(address user, address oldPool, address newPool, uint256 lpTokenAmount); // Emitted when a migration is completed\n\n    constructor(address newAddressProviderAddress_) {\n        address[] memory newPools_ = IAddressProvider(newAddressProviderAddress_).allPools();\n        for (uint256 i; i < newPools_.length; ++i) {\n            ILiquidityPool newPool_ = ILiquidityPool(newPools_[i]);\n            address underlying_ = newPool_.getUnderlying();\n            _underlyingNewPools[underlying_] = newPool_;\n            if (underlying_ == address(0)) continue;\n            IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max);\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Migrates all of a users balance from the old pools to the new pools.\n     * @dev The user must have balance in all pools given, otherwise transaction will revert.\n     * @param oldPoolAddresses_ The list of old pools to migrate for the user.\n     */\n    function migrateAll(address[] calldata oldPoolAddresses_) external override {\n        for (uint256 i; i < oldPoolAddresses_.length; ) {\n            migrate(oldPoolAddresses_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Migrates a users balance from an old pool to a new pool.\n     * @dev The user must have balance in the pool given, otherwise transaction will revert.\n     * @param oldPoolAddress_ The old pool to migrate for the user.\n     */\n    function migrate(address oldPoolAddress_) public override {\n        ILiquidityPool oldPool_ = ILiquidityPool(oldPoolAddress_);\n        IERC20 lpToken_ = IERC20(oldPool_.getLpToken());\n        uint256 lpTokenAmount_ = lpToken_.balanceOf(msg.sender);\n        require(lpTokenAmount_ != 0, \"No LP Tokens\");\n        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\");\n        lpToken_.safeTransferFrom(msg.sender, address(this), lpTokenAmount_);\n        uint256 underlyingAmount_ = oldPool_.redeem(lpTokenAmount_);\n        address underlying_ = oldPool_.getUnderlying();\n        ILiquidityPool newPool_ = _underlyingNewPools[underlying_];\n        uint256 ethValue_ = underlying_ == address(0) ? underlyingAmount_ : 0;\n        newPool_.depositFor{value: ethValue_}(msg.sender, underlyingAmount_);\n        emit Migrated(msg.sender, address(oldPool_), address(newPool_), lpTokenAmount_);\n    }\n}"
    }
  ]
}