{
  "Title": "M-1: Use `safeTransferFrom()` instead of `transferFrom()` for outgoing erc721 transfers",
  "Content": "# Issue M-1: Use `safeTransferFrom()` instead of `transferFrom()` for outgoing erc721 transfers \n\nSource: https://github.com/sherlock-audit/2022-09-harpie-judging/tree/main/001-M \n\n## Found by \nCodingNameKiki, millers.planet, 0xNazgul, cccz, Bnke0x0, Chom, Waze, IEatBabyCarrots, TomJ, Tomo, hickuphh3, pashov, sach1r0, Sm4rty, IllIllI, chainNue, Dravee\n\n## Summary\n\nIt is recommended to use `safeTransferFrom()` instead of `transferFrom()` when transferring ERC721s out of the vault.\n\n## Vulnerability Detail\n\nThe `transferFrom()` method is used instead of `safeTransferFrom()`, which I assume is a gas-saving measure. I however argue that this isn’t recommended because:\n\n- [OpenZeppelin’s documentation](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-) discourages the use of `transferFrom()`; use `safeTransferFrom()` whenever possible\n- The recipient could have logic in the `onERC721Received()` function, which is only triggered in the `safeTransferFrom()` function and not in `transferFrom()`. A notable example of such contracts is the Sudoswap pair:\n\n```solidity\nfunction onERC721Received(\n  address,\n  address,\n  uint256 id,\n  bytes memory\n) public virtual returns (bytes4) {\n  IERC721 _nft = nft();\n  // If it's from the pair's NFT, add the ID to ID set\n  if (msg.sender == address(_nft)) {\n    idSet.add(id);\n  }\n  return this.onERC721Received.selector;\n}\n```\n\n- It helps ensure that the recipient is indeed capable of handling ERC721s.\n\n## Impact\n\nWhile unlikely because the recipient is the function caller, there is the potential loss of NFTs should the recipient is unable to handle the sent ERC721s.\n\n## Code Snippet\n\n[https://github.com/Harpieio/contracts/blob/97083d7ce8ae9d85e29a139b1e981464ff92b89e/contracts/Vault.sol#L137](https://github.com/Harpieio/contracts/blob/97083d7ce8ae9d85e29a139b1e981464ff92b89e/contracts/Vault.sol#L137)\n\n## Recommendation\n\nUse `safeTransferFrom()` when sending out the NFT from the vault.\n\n```diff\n- IERC721(_erc721Address).transferFrom(address(this), msg.sender, _id);\n+ IERC721(_erc721Address).safeTransferFrom(address(this), msg.sender, _id);\n```\n\nNote that the vault would have to inherit the `IERC721Receiver` contract if the change is applied to `Transfer.sol` as well.\n\n## Harpie Team\n\nAdded safeTransferFrom in withdraw function. Fix [here](https://github.com/Harpieio/contracts/pull/4/commits/aff1ee38e081194dd7d88835c37c864e759fd289).\n\n## Lead Senior Watson\n\nMakes sense to be compatible with contracts as recipients. Confirmed fix. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/3",
  "Code": [
    {
      "filename": "contracts/Vault.sol",
      "content": "// contracts/delegator.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @notice This contract is designed to hold ERC20s and ERC721s from user wallets and allow only them to withdraw.\n/// Users will have to pay a designated fee in order to withdraw their ERC20s and ERC721s.\n/// In case we need to reduce fees for each user, we have reduceFee functions we can call. \ncontract Vault {\n    using ECDSA for bytes32;\n\n    /// @dev We use safeERC20 for noncompliant ERC20s\n    using SafeERC20 for IERC20;\n\n    /// @dev This struct defines the amount of an ERC20 stored, and the fee required to withdraw\n    struct erc20Struct {\n        uint128 amountStored;\n        uint128 fee;\n    }\n\n    /// @dev This struct defines if an ERC721 id is stored, and the fee required to withdraw\n    struct erc721Struct {\n        bool isStored;\n        uint128 fee;\n    }\n\n    /// @dev The address of the Transfer contract linked to this contract\n    address private immutable transferer;\n    /// @notice The serverSigner is an EOA responsible for providing the signature of changeRecipientAddress\n    address private immutable serverSigner;\n    /// @notice The feeController is an EOA that's able to only reduce the fees of users and withdraw our fees\n    address payable private feeController;\n\n    /// @dev This mapping is a one-to-one that defines who can withdraw a user's transfered funds\n    mapping(address => address) private _recipientAddress;\n    \n    /// @dev These mappings define the tokens a user can withdraw from the Vault and the fees to withdraw\n    mapping(address => mapping(address => erc20Struct)) private _erc20WithdrawalAllowances;\n    mapping(address => mapping(address => mapping (uint256 => erc721Struct))) private _erc721WithdrawalAllowances;\n\n    /// @dev This mapping prevents the reuse of a signature to changeRecipientAddress\n    mapping(bytes32 => bool) private _isChangeRecipientMessageConsumed;\n\n    /// @dev Immutables like transferer and serverSigner are set during construction for safety\n    constructor(address _transferer, address _serverSigner, address payable _feeController) {\n        transferer = _transferer;\n        serverSigner = _serverSigner;\n        feeController = _feeController;\n    }\n\n    /// @notice Allow users to set up a recipient address for collecting stored assets\n    function setupRecipientAddress(address _recipient) external {\n        require(_recipientAddress[msg.sender] == address(0), \"You already have registered a recipient address\");\n        _recipientAddress[msg.sender] = _recipient;\n    }   \n\n    /// @notice Allow users to change their recipient address. Requires a signature from our serverSigner\n    /// to allow this transaction to fire\n    function changeRecipientAddress(bytes memory _signature, address _newRecipientAddress, uint256 expiry) external {\n        /// @dev Have server sign a message in the format [protectedWalletAddress, newRecipientAddress, exp, vaultAddress]\n        /// msg.sender == protectedWalletAddress (meaning that the protected wallet will submit this transaction)\n        /// @notice We require the extra signature in case we add 2fa in some way in future\n\n        bytes32 data = keccak256(abi.encodePacked(msg.sender, _newRecipientAddress, expiry, address(this)));\n        require(data.toEthSignedMessageHash().recover(_signature) == serverSigner, \"Invalid signature. Signature source may be incorrect, or a provided parameter is invalid\");\n        require(block.timestamp <= expiry, \"Signature expired\");\n        require(_isChangeRecipientMessageConsumed[data] == false, \"Already used this signature\");\n        _isChangeRecipientMessageConsumed[data] = true;\n        _recipientAddress[msg.sender] = _newRecipientAddress;\n    }\n\n    /// @notice View which address is authorized to withdraw assets\n    function viewRecipientAddress(address _originalAddress) public view returns (address) {\n        return _recipientAddress[_originalAddress];\n    }\n\n\n    /// @notice Log functions fire when the vault receives an ERC20 or ER721 from Transfer.sol\n    function logIncomingERC20(address _originalAddress, address _erc20Address, uint256 _amount, uint128 _fee) external{\n        require(msg.sender == transferer, \"Only the transferer contract can log funds.\");\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee += _fee;\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].amountStored += uint128(_amount);\n    }\n\n    function logIncomingERC721(address _originalAddress, address _erc721Address, uint256 _id, uint128 _fee) external {\n        require(msg.sender == transferer, \"Only the transferer contract can log funds.\");\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee += _fee;\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].isStored = true;\n    }\n\n\n    /// @notice These functions can be called to view an addresses' stored balances and the fees to withdraw them\n    function canWithdrawERC20(address _originalAddress, address _erc20Address) public view returns (uint256) {\n        return _erc20WithdrawalAllowances[_originalAddress][_erc20Address].amountStored;\n    }\n\n    function canWithdrawERC721(address _originalAddress, address _erc721Address, uint256 _id) public view returns (bool) {\n        return _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].isStored;\n    }\n\n    function erc20Fee(address _originalAddress, address _erc20Address) public view returns (uint128) {\n        return _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee;\n    }\n\n    function erc721Fee(address _originalAddress, address _erc721Address, uint256 _id) public view returns (uint128) {\n        return _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee;\n    }\n\n    /// @notice Withdrawal functions allow users to withdraw their assets after paying the ETH withdrawal fee\n    /// @dev A few guards are placed to avoid erroneous withdrawals.\n    /// - caller must be a recipient address of the assets of _originalAddress\n    /// - there must be an allowance in the _originalAddress's withdrawal allowance\n    /// - the _erc20Address must not be address(this)\n    /// - the msg.value must be >= the withdrawal fee\n    function withdrawERC20(address _originalAddress, address _erc20Address) payable external {\n        require(_recipientAddress[_originalAddress] == msg.sender, \"Function caller is not an authorized recipientAddress.\");\n        require(_erc20Address != address(this), \"The vault is not a token address\");\n        require(canWithdrawERC20(_originalAddress, _erc20Address) > 0, \"No withdrawal allowance.\");\n        require(msg.value >= _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee, \"Insufficient payment.\");\n\n        uint256 amount = canWithdrawERC20(_originalAddress, _erc20Address);\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].amountStored = 0;\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee = 0;\n        IERC20(_erc20Address).safeTransfer(msg.sender, amount);\n    }\n    function withdrawERC721(address _originalAddress, address _erc721Address, uint256 _id) payable external {\n        require(_recipientAddress[_originalAddress] == msg.sender, \"Function caller is not an authorized recipientAddress.\");\n        require(_erc721Address != address(this), \"The vault is not a token address\");\n        require(canWithdrawERC721(_originalAddress, _erc721Address, _id), \"Insufficient withdrawal allowance.\");\n        require(msg.value >= _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee, \"Insufficient payment.\");\n\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].isStored = false;\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee = 0;\n        IERC721(_erc721Address).transferFrom(address(this), msg.sender, _id);\n    }\n\n    /// @notice These functions allow Harpie to reduce (but never increase) the fee upon a user\n    function reduceERC20Fee(address _originalAddress, address _erc20Address, uint128 _reduceBy) external returns (uint128) {\n        require(msg.sender == feeController, \"msg.sender must be feeController.\");\n        require(_erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee >= _reduceBy, \"You cannot reduce more than the current fee.\");\n        _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee -= _reduceBy;\n        return _erc20WithdrawalAllowances[_originalAddress][_erc20Address].fee;\n    }\n\n    function reduceERC721Fee(address _originalAddress, address _erc721Address, uint128 _id, uint128 _reduceBy) external returns (uint128) {\n        require(msg.sender == feeController, \"msg.sender must be feeController.\");\n        require(_erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee >= _reduceBy, \"You cannot reduce more than the current fee.\");\n        _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee -= _reduceBy;\n        return _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee;\n    }\n\n    /// @notice This function allows us to withdraw the fees we collect in this contract\n    function withdrawPayments(uint256 _amount) external {\n        require(msg.sender == feeController, \"msg.sender must be feeController.\");\n        require(address(this).balance >= _amount, \"Cannot withdraw more than the amount in the contract.\");\n        feeController.transfer(_amount);\n    }\n\n    /// @notice This function allows us to change the signer that we use to reduce and withdraw fees\n    function changeFeeController(address payable _newFeeController) external {\n        require(msg.sender == feeController, \"msg.sender must be feeController.\");\n        feeController = _newFeeController;\n    }\n}"
    }
  ]
}