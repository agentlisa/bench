{
  "Title": "PSP22Wrapper's deposit_for/withdraw_to Implementations Might Lead to Stuck Tokens",
  "Content": "The [`deposit_for` function](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/token/psp22/extensions/wrapper.rs#L55) of `PSP22Wrapper` allows users to wrap their PSP22 tokens by depositing them in the contract, minting the same amount of wrapped tokens to the given `account`. For instance, if Alice owns 10 `Token`s and deposits them in the `WToken` contract, the latter will own 10 `Token`s, and Alice will own 10 `WToken`s.\n\n\nAdditionally, the contract implements [the `_recover` function](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/token/psp22/extensions/wrapper.rs#L90), which enables anyone to sweep `Token`s mistakenly sent to the `WToken` contract. For example, if Bob sends 5 `Token`s to `WToken`, then the `_recover` function will allow the caller to sweep an amount of:\n\n\n\n\n```\n underlying_balance(self) - self.total_supply() = 15 - 10 = 5\n\n```\n\n\nThe `WToken`-to-`Token` ratio will return to 1:1.\n\n\nHowever, there are no validations verifying whether the `account` parameter of the `deposit_for` function is not the wrapper itself. This means that if a user sends the wrapper contract's address as a parameter, the `_recover` function will account for these tokens as minted, and they will not be recoverable. For instance, let's say that Bob deposits his 5 Tokens through the `deposit_for` function instead, but sends the wrapper address as a parameter. Then, the `_recover` function will calculate the number of `Token`s to sweep as follows:\n\n\n\n\n```\n underlying_balance(self) - self.total_supply() = 15 - 15 = 0\n\n```\n\n\nConsequently, those tokens will be stuck in the wrapper token forever.\n\n\nNote that a similar behavior can occur when calling the `withdraw_to` function sending the wrapper contract address as the `account` parameter.\n\n\nConsider adding a check in the `deposit_for` and `withdraw_to` functions to ensure that the `account` parameter is not the wrapper contract's address, preventing such tokens from getting trapped in the wrapper token indefinitely.\n\n\n***Update:** Resolved in [pull request #140](https://github.com/Brushfam/openbrush-contracts/pull/140) at commit [57d90f8](https://github.com/Brushfam/openbrush-contracts/pull/140/commits/57d90f8ee3156b2009ea160e6a79eab328942b6d).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/token/psp22/extensions/wrapper.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    psp22,\n    psp22::extensions::wrapper,\n    traits::psp22::{\n        extensions::wrapper::*,\n        *,\n    },\n};\nuse ink::{\n    env::CallFlags,\n    prelude::vec::Vec,\n};\nuse openbrush::traits::{\n    AccountId,\n    Balance,\n    Storage,\n    String,\n};\npub use psp22::{\n    Internal as _,\n    InternalImpl as _,\n    PSP22Impl,\n};\npub use wrapper::Internal as _;\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    pub underlying: Option<AccountId>,\n}\n\npub trait PSP22WrapperImpl: Storage<Data> + Internal + psp22::Internal {\n    fn deposit_for(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        self._deposit(amount)?;\n        psp22::Internal::_mint_to(self, account, amount)\n    }\n\n    fn withdraw_to(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        psp22::Internal::_burn_from(self, Self::env().caller(), amount)?;\n        self._withdraw(account, amount)\n    }\n}\n\npub trait Internal {\n    /// Mint wrapped token to cover any underlyingTokens that would have been transfered by mistake. Internal\n    /// function that can be exposed with access control if desired.\n    fn _recover(&mut self, account: AccountId) -> Result<Balance, PSP22Error>;\n\n    /// helper function to transfer the underlying token from caller to the contract\n    fn _deposit(&mut self, amount: Balance) -> Result<(), PSP22Error>;\n\n    /// helper function to transfer the underlying token\n    fn _withdraw(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error>;\n\n    /// helper function to get balance of underlying tokens in the contract\n    fn _underlying_balance(&mut self) -> Balance;\n\n    /// Initalize the wrapper token with defining the underlying PSP22 token\n    ///\n    /// `underlying` is the token to be wrapped\n    fn _init(&mut self, underlying: AccountId);\n\n    /// Getter for caller to `PSP22Wrapper` of `underlying`\n    fn _underlying(&mut self) -> Option<AccountId>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal + psp22::Internal + PSP22 {\n    fn _recover(&mut self, account: AccountId) -> Result<Balance, PSP22Error> {\n        let value = Internal::_underlying_balance(self) - self.total_supply();\n        psp22::Internal::_mint_to(self, account, value)?;\n        Ok(value)\n    }\n\n    fn _deposit(&mut self, amount: Balance) -> Result<(), PSP22Error> {\n        if let Some(underlying) = Internal::_underlying(self) {\n            PSP22Ref::transfer_from_builder(\n                &underlying,\n                Self::env().caller(),\n                Self::env().account_id(),\n                amount,\n                Vec::<u8>::new(),\n            )\n            .call_flags(CallFlags::default().set_allow_reentry(true))\n            .try_invoke()\n            .unwrap()\n            .unwrap()\n        } else {\n            Err(PSP22Error::Custom(String::from(\"Underlying not initialized\")))\n        }\n    }\n\n    fn _withdraw(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        if let Some(underlying) = Internal::_underlying(self) {\n            PSP22Ref::transfer_builder(&underlying, account, amount, Vec::<u8>::new())\n                .call_flags(CallFlags::default().set_allow_reentry(true))\n                .try_invoke()\n                .unwrap()\n                .unwrap()\n        } else {\n            Err(PSP22Error::Custom(String::from(\"Underlying not initialized\")))\n        }\n    }\n\n    fn _underlying_balance(&mut self) -> Balance {\n        if let Some(underlying) = Internal::_underlying(self) {\n            PSP22Ref::balance_of(&underlying, Self::env().account_id())\n        } else {\n            0\n        }\n    }\n\n    fn _init(&mut self, underlying: AccountId) {\n        self.data().underlying.set(&Some(underlying));\n    }\n\n    fn _underlying(&mut self) -> Option<AccountId> {\n        self.data().underlying.get_or_default()\n    }\n}"
    },
    {
      "filename": "contracts/src/token/psp22/extensions/wrapper.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    psp22,\n    psp22::extensions::wrapper,\n    traits::psp22::{\n        extensions::wrapper::*,\n        *,\n    },\n};\nuse ink::{\n    env::CallFlags,\n    prelude::vec::Vec,\n};\nuse openbrush::traits::{\n    AccountId,\n    Balance,\n    Storage,\n    String,\n};\npub use psp22::{\n    Internal as _,\n    InternalImpl as _,\n    PSP22Impl,\n};\npub use wrapper::Internal as _;\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    pub underlying: Option<AccountId>,\n}\n\npub trait PSP22WrapperImpl: Storage<Data> + Internal + psp22::Internal {\n    fn deposit_for(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        self._deposit(amount)?;\n        psp22::Internal::_mint_to(self, account, amount)\n    }\n\n    fn withdraw_to(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        psp22::Internal::_burn_from(self, Self::env().caller(), amount)?;\n        self._withdraw(account, amount)\n    }\n}\n\npub trait Internal {\n    /// Mint wrapped token to cover any underlyingTokens that would have been transfered by mistake. Internal\n    /// function that can be exposed with access control if desired.\n    fn _recover(&mut self, account: AccountId) -> Result<Balance, PSP22Error>;\n\n    /// helper function to transfer the underlying token from caller to the contract\n    fn _deposit(&mut self, amount: Balance) -> Result<(), PSP22Error>;\n\n    /// helper function to transfer the underlying token\n    fn _withdraw(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error>;\n\n    /// helper function to get balance of underlying tokens in the contract\n    fn _underlying_balance(&mut self) -> Balance;\n\n    /// Initalize the wrapper token with defining the underlying PSP22 token\n    ///\n    /// `underlying` is the token to be wrapped\n    fn _init(&mut self, underlying: AccountId);\n\n    /// Getter for caller to `PSP22Wrapper` of `underlying`\n    fn _underlying(&mut self) -> Option<AccountId>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal + psp22::Internal + PSP22 {\n    fn _recover(&mut self, account: AccountId) -> Result<Balance, PSP22Error> {\n        let value = Internal::_underlying_balance(self) - self.total_supply();\n        psp22::Internal::_mint_to(self, account, value)?;\n        Ok(value)\n    }\n\n    fn _deposit(&mut self, amount: Balance) -> Result<(), PSP22Error> {\n        if let Some(underlying) = Internal::_underlying(self) {\n            PSP22Ref::transfer_from_builder(\n                &underlying,\n                Self::env().caller(),\n                Self::env().account_id(),\n                amount,\n                Vec::<u8>::new(),\n            )\n            .call_flags(CallFlags::default().set_allow_reentry(true))\n            .try_invoke()\n            .unwrap()\n            .unwrap()\n        } else {\n            Err(PSP22Error::Custom(String::from(\"Underlying not initialized\")))\n        }\n    }\n\n    fn _withdraw(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        if let Some(underlying) = Internal::_underlying(self) {\n            PSP22Ref::transfer_builder(&underlying, account, amount, Vec::<u8>::new())\n                .call_flags(CallFlags::default().set_allow_reentry(true))\n                .try_invoke()\n                .unwrap()\n                .unwrap()\n        } else {\n            Err(PSP22Error::Custom(String::from(\"Underlying not initialized\")))\n        }\n    }\n\n    fn _underlying_balance(&mut self) -> Balance {\n        if let Some(underlying) = Internal::_underlying(self) {\n            PSP22Ref::balance_of(&underlying, Self::env().account_id())\n        } else {\n            0\n        }\n    }\n\n    fn _init(&mut self, underlying: AccountId) {\n        self.data().underlying.set(&Some(underlying));\n    }\n\n    fn _underlying(&mut self) -> Option<AccountId> {\n        self.data().underlying.get_or_default()\n    }\n}"
    }
  ]
}