{
  "Title": "Killing a Gauge Could Result in Stuck Funds",
  "Content": "When a gauge is killed using the [`killGauge`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L298) or [`killGaugeTotally`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L316) functions in the `VoterV3` contract, the gauge-related data is cleared out. However, it is possible that the killed gauge has already been voted for and [its respective vote weight](https://github.com/ThenafiBNB/THENA-Contracts/blob/faa7161bf11f1f68d1744e534ca9e1b6c18ab04a/contracts/VoterV3.sol#L442) has been added to the [period's total vote weight](https://github.com/ThenafiBNB/THENA-Contracts/blob/faa7161bf11f1f68d1744e534ca9e1b6c18ab04a/contracts/VoterV3.sol#L455). The period's total weight is not adjusted when a gauge is killed, resulting in the portion of the reward that is committed to that gauge remaining unused and getting stuck in the contract.\n\n\nMore specifically, there are two possible problematic scenarios, regarding the rewards accounting of the current and previous period relative to the time that a gauge is killed.\n\n\n1. **Effects on the currently active voting period.** If a gauge is killed in the middle of a period, it's possible that this gauge has already been voted for by some users, so it already [contributes to `totalWeightPerEpoch`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L455), which is later [used to compute the `index` for that period](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L692). As a consequence, the killed gauge's share will eventually remain stuck in the contract. In fact, `totalWeightsPerEpoch` should be updated when killing a gauge to discard the respective votes and distribute the whole $THE emissions amount to the remaining gauges.\n2. **Effects on the previous voting period.** It is possible that a gauge is killed at a time when [a voting period has been updated](https://github.com/ThenafiBNB/THENA-Contracts/blob/faa7161bf11f1f68d1744e534ca9e1b6c18ab04a/contracts/MinterUpgradeable.sol#L159) but the reward amounts have not been distributed yet. This is possible because updating the period and distributing the respective rewards to the gauges require two separate actions ([period update](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/MinterUpgradeable.sol#L159) and [rewards distribution](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L729)). In this scenario, the `totalWeightsPerEpoch` that has been used [to compute `index`](https://github.com/ThenafiBNB/THENA-Contracts/blob/faa7161bf11f1f68d1744e534ca9e1b6c18ab04a/contracts/VoterV3.sol#L692-L694) includes the killed gauge's weight, [even if its share of rewards will not be attributed to it after it's killed](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L845-L846). Thus its share will eventually remain unused and stuck in the `VoterV3` contract.\n\n\nWhen a gauge is killed, consider updating the `totalWeightsPerEpoch` value of the currently active voting period in order to distribute the whole reward amount to the remaining gauges. In addition, consider consolidating the [reward amount notification](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L686) and [the distribution of the gauges' rewards](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L729) into one single action in order to avoid losing part of the previous period's rewards when a gauge is killed.\n\n\n***Update:** Partially resolved in [pull request #3](https://github.com/ThenafiBNB/THENA-Contracts/pull/3) at commit [7864885](https://github.com/ThenafiBNB/THENA-Contracts/pull/3/commits/7864885b12f53b8d8224cdca360c7004b0aa0c35). The effects on the currently active voting period are handled by updating `totalWeightPerEpoch` when killing a gauge. Regarding the effects on the previous voting period, the Retro-Thena team stated:*\n\n\n\n> *We do not expect any gauge to be killed between a period update and rewards distribution because of our off-chain procedures that make sure to trigger the rewards distribution right after each period update.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/VoterV3.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IBribeFactory.sol';\nimport './interfaces/IGauge.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IMinter.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/IAlgebraFactory.sol';\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n\ninterface IHypervisor {\n    function pool() external view returns(address);\n}\n\ncontract VoterV3 is IVoter, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n\n    \n    bool internal initflag;\n\n    address public _ve;                                         // the ve token that governs these contracts\n    address public factory;                                     // classic stable and volatile Pair Factory\n    address[] public factories;                                 // Array with all the pair factories\n    address internal base;                                      // $the token\n    address public gaugefactory;                                // gauge factory\n    address[] public gaugeFactories;                            // array with all the gauge factories\n    address public bribefactory;                                // bribe factory (internal and external)\n    address public minter;                                      // minter mints $the each epoch\n    address public permissionRegistry;                          // registry to check accesses\n    address[] public pools;                                     // all pools viable for incentives\n\n\n    uint internal index;                                        // gauge index\n    uint internal constant DURATION = 7 days;                   // rewards are released over 7 days\n    uint public VOTE_DELAY;                                     // delay between votes in seconds\n    uint public constant MAX_VOTE_DELAY = 7 days;               // Max vote delay allowed\n\n\n    mapping(address => uint) internal supplyIndex;              // gauge    => index\n    mapping(address => uint) public claimable;                  // gauge    => claimable $the\n    mapping(address => address) public gauges;                  // pool     => gauge\n    mapping(address => uint) public gaugesDistributionTimestmap;// gauge    => last Distribution Time\n    mapping(address => address) public poolForGauge;            // gauge    => pool\n    mapping(address => address) public internal_bribes;         // gauge    => internal bribe (only fees)\n    mapping(address => address) public external_bribes;         // gauge    => external bribe (real bribes)\n    mapping(uint => mapping(address => uint256)) public votes;  // nft      => pool     => votes\n    mapping(uint => address[]) public poolVote;                 // nft      => pools\n    mapping(uint => mapping(address => uint)) internal weightsPerEpoch; // timestamp => pool => weights\n    mapping(uint => uint) internal totWeightsPerEpoch;         // timestamp => total weights\n    mapping(uint => uint) public usedWeights;                   // nft      => total voting weight of user\n    mapping(uint => uint) public lastVoted;                     // nft      => timestamp of last vote\n    mapping(address => bool) public isGauge;                    // gauge    => boolean [is a gauge?]\n    mapping(address => bool) public isWhitelisted;              // token    => boolean [is an allowed token?]\n    mapping(address => bool) public isAlive;                    // gauge    => boolean [is the gauge alive?]\n    mapping(address => bool) public isFactory;                  // factory  => boolean [the pair factory exists?]\n    mapping(address => bool) public isGaugeFactory;             // g.factory=> boolean [the gauge factory exists?]\n\n    event GaugeCreated(address indexed gauge, address creator, address internal_bribe, address indexed external_bribe, address indexed pool);\n    event GaugeKilled(address indexed gauge);\n    event GaugeRevived(address indexed gauge);\n    event Voted(address indexed voter, uint tokenId, uint256 weight);\n    event Abstained(uint tokenId, uint256 weight);\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\n    event Whitelisted(address indexed whitelister, address indexed token);\n    event Blacklisted(address indexed blacklister, address indexed token);\n\n    constructor() {}\n\n    function initialize(address __ve, address _factory, address  _gauges, address _bribes) initializer public {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        _ve = __ve;\n        base = IVotingEscrow(__ve).token();\n\n        factory = _factory;\n        factories.push(factory);\n        isFactory[factory] = true;\n\n        gaugefactory = _gauges;\n        gaugeFactories.push(_gauges);\n        isGaugeFactory[_gauges] = true;\n\n        bribefactory = _bribes;\n\n        minter = msg.sender;\n        permissionRegistry = msg.sender;\n\n        VOTE_DELAY = 0;\n        initflag = false;\n    }\n\n \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    MODIFIERS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    modifier VoterAdmin() {\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender), 'ERR: VOTER_ADMIN');\n        _;\n    }\n\n    modifier Governance() {\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"GOVERNANCE\",msg.sender), 'ERR: GOVERNANCE');\n        _;\n    }\n\n    \n    /// @notice initialize the voter contract \n    /// @param  _tokens array of tokens to whitelist\n    /// @param  _minter the minter of $the\n    function _init(address[] memory _tokens, address _permissionsRegistry, address _minter) external {\n        require(msg.sender == minter || IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender));\n        require(!initflag);\n        for (uint i = 0; i < _tokens.length; i++) {\n            _whitelist(_tokens[i]);\n        }\n        minter = _minter;\n        permissionRegistry = _permissionsRegistry;\n        initflag = true;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VoterAdmin\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice set vote delay in seconds\n    function setVoteDelay(uint _delay) external VoterAdmin {\n        require(_delay != VOTE_DELAY);\n        require(_delay <= MAX_VOTE_DELAY);\n        VOTE_DELAY = _delay;\n    }\n\n    /// @notice Set a new Minter\n    function setMinter(address _minter) external VoterAdmin {\n        require(_minter != address(0));\n        minter = _minter;\n    }\n\n    /// @notice Set a new Bribe Factory\n    function setBribeFactory(address _bribeFactory) external VoterAdmin {\n        bribefactory = _bribeFactory;\n    }\n\n    /// @notice Set a new Gauge Factory\n    function setGaugeFactory(address _gaugeFactory) external VoterAdmin {\n        gaugefactory = _gaugeFactory;\n    }\n\n    /// @notice Set a new Pair Factory\n    function setPairFactory(address _factory) external VoterAdmin {\n        factory = _factory;\n    }\n\n    /// @notice Set a new PermissionRegistry\n    function setPermissionsRegistry(address _permissionRegistry) external VoterAdmin {\n        permissionRegistry = _permissionRegistry;\n    }\n\n    /// @notice Set a new bribes for a given gauge\n    function setNewBribes(address _gauge, address _internal, address _external) external VoterAdmin {\n        require(isGauge[_gauge] == true);\n        _setInternalBribe(_gauge, _internal);\n        _setExternalBribe(_gauge, _external);\n    }\n\n    /// @notice Set a new internal bribe for a given gauge\n    function setInternalBribeFor(address _gauge, address _internal) external VoterAdmin {\n        require(isGauge[_gauge]);\n        _setInternalBribe(_gauge, _internal);\n    }\n\n    /// @notice Set a new External bribe for a given gauge\n    function setExternalBribeFor(address _gauge, address _external) external VoterAdmin {\n        require(isGauge[_gauge]);\n        _setExternalBribe(_gauge, _external);\n    }\n\n    function _setInternalBribe(address _gauge, address _internal) private {\n        internal_bribes[_gauge] = _internal;\n    }\n\n    function _setExternalBribe(address _gauge, address _external) private {\n        external_bribes[_gauge] = _external;\n    }\n    \n    \n    /// @notice Increase gauge approvals if max is type(uint).max is reached    [very long run could happen]\n    function increaseGaugeApprovals(address _gauge) external VoterAdmin {\n        require(isGauge[_gauge]);\n        IERC20(base).approve(_gauge, 0);\n        IERC20(base).approve(_gauge, type(uint).max);\n    }\n\n    \n    function addFactory(address _pairFactory, address _gaugeFactory) external VoterAdmin {\n        require(_pairFactory != address(0), 'addr 0');\n        require(_gaugeFactory != address(0), 'addr 0');\n        require(!isFactory[_pairFactory], 'factory true');\n        require(!isGaugeFactory[_gaugeFactory], 'g.fact true');\n\n        factories.push(_pairFactory);\n        gaugeFactories.push(_gaugeFactory);\n        isFactory[_pairFactory] = true;\n        isGaugeFactory[_gaugeFactory] = true;\n    }\n\n    function replaceFactory(address _pairFactory, address _gaugeFactory, uint256 _pos) external VoterAdmin {\n        require(_pairFactory != address(0), 'addr 0');\n        require(_gaugeFactory != address(0), 'addr 0');\n        require(isFactory[_pairFactory], 'factory false');\n        require(isGaugeFactory[_gaugeFactory], 'g.fact false');\n        address oldPF = factories[_pos];\n        address oldGF = gaugeFactories[_pos];\n        isFactory[oldPF] = false;\n        isGaugeFactory[oldGF] = false;\n\n        factories[_pos] = (_pairFactory);\n        gaugeFactories[_pos] = (_gaugeFactory);\n        isFactory[_pairFactory] = true;\n        isGaugeFactory[_gaugeFactory] = true;\n    }\n\n    function removeFactory(uint256 _pos) external VoterAdmin {\n        address oldPF = factories[_pos];\n        address oldGF = gaugeFactories[_pos];\n        require(isFactory[oldPF], 'factory false');\n        require(isGaugeFactory[oldGF], 'g.fact false');\n        factories[_pos] = address(0);\n        gaugeFactories[_pos] = address(0);\n        isFactory[oldPF] = false;\n        isGaugeFactory[oldGF] = false;\n    }\n\n    \n    \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    GOVERNANCE\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n    \n    \n    /// @notice Whitelist a token for gauge creation\n    function whitelist(address[] memory _token) external Governance {\n        uint256 i = 0;\n        for(i = 0; i < _token.length; i++){\n            _whitelist(_token[i]);\n        }\n    }\n       \n    function _whitelist(address _token) private {\n        require(!isWhitelisted[_token]);\n        isWhitelisted[_token] = true;\n        emit Whitelisted(msg.sender, _token);\n    }\n    \n    /// @notice Blacklist a malicious token\n    function blacklist(address[] memory _token) external Governance {\n        uint256 i = 0;\n        for(i = 0; i < _token.length; i++){\n            _blacklist(_token[i]);\n        }\n    }\n       \n    function _blacklist(address _token) private {\n        require(isWhitelisted[_token]);\n        isWhitelisted[_token] = false;\n        emit Blacklisted(msg.sender, _token);\n    }\n\n     /// @notice Kill a malicious gauge \n    /// @param  _gauge gauge to kill\n    function killGauge(address _gauge) external Governance {\n        require(isAlive[_gauge], \"gauge already dead\");\n        isAlive[_gauge] = false;\n        claimable[_gauge] = 0;\n        emit GaugeKilled(_gauge);\n    }\n\n    /// @notice Revive a malicious gauge \n    /// @param  _gauge gauge to revive\n    function reviveGauge(address _gauge) external Governance {\n        require(!isAlive[_gauge], \"gauge already alive\");\n        require(isGauge[_gauge], 'gauge killed totally');\n        isAlive[_gauge] = true;\n        emit GaugeRevived(_gauge);\n    }\n    \n    /// @notice Kill a malicious gauge completly\n    /// @param  _gauge gauge to kill\n    function killGaugeTotally(address _gauge) external Governance {\n        require(isAlive[_gauge], \"gauge already dead\");\n\n        delete isAlive[_gauge];\n        delete internal_bribes[_gauge];\n        delete external_bribes[_gauge];\n        delete poolForGauge[_gauge];\n        delete isGauge[_gauge];\n        delete claimable[_gauge];\n        delete supplyIndex[_gauge];\n\n        address _pool = poolForGauge[_gauge];\n        gauges[_pool] = address(0);\n        \n\n        emit GaugeKilled(_gauge);\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    \n    /// @notice Reset the votes of a given TokenID\n    function reset(uint _tokenId) external nonReentrant {\n        _voteDelay(_tokenId);\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        _reset(_tokenId);\n        IVotingEscrow(_ve).abstain(_tokenId);\n        lastVoted[_tokenId] = _epochTimestamp() + 1;\n    }\n\n    function _reset(uint _tokenId) internal {\n        address[] storage _poolVote = poolVote[_tokenId];\n        uint _poolVoteCnt = _poolVote.length;\n        uint256 _totalWeight = 0;\n        uint256 _time = _epochTimestamp();\n\n        for (uint i = 0; i < _poolVoteCnt; i ++) {\n            address _pool = _poolVote[i];\n            uint256 _votes = votes[_tokenId][_pool];\n\n            if (_votes != 0) {\n                _updateFor(gauges[_pool]);\n\n                // if user last vote is < than epochTimestamp then votes are 0! IF not underflow occur\n                if(lastVoted[_tokenId] > _epochTimestamp()) weightsPerEpoch[_time][_pool] -= _votes;\n\n                votes[_tokenId][_pool] -= _votes;\n\n                if (_votes > 0) {\n                    IBribe(internal_bribes[gauges[_pool]])._withdraw(uint256(_votes), _tokenId);\n                    IBribe(external_bribes[gauges[_pool]])._withdraw(uint256(_votes), _tokenId);\n                    _totalWeight += _votes;\n                }\n                \n                emit Abstained(_tokenId, _votes);\n            }\n        }\n\n        \n        // if user last vote is < than epochTimestamp then _totalWeight is 0! IF not underflow occur\n        if(lastVoted[_tokenId] < _epochTimestamp()) _totalWeight = 0;\n        \n        totWeightsPerEpoch[_time] -= _totalWeight;\n        usedWeights[_tokenId] = 0;\n        delete poolVote[_tokenId];\n    }\n\n    /// @notice Recast the saved votes of a given TokenID\n    function poke(uint _tokenId) external nonReentrant {\n        _voteDelay(_tokenId);\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        address[] memory _poolVote = poolVote[_tokenId];\n        uint _poolCnt = _poolVote.length;\n        uint256[] memory _weights = new uint256[](_poolCnt);\n\n        for (uint i = 0; i < _poolCnt; i ++) {\n            _weights[i] = votes[_tokenId][_poolVote[i]];\n        }\n\n        _vote(_tokenId, _poolVote, _weights);\n        lastVoted[_tokenId] = _epochTimestamp() + 1;\n    }\n\n    \n    /// @notice Vote for pools\n    /// @param  _tokenId    veNFT tokenID used to vote\n    /// @param  _poolVote   array of LPs addresses to vote  (eg.: [sAMM usdc-usdt   , sAMM busd-usdt, vAMM wbnb-the ,...])\n    /// @param  _weights    array of weights for each LPs   (eg.: [10               , 90            , 45             ,...])  \n    function vote(uint _tokenId, address[] calldata _poolVote, uint256[] calldata _weights) external nonReentrant {\n        _voteDelay(_tokenId);\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        require(_poolVote.length == _weights.length);\n        _vote(_tokenId, _poolVote, _weights);\n        lastVoted[_tokenId] = _epochTimestamp() + 1;\n    }\n    \n    function _vote(uint _tokenId, address[] memory _poolVote, uint256[] memory _weights) internal {\n        _reset(_tokenId);\n        uint _poolCnt = _poolVote.length;\n        uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\n        uint256 _totalVoteWeight = 0;\n        uint256 _totalWeight = 0;\n        uint256 _usedWeight = 0;\n        uint256 _time = _epochTimestamp();\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            _totalVoteWeight += _weights[i];\n        }\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            address _pool = _poolVote[i];\n            address _gauge = gauges[_pool];\n\n            if (isGauge[_gauge]) {\n                uint256 _poolWeight = _weights[i] * _weight / _totalVoteWeight;\n                require(votes[_tokenId][_pool] == 0);\n                require(_poolWeight != 0);\n                _updateFor(_gauge);\n\n                poolVote[_tokenId].push(_pool);\n                weightsPerEpoch[_time][_pool] += _poolWeight;\n\n                votes[_tokenId][_pool] += _poolWeight;\n\n                IBribe(internal_bribes[_gauge])._deposit(uint256(_poolWeight), _tokenId);\n                IBribe(external_bribes[_gauge])._deposit(uint256(_poolWeight), _tokenId);\n                \n                _usedWeight += _poolWeight;\n                _totalWeight += _poolWeight;\n                emit Voted(msg.sender, _tokenId, _poolWeight);\n            }\n        }\n        if (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\n        totWeightsPerEpoch[_time] += _totalWeight;\n        usedWeights[_tokenId] = (_usedWeight);\n    }\n\n    /// @notice claim LP gauge rewards\n    function claimRewards(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            IGauge(_gauges[i]).getReward(msg.sender);\n        }\n    }\n\n    /// @notice claim bribes rewards given a TokenID\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint _tokenId) external {\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\n        }\n    }\n\n    /// @notice claim fees rewards given a TokenID\n    function claimFees(address[] memory _fees, address[][] memory _tokens, uint _tokenId) external {\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        for (uint i = 0; i < _fees.length; i++) {\n            IBribe(_fees[i]).getRewardForOwner(_tokenId, _tokens[i]);\n        }\n    }\n\n    /// @notice claim bribes rewards given an address\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens) external {\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForAddress(msg.sender, _tokens[i]);\n        }\n    }\n\n    /// @notice claim fees rewards given an address\n    function claimFees(address[] memory _bribes, address[][] memory _tokens) external {\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForAddress(msg.sender, _tokens[i]);\n        }\n    }    \n\n    /// @notice attach a veNFT tokenID to a gauge. This is used for boost farming \n    /// @dev boost not available in Thena. Keep the function in case we need it for future updates. \n    function attachTokenToGauge(uint tokenId, address account) external {\n        require(isGauge[msg.sender]);\n        require(isAlive[msg.sender]); // killed gauges cannot attach tokens to themselves\n        if (tokenId > 0) IVotingEscrow(_ve).attach(tokenId);\n        emit Attach(account, msg.sender, tokenId);\n    }\n\n    \n    /// @notice detach a veNFT tokenID to a gauge. This is used for boost farming \n    /// @dev boost not available in Thena. Keep the function in case we need it for future updates. \n    function detachTokenFromGauge(uint tokenId, address account) external {\n        require(isGauge[msg.sender]);\n        if (tokenId > 0) IVotingEscrow(_ve).detach(tokenId);\n        emit Detach(account, msg.sender, tokenId);\n    }\n\n    /// @notice check if user can vote\n    function _voteDelay(uint _tokenId) internal view {\n        require(block.timestamp > lastVoted[_tokenId] + VOTE_DELAY, \"ERR: VOTE_DELAY\");\n    }\n\n\n\n     /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    GAUGE CREATION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n    /// @notice create multiple gauges\n    function createGauges(address[] memory _pool, uint256[] memory _gaugeTypes) external nonReentrant returns(address[] memory, address[] memory, address[] memory)  {\n        require(_pool.length == _gaugeTypes.length);\n        require(_pool.length <= 10);\n        address[] memory _gauge = new address[](_pool.length);\n        address[] memory _int = new address[](_pool.length);\n        address[] memory _ext = new address[](_pool.length);\n\n        uint i = 0;\n        for(i; i < _pool.length; i++){\n            (_gauge[i], _int[i], _ext[i]) = _createGauge(_pool[i], _gaugeTypes[i]);\n        }\n        return (_gauge, _int, _ext);\n    }\n\n     /// @notice create a gauge  \n    function createGauge(address _pool, uint256 _gaugeType) external nonReentrant returns (address _gauge, address _internal_bribe, address _external_bribe)  {\n        (_gauge, _internal_bribe, _external_bribe) = _createGauge(_pool, _gaugeType);\n    }\n\n    /// @notice create a gauge\n    /// @param  _pool       LP address \n    /// @param  _gaugeType  the type of the gauge you want to create\n    /// @dev    To create stable/Volatile pair gaugeType = 0, Concentrated liqudity = 1, ...\n    ///         Make sure to use the corrcet gaugeType or it will fail\n\n    function _createGauge(address _pool, uint256 _gaugeType) internal returns (address _gauge, address _internal_bribe, address _external_bribe) {\n        require(_gaugeType < factories.length, \"gaugetype\");\n        require(gauges[_pool] == address(0x0), \"!exists\");\n        bool isPair;\n        address _factory = factories[_gaugeType];\n        address _gaugeFactory = gaugeFactories[_gaugeType];\n        require(_factory != address(0));\n        require(_gaugeFactory != address(0));\n        \n\n        address tokenA = address(0);\n        address tokenB = address(0);\n        (tokenA) = IPairInfo(_pool).token0();\n        (tokenB) = IPairInfo(_pool).token1();\n\n        // for future implementation add isPair() in factory\n        if(_gaugeType == 0){\n            isPair = IPairFactory(_factory).isPair(_pool);\n        } \n        if(_gaugeType == 1) {\n            address _pool_factory = IAlgebraFactory(_factory).poolByPair(tokenA, tokenB);\n            address _pool_hyper = IHypervisor(_pool).pool();\n            require(_pool_hyper == _pool_factory, 'wrong tokens');    \n            isPair = true;\n        } else {\n            //update\n            //isPair = false;\n        }\n\n        // gov can create for any pool, even non-Thena pairs\n        if (!IPermissionsRegistry(permissionRegistry).hasRole(\"GOVERNANCE\",msg.sender)) { \n            require(isPair, \"!_pool\");\n            require(isWhitelisted[tokenA] && isWhitelisted[tokenB], \"!whitelisted\");\n            require(tokenA != address(0) && tokenB != address(0), \"!pair.tokens\");\n        }\n\n        // create internal and external bribe\n        address _owner = IPermissionsRegistry(permissionRegistry).thenaTeamMultisig();\n        string memory _type =  string.concat(\"Thena LP Fees: \", IERC20(_pool).symbol() );\n        _internal_bribe = IBribeFactory(bribefactory).createBribe(_owner, tokenA, tokenB, _type);\n\n        _type = string.concat(\"Thena Bribes: \", IERC20(_pool).symbol() );\n        _external_bribe = IBribeFactory(bribefactory).createBribe(_owner, tokenA, tokenB, _type);\n\n        // create gauge\n        _gauge = IGaugeFactory(_gaugeFactory).createGaugeV2(base, _ve, _pool, address(this), _internal_bribe, _external_bribe, isPair);\n     \n        // approve spending for $the\n        IERC20(base).approve(_gauge, type(uint).max);\n\n        // save data\n        internal_bribes[_gauge] = _internal_bribe;\n        external_bribes[_gauge] = _external_bribe;\n        gauges[_pool] = _gauge;\n        poolForGauge[_gauge] = _pool;\n        isGauge[_gauge] = true;\n        isAlive[_gauge] = true;\n        pools.push(_pool);\n\n        // update index\n        _updateFor(_gauge);\n\n        emit GaugeCreated(_gauge, msg.sender, _internal_bribe, _external_bribe, _pool);\n    }\n\n   \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice view the total length of the pools\n    function length() external view returns (uint) {\n        return pools.length;\n    }\n\n    /// @notice view the total length of the voted pools given a tokenId\n    function poolVoteLength(uint tokenId) external view returns(uint) { \n        return poolVote[tokenId].length;\n    }\n\n    function _factories() external view returns(address[] memory){\n        return factories;\n    }\n    \n    function factoryLength() external view returns(uint){\n        return factories.length;\n    }\n    \n    function _gaugeFactories() external view returns(address[] memory){\n        return gaugeFactories;\n    }\n    \n    function gaugeFactoriesLength() external view returns(uint) {\n        return gaugeFactories.length;\n    }\n\n    function weights(address _pool) public view returns(uint) {\n        uint _time = _epochTimestamp();\n        return weightsPerEpoch[_time][_pool];\n    }\n\n    function weightsAt(address _pool, uint _time) public view returns(uint) {\n        return weightsPerEpoch[_time][_pool];\n    }\n\n    function totalWeight() public view returns(uint) {\n        uint _time = _epochTimestamp();\n        return totWeightsPerEpoch[_time];\n    }\n\n    function totalWeightAt(uint _time) public view returns(uint) {\n        return totWeightsPerEpoch[_time];\n    }\n\n    function _epochTimestamp() public view returns(uint) {\n        return IMinter(minter).active_period();\n    }\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    DISTRIBUTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice notify reward amount for gauge\n    /// @dev    the function is called by the minter each epoch. Anyway anyone can top up some extra rewards.\n    /// @param  amount  amount to distribute\n    function notifyRewardAmount(uint amount) external {\n        require(msg.sender == minter);\n        _safeTransferFrom(base, msg.sender, address(this), amount);     // transfer the distro in\n        uint _totalWeight = totalWeightAt(_epochTimestamp() - 604800);   // minter call notify after updates active_period, loads votes - 1 week\n        uint256 _ratio = 0;\n\n        if(_totalWeight > 0) _ratio = amount * 1e18 / _totalWeight;     // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index += _ratio;\n        }\n\n        emit NotifyReward(msg.sender, base, amount);\n    }\n\n    /// @notice notify reward amount for gauge\n    /// @dev    the function is called by the minter each epoch. Anyway anyone can top up some extra rewards.\n    /// @param  amount  amount to distribute\n    function _notifyRewardAmount(uint amount) external {\n        _safeTransferFrom(base, msg.sender, address(this), amount); // transfer the distro in\n        uint _totalWeight = totalWeight();\n        require(_totalWeight > 0);\n        uint256 _ratio = amount * 1e18 / _totalWeight; // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index += _ratio;\n        }\n        emit NotifyReward(msg.sender, base, amount);\n    }\n\n  \n\n    /// @notice distribute the LP Fees to the internal bribes\n    /// @param  _gauges  gauge address where to claim the fees \n    /// @dev    the gauge is the owner of the LPs so it has to claim\n    function distributeFees(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            if (isGauge[_gauges[i]] && isAlive[_gauges[i]]){\n                IGauge(_gauges[i]).claimFees();\n            }\n        }\n    }\n\n    \n    /// @notice Distribute the emission for ALL gauges \n    function distributeAll() external nonReentrant {\n        \n        IMinter(minter).update_period();\n\n        uint x = 0;\n        uint stop = pools.length;\n        for (x; x < stop; x++) {\n            _distribute(gauges[pools[x]]);\n        }\n    }\n\n    /// @notice distribute the emission for N gauges\n    /// @param  start   start index point of the pools array\n    /// @param  finish  finish index point of the pools array\n    /// @dev    this function is used in case we have too many pools and gasLimit is reached\n    function distribute(uint start, uint finish) public nonReentrant {\n        IMinter(minter).update_period();\n        for (uint x = start; x < finish; x++) {\n            _distribute(gauges[pools[x]]);\n        }\n    }\n\n    /// @notice distribute reward onyl for given gauges\n    /// @dev    this function is used in case some distribution fails\n    function distribute(address[] memory _gauges) external nonReentrant {\n        IMinter(minter).update_period();\n        for (uint x = 0; x < _gauges.length; x++) {\n            _distribute(_gauges[x]);\n        }\n    }\n\n    /// @notice distribute the emission\n    function _distribute(address _gauge) internal {\n\n        uint lastTimestamp = gaugesDistributionTimestmap[_gauge];\n        uint currentTimestamp = _epochTimestamp();\n        if(lastTimestamp < currentTimestamp){\n            _updateForAfterDistribution(_gauge); // should set claimable to 0 if killed\n\n            uint _claimable = claimable[_gauge];"
    }
  ]
}