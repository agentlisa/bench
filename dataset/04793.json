{
  "Title": "[10] Consider renaming `CURRENT_MAX_PRECOMPILE_ADDRESS` to `MAX_POSSIBLE_PRECOMPILE_ADDRESS`",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/Constants.sol#L43-L47\n\n```solidity\n/// @dev The maximal possible address of an L1-like precompie. These precompiles maintain the following properties:\n/// - Their extcodehash is EMPTY_STRING_KECCAK\n/// - Their extcodesize is 0 despite having a bytecode formally deployed there.\nuint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = 0xff;\n\n```\n\nNote that this address is used in the`AccountCodeStorage.getCodeHash`function, i.e\n\n```solidity\naddress account = address(uint160(_input));\nif (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n    return EMPTY_STRING_KECCAK;\n}\n```\n\nCase is that the current name suggests that there are 255 addresses already, where as is should mean that the maximal possible address of an L1-like precompile should be 255 as [this comment](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/Constants.sol#L43) hints.\n\n### Impact\n\nConfusing code, makes it harder to understand protocol\n\n### Recommended Mitigation Steps\n\nConsider changing `CURRENT_MAX_PRECOMPILE_ADDRESS` to `MAX_POSSIBLE_PRECOMPILE_ADDRESS`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/Constants.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IAccountCodeStorage} from \"./interfaces/IAccountCodeStorage.sol\";\nimport {INonceHolder} from \"./interfaces/INonceHolder.sol\";\nimport {IContractDeployer} from \"./interfaces/IContractDeployer.sol\";\nimport {IKnownCodesStorage} from \"./interfaces/IKnownCodesStorage.sol\";\nimport {IImmutableSimulator} from \"./interfaces/IImmutableSimulator.sol\";\nimport {IBaseToken} from \"./interfaces/IBaseToken.sol\";\nimport {IL1Messenger} from \"./interfaces/IL1Messenger.sol\";\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {ICompressor} from \"./interfaces/ICompressor.sol\";\nimport {IComplexUpgrader} from \"./interfaces/IComplexUpgrader.sol\";\nimport {IBootloaderUtilities} from \"./interfaces/IBootloaderUtilities.sol\";\nimport {IPubdataChunkPublisher} from \"./interfaces/IPubdataChunkPublisher.sol\";\n\n/// @dev All the system contracts introduced by zkSync have their addresses\n/// started from 2^15 in order to avoid collision with Ethereum precompiles.\nuint160 constant SYSTEM_CONTRACTS_OFFSET = {{SYSTEM_CONTRACTS_OFFSET}}; // 2^15\n\n/// @dev Unlike the value above, it is not overridden for the purpose of testing and \n/// is identical to the constant value actually used as the system contracts offset on \n/// mainnet. \nuint160 constant REAL_SYSTEM_CONTRACTS_OFFSET = 0x8000;\n\n/// @dev All the system contracts must be located in the kernel space,\n/// i.e. their addresses must be below 2^16.\nuint160 constant MAX_SYSTEM_CONTRACT_ADDRESS = 0xffff; // 2^16 - 1\n\naddress constant ECRECOVER_SYSTEM_CONTRACT = address(0x01);\naddress constant SHA256_SYSTEM_CONTRACT = address(0x02);\naddress constant ECADD_SYSTEM_CONTRACT = address(0x06);\naddress constant ECMUL_SYSTEM_CONTRACT = address(0x07);\n\n\n/// @dev The number of ergs that need to be spent for a single byte of pubdata regardless of the pubdata price.\n/// This variable is used to ensure the following:\n/// - That the long-term storage of the operator is compensated properly.\n/// - That it is not possible that the pubdata counter grows too high without spending proportional amount of computation.\nuint256 constant COMPUTATIONAL_PRICE_FOR_PUBDATA = 80;\n\n/// @dev The maximal possible address of an L1-like precompie. These precompiles maintain the following properties:\n/// - Their extcodehash is EMPTY_STRING_KECCAK\n/// - Their extcodesize is 0 despite having a bytecode formally deployed there.\nuint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = 0xff;\n\naddress payable constant BOOTLOADER_FORMAL_ADDRESS = payable(address(SYSTEM_CONTRACTS_OFFSET + 0x01));\nIAccountCodeStorage constant ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT = IAccountCodeStorage(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x02)\n);\nINonceHolder constant NONCE_HOLDER_SYSTEM_CONTRACT = INonceHolder(address(SYSTEM_CONTRACTS_OFFSET + 0x03));\nIKnownCodesStorage constant KNOWN_CODE_STORAGE_CONTRACT = IKnownCodesStorage(address(SYSTEM_CONTRACTS_OFFSET + 0x04));\nIImmutableSimulator constant IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT = IImmutableSimulator(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x05)\n);\nIContractDeployer constant DEPLOYER_SYSTEM_CONTRACT = IContractDeployer(address(SYSTEM_CONTRACTS_OFFSET + 0x06));\n\n// A contract that is allowed to deploy any codehash\n// on any address. To be used only during an upgrade.\naddress constant FORCE_DEPLOYER = address(SYSTEM_CONTRACTS_OFFSET + 0x07);\nIL1Messenger constant L1_MESSENGER_CONTRACT = IL1Messenger(address(SYSTEM_CONTRACTS_OFFSET + 0x08));\naddress constant MSG_VALUE_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x09);\n\nIBaseToken constant BASE_TOKEN_SYSTEM_CONTRACT = IBaseToken(address(SYSTEM_CONTRACTS_OFFSET + 0x0a));\nIBaseToken constant REAL_BASE_TOKEN_SYSTEM_CONTRACT = IBaseToken(address(REAL_SYSTEM_CONTRACTS_OFFSET + 0x0a));\n\n// Hardcoded because even for tests we should keep the address. (Instead `SYSTEM_CONTRACTS_OFFSET + 0x10`)\n// Precompile call depends on it.\n// And we don't want to mock this contract.\naddress constant KECCAK256_SYSTEM_CONTRACT = address(0x8010);\n\nISystemContext constant SYSTEM_CONTEXT_CONTRACT = ISystemContext(payable(address(SYSTEM_CONTRACTS_OFFSET + 0x0b)));\nISystemContext constant REAL_SYSTEM_CONTEXT_CONTRACT = ISystemContext(payable(address(REAL_SYSTEM_CONTRACTS_OFFSET + 0x0b)));\n\nIBootloaderUtilities constant BOOTLOADER_UTILITIES = IBootloaderUtilities(address(SYSTEM_CONTRACTS_OFFSET + 0x0c));\n\n// It will be a different value for tests, while shouldn't. But for now, this constant is not used by other contracts, so that's fine.\naddress constant EVENT_WRITER_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x0d);\n\nICompressor constant COMPRESSOR_CONTRACT = ICompressor(address(SYSTEM_CONTRACTS_OFFSET + 0x0e));\n\nIComplexUpgrader constant COMPLEX_UPGRADER_CONTRACT = IComplexUpgrader(address(SYSTEM_CONTRACTS_OFFSET + 0x0f));\n\nIPubdataChunkPublisher constant PUBDATA_CHUNK_PUBLISHER = IPubdataChunkPublisher(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x11)\n);\n\n/// @dev If the bitwise AND of the extraAbi[2] param when calling the MSG_VALUE_SIMULATOR\n/// is non-zero, the call will be assumed to be a system one.\nuint256 constant MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT = 1;\n\n/// @dev The maximal msg.value that context can have\nuint256 constant MAX_MSG_VALUE = 2 ** 128 - 1;\n\n/// @dev Prefix used during derivation of account addresses using CREATE2\n/// @dev keccak256(\"zksyncCreate2\")\nbytes32 constant CREATE2_PREFIX = 0x2020dba91b30cc0006188af794c2fb30dd8520db7e2c088b7fc7c103c00ca494;\n/// @dev Prefix used during derivation of account addresses using CREATE\n/// @dev keccak256(\"zksyncCreate\")\nbytes32 constant CREATE_PREFIX = 0x63bae3a9951d38e8a3fbb7b70909afc1200610fc5bc55ade242f815974674f23;\n\n/// @dev Each state diff consists of 156 bytes of actual data and 116 bytes of unused padding, needed for circuit efficiency.\nuint256 constant STATE_DIFF_ENTRY_SIZE = 272;\n\n/// @dev While the \"real\" amount of pubdata that can be sent rarely exceeds the BLOB_SIZE_BYTES * MAX_NUMBER_OF_BLOBS, it is better to\n/// allow the operator to provide any reasonably large value in order to avoid unneeded constraints on the operator.\nuint256 constant MAX_ALLOWED_PUBDATA_PER_BATCH = 520000;\n\nenum SystemLogKey {\n    L2_TO_L1_LOGS_TREE_ROOT_KEY,\n    TOTAL_L2_TO_L1_PUBDATA_KEY,\n    STATE_DIFF_HASH_KEY,\n    PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\n    PREV_BATCH_HASH_KEY,\n    CHAINED_PRIORITY_TXN_HASH_KEY,\n    NUMBER_OF_LAYER_1_TXS_KEY,\n    BLOB_ONE_HASH_KEY,\n    BLOB_TWO_HASH_KEY,\n    EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\n}\n\n/// @dev The number of leaves in the L2->L1 log Merkle tree.\n/// While formally a tree of any length is acceptable, the node supports only a constant length of 4096 leaves.\nuint256 constant L2_TO_L1_LOGS_MERKLE_TREE_LEAVES = 4096;\n\n/// @dev The length of the derived key in bytes inside compressed state diffs.\nuint256 constant DERIVED_KEY_LENGTH = 32;\n/// @dev The length of the enum index in bytes inside compressed state diffs.\nuint256 constant ENUM_INDEX_LENGTH = 8;\n/// @dev The length of value in bytes inside compressed state diffs.\nuint256 constant VALUE_LENGTH = 32;\n\n/// @dev The length of the compressed initial storage write in bytes.\nuint256 constant COMPRESSED_INITIAL_WRITE_SIZE = DERIVED_KEY_LENGTH + VALUE_LENGTH;\n/// @dev The length of the compressed repeated storage write in bytes.\nuint256 constant COMPRESSED_REPEATED_WRITE_SIZE = ENUM_INDEX_LENGTH + VALUE_LENGTH;\n\n/// @dev The position from which the initial writes start in the compressed state diffs.\nuint256 constant INITIAL_WRITE_STARTING_POSITION = 4;\n\n/// @dev Each storage diffs consists of the following elements:\n/// [20bytes address][32bytes key][32bytes derived key][8bytes enum index][32bytes initial value][32bytes final value]\n/// @dev The offset of the deriived key in a storage diff.\nuint256 constant STATE_DIFF_DERIVED_KEY_OFFSET = 52;\n/// @dev The offset of the enum index in a storage diff.\nuint256 constant STATE_DIFF_ENUM_INDEX_OFFSET = 84;\n/// @dev The offset of the final value in a storage diff.\nuint256 constant STATE_DIFF_FINAL_VALUE_OFFSET = 124;\n\n/// @dev Total number of bytes in a blob. Blob = 4096 field elements * 31 bytes per field element\n/// @dev EIP-4844 defines it as 131_072 but we use 4096 * 31 within our circuits to always fit within a field element\n/// @dev Our circuits will prove that a EIP-4844 blob and our internal blob are the same.\nuint256 constant BLOB_SIZE_BYTES = 126_976;\n\n/// @dev Max number of blobs currently supported\nuint256 constant MAX_NUMBER_OF_BLOBS = 2;"
    },
    {
      "filename": "code/system-contracts/contracts/Constants.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IAccountCodeStorage} from \"./interfaces/IAccountCodeStorage.sol\";\nimport {INonceHolder} from \"./interfaces/INonceHolder.sol\";\nimport {IContractDeployer} from \"./interfaces/IContractDeployer.sol\";\nimport {IKnownCodesStorage} from \"./interfaces/IKnownCodesStorage.sol\";\nimport {IImmutableSimulator} from \"./interfaces/IImmutableSimulator.sol\";\nimport {IBaseToken} from \"./interfaces/IBaseToken.sol\";\nimport {IL1Messenger} from \"./interfaces/IL1Messenger.sol\";\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {ICompressor} from \"./interfaces/ICompressor.sol\";\nimport {IComplexUpgrader} from \"./interfaces/IComplexUpgrader.sol\";\nimport {IBootloaderUtilities} from \"./interfaces/IBootloaderUtilities.sol\";\nimport {IPubdataChunkPublisher} from \"./interfaces/IPubdataChunkPublisher.sol\";\n\n/// @dev All the system contracts introduced by zkSync have their addresses\n/// started from 2^15 in order to avoid collision with Ethereum precompiles.\nuint160 constant SYSTEM_CONTRACTS_OFFSET = {{SYSTEM_CONTRACTS_OFFSET}}; // 2^15\n\n/// @dev Unlike the value above, it is not overridden for the purpose of testing and \n/// is identical to the constant value actually used as the system contracts offset on \n/// mainnet. \nuint160 constant REAL_SYSTEM_CONTRACTS_OFFSET = 0x8000;\n\n/// @dev All the system contracts must be located in the kernel space,\n/// i.e. their addresses must be below 2^16.\nuint160 constant MAX_SYSTEM_CONTRACT_ADDRESS = 0xffff; // 2^16 - 1\n\naddress constant ECRECOVER_SYSTEM_CONTRACT = address(0x01);\naddress constant SHA256_SYSTEM_CONTRACT = address(0x02);\naddress constant ECADD_SYSTEM_CONTRACT = address(0x06);\naddress constant ECMUL_SYSTEM_CONTRACT = address(0x07);\n\n\n/// @dev The number of ergs that need to be spent for a single byte of pubdata regardless of the pubdata price.\n/// This variable is used to ensure the following:\n/// - That the long-term storage of the operator is compensated properly.\n/// - That it is not possible that the pubdata counter grows too high without spending proportional amount of computation.\nuint256 constant COMPUTATIONAL_PRICE_FOR_PUBDATA = 80;\n\n/// @dev The maximal possible address of an L1-like precompie. These precompiles maintain the following properties:\n/// - Their extcodehash is EMPTY_STRING_KECCAK\n/// - Their extcodesize is 0 despite having a bytecode formally deployed there.\nuint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = 0xff;\n\naddress payable constant BOOTLOADER_FORMAL_ADDRESS = payable(address(SYSTEM_CONTRACTS_OFFSET + 0x01));\nIAccountCodeStorage constant ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT = IAccountCodeStorage(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x02)\n);\nINonceHolder constant NONCE_HOLDER_SYSTEM_CONTRACT = INonceHolder(address(SYSTEM_CONTRACTS_OFFSET + 0x03));\nIKnownCodesStorage constant KNOWN_CODE_STORAGE_CONTRACT = IKnownCodesStorage(address(SYSTEM_CONTRACTS_OFFSET + 0x04));\nIImmutableSimulator constant IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT = IImmutableSimulator(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x05)\n);\nIContractDeployer constant DEPLOYER_SYSTEM_CONTRACT = IContractDeployer(address(SYSTEM_CONTRACTS_OFFSET + 0x06));\n\n// A contract that is allowed to deploy any codehash\n// on any address. To be used only during an upgrade.\naddress constant FORCE_DEPLOYER = address(SYSTEM_CONTRACTS_OFFSET + 0x07);\nIL1Messenger constant L1_MESSENGER_CONTRACT = IL1Messenger(address(SYSTEM_CONTRACTS_OFFSET + 0x08));\naddress constant MSG_VALUE_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x09);\n\nIBaseToken constant BASE_TOKEN_SYSTEM_CONTRACT = IBaseToken(address(SYSTEM_CONTRACTS_OFFSET + 0x0a));\nIBaseToken constant REAL_BASE_TOKEN_SYSTEM_CONTRACT = IBaseToken(address(REAL_SYSTEM_CONTRACTS_OFFSET + 0x0a));\n\n// Hardcoded because even for tests we should keep the address. (Instead `SYSTEM_CONTRACTS_OFFSET + 0x10`)\n// Precompile call depends on it.\n// And we don't want to mock this contract.\naddress constant KECCAK256_SYSTEM_CONTRACT = address(0x8010);\n\nISystemContext constant SYSTEM_CONTEXT_CONTRACT = ISystemContext(payable(address(SYSTEM_CONTRACTS_OFFSET + 0x0b)));\nISystemContext constant REAL_SYSTEM_CONTEXT_CONTRACT = ISystemContext(payable(address(REAL_SYSTEM_CONTRACTS_OFFSET + 0x0b)));\n\nIBootloaderUtilities constant BOOTLOADER_UTILITIES = IBootloaderUtilities(address(SYSTEM_CONTRACTS_OFFSET + 0x0c));\n\n// It will be a different value for tests, while shouldn't. But for now, this constant is not used by other contracts, so that's fine.\naddress constant EVENT_WRITER_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x0d);\n\nICompressor constant COMPRESSOR_CONTRACT = ICompressor(address(SYSTEM_CONTRACTS_OFFSET + 0x0e));\n\nIComplexUpgrader constant COMPLEX_UPGRADER_CONTRACT = IComplexUpgrader(address(SYSTEM_CONTRACTS_OFFSET + 0x0f));\n\nIPubdataChunkPublisher constant PUBDATA_CHUNK_PUBLISHER = IPubdataChunkPublisher(\n    address(SYSTEM_CONTRACTS_OFFSET + 0x11)\n);\n\n/// @dev If the bitwise AND of the extraAbi[2] param when calling the MSG_VALUE_SIMULATOR\n/// is non-zero, the call will be assumed to be a system one.\nuint256 constant MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT = 1;\n\n/// @dev The maximal msg.value that context can have\nuint256 constant MAX_MSG_VALUE = 2 ** 128 - 1;\n\n/// @dev Prefix used during derivation of account addresses using CREATE2\n/// @dev keccak256(\"zksyncCreate2\")\nbytes32 constant CREATE2_PREFIX = 0x2020dba91b30cc0006188af794c2fb30dd8520db7e2c088b7fc7c103c00ca494;\n/// @dev Prefix used during derivation of account addresses using CREATE\n/// @dev keccak256(\"zksyncCreate\")\nbytes32 constant CREATE_PREFIX = 0x63bae3a9951d38e8a3fbb7b70909afc1200610fc5bc55ade242f815974674f23;\n\n/// @dev Each state diff consists of 156 bytes of actual data and 116 bytes of unused padding, needed for circuit efficiency.\nuint256 constant STATE_DIFF_ENTRY_SIZE = 272;\n\n/// @dev While the \"real\" amount of pubdata that can be sent rarely exceeds the BLOB_SIZE_BYTES * MAX_NUMBER_OF_BLOBS, it is better to\n/// allow the operator to provide any reasonably large value in order to avoid unneeded constraints on the operator.\nuint256 constant MAX_ALLOWED_PUBDATA_PER_BATCH = 520000;\n\nenum SystemLogKey {\n    L2_TO_L1_LOGS_TREE_ROOT_KEY,\n    TOTAL_L2_TO_L1_PUBDATA_KEY,\n    STATE_DIFF_HASH_KEY,\n    PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\n    PREV_BATCH_HASH_KEY,\n    CHAINED_PRIORITY_TXN_HASH_KEY,\n    NUMBER_OF_LAYER_1_TXS_KEY,\n    BLOB_ONE_HASH_KEY,\n    BLOB_TWO_HASH_KEY,\n    EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\n}\n\n/// @dev The number of leaves in the L2->L1 log Merkle tree.\n/// While formally a tree of any length is acceptable, the node supports only a constant length of 4096 leaves.\nuint256 constant L2_TO_L1_LOGS_MERKLE_TREE_LEAVES = 4096;\n\n/// @dev The length of the derived key in bytes inside compressed state diffs.\nuint256 constant DERIVED_KEY_LENGTH = 32;\n/// @dev The length of the enum index in bytes inside compressed state diffs.\nuint256 constant ENUM_INDEX_LENGTH = 8;\n/// @dev The length of value in bytes inside compressed state diffs.\nuint256 constant VALUE_LENGTH = 32;\n\n/// @dev The length of the compressed initial storage write in bytes.\nuint256 constant COMPRESSED_INITIAL_WRITE_SIZE = DERIVED_KEY_LENGTH + VALUE_LENGTH;\n/// @dev The length of the compressed repeated storage write in bytes.\nuint256 constant COMPRESSED_REPEATED_WRITE_SIZE = ENUM_INDEX_LENGTH + VALUE_LENGTH;\n\n/// @dev The position from which the initial writes start in the compressed state diffs.\nuint256 constant INITIAL_WRITE_STARTING_POSITION = 4;\n\n/// @dev Each storage diffs consists of the following elements:\n/// [20bytes address][32bytes key][32bytes derived key][8bytes enum index][32bytes initial value][32bytes final value]\n/// @dev The offset of the deriived key in a storage diff.\nuint256 constant STATE_DIFF_DERIVED_KEY_OFFSET = 52;\n/// @dev The offset of the enum index in a storage diff.\nuint256 constant STATE_DIFF_ENUM_INDEX_OFFSET = 84;\n/// @dev The offset of the final value in a storage diff.\nuint256 constant STATE_DIFF_FINAL_VALUE_OFFSET = 124;\n\n/// @dev Total number of bytes in a blob. Blob = 4096 field elements * 31 bytes per field element\n/// @dev EIP-4844 defines it as 131_072 but we use 4096 * 31 within our circuits to always fit within a field element\n/// @dev Our circuits will prove that a EIP-4844 blob and our internal blob are the same.\nuint256 constant BLOB_SIZE_BYTES = 126_976;\n\n/// @dev Max number of blobs currently supported\nuint256 constant MAX_NUMBER_OF_BLOBS = 2;"
    }
  ]
}