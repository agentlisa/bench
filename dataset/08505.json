{
  "Title": "[Nâ€‘10] `pragma experimental ABIEncoderV2` is deprecated",
  "Content": "\nUse `pragma abicoder v2` [instead](https://github.com/ethereum/solidity/blob/69411436139acf5dbcfc5828446f18b9fcfee32c/docs/080-breaking-changes.rst#silent-changes-of-the-semantics)\n\n*There are 2 instances of this issue.*\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-ens",
  "Code": [
    {
      "filename": "docs/080-breaking-changes.rst",
      "content": "********************************\nSolidity v0.8.0 Breaking Changes\n********************************\n\nThis section highlights the main breaking changes introduced in Solidity\nversion 0.8.0.\nFor the full list check\n`the release changelog <https://github.com/ethereum/solidity/releases/tag/v0.8.0>`_.\n\nSilent Changes of the Semantics\n===============================\n\nThis section lists changes where existing code changes its behaviour without\nthe compiler notifying you about it.\n\n* Arithmetic operations revert on underflow and overflow. You can use ``unchecked { ... }`` to use\n  the previous wrapping behaviour.\n\n  Checks for overflow are very common, so we made them the default to increase readability of code,\n  even if it comes at a slight increase of gas costs.\n\n* ABI coder v2 is activated by default.\n\n  You can choose to use the old behaviour using ``pragma abicoder v1;``.\n  The pragma ``pragma experimental ABIEncoderV2;`` is still valid, but it is deprecated and has no effect.\n  If you want to be explicit, please use ``pragma abicoder v2;`` instead.\n\n  Note that ABI coder v2 supports more types than v1 and performs more sanity checks on the inputs.\n  ABI coder v2 makes some function calls more expensive and it can also make contract calls\n  revert that did not revert with ABI coder v1 when they contain data that does not conform to the\n  parameter types.\n\n* Exponentiation is right associative, i.e., the expression ``a**b**c`` is parsed as ``a**(b**c)``.\n  Before 0.8.0, it was parsed as ``(a**b)**c``.\n\n  This is the common way to parse the exponentiation operator.\n\n* Failing assertions and other internal checks like division by zero or arithmetic overflow do\n  not use the invalid opcode but instead the revert opcode.\n  More specifically, they will use error data equal to a function call to ``Panic(uint256)`` with an error code specific\n  to the circumstances.\n\n  This will save gas on errors while it still allows static analysis tools to distinguish\n  these situations from a revert on invalid input, like a failing ``require``.\n\n* If a byte array in storage is accessed whose length is encoded incorrectly, a panic is caused.\n  A contract cannot get into this situation unless inline assembly is used to modify the raw representation of storage byte arrays.\n\n* If constants are used in array length expressions, previous versions of Solidity would use arbitrary precision\n  in all branches of the evaluation tree. Now, if constant variables are used as intermediate expressions,\n  their values will be properly rounded in the same way as when they are used in run-time expressions.\n\n* The type ``byte`` has been removed. It was an alias of ``bytes1``.\n\nNew Restrictions\n================\n\nThis section lists changes that might cause existing contracts to not compile anymore.\n\n* There are new restrictions related to explicit conversions of literals. The previous behaviour in\n  the following cases was likely ambiguous:\n\n  1. Explicit conversions from negative literals and literals larger than ``type(uint160).max`` to\n     ``address`` are disallowed.\n  2. Explicit conversions between literals and an integer type ``T`` are only allowed if the literal\n     lies between ``type(T).min`` and ``type(T).max``. In particular, replace usages of ``uint(-1)``\n     with ``type(uint).max``.\n  3. Explicit conversions between literals and enums are only allowed if the literal can\n     represent a value in the enum.\n  4. Explicit conversions between literals and ``address`` type (e.g. ``address(literal)``) have the\n     type ``address`` instead of ``address payable``. One can get a payable address type by using an\n     explicit conversion, i.e., ``payable(literal)``.\n\n* :ref:`Address literals<address_literals>` have the type ``address`` instead of ``address\n  payable``. They can be converted to ``address payable`` by using an explicit conversion, e.g.\n  ``payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)``.\n\n* There are new restrictions on explicit type conversions. The conversion is only allowed when there\n  is at most one change in sign, width or type-category (``int``, ``address``, ``bytesNN``, etc.).\n  To perform multiple changes, use multiple conversions.\n\n  Let us use the notation ``T(S)`` to denote the explicit conversion ``T(x)``, where, ``T`` and\n  ``S`` are types, and ``x`` is any arbitrary variable of type ``S``. An example of such a\n  disallowed conversion would be ``uint16(int8)`` since it changes both width (8 bits to 16 bits)\n  and sign (signed integer to unsigned integer). In order to do the conversion, one has to go\n  through an intermediate type. In the previous example, this would be ``uint16(uint8(int8))`` or\n  ``uint16(int16(int8))``. Note that the two ways to convert will produce different results e.g.,\n  for ``-1``. The following are some examples of conversions that are disallowed by this rule.\n\n  - ``address(uint)`` and ``uint(address)``: converting both type-category and width. Replace this by\n    ``address(uint160(uint))`` and ``uint(uint160(address))`` respectively.\n  - ``payable(uint160)``, ``payable(bytes20)`` and ``payable(integer-literal)``: converting both\n    type-category and state-mutability. Replace this by ``payable(address(uint160))``,\n    ``payable(address(bytes20))`` and ``payable(address(integer-literal))`` respectively. Note that\n    ``payable(0)`` is valid and is an exception to the rule.\n  - ``int80(bytes10)`` and ``bytes10(int80)``: converting both type-category and sign. Replace this by\n    ``int80(uint80(bytes10))`` and ``bytes10(uint80(int80)`` respectively.\n  - ``Contract(uint)``: converting both type-category and width. Replace this by\n    ``Contract(address(uint160(uint)))``.\n\n  These conversions were disallowed to avoid ambiguity. For example, in the expression ``uint16 x =\n  uint16(int8(-1))``, the value of ``x`` would depend on whether the sign or the width conversion\n  was applied first.\n\n* Function call options can only be given once, i.e. ``c.f{gas: 10000}{value: 1}()`` is invalid and has to be changed to ``c.f{gas: 10000, value: 1}()``.\n\n* The global functions ``log0``, ``log1``, ``log2``, ``log3`` and ``log4`` have been removed.\n\n  These are low-level functions that were largely unused. Their behaviour can be accessed from inline assembly.\n\n* ``enum`` definitions cannot contain more than 256 members.\n\n  This will make it safe to assume that the underlying type in the ABI is always ``uint8``.\n\n* Declarations with the name ``this``, ``super`` and ``_`` are disallowed, with the exception of\n  public functions and events. The exception is to make it possible to declare interfaces of contracts\n  implemented in languages other than Solidity that do permit such function names.\n\n* Remove support for the ``\\b``, ``\\f``, and ``\\v`` escape sequences in code.\n  They can still be inserted via hexadecimal escapes, e.g. ``\\x08``, ``\\x0c``, and ``\\x0b``, respectively.\n\n* The global variables ``tx.origin`` and ``msg.sender`` have the type ``address`` instead of\n  ``address payable``. One can convert them into ``address payable`` by using an explicit\n  conversion, i.e., ``payable(tx.origin)`` or ``payable(msg.sender)``.\n\n  This change was done since the compiler cannot determine whether or not these addresses\n  are payable or not, so it now requires an explicit conversion to make this requirement visible.\n\n* Explicit conversion into ``address`` type always returns a non-payable ``address`` type. In\n  particular, the following explicit conversions have the type ``address`` instead of ``address\n  payable``:\n\n  - ``address(u)`` where ``u`` is a variable of type ``uint160``. One can convert ``u``\n    into the type ``address payable`` by using two explicit conversions, i.e.,\n    ``payable(address(u))``.\n  - ``address(b)`` where ``b`` is a variable of type ``bytes20``. One can convert ``b``\n    into the type ``address payable`` by using two explicit conversions, i.e.,\n    ``payable(address(b))``.\n  - ``address(c)`` where ``c`` is a contract. Previously, the return type of this\n    conversion depended on whether the contract can receive Ether (either by having a receive\n    function or a payable fallback function). The conversion ``payable(c)`` has the type ``address\n    payable`` and is only allowed when the contract ``c`` can receive Ether. In general, one can\n    always convert ``c`` into the type ``address payable`` by using the following explicit\n    conversion: ``payable(address(c))``. Note that ``address(this)`` falls under the same category\n    as ``address(c)`` and the same rules apply for it.\n\n* The ``chainid`` builtin in inline assembly is now considered ``view`` instead of ``pure``.\n\n* Unary negation cannot be used on unsigned integers anymore, only on signed integers.\n\nInterface Changes\n=================\n\n* The output of ``--combined-json`` has changed: JSON fields ``abi``, ``devdoc``, ``userdoc`` and\n  ``storage-layout`` are sub-objects now. Before 0.8.0 they used to be serialised as strings.\n\n* The \"legacy AST\" has been removed (``--ast-json`` on the commandline interface and ``legacyAST`` for standard JSON).\n  Use the \"compact AST\" (``--ast-compact--json`` resp. ``AST``) as replacement.\n\n* The old error reporter (``--old-reporter``) has been removed.\n\n\nHow to update your code\n=======================\n\n- If you rely on wrapping arithmetic, surround each operation with ``unchecked { ... }``.\n- Optional: If you use SafeMath or a similar library, change ``x.add(y)`` to ``x + y``, ``x.mul(y)`` to ``x * y`` etc.\n- Add ``pragma abicoder v1;`` if you want to stay with the old ABI coder.\n- Optionally remove ``pragma experimental ABIEncoderV2`` or ``pragma abicoder v2`` since it is redundant.\n- Change ``byte`` to ``bytes1``.\n- Add intermediate explicit type conversions if required.\n- Combine ``c.f{gas: 10000}{value: 1}()`` to ``c.f{gas: 10000, value: 1}()``.\n- Change ``msg.sender.transfer(x)`` to ``payable(msg.sender).transfer(x)`` or use a stored variable of ``address payable`` type.\n- Change ``x**y**z`` to ``(x**y)**z``.\n- Use inline assembly as a replacement for ``log0``, ..., ``log4``.\n- Negate unsigned integers by subtracting them from the maximum value of the type and adding 1 (e.g. ``type(uint256).max - x + 1``, while ensuring that `x` is not zero)"
    }
  ]
}