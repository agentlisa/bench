{
  "Title": "[L-07] User can stake twice on beacon chain from same eipod, thus losing funds due to same withdrawal credentials",
  "Content": "\n### Proof of Concept\nThere are no restriction to how many times user can stake on beacon with `EigenPodManager` on `EigenPod`, thus all of them will have the same `_podWithdrawalCredentials()` and I think first deposit will be lost.\n```sodlidity\n    function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable onlyEigenPodManager {\n        // stake on ethpos\n        require(msg.value == 32 ether, \"EigenPod.stake: must initially stake for any validator with 32 ether\");\n        ethPOS.deposit{value : 32 ether}(pubkey, _podWithdrawalCredentials(), signature, depositDataRoot);\n        emit EigenPodStaked(pubkey);\n    }\n```\n[src/contracts/pods/EigenPod.sol#L159](https://github.com/code-423n4/2023-04-eigenlayer/blob/398cc428541b91948f717482ec973583c9e76232/src/contracts/pods/EigenPod.sol#L159)\n\nThere are some ways users can make a mistake by calling it twice or they would like to create another one.\nI've looked into rocketpool contracts; they are not allowing users to stake twice with the same pubkeys, so I think its important to implement the same security issue.\n```solidity\n    function preStake(bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) internal {\n...\n        require(rocketMinipoolManager.getMinipoolByPubkey(_validatorPubkey) == address(0x0), \"Validator pubkey is in use\");\n        // Set minipool pubkey\n        rocketMinipoolManager.setMinipoolPubkey(_validatorPubkey);\n        // Get withdrawal credentials\n        bytes memory withdrawalCredentials = rocketMinipoolManager.getMinipoolWithdrawalCredentials(address(this));\n        // Send staking deposit to casper\n        casperDeposit.deposit{value : prelaunchAmount}(_validatorPubkey, withdrawalCredentials, _validatorSignature, _depositDataRoot);\n        // Emit event\n        emit MinipoolPrestaked(_validatorPubkey, _validatorSignature, _depositDataRoot, prelaunchAmount, withdrawalCredentials, block.timestamp);\n    }\n```\n[contracts/contract/minipool/RocketMinipoolDelegate.sol#L235](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/minipool/RocketMinipoolDelegate.sol#L235)\n\nSame safe thing done in frax finance: \n```\n    function depositEther(uint256 max_deposits) external nonReentrant {\n...\n            // Deposit the ether in the ETH 2.0 deposit contract\n            depositContract.deposit{value: DEPOSIT_SIZE}(\n                pubKey,\n                withdrawalCredential,\n                signature,\n                depositDataRoot\n            );\n\n            // Set the validator as used so it won't get an extra 32 ETH\n            activeValidators[pubKey] = true;\n    ...\n}\n```\n[src/frxETHMinter.sol#L156](https://github.com/FraxFinance/frxETH-public/blob/7f7731dbc93154131aba6e741b6116da05b25662/src/frxETHMinter.sol#L156)\n\n### Tools Used\nPOC\n\n```diff\n    function testWithdrawFromPod() public {\n        cheats.startPrank(podOwner);\n        eigenPodManager.stake{value: stakeAmount}(pubkey, signature, depositDataRoot);\n+        eigenPodManager.stake{value: stakeAmount}(pubkey, signature, depositDataRoot);\n        cheats.stopPrank();\n\n        IEigenPod pod = eigenPodManager.getPod(podOwner);\n        uint256 balance = address(pod).balance;\n        cheats.deal(address(pod), stakeAmount);\n\n        cheats.startPrank(podOwner);\n        cheats.expectEmit(true, false, false, false);\n        emit DelayedWithdrawalCreated(podOwner, podOwner, balance, delayedWithdrawalRouter.userWithdrawalsLength(podOwner));\n        pod.withdrawBeforeRestaking();\n        cheats.stopPrank();\n        require(address(pod).balance == 0, \"Pod balance should be 0\");\n    }\n\n```\n### Recommended Mitigation Steps\nYou can look at rocketpool contracts and borrow their logic:\n```diff\n    function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable onlyEigenPodManager {\n+        require(EigenPodManager.getEigenPodByPubkey(_validatorPubkey) == address(0x0), \"Validator pubkey is in use\");\n+        EigenPodManager.setEigenPodByPubkey(_validatorPubkey);\n\n        require(msg.value == 32 ether, \"EigenPod.stake: must initially stake for any validator with 32 ether\");\n        ethPOS.deposit{value : 32 ether}(pubkey, _podWithdrawalCredentials(), signature, depositDataRoot);\n        emit EigenPodStaked(pubkey);\n    }\n\n```\n\n**[ChaoticWalrus (EigenLayer) disagreed with severity and commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/54#issuecomment-1549011639):**\n>We believe this is purely informational. People can already stake multiple times through the `ETH2Deposit` contract.\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/54#issuecomment-1572315807):**\n>Downgrading to QA for now. @volodya - please do send me proof that a new withdrawal would be bricked (I believe it would be releasable via the normal flow).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/54#issuecomment-1582367586):**\n>Have had a informal confirmation that excess ETH is refunded as rewards.\n>\n>In lack of additional info, am maintaining the judgment.\n\n***\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-eigenlayer",
  "Code": [
    {
      "filename": "src/contracts/pods/EigenPod.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/utils/AddressUpgradeable.sol\";\n\nimport \"../libraries/BeaconChainProofs.sol\";\nimport \"../libraries/BytesLib.sol\";\nimport \"../libraries/Endian.sol\";\n\nimport \"../interfaces/IETHPOSDeposit.sol\";\nimport \"../interfaces/IEigenPodManager.sol\";\nimport \"../interfaces/IEigenPod.sol\";\nimport \"../interfaces/IDelayedWithdrawalRouter.sol\";\nimport \"../interfaces/IPausable.sol\";\n\nimport \"./EigenPodPausingConstants.sol\";\n\n/**\n * @title The implementation contract used for restaking beacon chain ETH on EigenLayer \n * @author Layr Labs, Inc.\n * @notice The main functionalities are:\n * - creating new ETH validators with their withdrawal credentials pointed to this contract\n * - proving from beacon chain state roots that withdrawal credentials are pointed to this contract\n * - proving from beacon chain state roots the balances of ETH validators with their withdrawal credentials\n *   pointed to this contract\n * - updating aggregate balances in the EigenPodManager\n * - withdrawing eth when withdrawals are initiated\n * @dev Note that all beacon chain balances are stored as gwei within the beacon chain datastructures. We choose\n *   to account balances in terms of gwei in the EigenPod contract and convert to wei when making calls to other contracts\n */\ncontract EigenPod is IEigenPod, Initializable, ReentrancyGuardUpgradeable, EigenPodPausingConstants {\n    using BytesLib for bytes;\n\n    // CONSTANTS + IMMUTABLES\n    uint256 internal constant GWEI_TO_WEI = 1e9;\n\n    /// @notice Maximum \"staleness\" of a Beacon Chain state root against which `verifyOvercommittedStake` may be proven. 7 days in blocks.\n    uint256 internal constant VERIFY_OVERCOMMITTED_WINDOW_BLOCKS = 50400;\n\n    /// @notice This is the beacon chain deposit contract\n    IETHPOSDeposit public immutable ethPOS;\n\n    /// @notice Contract used for withdrawal routing, to provide an extra \"safety net\" mechanism\n    IDelayedWithdrawalRouter public immutable delayedWithdrawalRouter;\n\n    /// @notice The single EigenPodManager for EigenLayer\n    IEigenPodManager public immutable eigenPodManager;\n\n    /// @notice The amount of eth, in gwei, that is restaked per validator\n    uint64 public immutable REQUIRED_BALANCE_GWEI;\n\n    /// @notice The amount of eth, in wei, that is restaked per ETH validator into EigenLayer\n    uint256 public immutable REQUIRED_BALANCE_WEI;\n\n    /// @notice The owner of this EigenPod\n    address public podOwner;\n\n    /**\n     * @notice The latest block number at which the pod owner withdrew the balance of the pod.\n     * @dev This variable is only updated when the `withdraw` function is called, which can only occur before `hasRestaked` is set to true for this pod.\n     * Proofs for this pod are only valid against Beacon Chain state roots corresponding to blocks after the stored `mostRecentWithdrawalBlockNumber`.\n     */\n    uint64 public mostRecentWithdrawalBlockNumber;\n\n    // STORAGE VARIABLES\n    /// @notice the amount of execution layer ETH in this contract that is staked in EigenLayer (i.e. withdrawn from the Beacon Chain but not from EigenLayer), \n    uint64 public restakedExecutionLayerGwei;\n\n    /// @notice an indicator of whether or not the podOwner has ever \"fully restaked\" by successfully calling `verifyCorrectWithdrawalCredentials`.\n    bool public hasRestaked;\n\n    /// @notice this is a mapping of validator indices to a Validator struct containing pertinent info about the validator\n    mapping(uint40 => VALIDATOR_STATUS) public validatorStatus;\n\n    /// @notice This is a mapping of validatorIndex to withdrawalIndex to whether or not they have proven a withdrawal for that index\n    mapping(uint40 => mapping(uint64 => bool)) public provenPartialWithdrawal;\n\n    /// @notice Emitted when an ETH validator stakes via this eigenPod\n    event EigenPodStaked(bytes pubkey);\n\n    /// @notice Emitted when an ETH validator's withdrawal credentials are successfully verified to be pointed to this eigenPod\n    event ValidatorRestaked(uint40 validatorIndex);\n\n    /// @notice Emitted when an ETH validator is proven to have a balance less than `REQUIRED_BALANCE_GWEI` in the beacon chain\n    event ValidatorOvercommitted(uint40 validatorIndex);\n    \n    /// @notice Emitted when an ETH validator is prove to have withdrawn from the beacon chain\n    event FullWithdrawalRedeemed(uint40 validatorIndex, address indexed recipient, uint64 withdrawalAmountGwei);\n\n    /// @notice Emitted when a partial withdrawal claim is successfully redeemed\n    event PartialWithdrawalRedeemed(uint40 validatorIndex, address indexed recipient, uint64 partialWithdrawalAmountGwei);\n\n    /// @notice Emitted when restaked beacon chain ETH is withdrawn from the eigenPod.\n    event RestakedBeaconChainETHWithdrawn(address indexed recipient, uint256 amount);\n\n    modifier onlyEigenPodManager {\n        require(msg.sender == address(eigenPodManager), \"EigenPod.onlyEigenPodManager: not eigenPodManager\");\n        _;\n    }\n\n    modifier onlyEigenPodOwner {\n        require(msg.sender == podOwner, \"EigenPod.onlyEigenPodOwner: not podOwner\");\n        _;\n    }\n\n    modifier onlyNotFrozen {\n        require(!eigenPodManager.slasher().isFrozen(podOwner), \"EigenPod.onlyNotFrozen: pod owner is frozen\");\n        _;\n    }\n\n    modifier hasNeverRestaked {\n        require(!hasRestaked, \"EigenPod.hasNeverRestaked: restaking is enabled\");\n        _;\n    }\n\n    /// @notice Checks that `blockNumber` is strictly greater than the value stored in `mostRecentWithdrawalBlockNumber`\n    modifier proofIsForValidBlockNumber(uint64 blockNumber) {\n        require(blockNumber > mostRecentWithdrawalBlockNumber,\n            \"EigenPod.proofIsForValidBlockNumber: beacon chain proof must be for block number after mostRecentWithdrawalBlockNumber\");\n        _;\n    }\n\n    /**\n     * @notice Based on 'Pausable' code, but uses the storage of the EigenPodManager instead of this contract. This construction\n     * is necessary for enabling pausing all EigenPods at the same time (due to EigenPods being Beacon Proxies).\n     * Modifier throws if the `indexed`th bit of `_paused` in the EigenPodManager is 1, i.e. if the `index`th pause switch is flipped.\n     */\n    modifier onlyWhenNotPaused(uint8 index) {\n        require(!IPausable(address(eigenPodManager)).paused(index), \"EigenPod.onlyWhenNotPaused: index is paused in EigenPodManager\");\n        _;\n    }\n\n    constructor(\n        IETHPOSDeposit _ethPOS,\n        IDelayedWithdrawalRouter _delayedWithdrawalRouter,\n        IEigenPodManager _eigenPodManager,\n        uint256 _REQUIRED_BALANCE_WEI\n    ) {\n        ethPOS = _ethPOS;\n        delayedWithdrawalRouter = _delayedWithdrawalRouter;\n        eigenPodManager = _eigenPodManager;\n        REQUIRED_BALANCE_WEI = _REQUIRED_BALANCE_WEI;\n        REQUIRED_BALANCE_GWEI = uint64(_REQUIRED_BALANCE_WEI / GWEI_TO_WEI);\n        require(_REQUIRED_BALANCE_WEI % GWEI_TO_WEI == 0, \"EigenPod.contructor: _REQUIRED_BALANCE_WEI is not a whole number of gwei\");\n        _disableInitializers();\n    }\n\n    /// @notice Used to initialize the pointers to addresses crucial to the pod's functionality. Called on construction by the EigenPodManager.\n    function initialize(address _podOwner) external initializer {\n        require(_podOwner != address(0), \"EigenPod.initialize: podOwner cannot be zero address\");\n        podOwner = _podOwner;\n    }\n\n    /// @notice Called by EigenPodManager when the owner wants to create another ETH validator.\n    function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable onlyEigenPodManager {\n        // stake on ethpos\n        require(msg.value == 32 ether, \"EigenPod.stake: must initially stake for any validator with 32 ether\");\n        ethPOS.deposit{value : 32 ether}(pubkey, _podWithdrawalCredentials(), signature, depositDataRoot);\n        emit EigenPodStaked(pubkey);\n    }\n\n    /**\n     * @notice  This function verifies that the withdrawal credentials of the podOwner are pointed to\n     * this contract. It also verifies the current (not effective) balance  of the validator.  It verifies the provided proof of the ETH validator against the beacon chain state\n     * root, marks the validator as 'active' in EigenLayer, and credits the restaked ETH in Eigenlayer.\n     * @param oracleBlockNumber is the Beacon Chain blockNumber whose state root the `proof` will be proven against.\n     * @param validatorIndex is the index of the validator being proven, refer to consensus specs \n     * @param proofs is the bytes that prove the ETH validator's balance and withdrawal credentials against a beacon chain state root\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs \n     * for details: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyWithdrawalCredentialsAndBalance(\n        uint64 oracleBlockNumber,\n        uint40 validatorIndex,\n        BeaconChainProofs.ValidatorFieldsAndBalanceProofs calldata proofs,\n        bytes32[] calldata validatorFields\n    )\n        external\n        onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_CREDENTIALS)\n        // check that the provided `oracleBlockNumber` is after the `mostRecentWithdrawalBlockNumber`\n        proofIsForValidBlockNumber(oracleBlockNumber)\n    {\n        require(validatorStatus[validatorIndex] == VALIDATOR_STATUS.INACTIVE,\n            \"EigenPod.verifyCorrectWithdrawalCredentials: Validator must be inactive to prove withdrawal credentials\");\n\n        require(validatorFields[BeaconChainProofs.VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX] == bytes32(_podWithdrawalCredentials()),\n            \"EigenPod.verifyCorrectWithdrawalCredentials: Proof is not for this EigenPod\");\n        // deserialize the balance field from the balanceRoot\n        uint64 validatorCurrentBalanceGwei = BeaconChainProofs.getBalanceFromBalanceRoot(validatorIndex, proofs.balanceRoot);\n        \n        // make sure the balance is greater than the amount restaked per validator\n        require(validatorCurrentBalanceGwei >= REQUIRED_BALANCE_GWEI,\n            \"EigenPod.verifyCorrectWithdrawalCredentials: ETH validator's balance must be greater than or equal to the restaked balance per validator\");\n\n        // verify ETH validator proof\n        bytes32 beaconStateRoot = eigenPodManager.getBeaconChainStateRoot(oracleBlockNumber);\n        BeaconChainProofs.verifyValidatorFields(\n            validatorIndex,\n            beaconStateRoot,\n            proofs.validatorFieldsProof,\n            validatorFields\n        );\n\n        // verify ETH validator's current balance, which is stored in the `balances` container of the beacon state\n        BeaconChainProofs.verifyValidatorBalance(\n            validatorIndex,\n            beaconStateRoot,\n            proofs.validatorBalanceProof,\n            proofs.balanceRoot\n        );\n        // set the status to active\n        validatorStatus[validatorIndex] = VALIDATOR_STATUS.ACTIVE;\n\n        // Sets \"hasRestaked\" to true if it hasn't been set yet. \n        if (!hasRestaked) {\n            hasRestaked = true;\n        }\n\n        emit ValidatorRestaked(validatorIndex);\n\n        // virtually deposit REQUIRED_BALANCE_WEI for new ETH validator\n        eigenPodManager.restakeBeaconChainETH(podOwner, REQUIRED_BALANCE_WEI);\n    }\n\n    /**\n     * @notice This function records an overcommitment of stake to EigenLayer on behalf of a certain ETH validator.\n     *         If successful, the overcommitted balance is penalized (available for withdrawal whenever the pod's balance allows).\n     *         The ETH validator's shares in the enshrined beaconChainETH strategy are also removed from the StrategyManager and undelegated.\n     * @param oracleBlockNumber The oracleBlockNumber whose state root the `proof` will be proven against.\n     *        Must be within `VERIFY_OVERCOMMITTED_WINDOW_BLOCKS` of the current block.\n     * @param validatorIndex is the index of the validator being proven, refer to consensus specs \n     * @param proofs is the proof of the validator's balance and validatorFields in the balance tree and the balanceRoot to prove for\n     * @param beaconChainETHStrategyIndex is the index of the beaconChainETHStrategy for the pod owner for the callback to \n     *                                    the StrategyManager in case it must be removed from the list of the podOwners strategies\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     * @dev For more details on the Beacon Chain spec, see: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyOvercommittedStake(\n        uint40 validatorIndex,\n        BeaconChainProofs.ValidatorFieldsAndBalanceProofs calldata proofs,\n        bytes32[] calldata validatorFields,\n        uint256 beaconChainETHStrategyIndex,\n        uint64 oracleBlockNumber\n    ) external onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_OVERCOMMITTED) {\n       // ensure that the blockNumber being proven against is not \"too stale\", i.e. that the validator was *recently* overcommitted.\n        require(oracleBlockNumber + VERIFY_OVERCOMMITTED_WINDOW_BLOCKS >= block.number,\n            \"EigenPod.verifyOvercommittedStake: specified blockNumber is too far in past\");\n\n        require(validatorStatus[validatorIndex] == VALIDATOR_STATUS.ACTIVE, \"EigenPod.verifyOvercommittedStake: Validator not active\");\n\n        // deserialize the balance field from the balanceRoot\n        uint64 validatorCurrentBalanceGwei = BeaconChainProofs.getBalanceFromBalanceRoot(validatorIndex, proofs.balanceRoot);        \n\n        require(validatorCurrentBalanceGwei < REQUIRED_BALANCE_GWEI,\n            \"EigenPod.verifyOvercommittedStake: validator's balance must be less than the restaked balance per validator\");\n        \n        // verify ETH validator proof\n        bytes32 beaconStateRoot = eigenPodManager.getBeaconChainStateRoot(oracleBlockNumber);\n \n        /**\n         * If validator's balance is zero, then either they have fully withdrawn or they have been slashed down zero.\n         * If the validator *has* been slashed, then this function can proceed. If they have *not* been slashed, then\n         * the `verifyAndProcessWithdrawal` function should be called instead.\n         */\n        if (validatorCurrentBalanceGwei == 0) {\n            uint64 slashedStatus = Endian.fromLittleEndianUint64(validatorFields[BeaconChainProofs.VALIDATOR_SLASHED_INDEX]);\n            require(slashedStatus == 1, \"EigenPod.verifyOvercommittedStake: Validator must be slashed to be overcommitted\");\n            //Verify the validator fields, which contain the validator's slashed status\n            BeaconChainProofs.verifyValidatorFields(\n                validatorIndex,\n                beaconStateRoot,\n                proofs.validatorFieldsProof,\n                validatorFields\n            );\n        }\n        // verify ETH validator's current balance, which is stored in the `balances` container of the beacon state\n       BeaconChainProofs.verifyValidatorBalance(\n            validatorIndex,\n            beaconStateRoot,\n            proofs.validatorBalanceProof,\n            proofs.balanceRoot\n        );\n\n        // mark the ETH validator as overcommitted\n        validatorStatus[validatorIndex] = VALIDATOR_STATUS.OVERCOMMITTED;\n\n        emit ValidatorOvercommitted(validatorIndex);\n\n        // remove and undelegate shares in EigenLayer\n        eigenPodManager.recordOvercommittedBeaconChainETH(podOwner, beaconChainETHStrategyIndex, REQUIRED_BALANCE_WEI);\n    }\n\n    /**\n     * @notice This function records a full withdrawal on behalf of one of the Ethereum validators for this EigenPod\n     * @param withdrawalProofs is the information needed to check the veracity of the block number and withdrawal being proven\n     * @param validatorFieldsProof is the information needed to check the veracity of the validator fields being proven\n     * @param withdrawalFields are the fields of the withdrawal being proven\n     * @param validatorFields are the fields of the validator being proven\n     * @param beaconChainETHStrategyIndex is the index of the beaconChainETHStrategy for the pod owner for the callback to \n     *        the EigenPodManager to the StrategyManager in case it must be removed from the podOwner's list of strategies\n     */\n    function verifyAndProcessWithdrawal(\n        BeaconChainProofs.WithdrawalProofs calldata withdrawalProofs, \n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields,\n        bytes32[] calldata withdrawalFields,\n        uint256 beaconChainETHStrategyIndex,\n        uint64 oracleBlockNumber\n    )\n        external\n        onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_WITHDRAWAL)\n        onlyNotFrozen\n        /** \n         * Check that the provided block number being proven against is after the `mostRecentWithdrawalBlockNumber`.\n         * Without this check, there is an edge case where a user proves a past withdrawal for a validator whose funds they already withdrew,\n         * as a way to \"withdraw the same funds twice\" without providing adequate proof.\n         * Note that this check is not made using the oracleBlockNumber as in the `verifyWithdrawalCredentials` proof; instead this proof\n         * proof is made for the block number of the withdrawal, which may be within 8192 slots of the oracleBlockNumber. \n         * This difference in modifier usage is OK, since it is still not possible to `verifyAndProcessWithdrawal` against a slot that occurred\n         * *prior* to the proof provided in the `verifyWithdrawalCredentials` function.\n         */\n        proofIsForValidBlockNumber(Endian.fromLittleEndianUint64(withdrawalProofs.blockNumberRoot))\n    {\n        /**\n         * If the validator status is inactive, then withdrawal credentials were never verified for the validator,\n         * and thus we cannot know that the validator is related to this EigenPod at all!\n         */\n        uint40 validatorIndex = uint40(Endian.fromLittleEndianUint64(withdrawalFields[BeaconChainProofs.WITHDRAWAL_VALIDATOR_INDEX_INDEX]));\n        \n        require(validatorStatus[validatorIndex] != VALIDATOR_STATUS.INACTIVE,\n            \"EigenPod.verifyOvercommittedStake: Validator never proven to have withdrawal credentials pointed to this contract\");\n\n        // fetch the beacon state root for the specified block\n        bytes32 beaconStateRoot = eigenPodManager.getBeaconChainStateRoot(oracleBlockNumber);\n\n        // Verifying the withdrawal as well as the slot\n        BeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, withdrawalProofs, withdrawalFields);\n        // Verifying the validator fields, specifically the withdrawable epoch\n        BeaconChainProofs.verifyValidatorFields(validatorIndex, beaconStateRoot, validatorFieldsProof, validatorFields);\n\n        uint64 withdrawalAmountGwei = Endian.fromLittleEndianUint64(withdrawalFields[BeaconChainProofs.WITHDRAWAL_VALIDATOR_AMOUNT_INDEX]);\n\n        //check if the withdrawal occured after mostRecentWithdrawalBlockNumber\n        uint64 slot = Endian.fromLittleEndianUint64(withdrawalProofs.slotRoot);\n\n        /**\n         * if the validator's withdrawable epoch is less than or equal to the slot's epoch, then the validator has fully withdrawn because\n         * a full withdrawal is only processable after the withdrawable epoch has passed.\n         */\n        // reference: uint64 withdrawableEpoch = Endian.fromLittleEndianUint64(validatorFields[BeaconChainProofs.VALIDATOR_WITHDRAWABLE_EPOCH_INDEX]);\n        if (Endian.fromLittleEndianUint64(validatorFields[BeaconChainProofs.VALIDATOR_WITHDRAWABLE_EPOCH_INDEX]) <= slot/BeaconChainProofs.SLOTS_PER_EPOCH) {\n            _processFullWithdrawal(withdrawalAmountGwei, validatorIndex, beaconChainETHStrategyIndex, podOwner, validatorStatus[validatorIndex]);\n        } else {\n            _processPartialWithdrawal(slot, withdrawalAmountGwei, validatorIndex, podOwner);\n        }\n    }\n\n    function _processFullWithdrawal(\n        uint64 withdrawalAmountGwei,\n        uint40 validatorIndex,\n        uint256 beaconChainETHStrategyIndex,\n        address recipient,\n        VALIDATOR_STATUS status\n    ) internal {\n        uint256 amountToSend;\n\n        // if the validator has not previously been proven to be \"overcommitted\"\n        if (status == VALIDATOR_STATUS.ACTIVE) {\n            // if the withdrawal amount is greater than the REQUIRED_BALANCE_GWEI (i.e. the amount restaked on EigenLayer, per ETH validator)\n            if (withdrawalAmountGwei >= REQUIRED_BALANCE_GWEI) {\n                // then the excess is immediately withdrawable\n                amountToSend = uint256(withdrawalAmountGwei - REQUIRED_BALANCE_GWEI) * uint256(GWEI_TO_WEI);\n                // and the extra execution layer ETH in the contract is REQUIRED_BALANCE_GWEI, which must be withdrawn through EigenLayer's normal withdrawal process\n                restakedExecutionLayerGwei += REQUIRED_BALANCE_GWEI;\n            } else {\n                // otherwise, just use the full withdrawal amount to continue to \"back\" the podOwner's remaining shares in EigenLayer (i.e. none is instantly withdrawable)\n                restakedExecutionLayerGwei += withdrawalAmountGwei;\n                // remove and undelegate 'extra' (i.e. \"overcommitted\") shares in EigenLayer\n                eigenPodManager.recordOvercommittedBeaconChainETH(podOwner, beaconChainETHStrategyIndex, uint256(REQUIRED_BALANCE_GWEI - withdrawalAmountGwei) * GWEI_TO_WEI);\n            }\n        // if the validator *has* previously been proven to be \"overcommitted\"\n        } else if (status == VALIDATOR_STATUS.OVERCOMMITTED) {\n            // if the withdrawal amount is greater than the REQUIRED_BALANCE_GWEI (i.e. the amount restaked on EigenLayer, per ETH validator)\n            if (withdrawalAmountGwei >= REQUIRED_BALANCE_GWEI) {\n                // then the excess is immediately withdrawable\n                amountToSend = uint256(withdrawalAmountGwei - REQUIRED_BALANCE_GWEI) * uint256(GWEI_TO_WEI);\n                // and the extra execution layer ETH in the contract is REQUIRED_BALANCE_GWEI, which must be withdrawn through EigenLayer's normal withdrawal process\n                restakedExecutionLayerGwei += REQUIRED_BALANCE_GWEI;\n                /**\n                 * since in `verifyOvercommittedStake` the podOwner's beaconChainETH shares are decremented by `REQUIRED_BALANCE_WEI`, we must reverse the process here,\n                 * in order to allow the podOwner to complete their withdrawal through EigenLayer's normal withdrawal process\n                 */\n                eigenPodManager.restakeBeaconChainETH(podOwner, REQUIRED_BALANCE_WEI);\n            } else {\n                // otherwise, just use the full withdrawal amount to continue to \"back\" the podOwner's remaining shares in EigenLayer (i.e. none is instantly withdrawable)\n                restakedExecutionLayerGwei += withdrawalAmountGwei;\n                /**\n                 * since in `verifyOvercommittedStake` the podOwner's beaconChainETH shares are decremented by `REQUIRED_BALANCE_WEI`, we must reverse the process here,\n                 * in order to allow the podOwner to complete their withdrawal through EigenLayer's normal withdrawal process\n                 */\n                eigenPodManager.restakeBeaconChainETH(podOwner, uint256(withdrawalAmountGwei) * GWEI_TO_WEI);\n            }\n        // If the validator status is withdrawn, they have already processed their ETH withdrawal\n        }  else {\n            revert(\"EigenPod.verifyBeaconChainFullWithdrawal: VALIDATOR_STATUS is WITHDRAWN or invalid VALIDATOR_STATUS\");\n        }\n\n        // set the ETH validator status to withdrawn\n        validatorStatus[validatorIndex] = VALIDATOR_STATUS.WITHDRAWN;\n\n        emit FullWithdrawalRedeemed(validatorIndex, recipient, withdrawalAmountGwei);\n\n        // send ETH to the `recipient`, if applicable\n        if (amountToSend != 0) {\n            _sendETH(recipient, amountToSend);\n        }\n    }\n\n    function _processPartialWithdrawal(uint64 withdrawalHappenedSlot, uint64 partialWithdrawalAmountGwei, uint40 validatorIndex, address recipient) internal {\n        require(!provenPartialWithdrawal[validatorIndex][withdrawalHappenedSlot], \"EigenPod._processPartialWithdrawal: partial withdrawal has already been proven for this slot\");\n\n        provenPartialWithdrawal[validatorIndex][withdrawalHappenedSlot] = true;\n        emit PartialWithdrawalRedeemed(validatorIndex, recipient, partialWithdrawalAmountGwei);\n\n        // send the ETH to the `recipient`\n        _sendETH(recipient, uint256(partialWithdrawalAmountGwei) * uint256(GWEI_TO_WEI));\n    }\n\n    /**\n     * @notice Transfers `amountWei` in ether from this contract to the specified `recipient` address\n     * @notice Called by EigenPodManager to withdrawBeaconChainETH that has been added to the EigenPod's balance due to a withdrawal from the beacon chain.\n     * @dev Called during withdrawal or slashing.\n     */\n    function withdrawRestakedBeaconChainETH(\n        address recipient,\n        uint256 amountWei\n    )\n        external\n        onlyEigenPodManager\n    {\n        // reduce the restakedExecutionLayerGwei\n        restakedExecutionLayerGwei -= uint64(amountWei / GWEI_TO_WEI);\n\n        emit RestakedBeaconChainETHWithdrawn(recipient, amountWei);\n\n        // transfer ETH from pod to `recipient`\n        _sendETH(recipient, amountWei);\n    }\n\n    /// @notice Called by the pod owner to withdraw the balance of the pod when `hasRestaked` is set to false\n    function withdrawBeforeRestaking() external onlyEigenPodOwner hasNeverRestaked {\n        mostRecentWithdrawalBlockNumber = uint32(block.number);\n        _sendETH(podOwner, address(this).balance);\n    }\n\n    // INTERNAL FUNCTIONS\n    function _podWithdrawalCredentials() internal view returns(bytes memory) {\n        return abi.encodePacked(bytes1(uint8(1)), bytes11(0), address(this));\n    }\n\n    function _sendETH(address recipient, uint256 amountWei) internal {\n        delayedWithdrawalRouter.createDelayedWithdrawal{value: amountWei}(podOwner, recipient);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}"
    },
    {
      "filename": "contracts/contract/minipool/RocketMinipoolDelegate.sol",
      "content": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./RocketMinipoolStorageLayout.sol\";\nimport \"../../interface/casper/DepositInterface.sol\";\nimport \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolQueueInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolPenaltyInterface.sol\";\nimport \"../../interface/network/RocketNetworkPricesInterface.sol\";\nimport \"../../interface/node/RocketNodeManagerInterface.sol\";\nimport \"../../interface/node/RocketNodeStakingInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/node/settings/RocketDAONodeTrustedSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../interface/network/RocketNetworkFeesInterface.sol\";\nimport \"../../interface/token/RocketTokenRETHInterface.sol\";\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolStatus.sol\";\n\n// An individual minipool in the Rocket Pool network\n\ncontract RocketMinipoolDelegate is RocketMinipoolStorageLayout, RocketMinipoolInterface {\n\n    // Constants\n    uint8 public constant version = 2;                            // Used to identify which delegate contract each minipool is using\n    uint256 constant calcBase = 1 ether;\n    uint256 constant prelaunchAmount = 16 ether;                  // The amount of ETH initially deposited when minipool is created\n    uint256 constant distributionCooldown = 100;                  // Number of blocks that must pass between calls to distributeBalance\n\n    // Libs\n    using SafeMath for uint;\n\n    // Events\n    event StatusUpdated(uint8 indexed status, uint256 time);\n    event ScrubVoted(address indexed member, uint256 time);\n    event MinipoolScrubbed(uint256 time);\n    event MinipoolPrestaked(bytes validatorPubkey, bytes validatorSignature, bytes32 depositDataRoot, uint256 amount, bytes withdrawalCredentials, uint256 time);\n    event EtherDeposited(address indexed from, uint256 amount, uint256 time);\n    event EtherWithdrawn(address indexed to, uint256 amount, uint256 time);\n    event EtherWithdrawalProcessed(address indexed executed, uint256 nodeAmount, uint256 userAmount, uint256 totalBalance, uint256 time);\n\n    // Status getters\n    function getStatus() override external view returns (MinipoolStatus) { return status; }\n    function getFinalised() override external view returns (bool) { return finalised; }\n    function getStatusBlock() override external view returns (uint256) { return statusBlock; }\n    function getStatusTime() override external view returns (uint256) { return statusTime; }\n    function getScrubVoted(address _member) override external view returns (bool) { return memberScrubVotes[_member]; }\n\n    // Deposit type getter\n    function getDepositType() override external view returns (MinipoolDeposit) { return depositType; }\n\n    // Node detail getters\n    function getNodeAddress() override external view returns (address) { return nodeAddress; }\n    function getNodeFee() override external view returns (uint256) { return nodeFee; }\n    function getNodeDepositBalance() override external view returns (uint256) { return nodeDepositBalance; }\n    function getNodeRefundBalance() override external view returns (uint256) { return nodeRefundBalance; }\n    function getNodeDepositAssigned() override external view returns (bool) { return nodeDepositAssigned; }\n\n    // User deposit detail getters\n    function getUserDepositBalance() override external view returns (uint256) { return userDepositBalance; }\n    function getUserDepositAssigned() override external view returns (bool) { return userDepositAssignedTime != 0; }\n    function getUserDepositAssignedTime() override external view returns (uint256) { return userDepositAssignedTime; }\n    function getTotalScrubVotes() override external view returns (uint256) { return totalScrubVotes; }\n\n    // Prevent direct calls to this contract\n    modifier onlyInitialised() {\n        require(storageState == StorageState.Initialised, \"Storage state not initialised\");\n        _;\n    }\n\n    modifier onlyUninitialised() {\n        require(storageState == StorageState.Uninitialised, \"Storage state already initialised\");\n        _;\n    }\n\n    // Only allow access from the owning node address\n    modifier onlyMinipoolOwner(address _nodeAddress) {\n        require(_nodeAddress == nodeAddress, \"Invalid minipool owner\");\n        _;\n    }\n\n    // Only allow access from the owning node address or their withdrawal address\n    modifier onlyMinipoolOwnerOrWithdrawalAddress(address _nodeAddress) {\n        require(_nodeAddress == nodeAddress || _nodeAddress == rocketStorage.getNodeWithdrawalAddress(nodeAddress), \"Invalid minipool owner\");\n        _;\n    }\n\n    // Only allow access from the latest version of the specified Rocket Pool contract\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getContractAddress(_contractName), \"Invalid or outdated contract\");\n        _;\n    }\n\n    // Get the address of a Rocket Pool network contract\n    function getContractAddress(string memory _contractName) private view returns (address) {\n        address contractAddress = rocketStorage.getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        require(contractAddress != address(0x0), \"Contract not found\");\n        return contractAddress;\n    }\n\n    function initialise(address _nodeAddress, MinipoolDeposit _depositType) override external onlyUninitialised {\n        //"
    }
  ]
}