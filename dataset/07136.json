{
  "Title": "[L-01] An authorized user can unauthorize other authorized users of the same sender",
  "Content": "\nA user can grant authorization to another address to make calls on their behalf via the `Caller.callAs` function. The `Caller.unauthorize` function allows the user to revoke the authorization of another address.\n\nAn authorized user can revoke the authorization of another authorized user of the same sender. This is because the authorized user can call the `Caller.unauthorize` function on behalf of the sender.\n\n### Findings\n\n[Caller.sol#L114-L118](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Caller.sol#L114-L118)\n\n```solidity\n114: function unauthorize(address user) public {\n115:     address sender = _msgSender();\n116:     require(_authorized[sender].remove(user), \"Address is not authorized\");\n117:     emit Unauthorized(sender, user);\n118: }\n```\n\n### Recommended Mitigation Steps\n\nConsider preventing calls to the `Caller` contract address from within the `_call` function.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-01-drips-protocol-contest",
  "Code": [
    {
      "filename": "src/Caller.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.17;\n\nimport {Address} from \"openzeppelin-contracts/utils/Address.sol\";\nimport {ECDSA, EIP712} from \"openzeppelin-contracts/utils/cryptography/draft-EIP712.sol\";\nimport {ERC2771Context} from \"openzeppelin-contracts/metatx/ERC2771Context.sol\";\nimport {EnumerableSet} from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\n\nusing EnumerableSet for EnumerableSet.AddressSet;\n\n/// @notice Description of a call.\n/// @param to The called address.\n/// @param data The calldata to be used for the call.\n/// @param value The value of the call.\nstruct Call {\n    address to;\n    bytes data;\n    uint256 value;\n}\n\n/// @notice A generic call executor increasing flexibility of other smart contracts' APIs.\n/// It offers 3 main features, which can be mixed and matched for even more flexibility:\n/// - Authorizing addresses to act on behalf of other addresses\n/// - Support for EIP-712 messages\n/// - Batching calls\n///\n/// `Caller` adds these features to the APIs of all smart contracts reading the message\n/// sender passed as per ERC-2771 and accepting this contract as a trusted forwarder.\n/// To all other contracts `Caller` adds a feature of batching calls\n/// for all functions tolerating `msg.sender` being an instance of `Caller`.\n///\n/// Usage examples:\n/// - Batching sequences of calls to a contract.\n/// The contract API may consist of many functions which need to be called in sequence,\n/// but it may not offer a composite functions performing exactly that sequence.\n/// It's expensive, slow and unreliable to create a separate transaction for each step.\n/// To solve that problem create a batch of calls and submit it to `callBatched`.\n/// - Batching sequences of calls to multiple contracts.\n/// It's a common pattern to submit an ERC-2612 permit to approve a smart contract\n/// to spend the user's ERC-20 tokens before running that contract's logic.\n/// Unfortunately unless the contract's API accepts signed messages for the token it requires\n/// creating two separate transactions making it as inconvenient as a regular approval.\n/// The solution is again to use `callBatched` because it can call multiple contracts.\n/// Just create a batch first calling the ERC-20 contract and then the contract needing the tokens.\n/// - Setting up a proxy address.\n/// Sometimes a secure but inconvenient to use address like a cold wallet\n/// or a multisig needs to have a proxy or an operator.\n/// That operator is temporarily trusted, but later it must be revoked or rotated.\n/// To achieve this first `authorize` the proxy using the safe address and then use that proxy\n/// to act on behalf of the secure address using `callAs`.\n/// Later, when the proxy address needs to be revoked, either the secure address or the proxy itself\n/// can `unauthorize` the proxy address and maybe `authorize` another address.\n/// - Setting up operations callable by others.\n/// Some operations may benefit from being callable either by trusted addresses or by anybody.\n/// To achieve this deploy a smart contract executing these operations\n/// via `callAs` and, if you need that too, implementing a custom authorization.\n/// Finally, `authorize` this smart contract to act on behalf of your address.\n/// - Batching dynamic sequences of calls.\n/// Some operations need to react dynamically to the state of the blockchain.\n/// For example an unknown amount of funds is retrieved from a smart contract,\n/// which then needs to be dynamically split and used for different purposes.\n/// To do this, first deploy a smart contract performing that logic.\n/// Next, call `callBatched` which first calls `authorize` on the `Caller` itself authorizing\n/// the new contract to perform `callAs`, then calls that contract and finally `unauthorize`s it.\n/// This way the contract can perform any logic it needs on behalf of your address, but only once.\n/// - Gasless transactions.\n/// It's an increasingly common pattern to use smart contracts without necessarily spending Ether.\n/// This is achieved with gasless transactions where the wallet signs an ERC-712 message\n/// and somebody else submits the actual transaction executing what the message requests.\n/// It may be executed by another wallet or by an operator\n/// expecting to be repaid for the spent Ether in other assets.\n/// You can achieve this with `callSigned`, which allows anybody\n/// to execute a call on behalf of the signer of a message.\n/// `Caller` doesn't deal with gas, so if you're using a gasless network,\n/// it may require you to specify the gas needed for the entire call execution.\n/// - Executing batched calls with authorization or signature.\n/// You can use both `callAs` and `callSigned` to call `Caller` itself,\n/// which in turn can execute batched calls on behalf of the authorizing or signing address.\n/// It also applies to `authorize` and `unauthorize`, they too can be called using\n/// `callAs`, `callSigned` or `callBatched`.\ncontract Caller is EIP712(\"Caller\", \"1\"), ERC2771Context(address(this)) {\n    string internal constant CALL_SIGNED_TYPE_NAME = \"CallSigned(\"\n        \"address sender,address to,bytes data,uint256 value,uint256 nonce,uint256 deadline)\";\n    bytes32 internal immutable callSignedTypeHash = keccak256(bytes(CALL_SIGNED_TYPE_NAME));\n\n    /// @notice Each sender's set of address authorized to make calls on its behalf.\n    // slither-disable-next-line naming-convention\n    mapping(address => EnumerableSet.AddressSet) internal _authorized;\n    /// @notice The nonce which needs to be used in the next EIP-712 message signed by the address.\n    mapping(address => uint256) public nonce;\n\n    /// @notice Emitted when granting the authorization\n    /// of an address to make calls on behalf of the `sender`.\n    /// @param sender The authorizing address.\n    /// @param authorized The authorized address.\n    event Authorized(address indexed sender, address indexed authorized);\n\n    /// @notice Emitted when revoking the authorization\n    /// of an address to make calls on behalf of the `sender`.\n    /// @param sender The authorizing address.\n    /// @param unauthorized The authorized address.\n    event Unauthorized(address indexed sender, address indexed unauthorized);\n\n    /// @notice Grants the authorization of an address to make calls on behalf of the sender.\n    /// @param user The authorized address.\n    function authorize(address user) public {\n        address sender = _msgSender();\n        require(_authorized[sender].add(user), \"Address already is authorized\");\n        emit Authorized(sender, user);\n    }\n\n    /// @notice Revokes the authorization of an address to make calls on behalf of the sender.\n    /// @param user The unauthorized address.\n    function unauthorize(address user) public {\n        address sender = _msgSender();\n        require(_authorized[sender].remove(user), \"Address is not authorized\");\n        emit Unauthorized(sender, user);\n    }\n\n    /// @notice Checks if an address is authorized to make calls on behalf of a sender.\n    /// @param sender The authorizing address.\n    /// @param user The potentially authorized address.\n    /// @return authorized True if `user` is authorized.\n    function isAuthorized(address sender, address user) public view returns (bool authorized) {\n        return _authorized[sender].contains(user);\n    }\n\n    /// @notice Returns all the addresses authorized to make calls on behalf of a sender.\n    /// @param sender The authorizing address.\n    /// @return authorized The list of all the authorized addresses, ordered arbitrarily.\n    /// The list's order may change when sender authorizes or unauthorizes addresses.\n    function allAuthorized(address sender) public view returns (address[] memory authorized) {\n        return _authorized[sender].values();\n    }\n\n    /// @notice Makes a call on behalf of the `sender`.\n    /// Callable only by an address currently `authorize`d by the `sender`.\n    /// Reverts if the call reverts or the called address is not a smart contract.\n    /// This function is payable, any Ether sent to it will be passed in the call.\n    /// @param sender The sender to be set as the message sender of the call as per ERC-2771.\n    /// @param to The called address.\n    /// @param data The calldata to be used for the call.\n    /// @return returnData The data returned by the call.\n    function callAs(address sender, address to, bytes memory data)\n        public\n        payable\n        returns (bytes memory returnData)\n    {\n        require(isAuthorized(sender, _msgSender()), \"Not authorized\");\n        return _call(sender, to, data, msg.value);\n    }\n\n    /// @notice Makes a call on behalf of the `sender`.\n    /// Requires a `sender`'s signature of an ERC-721 message approving the call.\n    /// Reverts if the call reverts or the called address is not a smart contract.\n    /// This function is payable, any Ether sent to it will be passed in the call.\n    /// @param sender The sender to be set as the message sender of the call as per ERC-2771.\n    /// @param to The called address.\n    /// @param data The calldata to be used for the call.\n    /// @param deadline The timestamp until which the message signature is valid.\n    /// @param r The `r` part of the compact message signature as per EIP-2098.\n    /// @param sv The `sv` part of the compact message signature as per EIP-2098.\n    /// @return returnData The data returned by the call.\n    function callSigned(\n        address sender,\n        address to,\n        bytes memory data,\n        uint256 deadline,\n        bytes32 r,\n        bytes32 sv\n    ) public payable returns (bytes memory returnData) {\n        // slither-disable-next-line timestamp\n        require(block.timestamp <= deadline, \"Execution deadline expired\");\n        uint256 currNonce = nonce[sender]++;\n        bytes32 executeHash = keccak256(\n            abi.encode(\n                callSignedTypeHash, sender, to, keccak256(data), msg.value, currNonce, deadline\n            )\n        );\n        address signer = ECDSA.recover(_hashTypedDataV4(executeHash), r, sv);\n        require(signer == sender, \"Invalid signature\");\n        return _call(sender, to, data, msg.value);\n    }\n\n    /// @notice Executes a batch of calls.\n    /// The caller will be set as the message sender of all the calls as per ERC-2771.\n    /// Reverts if any of the calls reverts or any of the called addresses is not a smart contract.\n    /// This function is payable, any Ether sent to it can be used in the batched calls.\n    /// Any unused Ether will stay in this contract,\n    /// anybody will be able to use it in future calls to `callBatched`.\n    /// @param calls The calls to perform.\n    /// @return returnData The data returned by each of the calls.\n    function callBatched(Call[] memory calls) public payable returns (bytes[] memory returnData) {\n        returnData = new bytes[](calls.length);\n        address sender = _msgSender();\n        for (uint256 i = 0; i < calls.length; i++) {\n            Call memory call = calls[i];\n            returnData[i] = _call(sender, call.to, call.data, call.value);\n        }\n    }\n\n    function _call(address sender, address to, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory returnData)\n    {\n        // Encode the message sender as per ERC-2771\n        return Address.functionCallWithValue(to, abi.encodePacked(data, sender), value);\n    }\n}"
    }
  ]
}