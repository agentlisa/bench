{
  "Title": "[M01] Static arguments passed after dynamic arguments",
  "Content": "In the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract, the [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L68) and [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L67) bytes fields are used as arguments for the [`_callGetTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L326) and [`_callGetMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L315) functions. These calls provide a way to calculate one side of the swap based on the other side, and they allow users to partially fill orders.\n\n\nThe [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L68)/[`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L67) fields are dynamic variables and are packed in front of the [`takerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L321) and [`makerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L332) values in the [`_callGetTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L326) and [`_callGetMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L315) functions. It is possible for a malicious maker to provide more data than expected in the [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L68) and  \n\n[`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L67) fields to push the [`takerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L321) and [`makerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L332) bytes past where they are assumed to be when being decoded in the next function. This allows the maker to shift the passed in taker or maker amount by a full bytes to the right and even replace them completely if an extra 32 bytes of data is provided.\n\n\nUsers already have to manually review the [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L68) and [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L67) fields in the order, but this technique is rather hard to spot. Also worth noting, this attack even applies to the internally trusted [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol#L14) and [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol#L20) functions. For most attacks, providing a reasonable threshold amount will prevent loss of funds.\n\n\nTo prevent this, consider encoding the static arguments before the dynamic arguments to avoid giving the dynamic arguments a method to control the static arguments.\n\n\n***Update:** Not fixed. The 1inch team stated:*\n\n\n\n> We’ll take extra care with getters validation. We’ll try to implement sanity validation of getters in our sdk that will help with filtering potentially malicious orders.\n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OrderMixin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./helpers/AmountCalculator.sol\";\nimport \"./helpers/ChainlinkCalculator.sol\";\nimport \"./helpers/NonceManager.sol\";\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./interfaces/InteractiveNotificationReceiver.sol\";\nimport \"./libraries/ArgumentsDecoder.sol\";\nimport \"./libraries/Permitable.sol\";\n\n/// @title Order Limits v1 mixin\nabstract contract OrderMixin is\n    EIP712,\n    AmountCalculator,\n    ChainlinkCalculator,\n    NonceManager,\n    PredicateHelper,\n    Permitable\n{\n    using Address for address;\n    using ArgumentsDecoder for bytes;\n\n    /// @notice Emitted every time order gets filled, including partial fills\n    event OrderFilled(\n        address indexed maker,\n        bytes32 orderHash,\n        uint256 remaining\n    );\n\n    /// @notice Emitted when order gets cancelled\n    event OrderCanceled(\n        address indexed maker,\n        bytes32 orderHash\n    );\n\n    // Fixed-size order part with core information\n    struct StaticOrder {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n    }\n\n    // `StaticOrder` extension including variable-sized additional order meta information\n    struct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n        bytes makerAssetData;\n        bytes takerAssetData;\n        bytes getMakerAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n        bytes getTakerAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n        bytes predicate;      // this.staticcall(bytes) => (bool)\n        bytes permit;         // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n        bytes interaction;\n    }\n\n    bytes32 constant public LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(uint256 salt,address makerAsset,address takerAsset,address maker,address receiver,address allowedSender,uint256 makingAmount,uint256 takingAmount,bytes makerAssetData,bytes takerAssetData,bytes getMakerAmount,bytes getTakerAmount,bytes predicate,bytes permit,bytes interaction)\"\n    );\n\n    /// @notice Stores unfilled amounts for each order plus one.\n    /// Therefore 0 means order doesn't exist and 1 means order was filled\n    mapping(bytes32 => uint256) private _remaining;\n\n    /// @notice Returns unfilled amount for order. Throws if order does not exist\n    function remaining(bytes32 orderHash) external view returns(uint256 amount) {\n        amount = _remaining[orderHash];\n        require(amount > 0, \"LOP: Unknown order\");\n        unchecked { amount -= 1; }\n    }\n\n    /// @notice Returns unfilled amount for order\n    /// @return Result Unfilled amount of order plus one if order exists. Otherwise 0\n    function remainingRaw(bytes32 orderHash) external view returns(uint256) {\n        return _remaining[orderHash];\n    }\n\n    /// @notice Same as `remainingRaw` but for multiple orders\n    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory results) {\n        results = new uint256[](orderHashes.length);\n        for (uint i = 0; i < orderHashes.length; i++) {\n            results[i] = _remaining[orderHashes[i]];\n        }\n    }\n\n    /// @notice Checks order predicate\n    function checkPredicate(Order memory order) public view returns(bool) {\n        bytes memory result = address(this).functionStaticCall(order.predicate, \"LOP: predicate call failed\");\n        require(result.length == 32, \"LOP: invalid predicate return\");\n        return result.decodeBool();\n    }\n\n    /**\n     * @notice Calls every target with corresponding data. Then reverts with CALL_RESULTS_0101011 where zeroes and ones\n     * denote failure or success of the corresponding call\n     * @param targets Array of addresses that will be called\n     * @param data Array of data that will be passed to each call\n     */\n    function simulateCalls(address[] calldata targets, bytes[] calldata data) external {\n        require(targets.length == data.length, \"LOP: array size mismatch\");\n        bytes memory reason = new bytes(targets.length);\n        for (uint i = 0; i < targets.length; i++) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = targets[i].call(data[i]);\n            if (success && result.length > 0) {\n                success = result.decodeBool();\n            }\n            reason[i] = success ? bytes1(\"1\") : bytes1(\"0\");\n        }\n\n        // Always revert and provide per call results\n        revert(string(abi.encodePacked(\"CALL_RESULTS_\", reason)));\n    }\n\n    /// @notice Cancels order by setting remaining amount to zero\n    function cancelOrder(Order memory order) external {\n        require(order.maker == msg.sender, \"LOP: Access denied\");\n\n        bytes32 orderHash = _hash(order);\n        require(_remaining[orderHash] != 1, \"LOP: already filled\");\n        _remaining[orderHash] = 1;\n        emit OrderCanceled(msg.sender, orderHash);\n    }\n\n    /// @notice Fills an order. If one doesn't exist (first fill) it will be created using order.makerAssetData\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount\n    ) external returns(uint256, uint256) {\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, msg.sender);\n    }\n\n    /// @notice Same as `fillOrder` but calls permit first,\n    /// allowing to approve token spending and make a swap in one transaction.\n    /// Also allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    /// @param target Address that will receive swap funds\n    /// @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.\n    /// See tests for examples\n    function fillOrderToWithPermit(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target,\n        bytes calldata permit\n    ) external returns(uint256, uint256) {\n        (address token, bytes calldata permitData) = permit.decodeTargetAndData();\n        _permit(token, permitData);\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, target);\n    }\n\n    /// @notice Same as `fillOrder` but allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    /// @param target Address that will receive swap funds\n    function fillOrderTo(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target\n    ) public returns(uint256, uint256) {\n        bytes32 orderHash = _hash(order);\n\n        {  // Stack too deep\n            uint256 remainingMakerAmount = _remaining[orderHash];\n            if (remainingMakerAmount == 0) {\n                // First fill: validate order and permit maker asset\n                require(order.allowedSender == address(0) || order.allowedSender == msg.sender, \"LOP: private order\");\n                require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"LOP: bad signature\");\n                remainingMakerAmount = order.makingAmount;\n                if (order.permit.length > 0) {\n                    (address token, bytes memory permit) = order.permit.decodeTargetAndCalldata();\n                    _permitMemory(token, permit);\n                    require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n                }\n            } else {\n                unchecked { remainingMakerAmount -= 1; }\n            }\n\n            // Check if order is valid\n            if (order.predicate.length > 0) {\n                require(checkPredicate(order), \"LOP: predicate returned false\");\n            }\n\n            // Compute maker and taker assets amount\n            if ((takingAmount == 0) == (makingAmount == 0)) {\n                revert(\"LOP: only one amount should be 0\");\n            }\n            else if (takingAmount == 0) {\n                if (makingAmount > remainingMakerAmount) {\n                    makingAmount = remainingMakerAmount;\n                }\n                takingAmount = _callGetTakerAmount(order, makingAmount);\n                require(takingAmount <= thresholdAmount, \"LOP: taking amount too high\");\n            }\n            else {\n                makingAmount = _callGetMakerAmount(order, takingAmount);\n                if (makingAmount > remainingMakerAmount) {\n                    makingAmount = remainingMakerAmount;\n                    takingAmount = _callGetTakerAmount(order, makingAmount);\n                }\n                require(makingAmount >= thresholdAmount, \"LOP: making amount too low\");\n            }\n\n            require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n            // Update remaining amount in storage\n            unchecked {\n                remainingMakerAmount = remainingMakerAmount - makingAmount;\n                _remaining[orderHash] = remainingMakerAmount + 1;\n            }\n            emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n        }\n\n        // Taker => Maker\n        _makeCall(\n            order.takerAsset,\n            abi.encodePacked(\n                IERC20.transferFrom.selector,\n                uint256(uint160(msg.sender)),\n                uint256(uint160(order.receiver == address(0) ? order.maker : order.receiver)),\n                takingAmount,\n                order.takerAssetData\n            )\n        );\n\n        // Maker can handle funds interactively\n        if (order.interaction.length > 0) {\n            (address interactionTarget, bytes memory interactionData) = order.interaction.decodeTargetAndCalldata();\n            InteractiveNotificationReceiver(interactionTarget).notifyFillOrder(\n                msg.sender, order.makerAsset, order.takerAsset, makingAmount, takingAmount, interactionData\n            );\n        }\n\n        // Maker => Taker\n        _makeCall(\n            order.makerAsset,\n            abi.encodePacked(\n                IERC20.transferFrom.selector,\n                uint256(uint160(order.maker)),\n                uint256(uint160(target)),\n                makingAmount,\n                order.makerAsset\n            )\n        );\n\n        return (makingAmount, takingAmount);\n    }\n\n    function _hash(Order memory order) private view returns(bytes32) {\n        StaticOrder memory staticOrder;\n        assembly {  // solhint-disable-line no-inline-assembly\n            staticOrder := order\n        }\n        return _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    LIMIT_ORDER_TYPEHASH,\n                    staticOrder,\n                    keccak256(order.makerAssetData),\n                    keccak256(order.takerAssetData),\n                    keccak256(order.getMakerAmount),\n                    keccak256(order.getTakerAmount),\n                    keccak256(order.predicate),\n                    keccak256(order.permit),\n                    keccak256(order.interaction)\n                )\n            )\n        );\n    }\n\n    function _makeCall(address asset, bytes memory assetData) private {\n        bytes memory result = asset.functionCall(assetData, \"LOP: asset.call failed\");\n        if (result.length > 0) {\n            require(result.decodeBool(), \"LOP: asset.call bad result\");\n        }\n    }\n\n    function _callGetMakerAmount(Order memory order, uint256 takerAmount) private view returns(uint256 makerAmount) {\n        if (order.getMakerAmount.length == 0) {\n            // On empty order.getMakerAmount calldata only whole fills are allowed\n            require(takerAmount == order.takingAmount, \"LOP: wrong taker amount\");\n            return order.makingAmount;\n        }\n        bytes memory result = address(this).functionStaticCall(abi.encodePacked(order.getMakerAmount, takerAmount), \"LOP: getMakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getMakerAmount ret\");\n        return result.decodeUint256();\n    }\n\n    function _callGetTakerAmount(Order memory order, uint256 makerAmount) private view returns(uint256 takerAmount) {\n        if (order.getTakerAmount.length == 0) {\n            // On empty order.getTakerAmount calldata only whole fills are allowed\n            require(makerAmount == order.makingAmount, \"LOP: wrong maker amount\");\n            return order.takingAmount;\n        }\n        bytes memory result = address(this).functionStaticCall(abi.encodePacked(order.getTakerAmount, makerAmount), \"LOP: getTakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getTakerAmount ret\");\n        return result.decodeUint256();\n    }\n}"
    },
    {
      "filename": "contracts/OrderMixin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./helpers/AmountCalculator.sol\";\nimport \"./helpers/ChainlinkCalculator.sol\";\nimport \"./helpers/NonceManager.sol\";\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./interfaces/InteractiveNotificationReceiver.sol\";\nimport \"./libraries/ArgumentsDecoder.sol\";\nimport \"./libraries/Permitable.sol\";\n\n/// @title Order Limits v1 mixin\nabstract contract OrderMixin is\n    EIP712,\n    AmountCalculator,\n    ChainlinkCalculator,\n    NonceManager,\n    PredicateHelper,\n    Permitable\n{\n    using Address for address;\n    using ArgumentsDecoder for bytes;\n\n    /// @notice Emitted every time order gets filled, including partial fills\n    event OrderFilled(\n        address indexed maker,\n        bytes32 orderHash,\n        uint256 remaining\n    );\n\n    /// @notice Emitted when order gets cancelled\n    event OrderCanceled(\n        address indexed maker,\n        bytes32 orderHash\n    );\n\n    // Fixed-size order part with core information\n    struct StaticOrder {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n    }\n\n    // `StaticOrder` extension including variable-sized additional order meta information\n    struct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n        bytes makerAssetData;\n        bytes takerAssetData;\n        bytes getMakerAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n        bytes getTakerAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n        bytes predicate;      // this.staticcall(bytes) => (bool)\n        bytes permit;         // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n        bytes interaction;\n    }\n\n    bytes32 constant public LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(uint256 salt,address makerAsset,address takerAsset,address maker,address receiver,address allowedSender,uint256 makingAmount,uint256 takingAmount,bytes makerAssetData,bytes takerAssetData,bytes getMakerAmount,bytes getTakerAmount,bytes predicate,bytes permit,bytes interaction)\"\n    );\n\n    /// @notice Stores unfilled amounts for each order plus one.\n    /// Therefore 0 means order doesn't exist and 1 means order was filled\n    mapping(bytes32 => uint256) private _remaining;\n\n    /// @notice Returns unfilled amount for order. Throws if order does not exist\n    function remaining(bytes32 orderHash) external view returns(uint256 amount) {\n        amount = _remaining[orderHash];\n        require(amount > 0, \"LOP: Unknown order\");\n        unchecked { amount -= 1; }\n    }\n\n    /// @notice Returns unfilled amount for order\n    /// @return Result Unfilled amount of order plus one if order exists. Otherwise 0\n    function remainingRaw(bytes32 orderHash) external view returns(uint256) {\n        return _remaining[orderHash];\n    }\n\n    /// @notice Same as `remainingRaw` but for multiple orders\n    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory results) {\n        results = new uint256[](orderHashes.length);\n        for (uint i = 0; i < orderHashes.length; i++) {\n            results[i] = _remaining[orderHashes[i]];\n        }\n    }\n\n    /// @notice Checks order predicate\n    function checkPredicate(Order memory order) public view returns(bool) {\n        bytes memory result = address(this).functionStaticCall(order.predicate, \"LOP: predicate call failed\");\n        require(result.length == 32, \"LOP: invalid predicate return\");\n        return result.decodeBool();\n    }\n\n    /**\n     * @notice Calls every target with corresponding data. Then reverts with CALL_RESULTS_0101011 where zeroes and ones\n     * denote failure or success of the corresponding call\n     * @param targets Array of addresses that will be called\n     * @param data Array of data that will be passed to each call\n     */\n    function simulateCalls(address[] calldata targets, bytes[] calldata data) external {\n        require(targets.length == data.length, \"LOP: array size mismatch\");\n        bytes memory reason = new bytes(targets.length);\n        for (uint i = 0; i < targets.length; i++) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = targets[i].call(data[i]);\n            if (success && result.length > 0) {\n                success = result.decodeBool();\n            }\n            reason[i] = success ? bytes1(\"1\") : bytes1(\"0\");\n        }\n\n        // Always revert and provide per call results\n        revert(string(abi.encodePacked(\"CALL_RESULTS_\", reason)));\n    }\n\n    /// @notice Cancels order by setting remaining amount to zero\n    function cancelOrder(Order memory order) external {\n        require(order.maker == msg.sender, \"LOP: Access denied\");\n\n        bytes32 orderHash = _hash(order);\n        require(_remaining[orderHash] != 1, \"LOP: already filled\");\n        _remaining[orderHash] = 1;\n        emit OrderCanceled(msg.sender, orderHash);\n    }\n\n    /// @notice Fills an order. If one doesn't exist (first fill) it will be created using order.makerAssetData\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount\n    ) external returns(uint256, uint256) {\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, msg.sender);\n    }\n\n    /// @notice Same as `fillOrder` but calls permit first,\n    /// allowing to approve token spending and make a swap in one transaction.\n    /// Also allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    /// @param target Address that will receive swap funds\n    /// @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.\n    /// See tests for examples\n    function fillOrderToWithPermit(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target,\n        bytes calldata permit\n    ) external returns(uint256, uint256) {\n        (address token, bytes calldata permitData) = permit.decodeTargetAndData();\n        _permit(token, permitData);\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, target);\n    }\n\n    /// @notice Same as `fillOrder` but allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    /// @param target Address that will receive swap funds\n    function fillOrderTo(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target\n    ) public returns(uint256, uint256) {\n        bytes32 orderHash = _hash(order);\n\n        {  // Stack too deep\n            uint256 remainingMakerAmount = _remaining[orderHash];\n            if (remainingMakerAmount == 0) {\n                // First fill: validate order and permit maker asset\n                require(order.allowedSender == address(0) || order.allowedSender == msg.sender, \"LOP: private order\");\n                require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"LOP: bad signature\");\n                remainingMakerAmount = order.makingAmount;\n                if (order.permit.length > 0) {\n                    (address token, bytes memory permit) = order.permit.decodeTargetAndCalldata();\n                    _permitMemory(token, permit);\n                    require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n                }\n            } else {\n                unchecked { remainingMakerAmount -= 1; }\n            }\n\n            // Check if order is valid\n            if (order.predicate.length > 0) {\n                require(checkPredicate(order), \"LOP: predicate returned false\");\n            }\n\n            // Compute maker and taker assets amount\n            if ((takingAmount == 0) == (makingAmount == 0)) {\n                revert(\"LOP: only one amount should be 0\");\n            }\n            else if (takingAmount == 0) {\n                if (makingAmount > remainingMakerAmount) {\n                    makingAmount = remainingMakerAmount;\n                }\n                takingAmount = _callGetTakerAmount(order, makingAmount);\n                require(takingAmount <= thresholdAmount, \"LOP: taking amount too high\");\n            }\n            else {\n                makingAmount = _callGetMakerAmount(order, takingAmount);\n                if (makingAmount > remainingMakerAmount) {\n                    makingAmount = remainingMakerAmount;\n                    takingAmount = _callGetTakerAmount(order, makingAmount);\n                }\n                require(makingAmount >= thresholdAmount, \"LOP: making amount too low\");\n            }\n\n            require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n            // Update remaining amount in storage\n            unchecked {\n                remainingMakerAmount = remainingMakerAmount - makingAmount;\n                _remaining[orderHash] = remainingMakerAmount + 1;\n            }\n            emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n        }\n\n        // Taker => Maker\n        _makeCall(\n            order.takerAsset,\n            abi.encodePacked(\n                IERC20.transferFrom.selector,\n                uint256(uint160(msg.sender)),\n                uint256(uint160(order.receiver == address(0) ? order.maker : order.receiver)),\n                takingAmount,\n                order.takerAssetData\n            )\n        );\n\n        // Maker can handle funds interactively\n        if (order.interaction.length > 0) {\n            (address interactionTarget, bytes memory interactionData) = order.interaction.decodeTargetAndCalldata();\n            InteractiveNotificationReceiver(interactionTarget).notifyFillOrder(\n                msg.sender, order.makerAsset, order.takerAsset, makingAmount, takingAmount, interactionData\n            );\n        }\n\n        // Maker => Taker\n        _makeCall(\n            order.makerAsset,\n            abi.encodePacked(\n                IERC20.transferFrom.selector,\n                uint256(uint160(order.maker)),\n                uint256(uint160(target)),\n                makingAmount,\n                order.makerAsset\n            )\n        );\n\n        return (makingAmount, takingAmount);\n    }\n\n    function _hash(Order memory order) private view returns(bytes32) {\n        StaticOrder memory staticOrder;\n        assembly {  // solhint-disable-line no-inline-assembly\n            staticOrder := order\n        }\n        return _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    LIMIT_ORDER_TYPEHASH,\n                    staticOrder,\n                    keccak256(order.makerAssetData),\n                    keccak256(order.takerAssetData),\n                    keccak256(order.getMakerAmount),\n                    keccak256(order.getTakerAmount),\n                    keccak256(order.predicate),\n                    keccak256(order.permit),\n                    keccak256(order.interaction)\n                )\n            )\n        );\n    }\n\n    function _makeCall(address asset, bytes memory assetData) private {\n        bytes memory result = asset.functionCall(assetData, \"LOP: asset.call failed\");\n        if (result.length > 0) {\n            require(result.decodeBool(), \"LOP: asset.call bad result\");\n        }\n    }\n\n    function _callGetMakerAmount(Order memory order, uint256 takerAmount) private view returns(uint256 makerAmount) {\n        if (order.getMakerAmount.length == 0) {\n            // On empty order.getMakerAmount calldata only whole fills are allowed\n            require(takerAmount == order.takingAmount, \"LOP: wrong taker amount\");\n            return order.makingAmount;\n        }\n        bytes memory result = address(this).functionStaticCall(abi.encodePacked(order.getMakerAmount, takerAmount), \"LOP: getMakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getMakerAmount ret\");\n        return result.decodeUint256();\n    }\n\n    function _callGetTakerAmount(Order memory order, uint256 makerAmount) private view returns(uint256 takerAmount) {\n        if (order.getTakerAmount.length == 0) {\n            // On empty order.getTakerAmount calldata only whole fills are allowed\n            require(makerAmount == order.makingAmount, \"LOP: wrong maker amount\");\n            return order.takingAmount;\n        }\n        bytes memory result = address(this).functionStaticCall(abi.encodePacked(order.getTakerAmount, makerAmount), \"LOP: getTakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getTakerAmount ret\");\n        return result.decodeUint256();\n    }\n}"
    },
    {
      "filename": "contracts/OrderMixin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./helpers/AmountCalculator.sol\";\nimport \"./helpers/ChainlinkCalculator.sol\";\nimport \"./helpers/NonceManager.sol\";\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./interfaces/InteractiveNotificationReceiver.sol\";\nimport \"./libraries/ArgumentsDecoder.sol\";\nimport \"./libraries/Permitable.sol\";\n\n/// @title Order Limits v1 mixin\nabstract contract OrderMixin is\n    EIP712,\n    AmountCalculator,\n    ChainlinkCalculator,\n    NonceManager,\n    PredicateHelper,\n    Permitable\n{\n    using Address for address;\n    using ArgumentsDecoder for bytes;\n\n    /// @notice Emitted every time order gets filled, including partial fills\n    event OrderFilled(\n        address indexed maker,\n        bytes32 orderHash,\n        uint256 remaining\n    );\n\n    /// @notice Emitted when order gets cancelled\n    event OrderCanceled(\n        address indexed maker,\n        bytes32 orderHash\n    );\n\n    // Fixed-size order part with core information\n    struct StaticOrder {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n    }\n\n    // `StaticOrder` extension including variable-sized additional order meta information\n    struct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n        bytes makerAssetData;\n        bytes takerAssetData;\n        bytes getMakerAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n        bytes getTakerAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n        bytes predicate;      // this.staticcall(bytes) => (bool)\n        bytes permit;         // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n        bytes interaction;\n    }\n\n    bytes32 constant public LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(uint256 salt,address makerAsset,address takerAsset,address maker,address receiver,address allowedSender,uint256 makingAmount,uint256 takingAmount,bytes makerAssetData,bytes takerAssetData,bytes getMakerAmount,bytes getTakerAmount,bytes predicate,bytes permit,bytes interaction)\"\n    );\n\n    /// @notice Stores unfilled amounts for each order plus one.\n    /// Therefore 0 means order doesn't exist and 1 means order was filled\n    mapping(bytes32 => uint256) private _remaining;\n\n    /// @notice Returns unfilled amount for order. Throws if order does not exist\n    function remaining(bytes32 orderHash) external view returns(uint256 amount) {\n        amount = _remaining[orderHash];\n        require(amount > 0, \"LOP: Unknown order\");\n        unchecked { amount -= 1; }\n    }\n\n    /// @notice Returns unfilled amount for order\n    /// @return Result Unfilled amount of order plus one if order exists. Otherwise 0\n    function remainingRaw(bytes32 orderHash) external view returns(uint256) {\n        return _remaining[orderHash];\n    }\n\n    /// @notice Same as `remainingRaw` but for multiple orders\n    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory results) {\n        results = new uint256[](orderHashes.length);\n        for (uint i = 0; i < orderHashes.length; i++) {\n            results[i] = _remaining[orderHashes[i]];\n        }\n    }\n\n    /// @notice Checks order predicate\n    function checkPredicate(Order memory order)"
    }
  ]
}