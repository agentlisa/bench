{
  "Title": "LibOracle fails to check the fidelity of price data from WETH/USDC pool, which can lead to price manipulation",
  "Content": "# LibOracle fails to check the fidelity of price data from WETH/USDC pool, which can lead to price manipulation\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOracle.sol#L91-L92\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOracle.sol#L91-L92</a>\n\n\n## Summary\n\nAs per the [documentation](https://dittoeth.com/technical/oracles), LibOracle should only be returning the TWAP price from the WETH/USDC pool if the amount of WETH in the pool is >= 100e18. This is to ensure the fidelity of the data, which reduces the risk of price manipulation. However, this is not properly implemented for the case in which there was an invalid fetch of chainlink data. In this case, LibOracle simply returns the TWAP price without checking if there's enough liquidity in the pool. This can lead to a lack of data fidelity for the returned price.\n\nIt's clear that reverting should be the correct action rather than returning the TWAP price without checking the liquidity, as even when there is a valid chainlink price, if the TWAP price is closer to the cached price (and there isn't enough liquidity), it will still revert.\n\n## Vulnerability Details\n\nLibOracle has a `baseOracleCircuitBreaker` function which handles whether to return the TWAP price or the chainlink price, when the asset is USD, and it is defined as follows:\n```solidity\nfunction baseOracleCircuitBreaker(\n    uint256 protocolPrice,\n    uint80 roundId,\n    int256 chainlinkPrice,\n    uint256 timeStamp,\n    uint256 chainlinkPriceInEth\n) private view returns (uint256 _protocolPrice) {\n    bool invalidFetchData = roundId == 0 || timeStamp == 0\n        || timeStamp > block.timestamp || chainlinkPrice <= 0\n        || block.timestamp > 2 hours + timeStamp;\n    ...\n    if (invalidFetchData || priceDeviation) {\n        uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n            Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n        );\n        uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n        uint256 twapPriceInv = twapPriceInEther.inv();\n        if (twapPriceInEther == 0) {\n            revert Errors.InvalidTwapPrice();\n        }\n\n        if (invalidFetchData) {\n            return twapPriceInv; // @issue\n        } else {\n            ...\n        }\n    } else {\n        return chainlinkPriceInEth;\n    }\n}\n```\nWhen `invalidFetchData` is true, meaning that the chainlink price was not properly fetched, it will always return `twapPriceInv`. However, this lacks any checks as to whether there is at least 100 WETH in the Uniswap pool, which can result in a lack of data fidelity.\n\n## Impact\n\nWhen the chainlink oracle is not functioning correctly, LibOracle will always return the TWAP price for the USD asset. However, this lacks any check as to whether there is enough liquidity in the Uniswap pool to guarantee data fidelity, meaning there is a higher likelihood of price manipulation.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\nBefore returning the TWAP price when `invalidFetchData` is true, first check whether the WETH/USDC pool has enough liquidity.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    }
  ]
}