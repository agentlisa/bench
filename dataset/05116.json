{
  "Title": "[G-10] Using calldata instead of memory for read-only arguments in external functions saves gas",
  "Content": "\n**Instance 1:**\n\nRefactor the `PendlePowerFarmToken.initialize()` function to use `calldata` in place of `memory` for the `_tokenName` amd `_symbolName` parameters.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L685-#L686\n\nSince the string parameters `_tokenName` amd `_symbolName` were not modified, we can reduce the gas cost of the `PendlePowerFarmToken.initialize()` function by using `calldata` in place of `memory` in the definition of the `_tokenName` amd `_symbolName` parameters. In implementing this we would avoid having to copy the strings from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n682:    function initialize(\n683:        address _underlyingPendleMarket,\n684:        address _pendleController,\n685:        string memory _tokenName,   //@audit use calldata in-place of memory\n686:        string memory _symbolName,   //@audit use calldata in-place of memory\n687:        uint16 _maxCardinality\n688:    )\n689:        external\n690:    {\n.\n.\n.\n732:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..2f53c1d 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -682,8 +682,8 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n     function initialize(\n         address _underlyingPendleMarket,\n         address _pendleController,\n-        string memory _tokenName,\n-        string memory _symbolName,\n+        string calldata _tokenName,\n+        string calldata _symbolName,\n         uint16 _maxCardinality\n     )\n```\n\n**Instance 2:**\n\nRefactor the `FeeManager.revokeBeneficial()` function to use `calldata` in place of `memory` for the `_feeTokens` parameter.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L573\n\nSince the `_feeTokens` array is not modified, we can reduce the gas cost of the `FeeManager.revokeBeneficial()` function by using `calldata` in place of `memory` in the definition of the `_feeTokens` parameter. In implementing this we would avoid having to copy the array from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/FeeManager/FeeManager.sol\n\n571:    function revokeBeneficial(\n572:        address _user,\n573:        address[] memory _feeTokens    //@audit use calldata in-place of memory\n574:    )\n575:        external\n576:        onlyMaster\n577:    {\n.\n.\n.\n598:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/FeeManager.sol b/contracts/FeeManager/FeeManager.sol\nindex f176113..d32aa04 100644\n--- a/contracts/FeeManager/FeeManager.sol\n+++ b/contracts/FeeManager/FeeManager.sol\n@@ -570,7 +570,7 @@ contract FeeManager is FeeManagerHelper {\n      */\n     function revokeBeneficial(\n         address _user,\n-        address[] memory _feeTokens\n+        address[] calldata _feeTokens\n     )\n         external\n         onlyMaster\n```\n\n**Instance 3:**\n\nRefactor the `PendlePowerFarmLeverageLogic.receiveFlashLoan()` function to use `calldata` in place of `memory` for the `_flashloanToken`, `_flashloanAmounts`, `_feeAmounts` and `_userData` parameters.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L60-#L63\n\nSince the `_flashloanToken`, `_flashloanAmounts`, `_feeAmounts` arrays and the `_userData` were not modified, we can reduce the gas cost of the `PendlePowerFarmLeverageLogic.receiveFlashLoan()` function by using `calldata` in place of `memory` in the definition of these parameters. In implementing this we would avoid having to copy the arrays from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: /contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol\n\n59:     function receiveFlashLoan(\n60:         IERC20[] memory _flashloanToken,    //@audit use calldata in-place of memory\n61:         uint256[] memory _flashloanAmounts,    //@audit use calldata in-place of memory\n62:         uint256[] memory _feeAmounts,    //@audit use calldata in-place of memory\n63:         bytes memory _userData    //@audit use calldata in-place of memory\n64:     )\n65:         external\n66:     {\n.\n.\n.\n129:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol b/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol\nindex 70644f2..855189c 100644\n--- a/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol\n+++ b/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol\n@@ -57,10 +57,10 @@ abstract contract PendlePowerFarmLeverageLogic is\n      * logic. Overwritten with opening flows.\n      */\n     function receiveFlashLoan(\n-        IERC20[] memory _flashloanToken,\n-        uint256[] memory _flashloanAmounts,\n-        uint256[] memory _feeAmounts,\n-        bytes memory _userData\n+        IERC20[] calldata _flashloanToken,\n+        uint256[] calldata _flashloanAmounts,\n+        uint256[] calldata _feeAmounts,\n+        bytes calldata _userData\n     )\n         external\n```\n\n**Instance 4:**\n\nRefactor the `PendlePowerFarmController.addPendleMarket()` function to use `calldata` in place of `memory` for the `_tokenName` and `_symbolName` parameters.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L213-#L214\n\nSince the strings parameters `_tokenName` and `_symbolName` were not modified, we can reduce the gas cost of the `PendlePowerFarmController.addPendleMarket()` function by using `calldata` in place of `memory` in the definition of these parameters. In implementing this we would avoid having to copy the strings from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n\n211:    function addPendleMarket(\n212:        address _pendleMarket,\n213:        string memory _tokenName,    //@audit use calldata in-place of memory\n214:        string memory _symbolName,    //@audit use calldata in-place of memory\n215:        uint16 _maxCardinality\n216:    )\n217:        external\n218:        onlyMaster\n219:    {\n.\n.\n.\n291    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.solindex 15cb863..813cab4 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol\n@@ -210,8 +210,8 @@ contract PendlePowerFarmController is PendlePowerFarmControllerHelper {\n\n     function addPendleMarket(\n         address _pendleMarket,\n-        string memory _tokenName,\n-        string memory _symbolName,\n+        string calldata _tokenName,\n+        string calldata _symbolName,\n         uint16 _maxCardinality\n     )\n```\n\n**Instance 5:**\n\nRefactor the `PositionNFTs.setBaseURI()` function to use `calldata` in place of `memory` for the `_newBaseURI` parameter.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PositionNFTs.sol#L320\n\nSince the string parameter `_newBaseURI` was not modified, we can reduce the gas cost of the `PositionNFTs.setBaseURI()` function by using `calldata` in place of `memory` in the definition of the `_newBaseURI` parameter. In implementing this we would avoid having to copy the string from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PositionNFTs.sol\n\n319:    function setBaseURI(\n320:        string memory _newBaseURI    //@audit use calldata in-place of memory\n321:    )\n322:        external\n323:        onlyMaster\n324:    {\n325:        baseURI = _newBaseURI;\n326:    }\n```\n\n```diff\ndiff --git a/contracts/PositionNFTs.sol b/contracts/PositionNFTs.sol\nindex fb680ec..b43253d 100644\n--- a/contracts/PositionNFTs.sol\n+++ b/contracts/PositionNFTs.sol\n@@ -317,7 +317,7 @@ contract PositionNFTs is ERC721Enumerable, OwnableMaster {\n      * @dev Allows to update base target for MetaData.\n      */\n     function setBaseURI(\n-        string memory _newBaseURI\n+        string calldata _newBaseURI\n     )\n         external\n         onlyMaster\n```\n\n**Instance 6:**\n\nRefactor the `PositionNFTs.setBaseExtension()` function to use `calldata` in place of `memory` for the `_newBaseExtension` parameter.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PositionNFTs.sol#L329\n\nSince the string parameter `_newBaseExtension` was not modified, we can reduce the gas cost of the `PositionNFTs.setBaseExtension()` function by using `calldata` in place of `memory` in the definition of the `_newBaseExtension` parameter. In implementing this we would avoid having to copy the string from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PositionNFTs.sol\n\n328:    function setBaseExtension(\n329:        string memory _newBaseExtension    //@audit use calldata in-place of memory\n330:    )\n331:        external\n332:        onlyMaster\n333:    {\n334:        baseExtension = _newBaseExtension;\n335:    }\n```\n\n```diff\ndiff --git a/contracts/PositionNFTs.sol b/contracts/PositionNFTs.sol\nindex fb680ec..ed078dd 100644\n--- a/contracts/PositionNFTs.sol\n+++ b/contracts/PositionNFTs.sol\n@@ -326,7 +326,7 @@ contract PositionNFTs is ERC721Enumerable, OwnableMaster {\n     }\n\n     function setBaseExtension(\n-        string memory _newBaseExtension\n+        string calldata _newBaseExtension\n     )\n         external\n         onlyMaster\n```\n\n**Instance 7:**\n\nRefactor the `PendlePowerFarmTokenFactory.deploy()` function to use `calldata` in place of `memory` for the `_tokenName` and `_symbolName` parameters.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol#L37-#L38\n\nSince the strings parameters `_tokenName` and `_symbolName` were not modified, we can reduce the gas cost of the `PendlePowerFarmTokenFactory.deploy()` function by using `calldata` in place of `memory` in the definition of these parameters. In implementing this we would avoid having to copy the strings from calldata to memory. The diff below shows how the code should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol\n\n35:    function deploy(\n36:        address _underlyingPendleMarket,\n37:        string memory _tokenName,     //@audit use calldata in-place of memory\n38:        string memory _symbolName,    //@audit use calldata in-place of memory\n39:        uint16 _maxCardinality\n40:    )\n41:        external\n42:        returns (address)\n43:    {\n44:        if (msg.sender != PENDLE_POWER_FARM_CONTROLLER) {\n45:            revert DeployForbidden();\n46:        }\n47:\n48:        return _clone(\n49:            _underlyingPendleMarket,\n50:            _tokenName,\n51:            _symbolName,\n52:            _maxCardinality\n53:        );\n54:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol\nindex 0936d72..836a38b 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmTokenFactory.sol\n@@ -34,8 +34,8 @@ contract PendlePowerFarmTokenFactory {\n\n     function deploy(\n         address _underlyingPendleMarket,\n-        string memory _tokenName,\n-        string memory _symbolName,\n+        string calldata _tokenName,\n+        string calldata _symbolName,\n         uint16 _maxCardinality\n     )\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./SimpleERC20Clone.sol\";\n\nimport \"../../InterfaceHub/IPendle.sol\";\nimport \"../../InterfaceHub/IPendleController.sol\";\n\nimport \"../../TransferHub/TransferHelper.sol\";\n\nerror MarketExpired();\nerror NotController();\nerror ZeroFee();\nerror TooMuchFee();\nerror NotEnoughLpAssetsTransferred();\nerror InsufficientShares();\nerror ZeroAmount();\nerror FeeTooHigh();\nerror NotEnoughShares();\nerror InvalidSharePriceGrowth();\nerror InvalidSharePrice();\nerror AlreadyInitialized();\n\ncontract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n\n    // Pendle - LP token address\n    address public UNDERLYING_PENDLE_MARKET;\n    address public PENDLE_POWER_FARM_CONTROLLER;\n\n    // Total balance of LPs backing at current compound distribution\n    uint256 public underlyingLpAssetsCurrent;\n\n    // Lp assets from compound left to distribute\n    uint256 public totalLpAssetsToDistribute;\n\n    // Interface Object for underlying Market\n    IPendleMarket public PENDLE_MARKET;\n\n    // InterfaceObject for pendle Sy\n    IPendleSy public PENDLE_SY;\n\n    // Interface for Pendle Controller\n    IPendleController public PENDLE_CONTROLLER;\n\n    // Max cardinality of Pendle Market\n    uint16 public MAX_CARDINALITY;\n\n    uint256 public mintFee;\n    uint256 public lastInteraction;\n\n    uint256 private constant ONE_WEEK = 7 days;\n    uint256 internal constant ONE_YEAR = 365 days;\n    uint256 private constant MAX_MINT_FEE = 10000;\n\n    uint256 private constant PRECISION_FACTOR_E6 = 1E6;\n    uint256 private constant PRECISION_FACTOR_E18 = 1E18;\n    uint256 internal constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\n    uint256 internal constant PRECISION_FACTOR_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\n\n    uint256 private INITIAL_TIME_STAMP;\n\n    uint256 internal constant RESTRICTION_FACTOR = 10\n        * PRECISION_FACTOR_E36\n        / PRECISION_FACTOR_YEAR;\n\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    function _onlyController()\n        private\n        view\n    {\n        if (msg.sender != PENDLE_POWER_FARM_CONTROLLER) {\n            revert NotController();\n        }\n    }\n\n    modifier syncSupply()\n    {\n        _triggerIndexUpdate();\n        _overWriteCheck();\n        _syncSupply();\n        _updateRewards();\n        _setLastInteraction();\n        _increaseCardinalityNext();\n        uint256 sharePriceBefore = _getSharePrice();\n        _;\n        _validateSharePriceGrowth(\n            _validateSharePrice(\n                sharePriceBefore\n            )\n        );\n    }\n\n    function _validateSharePrice(\n        uint256 _sharePriceBefore\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 sharePricenNow = _getSharePrice();\n\n        if (sharePricenNow < _sharePriceBefore) {\n            revert InvalidSharePrice();\n        }\n\n        return sharePricenNow;\n    }\n\n    function _validateSharePriceGrowth(\n        uint256 _sharePriceNow\n    )\n        private\n        view\n    {\n        uint256 timeDifference = block.timestamp\n            - INITIAL_TIME_STAMP;\n\n        uint256 maximum = timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n\n        if (_sharePriceNow > maximum) {\n            revert InvalidSharePriceGrowth();\n        }\n    }\n\n    function _overWriteCheck()\n        internal\n    {\n        _wrapOverWrites(\n            _updateRewardTokens()\n        );\n    }\n\n    function _triggerIndexUpdate()\n        internal\n    {\n        _withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            0\n        );\n    }\n\n    function _wrapOverWrites(\n        bool _overWritten\n    )\n        internal\n    {\n        if (_overWritten == true) {\n            _overWriteIndexAll();\n            _overWriteAmounts();\n        }\n    }\n\n    function _updateRewardTokens()\n        private\n        returns (bool)\n    {\n        return PENDLE_CONTROLLER.updateRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndexAll()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndexAll(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _overWriteIndex(\n        uint256 _index\n    )\n        private\n    {\n        PENDLE_CONTROLLER.overWriteIndex(\n            UNDERLYING_PENDLE_MARKET,\n            _index\n        );\n    }\n\n    function _overWriteAmounts()\n        private\n    {\n        PENDLE_CONTROLLER.overWriteAmounts(\n            UNDERLYING_PENDLE_MARKET\n        );\n    }\n\n    function _updateRewards()\n        private\n    {\n        uint256[] memory rewardsOutsideArray = _calculateRewardsClaimedOutside();\n\n        uint256 i;\n        uint256 l = rewardsOutsideArray.length;\n\n        while (i < l) {\n            if (rewardsOutsideArray[i] > 0) {\n                PENDLE_CONTROLLER.increaseReservedForCompound(\n                    UNDERLYING_PENDLE_MARKET,\n                    rewardsOutsideArray\n                );\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _calculateRewardsClaimedOutside()\n        internal\n        returns (uint256[] memory)\n    {\n        address[] memory rewardTokens = PENDLE_CONTROLLER.pendleChildCompoundInfoRewardTokens(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint128[] memory lastIndex = PENDLE_CONTROLLER.pendleChildCompoundInfoLastIndex(\n            UNDERLYING_PENDLE_MARKET\n        );\n\n        uint256 l = rewardTokens.length;\n        uint256[] memory rewardsOutsideArray = new uint256[](l);\n\n        uint256 i;\n        uint128 index;\n\n        while (i < l) {\n            UserReward memory userReward = _getUserReward(\n                rewardTokens[i],\n                PENDLE_POWER_FARM_CONTROLLER\n            );\n\n            if (userReward.accrued > 0) {\n                PENDLE_MARKET.redeemRewards(\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n\n                userReward = _getUserReward(\n                    rewardTokens[i],\n                    PENDLE_POWER_FARM_CONTROLLER\n                );\n            }\n\n            index = userReward.index;\n\n            if (lastIndex[i] == 0 && index > 0) {\n                rewardsOutsideArray[i] = 0;\n                _overWriteIndex(\n                    i\n                );\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            if (index == lastIndex[i]) {\n                rewardsOutsideArray[i] = 0;\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            uint256 indexDiff = index\n                - lastIndex[i];\n\n            uint256 activeBalance = _getActiveBalance();\n            uint256 totalLpAssetsCurrent = totalLpAssets();\n            uint256 lpBalanceController = _getBalanceLpBalanceController();\n\n            bool scaleNecessary = totalLpAssetsCurrent < lpBalanceController;\n\n            rewardsOutsideArray[i] = scaleNecessary\n                ? indexDiff\n                    * activeBalance\n                    * totalLpAssetsCurrent\n                    / lpBalanceController\n                    / PRECISION_FACTOR_E18\n                : indexDiff\n                    * activeBalance\n                    / PRECISION_FACTOR_E18;\n\n            _overWriteIndex(\n                i\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewardsOutsideArray;\n    }\n\n    function _getBalanceLpBalanceController()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.balanceOf(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getActiveBalance()\n        private\n        view\n        returns (uint256)\n    {\n        return PENDLE_MARKET.activeBalance(\n            PENDLE_POWER_FARM_CONTROLLER\n        );\n    }\n\n    function _getSharePrice()\n        private\n        view\n        returns (uint256)\n    {\n        return previewUnderlyingLpAssets() * PRECISION_FACTOR_E18\n            / totalSupply();\n    }\n\n    function _syncSupply()\n        private\n    {\n        uint256 additonalAssets = previewDistribution();\n\n        if (additonalAssets == 0) {\n            return;\n        }\n\n        underlyingLpAssetsCurrent += additonalAssets;\n        totalLpAssetsToDistribute -= additonalAssets;\n    }\n\n    function _increaseCardinalityNext()\n        internal\n    {\n        MarketStorage memory storageMarket = PENDLE_MARKET._storage();\n\n        if (storageMarket.observationCardinalityNext < MAX_CARDINALITY) {\n            PENDLE_MARKET.increaseObservationsCardinalityNext(\n                storageMarket.observationCardinalityNext + 1\n            );\n        }\n    }\n\n    function _withdrawLp(\n        address _to,\n        uint256 _amount\n    )\n        internal\n    {\n        PENDLE_CONTROLLER.withdrawLp(\n            UNDERLYING_PENDLE_MARKET,\n            _to,\n            _amount\n        );\n    }\n\n    function _getUserReward(\n        address _rewardToken,\n        address _user\n    )\n        internal\n        view\n        returns (UserReward memory)\n    {\n        return PENDLE_MARKET.userReward(\n            _rewardToken,\n            _user\n        );\n    }\n\n    function previewDistribution()\n        public\n        view\n        returns (uint256)\n    {\n        if (totalLpAssetsToDistribute == 0) {\n            return 0;\n        }\n\n        if (block.timestamp == lastInteraction) {\n            return 0;\n        }\n\n        if (totalLpAssetsToDistribute < ONE_WEEK) {\n            return totalLpAssetsToDistribute;\n        }\n\n        uint256 currentRate = totalLpAssetsToDistribute\n            / ONE_WEEK;\n\n        uint256 additonalAssets = currentRate\n            * (block.timestamp - lastInteraction);\n\n        if (additonalAssets > totalLpAssetsToDistribute) {\n            return totalLpAssetsToDistribute;\n        }\n\n        return additonalAssets;\n    }\n\n    function _setLastInteraction()\n        private\n    {\n        lastInteraction = block.timestamp;\n    }\n\n    function _applyMintFee(\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _amount\n            * (PRECISION_FACTOR_E6 - mintFee)\n            / PRECISION_FACTOR_E6;\n    }\n\n    function totalLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return underlyingLpAssetsCurrent\n            + totalLpAssetsToDistribute;\n    }\n\n    function previewUnderlyingLpAssets()\n        public\n        view\n        returns (uint256)\n    {\n        return previewDistribution()\n            + underlyingLpAssetsCurrent;\n    }\n\n    function previewMintShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _underlyingAssetAmount\n            * totalSupply()\n            / _underlyingLpAssetsCurrent;\n    }\n\n    function previewAmountWithdrawShares(\n        uint256 _shares,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _shares\n            * _underlyingLpAssetsCurrent\n            / totalSupply();\n    }\n\n    function previewBurnShares(\n        uint256 _underlyingAssetAmount,\n        uint256 _underlyingLpAssetsCurrent\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 product = _underlyingAssetAmount\n            * totalSupply();\n\n        return product % _underlyingLpAssetsCurrent == 0\n            ? product / _underlyingLpAssetsCurrent\n            : product / _underlyingLpAssetsCurrent + 1;\n    }\n\n    function manualSync()\n        external\n        syncSupply\n        returns (bool)\n    {\n        return true;\n    }\n\n    function addCompoundRewards(\n        uint256 _amount\n    )\n        external\n        syncSupply\n    {\n        if (_amount == 0) {\n            revert ZeroAmount();\n        }\n\n        totalLpAssetsToDistribute += _amount;\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return;\n        }\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _amount\n        );\n    }\n\n    /**\n     * @dev External wrapper for mint function.\n     */\n    function depositExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewMintShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares == 0) {\n            revert NotEnoughLpAssetsTransferred();\n        }\n\n        uint256 reducedShares = _applyMintFee(\n            shares\n        );\n\n        uint256 feeShares = shares\n            - reducedShares;\n\n        if (feeShares == 0) {\n            revert ZeroFee();\n        }\n\n        if (reducedShares == feeShares) {\n            revert TooMuchFee();\n        }\n\n        _mint(\n            msg.sender,\n            reducedShares\n        );\n\n        _mint(\n            PENDLE_POWER_FARM_CONTROLLER,\n            feeShares\n        );\n\n        underlyingLpAssetsCurrent += _underlyingLpAssetAmount;\n\n        _safeTransferFrom(\n            UNDERLYING_PENDLE_MARKET,\n            msg.sender,\n            PENDLE_POWER_FARM_CONTROLLER,\n            _underlyingLpAssetAmount\n        );\n\n        return (\n            reducedShares,\n            feeShares\n        );\n    }\n\n    function changeMintFee(\n        uint256 _newFee\n    )\n        external\n        onlyController\n    {\n        if (_newFee > MAX_MINT_FEE) {\n            revert FeeTooHigh();\n        }\n\n        mintFee = _newFee;\n    }\n\n    /**\n     * @dev External wrapper for burn function.\n     */\n    function withdrawExactShares(\n        uint256 _shares\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_shares == 0) {\n            revert ZeroAmount();\n        }\n\n        if (_shares > balanceOf(msg.sender)) {\n            revert InsufficientShares();\n        }\n\n        uint256 tokenAmount = previewAmountWithdrawShares(\n            _shares,\n            underlyingLpAssetsCurrent\n        );\n\n        underlyingLpAssetsCurrent -= tokenAmount;\n\n        _burn(\n            msg.sender,\n            _shares\n        );\n\n        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n            return tokenAmount;\n        }\n\n        _withdrawLp(\n            msg.sender,\n            tokenAmount\n        );\n\n        return tokenAmount;\n    }\n\n    function withdrawExactAmount(\n        uint256 _underlyingLpAssetAmount\n    )\n        external\n        syncSupply\n        returns (uint256)\n    {\n        if (_underlyingLpAssetAmount == 0) {\n            revert ZeroAmount();\n        }\n\n        uint256 shares = previewBurnShares(\n            _underlyingLpAssetAmount,\n            underlyingLpAssetsCurrent\n        );\n\n        if (shares > balanceOf(msg.sender)) {\n            revert NotEnoughShares();\n        }\n\n        _burn(\n            msg.sender,\n            shares\n        );\n\n        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount;\n\n        _withdrawLp(\n            msg.sender,\n            _underlyingLpAssetAmount\n        );\n\n        return shares;\n    }\n\n    function initialize(\n        address _underlyingPendleMarket,\n        address _pendleController,\n        string memory _tokenName,\n        string memory _symbolName,\n        uint16 _maxCardinality\n    )\n        external\n    {\n        if (address(PENDLE_MARKET) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        PENDLE_MARKET = IPendleMarket(\n            _underlyingPendleMarket\n        );\n\n        if (PENDLE_MARKET.isExpired() == true) {\n            revert MarketExpired();\n        }\n\n        PENDLE_CONTROLLER = IPendleController(\n            _pendleController\n        );\n\n        MAX_CARDINALITY = _maxCardinality;\n\n        _name = _tokenName;\n        _symbol = _symbolName;\n\n        PENDLE_POWER_FARM_CONTROLLER = _pendleController;\n        UNDERLYING_PENDLE_MARKET = _underlyingPendleMarket;\n\n        (\n            address pendleSyAddress,\n            ,\n        ) = PENDLE_MARKET.readTokens();\n\n        PENDLE_SY = IPendleSy(\n            pendleSyAddress\n        );\n\n        _decimals = PENDLE_SY.decimals();\n\n        lastInteraction = block.timestamp;\n\n        _totalSupply = 1;\n        underlyingLpAssetsCurrent = 1;\n        mintFee = 3000;\n        INITIAL_TIME_STAMP = block.timestamp;\n    }\n}"
    },
    {
      "filename": "contracts/FeeManager/FeeManager.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author Christoph Krpoun\n * @author Ren√© Hochmuth\n * @author Vitally Marinchenko\n */\n\nimport \"./FeeManagerHelper.sol\";\n\n/**\n * @dev Purpose of this contract is to organize fee distribution from wiseLending.\n * The feeManager aquires fee token in form of shares from each pool and can call them\n * with \"claimWiseFees()\" for each pool.\n *\n * Furthermore, this contracts has two different incentive\n * structures which can be used to bootstrap the WISE ecosystem (beneficial and incnetiveOwner roles).\n *\n * Additionally, this contract keeps track of the bad debt of each postion and has a simple mechanism\n * to pay them back via incentives. The incentive amount is funded by the gathered fees.\n */\n\ncontract FeeManager is FeeManagerHelper {\n\n    constructor(\n        address _master,\n        address _aaveAddress,\n        address _wiseLendingAddress,\n        address _oracleHubAddress,\n        address _wiseSecurityAddress,\n        address _positionNFTAddress\n    )\n        DeclarationsFeeManager(\n            _master,\n            _aaveAddress,\n            _wiseLendingAddress,\n            _oracleHubAddress,\n            _wiseSecurityAddress,\n            _positionNFTAddress\n        )\n    {}\n\n    /**\n     * @dev Allows to adjust the paid out incentive\n     * percentage for user to reduce bad debt.\n     */\n    function setRepayBadDebtIncentive(\n        uint256 _percent\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _percent\n        );\n\n        paybackIncentive = _percent;\n    }\n\n    /**\n     * @dev Maps underlying token with corresponding aToken.\n     * Sets bool to identify pool token as aToken.\n     */\n    function setAaveFlag(\n        address _poolToken,\n        address _underlyingToken\n    )\n        external\n        onlyMaster\n    {\n        _setAaveFlag(\n            _poolToken,\n            _underlyingToken\n        );\n    }\n\n    /**\n     * @dev Bulk function for setting aave flag for multiple pools.\n     */\n    function setAaveFlagBulk(\n        address[] calldata _poolTokens,\n        address[] calldata _underlyingTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n            _setAaveFlag(\n                _poolTokens[i],\n                _underlyingTokens[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to adjust pool fee. Fee can not be greater than 100%\n     * or lower than 1%. Can be adjusted for each pool individually.\n     */\n    function setPoolFee(\n        address _poolToken,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _newFee\n        );\n\n        WISE_LENDING.setPoolFee(\n            _poolToken,\n            _newFee\n        );\n\n        emit PoolFeeChanged(\n            _poolToken,\n            _newFee,\n            block.timestamp\n        );\n    }\n\n    /**\n    * @dev Function to adjust pool fees in bulk. Fee for each pool can not be\n    * greater than 100% or lower than 1%. Can be adjusted for each pool individually.\n    */\n    function setPoolFeeBulk(\n        address[] calldata _poolTokens,\n        uint256[] calldata _newFees\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n\n            _checkValue(\n                _newFees[i]\n            );\n\n            WISE_LENDING.setPoolFee(\n                _poolTokens[i],\n                _newFees[i]\n            );\n\n            emit PoolFeeChanged(\n                _poolTokens[i],\n                _newFees[i],\n                block.timestamp\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to propose new incentive master. This role can increase\n     * the incentive amount for both incentive mappings. These are two roles\n     * for incentivising external persons e.g. developers.\n     */\n    function proposeIncentiveMaster(\n        address _proposedIncentiveMaster\n    )\n        external\n        onlyIncentiveMaster\n    {\n        if (_proposedIncentiveMaster == ZERO_ADDRESS) {\n            revert ZeroAddress();\n        }\n\n        proposedIncentiveMaster = _proposedIncentiveMaster;\n\n        emit IncentiveMasterProposed(\n            _proposedIncentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim proposed incentive master by proposed entity.\n     */\n    function claimOwnershipIncentiveMaster()\n        external\n    {\n        if (msg.sender != proposedIncentiveMaster) {\n            revert NotAllowed();\n        }\n\n        incentiveMaster = proposedIncentiveMaster;\n        proposedIncentiveMaster = ZERO_ADDRESS;\n\n        emit ClaimedOwnershipIncentiveMaster(\n            incentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity A.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveA(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerA] += _value;\n\n        emit IncentiveIncreasedA(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity B.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveB(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerB] += _value;\n\n        emit IncentiveIncreasedB(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to claim all gathered incetives.\n     */\n    function claimIncentivesBulk()\n        external\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n\n            tokenAddress = poolTokenAddresses[i];\n\n            if (isAaveToken[tokenAddress] == true) {\n                tokenAddress = underlyingToken[\n                    tokenAddress\n                ];\n            }\n\n            claimIncentives(\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedIncentivesBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claims gathered incentives for a specific token.\n     */\n    function claimIncentives(\n        address _feeToken\n    )\n        public\n    {\n        uint256 amount = gatheredIncentiveToken[msg.sender][_feeToken];\n\n        if (amount == 0) {\n            revert NoIncentive();\n        }\n\n        delete gatheredIncentiveToken[msg.sender][_feeToken];\n\n        emit ClaimedIncentives(\n            msg.sender,\n            _feeToken,\n            amount,\n            block.timestamp\n        );\n\n        _safeTransfer(\n            _feeToken,\n            msg.sender,\n            amount\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerA! Only callable by\n     * incentiveOwnerA.\n     */\n    function changeIncentiveUSDA(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        incentiveOwnerA = _newOwner;\n\n        emit IncentiveOwnerAChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerB! Only callable by\n     * incentiveOwnerB.\n     */\n    function changeIncentiveUSDB(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        incentiveOwnerB = _newOwner;\n\n        emit IncentiveOwnerBChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function adding new pool token to pool token list.\n     * Called during pool creation and only callable by wiseLending\n     * contract.\n     */\n    function addPoolTokenAddress(\n        address _poolToken\n    )\n        external\n        onlyWiseLending\n    {\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to add pool token manualy. Only\n     * callable by feeManager master.\n     */\n    function addPoolTokenAddressManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        if (poolTokenAdded[_poolToken] == true) {\n            revert PoolAlreadyAdded();\n        }\n\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to remove pool token manualy from pool\n     * token list. Only callable by feeManager master.\n     */\n    function removePoolTokenManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 len = getPoolTokenAddressesLength();\n        uint256 lastEntry = len - 1;\n        bool found;\n\n        if (poolTokenAdded[_poolToken] == false) {\n            revert PoolNotPresent();\n        }\n\n        while (i < len) {\n\n            if (_poolToken != poolTokenAddresses[i]) {\n\n                unchecked {\n                    ++i;\n                }\n\n                continue;\n            }\n\n            found = true;\n\n            if (i != lastEntry) {\n                poolTokenAddresses[i] = poolTokenAddresses[lastEntry];\n            }\n\n            break;\n        }\n\n        if (found == true) {\n\n            poolTokenAddresses.pop();\n            poolTokenAdded[_poolToken] = false;\n\n            emit PoolTokenRemoved(\n                _poolToken,\n                block.timestamp\n            );\n\n            return;\n        }\n\n        revert PoolNotPresent();\n    }\n\n    /**\n     * @dev Increase function for total bad debt of\n     * wiseLending. Only callable by wiseSecurity contract\n     * during liquidation.\n     */\n    function increaseTotalBadDebtLiquidation(\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _increaseTotalBadDebt(\n            _amount\n        );\n\n        emit BadDebtIncreasedLiquidation(\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for bad debt of a position.\n     * Only callable by wiseSecurity contract during liquidation.\n     */\n    function setBadDebtUserLiquidation(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _setBadDebtPosition(\n            _nftId,\n            _amount\n        );\n\n        emit SetBadDebtPosition(\n            _nftId,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to declare an address as beneficial for\n     * a fee token. Address can claim gathered fee token as long as\n     * it is declared as beneficial. Only setable by master.\n     */\n    function setBeneficial(\n        address _user,\n        address[] calldata _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _feeTokens.length;\n\n        while (i < l) {\n            _setAllowedTokens(\n                _user,\n                _feeTokens[i],\n                true\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit SetBeneficial(\n            _user,\n            _feeTokens,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to remove an address as beneficial for\n     * a fee token. Only setable by master.\n     */\n    function revokeBeneficial(\n        address _user,\n        address[] memory _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _feeTokens.length;\n\n        while (i < l) {\n            _setAllowedTokens(\n                _user,\n                _feeTokens[i],\n                false\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit RevokeBeneficial(\n            _user,\n            _feeTokens,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim all fees from wiseLending and send them to feeManager.\n     */\n    function claimWiseFeesBulk()\n        external\n    {\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n            claimWiseFees(\n                poolTokenAddresses[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedFeesWiseBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim fees from wiseLending and send them to feeManager for\n     * a specific pool.\n     */\n    function claimWiseFees(\n        address _poolToken\n    )\n        public\n    {\n        address underlyingTokenAddress = _poolToken;\n\n        uint256 shares = WISE_LENDING.getPositionLendingShares(\n            FEE_MANAGER_NFT,\n            _poolToken\n        );\n\n        if (shares == 0) {\n            return;\n        }\n\n        uint256 tokenAmount = WISE_LENDING.withdrawExactShares(\n            FEE_MANAGER_NFT,\n            _poolToken,\n            shares\n        );\n\n        if (isAaveToken[_poolToken] == true) {\n\n            underlyingTokenAddress = underlyingToken[\n                _poolToken\n            ];\n\n            tokenAmount = AAVE.withdraw(\n                underlyingTokenAddress,\n                tokenAmount,\n                address(this)\n            );\n        }\n\n        if (totalBadDebtETH == 0) {\n\n            tokenAmount = _distributeIncentives(\n                tokenAmount,\n                _poolToken,\n                underlyingTokenAddress\n            );\n        }\n\n        _increaseFeeTokens(\n            underlyingTokenAddress,\n            tokenAmount\n        );\n\n        emit ClaimedFeesWise(\n            underlyingTokenAddress,\n            tokenAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for beneficial to claim gathered fees. Can only\n     * claim fees for which the beneficial is allowed. Can only claim\n     * token which are inside the feeManager.\n     */\n    function claimFeesBeneficial(\n        address _feeToken,\n        uint256 _amount\n    )\n        external\n    {\n        address caller = msg.sender;\n\n        if (totalBadDebtETH > 0) {\n            revert ExistingBadDebt();\n        }\n\n        if (allowedTokens[caller][_feeToken] == false) {\n            revert NotAllowed();\n        }\n\n        _decreaseFeeTokens(\n            _feeToken,\n            _amount\n        );\n\n        _safeTransfer(\n            _feeToken,\n            caller,\n            _amount\n        );\n\n        emit ClaimedFeesBeneficial(\n            caller,\n            _feeToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for paying back bad debt of a position. Caller\n     * chooses postion, token and receive token. Only gathered fee token\n     * can be distributed as receive token. Caller gets 5% more\n     * in ETH value as incentive.\n     */\n    function paybackBadDebtForTo"
    }
  ]
}