{
  "Title": "[M-14] `BoostAggregator` owner can set fees to 100% and steal all of the user's rewards",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L119> <br><https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L153>\n\n### Impact\n\nUsers who use `BoostAggregator` will suffer a 100% loss of their rewards.\n\n### Proof of Concept\n\nAfter users have staked their tokens, the owner of the `BoostAggregator` can set `protocolFee` to `10_000` (100%) and steal the user's rewards. Anyone can create their own `BoostAggregator` and it is supposed to be publicly used; therefore, the owner of it cannot be considered trusted. Allowing the owner to steal the user's rewards is an unnecessary vulnerability.\n\n```solidity\n    function setProtocolFee(uint256 _protocolFee) external onlyOwner { \n        if (_protocolFee > DIVISIONER) revert FeeTooHigh();\n        protocolFee = _protocolFee; // @audit - owner can set it to 100% and steal all rewards\n    }\n```\n\n### Recommended Mitigation Steps\n\nCreate a mapping which tracks the `protocolFee` at which the user has deposited their NFT. Upon withdrawing, get the `protocolFee` from the said mapping.\n\n**[Trust (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/634#issuecomment-1649475291):**\n > A fair level of trust is assumed on receiving `boostAggregator`, but the loss of yield is serious. Therefore, medium is appropriate.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/634#issuecomment-1653252394):**\n > A different severity from [#731](https://github.com/code-423n4/2023-05-maia-findings/issues/731), as this requires a malicious aggregator owner, while #731 can happen during normal interaction.\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/634#issuecomment-1708826139):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/634).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/talos/boost-aggregator/BoostAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {UniswapV3Staker} from \"@v3-staker/UniswapV3Staker.sol\";\n\nimport {IBoostAggregator} from \"../interfaces/IBoostAggregator.sol\";\n\n/// @title Boost Aggregator for Uniswap V3 NFTs\ncontract BoostAggregator is Ownable, IBoostAggregator {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                        BOOST AGGREGATOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @inheritdoc IBoostAggregator\n    UniswapV3Staker public immutable uniswapV3Staker;\n\n    /// @inheritdoc IBoostAggregator\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @inheritdoc IBoostAggregator\n    ERC20 public immutable hermes;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => address) public userToRewardsDepot;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => address) public tokenIdToUser;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => uint256) public tokenIdRewards;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => bool) public whitelistedAddresses;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolRewards;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolFee = 2000; // 20%\n    // divisioner for protocol fee\n    uint256 private constant DIVISIONER = 10000;\n\n    /**\n     * @notice Creates a new BoostAggregator\n     * @param _uniswapV3Staker The UniswapV3Staker contract\n     * @param _hermes The hermes token contract\n     * @param _owner The owner of this contract\n     */\n    constructor(UniswapV3Staker _uniswapV3Staker, ERC20 _hermes, address _owner) {\n        _initializeOwner(_owner);\n        uniswapV3Staker = _uniswapV3Staker;\n        hermesGaugeBoost = uniswapV3Staker.hermesGaugeBoost();\n        nonfungiblePositionManager = uniswapV3Staker.nonfungiblePositionManager();\n        hermes = _hermes;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    /// @dev msg.sender not validated to be nonfungiblePositionManager in order to allow\n    ///      whitelisted addresses to retrieve NFTs incorrectly sent to this contract\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        onlyWhitelisted(from)\n        returns (bytes4)\n    {\n        // update tokenIdRewards prior to staking\n        tokenIdRewards[tokenId] = uniswapV3Staker.tokenIdRewards(tokenId);\n        // map tokenId to user\n        tokenIdToUser[tokenId] = from;\n        // stake NFT to Uniswap V3 Staker\n        nonfungiblePositionManager.safeTransferFrom(address(this), address(uniswapV3Staker), tokenId);\n\n        return this.onERC721Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARD DEPOTS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function setOwnRewardsDepot(address rewardsDepot) external {\n        userToRewardsDepot[msg.sender] = rewardsDepot;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UNSTAKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function unstakeAndWithdraw(uint256 tokenId) external {\n        address user = tokenIdToUser[tokenId];\n        if (user != msg.sender) revert NotTokenIdOwner();\n\n        // unstake NFT from Uniswap V3 Staker\n        uniswapV3Staker.unstakeToken(tokenId);\n\n        uint256 pendingRewards = uniswapV3Staker.tokenIdRewards(tokenId) - tokenIdRewards[tokenId];\n\n        if (pendingRewards > DIVISIONER) {\n            uint256 newProtocolRewards = (pendingRewards * protocolFee) / DIVISIONER;\n            /// @dev protocol rewards stay in stake contract\n            protocolRewards += newProtocolRewards;\n            pendingRewards -= newProtocolRewards;\n\n            address rewardsDepot = userToRewardsDepot[user];\n            if (rewardsDepot != address(0)) {\n                // claim rewards to user's rewardsDepot\n                uniswapV3Staker.claimReward(rewardsDepot, pendingRewards);\n            } else {\n                // claim rewards to user\n                uniswapV3Staker.claimReward(user, pendingRewards);\n            }\n        }\n\n        // withdraw rewards from Uniswap V3 Staker\n        uniswapV3Staker.withdrawToken(tokenId, user, \"\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function addWhitelistedAddress(address user) external onlyOwner {\n        whitelistedAddresses[user] = true;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function removeWhitelistedAddress(address user) external onlyOwner {\n        delete whitelistedAddresses[user];\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function setProtocolFee(uint256 _protocolFee) external onlyOwner {\n        if (_protocolFee > DIVISIONER) revert FeeTooHigh();\n        protocolFee = _protocolFee;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawProtocolFees(address to) external onlyOwner {\n        uniswapV3Staker.claimReward(to, protocolRewards);\n        delete protocolRewards;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawAllGaugeBoost(address to) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesAllBoost();\n        address(hermesGaugeBoost).safeTransfer(to, hermesGaugeBoost.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawGaugeBoost(address to, uint256 amount) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesBoost(amount);\n        hermesGaugeBoost.updateUserBoost(address(this));\n        address(hermesGaugeBoost).safeTransfer(to, amount);\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) external onlyOwner {\n        hermesGaugeBoost.decrementGaugesBoostIndexed(boost, offset, num);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Only whitelisted addresses\n    /// @param from The address who the NFT is being transferred from\n    modifier onlyWhitelisted(address from) {\n        if (!whitelistedAddresses[from]) revert Unauthorized();\n        _;\n    }\n}"
    }
  ]
}