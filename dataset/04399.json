{
  "Title": "[L07][Fixed] Repo owner could lose collateral if leftover oTokens are not burnt before the option expires",
  "Content": "Currently, `Repo` owners are allowed to freely mint oTokens by providing collateral. However, there is no way for the `Repo` owner to redeem the corresponding collateral for any unsold oTokens after the option expires. The `Repo` owners are supposed to burn all unsold oTokens before `expiry` to avoid losing the corresponding collateral.\n\n\nWhile this design works and makes sense, it is quite risky for the `Repo` owners and it is unclear that `Repo` owners are bearing risks of being stuck with their own oTokens.\n\n\nConsider adding more documentation and warnings in the code to further advice `Repo` owners, or only allow issuing oTokens when a trade occurs.\n\n\n**Update**: *The team confirmed this is an expected behavior, comments are added in [line 442 of the follow up commit](https://github.com/opynfinance/Convexity-Protocol/blob/3adfd9afa6d463869d9e0a78cc7f316ae34eb89e/contracts/OptionsContract.sol#L442) to ensure users are only issuing oTokens when a trade occurs.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OptionsContract.sol",
      "content": "pragma solidity 0.5.10;\n\nimport \"./lib/CompoundOracleInterface.sol\";\nimport \"./OptionsExchange.sol\";\nimport \"./OptionsUtils.sol\";\nimport \"./lib/UniswapFactoryInterface.sol\";\nimport \"./lib/UniswapExchangeInterface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title Opyn's Options Contract\n * @author Opyn\n */\ncontract OptionsContract is Ownable, ERC20 {\n    using SafeMath for uint256;\n\n    /* represents floting point numbers, where number = value * 10 ** exponent\n    i.e 0.1 = 10 * 10 ** -3 */\n    struct Number {\n        uint256 value;\n        int32 exponent;\n    }\n\n    // Keeps track of the weighted collateral and weighted debt for each vault.\n    struct Vault {\n        uint256 collateral;\n        uint256 oTokensIssued;\n        uint256 underlying;\n        bool owned;\n    }\n\n    OptionsExchange public optionsExchange;\n\n    mapping(address => Vault) internal vaults;\n\n    address payable[] internal vaultOwners;\n\n    // 10 is 0.01 i.e. 1% incentive.\n    Number public liquidationIncentive = Number(10, -3);\n\n    // 100 is egs. 0.1 i.e. 10%.\n    Number public transactionFee = Number(0, -3);\n\n    /* 500 is 0.5. Max amount that a Vault can be liquidated by i.e.\n    max collateral that can be taken in one function call */\n    Number public liquidationFactor = Number(500, -3);\n\n    /* 16 means 1.6. The minimum ratio of a Vault's collateral to insurance promised.\n    The ratio is calculated as below:\n    vault.collateral / (Vault.oTokensIssued * strikePrice) */\n    Number public minCollateralizationRatio = Number(16, -1);\n\n    // The amount of insurance promised per oToken\n    Number public strikePrice;\n\n    // The amount of underlying that 1 oToken protects.\n    Number public oTokenExchangeRate;\n\n    /* UNIX time.\n    Exercise period starts at `(expiry - windowSize)` and ends at `expiry` */\n    uint256 internal windowSize;\n\n    /* The total fees accumulated in the contract any time liquidate or exercise is called */\n    uint256 internal totalFee;\n\n    // The time of expiry of the options contract\n    uint256 public expiry;\n\n    // The precision of the collateral\n    int32 public collateralExp = -18;\n\n    // The precision of the underlying\n    int32 public underlyingExp = -18;\n\n    // The collateral asset\n    IERC20 public collateral;\n\n    // The asset being protected by the insurance\n    IERC20 public underlying;\n\n    // The asset in which insurance is denominated in.\n    IERC20 public strike;\n\n    // The Oracle used for the contract\n    CompoundOracleInterface public COMPOUND_ORACLE;\n\n    /**\n    * @param _collateral The collateral asset\n    * @param _collExp The precision of the collateral (-18 if ETH)\n    * @param _underlying The asset that is being protected\n    * @param _underlyingExp The precision of the underlying asset\n    * @param _oTokenExchangeExp The precision of the `amount of underlying` that 1 oToken protects\n    * @param _strikePrice The amount of strike asset that will be paid out per oToken\n    * @param _strikeExp The precision of the strike price.\n    * @param _strike The asset in which the insurance is calculated\n    * @param _expiry The time at which the insurance expires\n    * @param _optionsExchange The contract which interfaces with the exchange + oracle\n    * @param _oracleAddress The address of the oracle\n    * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\n    */\n    constructor(\n        IERC20 _collateral,\n        int32 _collExp,\n        IERC20 _underlying,\n        int32 _underlyingExp,\n        int32 _oTokenExchangeExp,\n        uint256 _strikePrice,\n        int32 _strikeExp,\n        IERC20 _strike,\n        uint256 _expiry,\n        OptionsExchange _optionsExchange,\n        address _oracleAddress,\n        uint256 _windowSize\n    ) public {\n        require(block.timestamp < _expiry, \"Can't deploy an expired contract\");\n        require(\n            _windowSize <= _expiry,\n            \"Exercise window can't be longer than the contract's lifespan\"\n        );\n        require(\n            isWithinExponentRange(_collExp),\n            \"collateral exponent not within expected range\"\n        );\n        require(\n            isWithinExponentRange(_underlyingExp),\n            \"underlying exponent not within expected range\"\n        );\n        require(\n            isWithinExponentRange(_strikeExp),\n            \"strike price exponent not within expected range\"\n        );\n        require(\n            isWithinExponentRange(_oTokenExchangeExp),\n            \"oToken exchange rate exponent not within expected range\"\n        );\n\n        collateral = _collateral;\n        collateralExp = _collExp;\n\n        underlying = _underlying;\n        underlyingExp = _underlyingExp;\n        oTokenExchangeRate = Number(1, _oTokenExchangeExp);\n\n        strikePrice = Number(_strikePrice, _strikeExp);\n        strike = _strike;\n\n        expiry = _expiry;\n        COMPOUND_ORACLE = CompoundOracleInterface(_oracleAddress);\n        optionsExchange = _optionsExchange;\n        windowSize = _windowSize;\n    }\n\n    /*** Events ***/\n    event VaultOpened(address payable vaultOwner);\n    event ETHCollateralAdded(\n        address payable vaultOwner,\n        uint256 amount,\n        address payer\n    );\n    event ERC20CollateralAdded(\n        address payable vaultOwner,\n        uint256 amount,\n        address payer\n    );\n    event IssuedOTokens(\n        address issuedTo,\n        uint256 oTokensIssued,\n        address payable vaultOwner\n    );\n    event Liquidate(\n        uint256 amtCollateralToPay,\n        address payable vaultOwner,\n        address payable liquidator\n    );\n    event Exercise(\n        uint256 amtUnderlyingToPay,\n        uint256 amtCollateralToPay,\n        address payable exerciser,\n        address payable vaultExercisedFrom\n    );\n    event RedeemVaultBalance(\n        uint256 amtCollateralRedeemed,\n        uint256 amtUnderlyingRedeemed,\n        address payable vaultOwner\n    );\n    event BurnOTokens(address payable vaultOwner, uint256 oTokensBurned);\n    event RemoveCollateral(uint256 amtRemoved, address payable vaultOwner);\n    event UpdateParameters(\n        uint256 liquidationIncentive,\n        uint256 liquidationFactor,\n        uint256 transactionFee,\n        uint256 minCollateralizationRatio,\n        address owner\n    );\n    event TransferFee(address payable to, uint256 fees);\n    event RemoveUnderlying(\n        uint256 amountUnderlying,\n        address payable vaultOwner\n    );\n\n    /**\n     * @dev Throws if called Options contract is expired.\n     */\n    modifier notExpired() {\n        require(!hasExpired(), \"Options contract expired\");\n        _;\n    }\n\n    /**\n     * @notice This function gets the array of vaultOwners\n     */\n    function getVaultOwners() public view returns (address payable[] memory) {\n        address payable[] memory owners;\n        uint256 index = 0;\n        for (uint256 i = 0; i < vaultOwners.length; i++) {\n            if (hasVault(vaultOwners[i])) {\n                owners[index] = vaultOwners[i];\n                index++;\n            }\n        }\n\n        return owners;\n    }\n\n    /**\n     * @notice Can only be called by owner. Used to update the fees, minminCollateralizationRatio, etc\n     * @param _liquidationIncentive The incentive paid to liquidator. 10 is 0.01 i.e. 1% incentive.\n     * @param _liquidationFactor Max amount that a Vault can be liquidated by. 500 is 0.5.\n     * @param _transactionFee The fees paid to our protocol every time a execution happens. 100 is egs. 0.1 i.e. 10%.\n     * @param _minCollateralizationRatio The minimum ratio of a Vault's collateral to insurance promised. 16 means 1.6.\n     */\n    function updateParameters(\n        uint256 _liquidationIncentive,\n        uint256 _liquidationFactor,\n        uint256 _transactionFee,\n        uint256 _minCollateralizationRatio\n    ) public onlyOwner {\n        require(\n            _liquidationIncentive <= 200,\n            \"Can't have >20% liquidation incentive\"\n        );\n        require(\n            _liquidationFactor <= 1000,\n            \"Can't liquidate more than 100% of the vault\"\n        );\n        require(_transactionFee <= 100, \"Can't have transaction fee > 10%\");\n        require(\n            _minCollateralizationRatio >= 10,\n            \"Can't have minCollateralizationRatio < 1\"\n        );\n\n        liquidationIncentive.value = _liquidationIncentive;\n        liquidationFactor.value = _liquidationFactor;\n        transactionFee.value = _transactionFee;\n        minCollateralizationRatio.value = _minCollateralizationRatio;\n\n        emit UpdateParameters(\n            _liquidationIncentive,\n            _liquidationFactor,\n            _transactionFee,\n            _minCollateralizationRatio,\n            owner()\n        );\n    }\n\n    /**\n     * @notice Can only be called by owner. Used to take out the protocol fees from the contract.\n     * @param _address The address to send the fee to.\n     */\n    function transferFee(address payable _address) public onlyOwner {\n        uint256 fees = totalFee;\n        totalFee = 0;\n        transferCollateral(_address, fees);\n\n        emit TransferFee(_address, fees);\n    }\n\n    /**\n     * @notice Checks if a `owner` has already created a Vault\n     * @param owner The address of the supposed owner\n     * @return true or false\n     */\n    function hasVault(address payable owner) public view returns (bool) {\n        return vaults[owner].owned;\n    }\n\n    /**\n     * @notice Creates a new empty Vault and sets the owner of the vault to be the msg.sender.\n     */\n    function openVault() public notExpired returns (bool) {\n        require(!hasVault(msg.sender), \"Vault already created\");\n\n        vaults[msg.sender] = Vault(0, 0, 0, true);\n        vaultOwners.push(msg.sender);\n\n        emit VaultOpened(msg.sender);\n        return true;\n    }\n\n    /**\n     * @notice If the collateral type is ETH, anyone can call this function any time before\n     * expiry to increase the amount of collateral in a Vault. Will fail if ETH is not the\n     * collateral asset.\n     * Remember that adding ETH collateral even if no oTokens have been created can put the owner at a\n     * risk of losing the collateral if an exercise event happens.\n     * Ensure that you issue and immediately sell oTokens to allow the owner to earn premiums.\n     * (Either call the createAndSell function in the oToken contract or batch the\n     * addERC20Collateral, issueOTokens and sell transactions and ensure they happen atomically to protect\n     * the end user).\n     * @param vaultOwner the index of the Vault to which collateral will be added.\n     */\n    function addETHCollateral(address payable vaultOwner)\n        public\n        payable\n        notExpired\n        returns (uint256)\n    {\n        require(isETH(collateral), \"ETH is not the specified collateral type\");\n        require(hasVault(vaultOwner), \"Vault does not exist\");\n\n        emit ETHCollateralAdded(vaultOwner, msg.value, msg.sender);\n        return _addCollateral(vaultOwner, msg.value);\n    }\n\n    /**\n     * @notice If the collateral type is any ERC20, anyone can call this function any time before\n     * expiry to increase the amount of collateral in a Vault. Can only transfer in the collateral asset.\n     * Will fail if ETH is the collateral asset.\n     * The user has to allow the contract to handle their ERC20 tokens on his behalf before these\n     * functions are called.\n     * Remember that adding ERC20 collateral even if no oTokens have been created can put the owner at a\n     * risk of losing the collateral. Ensure that you issue and immediately sell the oTokens!\n     * (Either call the createAndSell function in the oToken contract or batch the\n     * addERC20Collateral, issueOTokens and sell transactions and ensure they happen atomically to protect\n     * the end user).\n     * @param vaultOwner the index of the Vault to which collateral will be added.\n     * @param amt the amount of collateral to be transferred in.\n     */\n    function addERC20Collateral(address payable vaultOwner, uint256 amt)\n        public\n        notExpired\n        returns (uint256)\n    {\n        require(\n            collateral.transferFrom(msg.sender, address(this), amt),\n            \"Could not transfer in collateral tokens\"\n        );\n        require(hasVault(vaultOwner), \"Vault does not exist\");\n\n        emit ERC20CollateralAdded(vaultOwner, amt, msg.sender);\n        return _addCollateral(vaultOwner, amt);\n    }\n\n    /**\n     * @notice Returns the amount of underlying to be transferred during an exercise call\n     */\n    function underlyingToTransfer(uint256 oTokensToExercise)\n        public\n        view\n        returns (uint256)\n    {\n        uint64 underlyingPerOTokenExp = uint64(\n            oTokenExchangeRate.exponent - underlyingExp\n        );\n        return oTokensToExercise.mul(10**underlyingPerOTokenExp);\n    }\n\n    /**\n     * @notice Returns true if exercise can be called\n     */\n    function isExerciseWindow() public view returns (bool) {\n        return ((block.timestamp >= expiry.sub(windowSize)) &&\n            (block.timestamp < expiry));\n    }\n\n    /**\n     * @notice Returns true if the oToken contract has expired\n     */\n    function hasExpired() public view returns (bool) {\n        return (block.timestamp >= expiry);\n    }\n\n    /**\n     * @notice Called by anyone holding the oTokens and underlying during the\n     * exercise window i.e. from `expiry - windowSize` time to `expiry` time. The caller\n     * transfers in their oTokens and corresponding amount of underlying and gets\n     * `strikePrice * oTokens` amount of collateral out. The collateral paid out is taken from\n     * the each vault owner starting with the first and iterating until the oTokens to exercise\n     * are found.\n     * NOTE: This uses a for loop and hence could run out of gas if the array passed in is too big!\n     * @param oTokensToExercise the number of oTokens being exercised.\n     * @param vaultsToExerciseFrom the array of vaults to exercise from.\n     */\n    function exercise(\n        uint256 oTokensToExercise,\n        address payable[] memory vaultsToExerciseFrom\n    ) public payable {\n        for (uint256 i = 0; i < vaultsToExerciseFrom.length; i++) {\n            address payable vaultOwner = vaultsToExerciseFrom[i];\n            require(\n                hasVault(vaultOwner),\n                \"Cannot exercise from a vault that doesn't exist\"\n            );\n            Vault storage vault = vaults[vaultOwner];\n            if (oTokensToExercise == 0) {\n                return;\n            } else if (vault.oTokensIssued >= oTokensToExercise) {\n                _exercise(oTokensToExercise, vaultOwner);\n                return;\n            } else {\n                oTokensToExercise = oTokensToExercise.sub(vault.oTokensIssued);\n                _exercise(vault.oTokensIssued, vaultOwner);\n            }\n        }\n        require(\n            oTokensToExercise == 0,\n            \"Specified vaults have insufficient collateral\"\n        );\n    }\n\n    /**\n     * @notice This function allows the vault owner to remove their share of underlying after an exercise\n     */\n    function removeUnderlying() public {\n        require(hasVault(msg.sender), \"Vault does not exist\");\n        Vault storage vault = vaults[msg.sender];\n\n        require(vault.underlying > 0, \"No underlying balance\");\n\n        uint256 underlyingToTransfer = vault.underlying;\n        vault.underlying = 0;\n\n        transferUnderlying(msg.sender, underlyingToTransfer);\n        emit RemoveUnderlying(underlyingToTransfer, msg.sender);\n\n    }\n\n    /**\n     * @notice This function is called to issue the option tokens. Remember that issuing oTokens even if they\n     * haven't been sold can put the owner at a risk of not making premiums on the oTokens. Ensure that you\n     * issue and immidiately sell the oTokens! (Either call the createAndSell function in the oToken contract\n     * of batch the issueOTokens transaction with a sell transaction and ensure it happens atomically).\n     * @dev The owner of a Vault should only be able to have a max of\n     * repo.collateral * collateralToStrike / (minminCollateralizationRatio * strikePrice) tokens issued.\n     * @param oTokensToIssue The number of o tokens to issue\n     * @param receiver The address to send the oTokens to\n     */\n    function issueOTokens(uint256 oTokensToIssue, address receiver)\n        public\n        notExpired\n    {\n        //check that we're properly collateralized to mint this number, then call _mint(address account, uint256 amount)\n        require(hasVault(msg.sender), \"Vault does not exist\");\n\n        Vault storage vault = vaults[msg.sender];\n\n        // checks that the vault is sufficiently collateralized\n        uint256 newOTokensBalance = vault.oTokensIssued.add(oTokensToIssue);\n        require(isSafe(vault.collateral, newOTokensBalance), \"unsafe to mint\");\n\n        // issue the oTokens\n        vault.oTokensIssued = newOTokensBalance;\n        _mint(receiver, oTokensToIssue);\n\n        emit IssuedOTokens(receiver, oTokensToIssue, msg.sender);\n        return;\n    }\n\n    /**\n     * @notice Returns the vault for a given address\n     * @param vaultOwner the owner of the Vault to return\n     */\n    function getVault(address payable vaultOwner)\n        public\n        view\n        returns (uint256, uint256, uint256, bool)\n    {\n        Vault storage vault = vaults[vaultOwner];\n        return (\n            vault.collateral,\n            vault.oTokensIssued,\n            vault.underlying,\n            vault.owned\n        );\n    }\n\n    /**\n     * @notice Returns true if the given ERC20 is ETH.\n     * @param _ierc20 the ERC20 asset.\n     */\n    function isETH(IERC20 _ierc20) public pure returns (bool) {\n        return _ierc20 == IERC20(0);\n    }\n\n    /**\n     * @notice allows the owner to burn their oTokens to increase the collateralization ratio of\n     * their vault.\n     * @param amtToBurn number of oTokens to burn\n     * @dev only want to call this function before expiry. After expiry, no benefit to calling it.\n     */\n    function burnOTokens(uint256 amtToBurn) public notExpired {\n        require(hasVault(msg.sender), \"Vault does not exist\");\n\n        Vault storage vault = vaults[msg.sender];\n\n        vault.oTokensIssued = vault.oTokensIssued.sub(amtToBurn);\n        _burn(msg.sender, amtToBurn);\n\n        emit BurnOTokens(msg.sender, amtToBurn);\n    }\n\n    /**\n     * @notice allows the owner to remove excess collateral from the vault before expiry. Removing collateral lowers\n     * the collateralization ratio of the vault.\n     * @param amtToRemove Amount of collateral to remove in 10^-18.\n     */\n    function removeCollateral(uint256 amtToRemove) public notExpired {\n        require(amtToRemove > 0, \"Cannot remove 0 collateral\");\n        require(hasVault(msg.sender), \"Vault does not exist\");\n\n        Vault storage vault = vaults[msg.sender];\n        require(\n            amtToRemove <= getCollateral(msg.sender),\n            \"Can't remove more collateral than owned\"\n        );\n\n        // check that vault will remain safe after removing collateral\n        uint256 newCollateralBalance = vault.collateral.sub(amtToRemove);\n\n        require(\n            isSafe(newCollateralBalance, vault.oTokensIssued),\n            \"Vault is unsafe\"\n        );\n\n        // remove the collateral\n        vault.collateral = newCollateralBalance;\n        transferCollateral(msg.sender, amtToRemove);\n\n        emit RemoveCollateral(amtToRemove, msg.sender);\n    }\n\n    /**\n     * @notice after expiry, each vault holder can get back their proportional share of collateral\n     * from vaults that they own.\n     * @dev The owner gets all of their collateral back if no exercise event took their collateral.\n     */\n    function redeemVaultBalance() public {\n        require(hasExpired(), \"Can't collect collateral until expiry\");\n        require(hasVault(msg.sender), \"Vault does not exist\");\n\n        // pay out owner their share\n        Vault storage vault = vaults[msg.sender];\n\n        // To deal with lower precision\n        uint256 collateralToTransfer = vault.collateral;\n        uint256 underlyingToTransfer = vault.underlying;\n\n        vault.collateral = 0;\n        vault.oTokensIssued = 0;\n        vault.underlying = 0;\n\n        transferCollateral(msg.sender, collateralToTransfer);\n        transferUnderlying(msg.sender, underlyingToTransfer);\n\n        emit RedeemVaultBalance(\n            collateralToTransfer,\n            underlyingToTransfer,\n            msg.sender\n        );\n    }\n\n    /**\n     * This function returns the maximum amount of collateral liquidatable if the given vault is unsafe\n     * @param vaultOwner The index of the vault to be liquidated\n     */\n    function maxCollateralLiquidatable(address payable vaultOwner)\n        public\n        view\n        returns (uint256)\n    {\n        if (isUnsafe(vaultOwner)) {\n            Vault storage vault = vaults[vaultOwner];\n            return vault.collateral.mul(liquidationFactor.value);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice This function can be called by anyone who notices a vault is undercollateralized.\n     * The caller gets a reward for reducing the amount of oTokens in circulation.\n     * @dev Liquidator comes with _oTokens. They get _oTokens * strikePrice * (incentive + fee)\n     * amount of collateral out. They can liquidate a max of liquidationFactor * vault.collateral out\n     * in one function call i.e. partial liquidations.\n     * @param vaultOwner The index of the vault to be liquidated\n     * @param oTokensToLiquidate The number of oTokens being taken out of circulation\n     */\n    function liquidate(address payable vaultOwner, uint256 oTokensToLiquidate)\n        public\n        notExpired\n    {\n        require(hasVault(vaultOwner), \"Vault does not exist\");\n\n        Vault storage vault = vaults[vaultOwner];\n\n        // cannot liquidate a safe vault.\n        require(isUnsafe(vaultOwner), \"Vault is safe\");\n\n        // Owner can't liquidate themselves\n        require(msg.sender != vaultOwner, \"Owner can't liquidate themselves\");\n\n        uint256 amtCollateral = calculateCollateralToPay(\n            oTokensToLiquidate,\n            Number(1, 0)\n        );\n        uint256 amtIncentive = calculateCollateralToPay(\n            oTokensToLiquidate,\n            liquidationIncentive\n        );\n        uint256 amtCollateralToPay = amtCollateral.add(amtIncentive);\n\n        // calculate the maximum amount of collateral that can be liquidated\n        uint256 maxCollateralLiquidatable = maxCollateralLiquidatable(\n            vaultOwner\n        );\n        if (liquidationFactor.exponent > 0) {\n            maxCollateralLiquidatable = maxCollateralLiquidatable.mul(\n                10**uint256(liquidationFactor.exponent)\n            );\n        } else {\n            maxCollateralLiquidatable = maxCollateralLiquidatable.div(\n                10**uint256(-1 * liquidationFactor.exponent)\n            );\n        }\n\n        require(\n            amtCollateralToPay <= maxCollateralLiquidatable,\n            \"Can only liquidate liquidation factor at any given time\"\n        );\n\n        // deduct the collateral and oTokensIssued\n        vault.collateral = vault.collateral.sub(amtCollateralToPay);\n        vault.oTokensIssued = vault.oTokensIssued.sub(oTokensToLiquidate);\n\n        // transfer the collateral and burn the _oTokens\n        _burn(msg.sender, oTokensToLiquidate);\n        transferCollateral(msg.sender, amtCollateralToPay);\n\n        emit Liquidate(amtCollateralToPay, vaultOwner, msg.sender);\n    }\n\n    /**\n     * @notice checks if a vault is unsafe. If so, it can be liquidated\n     * @param vaultOwner The number of the vault to check\n     * @return true or false\n     */\n    function isUnsafe(address payable vaultOwner) public view returns (bool) {\n        bool isUnsafe = !isSafe(\n            getCollateral(vaultOwner),\n            getOTokensIssued(vaultOwner)\n        );\n        return isUnsafe;\n    }\n\n    /**\n     * @notice This function returns if an -30 <= exponent <= 30\n     */\n    function isWithinExponentRange(int32 val) internal returns (bool) {\n        return ((val <= 30) && (val >= -30));\n    }\n\n    /**\n     * @notice This function calculates and returns the amount of collateral in the vault\n    */\n    function getCollateral(address payable vaultOwner)\n        internal\n        view\n        returns (uint256)\n    {\n        Vault storage vault = vaults[vaultOwner];\n        return vault.collateral;\n    }\n\n    /**\n     * @notice This function calculates and returns the amount of puts issued by the Vault\n    */\n    function getOTokensIssued(address payable vaultOwner)\n        internal\n        view\n        returns (uint256)\n    {\n        Vault storage vault = vaults[vaultOwner];\n        return vault.oTokensIssued;\n    }\n\n    /**\n     * @notice Called by anyone holding the oTokens and underlying during the\n     * exercise window i.e. from `expiry - windowSize` time to `expiry` time. The caller\n     * transfers in their oTokens and corresponding amount of underlying and gets\n     * `strikePrice * oTokens` amount of collateral out. The collateral paid out is taken from\n     * the specified vault holder. At the end of the expiry window, the vault holder can redeem their balance\n     * of collateral. The vault owner can withdraw their underlying at any time.\n     * The user has to allow the contract to handle their oTokens and underlying on his behalf before these functions are called.\n     * @param oTokensToExercise the number of oTokens being exercised.\n     * @param vaultToExerciseFrom the address of the vaultOwner to take collateral from.\n     * @dev oTokenExchangeRate is the number of underlying tokens that 1 oToken protects.\n     */\n    function _exercise(\n        uint256 oTokensToExercise,\n        address payable vaultToExerciseFrom\n    ) internal {\n        // 1. before exercise window: revert\n        require(\n            isExerciseWindow(),\n            \"Can't exercise outside of the exercise window\"\n        );\n\n        require(hasVault(vaultToExerciseFrom), \"Vault does not exist\");\n\n        Vault storage vault = vaults[vaultToExerciseFrom];\n        require(oTokensToExercise > 0, \"Can't exercise 0 oTokens\");\n        // Check correct amount of oTokens passed in)\n        require(\n            oTokensToExercise <= vault.oTokensIssued,\n            \"Can't exercise more oTokens than the owner has\"\n        );\n        // Ensure person calling has enough oTokens\n        require(\n            balanceOf(msg.sender) >= oTokensToExercise,\n            \"Not enough oTokens\"\n        );\n\n        // 1. Check sufficient underlying\n        // 1.1 update underlying balances\n        uint256 amtUnderlyingToPay = underlyingToTransfer(oTokensToExercise);\n        vault.underlying = vault.underlying.add(amtUnderlyingToPay);\n\n        // 2. Calculate Collateral to pay\n        // 2.1 Payout enough collateral to get (strikePrice * oTokens) amount of collateral\n        uint256 amtCollateralToPay = calculateCollateralToPay(\n            oTokensToExercise,\n            Number(1, 0)\n        );\n\n        // 2.2 Take a small fee on every exercise\n        uint256 amtFee = calculateCollateralToPay(\n            oTokensToExercise,\n            transactionFee\n        );\n        totalFee = totalFee.add(amtFee);\n\n        uint256 totalCollateralToPay = amtCollateralToPay.add(amtFee);\n        require(\n            totalCollateralToPay <= vault.collateral,\n            \"Vault underwater, can't exercise\"\n        );\n\n        // 3. Update collateral + oToken balances\n        vault.collateral = vault.collateral.sub(totalCollateralToPay);\n        vault.oTokensIssued = vault.oTokensIssued.sub(oTokensToExercise);\n\n        // 4. Transfer in underlying, burn oTokens + pay out collateral\n        // 4.1 Transfer in underlying\n        if (isETH(underlying)) {\n            require(msg.value == amtUnderlyingToPay, \"Incorrect msg.value\");\n        } else {\n            require(\n                underlying.transferFrom(\n                    msg.sender,\n                    address(this),\n                    amtUnderlyingToPay\n                ),\n                \"Could not transfer in tokens\"\n            );\n        }\n        // 4.2 burn oTokens\n        _burn(msg.sender, oTokensToExercise);\n\n        // 4.3 Pay out collateral\n        transferCollateral(msg.sender, amtCollateralToPay);\n\n        emit Exercise(\n            amtUnderlyingToPay,\n            amtCollateralToPay,\n            msg.sender,\n            vaultToExerciseFrom\n        );\n\n    }\n\n    /**\n     * @notice adds `_amt` collateral to `vaultOwner` and returns the new balance of the vault\n     * @param vaultOwner the index of the vault\n     * @param amt the amount of collateral to add\n     */\n    function _addCollateral(address payable vaultOwner, uint256 amt)\n        internal\n        notExpired\n        returns (uint256)\n    {\n        Vault storage vault = vaults[vaultOwner];\n        vault.collateral = vault.collateral.add(amt);\n\n        return vault.collateral;\n    }\n\n    /**\n     * @notice checks if a hypothetical vault is safe with the given collateralAmt and oTokensIssued\n     * @param collateralAmt The amount of collateral the hypothetical vault has\n     * @param oTokensIssued The amount of oTokens generated by the hypothetical vault\n     * @return true or false\n     */\n    function isSafe(uint256 collateralAmt, uint256 oTokensIssued)\n        internal\n        view\n        returns (bool)\n    {\n        // get price from Oracle\n        uint256 ethToCollateralPrice = getPrice(address(collateral));\n        uint256 ethToStrikePrice = getPrice(address(strike));\n\n        // check `oTokensIssued * minCollateralizationRatio * strikePrice <= collAmt * collateralToStrikePrice`\n        uint256 leftSideVal = oTokensIssued\n            .mul(minCollateralizationRatio.value)\n            .mul(strikePrice.value);\n        int32 leftSideExp = minCollateralizationRatio.exponent +\n            strikePrice.exponent;\n\n        uint256 rightSideVal = (collateralAmt.mul(ethToStrikePrice)).div(\n            ethToCollateralPrice\n        );\n        int32 rightSideExp = collateralExp;\n\n        uint256 exp = 0;\n        bool stillSafe = false;\n\n        if (rightSideExp < leftSideExp) {\n            exp = uint256(leftSideExp - rightSideExp);\n            stillSafe = leftSideVal.mul(10**exp) <= rightSideVal;\n        } else {\n            exp = uint256(rightSideExp - leftSideExp);\n            stillSafe = leftSideVal <= rightSideVal.mul(10**exp);\n        }\n\n        return stillSafe;\n    }\n\n    /**\n     * @notice This function calculates the amount of collateral to be paid out.\n     * @dev The amount of collateral to paid out is determined by:\n     * `proportion` * `strikePrice` * `oTokens` amount of collateral.\n     * @param _oTokens The number of oTokens.\n     * @param proportion The proportion of the collateral to pay out. If 100% of collateral\n     * should be paid out, pass in Number(1, 0). The proportion might be less than 100% if\n     * you are calculating fees.\n     */\n    function calculateCollateralToPay(\n        uint256 _oTokens,\n        Number memory proportion\n    ) internal returns (uint256) {\n        // Get price from oracle\n        uint256 ethToCollateralPrice = getPrice(address(collateral));\n        uint256 ethToStrikePrice = getPrice(address(strike));\n\n        // calculate how much should be paid out\n        uint256 amtCollateralToPayInEthNum = _oTokens\n            .mul(strikePrice.value)\n            .mul(proportion.value)\n            .mul(ethToCollateralPrice);\n        int32 amtCollateralToPayExp = strikePrice.exponent +\n            proportion.exponent -\n            collateralExp;\n        uint256 amtCollateralToPay = 0;\n        if (amtCollateralToPayExp > 0) {\n            uint32 exp = uint32(amtCollateralToPayExp);\n            amtCollateralToPay = amtCollateralToPayInEthNum.mul(10**exp).div(\n                ethToStrikePrice\n            );\n        } else {\n            uint32 exp = uint32(-1 * amtCollateralToPayExp);\n            amtCollateralToPay = (amtCollateralToPayInEthNum.div(10**exp)).div(\n                ethToStrikePrice\n            );\n        }\n\n        return amtCollateralToPay;\n\n    }\n\n    /**\n     * @notice This function transfers `amt` collateral to `_addr`\n     * @param _addr The address to send the collateral to\n     * @param _amt The amount of the collateral to pay out.\n     */\n    function transferCollateral(address payable _addr, uint256 _amt) internal {\n        if (isETH(collateral)) {\n            _addr.transfer(_amt);\n        } else {\n            collateral.transfer(_"
    }
  ]
}