{
  "Title": "[M-01] Liquidations can be run on the bogus Oracle prices",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35\n\n\n# Vulnerability details\n\n## Impact\n\nIf the price feed is manipulated in any way or there is any malfunction based volatility on the market, a malicious user can use this to liquidate a healthy position.\n\nAn attacker can setup a monitoring of the used Oracle feed and act on observing a price outbreak (for example, zero price, which is usually a subject to filtration), liquidating the trader position which is perfectly healthy otherwise, obtaining the collateral with a substantial discount at the expense of the trader.\n\nThe same is for a flash crash kind of scenario, i.e. a price outbreak of any nature will allow for non-market liquidation by an attacker, who has the incentives to setup such a monitoring and act on such an outbreak, knowing that it will not be smoothed or filtered out, allowing a liquidation at a non-market price that happen to be printed in the Oracle feed\n\n## Proof of Concept\n\nOracle.getUnderlyingPrice just passes on the latest Oracle answer, not checking it anyhow:\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35\n\nIt is then used in liquidation triggers providing isLiquidatable and _getLiquidationInfo functions:\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L249\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L465\n\n## Recommended Mitigation Steps\n\nAdd a non-zero Oracle price check, possibly add an additional Oracle feed information usage to control that the price is fresh. Please consult the Chainlink for that as OCR introduction might have changed the state of the art approach (i.e. whether and how to use latestRoundData returned data):\n\nhttps://docs.chain.link/docs/off-chain-reporting/\n\nRegarding any price spikes it is straightforward to construct a mitigation mechanics for such cases, so the system will be affected by sustainable price movements only.\n\nAs price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.\n\nOne of the approaches is to track both current and TWAP prices, and condition all state changing actions, including liquidations, on the current price being within a threshold of the TWAP one. If the liquidation margin level is conservative enough and TWAP window is small enough this is safe for the overall stability of the system, while providing substantial mitigation mechanics by allowing state changes on the locally calm market only.\n\nAnother approach is to introduce time delay between liquidation request and actual liquidation. Again, conservative enough margin level plus small enough delay keeps the system safe, while requiring that market conditions allow for liquidation both at request time and at execution time provides ample filtration against price feed outbreaks\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { AggregatorV3Interface } from \"./Interfaces.sol\";\n\ncontract Oracle is Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    mapping(address => address) public chainLinkAggregatorMap;\n    mapping(address => int256) public stablePrice;\n\n    uint256[50] private __gap;\n\n    function initialize(address _governance) external initializer {\n        _setGovernace(_governance);\n    }\n\n    function getUnderlyingPrice(address underlying)\n        virtual\n        external\n        view\n        returns(int256 answer)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        (,answer,,,) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();\n        answer /= 100;\n    }\n\n    function getUnderlyingTwapPrice(address underlying, uint256 intervalInSeconds)\n        virtual\n        public\n        view\n        returns (int256)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]);\n        requireNonEmptyAddress(address(aggregator));\n        require(intervalInSeconds != 0, \"interval can't be 0\");\n\n        // 3 different timestamps, `previous`, `current`, `target`\n        // `base` = now - intervalInSeconds\n        // `current` = current round timestamp from aggregator\n        // `previous` = previous round timestamp form aggregator\n        // now >= previous > current > = < base\n        //\n        //  while loop i = 0\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base                 current  now(previous)\n        //\n        //  while loop i = 1\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base           current previous now\n\n        (uint80 round, uint256 latestPrice, uint256 latestTimestamp) = getLatestRoundData(aggregator);\n        uint256 baseTimestamp = _blockTimestamp() - intervalInSeconds;\n        // if latest updated timestamp is earlier than target timestamp, return the latest price.\n        if (latestTimestamp < baseTimestamp || round == 0) {\n            return formatPrice(latestPrice);\n        }\n\n        // rounds are like snapshots, latestRound means the latest price snapshot. follow chainlink naming\n        uint256 previousTimestamp = latestTimestamp;\n        uint256 cumulativeTime = _blockTimestamp() - previousTimestamp;\n        uint256 weightedPrice = latestPrice * cumulativeTime;\n        while (true) {\n            if (round == 0) {\n                // if cumulative time is less than requested interval, return current twap price\n                return formatPrice(weightedPrice / cumulativeTime);\n            }\n\n            round = round - 1; // check round sanity\n            (, uint256 currentPrice, uint256 currentTimestamp) = getRoundData(aggregator, round);\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentTimestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, intervalInSeconds is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice + (currentPrice * (previousTimestamp - baseTimestamp));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp - currentTimestamp;\n            weightedPrice = weightedPrice + (currentPrice * timeFraction);\n            cumulativeTime = cumulativeTime + timeFraction;\n            previousTimestamp = currentTimestamp;\n        }\n        return formatPrice(weightedPrice / intervalInSeconds);\n    }\n\n    //\n    // INTERNAL VIEW FUNCTIONS\n    //\n\n    function getLatestRoundData(AggregatorV3Interface _aggregator)\n        internal\n        view\n        returns (\n            uint80,\n            uint256 finalPrice,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();\n        finalPrice = uint256(latestPrice);\n        if (latestPrice < 0) {\n            requireEnoughHistory(round);\n            (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);\n        }\n        return (round, finalPrice, latestTimestamp);\n    }\n\n    function getRoundData(AggregatorV3Interface _aggregator, uint80 _round)\n        internal\n        view\n        returns (\n            uint80,\n            uint256,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.getRoundData(_round);\n        while (latestPrice < 0) {\n            requireEnoughHistory(round);\n            round = round - 1;\n            (, latestPrice, , latestTimestamp, ) = _aggregator.getRoundData(round);\n        }\n        return (round, uint256(latestPrice), latestTimestamp);\n    }\n\n    function formatPrice(uint256 _price) internal pure returns (int256) {\n        return (_price / 100).toInt256(); // 6 decimals\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    // Internal\n\n    function requireEnoughHistory(uint80 _round) internal pure {\n        require(_round > 0, \"Not enough history\");\n    }\n\n    function requireNonEmptyAddress(address _addr) internal pure {\n        require(_addr != address(0), \"empty address\");\n    }\n\n    // Governance\n\n    function setAggregator(address underlying, address aggregator) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        requireNonEmptyAddress(aggregator);\n        chainLinkAggregatorMap[underlying] = aggregator;\n        // AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData(); // sanity check\n    }\n\n    function setStablePrice(address underlying, int256 price) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        stablePrice[underlying] = price;\n    }\n}"
    }
  ]
}