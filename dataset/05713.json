{
  "Title": "[26] Wrong comment",
  "Content": "\n[secp256k1/mod.rs, line 404](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L404)\n\n```diff\n-                // The two points are equal, so we double.\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs",
      "content": "use boojum::pairing::ff::BitIterator;\nuse boojum::pairing::ff::*;\nuse boojum::pairing::{\n    EncodingBytes, GenericCompressedEncodable, GenericCurveAffine, GenericCurveProjective,\n    GenericUncompressedEncodable, GroupDecodingError,\n};\n\npub mod fq;\npub mod fr;\n\nuse fq::*;\nuse fr::*;\n\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub struct PointAffine {\n    pub(crate) x: Fq,\n    pub(crate) y: Fq,\n    pub(crate) infinity: bool,\n}\n\nstatic NAME_STR: &'static str = \"Secp256k1\";\n\nimpl ::std::fmt::Display for PointAffine {\n    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n        if self.infinity {\n            write!(f, \"{}(Infinity)\", NAME_STR)\n        } else {\n            write!(f, \"{}(x={}, y={})\", NAME_STR, self.x, self.y)\n        }\n    }\n}\n\n#[derive(Copy, Clone, Debug, Eq)]\npub struct PointProjective {\n    pub(crate) x: Fq,\n    pub(crate) y: Fq,\n    pub(crate) z: Fq,\n}\n\nimpl ::std::fmt::Display for PointProjective {\n    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n        write!(f, \"{}\", self.into_affine())\n    }\n}\n\nimpl PartialEq for PointProjective {\n    fn eq(&self, other: &PointProjective) -> bool {\n        if self.is_zero() {\n            return other.is_zero();\n        }\n\n        if other.is_zero() {\n            return false;\n        }\n\n        // The points (X, Y, Z) and (X', Y', Z')\n        // are equal when (X * Z^2) = (X' * Z'^2)\n        // and (Y * Z^3) = (Y' * Z'^3).\n\n        let mut z1 = self.z;\n        z1.square();\n        let mut z2 = other.z;\n        z2.square();\n\n        let mut tmp1 = self.x;\n        tmp1.mul_assign(&z2);\n\n        let mut tmp2 = other.x;\n        tmp2.mul_assign(&z1);\n\n        if tmp1 != tmp2 {\n            return false;\n        }\n\n        z1.mul_assign(&self.z);\n        z2.mul_assign(&other.z);\n        z2.mul_assign(&self.y);\n        z1.mul_assign(&other.y);\n\n        if z1 != z2 {\n            return false;\n        }\n\n        true\n    }\n}\n\nimpl PointAffine {\n    fn mul_bits<S: AsRef<[u64]>>(&self, bits: BitIterator<S>) -> PointProjective {\n        let mut res = PointProjective::zero();\n        for i in bits {\n            res.double();\n            if i {\n                res.add_assign_mixed(self)\n            }\n        }\n        res\n    }\n\n    /// Attempts to construct an affine point given an x-coordinate. The\n    /// point is not guaranteed to be in the prime order subgroup.\n    ///\n    /// If and only if `greatest` is set will the lexicographically\n    /// largest y-coordinate be selected.\n    fn get_point_from_x(x: Fq, greatest: bool) -> Option<PointAffine> {\n        // Compute x^3 + b\n        let mut x3b = x;\n        x3b.square();\n        x3b.mul_assign(&x);\n        x3b.add_assign(&PointAffine::get_coeff_b());\n\n        x3b.sqrt().map(|y| {\n            let mut negy = y;\n            negy.negate();\n\n            PointAffine {\n                x: x,\n                y: if (y < negy) ^ greatest { y } else { negy },\n                infinity: false,\n            }\n        })\n    }\n\n    fn is_on_curve(&self) -> bool {\n        if self.is_zero() {\n            true\n        } else {\n            // Check that the point is on the curve\n            let mut y2 = self.y;\n            y2.square();\n\n            let mut x3b = self.x;\n            x3b.square();\n            x3b.mul_assign(&self.x);\n            x3b.add_assign(&Self::get_coeff_b());\n\n            y2 == x3b\n        }\n    }\n}\n\nimpl GenericCurveAffine for PointAffine {\n    type Scalar = Fr;\n    type Base = Fq;\n    type Projective = PointProjective;\n\n    fn zero() -> Self {\n        PointAffine {\n            x: Fq::zero(),\n            y: Fq::one(),\n            infinity: true,\n        }\n    }\n\n    fn one() -> Self {\n        Self::get_generator()\n    }\n\n    fn is_zero(&self) -> bool {\n        self.infinity\n    }\n\n    fn mul<S: Into<<Self::Scalar as PrimeField>::Repr>>(&self, by: S) -> PointProjective {\n        let bits = BitIterator::new(by.into());\n        self.mul_bits(bits)\n    }\n\n    fn negate(&mut self) {\n        if !self.is_zero() {\n            self.y.negate();\n        }\n    }\n\n    fn into_projective(&self) -> PointProjective {\n        (*self).into()\n    }\n\n    #[inline(always)]\n    fn as_xy(&self) -> (&Self::Base, &Self::Base) {\n        (&self.x, &self.y)\n    }\n\n    #[inline(always)]\n    fn into_xy_unchecked(self) -> (Self::Base, Self::Base) {\n        (self.x, self.y)\n    }\n\n    #[inline(always)]\n    fn from_xy_unchecked(x: Self::Base, y: Self::Base) -> Self {\n        let infinity = x.is_zero() && y.is_zero();\n        Self {\n            x: x,\n            y: y,\n            infinity,\n        }\n    }\n\n    fn from_xy_checked(x: Self::Base, y: Self::Base) -> Result<Self, GroupDecodingError> {\n        let infinity = x.is_zero() && y.is_zero();\n        let affine = Self {\n            x: x,\n            y: y,\n            infinity,\n        };\n\n        if !affine.is_on_curve() {\n            Err(GroupDecodingError::NotOnCurve)\n        } else {\n            Ok(affine)\n        }\n    }\n\n    fn a_coeff() -> Self::Base {\n        Self::Base::zero()\n    }\n\n    fn b_coeff() -> Self::Base {\n        Self::get_coeff_b()\n    }\n}\n\nimpl GenericCurveProjective for PointProjective {\n    type Scalar = Fr;\n    type Base = Fq;\n    type Affine = PointAffine;\n\n    // The point at infinity is always represented by\n    // Z = 0.\n    fn zero() -> Self {\n        PointProjective {\n            x: Fq::zero(),\n            y: Fq::one(),\n            z: Fq::zero(),\n        }\n    }\n\n    fn one() -> Self {\n        PointAffine::one().into()\n    }\n\n    // The point at infinity is always represented by\n    // Z = 0.\n    fn is_zero(&self) -> bool {\n        self.z.is_zero()\n    }\n\n    fn is_normalized(&self) -> bool {\n        self.is_zero() || self.z == Fq::one()\n    }\n\n    fn batch_normalization(v: &mut [Self]) {\n        // Montgomeryâ€™s Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n\n        // First pass: compute [a, ab, abc, ...]\n        let mut prod = Vec::with_capacity(v.len());\n        let mut tmp = Fq::one();\n        for g in v\n            .iter_mut()\n            // Ignore normalized elements\n            .filter(|g| !g.is_normalized())\n        {\n            tmp.mul_assign(&g.z);\n            prod.push(tmp);\n        }\n\n        // Invert `tmp`.\n        tmp = tmp.inverse().unwrap(); // Guaranteed to be nonzero.\n\n        // Second pass: iterate backwards to compute inverses\n        for (g, s) in v\n            .iter_mut()\n            // Backwards\n            .rev()\n            // Ignore normalized elements\n            .filter(|g| !g.is_normalized())\n            // Backwards, skip last element, fill in one for last term.\n            .zip(prod.into_iter().rev().skip(1).chain(Some(Fq::one())))\n        {\n            // tmp := tmp * g.z; g.z := tmp * s = 1/z\n            let mut newtmp = tmp;\n            newtmp.mul_assign(&g.z);\n            g.z = tmp;\n            g.z.mul_assign(&s);\n            tmp = newtmp;\n        }\n\n        // Perform affine transformations\n        for g in v.iter_mut().filter(|g| !g.is_normalized()) {\n            let mut z = g.z; // 1/z\n            z.square(); // 1/z^2\n            g.x.mul_assign(&z); // x/z^2\n            z.mul_assign(&g.z); // 1/z^3\n            g.y.mul_assign(&z); // y/z^3\n            g.z = Fq::one(); // z = 1\n        }\n    }\n\n    fn double(&mut self) {\n        if self.is_zero() {\n            return;\n        }\n\n        // Other than the point at infinity, no points on E or E'\n        // can double to equal the point at infinity, as y=0 is\n        // never true for points on the curve.\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n\n        // A = X1^2\n        let mut a = self.x;\n        a.square();\n\n        // B = Y1^2\n        let mut b = self.y;\n        b.square();\n\n        // C = B^2\n        let mut c = b;\n        c.square();\n\n        // D = 2*((X1+B)2-A-C)\n        let mut d = self.x;\n        d.add_assign(&b);\n        d.square();\n        d.sub_assign(&a);\n        d.sub_assign(&c);\n        d.double();\n\n        // E = 3*A\n        let mut e = a;\n        e.double();\n        e.add_assign(&a);\n\n        // F = E^2\n        let mut f = e;\n        f.square();\n\n        // Z3 = 2*Y1*Z1\n        self.z.mul_assign(&self.y);\n        self.z.double();\n\n        // X3 = F-2*D\n        self.x = f;\n        self.x.sub_assign(&d);\n        self.x.sub_assign(&d);\n\n        // Y3 = E*(D-X3)-8*C\n        self.y = d;\n        self.y.sub_assign(&self.x);\n        self.y.mul_assign(&e);\n        c.double();\n        c.double();\n        c.double();\n        self.y.sub_assign(&c);\n    }\n\n    fn add_assign(&mut self, other: &Self) {\n        if self.is_zero() {\n            *self = *other;\n            return;\n        }\n\n        if other.is_zero() {\n            return;\n        }\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl\n\n        // Z1Z1 = Z1^2\n        let mut z1z1 = self.z;\n        z1z1.square();\n\n        // Z2Z2 = Z2^2\n        let mut z2z2 = other.z;\n        z2z2.square();\n\n        // U1 = X1*Z2Z2\n        let mut u1 = self.x;\n        u1.mul_assign(&z2z2);\n\n        // U2 = X2*Z1Z1\n        let mut u2 = other.x;\n        u2.mul_assign(&z1z1);\n\n        // S1 = Y1*Z2*Z2Z2\n        let mut s1 = self.y;\n        s1.mul_assign(&other.z);\n        s1.mul_assign(&z2z2);\n\n        // S2 = Y2*Z1*Z1Z1\n        let mut s2 = other.y;\n        s2.mul_assign(&self.z);\n        s2.mul_assign(&z1z1);\n\n        if u1 == u2 && s1 == s2 {\n            // The two points are equal, so we double.\n            self.double();\n        } else {\n            // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n\n            if u1 == u2 {\n                // The two points are equal, so we double.\n                (*self) = Self::zero();\n                return;\n            }\n\n            // H = U2-U1\n            let mut h = u2;\n            h.sub_assign(&u1);\n\n            // I = (2*H)^2\n            let mut i = h;\n            i.double();\n            i.square();\n\n            // J = H*I\n            let mut j = h;\n            j.mul_assign(&i);\n\n            // r = 2*(S2-S1)\n            let mut r = s2;\n            r.sub_assign(&s1);\n            r.double();\n\n            // V = U1*I\n            let mut v = u1;\n            v.mul_assign(&i);\n\n            // X3 = r^2 - J - 2*V\n            self.x = r;\n            self.x.square();\n            self.x.sub_assign(&j);\n            self.x.sub_assign(&v);\n            self.x.sub_assign(&v);\n\n            // Y3 = r*(V - X3) - 2*S1*J\n            self.y = v;\n            self.y.sub_assign(&self.x);\n            self.y.mul_assign(&r);\n            s1.mul_assign(&j); // S1 = S1 * J * 2\n            s1.double();\n            self.y.sub_assign(&s1);\n\n            // Z3 = ((Z1+Z2)^2 - Z1Z1 - Z2Z2)*H\n            self.z.add_assign(&other.z);\n            self.z.square();\n            self.z.sub_assign(&z1z1);\n            self.z.sub_assign(&z2z2);\n            self.z.mul_assign(&h);\n        }\n    }\n\n    fn add_assign_mixed(&mut self, other: &Self::Affine) {\n        if other.is_zero() {\n            return;\n        }\n\n        if self.is_zero() {\n            self.x = other.x;\n            self.y = other.y;\n            self.z = Fq::one();\n            return;\n        }\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-madd-2007-bl\n\n        // Z1Z1 = Z1^2\n        let mut z1z1 = self.z;\n        z1z1.square();\n\n        // U2 = X2*Z1Z1\n        let mut u2 = other.x;\n        u2.mul_assign(&z1z1);\n\n        // S2 = Y2*Z1*Z1Z1\n        let mut s2 = other.y;\n        s2.mul_assign(&self.z);\n        s2.mul_assign(&z1z1);\n\n        if self.x == u2 && self.y == s2 {\n            // The two points are equal, so we double.\n            self.double();\n        } else {\n            // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n\n            // H = U2-X1\n            let mut h = u2;\n            h.sub_assign(&self.x);\n\n            // HH = H^2\n            let mut hh = h;\n            hh.square();\n\n            // I = 4*HH\n            let mut i = hh;\n            i.double();\n            i.double();\n\n            // J = H*I\n            let mut j = h;\n            j.mul_assign(&i);\n\n            // r = 2*(S2-Y1)\n            let mut r = s2;\n            r.sub_assign(&self.y);\n            r.double();\n\n            // V = X1*I\n            let mut v = self.x;\n            v.mul_assign(&i);\n\n            // X3 = r^2 - J - 2*V\n            self.x = r;\n            self.x.square();\n            self.x.sub_assign(&j);\n            self.x.sub_assign(&v);\n            self.x.sub_assign(&v);\n\n            // Y3 = r*(V-X3)-2*Y1*J\n            j.mul_assign(&self.y); // J = 2*Y1*J\n            j.double();\n            self.y = v;\n            self.y.sub_assign(&self.x);\n            self.y.mul_assign(&r);\n            self.y.sub_assign(&j);\n\n            // Z3 = (Z1+H)^2-Z1Z1-HH\n            self.z.add_assign(&h);\n            self.z.square();\n            self.z.sub_assign(&z1z1);\n            self.z.sub_assign(&hh);\n        }\n    }\n\n    fn negate(&mut self) {\n        if !self.is_zero() {\n            self.y.negate()\n        }\n    }\n\n    fn mul_assign<S: Into<<Self::Scalar as PrimeField>::Repr>>(&mut self, other: S) {\n        let mut res = Self::zero();\n\n        let mut found_one = false;\n\n        for i in BitIterator::new(other.into()) {\n            if found_one {\n                res.double();\n            } else {\n                found_one = i;\n            }\n\n            if i {\n                res.add_assign(self);\n            }\n        }\n\n        *self = res;\n    }\n\n    fn into_affine(&self) -> PointAffine {\n        (*self).into()\n    }\n\n    fn recommended_wnaf_for_scalar(scalar: <Self::Scalar as PrimeField>::Repr) -> usize {\n        Self::empirical_recommended_wnaf_for_scalar(scalar)\n    }\n\n    fn recommended_wnaf_for_num_scalars(num_scalars: usize) -> usize {\n        Self::empirical_recommended_wnaf_for_num_scalars(num_scalars)\n    }\n\n    fn as_xyz(&self) -> (&Self::Base, &Self::Base, &Self::Base) {\n        (&self.x, &self.y, &self.z)\n    }\n\n    fn into_xyz_unchecked(self) -> (Self::Base, Self::Base, Self::Base) {\n        (self.x, self.y, self.z)\n    }\n\n    fn from_xyz_unchecked(x: Self::Base, y: Self::Base, z: Self::Base) -> Self {\n        Self { x, y, z }\n    }\n\n    fn from_xyz_checked(\n        _x: Self::Base,\n        _y: Self::Base,\n        _z: Self::Base,\n    ) -> Result<Self, GroupDecodingError> {\n        unimplemented!()\n    }\n}\n\n// The affine point X, Y is represented in the jacobian\n// coordinates with Z = 1.\nimpl From<PointAffine> for PointProjective {\n    fn from(p: PointAffine) -> PointProjective {\n        if p.is_zero() {\n            PointProjective::zero()\n        } else {\n            PointProjective {\n                x: p.x,\n                y: p.y,\n                z: Fq::one(),\n            }\n        }\n    }\n}\n\n// The projective point X, Y, Z is represented in the affine\n// coordinates as X/Z^2, Y/Z^3.\nimpl From<PointProjective> for PointAffine {\n    fn from(p: PointProjective) -> PointAffine {\n        if p.is_zero() {\n            PointAffine::zero()\n        } else if p.z == Fq::one() {\n            // If Z is one, the point is already normalized.\n            PointAffine {\n                x: p.x,\n                y: p.y,\n                infinity: false,\n            }\n        } else {\n            // Z is nonzero, so it must have an inverse in a field.\n            let zinv = p.z.inverse().unwrap();\n            let mut zinv_powered = zinv;\n            zinv_powered.square();\n\n            // X/Z^2\n            let mut x = p.x;\n            x.mul_assign(&zinv_powered);\n\n            // Y/Z^3\n            let mut y = p.y;\n            zinv_powered.mul_assign(&zinv);\n            y.mul_assign(&zinv_powered);\n\n            PointAffine {\n                x: x,\n                y: y,\n                infinity: false,\n            }\n        }\n    }\n}\n\nimpl rand::Rand for PointProjective {\n    fn rand<R: rand::Rng>(rng: &mut R) -> Self {\n        loop {\n            let x = rng.gen();\n            let greatest = rng.gen();\n\n            if let Some(p) = PointAffine::get_point_from_x(x, greatest) {\n                if !p.is_zero() {\n                    if p.is_on_curve() {\n                        return p.into_projective();\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl rand::Rand for PointAffine {\n    fn rand<R: rand::Rng>(rng: &mut R) -> Self {\n        loop {\n            let x = rng.gen();\n            let greatest = rng.gen();\n\n            if let Some(p) = PointAffine::get_point_from_x(x, greatest) {\n                if !p.is_zero() {\n                    if p.is_on_curve() {\n                        return p;\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl PointAffine {\n    fn get_coeff_b() -> <Self as GenericCurveAffine>::Base {\n        Fq::from_str(\"7\").unwrap()\n    }\n\n    fn get_generator() -> Self {\n        Self {\n            x: crate::ff::from_hex::<Fq>(\n                \"0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\",\n            )\n            .unwrap(),\n            y: crate::ff::from_hex::<Fq>(\n                \"0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\",\n            )\n            .unwrap(),\n            infinity: false,\n        }\n    }\n}\n\nimpl PointProjective {\n    fn empirical_recommended_wnaf_for_scalar(scalar: FrRepr) -> usize {\n        let num_bits = scalar.num_bits() as usize;\n\n        if num_bits >= 130 {\n            4\n        } else if num_bits >= 34 {\n            3\n        } else {\n            2\n        }\n    }\n\n    fn empirical_recommended_wnaf_for_num_scalars(num_scalars: usize) -> usize {\n        const RECOMMENDATIONS: [usize; 12] =\n            [1, 3, 7, 20, 43, 120, 273, 563, 1630, 3128, 7933, 62569];\n\n        let mut ret = 4;\n        for r in &RECOMMENDATIONS {\n            if num_scalars > *r {\n                ret += 1;\n            } else {\n                break;\n            }\n        }\n\n        ret\n    }\n}\n\nimpl GenericUncompressedEncodable<64> for PointAffine {\n    /// Converts this element into its uncompressed encoding, so long as it's not\n    /// the point at infinity.\n    fn into_uncompressed(&self) -> EncodingBytes<Self, 64> {\n        todo!()\n    }\n\n    /// Converts an uncompressed encoding into the curve point\n    fn from_uncompressed(_encoding: EncodingBytes<Self, 64>) -> Result<Self, GroupDecodingError> {\n        todo!()\n    }\n}\n\nimpl GenericCompressedEncodable<32> for PointAffine {\n    /// Converts this element into its uncompressed encoding, so long as it's not\n    /// the point at infinity.\n    fn into_compressed(&self) -> (EncodingBytes<Self, 32>, bool) {\n        todo!();\n    }\n\n    /// Converts an uncompressed encoding into the curve point\n    fn from_compressed(\n        _encoding: EncodingBytes<Self, 32>,\n        _parity: bool,\n    ) -> Result<Self, GroupDecodingError> {\n        todo!()\n    }\n}"
    }
  ]
}