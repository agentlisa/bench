{
  "Title": "An inverted price is used for overflow validation during the creation of new limit orders",
  "Content": "##### Description\nIn function `core.LimitOrderManagement.addOrRemoveLimitOrder` the price used to evaluate whether the parameter `amountToBuy` is prone to overflow or does not appear to be inverted:\nhttps://github.com/cryptoalgebra/Algebra/blob/bddd6487c86e0d6afef39638159dc403a91ba433/src/core/contracts/libraries/LimitOrderManagement.sol#L46-L48\n```solidity\nuint256 amountToBuy = (tick > currentTick)\n  ? FullMath.mulDivRoundingUp(_amountToSell, Constants.Q144, priceX144)\n  : FullMath.mulDivRoundingUp(_amountToSell, priceX144, Constants.Q144);\n```\nPrice is represented as the ratio `token1/token0`. In the specified expression, if `tick` is greater than `currentTick`, then the new limit order position will sell `token0` in exchange for `token1`. Accordingly, to calculate the `amountToBuy`, `_amountToSell` , it should be multiplied by `priceX144` instead of being divided.\n##### Recommendation\nWe recommend inverting the specified expression.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/contracts/libraries/LimitOrderManagement.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.17;\n\nimport '../interfaces/IAlgebraPoolErrors.sol';\nimport './FullMath.sol';\nimport './LiquidityMath.sol';\nimport './Constants.sol';\nimport './TickMath.sol';\n\n/// @title LimitOrderManagement\n/// @notice Contains functions for managing limit orders and relevant calculations\nlibrary LimitOrderManagement {\n  struct LimitOrder {\n    uint128 amountToSell;\n    uint128 soldAmount;\n    uint256 boughtAmount0Cumulative;\n    uint256 boughtAmount1Cumulative;\n    bool initialized;\n  }\n\n  /// @notice Updates a limit order state and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n  /// @param self The mapping containing limit order cumulatives for initialized ticks\n  /// @param tick The tick that will be updated\n  /// @param currentTick The current tick in pool\n  /// @param amount The amount of liquidity that will be added/removed\n  /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n  function addOrRemoveLimitOrder(\n    mapping(int24 => LimitOrder) storage self,\n    int24 tick,\n    int24 currentTick,\n    int128 amount\n  ) internal returns (bool flipped) {\n    if (tick >= Constants.MAX_LIMIT_ORDER_TICK || tick < -Constants.MAX_LIMIT_ORDER_TICK) revert IAlgebraPoolErrors.invalidTickForLimitOrder();\n\n    LimitOrder storage data = self[tick];\n    uint128 _amountToSell = data.amountToSell;\n\n    unchecked {\n      flipped = _amountToSell == 0; // calculate 'flipped' for amount > 0 case\n      _amountToSell = LiquidityMath.addDelta(_amountToSell, amount);\n      if (amount > 0) {\n        // check if a limit order can be closed at all\n        uint256 tickSqrtPrice = TickMath.getSqrtRatioAtTick(tick);\n        // MAX_LIMIT_ORDER_TICK check guarantees that this value does not overflow\n        uint256 priceX144 = FullMath.mulDiv(tickSqrtPrice, tickSqrtPrice, Constants.Q48);\n        uint256 amountToBuy = (tick > currentTick)\n          ? FullMath.mulDivRoundingUp(_amountToSell, Constants.Q144, priceX144)\n          : FullMath.mulDivRoundingUp(_amountToSell, priceX144, Constants.Q144);\n        if (amountToBuy > Constants.Q128 >> 1) revert IAlgebraPoolErrors.invalidAmountForLimitOrder();\n      } else {\n        flipped = _amountToSell == 0; // override 'flipped' value\n        if (flipped) data.soldAmount = 0; // reset filled amount if all orders are closed\n      }\n      data.amountToSell = _amountToSell;\n    }\n  }\n\n  /// @notice Adds/removes liquidity to tick with partly executed limit order\n  /// @param self The mapping containing limit order cumulatives for initialized ticks\n  /// @param tick The tick that will be updated\n  /// @param amount The amount of liquidity that will be added/removed\n  function addVirtualLiquidity(mapping(int24 => LimitOrder) storage self, int24 tick, int128 amount) internal {\n    LimitOrder storage data = self[tick];\n    if (amount > 0) {\n      data.amountToSell += uint128(amount);\n      data.soldAmount += uint128(amount);\n    } else {\n      data.amountToSell -= uint128(-amount);\n      data.soldAmount -= uint128(-amount);\n    }\n  }\n\n  /// @notice Executes a limit order on the specified tick\n  /// @param self The mapping containing limit order cumulatives for initialized ticks\n  /// @param tick Limit order execution tick\n  /// @param tickSqrtPrice Limit order execution price\n  /// @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\n  /// @param amountA Amount of tokens that will be swapped\n  /// @param fee The fee taken from the input amount, expressed in hundredths of a bip\n  /// @return closed Status of limit order after execution\n  /// @return amountOut Amount of token that user receive after swap\n  /// @return amountIn Amount of token that user need to pay\n  function executeLimitOrders(\n    mapping(int24 => LimitOrder) storage self,\n    int24 tick,\n    uint160 tickSqrtPrice,\n    bool zeroToOne,\n    int256 amountA,\n    uint16 fee\n  ) internal returns (bool closed, uint256 amountOut, uint256 amountIn, uint256 feeAmount) {\n    unchecked {\n      bool exactIn = amountA > 0;\n      if (!exactIn) amountA = -amountA;\n      if (amountA < 0) revert IAlgebraPoolErrors.invalidAmountRequired(); // in case of type(int256).min\n\n      // price is defined as \"token1/token0\"\n      // MAX_LIMIT_ORDER_TICK check guarantees that this value does not overflow\n      uint256 priceX144 = FullMath.mulDiv(tickSqrtPrice, tickSqrtPrice, Constants.Q48);\n\n      uint256 amountB = (zeroToOne == exactIn)\n        ? FullMath.mulDiv(uint256(amountA), priceX144, Constants.Q144) // tokenA is token0\n        : FullMath.mulDiv(uint256(amountA), Constants.Q144, priceX144); // tokenA is token1\n\n      // limit orders buy tokenIn and sell tokenOut\n      (amountOut, amountIn) = exactIn ? (amountB, uint256(amountA)) : (uint256(amountA), amountB);\n\n      LimitOrder storage data = self[tick];\n      (uint128 amountToSell, uint128 soldAmount) = (data.amountToSell, data.soldAmount);\n      uint256 unsoldAmount = amountToSell - soldAmount; // safe since soldAmount always < amountToSell\n\n      if (exactIn) {\n        amountOut = FullMath.mulDiv(amountOut, Constants.FEE_DENOMINATOR - fee, Constants.FEE_DENOMINATOR);\n      }\n\n      if (amountOut >= unsoldAmount) {\n        if (amountOut > unsoldAmount) {\n          amountOut = unsoldAmount;\n        }\n        (closed, data.amountToSell, data.soldAmount) = (true, 0, 0);\n      } else {\n        // overflow is desired since we do not support tokens with totalSupply > type(uint128).max\n        data.soldAmount = soldAmount + uint128(amountOut);\n      }\n\n      amountIn = zeroToOne\n        ? FullMath.mulDivRoundingUp(amountOut, Constants.Q144, priceX144)\n        : FullMath.mulDivRoundingUp(amountOut, priceX144, Constants.Q144);\n\n      if (exactIn) {\n        if (amountOut == unsoldAmount) {\n          feeAmount = FullMath.mulDivRoundingUp(amountIn, fee, Constants.FEE_DENOMINATOR);\n        } else {\n          feeAmount = uint256(amountA) - amountIn;\n        }\n      } else {\n        feeAmount = FullMath.mulDivRoundingUp(amountIn, fee, Constants.FEE_DENOMINATOR - fee);\n      }\n\n      // overflows are desired since there are relative accumulators\n      if (zeroToOne) {\n        data.boughtAmount0Cumulative += FullMath.mulDiv(amountIn, Constants.Q128, amountToSell);\n      } else {\n        data.boughtAmount1Cumulative += FullMath.mulDiv(amountIn, Constants.Q128, amountToSell);\n      }\n    }\n  }\n}"
    }
  ]
}