{
  "Title": "Missing validations",
  "Content": "There are some places in the code base that might benefit from some sanity checks on the input provided:\n\n\n* The [`transferGovernor`](https://github.com/compound-finance/comet/blob/0f1221967149115f50a09681eea9580879ee7720/contracts/Configurator.sol#L289) and [`setGovernor`](https://github.com/compound-finance/comet/blob/0f1221967149115f50a09681eea9580879ee7720/contracts/Configurator.sol#L74) functions of the `Configurator` are not checking the address to be non-zero.\n* The [`CometRewards`](https://github.com/compound-finance/comet/blob/0f1221967149115f50a09681eea9580879ee7720/contracts/CometRewards.sol#L39) constructor is missing the same check over the address parameter.\n* In [line 260](https://github.com/compound-finance/comet/blob/0f1221967149115f50a09681eea9580879ee7720/contracts/Comet.sol#L260) of the `Comet` contract, the `priceFeed` is set but is not checked to retrieve a valid price.\n* [`withdrawAndBorrowAmount`](https://github.com/compound-finance/comet/blob/0f1221967149115f50a09681eea9580879ee7720/contracts/Comet.sol#L672) and [`repayAndSupplyAmount`](https://github.com/compound-finance/comet/blob/0f1221967149115f50a09681eea9580879ee7720/contracts/Comet.sol#L658) functions assume certain values over the `newPrincipal` but those should be required instead.\n\n\nTo reduce possible errors and make the code more rodust, consider adding sanity checks where needed.\n\n\n**Update**: *Partially fixed in [PR 455](https://github.com/compound-finance/comet/pull/455), merged commit [bf20ccf](https://github.com/compound-finance/comet/commit/bf20ccfa991578de670fcb5d6f3ae2362ebc6aa0). `withdrawAndBorrowAmount` and `repayAndSupplyAmount` have new validations but the rest of the items will not be fixed. In the words of the team: “There are arbitrarily many bad addresses which can be set, checking for the zero address seems like added complexity for little gain. In addition, while further checks in Comet.sol could be added, the contract is being optimized for efficiency and is up against a size limit, so we favor the current approach”.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Configurator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./CometFactory.sol\";\nimport \"./CometConfiguration.sol\";\nimport \"./ConfiguratorStorage.sol\";\n\ncontract Configurator is ConfiguratorStorage {\n\n    /** Custom events **/\n\n    event AddAsset(AssetConfig assetConfig);\n    event CometDeployed(address newComet);\n    event GovernorTransferred(address oldGovernor, address newGovernor);\n    event SetFactory(address oldFactory, address newFactory);\n    event SetGovernor(address oldGovernor, address newGovernor);\n    event SetPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n    event SetBaseTokenPriceFeed(address oldBaseTokenPriceFeed, address newBaseTokenPriceFeed);\n    event SetExtensionDelegate(address oldExt, address newExt);\n    event SetKink(uint64 oldKink, uint64 newKink);\n    event SetPerYearInterestRateSlopeLow(uint64 oldIRSlopeLow, uint64 newIRSlopeLow);\n    event SetPerYearInterestRateSlopeHigh(uint64 oldIRSlopeHigh, uint64 newIRSlopeHigh);\n    event SetPerYearInterestRateBase(uint64 oldIRBase, uint64 newIRBase);\n    event SetReserveRate(uint64 oldReserveRate, uint64 newReserveRate);\n    event SetStoreFrontPriceFactor(uint64 oldStoreFrontPriceFactor, uint64 newStoreFrontPriceFactor);\n    event SetBaseTrackingSupplySpeed(uint64 oldBaseTrackingSupplySpeed, uint64 newBaseTrackingSupplySpeed);\n    event SetBaseTrackingBorrowSpeed(uint64 oldBaseTrackingBorrowSpeed, uint64 newBaseTrackingBorrowSpeed);\n    event SetBaseMinForRewards(uint104 oldBaseMinForRewards, uint104 newBaseMinForRewards);\n    event SetBaseBorrowMin(uint104 oldBaseBorrowMin, uint104 newBaseBorrowMin);\n    event SetTargetReserves(uint104 oldTargetReserves, uint104 newTargetReserves);\n    event UpdateAsset(AssetConfig oldAssetConfig, AssetConfig newAssetConfig);\n    event UpdateAssetPriceFeed(address indexed asset, address oldPriceFeed, address newPriceFeed);\n    event UpdateAssetBorrowCollateralFactor(address indexed asset, uint64 oldBorrowCF, uint64 newBorrowCF);\n    event UpdateAssetLiquidateCollateralFactor(address indexed asset, uint64 oldLiquidateCF, uint64 newLiquidateCF);\n    event UpdateAssetLiquidationFactor(address indexed asset, uint64 oldLiquidationFactor, uint64 newLiquidationFactor);\n    event UpdateAssetSupplyCap(address indexed asset, uint128 oldSupplyCap, uint128 newSupplyCap);\n\n    /** Custom errors **/\n\n    error AlreadyInitialized();\n    error AssetDoesNotExist();\n    error InvalidAddress();\n    error Unauthorized();\n\n    /// @notice Initializes the storage for Configurator\n    function initialize(address _governor, address _factory, Configuration calldata _config) public {\n        if (version != 0) revert AlreadyInitialized();\n        if (_governor == address(0)) revert InvalidAddress();\n        if (_factory == address(0)) revert InvalidAddress();\n\n        governor = _governor;\n        factory = _factory;\n        configuratorParams = _config;\n        version = 1;\n    }\n\n    /// @notice Sets the factory for Configurator\n    /// @dev only callable by governor\n    function setFactory(address newFactory) external {\n        if (msg.sender != governor) revert Unauthorized();\n        address oldFactory = factory;\n        factory = newFactory;\n        emit SetFactory(oldFactory, newFactory);\n    }\n\n    /** Setters for Comet-related configuration **/\n    /**\n    * The following configuration parameters do not have setters:\n    *   - BaseToken\n    *   - TrackingIndexScale\n    */\n\n    /// @dev only callable by governor\n    function setGovernor(address newGovernor) external {\n        if (msg.sender != governor) revert Unauthorized();\n        address oldGovernor = configuratorParams.governor;\n        configuratorParams.governor = newGovernor;\n        emit SetGovernor(oldGovernor, newGovernor);\n    }\n\n    /// @dev only callable by governor\n    function setPauseGuardian(address newPauseGuardian) external {\n        if (msg.sender != governor) revert Unauthorized();\n        address oldPauseGuardian = configuratorParams.pauseGuardian;\n        configuratorParams.pauseGuardian = newPauseGuardian;\n        emit SetPauseGuardian(oldPauseGuardian, newPauseGuardian);\n    }\n\n    /// @dev only callable by governor\n    function setBaseTokenPriceFeed(address newBaseTokenPriceFeed) external {\n        if (msg.sender != governor) revert Unauthorized();\n        address oldBaseTokenPriceFeed = configuratorParams.baseTokenPriceFeed;\n        configuratorParams.baseTokenPriceFeed = newBaseTokenPriceFeed;\n        emit SetBaseTokenPriceFeed(oldBaseTokenPriceFeed, newBaseTokenPriceFeed);\n    }\n\n    /// @dev only callable by governor\n    function setExtensionDelegate(address newExtensionDelegate) external {\n        if (msg.sender != governor) revert Unauthorized();\n        address oldExtensionDelegate = configuratorParams.extensionDelegate;\n        configuratorParams.extensionDelegate = newExtensionDelegate;\n        emit SetExtensionDelegate(oldExtensionDelegate, newExtensionDelegate);\n    }\n\n    /// @dev only callable by governor\n    function setKink(uint64 newKink) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint64 oldKink = configuratorParams.kink;\n        configuratorParams.kink = newKink;\n        emit SetKink(oldKink, newKink);\n    }\n\n    /// @dev only callable by governor\n    function setPerYearInterestRateSlopeLow(uint64 newSlope) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint64 oldSlope = configuratorParams.perYearInterestRateSlopeLow;\n        configuratorParams.perYearInterestRateSlopeLow = newSlope;\n        emit SetPerYearInterestRateSlopeLow(oldSlope, newSlope);\n    }\n\n    /// @dev only callable by governor\n    function setPerYearInterestRateSlopeHigh(uint64 newSlope) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint64 oldSlope = configuratorParams.perYearInterestRateSlopeHigh;\n        configuratorParams.perYearInterestRateSlopeHigh = newSlope;\n        emit SetPerYearInterestRateSlopeHigh(oldSlope, newSlope);\n    }\n\n    /// @dev only callable by governor\n    function setPerYearInterestRateBase(uint64 newBase) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint64 oldBase = configuratorParams.perYearInterestRateBase;\n        configuratorParams.perYearInterestRateBase = newBase;\n        emit SetPerYearInterestRateBase(oldBase, newBase);\n    }\n\n    /// @dev only callable by governor\n    function setReserveRate(uint64 newReserveRate) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint64 oldReserveRate = configuratorParams.reserveRate;\n        configuratorParams.reserveRate = newReserveRate;\n        emit SetReserveRate(oldReserveRate, newReserveRate);\n    }\n\n    /// @dev only callable by governor\n    function setStoreFrontPriceFactor(uint64 newStoreFrontPriceFactor) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint64 oldStoreFrontPriceFactor = configuratorParams.storeFrontPriceFactor;\n        configuratorParams.storeFrontPriceFactor = newStoreFrontPriceFactor;\n        emit SetStoreFrontPriceFactor(oldStoreFrontPriceFactor, newStoreFrontPriceFactor);\n    }\n\n    /// @dev only callable by governor\n    function setBaseTrackingSupplySpeed(uint64 newBaseTrackingSupplySpeed) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint64 oldBaseTrackingSupplySpeed = configuratorParams.baseTrackingSupplySpeed;\n        configuratorParams.baseTrackingSupplySpeed = newBaseTrackingSupplySpeed;\n        emit SetBaseTrackingSupplySpeed(oldBaseTrackingSupplySpeed, newBaseTrackingSupplySpeed);\n    }\n\n    /// @dev only callable by governor\n    function setBaseTrackingBorrowSpeed(uint64 newBaseTrackingBorrowSpeed) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint64 oldBaseTrackingBorrowSpeed = configuratorParams.baseTrackingBorrowSpeed;\n        configuratorParams.baseTrackingBorrowSpeed = newBaseTrackingBorrowSpeed;\n        emit SetBaseTrackingBorrowSpeed(oldBaseTrackingBorrowSpeed, newBaseTrackingBorrowSpeed);\n    }\n\n    /// @dev only callable by governor\n    function setBaseMinForRewards(uint104 newBaseMinForRewards) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint104 oldBaseMinForRewards = configuratorParams.baseMinForRewards;\n        configuratorParams.baseMinForRewards = newBaseMinForRewards;\n        emit SetBaseMinForRewards(oldBaseMinForRewards, newBaseMinForRewards);\n    }\n\n    /// @dev only callable by governor\n    function setBaseBorrowMin(uint104 newBaseBorrowMin) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint104 oldBaseBorrowMin = configuratorParams.baseBorrowMin;\n        configuratorParams.baseBorrowMin = newBaseBorrowMin;\n        emit SetBaseBorrowMin(oldBaseBorrowMin, newBaseBorrowMin);\n    }\n\n    /// @dev only callable by governor\n    function setTargetReserves(uint104 newTargetReserves) external {\n        if (msg.sender != governor) revert Unauthorized();\n        uint104 oldTargetReserves = configuratorParams.targetReserves;\n        configuratorParams.targetReserves = newTargetReserves;\n        emit SetTargetReserves(oldTargetReserves, newTargetReserves);\n    }\n\n    /// @dev only callable by governor\n    function addAsset(AssetConfig calldata assetConfig) external {\n        if (msg.sender != governor) revert Unauthorized();\n        configuratorParams.assetConfigs.push(assetConfig);\n        emit AddAsset(assetConfig);\n    }\n\n    /// @dev only callable by governor\n    function updateAsset(AssetConfig calldata newAssetConfig) external {\n        if (msg.sender != governor) revert Unauthorized();\n\n        uint assetIndex = getAssetIndex(newAssetConfig.asset);\n        AssetConfig memory oldAssetConfig = configuratorParams.assetConfigs[assetIndex];\n        configuratorParams.assetConfigs[assetIndex] = newAssetConfig;\n        emit UpdateAsset(oldAssetConfig, newAssetConfig);\n    }\n\n    /// @dev only callable by governor\n    function updateAssetPriceFeed(address asset, address newPriceFeed) external {\n        if (msg.sender != governor) revert Unauthorized();\n\n        uint assetIndex = getAssetIndex(asset);\n        address oldPriceFeed = configuratorParams.assetConfigs[assetIndex].priceFeed;\n        configuratorParams.assetConfigs[assetIndex].priceFeed = newPriceFeed;\n        emit UpdateAssetPriceFeed(asset, oldPriceFeed, newPriceFeed);\n    }\n\n    /// @dev only callable by governor\n    function updateAssetBorrowCollateralFactor(address asset, uint64 newBorrowCF) external {\n        if (msg.sender != governor) revert Unauthorized();\n\n        uint assetIndex = getAssetIndex(asset);\n        uint64 oldBorrowCF = configuratorParams.assetConfigs[assetIndex].borrowCollateralFactor;\n        configuratorParams.assetConfigs[assetIndex].borrowCollateralFactor = newBorrowCF;\n        emit UpdateAssetBorrowCollateralFactor(asset, oldBorrowCF, newBorrowCF);\n    }\n\n    /// @dev only callable by governor\n    function updateAssetLiquidateCollateralFactor(address asset, uint64 newLiquidateCF) external {\n        if (msg.sender != governor) revert Unauthorized();\n\n        uint assetIndex = getAssetIndex(asset);\n        uint64 oldLiquidateCF = configuratorParams.assetConfigs[assetIndex].liquidateCollateralFactor;\n        configuratorParams.assetConfigs[assetIndex].liquidateCollateralFactor = newLiquidateCF;\n        emit UpdateAssetLiquidateCollateralFactor(asset, oldLiquidateCF, newLiquidateCF);\n    }\n\n    /// @dev only callable by governor\n    function updateAssetLiquidationFactor(address asset, uint64 newLiquidationFactor) external {\n        if (msg.sender != governor) revert Unauthorized();\n\n        uint assetIndex = getAssetIndex(asset);\n        uint64 oldLiquidationFactor = configuratorParams.assetConfigs[assetIndex].liquidationFactor;\n        configuratorParams.assetConfigs[assetIndex].liquidationFactor = newLiquidationFactor;\n        emit UpdateAssetLiquidationFactor(asset, oldLiquidationFactor, newLiquidationFactor);\n    }\n\n    /// @dev only callable by governor\n    function updateAssetSupplyCap(address asset, uint128 newSupplyCap) external {\n        if (msg.sender != governor) revert Unauthorized();\n\n        uint assetIndex = getAssetIndex(asset);\n        uint128 oldSupplyCap = configuratorParams.assetConfigs[assetIndex].supplyCap;\n        configuratorParams.assetConfigs[assetIndex].supplyCap = newSupplyCap;\n        emit UpdateAssetSupplyCap(asset, oldSupplyCap, newSupplyCap);\n    }\n\n    /// @dev Determine index of asset that matches given address\n    function getAssetIndex(address asset) internal view returns (uint) {\n        AssetConfig[] memory assetConfigs = configuratorParams.assetConfigs;\n        uint numAssets = assetConfigs.length;\n        for (uint i = 0; i < numAssets; i++) {\n            if (assetConfigs[i].asset == asset) {\n                return i;\n            }\n        }\n        revert AssetDoesNotExist();\n    }\n\n    /** End of setters for Comet-related configuration **/\n\n    /// @notice Gets the configuration params\n    function getConfiguration() external view returns (Configuration memory) {\n        return configuratorParams;\n    }\n\n    /// @notice Deploy a new version of the Comet implementation.\n    /// @dev callable by anyone\n    function deploy() external returns (address) {\n        address newComet = CometFactory(factory).clone(configuratorParams);\n        emit CometDeployed(newComet);\n        return newComet;\n    }\n\n    /// @notice Transfers the governor rights to a new address\n    /// @dev only callable by governor\n    function transferGovernor(address newGovernor) external {\n        if (msg.sender != governor) revert Unauthorized();\n        address oldGovernor = governor;\n        governor = newGovernor;\n        emit GovernorTransferred(oldGovernor, newGovernor);\n    }\n}"
    },
    {
      "filename": "contracts/CometRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./CometInterface.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @title Compound's CometRewards Contract\n * @notice Hold and claim token rewards\n * @author Compound\n */\ncontract CometRewards {\n    struct RewardConfig {\n        address token;\n        uint64 rescaleFactor;\n        bool shouldUpscale;\n    }\n\n    /// @notice The governor address which controls the contract\n    address public immutable governor;\n\n    /// @notice Reward token address per Comet instance\n    mapping(address => RewardConfig) public rewardConfig;\n\n    /// @notice Rewards claimed per Comet instance and user account\n    mapping(address => mapping(address => uint)) public rewardsClaimed;\n\n    /** Custom errors **/\n\n    error InvalidUInt64(uint);\n    error NotPermitted(address);\n    error NotSupported(address);\n    error TransferOutFailed(address, uint);\n\n    /**\n     * @notice Construct a new rewards pool\n     * @param governor_ The governor who will control the contract\n     */\n    constructor(address governor_) {\n        governor = governor_;\n    }\n\n    /**\n     * @notice Set the reward token for a Comet instance\n     * @param comet The protocol instance\n     * @param token The reward token address\n     */\n    function _setRewardConfig(address comet, address token) external {\n        if (msg.sender != governor) revert NotPermitted(msg.sender);\n\n        uint64 accrualScale = CometInterface(comet).baseAccrualScale();\n        uint8 tokenDecimals = ERC20(token).decimals();\n        uint64 tokenScale = safe64(10 ** tokenDecimals);\n        if (accrualScale > tokenScale) {\n            rewardConfig[comet] = RewardConfig({\n                token: token,\n                rescaleFactor: accrualScale / tokenScale,\n                shouldUpscale: false\n            });\n        } else {\n            rewardConfig[comet] = RewardConfig({\n                token: token,\n                rescaleFactor: tokenScale / accrualScale,\n                shouldUpscale: true\n            });\n        }\n    }\n\n    /**\n     * @notice Withdraw tokens from the contract\n     * @param token The reward token address\n     * @param to Where to send the tokens\n     * @param amount The number of tokens to withdraw\n     */\n    function _withdrawToken(address token, address to, uint amount) external {\n        if (msg.sender != governor) revert NotPermitted(msg.sender);\n\n        doTransferOut(token, to, amount);\n    }\n\n    /**\n     * @notice Claim rewards of token type from a comet instance to owner address\n     * @param comet The protocol instance\n     * @param src The owner to claim for\n     * @param shouldAccrue Whether or not to call accrue first\n     */\n    function claim(address comet, address src, bool shouldAccrue) external {\n        claimInternal(comet, src, src, shouldAccrue);\n    }\n\n    /**\n     * @notice Claim rewards of token type from a comet instance to a target address\n     * @param comet The protocol instance\n     * @param src The owner to claim for\n     * @param to The address to receive the rewards\n     */\n    function claimTo(address comet, address src, address to, bool shouldAccrue) external {\n        if (!CometInterface(comet).hasPermission(src, msg.sender)) revert NotPermitted(msg.sender);\n\n        claimInternal(comet, src, to, shouldAccrue);\n    }\n\n    /**\n     * @dev Claim to, assuming permitted\n     */\n    function claimInternal(address comet, address src, address to, bool shouldAccrue) internal {\n        RewardConfig memory config = rewardConfig[comet];\n        if (config.token == address(0)) revert NotSupported(comet);\n\n        if (shouldAccrue) {\n            CometInterface(comet).accrueAccount(src);\n        }\n\n        uint claimed = rewardsClaimed[comet][src];\n        uint accrued = CometInterface(comet).baseTrackingAccrued(src);\n        if (config.shouldUpscale) {\n            accrued *= config.rescaleFactor;\n        } else {\n            accrued /= config.rescaleFactor;\n        }\n        if (accrued > claimed) {\n            uint owed = accrued - claimed;\n            rewardsClaimed[comet][src] = accrued;\n            doTransferOut(config.token, to, owed);\n        }\n    }\n\n    /**\n     * @dev Safe ERC20 transfer out\n     */\n    function doTransferOut(address token, address to, uint amount) internal {\n        bool success = ERC20(token).transfer(to, amount);\n        if (!success) revert TransferOutFailed(to, amount);\n    }\n\n    /**\n     * @dev Safe cast to uint64\n     */\n    function safe64(uint n) internal pure returns (uint64) {\n        if (n > type(uint64).max) revert InvalidUInt64(n);\n        return uint64(n);\n    }\n}"
    },
    {
      "filename": "contracts/Comet.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport \"./CometMainInterface.sol\";\nimport \"./ERC20.sol\";\nimport \"./vendor/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title Compound's Comet Contract\n * @notice An efficient monolithic money market protocol\n * @author Compound\n */\ncontract Comet is CometMainInterface {\n    /** Custom errors **/\n\n    error Absurd();\n    error AlreadyInitialized();\n    error BadAsset();\n    error BadDecimals();\n    error BadDiscount();\n    error BadKink();\n    error BadMinimum();\n    error BadPrice();\n    error BadReserveRate();\n    error BorrowTooSmall();\n    error BorrowCFTooLarge();\n    error InsufficientReserves();\n    error LiquidateCFTooLarge();\n    error NoSelfTransfer();\n    error NotCollateralized();\n    error NotForSale();\n    error NotLiquidatable();\n    error Paused();\n    error SupplyCapExceeded();\n    error TimestampTooLarge();\n    error TooManyAssets();\n    error TooMuchSlippage();\n    error TransferInFailed();\n    error TransferOutFailed();\n    error Unauthorized();\n\n    /** General configuration constants **/\n\n    /// @notice The admin of the protocol\n    address public override immutable governor;\n\n    /// @notice The account which may trigger pauses\n    address public override immutable pauseGuardian;\n\n    /// @notice The address of the base token contract\n    address public override immutable baseToken;\n\n    /// @notice The address of the price feed for the base token\n    address public override immutable baseTokenPriceFeed;\n\n    /// @notice The address of the extension contract delegate\n    address public override immutable extensionDelegate;\n\n    /// @notice The point in the supply and borrow rates separating the low interest rate slope and the high interest rate slope (factor)\n    /// @dev uint64\n    uint public override immutable kink;\n\n    /// @notice Per second interest rate slope applied when utilization is below kink (factor)\n    /// @dev uint64\n    uint public override immutable perSecondInterestRateSlopeLow;\n\n    /// @notice Per second interest rate slope applied when utilization is above kink (factor)\n    /// @dev uint64\n    uint public override immutable perSecondInterestRateSlopeHigh;\n\n    /// @notice Per second base interest rate (factor)\n    /// @dev uint64\n    uint public override immutable perSecondInterestRateBase;\n\n    /// @notice The rate of total interest paid that goes into reserves (factor)\n    /// @dev uint64\n    uint public override immutable reserveRate;\n\n    /// @notice The fraction of the liquidation penalty that goes to buyers of collateral instead of the protocol\n    /// @dev uint64\n    uint public override immutable storeFrontPriceFactor;\n\n    /// @notice The scale for base token (must be less than 18 decimals)\n    /// @dev uint64\n    uint public override immutable baseScale;\n\n    /// @notice The scale for reward tracking\n    /// @dev uint64\n    uint public override immutable trackingIndexScale;\n\n    /// @notice The speed at which supply rewards are tracked (in trackingIndexScale)\n    /// @dev uint64\n    uint public override immutable baseTrackingSupplySpeed;\n\n    /// @notice The speed at which borrow rewards are tracked (in trackingIndexScale)\n    /// @dev uint64\n    uint public override immutable baseTrackingBorrowSpeed;\n\n    /// @notice The minimum amount of base wei for rewards to accrue\n    /// @dev This must be large enough so as to prevent division by base wei from overflowing the 64 bit indices\n    /// @dev uint104\n    uint public override immutable baseMinForRewards;\n\n    /// @notice The minimum base amount required to initiate a borrow\n    /// @dev uint104\n    uint public override immutable baseBorrowMin;\n\n    /// @notice The minimum base token reserves which must be held before collateral is hodled\n    /// @dev uint104\n    uint public override immutable targetReserves;\n\n    /// @notice The number of decimals for wrapped base token\n    uint8 public override immutable decimals;\n\n    /// @notice The number of assets this contract actually supports\n    uint8 public override immutable numAssets;\n\n    /// @notice Factor to divide by when accruing rewards in order to preserve 6 decimals (i.e. baseScale / 1e6)\n    uint internal immutable accrualDescaleFactor;\n\n    /**  Collateral asset configuration (packed) **/\n\n    uint256 internal immutable asset00_a;\n    uint256 internal immutable asset00_b;\n    uint256 internal immutable asset01_a;\n    uint256 internal immutable asset01_b;\n    uint256 internal immutable asset02_a;\n    uint256 internal immutable asset02_b;\n    uint256 internal immutable asset03_a;\n    uint256 internal immutable asset03_b;\n    uint256 internal immutable asset04_a;\n    uint256 internal immutable asset04_b;\n    uint256 internal immutable asset05_a;\n    uint256 internal immutable asset05_b;\n    uint256 internal immutable asset06_a;\n    uint256 internal immutable asset06_b;\n    uint256 internal immutable asset07_a;\n    uint256 internal immutable asset07_b;\n    uint256 internal immutable asset08_a;\n    uint256 internal immutable asset08_b;\n    uint256 internal immutable asset09_a;\n    uint256 internal immutable asset09_b;\n    uint256 internal immutable asset10_a;\n    uint256 internal immutable asset10_b;\n    uint256 internal immutable asset11_a;\n    uint256 internal immutable asset11_b;\n    uint256 internal immutable asset12_a;\n    uint256 internal immutable asset12_b;\n    uint256 internal immutable asset13_a;\n    uint256 internal immutable asset13_b;\n    uint256 internal immutable asset14_a;\n    uint256 internal immutable asset14_b;\n\n    /**\n     * @notice Construct a new protocol instance\n     * @param config The mapping of initial/constant parameters\n     **/\n    constructor(Configuration memory config) {\n        // Sanity checks\n        uint8 decimals_ = ERC20(config.baseToken).decimals();\n        if (decimals_ > MAX_BASE_DECIMALS) revert BadDecimals();\n        if (config.storeFrontPriceFactor > FACTOR_SCALE) revert BadDiscount();\n        if (config.assetConfigs.length > MAX_ASSETS) revert TooManyAssets();\n        if (config.baseMinForRewards == 0) revert BadMinimum();\n        if (AggregatorV3Interface(config.baseTokenPriceFeed).decimals() != PRICE_FEED_DECIMALS) revert BadDecimals();\n        if (config.reserveRate > FACTOR_SCALE) revert BadReserveRate();\n        if (config.kink > FACTOR_SCALE) revert BadKink();\n\n        // Copy configuration\n        unchecked {\n            governor = config.governor;\n            pauseGuardian = config.pauseGuardian;\n            baseToken = config.baseToken;\n            baseTokenPriceFeed = config.baseTokenPriceFeed;\n            extensionDelegate = config.extensionDelegate;\n            storeFrontPriceFactor = config.storeFrontPriceFactor;\n\n            decimals = decimals_;\n            baseScale = uint64(10 ** decimals_);\n            trackingIndexScale = config.trackingIndexScale;\n            if (baseScale < BASE_ACCRUAL_SCALE) revert BadDecimals();\n            accrualDescaleFactor = baseScale / BASE_ACCRUAL_SCALE;\n\n            baseMinForRewards = config.baseMinForRewards;\n            baseTrackingSupplySpeed = config.baseTrackingSupplySpeed;\n            baseTrackingBorrowSpeed = config.baseTrackingBorrowSpeed;\n\n            baseBorrowMin = config.baseBorrowMin;\n            targetReserves = config.targetReserves;\n        }\n\n        // Set interest rate model configs\n        unchecked {\n            kink = config.kink;\n            perSecondInterestRateSlopeLow = config.perYearInterestRateSlopeLow / SECONDS_PER_YEAR;\n            perSecondInterestRateSlopeHigh = config.perYearInterestRateSlopeHigh / SECONDS_PER_YEAR;\n            perSecondInterestRateBase = config.perYearInterestRateBase / SECONDS_PER_YEAR;\n            reserveRate = config.reserveRate;\n        }\n\n        // Set asset info\n        numAssets = uint8(config.assetConfigs.length);\n\n        (asset00_a, asset00_b) = _getPackedAsset(config.assetConfigs, 0);\n        (asset01_a, asset01_b) = _getPackedAsset(config.assetConfigs, 1);\n        (asset02_a, asset02_b) = _getPackedAsset(config.assetConfigs, 2);\n        (asset03_a, asset03_b) = _getPackedAsset(config.assetConfigs, 3);\n        (asset04_a, asset04_b) = _getPackedAsset(config.assetConfigs, 4);\n        (asset05_a, asset05_b) = _getPackedAsset(config.assetConfigs, 5);\n        (asset06_a, asset06_b) = _getPackedAsset(config.assetConfigs, 6);\n        (asset07_a, asset07_b) = _getPackedAsset(config.assetConfigs, 7);\n        (asset08_a, asset08_b) = _getPackedAsset(config.assetConfigs, 8);\n        (asset09_a, asset09_b) = _getPackedAsset(config.assetConfigs, 9);\n        (asset10_a, asset10_b) = _getPackedAsset(config.assetConfigs, 10);\n        (asset11_a, asset11_b) = _getPackedAsset(config.assetConfigs, 11);\n        (asset12_a, asset12_b) = _getPackedAsset(config.assetConfigs, 12);\n        (asset13_a, asset13_b) = _getPackedAsset(config.assetConfigs, 13);\n        (asset14_a, asset14_b) = _getPackedAsset(config.assetConfigs, 14);\n    }\n\n    /**\n     * @notice Initialize storage for the contract\n     * @dev Can be used from constructor or proxy\n     */\n    function initializeStorage() override external {\n        if (lastAccrualTime != 0) revert AlreadyInitialized();\n\n        // Initialize aggregates\n        lastAccrualTime = getNowInternal();\n        baseSupplyIndex = BASE_INDEX_SCALE;\n        baseBorrowIndex = BASE_INDEX_SCALE;\n\n        // Implicit initialization (not worth increasing contract size)\n        // trackingSupplyIndex = 0;\n        // trackingBorrowIndex = 0;\n    }\n\n    /**\n     * @dev Checks and gets the packed asset info for storage\n     */\n    function _getPackedAsset(AssetConfig[] memory assetConfigs, uint i) internal view returns (uint256, uint256) {\n        AssetConfig memory assetConfig;\n        if (i < assetConfigs.length) {\n            assembly {\n                assetConfig := mload(add(add(assetConfigs, 0x20), mul(i, 0x20)))\n            }\n        } else {\n            return (0, 0);\n        }\n        address asset = assetConfig.asset;\n        address priceFeed = assetConfig.priceFeed;\n        uint8 decimals_ = assetConfig.decimals;\n\n        // Short-circuit if asset is nil\n        if (asset == address(0)) {\n            return (0, 0);\n        }\n\n        // Sanity check price feed and asset decimals\n        if (AggregatorV3Interface(priceFeed).decimals() != PRICE_FEED_DECIMALS) revert BadDecimals();\n        if (ERC20(asset).decimals() != decimals_) revert BadDecimals();\n\n        // Ensure collateral factors are within range\n        if (assetConfig.borrowCollateralFactor >= assetConfig.liquidateCollateralFactor) revert BorrowCFTooLarge();\n        if (assetConfig.liquidateCollateralFactor > MAX_COLLATERAL_FACTOR) revert LiquidateCFTooLarge();\n\n        unchecked {\n            // Keep 4 decimals for each factor\n            uint descale = FACTOR_SCALE / 1e4;\n            uint16 borrowCollateralFactor = uint16(assetConfig.borrowCollateralFactor / descale);\n            uint16 liquidateCollateralFactor = uint16(assetConfig.liquidateCollateralFactor / descale);\n            uint16 liquidationFactor = uint16(assetConfig.liquidationFactor / descale);\n\n            // Be nice and check descaled values are still within range\n            if (borrowCollateralFactor >= liquidateCollateralFactor) revert BorrowCFTooLarge();\n\n            // Keep whole units of asset for supply cap\n            uint64 supplyCap = uint64(assetConfig.supplyCap / (10 ** decimals_));\n\n            uint256 word_a = (uint160(asset) << 0 |\n                              uint256(borrowCollateralFactor) << 160 |\n                              uint256(liquidateCollateralFactor) << 176 |\n                              uint256(liquidationFactor) << 192);\n            uint256 word_b = (uint160(priceFeed) << 0 |\n                              uint256(decimals_) << 160 |\n                              uint256(supplyCap) << 168);\n\n            return (word_a, word_b);\n        }\n    }\n\n    /**\n     * @notice Get the i-th asset info, according to the order they were passed in originally\n     * @param i The index of the asset info to get\n     * @return The asset info object\n     */\n    function getAssetInfo(uint8 i) override public view returns (AssetInfo memory) {\n        if (i >= numAssets) revert BadAsset();\n\n        uint256 word_a;\n        uint256 word_b;\n\n        if (i == 0) {\n            word_a = asset00_a;\n            word_b = asset00_b;\n        } else if (i == 1) {\n            word_a = asset01_a;\n            word_b = asset01_b;\n        } else if (i == 2) {\n            word_a = asset02_a;\n            word_b = asset02_b;\n        } else if (i == 3) {\n            word_a = asset03_a;\n            word_b = asset03_b;\n        } else if (i == 4) {\n            word_a = asset04_a;\n            word_b = asset04_b;\n        } else if (i == 5) {\n            word_a = asset05_a;\n            word_b = asset05_b;\n        } else if (i == 6) {\n            word_a = asset06_a;\n            word_b = asset06_b;\n        } else if (i == 7) {\n            word_a = asset07_a;\n            word_b = asset07_b;\n        } else if (i == 8) {\n            word_a = asset08_a;\n            word_b = asset08_b;\n        } else if (i == 9) {\n            word_a = asset09_a;\n            word_b = asset09_b;\n        } else if (i == 10) {\n            word_a = asset10_a;\n            word_b = asset10_b;\n        } else if (i == 11) {\n            word_a = asset11_a;\n            word_b = asset11_b;\n        } else if (i == 12) {\n            word_a = asset12_a;\n            word_b = asset12_b;\n        } else if (i == 13) {\n            word_a = asset13_a;\n            word_b = asset13_b;\n        } else if (i == 14) {\n            word_a = asset14_a;\n            word_b = asset14_b;\n        } else {\n            revert Absurd();\n        }\n\n        address asset = address(uint160(word_a & type(uint160).max));\n        uint rescale = FACTOR_SCALE / 1e4;\n        uint64 borrowCollateralFactor = uint64(((word_a >> 160) & type(uint16).max) * rescale);\n        uint64 liquidateCollateralFactor = uint64(((word_a >> 176) & type(uint16).max) * rescale);\n        uint64 liquidationFactor = uint64(((word_a >> 192) & type(uint16).max) * rescale);\n\n        address priceFeed = address(uint160(word"
    }
  ]
}