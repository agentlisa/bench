{
  "Title": "[M-04] AutoPxGmx.maxWithdraw and AutoPxGlp.maxWithdraw functions calculate asset amount that is too big and cannot be withdrawn",
  "Content": "\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332>\n\n### Impact\n\nThe ERC-4626 Tokenized Vault Standard requires the `maxWithdraw` function to be implemented (<https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/#maxwithdraw>).\n\nThis function is supposed to return \"the maximum amount of underlying assets that can be withdrawn from the owner balance with a single withdraw call\".\n\nThe `PirexERC4626` contract implements this function (<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L225>).\\\nIt is implemented correctly when `PirexERC4626` is used on its own.\n\nHowever in this project, the `PirexERC4626` contract is not used on its own but inherited by `AutoPxGmx` (<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L14>) and `AutoPxGlp` (<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L14>).\n\n`AutoPxGmx` and `AutoPxGlp` implement a `withdrawalPenalty` i.e. a fee that is paid when a user wants to withdraw assets from the vault.\n\n`AutoPxGmx` and `AutoPxGlp` do not override the `maxWithdraw` function.\n\nThis causes the `maxWithdraw` function to return an amount of assets that is too big to be withdrawn.\n\nSo when `maxWithdraw` is called and with the returned amount `withdraw` is called, the call to `withdraw` will revert.\n\nThis can cause issues in any upstream components that rely on `AutoPxGmx` and `AutoPxGlp` to correctly implement the ERC4626 standard.\n\nFor example an upstream wrapper might only allow withdrawals with the maximum amount and determine this maximum amount by calling the `maxWithdraw` function. As this function returns a value that is too big, no withdrawals will be possible.\n\n### Proof of Concept\n\n1.  The `maxWithdraw` function in a `AutoPxGmx` contract is called\n2.  Now the `withdraw` function is called with the value that was returned by the `maxWithdraw` function (<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315>)\n3.  The `withdraw` function in turn calls the `previewWithdraw` function (<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199>)\n4.  The `previewWithdraw` function will increase the amount of shares to include the `withdrawalPenalty` (<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L215-L216>) which causes the amount of shares to burn to be too large and the call to `burn` will revert (<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L332>)\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nIn the `AutoPxGmx` and `AutoPxGlp` function, implement the `maxWithdraw` function that overrides the function in `PirexERC4626` and takes into account the `withdrawalPenalty`.\n\nPotential fix:\n\n```solidity\nfunction maxWithdraw(address owner) public view override returns (uint256) {\n    uint256 shares = balanceOf(owner);\n\n    // Calculate assets based on a user's % ownership of vault shares\n    uint256 assets = convertToAssets(shares);\n\n    uint256 _totalSupply = totalSupply;\n\n    // Calculate a penalty - zero if user is the last to withdraw\n    uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n        ? 0\n        : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n    // Redeemable amount is the post-penalty amount\n    return assets - penalty;\n}\n```\n\n**[drahrealm (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/97)** \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "src/vaults/PirexERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/**\n    @notice Pirex modifications\n            - Add beforeDeposit method\n            - Call beforeDeposit in deposit and mint methods\n            - Add afterWithdraw method\n            - Call afterWithdraw in redeem and withdraw methods\n            - Add afterTransfer method\n            - Call afterTransfer in transfer and transferFrom methods\n */\nabstract contract PirexERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /**\n        @notice Override transfer method to allow for pre-transfer internal hook\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        bool status = ERC20.transfer(to, amount);\n\n        afterTransfer(msg.sender, to, amount);\n\n        return status;\n    }\n\n    /**\n        @notice Override transferFrom method to allow for pre-transfer internal hook\n        @param  from    address  Account sending apxGLP\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        bool status = ERC20.transferFrom(from, to, amount);\n\n        afterTransfer(from, to, amount);\n\n        return status;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function beforeDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    {
      "filename": "src/vaults/AutoPxGmx.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\nimport {IV3SwapRouter} from \"src/interfaces/IV3SwapRouter.sol\";\n\ncontract AutoPxGmx is ReentrancyGuard, Owned, PirexERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    IV3SwapRouter public constant SWAP_ROUTER =\n        IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n\n    // Uniswap pool fee\n    uint24 public poolFee = 3000;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    ERC20 public immutable gmxBaseReward;\n    ERC20 public immutable gmx;\n\n    event PoolFeeUpdated(uint24 _poolFee);\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 gmxBaseRewardAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error AlreadySet();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _gmx            address  GMX token contract address\n        @param  _asset          address  Asset address (e.g. pxGMX)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGMX)\n        @param  _symbol         string   Asset symbol (e.g. apxGMX)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _gmx,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max);\n        gmx.safeApprove(_platform, type(uint256).max);\n    }\n\n    /**\n        @notice Set the Uniswap pool fee\n        @param  _poolFee  uint24  Uniswap pool fee\n     */\n    function setPoolFee(uint24 _poolFee) external onlyOwner {\n        if (_poolFee == 0) revert ZeroAmount();\n\n        poolFee = _poolFee;\n\n        emit PoolFeeUpdated(_poolFee);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGMX custodied by the AutoPxGmx contract\n        @return uint256  Amount of pxGMX custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares  uint256  Shares\n        @return uint256  Assets\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets  uint256  Assets\n        @return uint256  Shares\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGMX rewards before depositing\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(poolFee, 1, 0, true);\n    }\n\n    /**\n        @notice Compound pxGMX rewards\n        @param  fee                    uint24   Uniswap pool tier fee\n        @param  amountOutMinimum       uint256  Outbound token swap amount\n        @param  sqrtPriceLimitX96      uint160  Swap price impact limit (optional)\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  GMX base reward inbound swap amount\n        @return gmxAmountOut           uint256  GMX outbound swap amount\n        @return pxGmxMintAmount        uint256  pxGMX minted when depositing GMX\n        @return totalFee               uint256  Total platform fee\n        @return incentive              uint256  Compound incentive\n     */\n    function compound(\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        )\n    {\n        if (fee == 0) revert InvalidParam();\n        if (amountOutMinimum == 0) revert InvalidParam();\n\n        uint256 assetsBeforeClaim = asset.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n\n        // Swap entire reward balance for GMX\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            gmxAmountOut = SWAP_ROUTER.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: address(gmxBaseReward),\n                    tokenOut: address(gmx),\n                    fee: fee,\n                    recipient: address(this),\n                    amountIn: gmxBaseRewardAmountIn,\n                    amountOutMinimum: amountOutMinimum,\n                    sqrtPriceLimitX96: sqrtPriceLimitX96\n                })\n            );\n\n            // Deposit entire GMX balance for pxGMX, increasing the asset/share amount\n            (, pxGmxMintAmount, ) = PirexGmx(platform).depositGmx(\n                gmx.balanceOf(address(this)),\n                address(this)\n            );\n        }\n\n        // Only distribute fees if the amount of vault assets increased\n        if ((totalAssets() - assetsBeforeClaim) != 0) {\n            totalFee =\n                ((asset.balanceOf(address(this)) - assetsBeforeClaim) *\n                    platformFee) /\n                FEE_DENOMINATOR;\n            incentive = optOutIncentive\n                ? 0\n                : (totalFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (incentive != 0) asset.safeTransfer(msg.sender, incentive);\n\n            asset.safeTransfer(owner, totalFee - incentive);\n        }\n\n        emit Compounded(\n            msg.sender,\n            fee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            gmxBaseRewardAmountIn,\n            gmxAmountOut,\n            pxGmxMintAmount,\n            totalFee,\n            incentive\n        );\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n        compound(poolFee, 1, 0, true);\n\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        // Compound rewards and ensure they are properly accounted for prior to redemption calculation\n        compound(poolFee, 1, 0, true);\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /**\n        @notice Deposit GMX for apxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  apxGMX receiver\n        @return shares    uint256  Vault shares (i.e. apxGMX)\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256 shares)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Handle compounding of rewards before deposit (arguments are not used by `beforeDeposit` hook)\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // Intake sender GMX\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Convert sender GMX into pxGMX and get the post-fee amount (i.e. assets)\n        (, uint256 assets, ) = PirexGmx(platform).depositGmx(\n            amount,\n            address(this)\n        );\n\n        // NOTE: Modified `convertToShares` logic to consider assets already being in the vault\n        // and handle it by deducting the recently-deposited assets from the total\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n}"
    },
    {
      "filename": "src/vaults/AutoPxGlp.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmx"
    }
  ]
}