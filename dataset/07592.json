{
  "Title": "[L-03] Owner can renounce Ownership",
  "Content": "\n[Turnstile.sol#L4](https://github.com/code-423n4/2022-11-canto/blob/main/CIP-001/src/Turnstile.sol#L4)\n\nTypically, the contract’s owner is the account that deploys the contract. As a result, the owner is able to perform certain privileged activities.\n\nThe Openzeppelin’s Ownable used in this project contract implements renounceOwnership. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\n\n`onlyOwner` functions:\n```js\n\nCanto/contracts/turnstile.sol:\n  146  \n  147:     /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n  148:     /// @param _tokenId NFT that earned fees\n  149:     function distributeFees(uint256 _tokenId) public onlyOwner payable {\n  150          if (msg.value == 0) revert NothingToDistribute();\n\n```\n\n### Recommended Mitigation Steps\n\nWe recommend either reimplementing the function to disable it or to clearly specify if it is part of the contract design.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-canto",
  "Code": [
    {
      "filename": "CIP-001/src/Turnstile.sol",
      "content": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.8.17;\n\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"openzeppelin/utils/Counters.sol\";\n\n/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md\n/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.\n///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.\n///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.\ncontract Turnstile is Ownable, ERC721Enumerable {\n    using Counters for Counters.Counter;\n\n    struct NftData {\n        uint256 tokenId;\n        bool registered;\n    }\n\n    Counters.Counter private _tokenIdTracker;\n\n    /// @notice maps smart contract address to tokenId\n    mapping(address => NftData) public feeRecipient;\n\n    /// @notice maps tokenId to fees earned\n    mapping(uint256 => uint256) public balances;\n\n    event Register(address smartContract, address recipient, uint256 tokenId);\n    event Assign(address smartContract, uint256 tokenId);\n    event Withdraw(uint256 tokenId, address recipient, uint256 feeAmount);\n    event DistributeFees(uint256 tokenId, uint256 feeAmount);\n\n    error NotAnOwner();\n    error AlreadyRegistered();\n    error Unregistered();\n    error InvalidRecipient();\n    error InvalidTokenId();\n    error NothingToWithdraw();\n    error NothingToDistribute();\n\n    /// @dev only owner of _tokenId can call this function\n    modifier onlyNftOwner(uint256 _tokenId) {\n        if (ownerOf(_tokenId) != msg.sender) revert NotAnOwner();\n\n        _;\n    }\n\n    /// @dev only smart contract that is unregistered can call this function\n    modifier onlyUnregistered() {\n        address smartContract = msg.sender;\n\n        if (isRegistered(smartContract)) revert AlreadyRegistered();\n\n        _;\n    }\n\n    constructor() ERC721(\"Turnstile\", \"Turnstile\") {}\n\n    /// @notice Returns current value of counter used to tokenId of new minted NFTs\n    /// @return current counter value\n    function currentCounterId() external view returns (uint256) {\n        return _tokenIdTracker.current();\n    }\n\n    /// @notice Returns tokenId that collects fees generated by the smart contract\n    /// @param _smartContract address of the smart contract\n    /// @return tokenId that collects fees generated by the smart contract\n    function getTokenId(address _smartContract) external view returns (uint256) {\n        if (!isRegistered(_smartContract)) revert Unregistered();\n\n        return feeRecipient[_smartContract].tokenId;\n    }\n\n    /// @notice Returns true if smart contract is registered to collect fees\n    /// @param _smartContract address of the smart contract\n    /// @return true if smart contract is registered to collect fees, false otherwise\n    function isRegistered(address _smartContract) public view returns (bool) {\n        return feeRecipient[_smartContract].registered;\n    }\n\n    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.\n    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself\n    ///         can register a fee receipient.\n    /// @param _recipient recipient of the ownership NFT\n    /// @return tokenId of the ownership NFT that collects fees\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n\n    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.\n    ///         Callable only by smart contract itself.\n    /// @param _tokenId tokenId which will collect fees\n    /// @return tokenId of the ownership NFT that collects fees\n    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {\n        address smartContract = msg.sender;\n\n        if (!_exists(_tokenId)) revert InvalidTokenId();\n\n        emit Assign(smartContract, _tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: _tokenId,\n            registered: true\n        });\n\n        return _tokenId;\n    }\n\n    /// @notice Withdraws earned fees to `_recipient` address. Only callable by NFT owner.\n    /// @param _tokenId token Id\n    /// @param _recipient recipient of fees\n    /// @param _amount amount of fees to withdraw\n    /// @return amount of fees withdrawn\n    function withdraw(uint256 _tokenId, address payable _recipient, uint256 _amount)\n        public\n        onlyNftOwner(_tokenId)\n        returns (uint256)\n    {\n        uint256 earnedFees = balances[_tokenId];\n\n        if (earnedFees == 0 || _amount == 0) revert NothingToWithdraw();\n        if (_amount > earnedFees) _amount = earnedFees;\n\n        balances[_tokenId] = earnedFees - _amount;\n\n        emit Withdraw(_tokenId, _recipient, _amount);\n\n        Address.sendValue(_recipient, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n    /// @param _tokenId NFT that earned fees\n    function distributeFees(uint256 _tokenId) public onlyOwner payable {\n        if (msg.value == 0) revert NothingToDistribute();\n\n        balances[_tokenId] += msg.value;\n        emit DistributeFees(_tokenId, msg.value);\n    }\n}"
    }
  ]
}