{
  "Title": "Missing documentation",
  "Content": "Several functions within the codebase have missing or incomplete documentation:\n\n\nIn PR [#4110](https://github.com/UMAprotocol/protocol/pull/4110):\n\n\n* The [`_stakeTo`](https://github.com/UMAprotocol/protocol/blob/f94bc66a55fc1ad3ab63fca829d711373f9a953a/packages/core/contracts/oracle/implementation/Staker.sol#L131) function in the [`Staker`](https://github.com/UMAprotocol/protocol/blob/f94bc66a55fc1ad3ab63fca829d711373f9a953a/packages/core/contracts/oracle/implementation/Staker.sol) contract has no docstring\n\n\nIn PR [#4118](https://github.com/UMAprotocol/protocol/pull/4118):\n\n\n* The [`_previousVotingContract`](https://github.com/UMAprotocol/protocol/blob/6f3692e24c2e9d8681ca1f4a0cb1eac2c2022c06/packages/core/contracts/oracle/implementation/VotingV2.sol#L263) parameter has no corresponding @param line in the [`VotingV2`](https://github.com/UMAprotocol/protocol/blob/6f3692e24c2e9d8681ca1f4a0cb1eac2c2022c06/packages/core/contracts/oracle/implementation/VotingV2.sol) constructor docstring\n* The [`_getPriceFromPreviousVotingContract`](https://github.com/UMAprotocol/protocol/blob/6f3692e24c2e9d8681ca1f4a0cb1eac2c2022c06/packages/core/contracts/oracle/implementation/VotingV2.sol#L1158) function in [`VotingV2`](https://github.com/UMAprotocol/protocol/blob/6f3692e24c2e9d8681ca1f4a0cb1eac2c2022c06/packages/core/contracts/oracle/implementation/VotingV2.sol) has no docstring\n\n\nIn PR [#4128](https://github.com/UMAprotocol/protocol/pull/4128):\n\n\n* The [`emergencyPropose`](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/EmergencyProposer.sol#L110) function in [`EmergencyProposer`](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/EmergencyProposer.sol) [returns a value](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/EmergencyProposer.sol#L121) but its docstring has no corresponding @return line\n\n\nIn PR [#4135](https://github.com/UMAprotocol/protocol/pull/4135):\n\n\n* The [`getCurrentTime`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol#L39) function in [`VotingV2Test`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol) has no docstring\n* The [`commitVote`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol#L43) function in [`VotingV2Test`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol) lost its docstring when it was relocated from `VotingV2.sol`\n* The [`revealVote`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol#L51) function in [`VotingV2Test`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol) lost its docstring when it was relocated from `VotingV2.sol`\n* The [`commitAndEmitEncryptedVote`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol#L60) function in [`VotingV2Test`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol) lost its docstring when it was relocated from `VotingV2.sol`\n* The [`getPendingPriceRequestsArray`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol#L69) function in [`VotingV2Test`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol) has no docstring\n* The [`getPriceRequestStatuses`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol#L73) function in [`VotingV2Test`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/test/VotingV2Test.sol) lost its docstring when it was relocated from `VotingV2.sol`\n* The [`retrieveRewardsOnMigratedVotingContract`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/VotingV2.sol#L1036) function in [`VotingV2`](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/VotingV2.sol) [returns a value](https://github.com/UMAprotocol/protocol/blob/28beb7e0e339aafe4bf19435e5fa70a342e34375/packages/core/contracts/oracle/implementation/VotingV2.sol#L1045) but its docstring has no corresponding @return line\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions that implement sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec). Also consider providing explanatory comments for all events, structs, and storage variables that indicate their intended purpose.\n\n\n**Update:** *Partially fixed as of commit [`e729b6ba86529598326ec80083cdfbaf8541b94c`](https://github.com/UMAprotocol/protocol/pull/4155/commits/e729b6ba86529598326ec80083cdfbaf8541b94c) in [PR #4155](https://github.com/UMAprotocol/protocol/pull/4155). UMA’s statement:*\n\n\n\n> *It has been decided not to add docstring in the test contracts as this is not done through the rest of the repo.*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/Staker.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../interfaces/StakerInterface.sol\";\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\n\nimport \"./VotingToken.sol\";\nimport \"../../common/implementation/Lockable.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title Staking contract enabling UMA to be locked up by stakers to earn a pro rata share of a fixed emission rate.\n * @dev Handles the staking, unstaking and reward retrieval logic.\n */\nabstract contract Staker is StakerInterface, Ownable, Lockable {\n    /****************************************\n     *           STAKING TRACKERS           *\n     ****************************************/\n\n    uint256 public emissionRate;\n    uint256 public cumulativeActiveStake;\n    uint256 public cumulativePendingStake;\n    uint256 public rewardPerTokenStored;\n    uint64 public lastUpdateTime;\n    uint64 public unstakeCoolDown;\n\n    ExpandedIERC20 public votingToken;\n\n    struct VoterStake {\n        uint256 activeStake;\n        uint256 pendingUnstake;\n        uint256 pendingStake;\n        uint256 rewardsPaidPerToken;\n        uint256 outstandingRewards;\n        int256 unappliedSlash;\n        uint64 nextIndexToProcess;\n        uint64 unstakeRequestTime;\n        address delegate;\n    }\n\n    mapping(address => VoterStake) public voterStakes;\n    mapping(address => address) public delegateToStaker;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event Staked(\n        address indexed voter,\n        address indexed from,\n        uint256 amount,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 voterPendingUnstake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event RequestedUnstake(\n        address indexed voter,\n        uint256 amount,\n        uint256 unstakeTime,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event ExecutedUnstake(\n        address indexed voter,\n        uint256 tokensSent,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event WithdrawnRewards(address indexed voter, address indexed delegate, uint256 tokensWithdrawn);\n\n    event UpdatedReward(address indexed voter, uint256 newReward, uint256 lastUpdateTime);\n\n    event UpdatedActiveStake(\n        address indexed voter,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event SetNewEmissionRate(uint256 newEmissionRate);\n\n    event SetNewUnstakeCoolDown(uint256 newUnstakeCoolDown);\n\n    /**\n     * @notice Construct the Staker contract\n     * @param _emissionRate amount of voting tokens that are emitted per second, split pro rata to stakers.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     */\n    constructor(\n        uint256 _emissionRate,\n        uint64 _unstakeCoolDown,\n        address _votingToken\n    ) {\n        emissionRate = _emissionRate;\n        unstakeCoolDown = _unstakeCoolDown;\n        votingToken = ExpandedIERC20(_votingToken);\n    }\n\n    /****************************************\n     *           STAKER FUNCTIONS           *\n     ****************************************/\n\n    /**\n     * @notice Pulls tokens from users wallet and stakes them. If we are in an active reveal phase the stake amount will\n     * be added to the pending stake. If not, the stake amount will be added to the active stake.\n     * @param amount the amount of tokens to stake.\n     */\n    function stake(uint256 amount) public {\n        _stakeTo(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Pulls tokens from sender wallet and stakes them for the recipient. If we are in an active reveal phase the\n     * stake amount will be added to the pending stake. If not, the stake amount will be added to the active stake.\n     * @param recipient the recipient address.\n     * @param amount the amount of tokens to stake.\n     */\n    function stakeTo(address recipient, uint256 amount) public {\n        _stakeTo(msg.sender, recipient, amount);\n    }\n\n    function _stakeTo(\n        address from,\n        address recipient,\n        uint256 amount\n    ) internal {\n        VoterStake storage voterStake = voterStakes[recipient];\n\n        // If the staker has a cumulative staked balance of 0 then we can shortcut their lastRequestIndexConsidered to\n        // the most recent index. This means we don't need to traverse requests where the staker was not staked.\n        // _getStartingIndexForStaker returns the appropriate index to start at.\n        if (getVoterStake(recipient) + voterStake.pendingUnstake == 0)\n            voterStake.nextIndexToProcess = _getStartingIndexForStaker();\n        _updateTrackers(recipient);\n\n        if (_inActiveReveal()) {\n            voterStake.pendingStake += amount;\n            cumulativePendingStake += amount;\n        } else {\n            voterStake.activeStake += amount;\n            cumulativeActiveStake += amount;\n        }\n        // Tokens are pulled from the \"from\" address and sent to this contract.\n        // During withdrawAndRestake, \"from\" is the same as the address of this contract, so there is no need to transfer.\n        if (from != address(this)) votingToken.transferFrom(from, address(this), amount);\n        emit Staked(\n            recipient,\n            from,\n            amount,\n            voterStake.activeStake,\n            voterStake.pendingStake,\n            voterStake.pendingUnstake,\n            cumulativeActiveStake,\n            cumulativePendingStake\n        );\n    }\n\n    /**\n     * @notice Request a certain number of tokens to be unstaked. After the unstake time expires, the user may execute\n     * the unstake. Tokens requested to unstake are not slashable nor subject to earning rewards.\n     * This function cannot be called during an active reveal phase.\n     * Note that there is no way to cancel an unstake request, you must wait until after unstakeRequestTime and re-stake.\n     * @param amount the amount of tokens to request to be unstaked.\n     */\n    function requestUnstake(uint256 amount) external override nonReentrant() {\n        require(!_inActiveReveal(), \"In an active reveal phase\");\n        _updateTrackers(msg.sender);\n        VoterStake storage voterStake = voterStakes[msg.sender];\n\n        require(voterStake.activeStake >= amount, \"Bad request amount\");\n        require(voterStake.pendingUnstake == 0, \"Have previous request unstake\");\n\n        cumulativeActiveStake -= amount;\n        voterStake.pendingUnstake = amount;\n        voterStake.activeStake -= amount;\n        voterStake.unstakeRequestTime = SafeCast.toUint64(getCurrentTime());\n\n        emit RequestedUnstake(\n            msg.sender,\n            amount,\n            voterStake.unstakeRequestTime,\n            voterStake.activeStake,\n            voterStake.pendingStake\n        );\n    }\n\n    /**\n     * @notice  Execute a previously requested unstake. Requires the unstake time to have passed.\n     * @dev If a staker requested an unstake and time > unstakeRequestTime then send funds to staker.\n     */\n    function executeUnstake() external override nonReentrant() {\n        VoterStake storage voterStake = voterStakes[msg.sender];\n        require(\n            voterStake.unstakeRequestTime != 0 && getCurrentTime() >= voterStake.unstakeRequestTime + unstakeCoolDown,\n            \"Unstake time not passed\"\n        );\n        uint256 tokensToSend = voterStake.pendingUnstake;\n\n        if (tokensToSend > 0) {\n            voterStake.pendingUnstake = 0;\n            voterStake.unstakeRequestTime = 0;\n            votingToken.transfer(msg.sender, tokensToSend);\n        }\n\n        emit ExecutedUnstake(msg.sender, tokensToSend, voterStake.activeStake, voterStake.pendingStake);\n    }\n\n    /**\n     * @notice Send accumulated rewards to the voter. Note that these rewards do not include slashing balance changes.\n     * @return uint256 the amount of tokens sent to the voter.\n     */\n    function withdrawRewards() public returns (uint256) {\n        return _withdrawRewards(msg.sender, msg.sender);\n    }\n\n    function _withdrawRewards(address voter, address recipient) internal returns (uint256) {\n        _updateTrackers(voter);\n        VoterStake storage voterStake = voterStakes[voter];\n\n        uint256 tokensToMint = voterStake.outstandingRewards;\n        if (tokensToMint > 0) {\n            voterStake.outstandingRewards = 0;\n            require(votingToken.mint(recipient, tokensToMint), \"Voting token issuance failed\");\n            emit WithdrawnRewards(voter, msg.sender, tokensToMint);\n        }\n        return tokensToMint;\n    }\n\n    /**\n     * @notice Stake accumulated rewards. This is merely a convenience mechanism that combines the voter's withdrawal and stake\n     *  in the same transaction if requested by a delegate or the voter.\n     * @dev This method requires that the msg.sender(voter or delegate) has approved this contract.\n     * @dev The rewarded tokens simply pass through this contract before being staked on the voter's behalf.\n     *  The balance of the delegate remains unchanged.\n     * @return uint256 the amount of tokens that the voter is staking.\n     */\n    function withdrawAndRestake() external override returns (uint256) {\n        address voter = getVoterFromDelegate(msg.sender);\n        uint256 rewards = _withdrawRewards(voter, address(this));\n        _stakeTo(address(this), voter, rewards);\n        return rewards;\n    }\n\n    /**\n     * @notice Sets the delegate of a voter. This delegate can vote on behalf of the staker. The staker will still own\n     * all staked balances, receive rewards and be slashed based on the actions of the delegate. Intended use is using a\n     * low-security available wallet for voting while keeping access to staked amounts secure by a more secure wallet.\n     * @param delegate the address of the delegate.\n     */\n    function setDelegate(address delegate) external nonReentrant() {\n        voterStakes[msg.sender].delegate = delegate;\n    }\n\n    /**\n     * @notice Sets the delegator of a voter. Acts to accept a delegation. The delegate can only vote for the delegator\n     * if the delegator also selected the delegate to do so (two-way relationship needed).\n     * @param delegator the address of the delegator.\n     */\n    function setDelegator(address delegator) external nonReentrant() {\n        delegateToStaker[msg.sender] = delegator;\n    }\n\n    /****************************************\n     *        OWNER ADMIN FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice  Set the token's emission rate, the number of voting tokens that are emitted per second per staked token,\n     * split pro rata to stakers.\n     * @param newEmissionRate the new amount of voting tokens that are emitted per second, split pro rata to stakers.\n     */\n    function setEmissionRate(uint256 newEmissionRate) external onlyOwner {\n        _updateReward(address(0));\n        emissionRate = newEmissionRate;\n        emit SetNewEmissionRate(newEmissionRate);\n    }\n\n    /**\n     * @notice  Set the amount of time a voter must wait to unstake after submitting a request to do so.\n     * @param newUnstakeCoolDown the new duration of the cool down period in seconds.\n     */\n    function setUnstakeCoolDown(uint64 newUnstakeCoolDown) external onlyOwner {\n        unstakeCoolDown = newUnstakeCoolDown;\n        emit SetNewUnstakeCoolDown(newUnstakeCoolDown);\n    }\n\n    function _updateTrackers(address voterAddress) internal virtual {\n        _updateReward(voterAddress);\n        _updateActiveStake(voterAddress);\n    }\n\n    /****************************************\n     *            VIEW FUNCTIONS            *\n     ****************************************/\n\n    /**\n     * @notice Gets the voter from the delegate.\n     * @param caller caller of the function or the address to check in the mapping between a voter and their delegate.\n     * @return address voter that corresponds to the delegate.\n     */\n    function getVoterFromDelegate(address caller) public view returns (address) {\n        if (\n            delegateToStaker[caller] != address(0) && // The delegate chose to be a delegate for the staker.\n            voterStakes[delegateToStaker[caller]].delegate == caller // The staker chose the delegate.\n        ) return delegateToStaker[caller];\n        else return caller;\n    }\n\n    /**\n     * @notice  Determine the number of outstanding token rewards that can be withdrawn by a voter.\n     * @param voterAddress the address of the voter.\n     * @return uint256 the outstanding rewards.\n     */\n    function outstandingRewards(address voterAddress) public view returns (uint256) {\n        VoterStake storage voterStake = voterStakes[voterAddress];\n\n        return\n            ((getVoterStake(voterAddress) * (rewardPerToken() - voterStake.rewardsPaidPerToken)) / 1e18) +\n            voterStake.outstandingRewards;\n    }\n\n    /**\n     * @notice  Calculate the reward per token based on the last time the reward was updated.\n     * @return uint256 the reward per token.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (getCumulativeStake() == 0) return rewardPerTokenStored;\n        return\n            rewardPerTokenStored + ((getCurrentTime() - lastUpdateTime) * emissionRate * 1e18) / getCumulativeStake();\n    }\n\n    /**\n     * @notice  Returns the total amount of tokens staked. This is the sum of the active stake and the pending stake.\n     * @return uint256 the cumulative stake.\n     */\n    function getCumulativeStake() public view returns (uint256) {\n        return cumulativeActiveStake + cumulativePendingStake;\n    }\n\n    /**\n     * @notice  Returns the total amount of tokens staked by the voter.\n     * @param voterAddress the address of the voter.\n     * @return uint256 the total stake.\n     */\n    function getVoterStake(address voterAddress) public view returns (uint256) {\n        return voterStakes[voterAddress].activeStake + voterStakes[voterAddress].pendingStake;\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /****************************************\n     *          INTERNAL FUNCTIONS          *\n     ****************************************/\n\n    // Determine if we are in an active reveal phase. This function should be overridden by the child contract.\n    function _inActiveReveal() internal view virtual returns (bool) {\n        return false;\n    }\n\n    function _getStartingIndexForStaker() internal view virtual returns (uint64) {\n        return 0;\n    }\n\n    // Calculate the reward per token based on last time the reward was updated.\n    function _updateReward(address voterAddress) internal {\n        uint256 newRewardPerToken = rewardPerToken();\n        rewardPerTokenStored = newRewardPerToken;\n        lastUpdateTime = SafeCast.toUint64(getCurrentTime());\n        if (voterAddress != address(0)) {\n            VoterStake storage voterStake = voterStakes[voterAddress];\n            voterStake.outstandingRewards = outstandingRewards(voterAddress);\n            voterStake.rewardsPaidPerToken = newRewardPerToken;\n        }\n        emit UpdatedReward(voterAddress, newRewardPerToken, lastUpdateTime);\n    }\n\n    // Updates the active stake of the voter if not in an active reveal phase.\n    function _updateActiveStake(address voterAddress) internal {\n        if (voterStakes[voterAddress].pendingStake == 0 || _inActiveReveal()) return;\n        cumulativeActiveStake += voterStakes[voterAddress].pendingStake;\n        cumulativePendingStake -= voterStakes[voterAddress].pendingStake;\n        voterStakes[voterAddress].activeStake += voterStakes[voterAddress].pendingStake;\n        voterStakes[voterAddress].pendingStake = 0;\n\n        emit UpdatedActiveStake(\n            voterAddress,\n            voterStakes[voterAddress].activeStake,\n            voterStakes[voterAddress].pendingStake,\n            cumulativeActiveStake,\n            cumulativePendingStake\n        );\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/implementation/VotingV2.sol",
      "content": "// TODO: this whole /oracle/implementation directory should be restructured to separate the DVM and the OO.\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"../../common/implementation/MultiCaller.sol\";\n\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"../interfaces/OracleGovernanceInterface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"../interfaces/VotingV2Interface.sol\";\nimport \"../interfaces/RegistryInterface.sol\";\nimport \"./Constants.sol\";\nimport \"./ResultComputationV2.sol\";\nimport \"./SlashingLibrary.sol\";\nimport \"./SpamGuardIdentifierLib.sol\";\nimport \"./Staker.sol\";\nimport \"./VoteTimingV2.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title VotingV2 contract for the UMA DVM.\n * @dev Handles receiving and resolving price requests via a commit-reveal voting schelling scheme.\n */\n\ncontract VotingV2 is\n    Staker,\n    OracleInterface,\n    OracleAncillaryInterface,\n    OracleGovernanceInterface,\n    VotingV2Interface,\n    MultiCaller\n{\n    using VoteTimingV2 for VoteTimingV2.Data;\n    using ResultComputationV2 for ResultComputationV2.Data;\n\n    /****************************************\n     *        VOTING DATA STRUCTURES        *\n     ****************************************/\n\n    // Identifies a unique price request. Tracks ongoing votes as well as the result of the vote.\n    struct PriceRequest {\n        // If in the past, this was the voting round where this price was resolved. If current or the upcoming round,\n        // this is the voting round where this price will be voted on, but not necessarily resolved.\n        uint32 lastVotingRound;\n        // Denotes whether this is a governance request or not.\n        bool isGovernance;\n        // The pendingRequestIndex in the pendingPriceRequests that references this PriceRequest. A value of UINT64_MAX\n        // means that this PriceRequest is resolved and has been cleaned up from pendingPriceRequests.\n        uint64 pendingRequestIndex;\n        // Each request has a unique requestIndex number that is used to order all requests. This is the index within\n        // the priceRequestIds array and is incremented on each request.\n        uint64 priceRequestIndex;\n        // Timestamp that should be used when evaluating the request.\n        // Note: this is a uint64 to allow better variable packing while still leaving more than ample room for\n        // timestamps to stretch far into the future.\n        uint64 time;\n        // Identifier that defines how the voters should resolve the request.\n        bytes32 identifier;\n        // A map containing all votes for this price in various rounds.\n        mapping(uint256 => VoteInstance) voteInstances;\n        // Additional data used to resolve the request.\n        bytes ancillaryData;\n    }\n\n    struct VoteInstance {\n        mapping(address => VoteSubmission) voteSubmissions; // Maps (voterAddress) to their submission.\n        ResultComputationV2.Data resultComputation; // The data structure containing the computed voting results.\n    }\n\n    struct VoteSubmission {\n        bytes32 commit; // A bytes32 of 0 indicates no commit or a commit that was already revealed.\n        bytes32 revealHash; // The hash of the value that was revealed. This is only used for computation of rewards.\n    }\n\n    struct Round {\n        uint256 gat; // GAT is the required number of tokens to vote to not roll the vote.\n        uint256 cumulativeActiveStakeAtRound; // Total staked tokens at the start of the round.\n    }\n\n    // Represents the status a price request has.\n    enum RequestStatus {\n        NotRequested, // Was never requested.\n        Active, // Is being voted on in the current round.\n        Resolved, // Was resolved in a previous round.\n        Future // Is scheduled to be voted on in a future round.\n    }\n\n    // Only used as a return value in view methods -- never stored in the contract.\n    struct RequestState {\n        RequestStatus status;\n        uint256 lastVotingRound;\n    }\n\n    /****************************************\n     *          INTERNAL TRACKING           *\n     ****************************************/\n\n    // Maps round numbers to the rounds.\n    mapping(uint256 => Round) public rounds;\n\n    // Maps price request IDs to the PriceRequest struct.\n    mapping(bytes32 => PriceRequest) public priceRequests;\n\n    bytes32[] public priceRequestIds;\n\n    mapping(uint64 => uint64) public skippedRequestIndexes;\n\n    // Price request ids for price requests that haven't yet been resolved. These requests may be for future rounds.\n    bytes32[] public pendingPriceRequests;\n\n    VoteTimingV2.Data public voteTiming;\n\n    // Number of tokens that must participate to resolve a vote.\n    uint256 public gat;\n\n    // Reference to the Finder.\n    FinderInterface public immutable finder;\n\n    // Reference to Slashing Library.\n    SlashingLibrary public slashingLibrary;\n\n    // If non-zero, this contract has been migrated to this address.\n    address public migratedAddress;\n\n    // If non-zero, this is the previous voting contract, deployed before this one. Used to facilitate retrieval of\n    // previous price requests from DVM deployments before this one.\n    OracleAncillaryInterface public immutable previousVotingContract;\n\n    // Max value of an unsigned integer.\n    uint64 private constant UINT64_MAX = type(uint64).max;\n\n    // Max length in bytes of ancillary data that can be appended to a price request.\n    uint256 public constant ANCILLARY_BYTES_LIMIT = 8192;\n\n    /****************************************\n     *          SLASHING TRACKERS           *\n     ****************************************/\n\n    // Only used as a return value in view methods -- never stored in the contract.\n    struct SlashingTracker {\n        uint256 wrongVoteSlashPerToken;\n        uint256 noVoteSlashPerToken;\n        uint256 totalSlashed;\n        uint256 totalCorrectVotes;\n    }\n\n    /****************************************\n     *        SPAM DELETION TRACKERS        *\n     ****************************************/\n\n    uint256 public spamDeletionProposalBond;\n\n    struct SpamDeletionRequest {\n        uint256[2][] spamRequestIndices;\n        uint256 requestTime;\n        bool executed;\n        address proposer;\n        uint256 bond;\n    }\n\n    SpamDeletionRequest[] public spamDeletionProposals;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event VoteCommitted(\n        address indexed voter,\n        address indexed caller,\n        uint256 roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData\n    );\n\n    event EncryptedVote(\n        address indexed caller,\n        uint256 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData,\n        bytes encryptedVote\n    );\n\n    event VoteRevealed(\n        address indexed voter,\n        address indexed caller,\n        uint256 roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        int256 price,\n        bytes ancillaryData,\n        uint256 numTokens\n    );\n\n    event PriceRequestAdded(\n        address indexed requester,\n        uint256 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        uint256 requestIndex,\n        bytes ancillaryData,\n        bool isGovernance\n    );\n\n    event PriceResolved(\n        uint256 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        uint256 requestIndex,\n        int256 price,\n        bytes ancillaryData\n    );\n\n    event VotingContractMigrated(address newAddress);\n\n    event GatChanged(uint256 newGat);\n\n    event SlashingLibraryChanged(address newAddress);\n\n    event SpamDeletionProposalBondChanged(uint256 newBond);\n\n    event VoterSlashed(address indexed voter, int256 slashedTokens, uint256 postActiveStake);\n\n    event SignaledRequestsAsSpamForDeletion(\n        uint256 indexed proposalId,\n        address indexed sender,\n        uint256[2][] spamRequestIndices\n    );\n\n    event ExecutedSpamDeletion(uint256 indexed proposalId, bool indexed executed);\n\n    /**\n     * @notice Construct the VotingV2 contract.\n     * @param _emissionRate amount of voting tokens that are emitted per second, split prorate between stakers.\n     * @param _spamDeletionProposalBond amount of voting tokens that are required to propose a spam deletion.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     * @param _phaseLength length of the voting phases in seconds.\n     * @param _minRollToNextRoundLength time before the end of a round in which a request must be made for the request\n     *  to be voted on in the next round. If after this, the request is rolled to a round after the next round.\n     * @param _startingRequestIndex offset index to increment the first index in the priceRequestIds array.\n     * @param _gat number of tokens that must participate to resolve a vote.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     * @param _finder keeps track of all contracts within the system based on their interfaceName.\n     * Must be set to 0x0 for production environments that use live time.\n     * @param _slashingLibrary contract used to calculate voting slashing penalties based on voter participation.\n     */\n    constructor(\n        uint256 _emissionRate,\n        uint256 _spamDeletionProposalBond,\n        uint64 _unstakeCoolDown,\n        uint64 _phaseLength,\n        uint64 _minRollToNextRoundLength,\n        uint256 _gat,\n        uint64 _startingRequestIndex,\n        address _votingToken,\n        address _finder,\n        address _slashingLibrary,\n        address _previousVotingContract\n    ) Staker(_emissionRate, _unstakeCoolDown, _votingToken) {\n        voteTiming.init(_phaseLength, _minRollToNextRoundLength);\n        require(_gat < IERC20(_votingToken).totalSupply() && _gat > 0);\n        gat = _gat;\n        finder = FinderInterface(_finder);\n        slashingLibrary = SlashingLibrary(_slashingLibrary);\n        previousVotingContract = OracleAncillaryInterface(_previousVotingContract);\n        setSpamDeletionProposalBond(_spamDeletionProposalBond);\n\n        // We assume indices never get above 2^64. So we should never start with an index above half that range.\n        require(_startingRequestIndex < type(uint64).max / 2);\n\n        assembly {\n            sstore(priceRequestIds.slot, _startingRequestIndex)\n        }\n    }\n\n    /***************************************\n                    MODIFIERS\n    ****************************************/\n\n    modifier onlyRegisteredContract() {\n        _requireRegisteredContract();\n        _;\n    }\n\n    modifier onlyIfNotMigrated() {\n        _requireNotMigrated();\n        _;\n    }\n\n    /****************************************\n     *  PRICE REQUEST AND ACCESS FUNCTIONS  *\n     ****************************************/\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the identifier, time pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data\n     * is limited such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override nonReentrant() onlyIfNotMigrated() onlyRegisteredContract() {\n        _requestPrice(identifier, time, ancillaryData, false);\n    }\n\n    /**\n     * @notice Enqueues a governance action request (if a request isn't already present) for identifier, time pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data\n     * is limited such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n    function requestGovernanceAction(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) external override onlyOwner() {\n        _requestPrice(identifier, time, ancillaryData, true);\n    }\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the given identifier, time pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data is limited\n     * such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param isGovernance indicates whether the request is for a governance action.\n     */\n    function _requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bool isGovernance\n    ) internal {\n        uint256 blockTime = getCurrentTime();\n        require(time <= blockTime, \"Can only request in past\");\n        require(\n            isGovernance || _getIdentifierWhitelist().isIdentifierSupported(identifier),\n            \"Unsupported identifier request\"\n        );\n        require(ancillaryData.length <= ANCILLARY_BYTES_LIMIT, \"Invalid ancillary data\");\n\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\n\n        // Price has never been requested.\n        if (requestStatus == RequestStatus.NotRequested) {\n            // If the price request is a governance action then always place it in the following round. If the price\n            // request is a normal request then either place it in the next round or the following round based off\n            // the minRollToNextRoundLength. This limits when a request must be made for it to occur in the next round.\n            uint256 roundIdToVoteOnPriceRequest =\n                isGovernance ? currentRoundId + 1 : voteTiming.computeRoundToVoteOnPriceRequest(blockTime);\n            PriceRequest storage newPriceRequest = priceRequests[priceRequestId];\n            newPriceRequest.identifier = identifier;\n            newPriceRequest.time = SafeCast.toUint64(time);\n            newPriceRequest.lastVotingRound = SafeCast.toUint32(roundIdToVoteOnPriceRequest);\n            newPriceRequest.pendingRequestIndex = SafeCast.toUint64(pendingPriceRequests.length);\n            newPriceRequest.priceRequestIndex = SafeCast.toUint64(priceRequestIds.length);\n            newPriceRequest.ancillaryData = ancillaryData;\n            if (isGovernance) newPriceRequest.isGovernance = isGovernance;\n\n            pendingPriceRequests.push(priceRequestId);\n            priceRequestIds.push(priceRequestId);\n\n            emit PriceRequestAdded(\n                msg.sender,\n                roundIdToVoteOnPriceRequest,\n                identifier,\n                time,\n                newPriceRequest.priceRequestIndex,\n                ancillaryData,\n                isGovernance\n            );\n        }\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function requestPrice(bytes32 identifier, uint256 time) external override {\n        requestPri"
    }
  ]
}