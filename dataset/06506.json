{
  "Title": "[G-16] Use hardcode address instead of `address(this)`",
  "Content": "\nIt can be more gas-efficient to use a hardcoded address instead of the `address(this)` expression, especially if you need to use the same address multiple times in your contract.\n\nThe reason for this, is that using `address(this)` requires an additional `EXTCODESIZE` operation to retrieve the contract's address from its bytecode, which can increase the gas cost of your contract. By pre-calculating and using a hardcoded address, you can avoid this additional operation and reduce the overall gas cost of your contract.\n\nHere's an example of how you can use a hardcoded address instead of `address(this)`:\n\n```\ncontract MyContract {\n    address public myAddress = 0x1234567890123456789012345678901234567890;\n    \n    function doSomething() public {\n        // Use myAddress instead of address(this)\n        require(msg.sender == myAddress, \"Caller is not authorized\");\n        \n        // Do something\n    }\n}\n```\n\nIn the above example, we have a contract (MyContract) with a public address variable `myAddress`. Instead of using `address(this)` to retrieve the contract's address, we have pre-calculated and hardcoded the address in the variable. This can help to reduce the gas cost of our contract and make our code more efficient.\n\n[References](https://book.getfoundry.sh/reference/forge-std/compute-create-address)\n\n<details>\n\n```solidity\nFile:   src/maia/tokens/ERC4626PartnerManager.sol\n162      return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n\n168      return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n\n219      if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) \n\n226      address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))\n\n244      ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/maia/tokens/ERC4626PartnerManager.sol#L162\n\n```solidity\nFile:  src/maia/PartnerUtilityManager.sol\n75     if (partnerVault != address(0) && address(gaugeWeight).balanceOf(address(this)) > 0)\n\n85     if (partnerVault != address(0) && address(gaugeBoost).balanceOf(address(this)) > 0) \n\n95     if (partnerVault != address(0) && address(governance).balanceOf(address(this)) > 0) \n\n104    address(partnerGovernance).safeTransferFrom(msg.sender, address(this), amount);\n\n128    uint256 weightAvailable = address(gaugeWeight).balanceOf(address(this));\n\n139    uint256 boostAvailable = address(gaugeBoost).balanceOf(address(this));\n\n148    uint256 governanceAvailable = address(governance).balanceOf(address(this));\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/maia/PartnerUtilityManager.sol#L75\n\n```solidity\nFile:   src/talos/base/TalosBaseStrategy.sol\n125     address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n\n126     address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n146     recipient: address(this),\n\n196     address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n\n197     address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n366     recipient: address(this),\n\n406     uint256 balance0 = _token0.balanceOf(address(this));\n\n407     uint256 balance1 = _token1.balanceOf(address(this));\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L125\n\n```solidity\nFile:   src/talos/TalosStrategyStaked.sol\n90      flywheel.accrue(ERC20(address(this)), msg.sender, _to);\n\n95      flywheel.accrue(ERC20(address(this)), _from, _to);\n\n150     recipient: address(this),\n\n177     try nonfungiblePositionManager.safeTransferFrom(address(this), address(boostAggregator), _tokenId)\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L90\n\n```solidity\nFile:   src/ulysses-amm/UlyssesPool.sol\n103     return asset.balanceOf(address(this)) - getProtocolFees();\n\n108     return balanceOf[owner].min(asset.balanceOf(address(this)));\n\n127     uint256 balance = asset.balanceOf(address(this));\n\n218     asset.safeTransferFrom(msg.sender, address(this), newRebalancingFee - oldRebalancingFee);\n\n303     asset.safeTransferFrom(msg.sender, address(this), newRebalancingFee - oldRebalancingFee);\n\n1109    asset.safeTransferFrom(msg.sender, address(this), assets);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesPool.sol#L103\n\n```solidity\nFile:     src/ulysses-omnichain/BranchBridgeAgent.sol\n1020      uint256 gasRemaining = wrappedNativeToken.balanceOf(address(this));\n\n1078     IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), minExecCost);\n\n1093      IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));\n\n1103      IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), gasAmount);\n\n1325     uint256 executionBudget = anycallConfig.executionBudget(address(this));\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1020\n\n```solidity\nFile:    src/ulysses-omnichain/BranchPort.sol\n127     uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n138     uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n180     IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n249     _localAddress.safeTransferFrom(_depositor, address(this), _amount - _deposit);\n\n254     _depositor, address(this), _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())\n\n271      address(this),\n\n276      _localAddresses[i].safeTransferFrom(_depositor, address(this), _amounts[i] - _deposits[i]);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L127\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/maia/tokens/ERC4626PartnerManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {bHermes} from \"@hermes/bHermes.sol\";\nimport {bHermesVotes as ERC20MultiVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {PartnerManagerFactory} from \"../factories/PartnerManagerFactory.sol\";\nimport {IBaseVault} from \"../interfaces/IBaseVault.sol\";\nimport {PartnerUtilityManager} from \"../PartnerUtilityManager.sol\";\n\nimport {IERC4626PartnerManager} from \"../interfaces/IERC4626PartnerManager.sol\";\n\n/// @title Yield bearing, boosting, voting, and gauge enabled Partner Token\nabstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC4626, IERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         PARTNER MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    PartnerManagerFactory public immutable override factory;\n\n    /// @inheritdoc IERC4626PartnerManager\n    bHermes public immutable override bHermesToken;\n\n    /// @inheritdoc IERC4626PartnerManager\n    uint256 public override bHermesRate;\n\n    /**\n     * @notice Initializes the ERC4626PartnerManager token.\n     * @param _factory The partner manager factory.\n     * @param _bHermesRate The rate at which bHermes underlying's can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get partner tokens.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of this contract.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    )\n        PartnerUtilityManager(\n            address(bHermes(_bhermes).gaugeWeight()),\n            address(bHermes(_bhermes).gaugeBoost()),\n            address(bHermes(_bhermes).governance()),\n            address(new ERC20MultiVotes(_owner)),\n            partnerVault\n        )\n        ERC4626(\n            _partnerAsset,\n            string.concat(_name, \" - Burned Hermes: Aggregated Gov + Yield + Boost\"),\n            string.concat(_symbol, \"-bHermes\")\n        )\n    {\n        _initializeOwner(_owner);\n        partnerVault = _partnerVault;\n        factory = _factory;\n        bHermesRate = _bHermesRate;\n        bHermesToken = bHermes(_bhermes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            UTILITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function updateUnderlyingBalance() public virtual {\n        bHermesToken.claimOutstanding();\n    }\n\n    /// @inheritdoc IERC4626PartnerManager\n    function claimOutstanding() public virtual {\n        uint256 balance = balanceOf[msg.sender] * bHermesRate;\n        /// @dev Never overflows since balandeOf >= userClaimed.\n        claimWeight(balance - userClaimedWeight[msg.sender]);\n        claimBoost(balance - userClaimedBoost[msg.sender]);\n        claimGovernance(balance - userClaimedGovernance[msg.sender]);\n        claimPartnerGovernance(balance - userClaimedPartnerGovernance[msg.sender]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Compute the amount of tokens available in contract.\n    /// @dev 1:1 with underlying asset.\n    function totalAssets() public view override returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Computes and returns the amount of shares from a given amount of assets.\n     * @param assets amount of assets to convert to shares\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Computes and returns the amount of assets from a given amount of shares.\n     * @param shares amount of shares to convert to assets\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Simulates the amount of shares that the assets deposited are worth.\n     * @param assets amount of assets to simulate the deposit.\n     */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Calculates the amount of shares that the assets deposited are worth.\n     */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be withdrawn from a given amount of shares.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be redeemed from a given amount of shares.\n     * @param shares amount of shares to convert to assets.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ER4626 DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxMint(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be withdrawn by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxWithdraw(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /// @notice Returns the maximum amount of assets that can be redeemed by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxRedeem(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function migratePartnerVault(address newPartnerVault) external onlyOwner {\n        if (factory.vaultIds(IBaseVault(newPartnerVault)) == 0) revert UnrecognizedVault();\n\n        address oldPartnerVault = partnerVault;\n        if (oldPartnerVault != address(0)) IBaseVault(oldPartnerVault).clearAll();\n        bHermesToken.claimOutstanding();\n\n        address(gaugeWeight).safeApprove(oldPartnerVault, 0);\n        address(gaugeBoost).safeApprove(oldPartnerVault, 0);\n        address(governance).safeApprove(oldPartnerVault, 0);\n        address(partnerGovernance).safeApprove(oldPartnerVault, 0);\n\n        address(gaugeWeight).safeApprove(newPartnerVault, type(uint256).max);\n        address(gaugeBoost).safeApprove(newPartnerVault, type(uint256).max);\n        address(governance).safeApprove(newPartnerVault, type(uint256).max);\n        address(partnerGovernance).safeApprove(newPartnerVault, type(uint256).max);\n\n        partnerVault = newPartnerVault;\n        if (newPartnerVault != address(0)) IBaseVault(newPartnerVault).applyAll();\n\n        emit MigratePartnerVault(address(this), newPartnerVault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function increaseConversionRate(uint256 newRate) external onlyOwner {\n        if (newRate < bHermesRate) revert InvalidRate();\n\n        if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) {\n            revert InsufficientBacking();\n        }\n\n        bHermesRate = newRate;\n\n        partnerGovernance.mint(\n            address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))\n        );\n        bHermesToken.claimOutstanding();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new partner bhermes tokens to a specific address.\n     * @param to address to mints tokens to.\n     * @param amount amount of tokens to mint.\n     */\n    function _mint(address to, uint256 amount) internal virtual override {\n        if (amount > maxMint(to)) revert ExceedsMaxDeposit();\n        bHermesToken.claimOutstanding();\n\n        ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);\n        super._mint(to, amount);\n    }\n\n    /**\n     * @notice Burns (or unstakes) the vMaia token in exchange for the underlying\n     *         Partner tokens, performing changes around bHermes tokens.\n     * @param from account to burn the partner manager from\n     * @param amount amounts of vMaia to burn\n     */\n    function _burn(address from, uint256 amount) internal virtual override checkTransfer(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfer partner manager to a specific address.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(msg.sender, amount)\n        returns (bool)\n    {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer tokens from a given address.\n     * @param from address to transfer the tokens from.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available boost allows for call.\n    modifier checkBoost(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedBoost[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    modifier checkTransfer(address from, uint256 amount) virtual {\n        uint256 userBalance = balanceOf[from] * bHermesRate;\n\n        if (\n            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount\n                || userBalance - userClaimedGovernance[from] < amount\n                || userBalance - userClaimedPartnerGovernance[from] < amount\n        ) revert InsufficientUnderlying();\n\n        _;\n    }\n}"
    },
    {
      "filename": "src/maia/PartnerUtilityManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20Votes, UtilityManager, IUtilityManager} from \"@hermes/UtilityManager.sol\";\n\nimport {IBaseVault} from \"./interfaces/IBaseVault.sol\";\nimport {IPartnerUtilityManager} from \"./interfaces/IPartnerUtilityManager.sol\";\n\n/// @title Partner Utility Tokens Manager Contract\nabstract contract PartnerUtilityManager is UtilityManager, IPartnerUtilityManager {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                         UTILITY MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IPartnerUtilityManager\n    address public partnerVault;\n\n    /// @inheritdoc IPartnerUtilityManager\n    ERC20Votes public immutable partnerGovernance;\n\n    /// @inheritdoc IPartnerUtilityManager\n    mapping(address => uint256) public userClaimedPartnerGovernance;\n\n    /**\n     * @notice Constructs the Utility Manager Contract.\n     * @param _gaugeWeight The address of the weight gauge.\n     * @param _gaugeBoost The address of the boost gauge.\n     * @param _governance The address of the governance token.\n     * @param _partnerGovernance The address of the partner governance token.\n     * @param _partnerVault The address of the partner vault.\n     */\n    constructor(\n        address _gaugeWeight,\n        address _gaugeBoost,\n        address _governance,\n        address _partnerGovernance,\n        address _partnerVault\n    ) UtilityManager(_gaugeWeight, _gaugeBoost, _governance) {\n        partnerGovernance = ERC20Votes(_partnerGovernance);\n        partnerVault = _partnerVault;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        UTILITY TOKENS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUtilityManager\n    function forfeitMultiple(uint256 amount) public virtual override {\n        forfeitWeight(amount);\n        forfeitBoost(amount);\n        forfeitGovernance(amount);\n        forfeitPartnerGovernance(amount);\n    }\n\n    /// @inheritdoc IPartnerUtilityManager\n    function forfeitMultipleAmounts(uint256 weight, uint256 boost, uint256 _governance, uint256 _partnerGovernance)\n        public\n        virtual\n    {\n        forfeitWeight(weight);\n        forfeitBoost(boost);\n        forfeitGovernance(_governance);\n        forfeitPartnerGovernance(_partnerGovernance);\n    }\n\n    /// @inheritdoc IUtilityManager\n    function forfeitWeight(uint256 amount) public virtual override {\n        super.forfeitWeight(amount);\n\n        /// @dev Vault applies outstanding weight.\n        if (partnerVault != address(0) && address(gaugeWeight).balanceOf(address(this)) > 0) {\n            IBaseVault(partnerVault).applyWeight();\n        }\n    }\n\n    /// @inheritdoc IUtilityManager\n    function forfeitBoost(uint256 amount) public virtual override {\n        super.forfeitBoost(amount);\n\n        /// @dev Vault applies outstanding boost.\n        if (partnerVault != address(0) && address(gaugeBoost).balanceOf(address(this)) > 0) {\n            IBaseVault(partnerVault).applyBoost();\n        }\n    }\n\n    /// @inheritdoc IUtilityManager\n    function forfeitGovernance(uint256 amount) public virtual override {\n        super.forfeitGovernance(amount);\n\n        /// @dev Vault applies outstanding governance.\n        if (partnerVault != address(0) && address(governance).balanceOf(address(this)) > 0) {\n            IBaseVault(partnerVault).applyGovernance();\n        }\n    }\n\n    /// @inheritdoc IPartnerUtilityManager\n    function forfeitPartnerGovernance(uint256 amount) public {\n        userClaimedPartnerGovernance[msg.sender] -= amount;\n        /// @dev partnerGovernance is kept in this contract and not sent to vaults to avoid governance attacks.\n        address(partnerGovernance).safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @inheritdoc IUtilityManager\n    function claimMultiple(uint256 amount) public virtual override {\n        claimWeight(amount);\n        claimBoost(amount);\n        claimGovernance(amount);\n        claimPartnerGovernance(amount);\n    }\n\n    /// @inheritdoc IPartnerUtilityManager\n    function claimMultipleAmounts(uint256 weight, uint256 boost, uint256 _governance, uint256 _partnerGovernance)\n        public\n        virtual\n    {\n        claimWeight(weight);\n        claimBoost(boost);\n        claimGovernance(_governance);\n        claimPartnerGovernance(_partnerGovernance);\n    }\n\n    /// @inheritdoc IUtilityManager\n    function claimWeight(uint256 amount) public virtual override checkWeight(amount) {\n        uint256 weightAvailable = address(gaugeWeight).balanceOf(address(this));\n        /// @dev Must transfer weight amount to this manager address.\n        if (weightAvailable < amount) {\n            IBaseVault(partnerVault).clearWeight(amount - weightAvailable);\n        }\n\n        super.claimWeight(amount);\n    }\n\n    /// @inheritdoc IUtilityManager\n    function claimBoost(uint256 amount) public virtual override checkBoost(amount) {\n        uint256 boostAvailable = address(gaugeBoost).balanceOf(address(this));\n        /// @dev Must transfer boost amount to this manager address.\n        if (boostAvailable < amount) IBaseVault(partnerVault).clearBoost(amount - boostAvailable);\n\n        super.claimBoost(amount);\n    }\n\n    /// @inheritdoc IUtilityManager\n    function claimGovernance(uint256 amount) public virtual override checkGovernance(amount) {\n        uint256 governanceAvailable = address(governance).balanceOf(address(this));\n        /// @dev Must transfer governance amount to this manager address.\n        if (governanceAvailable < amount) {\n            IBaseVault(partnerVault).clearGovernance(amount - governanceAvailable);\n        }\n\n        super.claimGovernance(amount);\n    }\n\n    /// @inheritdoc IPartnerUtilityManager\n    function claimPartnerGovernance(uint256 amount) public checkPartnerGovernance(amount) {\n        userClaimedPartnerGovernance[msg.sender] += amount;\n        address(partnerGovernance).safeTransfer(msg.sender, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available governance allows for call.\n    modifier checkPartnerGovernance(uint256 amount) virtual;\n}"
    },
    {
      "filename": "src/talos/base/TalosBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {PoolVariables} from \"../libraries/PoolVariables.sol\";\n\nimport {ITalosBaseStrategy} from \"../interfaces/ITalosBaseStrategy.sol\";\nimport {ITalosOptimizer} from \"../interfaces/ITalosOptimizer.sol\";\n\n/// @title Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\nabstract contract TalosBaseStrategy is Ownable, ERC20, ReentrancyGuard, ITalosBaseStrategy {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /*//////////////////////////////////////////////////////////////\n                        TALOS BASE STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public override tokenId;\n    /// @inheritdoc ITalosBaseStrategy\n    uint128 public override liquidity;\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees0;\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees1;\n\n    /// @notice Current tick lower of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickLower;\n    /// @notice Current tick higher of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickUpper;\n\n    /// @inheritdoc ITalosBaseStrategy\n    bool public initialized;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token0;\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token1;\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public immutable override tickSpacing;\n    /// @inheritdoc ITalosBaseStrategy\n    uint24 public immutable override poolFee;\n    /// @inheritdoc ITalosBaseStrategy\n    IUniswapV3Pool public immutable override pool;\n    /// @inheritdoc ITalosBaseStrategy\n    ITalosOptimizer public immutable override optimizer;\n    /// @inheritdoc ITalosBaseStrategy\n    address public immutable strategyManager;\n    /// @inheritdoc ITalosBaseStrategy\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    uint24 internal constant MULTIPLIER = 1e6;\n\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) ERC20(\"TALOS LP\", \"TLP\", 18) {\n        _initializeOwner(_owner);\n        optimizer = _optimizer;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        strategyManager = _strategyManager;\n        pool = _pool;\n        token0 = ERC20(_pool.token0());\n        token1 = ERC20(_pool.token1());\n        tickSpacing = _pool.tickSpacing();\n        poolFee = _pool.fee();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INITIALIZATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function init(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        external\n        virtual\n        nonReentrant\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        if (initialized) revert AlreadyInitialized();\n\n        {\n            // Own Scope to avoid stack to deep\n            int24 _tickSpacing = tickSpacing; // Saves an extra SLOAD\n            int24 baseThreshold = _tickSpacing * optimizer.tickRangeMultiplier();\n            (, int24 currentTick,,,,,) = pool.slot0();\n            int24 tickFloor = PoolVariables.floor(currentTick, _tickSpacing);\n\n            int24 _tickLower = tickFloor - baseThreshold; // Saves an extra SLOAD\n            int24 _tickUpper = tickFloor + baseThreshold; // Saves an extra SLOAD\n            PoolVariables.checkRange(_tickLower, _tickUpper); // Check ticks also for overflow/underflow\n            tickLower = _tickLower;\n            tickUpper = _tickUpper;\n        }\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n\n        address(_token0).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n        address(_token1).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n\n        uint128 _liquidity;\n        uint256 _tokenId;\n        (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(_token0),\n                token1: address(_token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        shares = _liquidity * MULTIPLIER;\n        liquidity = _liquidity;\n        tokenId = _tokenId;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Initialize(tokenId, msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n        initialized = true;\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function deposit(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        uint256 _tokenId = tokenId;\n\n        beforeDeposit(_tokenId, receiver);\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        uint128 liquidityDifference;\n\n        (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: _tokenId,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        shares = supply == 0 ? liquidityDifference * MULTIPLIER : (liquidityDifference * supply) / liquidity;\n        liquidity += liquidityDifference;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Deposit(msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function redeem(uint256 shares, uint256 amount0Min, uint256 amount1Min, address receiver, address _owner)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 amount0, uint256 amount1)\n    {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance[_owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - shares;\n        }\n\n        if (shares == 0) revert RedeemingZeroShares();\n        if (receiver == address(0)) revert ReceiverIsZeroAddress();\n\n        uint256 _tokenId = tokenId;\n\n        beforeRedeem(_tokenId, receiver);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n        {\n            uint128 liquidityToDecrease = uint128((liquidity * shares) / totalSupply);\n\n            (amount0, amount1) = _nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: _tokenId,\n                    liquidity: liquidityToDecrease,\n                    amount0Min: amount0Min,\n                    amount1Min: amount1Min,\n                    deadline: block.timestamp\n                })\n            );\n\n            if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n            _burn(_owner, shares);\n\n            liquidity -= liquidityToDecrease;\n        }\n        emit Redeem(msg.sender, receiver, _owner, amount0, amount1, shares);\n\n        (amount0, amount1) = _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: receiver,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        afterRedeem(_tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        RERANGE/REBALANCE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rerange() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRerange();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rebalance() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRebalance();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external {\n        if (msg.sender != address(pool)) revert CallerIsNotPool();\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZe"
    }
  ]
}