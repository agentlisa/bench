{
  "Title": "M-2: Protocol fees not taken on premium",
  "Content": "# Issue M-2: Protocol fees not taken on premium \n\nSource: https://github.com/sherlock-audit/2023-01-illuminate-judging/issues/22 \n\n## Found by \nIllIllI\n\n## Summary\n\nProtocol fees not taken on premium\n\n\n## Vulnerability Detail\nThe Swivel version of `lend()` allows the user to use any extra underlying premium from their Swivel orders, to buy more iPTs via a swap or minting directly, but no fee is taken from this premium.\n\n\n## Impact\nRather than using the Illuminate version of `lend()`, which charges a fee, users could use the Swivel version, and ensure the fee portion is small, and the premium non-fee portion is large, so that Illuminate misses out on fees.\n\n\n## Code Snippet\nThe fee is calculated based on the amount listed in the orders:\n```solidity\n// File: src/Lender.sol : Lender.lend()   #1\n\n488            // Lent represents the total amount of underlying to be lent\n489 @>         uint256 lent = swivelAmount(a);\n490    \n491            // Get the underlying balance prior to calling initiate\n492            uint256 starting = IERC20(u).balanceOf(address(this));\n493    \n494            // Transfer underlying token from user to Illuminate\n495            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n496    \n497            // Calculate fee for the total amount to be lent\n498:@>         uint256 fee = lent / feenominator;\n```\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/Lender.sol#L488-L498\n\nBut the premium is the balance change after the orders have executed (can be thought of as positive slippage):\n```solidity\n// File: src/Lender.sol : Lender.lend()   #2\n525                // Calculate the premium\n526 @>             uint256 premium = (IERC20(u).balanceOf(address(this)) - starting) -\n527:                   fee;\n```\nhttps://github.com/sherlock-audit/2023-01-illuminate/blob/main/src/Lender.sol#L525-L527\n\nAnd no fee is charged on this premium, either when swapping in the yield pool, or when minting iPTs directly.\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\nCalculate the fee after the order, on the full balance change\n\nThis is similar to a [finding](https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/45) from the previous contest, but the mitigation was to remove the amount fee from the premium, but didn't address the fee for the premium itself\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/35",
  "Code": [
    {
      "filename": "src/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\nimport 'src/lib/Swivel.sol';\nimport 'src/lib/Element.sol';\nimport 'src/lib/Safe.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/lib/Maturities.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusAMM.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/ISensePeriphery.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IElementVault.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/IAPWineRouter.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\n\n/// @title Lender\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users\n/// @notice The contract holds the principal tokens and mints an ERC-5095 tokens to users to represent their loans\ncontract Lender {\n    /// @notice minimum wait before the admin may withdraw funds or change the fee rate\n    uint256 public constant HOLD = 3 days;\n\n    /// @notice address that is allowed to set and withdraw fees, disable principals, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal has been paused by the admin\n    mapping(uint8 => bool) public paused;\n    /// @notice flag that allows admin to stop all lending and minting across the entire protocol\n    bool public halted;\n\n    /// @notice contract used to execute swaps on Swivel's exchange\n    address public immutable swivelAddr;\n    /// @notice a SushiSwap router used by Pendle to execute swaps\n    address public immutable pendleAddr;\n    /// @notice a pool router used by APWine to execute swaps\n    address public immutable apwineAddr;\n\n    /// @notice a mapping that tracks the amount of unswapped premium by market. This underlying is later transferred to the Redeemer during Swivel's redeem call\n    mapping(address => mapping(uint256 => uint256)) public premiums;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public constant MIN_FEENOMINATOR = 500;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping(address => uint256) public withdrawals;\n\n    // Reantrancy protection\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status = _NOT_ENTERED;\n\n    // Rate limiting protection\n    /// @notice maximum amount of value that can flow through a protocol in a day (in USD)\n    uint256 public constant MAX_VALUE = 2_000_000e27;\n    /// @notice maps protocols to how much value, in USD, has flowed through each protocol\n    mapping(uint8 => uint256) public protocolFlow;\n    /// @notice timestamp from which values flowing through protocol has begun\n    mapping(uint8 => uint256) public periodStart;\n    /// @notice estimated price of ether, set by the admin\n    uint256 public etherPrice = 2_500;\n\n    /// @notice emitted upon lending to a protocol\n    event Lend(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 returned,\n        uint256 spent,\n        address sender\n    );\n    /// @notice emitted upon minting Illuminate principal tokens\n    event Mint(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount\n    );\n    /// @notice emitted upon scheduling a withdrawal\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted upon blocking a scheduled withdrawal\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n    /// @notice emitted upon scheduling a fee change\n    event ScheduleFeeChange(uint256 when);\n    /// @notice emitted upon blocking a scheduled fee change\n    event BlockFeeChange();\n    /// @notice emitted upon pausing or unpausing of a principal\n    event PausePrincipal(uint8 principal, bool indexed state);\n    /// @notice emitted upon pausing or unpausing minting, lending and redeeming\n    event PauseIlluminate(bool state);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    modifier unpaused(\n        address u,\n        uint256 m,\n        uint8 p\n    ) {\n        if (paused[p] || halted) {\n            revert Exception(1, p, 0, address(0), address(0));\n        }\n        _;\n    }\n\n    /// @notice reverts if called after maturity\n    /// @param m maturity (timestamp) of the market\n    modifier matured(uint256 m) {\n        if (block.timestamp > m) {\n            revert Exception(2, block.timestamp, m, address(0), address(0));\n        }\n        _;\n    }\n\n    /// @notice prevents users from re-entering contract\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        if (_status == _ENTERED) {\n            revert Exception(30, 0, 0, address(0), address(0));\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /// @notice initializes the Lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param a the APWine contract\n    constructor(\n        address s,\n        address p,\n        address a\n    ) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        apwineAddr = a;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // approve the underlying for max per given principal\n        for (uint8 i; i != 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).markets(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        // approve the redeemer to receive underlying from the lender\n        Safe.approve(IERC20(u), r, type(uint256).max);\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses.\n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        for (uint256 i; i != u.length; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice approves market contracts that require lender approval\n    /// @param u address of an underlying asset\n    /// @param a APWine's router contract\n    /// @param e Element's vault contract\n    /// @param n Notional's token contract\n    /// @param p Sense's periphery contract\n    function approve(\n        address u,\n        address a,\n        address e,\n        address n,\n        address p\n    ) external authorized(marketPlace) {\n        uint256 max = type(uint256).max;\n        IERC20 uToken = IERC20(u);\n        if (a != address(0)) {\n            Safe.approve(uToken, a, max);\n        }\n        if (e != address(0)) {\n            Safe.approve(uToken, e, max);\n        }\n        if (n != address(0)) {\n            Safe.approve(uToken, n, max);\n        }\n        if (p != address(0)) {\n            Safe.approve(uToken, p, max);\n        }\n        if (IERC20(u).allowance(address(this), swivelAddr) == 0) {\n            Safe.approve(uToken, swivelAddr, max);\n        }\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (block.timestamp < feeTime) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the ethereum price which is used in rate limiting\n    /// @param p the new price\n    /// @return bool true if the price was set\n    function setEtherPrice(uint256 p)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        etherPrice = p;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for Illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on Illuminate\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) external nonReentrant unpaused(u, m, p) returns (bool) {\n        // Fetch the desired principal token\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Disallow mints if market is not initialized\n        if (principal == address(0)) {\n            revert Exception(26, 0, 0, address(0), address(0));\n        }\n\n        // Get the maturity of the principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            revert Exception(32, 0, 0, address(0), address(0));\n        } else if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = Maturities.swivel(principal);\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = Maturities.yield(principal);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = Maturities.element(principal);\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = Maturities.pendle(principal);\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = Maturities.tempus(principal);\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            maturity = Maturities.apwine(principal);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = Maturities.notional(principal);\n        }\n\n        // Confirm that the principal token has not matured yet\n        if (block.timestamp > maturity || maturity == 0) {\n            revert Exception(\n                7,\n                maturity,\n                block.timestamp,\n                address(0),\n                address(0)\n            );\n        }\n\n        // Transfer the users principal tokens to the lender contract\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n\n        // Calculate how much should be minted based on the decimal difference\n        uint256 mintable = convertDecimals(u, principal, a);\n\n        // Confirm that minted iPT amount will not exceed rate limit for the protocol\n        rateLimit(p, u, mintable);\n\n        // Mint the tokens received from the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, mintable);\n\n        emit Mint(p, u, m, mintable);\n\n        return true;\n    }\n\n    /// @notice lend method for the Illuminate and Yield protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y Yield Space Pool for the principal token\n    /// @param minimum slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y,\n        uint256 minimum\n    ) external nonReentrant unpaused(u, m, p) matured(m) returns (uint256) {\n        // Get principal token for this market\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Extract fee\n        fees[u] = fees[u] + a / feenominator;\n\n        // Transfer underlying from user to the lender contract\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Make sure the Yield Space Pool matches the market\n        address fyToken = IYield(y).fyToken();\n        if (IYield(y).fyToken() != principal) {\n            revert Exception(12, 0, 0, fyToken, principal);\n        }\n        address base = address(IYield(y).base());\n        if (base != u) {\n            revert Exception(27, 0, 0, base, u);\n        }\n\n        // Set who should get the tokens that are swapped for\n        address receiver = address(this);\n\n        // If lending on Illuminate, swap directly to the caller\n        if (p == uint8(MarketPlace.Principals.Illuminate)) {\n            receiver = msg.sender;\n        }\n\n        // Swap underlying for PTs to lender\n        uint256 returned = yield(\n            u,\n            y,\n            a - a / feenominator,\n            receiver,\n            principal,\n            minimum\n        );\n\n        // Convert decimals from principal token to underlying\n        returned = convertDecimals(u, principal, returned);\n\n        // Only mint iPTs to user if lending through Yield protocol\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Confirm that minted iPT amount will not exceed rate limit for the protocol\n            rateLimit(p, u, returned);\n\n            // Mint Illuminate PTs to msg.sender\n            IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n        }\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n\n        return returned;\n    }\n\n    /// @notice lend method signature for Swivel\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y Yield Space Pool for the Illuminate PT in this market\n    /// @param o array of Swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @param e flag to indicate if returned funds should be swapped in Yield Space Pool\n    /// @param premiumSlippage slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s,\n        bool e,\n        uint256 premiumSlippage\n    ) external nonReentrant unpaused(u, m, p) matured(m) returns (uint256) {\n        // Ensure all the orders are for the underlying asset\n        swivelVerify(o, u);\n\n        // Lent represents the total amount of underlying to be lent\n        uint256 lent = swivelAmount(a);\n\n        // Get the underlying balance prior to calling initiate\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        // Transfer underlying token from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n\n        // Calculate fee for the total amount to be lent\n        uint256 fee = lent / feenominator;\n\n        {\n            // Get last order to be processed's index\n            uint256 lastIndex = a.length - 1;\n\n            // Add the accumulated fees to the total\n            a[lastIndex] = a[lastIndex] - fee; // Revert here if fee not paid\n\n            // Extract fee\n            fees[u] += fee;\n        }\n\n        uint256 received;\n        {\n            // Get the starting amount of principal tokens\n            uint256 startingZcTokens = IERC20(\n                IMarketPlace(marketPlace).markets(u, m, p)\n            ).balanceOf(address(this));\n\n            // Fill the given orders on Swivel\n            ISwivel(swivelAddr).initiate(o, a, s);\n\n            // Compute how many principal tokens were received\n            received = (IERC20(IMarketPlace(marketPlace).markets(u, m, p))\n                .balanceOf(address(this)) - startingZcTokens);\n\n            // Calculate the premium\n            uint256 premium = (IERC20(u).balanceOf(address(this)) - starting) -\n                fee;\n\n            // Store how much the user received in exchange for swapping the premium for iPTs\n            uint256 swapped;\n\n            if (e) {\n                // Swap the premium for Illuminate principal tokens\n                swapped += yield(\n                    u,\n                    y,\n                    premium,\n                    msg.sender,\n                    IMarketPlace(marketPlace).markets(u, m, 0),\n                    premiumSlippage\n                );\n            } else {\n                // Send the premium to the redeemer to hold until redemption\n                premiums[u][m] = premiums[u][m] + premium;\n\n                // Account for the premium\n                received = received + premium;\n            }\n\n            // Mint Illuminate principal tokens to the user\n            IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n            emit Lend(\n                uint8(MarketPlace.Principals.Swivel),\n                u,\n                m,\n                received + swapped,\n                lent,\n                msg.sender\n            );\n        }\n\n        // Confirm that minted iPT amount will not exceed rate limit for the protocol\n        rateLimit(p, u, received);\n        return received;\n    }\n\n    /// @notice lend method signature for Element\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param e Element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) external nonReentrant unpaused(u, m, p) matured(m) returns (uint256) {\n        // Get the principal token for this market for Element\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Transfer underlying token from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] = fees[u] + a / feenominator;\n\n        uint256 purchased;\n        {\n            // Calculate the amount to be lent\n            uint256 lent = a - a / feenominator;\n\n            // Create the variables needed to execute an Element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                poolId: i,\n                amount: lent,\n                kind: Element.SwapKind.GIVEN_IN,\n                assetIn: IAny(u),\n                assetOut: IAny(principal),\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000'\n            });\n\n            // Conduct the swap on Element\n            purchased = elementSwap(e, swap, fund, r, d);\n\n            // Convert decimals from principal token to underlying\n            purchased = convertDecimals(u, principal, purchased);\n        }\n\n        // Confirm that minted iPT amount will not exceed rate limit for the protocol\n        rateLimit(p, u, purchased);\n\n        // Mint tokens to the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, purchased);\n\n        emit Lend(p, u, m, purchased, a, msg.sender);\n        return purchased;\n    }\n\n    /// @notice lend method signature for Pendle\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) external nonReentrant unpaused(u, m, p) matured(m) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            uint256[] memory amounts = IPendle(pendleAddr)\n                .swapExactTokensForTokens(a - fee, r, path, address(this), d);\n\n            // Get the amount of PTs received\n            returned = amounts[amounts.length - 1];\n\n            // Convert decimals from principal token to underlying\n            returned = convertDecimals(u, principal, returned);\n        }\n\n        // Confirm that minted iPT amount will not exceed rate limit for the protocol\n        rateLimit(p, u, returned);\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n        return returned;\n    }\n\n    /// @notice lend method signature for Tempus and APWine\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x Tempus or APWine AMM that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x\n    ) external nonReentrant unpaused(u, m, p) matured(m) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting balance of the principal token\n        uint256 start = IERC20(principal).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Tempus)) {\n            // Get the Tempus pool from the principal token\n            ITempusPool pool = ITempusPool(ITempusToken(principal).pool());\n\n            // Get the pool of the contract the user submitted\n            address userPool = ITempusAMM(x).tempusPool();\n\n            // Confirm that the pool matches the principal token\n            if (address(pool) != userPool) {\n                revert Exception(27, 0, 0, address(pool), userPool);\n            }\n\n            // Get the Tempus router from the principal token\n            address controller = pool.controller();\n\n            // Swap on the Tempus router using the provided market and params\n            ITempus(controller).depositAndFix(x, lent, true, 0, d);\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            address poolUnderlying = IAPWineAMMPool(x)\n                .getUnderlyingOfIBTAddress();\n            if (u != poolUnderlying) {\n                revert Exception(27, 0, 0, u, poolUnderlying);\n            }\n            address poolPrincipal = IAPWineAMMPool(x).getPTAddress();\n            if (principal != poolPrincipal) {\n                revert Exception(27, 0, 0, principal, poolPrincipal);\n            }\n            // Swap on the APWine Pool using the provided market and params\n            IAPWineRouter(apwineAddr).swapExactAmountIn(\n                x,\n                apwinePairPath(),\n                apwineTokenPath(),\n                lent,\n                r,\n                address(this),\n                d,\n                address(0)\n            );\n        }\n\n        // Calculate the amount of Tempus principal tokens received after the deposit\n        uint256 received = IERC20(principal).balanceOf(address(this)) - start;\n\n        // Convert decimals from principal token to underlying\n        received = convertDecimals(u, principal, received);\n\n        // Verify that a minimum number of principal tokens were received\n        if (p == uint8(MarketPlace.Principals.Tempus) && received < r) {\n            revert Exception(11, received, r, address(0), address(0));\n        }\n\n        // Confirm that minted iPT amount will not exceed rate limit for the protocol\n        rateLimit(p, u, received);\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice lend method signature for Sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev Sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param x periphery contract that is used to conduct the swap\n    /// @param s Sense's maturity for the given market\n    /// @param adapter Sense's adapter necessary to facilitate the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        uint256 s,\n        address adapter\n    ) external nonReentrant unpaused(u, m, p) matured(m) returns (uint256) {\n        // Get the periphery's divider contract to verify that it maps to the prinicpal token of the market\n        address divider = ISensePeriphery(x).divider();\n\n        // Get the principal token for the user submitted periphery\n        address userPrincipal = ISenseDivider(divider).pt(adapter, s);\n\n        // Retrieve the principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));\n\n        // Verify that the `x` parameter matches the market's Sense principal token\n        if (address(token) != userPrincipal) {\n            revert Exception(27, 0, 0, address(token), userPrincipal);\n        }\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Determine the fee\n        uint256 fee = a / feenominator;\n\n        // Add the accumulated fees to the total\n        fees[u] = fees[u] + fee;\n\n        // Determine lent amount after fees\n        uint256 lent = a - fee;\n\n        // Stores the amount of principal tokens received in swap for underlying\n        uint256 received;\n        {\n            // Get the starting balance of the principal token\n            uint256 starting = token.balanceOf(address(this));\n\n            // Swap those tokens for the principal tokens\n            ISensePeriphery(x).swapUnderlyingForPTs(adapter, s, lent, r);\n\n            // Calculate number of principal tokens received in the swap\n            received = token.balanceOf(address(this)) - starting;\n\n            // Verify that we received the principal tokens\n            if (received < r) {\n                revert Exception(11, 0, 0, address(0), address(0));\n            }\n        }\n\n        // Get the Illuminate PT\n        address ipt = principalToken(u, m);\n\n        // Calculate the mintable amount of tokens for Sense due to decimal mismatch\n        uint256 mintable = convertDecimals(u, address(token), received);\n\n        // Confirm that minted iPT amount will not exceed rate limit for the protocol\n        rateLimit(p, u, mintable);\n\n        // Mint the Illuminate tokens based on the returned amount\n        IERC5095(ipt).authMint(msg.sende"
    }
  ]
}