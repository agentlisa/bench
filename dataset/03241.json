{
  "Title": "Incorrect condition",
  "Content": "##### Description\nThe condition is incorrect here that can lead to an infinite loop: https://github.com/mixbytes/lido-dot-ksm/blob/76a10efa5f223c4c613f26794802b8fb9bb188e1/contracts/Lido.sol#L748\n\n##### Recommendation\nWe recommend changing `||` into `&&`.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Lido.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IOracleMaster.sol\";\nimport \"../interfaces/ILedger.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IAuthManager.sol\";\n\nimport \"./stKSM.sol\";\n\n\ncontract Lido is stKSM, Initializable {\n    using Clones for address;\n    using SafeCast for uint256;\n\n    // Records a deposit made by a user\n    event Deposited(address indexed sender, uint256 amount);\n\n    // Created redeem order\n    event Redeemed(address indexed receiver, uint256 amount);\n\n    // Claimed vKSM tokens back\n    event Claimed(address indexed receiver, uint256 amount);\n\n    // Fee was updated\n    event FeeSet(uint16 fee, uint16 feeOperatorsBP, uint16 feeTreasuryBP,  uint16 feeDevelopersBP);\n\n    // Rewards distributed\n    event Rewards(address ledger, uint256 rewards, uint256 balance);\n\n    // Rewards distributed\n    event Losses(address ledger, uint256 losses, uint256 balance);\n\n    // Added new ledger\n    event LedgerAdd(\n        address addr,\n        bytes32 stashAccount,\n        bytes32 controllerAccount,\n        uint256 share\n    );\n\n    // Ledger removed\n    event LedgerRemove(\n        address addr\n    );\n\n    // Ledger share setted\n    event LedgerSetShare(\n        address addr,\n        uint256 share\n    );\n\n    // sum of all deposits and rewards\n    uint256 private fundRaisedBalance;\n\n    struct Claim {\n        uint256 balance;\n        uint64 timeout;\n    }\n    // one claim for account\n    mapping(address => Claim[]) public claimOrders;\n\n    // pending claims total\n    uint256 public pendingClaimsTotal;\n\n    // Ledger accounts\n    address[] private ledgers;\n\n    // Ledger address by stash account id\n    mapping(bytes32 => address) private ledgerByStash;\n\n    // Map to check ledger existence by address\n    mapping(address => uint256) private ledgerByAddress;\n\n    // Ledger shares map\n    mapping(address => uint256) public ledgerShares;\n\n    // Sum of all ledger shares\n    uint256 public ledgerSharesTotal;\n\n    // haven't executed buffrered deposits\n    uint256 public bufferedDeposits;\n\n    // haven't executed buffrered redeems\n    uint256 public bufferedRedeems;\n\n    // Ledger stakes\n    mapping(address => uint256) public ledgerStake;\n\n\n    // vKSM precompile\n    IERC20 public vKSM;\n    // controller\n    address public controller;\n\n\n    // auth manager contract address\n    address public AUTH_MANAGER;\n\n    // Maximum number of ledgers\n    uint256 public MAX_LEDGERS_AMOUNT;\n\n    // Who pay off relay chain transaction fees\n    bytes32 public GARANTOR;\n\n    /** fee interest in basis points.\n    It's packed uint256 consist of three uint16 (total_fee, treasury_fee, developers_fee).\n    where total_fee = treasury_fee + developers_fee + 3000 (3% operators fee)\n    */\n    Types.Fee private FEE;\n\n    // ledger clone template contract\n    address public LEDGER_CLONE;\n\n    // oracle master contract\n    address public ORACLE_MASTER;\n\n    // relay spec\n    Types.RelaySpec public RELAY_SPEC;\n\n    // developers fund\n    address public developers;\n\n    // treasury fund\n    address public treasury;\n\n    /** default interest value in base points.\n    */\n    uint16 internal constant DEFAULT_DEVELOPERS_FEE = 140;\n    uint16 internal constant DEFAULT_OPERATORS_FEE = 300;\n    uint16 internal constant DEFAULT_TREASURY_FEE = 560;\n\n    // Missing member index\n    uint256 internal constant MEMBER_NOT_FOUND = type(uint256).max;\n\n    // Spec manager role\n    bytes32 internal constant ROLE_SPEC_MANAGER = keccak256(\"ROLE_SPEC_MANAGER\");\n\n    // Pause manager role\n    bytes32 internal constant ROLE_PAUSE_MANAGER = keccak256(\"ROLE_PAUSE_MANAGER\");\n\n    // Fee manager role\n    bytes32 internal constant ROLE_FEE_MANAGER = keccak256(\"ROLE_FEE_MANAGER\");\n\n    // Oracle manager role\n    bytes32 internal constant ROLE_ORACLE_MANAGER = keccak256(\"ROLE_ORACLE_MANAGER\");\n\n    // Ledger manager role\n    bytes32 internal constant ROLE_LEDGER_MANAGER = keccak256(\"ROLE_LEDGER_MANAGER\");\n\n    // Stake manager role\n    bytes32 internal constant ROLE_STAKE_MANAGER = keccak256(\"ROLE_STAKE_MANAGER\");\n\n    // Treasury manager role\n    bytes32 internal constant ROLE_TREASURY = keccak256(\"ROLE_SET_TREASURY\");\n\n    // Developers address change role\n    bytes32 internal constant ROLE_DEVELOPERS = keccak256(\"ROLE_SET_DEVELOPERS\");\n\n    // max amount of claims in parallel\n    uint16 internal constant MAX_CLAIMS = 10;\n\n\n    modifier auth(bytes32 role) {\n        require(IAuthManager(AUTH_MANAGER).has(role, msg.sender), \"LIDO: UNAUTHORIZED\");\n        _;\n    }\n\n    /**\n    * @notice Initialize lido contract.\n    * @param _authManager - auth manager contract address\n    * @param _vKSM - vKSM contract address\n    * @param _controller - relay controller address\n    * @param _developers - devs address\n    * @param _treasury - treasury address\n    */\n    function initialize(\n        address _authManager,\n        address _vKSM,\n        address _controller,\n        address _developers,\n        address _treasury\n    ) external initializer {\n        vKSM = IERC20(_vKSM);\n        controller = _controller;\n        AUTH_MANAGER = _authManager;\n\n        MAX_LEDGERS_AMOUNT = 200;\n        Types.Fee memory _fee;\n        _fee.total = DEFAULT_OPERATORS_FEE + DEFAULT_DEVELOPERS_FEE + DEFAULT_TREASURY_FEE;\n        _fee.operators = DEFAULT_OPERATORS_FEE;\n        _fee.developers = DEFAULT_DEVELOPERS_FEE;\n        _fee.treasury = DEFAULT_TREASURY_FEE;\n        FEE = _fee;\n        GARANTOR = 0x00;\n\n        treasury = _treasury;\n        developers =_developers;\n    }\n\n    /**\n    * @notice Stub fallback for native token, always reverting\n    */\n    fallback() external {\n        revert(\"FORBIDDEN\");\n    }\n\n    /**\n    * @notice Set treasury address to '_treasury'\n    */\n    function setTreasury(address _treasury) external auth(ROLE_TREASURY) {\n        treasury = _treasury;\n    }\n\n    /**\n    * @notice Set developers address to '_developers'\n    */\n    function setDevelopers(address _developers) external auth(ROLE_DEVELOPERS) {\n        developers = _developers;\n    }\n\n    /**\n    * @notice Return unbonded tokens amount for user\n    * @param _holder - user account for whom need to calculate unbonding\n    * @return waiting - amount of tokens which are not unbonded yet\n    * @return unbonded - amount of token which unbonded and ready to claim\n    */\n    function getUnbonded(address _holder) external view returns (uint256 waiting, uint256 unbonded) {\n        uint256 waitingToUnbonding = 0;\n        uint256 readyToClaim = 0;\n        Claim[] storage orders = claimOrders[_holder];\n\n        for (uint256 i = 0; i < orders.length; ++i) {\n            if (orders[i].timeout < block.timestamp) {\n                readyToClaim += orders[i].balance;\n            }\n            else {\n                waitingToUnbonding += orders[i].balance;\n            }\n        }\n        return (waitingToUnbonding, readyToClaim);\n    }\n\n    /**\n    * @notice Return relay chain stash account addresses\n    * @return Array of bytes32 relaychain stash accounts\n    */\n    function getStashAccounts() public view returns (bytes32[] memory) {\n        bytes32[] memory _stashes = new bytes32[](ledgers.length);\n\n        for (uint i = 0; i < ledgers.length; i++) {\n            _stashes[i] = bytes32(ILedger(ledgers[i]).stashAccount());\n        }\n        return _stashes;\n    }\n\n    /**\n    * @notice Return ledger contract addresses\n    * @dev Each ledger contract linked with single stash account on the relaychain side\n    * @return Array of ledger contract addresses\n    */\n    function getLedgerAddresses() public view returns (address[] memory) {\n        return ledgers;\n    }\n\n    /**\n    * @notice Return ledger address by stash account id\n    * @dev If ledger not found function returns ZERO address\n    * @param _stashAccount - relaychain stash account id\n    * @return Linked ledger contract address\n    */\n    function findLedger(bytes32 _stashAccount) external view returns (address) {\n        return ledgerByStash[_stashAccount];\n    }\n\n    /**\n    * @notice Return vKSM amount available for stake by ledger\n    * @dev If we have balance less than pendingClaimsTotal that means\n    *      that ledgers already have locked KSMs\n    */\n    function avaliableForStake() external view returns(uint256) {\n        uint256 freeBalance = vKSM.balanceOf(address(this));\n        return freeBalance < pendingClaimsTotal ? 0 : freeBalance - pendingClaimsTotal;\n    }\n\n    /**\n    * @notice Set relay chain spec, allowed to call only by ROLE_SPEC_MANAGER\n    * @dev if some params are changed function will iterate over oracles and ledgers, be careful\n    * @param _relaySpec - new relaychain spec\n    */\n    function setRelaySpec(Types.RelaySpec calldata _relaySpec) external auth(ROLE_SPEC_MANAGER) {\n        require(ORACLE_MASTER != address(0), \"LIDO: ORACLE_MASTER_UNDEFINED\");\n        require(_relaySpec.genesisTimestamp > 0, \"LIDO: BAD_GENESIS_TIMESTAMP\");\n        require(_relaySpec.secondsPerEra > 0, \"LIDO: BAD_SECONDS_PER_ERA\");\n        require(_relaySpec.unbondingPeriod > 0, \"LIDO: BAD_UNBONDING_PERIOD\");\n        require(_relaySpec.maxValidatorsPerLedger > 0, \"LIDO: BAD_MAX_VALIDATORS_PER_LEDGER\");\n\n        //TODO loop through ledgerByAddress and oracles if some params changed\n\n        RELAY_SPEC = _relaySpec;\n\n        IOracleMaster(ORACLE_MASTER).setRelayParams(_relaySpec.genesisTimestamp, _relaySpec.secondsPerEra);\n    }\n\n    /**\n    * @notice Set oracle master address, allowed to call only by ROLE_ORACLE_MANAGER and only once\n    * @dev After setting non zero address it cannot be changed more\n    * @param _oracleMaster - oracle master address\n    */\n    function setOracleMaster(address _oracleMaster) external auth(ROLE_ORACLE_MANAGER) {\n        require(ORACLE_MASTER == address(0), \"LIDO: ORACLE_MASTER_ALREADY_DEFINED\");\n        ORACLE_MASTER = _oracleMaster;\n        IOracleMaster(ORACLE_MASTER).setLido(address(this));\n    }\n\n    /**\n    * @notice Set new ledger clone contract address, allowed to call only by ROLE_LEDGER_MANAGER\n    * @dev After setting new ledger clone address, old ledgers won't be affected, be careful\n    * @param _ledgerClone - ledger clone address\n    */\n    function setLedgerClone(address _ledgerClone) external auth(ROLE_LEDGER_MANAGER) {\n        LEDGER_CLONE = _ledgerClone;\n    }\n\n    /**\n    * @notice Set new lido fee, allowed to call only by ROLE_FEE_MANAGER\n    * @param _feeOperators - Operators percentage in basis points. It's always 3%\n    * @param _feeTreasury - Treasury fund percentage in basis points\n    * @param _feeDevelopers - Developers percentage in basis points\n    */\n    function setFee(uint16 _feeOperators, uint16 _feeTreasury,  uint16 _feeDevelopers) external auth(ROLE_FEE_MANAGER) {\n        Types.Fee memory _fee;\n        _fee.total = _feeTreasury + _feeOperators + _feeDevelopers;\n        require(_fee.total <= 10000 && (_feeTreasury > 0 || _feeDevelopers > 0) , \"LIDO: FEE_DONT_ADD_UP\");\n\n        emit FeeSet(_fee.total, _feeOperators, _feeTreasury, _feeDevelopers);\n\n        _fee.developers = _feeDevelopers;\n        _fee.operators = _feeOperators;\n        _fee.treasury = _feeTreasury;\n        FEE = _fee;\n    }\n\n    /**\n    * @notice Returns total fee basis points\n    */\n    function getFee() external view returns (uint16){\n        return FEE.total;\n    }\n\n    /**\n    * @notice Returns operators fee basis points\n    */\n    function getOperatorsFee() external view returns (uint16){\n        return FEE.operators;\n    }\n\n    /**\n    * @notice Returns treasury fee basis points\n    */\n    function getTreasuryFee() external view returns (uint16){\n       return FEE.treasury;\n    }\n\n    /**\n    * @notice Returns developers fee basis points\n    */\n    function getDevelopersFee() external view returns (uint16){\n        return FEE.developers;\n    }\n\n    /**\n    * @notice Stop pool routine operations (deposit, redeem, claimUnbonded),\n    *         allowed to call only by ROLE_PAUSE_MANAGER\n    */\n    function pause() external auth(ROLE_PAUSE_MANAGER) {\n        _pause();\n    }\n\n    /**\n    * @notice Resume pool routine operations (deposit, redeem, claimUnbonded),\n    *         allowed to call only by ROLE_PAUSE_MANAGER\n    */\n    function resume() external auth(ROLE_PAUSE_MANAGER) {\n        _unpause();\n    }\n\n    /**\n    * @notice Add new ledger, allowed to call only by ROLE_LEDGER_MANAGER\n    * @dev That function deploys new ledger for provided stash account\n    *      Also method triggers rebalancing stakes accross ledgers,\n           recommended to carefully calculate share value to avoid significant rebalancing.\n    * @param _stashAccount - relaychain stash account id\n    * @param _controllerAccount - controller account id for given stash\n    * @param _share - share of managing stake from total pooled tokens\n    * @return created ledger address\n    */\n    function addLedger(\n        bytes32 _stashAccount,\n        bytes32 _controllerAccount,\n        uint16 _index,\n        uint256 _share\n    )\n        external\n        auth(ROLE_LEDGER_MANAGER)\n        returns(address)\n    {\n        require(LEDGER_CLONE != address(0), \"LIDO: UNSPECIFIED_LEDGER_CLONE\");\n        require(ORACLE_MASTER != address(0), \"LIDO: NO_ORACLE_MASTER\");\n        require(ledgers.length < MAX_LEDGERS_AMOUNT, \"LIDO: LEDGERS_POOL_LIMIT\");\n        require(ledgerByStash[_stashAccount] == address(0), \"LIDO: STASH_ALREADY_EXISTS\");\n\n        address ledger = LEDGER_CLONE.cloneDeterministic(_stashAccount);\n        // skip one era before commissioning\n        ILedger(ledger).initialize(\n            _stashAccount,\n            _controllerAccount,\n            address(vKSM),\n            controller,\n            RELAY_SPEC.minNominatorBalance\n        );\n        ledgers.push(ledger);\n        ledgerByStash[_stashAccount] = ledger;\n        ledgerByAddress[ledger] = ledgers.length;\n        ledgerShares[ledger] = _share;\n        ledgerSharesTotal += _share;\n\n        IOracleMaster(ORACLE_MASTER).addLedger(ledger);\n\n//        vKSM.approve(ledger, type(uint256).max);\n\n        IController(controller).newSubAccount(_index, _stashAccount, ledger);\n\n        emit LedgerAdd(ledger, _stashAccount, _controllerAccount, _share);\n        return ledger;\n    }\n\n    /**\n    * @notice Set new share for existing ledger, allowed to call only by ROLE_LEDGER_MANAGER\n    * @param _ledger - target ledger address\n    * @param _newShare - new stare amount\n    */\n    function setLedgerShare(address _ledger, uint256 _newShare) external auth(ROLE_LEDGER_MANAGER) {\n        require(ledgerByAddress[_ledger] != 0, \"LIDO: LEDGER_NOT_FOUND\");\n\n        ledgerSharesTotal -= ledgerShares[_ledger];\n        ledgerShares[_ledger] = _newShare;\n        ledgerSharesTotal += _newShare;\n\n        emit LedgerSetShare(_ledger, _newShare);\n    }\n\n    /**\n    * @notice Remove ledger, allowed to call only by ROLE_LEDGER_MANAGER\n    * @dev That method cannot be executed for running ledger, so need to drain funds\n    *      from ledger by setting zero share and wait for unbonding period.\n    * @param _ledgerAddress - target ledger address\n    */\n    function removeLedger(address _ledgerAddress) external auth(ROLE_LEDGER_MANAGER) {\n        require(ledgerByAddress[_ledgerAddress] != 0, \"LIDO: LEDGER_NOT_FOUND\");\n        require(ledgerShares[_ledgerAddress] == 0, \"LIDO: LEDGER_HAS_NON_ZERO_SHARE\");\n\n        ILedger ledger = ILedger(_ledgerAddress);\n        require(ledger.isEmpty(), \"LIDO: LEDGER_IS_NOT_EMPTY\");\n\n        address lastLedger = ledgers[ledgers.length - 1];\n        uint256 idxToRemove = ledgerByAddress[_ledgerAddress] - 1;\n        ledgers[idxToRemove] = lastLedger; // put last ledger to removing ledger position\n        ledgerByAddress[lastLedger] = idxToRemove + 1; // fix last ledger index after swap\n        ledgers.pop();\n        delete ledgerByAddress[_ledgerAddress];\n        delete ledgerByStash[ledger.stashAccount()];\n        delete ledgerShares[_ledgerAddress];\n\n        IOracleMaster(ORACLE_MASTER).removeLedger(_ledgerAddress);\n\n        vKSM.approve(address(ledger), 0);\n\n        emit LedgerRemove(_ledgerAddress);\n    }\n\n    /**\n    * @notice Nominate on behalf of gived stash account, allowed to call only by ROLE_STAKE_MANAGER\n    * @dev Method spawns xcm call to relaychain\n    * @param _stashAccount - target stash account id\n    * @param _validators - validators set to be nominated\n    */\n    function nominate(bytes32 _stashAccount, bytes32[] calldata _validators) external auth(ROLE_STAKE_MANAGER) {\n        require(ledgerByStash[_stashAccount] != address(0),  \"UNKNOWN_STASH_ACCOUNT\");\n\n        ILedger(ledgerByStash[_stashAccount]).nominate(_validators);\n    }\n\n    /**\n    * @notice Deposit vKSM tokens to the pool and recieve stKSM(liquid staked tokens) instead.\n              User should approve tokens before executing this call.\n    * @dev Method accoumulate vKSMs on contract\n    * @param _amount - amount of vKSM tokens to be deposited\n    */\n    function deposit(uint256 _amount) external whenNotPaused {\n        vKSM.transferFrom(msg.sender, address(this), _amount);\n\n        _submit(_amount);\n\n        emit Deposited(msg.sender, _amount);\n    }\n\n    /**\n    * @notice Create request to redeem vKSM in exchange of stKSM. stKSM will be instantly burned and\n              created claim order, (see `getUnbonded` method).\n              User can have up to 10 redeem requests in parallel.\n    * @param _amount - amount of stKSM tokens to be redeemed\n    */\n    function redeem(uint256 _amount) external whenNotPaused {\n        uint256 _shares = getSharesByPooledKSM(_amount);\n        require(_shares <= _sharesOf(msg.sender), \"LIDO: REDEEM_AMOUNT_EXCEEDS_BALANCE\");\n        require(claimOrders[msg.sender].length < MAX_CLAIMS, \"LIDO: MAX_CLAIMS_EXCEEDS\");\n\n        _burnShares(msg.sender, _shares);\n        fundRaisedBalance -= _amount;\n        bufferedRedeems += _amount;\n\n        Claim memory newClaim = Claim(_amount, uint64(block.timestamp) + RELAY_SPEC.unbondingPeriod);\n        claimOrders[msg.sender].push(newClaim);\n        pendingClaimsTotal += _amount;\n\n        // emit event about burning (compatible with ERC20)\n        emit Transfer(msg.sender, address(0), _amount);\n\n        // lido event about redeemed\n        emit Redeemed(msg.sender, _amount);\n    }\n\n    /**\n    * @notice Claim all unbonded tokens at this point of time. Executed redeem requests will be removed\n              and approproate amount of vKSM transferred to calling account.\n    */\n    function claimUnbonded() external whenNotPaused {\n        uint256 readyToClaim = 0;\n        uint256 readyToClaimCount = 0;\n        Claim[] storage orders = claimOrders[msg.sender];\n\n        for (uint256 i = 0; i < orders.length; ++i) {\n            if (orders[i].timeout < block.timestamp) {\n                readyToClaim += orders[i].balance;\n                readyToClaimCount += 1;\n            }\n            else {\n                orders[i - readyToClaimCount] = orders[i];\n            }\n        }\n\n        // remove claimed items\n        for (uint256 i = 0; i < readyToClaimCount; ++i) { orders.pop(); }\n\n        if (readyToClaim > 0) {\n            vKSM.transfer(msg.sender, readyToClaim);\n            pendingClaimsTotal -= readyToClaim;\n            emit Claimed(msg.sender, readyToClaim);\n        }\n    }\n\n    /**\n    * @notice Distribute rewards earned by ledger, allowed to call only by ledger\n    */\n    function distributeRewards(uint256 _totalRewards, uint256 ledgerBalance) external {\n        require(ledgerByAddress[msg.sender] != 0, \"LIDO: NOT_FROM_LEDGER\");\n\n        Types.Fee memory _fee = FEE;\n\n        // it's `feeDevelopers` + `feeTreasure`\n        uint256 _feeDevTreasure = uint256(_fee.developers + _fee.treasury);\n        assert(_feeDevTreasure>0);\n\n        fundRaisedBalance += _totalRewards;\n\n        if (ledgerShares[msg.sender] > 0) {\n            ledgerStake[msg.sender] += _totalRewards;\n        }\n\n        uint256 _rewards = _totalRewards * _feeDevTreasure / uint256(10000 - _fee.operators);\n        uint256 shares2mint = _rewards * _getTotalShares() / (_getTotalPooledKSM()  - _rewards);\n\n        _mintShares(treasury, shares2mint);\n\n        uint256 _devShares = shares2mint *  uint256(_fee.developers) / _feeDevTreasure;\n        _transferShares(treasury, developers, _devShares);\n        _emitTransferAfterMintingShares(developers, _devShares);\n        _emitTransferAfterMintingShares(treasury, shares2mint - _devShares);\n\n        emit Rewards(msg.sender, _totalRewards, ledgerBalance);\n    }\n\n    /**\n    * @notice Distribute lossed by ledger, allowed to call only by ledger\n    */\n    function distributeLosses(uint256 _totalLosses, uint256 ledgerBalance) external {\n        require(ledgerByAddress[msg.sender] != 0, \"LIDO: NOT_FROM_LEDGER\");\n\n        fundRaisedBalance -= _totalLosses;\n        if (ledgerShares[msg.sender] > 0) {\n            ledgerStake[msg.sender] -= _totalLosses;\n        }\n\n        emit Losses(msg.sender, _totalLosses, ledgerBalance);\n    }\n\n    /**\n    * @notice Flush stakes, allowed to call only by oracle master\n    * @dev This method distributes buffered stakes between ledgers by soft manner\n    */\n    function flushStakes() external {\n        require(msg.sender == ORACLE_MASTER, \"LIDO: NOT_FROM_ORACLE_MASTER\");\n\n        _softRebalanceStakes();\n    }\n\n    /**\n    * @notice Force rebalance stake accross ledgers, allowed to call only by ROLE_STAKE_MANAGER\n    * @dev In some cases(due to rewards distribution) real ledger stakes can become different\n           from stakes calculated around ledger shares, so that method fixes that lag.\n    */\n    function forceRebalanceStake() external auth(ROLE_STAKE_MANAGER) {\n        _forceRebalanceStakes();\n\n        bufferedDeposits = 0;\n        bufferedRedeems = 0;\n    }\n\n    /**\n    * @notice Refresh allowance for each ledger, allowed to call only by ROLE_LEDGER_MANAGER\n    */\n    function refreshAllowances() external auth(ROLE_LEDGER_MANAGER) {\n        uint _length = ledgers.length;\n        for (uint i = 0; i < _length; i++) {\n            vKSM.approve(ledgers[i], type(uint256).max);\n        }\n    }\n\n    /**\n    * @notice Rebalance stake accross ledgers according their shares.\n    */\n    function _forceRebalanceStakes() internal {\n        uint256 totalStake = getTotalPooledKSM();\n\n        uint256 stakesSum = 0;\n        address nonZeroLedged = address(0);\n        uint _length = ledgers.length;\n        uint256 _ledgerSharesTotal = ledgerSharesTotal;\n        for (uint i = 0; i < _length; i++) {\n            uint256 share = ledgerShares[ledgers[i]];\n            uint256 stake = totalStake * share / _ledgerSharesTotal;\n\n            stakesSum += stake;\n            ledgerStake[ledgers[i]] = stake;\n\n            if (share > 0 && nonZeroLedged == address(0)) {\n                nonZeroLedged = ledgers[i];\n            }\n        }\n\n        // need to compensate remainder of integer division\n        // if we have at least one non zero ledger\n        uint256 remainingDust = totalStake - stakesSum;\n        if (remainingDust > 0 && nonZeroLedged != address(0)) {\n            ledgerStake[nonZeroLedged] += remainingDust;\n        }\n    }\n\n    /**\n    * @notice Rebalance stake accross ledgers according their shares.\n    */\n    function _softRebalanceStakes() internal {\n        if (bufferedDeposits > 0 || bufferedRedeems > 0) {\n            _distribute(bufferedDeposits.toInt256() - bufferedRedeems.toInt256());\n\n            bufferedDeposits = 0;\n            bufferedRedeems = 0;\n        }\n    }\n\n    function _distribute(int256 _stake) internal {\n        uint256 ledgersLength = ledgers.length;\n\n        int256[] memory diffs = new int256[](ledgersLength);\n        address[] memory ledgersCache = new address[](ledgersLength);\n        int256[] memory ledgerStakesCache = new int256[](ledgersLength);\n        uint256[] memory ledgerSharesCache = new uint256[](ledgersLength);\n\n        int256 activeDiffsSum = 0;\n        int256 totalChange = 0;\n\n        {\n            uint256 totalStake = getTotalPooledKSM();\n            uint256 _ledgerSharesTotal = ledgerSharesTotal;\n            int256 diff = 0;\n            for (uint256 i = 0; i < ledgersLength; ++i) {\n                ledgersCache[i] = ledgers[i];\n                ledgerStakesCache[i] = int256(ledgerStake[ledgersCache[i]]);\n                ledgerSharesCache[i] = ledgerShares[ledgersCache[i]];\n\n                uint256 targetStake = totalStake * ledgerSharesCache[i] / _ledgerSharesTotal;\n                diff = int256(targetStake) - int256(ledgerStakesCache[i]);\n                if (_stake * diff > 0) {\n                    activeDiffsSum += diff;\n                }\n                diffs[i] = diff;\n            }\n        }\n\n\n        if (activeDiffsSum != 0) {\n            int8 direction = 1;\n            if (activeDiffsSum < 0) {\n                direction = -1;\n                activeDiffsSum = -activeDiffsSum;\n            }\n\n            for (uint256 i = 0; i < ledgersLength; ++i) {\n                diffs[i] *= direction;\n                if (diffs[i] > 0 && (direction < 0 || ledgerSharesCache[i] > 0)) {\n                    int256 change = diffs[i] * _stake / activeDiffsSum;\n                    int256 newStake = ledgerStakesCache[i] + change;\n                    ledgerStake[ledgersCache[i]] = uint256(newStake);\n                    ledgerStakesCache[i] = newStake;\n                    totalChange += change;\n                }\n            }\n        }\n\n        {\n            int256 remaining = _stake - totalChange;\n            if (remaining > 0) {\n                for (uint256 i = 0; i < ledgersLength; ++i) {\n                    if (ledgerSharesCache[i] > 0) {\n                        ledgerStake[ledgersCache[i]] += uint256(remaining);\n                        break;\n                    }\n                }\n            }\n            else if (remaining < 0) {\n                for (uint256 i = 0; i < ledgersLength || remaining < 0; ++i) {\n                    uint256 stake = uint256(ledgerStakesCache[i]);\n                    if (stake > 0) {\n                        uint256 decrement = stake > uint256(-remaining) ? uint256(-remaining) : stake;\n                        ledgerStake[ledgersCache[i]] -= decrement;\n                        remaining += int256(decrement);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n    * @notice Process user deposit, mints stKSM and increase the pool buffer\n    * @return amount of stKSM shares generated\n    */\n    function _submit(uint256 _deposit) internal returns (uint256) {\n        address sender = msg.sender;\n\n        require(_deposit != 0, \"LIDO: ZERO_DEPOSIT\");\n\n        uint256 sharesAmount = getSharesByPooledKSM(_deposit);\n        if (sharesAmount == 0) {\n            // totalPooledKSM is 0: either the first-ever deposit or complete slashing\n            // assume that shares correspond to KSM as 1-to-1\n            sharesAmount = _deposit;\n        }\n\n        fundRaisedBalance += _deposit;\n        bufferedDeposits += _deposit;\n        _mintShares(sender, sharesAmount);\n\n        _emitTransferAfterMintingShares(sender, sharesAmount);\n        return sharesAmount;\n    }\n\n\n    /**\n    * @notice Emits an {Transfer} event where from is 0 address. Indicates mint events.\n    */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        emit Transfer(address(0), _to, getPooledKSMByShares(_sharesAmount));\n    }\n\n    /**\n    * @notice Returns amount of total pooled tokens by contract.\n    * @return amount of pooled vKSM in contract\n    */\n    function _getTotalPooledKSM() internal view override returns (uint256) {\n        return fundRaisedBalance;\n    }\n}"
    }
  ]
}