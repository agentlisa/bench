{
  "Title": "[M-24] Unstaking `vMAIA` tokens on the first Tuesday of the month can be offset",
  "Content": "\nAccording to [project documentation](https://v2-docs.maiadao.io/protocols/overview/tokenomics/vMaia) and [natspec](https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/vMaia.sol#L23-L24):\n\n> Users can stake their MAIA tokens at any time, but can only withdraw their staked tokens on the first Tuesday of each month.\n\n> *NOTE: Withdraw is only allowed once per month, during the 1st Tuesday (UTC+0) of the month.*\n\nThe implementation that keeps the above invariant true is dependent on at least one user attempting to unstake their `vMAIA` on the first chronological Tuesday of the month. But if nobody unstakes on the first Tuesday, then, on the second Tuesday of the month, the conditions are met and users can unstake them. Again, if no one unstakes on the second Tuesday, then the next Tuesday after that will be valid. So on and so forth.\n\nNot respecting the declared withdraw/unstaking period and limitation is a severe protocol issue in itself. The case is also not that improbable to happen. If good enough incentives are present, there will be odd Tuesdays where nobody will unstake, thus creating this loophole.\n\n### Issue details\n\n`vMAIA` is an `ERC4626` vault compliant contract ([`vMAIA`](https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/vMaia.sol#L26) -> [`ERC4626PartnerManager`](https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/tokens/ERC4626PartnerManager.sol#L22) -> [`ERC4626`](https://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626.sol)). `ERC4626::withdraw` has a [beforeWithdraw](https://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626.sol#L70) hook `callback` that is overwritten/implemented in [vMAIA::beforeWithdraw](https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/vMaia.sol#L97-L114).\n\n```Solidity\n    /**\n     * @notice Function that performs the necessary verifications before a user can withdraw from their vMaia position.\n     *  Checks if we're inside the unstaked period, if so then the user is able to withdraw.\n     * If we're not in the unstake period, then there will be checks to determine if this is the beginning of the month.\n     */\n    function beforeWithdraw(uint256, uint256) internal override {\n        /// @dev Check if unstake period has not ended yet, continue if it is the case.\n        if (unstakePeriodEnd >= block.timestamp) return;\n\n\n        uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);\n        if (_currentMonth == currentMonth) revert UnstakePeriodNotLive();\n\n\n        (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);\n        if (!isTuesday) revert UnstakePeriodNotLive();\n\n\n        currentMonth = _currentMonth;\n        unstakePeriodEnd = _unstakePeriodStart + 1 days;\n    }\n```\n\nBy thoroughly analyzing the function we can see that:\n\n- It first checks if the unstake period has not ended. The unstake period is 24h since the start of Tuesday. On the first call for the contract this is `0`, so execution continues:\n\n```Solidity\n        /// @dev Check if unstake period has not ended yet, continue if it is the case.\n        if (unstakePeriodEnd >= block.timestamp) return;\n```\n\n- It then gets to the current month and compares it to the last saved `currentMonth`. The `currentMonth` is set only after the Tuesday condition is met. Doing it this way, they ensure that after a Tuesday was validated, no further unstakes can happen in the same month.\n\n```Solidity\n        uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);\n        if (_currentMonth == currentMonth) revert UnstakePeriodNotLive();\n```\n\n- The next operation is to determine if \"now\" is a Tuesday and also to return to the start of the current day (this is to be used in determining the unstake period). To note here, is that it's only checking if \"it is a Tuesday\", **not the first Tuesday of the month**, rather. Up until now, the check is **this is the first Tuesday in a month that was noted by this execution**.\n\n```Solidity\n        (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);\n        if (!isTuesday) revert UnstakePeriodNotLive();\n```\n\n- After checking that we are in the first **marked** Tuesday of this month, the current month is noted (saved to `currentMonth`), and the unstake period is defined as the entire day (24 hours since the start of Tuesday).\n\n```Solidity\n        currentMonth = _currentMonth;\n        unstakePeriodEnd = _unstakePeriodStart + 1 days;\n```\n\nTo conclude the flow, the withdrawal limitation is actually:\n\n- In a given month, on the first Tuesday where users attempt to withdraw, and only on that Tuesday, will withdrawals be allowed. It can be the last Tuesday of the month or the first Tuesday of the month.\n\n### Proof of Concept\n\nAdd the following coded POC to `test\\maia\\vMaiaTest.t.sol` and run it with `forge test --match-test testWithdrawMaiaWorksOnAnyThursday -vvv`:\n\n```Solidity\n\n    import {DateTimeLib as MaiaDateTimeLib} from \"@maia/Libraries/DateTimeLib.sol\"; // add this next to the other imports\n\n    function testWithdrawMaiaWorksOnAnyThursday() public {\n        testDepositMaia();\n        uint256 amount = 100 ether;\n\n        // we now are in the first Tuesday of the month (ignore the name, getFirstDayOfNextMonthUnix gets the first Tuesday of the month)\n        hevm.warp(getFirstDayOfNextMonthUnix());\n\n        // sanity check that we are actually in a Tuesday\n        (bool isTuesday_, ) = MaiaDateTimeLib.isTuesday(block.timestamp);\n        assertTrue(isTuesday_);\n\n        // no withdraw is done, and then the next Tuesday comes\n        hevm.warp(block.timestamp + 7 days);\n\n        // sanity check that we are actually in a Tuesday, again\n        (isTuesday_, ) = MaiaDateTimeLib.isTuesday(block.timestamp);\n        assertTrue(isTuesday_);\n\n        // withdraw succeeds even if we are NOT in the first Tuesday of the month, but in the second one\n        vmaia.withdraw(amount, address(this), address(this));\n\n        assertEq(maia.balanceOf(address(vmaia)), 0);\n        assertEq(vmaia.balanceOf(address(this)), 0);\n    }\n```\n\n### Tools Used\n\nChatGPT for the `isFirstTuesdayOfMonth` function optimizations.\n\n### Recommended Mitigation Steps\n\nModify the `isTuesday` function into a `isFirstTuesdayOfMonth` function. Which is a function that checks the given timestamp is in the first Tuesday of its containing month.\n\nExample implementation:\n\n```Solidity\n    /// @dev Returns if the provided timestamp is in the first Tuesday of it's corresponding month (result) and (startOfDay);\n    ///      startOfDay will always by the timestamp of the first Tuesday found searching from the given timestamp,     \n    ///      regardless if it's the first of the month or not, so always check result if using it\n    function isFirstTuesdayOfMonth(uint256 timestamp) internal pure returns (bool result, uint256 startOfDay) {\n        uint256 month = getMonth(timestamp);\n        uint256 firstDayOfMonth = timestamp - ((timestamp % 86400) + 1) * 86400;\n        \n        uint256 dayIndex = ((firstDayOfMonth / 86400 + 3) % 7) + 1; // Monday: 1, Tuesday: 2, ....., Sunday: 7.\n        uint256 daysToAddToReachNextTuesday = (9 - dayIndex) % 7;\n\n        startOfDay = firstDayOfMonth + daysToAddToReachNextTuesday * 86400;\n        result = (startOfDay <= timestamp && timestamp < startOfDay + 86400) && month == getMonth(startOfDay);\n    }\n\n```\n\n### Assessed type\n\nTiming\n\n**[alexxander (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/469#issuecomment-1653409740):**\n > It is unrealistic to believe that absolutely no one will unstake their tokens. Even then, there wouldn't be any loss of funds. I'd consider QA or Low impact.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/469#issuecomment-1653440145):**\n > The rationalization for impact is well stated in [#396](https://github.com/code-423n4/2023-05-maia-findings/issues/396).\n\n**[0xLightt (Maia) acknowledged and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/469#issuecomment-1655674784):**\n > We are not addressing this because it will never happen in a realistic scenario. It is safe to assume at least one person will withdraw and we will do it ourselves if that doesn't happen. Will update docs and comments to state that it is the first Tuesday of every month that someone withdraws and not only the first Tuesday of every month.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/maia/vMaia.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesVotes as vMaiaVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {DateTimeLib} from \"./libraries/DateTimeLib.sol\";\nimport {ERC4626PartnerManager, PartnerManagerFactory} from \"./tokens/ERC4626PartnerManager.sol\";\n\n/**\n * @title vMaia: Yield bearing, boosting, voting, and gauge enabled MAIA\n * @author Maia DAO (https://github.com/Maia-DAO)\n * @notice vMaia is an ERC-4626 compliant MAIA token which:\n *         distributes bHermes utility tokens (Weight, Governance) and Maia Governance\n *         in exchange for staking MAIA.\n *\n *         NOTE: Withdraw is only allowed once per month,\n *               during the 1st Tuesday (UTC+0) of the month.\n */\ncontract vMaia is ERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         vMAIA STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 private currentMonth;\n    uint256 private unstakePeriodEnd;\n\n    /**\n     * @notice Initializes the vMaia token.\n     * @param _factory The factory that created this contract.\n     * @param _bHermesRate The rate at which bHermes can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get vMaia.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of the token.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    ) ERC4626PartnerManager(_factory, _bHermesRate, _partnerAsset, _name, _symbol, _bhermes, _partnerVault, _owner) {\n        // Set the current month to the current month.\n        currentMonth = DateTimeLib.getMonth(block.timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for the call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for the call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for the call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Boost can't be claimed; does not fail. It is all used by the partner vault.\n    function claimBoost(uint256 amount) public override {}\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function that performs the necessary verifications before a user can withdraw from their vMaia position.\n     *  Checks if we're inside the unstaked period, if so then the user is able to withdraw.\n     * If we're not in the unstake period, then there will be checks to determine if this is the beginning of the month.\n     */\n    function beforeWithdraw(uint256, uint256) internal override {\n        /// @dev Check if unstake period has not ended yet, continue if it is the case.\n        if (unstakePeriodEnd >= block.timestamp) return;\n\n        uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);\n        if (_currentMonth == currentMonth) revert UnstakePeriodNotLive();\n\n        (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);\n        if (!isTuesday) revert UnstakePeriodNotLive();\n\n        currentMonth = _currentMonth;\n        unstakePeriodEnd = _unstakePeriodStart + 1 days;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Error thrown when trying to withdraw and it is not the first Tuesday of the month.\n    error UnstakePeriodNotLive();\n}"
    },
    {
      "filename": "src/maia/vMaia.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {bHermesVotes as vMaiaVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {DateTimeLib} from \"./libraries/DateTimeLib.sol\";\nimport {ERC4626PartnerManager, PartnerManagerFactory} from \"./tokens/ERC4626PartnerManager.sol\";\n\n/**\n * @title vMaia: Yield bearing, boosting, voting, and gauge enabled MAIA\n * @author Maia DAO (https://github.com/Maia-DAO)\n * @notice vMaia is an ERC-4626 compliant MAIA token which:\n *         distributes bHermes utility tokens (Weight, Governance) and Maia Governance\n *         in exchange for staking MAIA.\n *\n *         NOTE: Withdraw is only allowed once per month,\n *               during the 1st Tuesday (UTC+0) of the month.\n */\ncontract vMaia is ERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         vMAIA STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 private currentMonth;\n    uint256 private unstakePeriodEnd;\n\n    /**\n     * @notice Initializes the vMaia token.\n     * @param _factory The factory that created this contract.\n     * @param _bHermesRate The rate at which bHermes can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get vMaia.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of the token.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    ) ERC4626PartnerManager(_factory, _bHermesRate, _partnerAsset, _name, _symbol, _bhermes, _partnerVault, _owner) {\n        // Set the current month to the current month.\n        currentMonth = DateTimeLib.getMonth(block.timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for the call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for the call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for the call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Boost can't be claimed; does not fail. It is all used by the partner vault.\n    function claimBoost(uint256 amount) public override {}\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function that performs the necessary verifications before a user can withdraw from their vMaia position.\n     *  Checks if we're inside the unstaked period, if so then the user is able to withdraw.\n     * If we're not in the unstake period, then there will be checks to determine if this is the beginning of the month.\n     */\n    function beforeWithdraw(uint256, uint256) internal override {\n        /// @dev Check if unstake period has not ended yet, continue if it is the case.\n        if (unstakePeriodEnd >= block.timestamp) return;\n\n        uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);\n        if (_currentMonth == currentMonth) revert UnstakePeriodNotLive();\n\n        (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);\n        if (!isTuesday) revert UnstakePeriodNotLive();\n\n        currentMonth = _currentMonth;\n        unstakePeriodEnd = _unstakePeriodStart + 1 days;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Error thrown when trying to withdraw and it is not the first Tuesday of the month.\n    error UnstakePeriodNotLive();\n}"
    }
  ]
}