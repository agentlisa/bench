{
  "Title": "Incorrect Check in UniswapFlashswapDirectMintHandler",
  "Content": "The check against [`maxResultingDebt`](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L123-L125) in the [`UniswapFlashswapDirectMintHandler` contract](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol) is incorrect and may mislead users. The intent for this handler is to help leverage positions within the wstETH / weETH market. The [`maxResultingDebt` parameter](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L86) is intended to limit the borrowed amount for the user, measured [in terms of the \"base asset\"](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L86).\n\n\nHere, the base asset should be wstETH. However, [the check](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L123-L125) compares this value to an amount of wETH. Since wETH units are worth slightly less than wstETH, this will have the effect of causing reverts more often for users as the threshold for \"max resulting debt\" will be lower than they are anticipating. This will result in a poor user experience overall, as well as potential errors in calculations from trying to convert to a reasonable wstETH value.\n\n\nConsider either changing the docstrings or name of the variable to make it clear that this value represents wETH. Alternatively, consider converting the [`amountWethToFlashloan` value](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L115) to an equivalent value of wstETH before the check.\n\n\n***Update:** Resolved in [pull request #52](https://github.com/Ion-Protocol/ion-protocol/pull/52).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { IWETH9 } from \"../../../interfaces/IWETH9.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport { IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WSTETH_ADDRESS } from \"../../../Constants.sol\";\n\n/**\n * @notice This contract allows for easy creation of leverge positions through a\n * Uniswap flashswap and direct mint of the collateral from the provider. This\n * will be used when the collateral cannot be minted directly with the base\n * asset but can be directly minted by a token that the base asset has a\n * UniswapV3 pool with.\n *\n * This contract is to be used when there exists a UniswapV3 pool between the\n * base asset and the mint asset.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nabstract contract UniswapFlashswapDirectMintHandler is IonHandlerBase, IUniswapV3SwapCallback {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH9;\n    using SafeCast for uint256;\n\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    uint256 private flashloanInitiated = 1;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n    IERC20 public immutable MINT_ASSET;\n    bool private immutable MINT_IS_TOKEN0;\n\n    /**\n     * @notice Creates a new `UniswapFlashswapDirectMintHandler` instance.\n     * @param _uniswapPool Pool to perform the flashswap on.\n     * @param _mintAsset The asset used to mint the collateral.\n     */\n    constructor(IUniswapV3Pool _uniswapPool, IERC20 _mintAsset) {\n        if (address(_uniswapPool) == address(0)) revert InvalidUniswapPool();\n\n        MINT_ASSET = _mintAsset;\n\n        address token0 = _uniswapPool.token0();\n        address token1 = _uniswapPool.token1();\n\n        if (token0 != address(MINT_ASSET) && token1 != address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n        if (token0 == address(MINT_ASSET) && token1 == address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n\n        UNISWAP_POOL = _uniswapPool;\n        MINT_IS_TOKEN0 = token0 == address(MINT_ASSET) ? true : false;\n\n        address baseAsset = MINT_IS_TOKEN0 ? token1 : token0;\n\n        if (baseAsset != address(BASE)) revert InvalidUniswapPool();\n    }\n\n    /**\n     * @notice Transfer collateral from user -> Initiate flashswap between from\n     * base asset to mint asset -> Use the mint asset to mint the collateral ->\n     * Deposit all collateral into `IonPool` -> Borrow the base asset -> Close\n     * the flashswap by sending the base asset to the Uniswap pool.\n     * @param initialDeposit in collateral terms. [WAD]\n     * @param resultingAdditionalCollateral in collateral terms. [WAD]\n     * @param maxResultingDebt in base asset terms. [WAD]\n     * @param proof used to validate the user is whitelisted.\n     */\n    function flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt,\n        uint256 deadline,\n        bytes32[] memory proof\n    )\n        external\n        onlyWhitelistedBorrowers(proof)\n        checkDeadline(deadline)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n        _flashswapAndMint(initialDeposit, resultingAdditionalCollateral, maxResultingDebt);\n    }\n\n    function _flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        internal\n    {\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLrt = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getAmountInForCollateralAmountOut(amountLrt);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        // We want to swap for ETH here\n        bool zeroForOne = MINT_IS_TOKEN0 ? false : true;\n        _initiateFlashSwap({\n            zeroForOne: zeroForOne,\n            amountOut: amountWethToFlashloan,\n            recipient: address(this),\n            data: abi.encode(msg.sender, resultingAdditionalCollateral, initialDeposit)\n        });\n    }\n\n    /**\n     * @notice Handles swap intiation logic. This function can only initiate\n     * exact output swaps.\n     * @param zeroForOne Direction of the swap.\n     * @param amountOut Desired amount of output.\n     * @param recipient of output tokens.\n     * @param data Arbitrary data to be passed through swap callback.\n     */\n    function _initiateFlashSwap(\n        bool zeroForOne,\n        uint256 amountOut,\n        address recipient,\n        bytes memory data\n    )\n        private\n        returns (uint256 amountIn)\n    {\n        (int256 amount0Delta, int256 amount1Delta) = UNISWAP_POOL.swap(\n            recipient, zeroForOne, -amountOut.toInt256(), zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, data\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n\n        // it's technically possible to not receive the full output amount,\n        if (amountOutReceived != amountOut) revert OutputAmountNotReceived(amountOutReceived, amountOut);\n    }\n\n    /**\n     * @notice From the perspective of the pool i.e. Negative amount means pool is\n     * sending. This function is intended to never be called directly. It should\n     * only be called by the Uniswap pool during a swap initiated by this\n     * contract.\n     *\n     * @dev One thing to note from a security perspective is that the pool only calls\n     * the callback on `msg.sender`. So a theoretical attacker cannot call this\n     * function by directing where to call the callback.\n     *\n     * @param amount0Delta change in token0\n     * @param amount1Delta change in token1\n     * @param _data arbitrary data\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        if (msg.sender != address(UNISWAP_POOL)) revert CallbackOnlyCallableByPool(msg.sender);\n\n        // swaps entirely within 0-liquidity regions are not supported\n        if (amount0Delta == 0 && amount1Delta == 0) revert InvalidZeroLiquidityRegionSwap();\n        (address user, uint256 resultingAdditionalCollateral, uint256 initialDeposit) =\n            abi.decode(_data, (address, uint256, uint256));\n\n        // Code below this if statement will always assume token0 is MINT_ASSET. If it\n        // is not actually the case, we will flip the vars\n        if (!MINT_IS_TOKEN0) {\n            (amount0Delta, amount1Delta) = (amount1Delta, amount0Delta);\n        }\n\n        address tokenIn = address(BASE);\n\n        // Sanity check that Uniswap is sending MINT_ASSET\n        assert(amount0Delta < 0 && amount1Delta > 0);\n\n        // MINT_ASSET needs to be converted into collateral asset\n        uint256 collateralFromDeposit = _mintCollateralAsset(uint256(-amount0Delta));\n\n        // Sanity check\n        assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n\n        // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed\n        // to cover the amount owed back to Uniswap\n        _depositAndBorrow(\n            user, address(this), resultingAdditionalCollateral, uint256(amount1Delta), AmountToBorrow.IS_MIN\n        );\n\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount1Delta));\n    }\n\n    /**\n     * @notice Deposits the mint asset into the a provider's collateral asset.\n     * @param amountMintAsset amount of \"mint asset\" to deposit. [WAD]\n     */\n    function _mintCollateralAsset(uint256 amountMintAsset) internal virtual returns (uint256);\n\n    /**\n     * @notice Calculates the amount of eth required to receive `amountLrt`.\n     * @dev Calculates the amount of eth required to receive `amountLrt`.\n     * @param amountLrt Desired output amount. [WAD]\n     * @return Amount mint asset required for desired output. [WAD]\n     */\n    function _getAmountInForCollateralAmountOut(uint256 amountLrt) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { IWETH9 } from \"../../../interfaces/IWETH9.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport { IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WSTETH_ADDRESS } from \"../../../Constants.sol\";\n\n/**\n * @notice This contract allows for easy creation of leverge positions through a\n * Uniswap flashswap and direct mint of the collateral from the provider. This\n * will be used when the collateral cannot be minted directly with the base\n * asset but can be directly minted by a token that the base asset has a\n * UniswapV3 pool with.\n *\n * This contract is to be used when there exists a UniswapV3 pool between the\n * base asset and the mint asset.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nabstract contract UniswapFlashswapDirectMintHandler is IonHandlerBase, IUniswapV3SwapCallback {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH9;\n    using SafeCast for uint256;\n\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    uint256 private flashloanInitiated = 1;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n    IERC20 public immutable MINT_ASSET;\n    bool private immutable MINT_IS_TOKEN0;\n\n    /**\n     * @notice Creates a new `UniswapFlashswapDirectMintHandler` instance.\n     * @param _uniswapPool Pool to perform the flashswap on.\n     * @param _mintAsset The asset used to mint the collateral.\n     */\n    constructor(IUniswapV3Pool _uniswapPool, IERC20 _mintAsset) {\n        if (address(_uniswapPool) == address(0)) revert InvalidUniswapPool();\n\n        MINT_ASSET = _mintAsset;\n\n        address token0 = _uniswapPool.token0();\n        address token1 = _uniswapPool.token1();\n\n        if (token0 != address(MINT_ASSET) && token1 != address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n        if (token0 == address(MINT_ASSET) && token1 == address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n\n        UNISWAP_POOL = _uniswapPool;\n        MINT_IS_TOKEN0 = token0 == address(MINT_ASSET) ? true : false;\n\n        address baseAsset = MINT_IS_TOKEN0 ? token1 : token0;\n\n        if (baseAsset != address(BASE)) revert InvalidUniswapPool();\n    }\n\n    /**\n     * @notice Transfer collateral from user -> Initiate flashswap between from\n     * base asset to mint asset -> Use the mint asset to mint the collateral ->\n     * Deposit all collateral into `IonPool` -> Borrow the base asset -> Close\n     * the flashswap by sending the base asset to the Uniswap pool.\n     * @param initialDeposit in collateral terms. [WAD]\n     * @param resultingAdditionalCollateral in collateral terms. [WAD]\n     * @param maxResultingDebt in base asset terms. [WAD]\n     * @param proof used to validate the user is whitelisted.\n     */\n    function flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt,\n        uint256 deadline,\n        bytes32[] memory proof\n    )\n        external\n        onlyWhitelistedBorrowers(proof)\n        checkDeadline(deadline)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n        _flashswapAndMint(initialDeposit, resultingAdditionalCollateral, maxResultingDebt);\n    }\n\n    function _flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        internal\n    {\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLrt = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getAmountInForCollateralAmountOut(amountLrt);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        // We want to swap for ETH here\n        bool zeroForOne = MINT_IS_TOKEN0 ? false : true;\n        _initiateFlashSwap({\n            zeroForOne: zeroForOne,\n            amountOut: amountWethToFlashloan,\n            recipient: address(this),\n            data: abi.encode(msg.sender, resultingAdditionalCollateral, initialDeposit)\n        });\n    }\n\n    /**\n     * @notice Handles swap intiation logic. This function can only initiate\n     * exact output swaps.\n     * @param zeroForOne Direction of the swap.\n     * @param amountOut Desired amount of output.\n     * @param recipient of output tokens.\n     * @param data Arbitrary data to be passed through swap callback.\n     */\n    function _initiateFlashSwap(\n        bool zeroForOne,\n        uint256 amountOut,\n        address recipient,\n        bytes memory data\n    )\n        private\n        returns (uint256 amountIn)\n    {\n        (int256 amount0Delta, int256 amount1Delta) = UNISWAP_POOL.swap(\n            recipient, zeroForOne, -amountOut.toInt256(), zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, data\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n\n        // it's technically possible to not receive the full output amount,\n        if (amountOutReceived != amountOut) revert OutputAmountNotReceived(amountOutReceived, amountOut);\n    }\n\n    /**\n     * @notice From the perspective of the pool i.e. Negative amount means pool is\n     * sending. This function is intended to never be called directly. It should\n     * only be called by the Uniswap pool during a swap initiated by this\n     * contract.\n     *\n     * @dev One thing to note from a security perspective is that the pool only calls\n     * the callback on `msg.sender`. So a theoretical attacker cannot call this\n     * function by directing where to call the callback.\n     *\n     * @param amount0Delta change in token0\n     * @param amount1Delta change in token1\n     * @param _data arbitrary data\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        if (msg.sender != address(UNISWAP_POOL)) revert CallbackOnlyCallableByPool(msg.sender);\n\n        // swaps entirely within 0-liquidity regions are not supported\n        if (amount0Delta == 0 && amount1Delta == 0) revert InvalidZeroLiquidityRegionSwap();\n        (address user, uint256 resultingAdditionalCollateral, uint256 initialDeposit) =\n            abi.decode(_data, (address, uint256, uint256));\n\n        // Code below this if statement will always assume token0 is MINT_ASSET. If it\n        // is not actually the case, we will flip the vars\n        if (!MINT_IS_TOKEN0) {\n            (amount0Delta, amount1Delta) = (amount1Delta, amount0Delta);\n        }\n\n        address tokenIn = address(BASE);\n\n        // Sanity check that Uniswap is sending MINT_ASSET\n        assert(amount0Delta < 0 && amount1Delta > 0);\n\n        // MINT_ASSET needs to be converted into collateral asset\n        uint256 collateralFromDeposit = _mintCollateralAsset(uint256(-amount0Delta));\n\n        // Sanity check\n        assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n\n        // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed\n        // to cover the amount owed back to Uniswap\n        _depositAndBorrow(\n            user, address(this), resultingAdditionalCollateral, uint256(amount1Delta), AmountToBorrow.IS_MIN\n        );\n\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount1Delta));\n    }\n\n    /**\n     * @notice Deposits the mint asset into the a provider's collateral asset.\n     * @param amountMintAsset amount of \"mint asset\" to deposit. [WAD]\n     */\n    function _mintCollateralAsset(uint256 amountMintAsset) internal virtual returns (uint256);\n\n    /**\n     * @notice Calculates the amount of eth required to receive `amountLrt`.\n     * @dev Calculates the amount of eth required to receive `amountLrt`.\n     * @param amountLrt Desired output amount. [WAD]\n     * @return Amount mint asset required for desired output. [WAD]\n     */\n    function _getAmountInForCollateralAmountOut(uint256 amountLrt) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { IWETH9 } from \"../../../interfaces/IWETH9.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport { IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WSTETH_ADDRESS } from \"../../../Constants.sol\";\n\n/**\n * @notice This contract allows for easy creation of leverge positions through a\n * Uniswap flashswap and direct mint of the collateral from the provider. This\n * will be used when the collateral cannot be minted directly with the base\n * asset but can be directly minted by a token that the base asset has a\n * UniswapV3 pool with.\n *\n * This contract is to be used when there exists a UniswapV3 pool between the\n * base asset and the mint asset.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nabstract contract UniswapFlashswapDirectMintHandler is IonHandlerBase, IUniswapV3SwapCallback {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH9;\n    using SafeCast for uint256;\n\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    uint256 private flashloanInitiated = 1;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n    IERC20 public immutable MINT_ASSET;\n    bool private immutable MINT_IS_TOKEN0;\n\n    /**\n     * @notice Creates a new `UniswapFlashswapDirectMintHandler` instance.\n     * @param _uniswapPool Pool to perform the flashswap on.\n     * @param _mintAsset The asset used to mint the collateral.\n     */\n    constructor(IUniswapV3Pool _uniswapPool, IERC20 _mintAsset) {\n        if (address(_uniswapPool) == address(0)) revert InvalidUniswapPool();\n\n        MINT_ASSET = _mintAsset;\n\n        address token0 = _uniswapPool.token0();\n        address token1 = _uniswapPool.token1();\n\n        if (token0 != address(MINT_ASSET) && token1 != address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n        if (token0 == address(MINT_ASSET) && token1 == address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n\n        UNISWAP_POOL = _uniswapPool;\n        MINT_IS_TOKEN0 = token0 == address(MINT_ASSET) ? true : false;\n\n        address baseAsset = MINT_IS_TOKEN0 ? token1 : token0;\n\n        if (baseAsset != address(BASE)) revert InvalidUniswapPool();\n    }\n\n    /**\n     * @notice Transfer collateral from user -> Initiate flashswap between from\n     * base asset to mint asset -> Use the mint asset to mint the collateral ->\n     * Deposit all collateral into `IonPool` -> Borrow the base asset -> Close\n     * the flashswap by sending the base asset to the Uniswap pool.\n     * @param initialDeposit in collateral terms. [WAD]\n     * @param resultingAdditionalCollateral in collateral terms. [WAD]\n     * @param maxResultingDebt in base asset terms. [WAD]\n     * @param proof used to validate the user is whitelisted.\n     */\n    function flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt,\n        uint256 deadline,\n        bytes32[] memory proof\n    )\n        external\n        onlyWhitelistedBorrowers(proof)\n        checkDeadline(deadline)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n        _flashswapAndMint(initialDeposit, resultingAdditionalCollateral, maxResultingDebt);\n    }\n\n    function _flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        internal\n    {\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLrt = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getAmountInForCollateralAmountOut(amountLrt);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        // We want to swap for ETH here\n        bool zeroForOne = MINT_IS_TOKEN0 ? false : true;\n        _initiateFlashSwap({\n            zeroForOne: zeroForOne,\n            amountOut: amountWethToFlashloan,\n            recipient: address(this),\n            data: abi.encode(msg.sender, resultingAdditionalCollateral, initialDeposit)\n        });\n    }\n\n    /**\n     * @notice Handles swap intiation logic. This function can only initiate\n     * exact output swaps.\n     * @param zeroForOne Direction of the swap.\n     * @param amountOut Desired amount of output.\n     * @param recipient of output tokens.\n     * @param data Arbitrary data to be passed through swap callback.\n     */\n    function _initiateFlashSwap(\n        bool zeroForOne,\n        uint256 amountOut,\n        address recipient,\n        bytes memory data\n    )\n        private\n        returns (uint256 amountIn)\n    {\n        (int256 amount0Delta, int256 amount1Delta) = UNISWAP_POOL.swap(\n            recipient, zeroForOne, -amountOut.toInt256(), zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, data\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n\n        // it's technically possible to not receive the full output amount,\n        if (amountOutReceived != amountOut) revert OutputAmountNotReceived(amountOutReceived, amountOut);\n    }\n\n    /**\n     * @notice From the perspective of the pool i.e. Negative amount means pool is\n     * sending. This function is intended to never be called directly. It should\n     * only be called by the Uniswap pool during a swap initiated by this\n     * contract.\n     *\n     * @dev One thing to note from a security perspective is that the pool only calls\n     * the callback on `msg.sender`. So a theoretical attacker cannot call this\n     * function by directing where to call the callback.\n     *\n     * @param amount0Delta change in token0\n     * @param amount1Delta change in token1\n     * @param _data arbitrary data\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        if (msg.sender != address(UNISWAP_POOL)) revert CallbackOnlyCallableByPool(msg.sender);\n\n        // swaps entirely within 0-liquidity regions are not supported\n        if (amount0Delta == 0 && amount1Delta == 0) revert InvalidZeroLiquidityRegionSwap();\n        (address user, uint256 resultingAdditionalCollateral, uint256 initialDeposit) =\n            abi.decode(_data, (address, uint256, uint256));\n\n        // Code below this if statement will always assume token0 is MINT_ASSET. If it\n        // is not actually the case, we will flip the vars\n        if (!MINT_IS_TOKEN0) {\n            (amount0Delta, amount1Delta) = (amount1Delta, amount0Delta);\n        }\n\n        address tokenIn = address(BASE);\n\n        // Sanity check that Uniswap is sending MINT_ASSET\n        assert(amount0Delta < 0 && amount1Delta > 0);\n\n        // MINT_ASSET needs to be converted into collateral asset\n        uint256 collateralFromDeposit = _mintCollateralAsset(uint256(-amount0Delta));\n\n        // Sanity check\n        assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n\n        // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed\n        // to cover the amount owed back to Uniswap\n        _depositAndBorrow(\n            user, address(this), resultingAdditionalCollateral, uint256(amount1Delta), AmountToBorrow.IS_MIN\n        );\n\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount1Delta));\n    }\n\n    /**\n     * @notice Deposits the mint asset into the a provider's collateral asset.\n     * @param amountMintAsset amount of \"mint asset\" to deposit. [WAD]\n     */\n    function _mintCollateralAsset(uint256 amountMintAsset) internal virtual returns (uint256);\n\n    /**\n     * @notice Calculates the amount of eth required to receive `amountLrt`.\n     * @dev Calculates the amount of eth required to receive `amountLrt`.\n     * @param amountLrt Desired output amount. [WAD]\n     * @return Amount mint asset required for desired output. [WAD]\n     */\n    function _getAmountInForCollateralAmountOut(uint256 amountLrt) internal view virtual returns (uint256);\n}"
    }
  ]
}