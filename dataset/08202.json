{
  "Title": "[M-03] Impossible to `setCreationCode()` with code size less than 13K",
  "Content": "_Submitted by 0xA5DF_\n\n<https://github.com/code-423n4/2022-08-frax/blob/92a8d7d331cc718cd64de6b02515b554672fb0f3/src/contracts/FraxlendPairDeployer.sol#L170-L178>\n\n<https://github.com/code-423n4/2022-08-frax/blob/92a8d7d331cc718cd64de6b02515b554672fb0f3/src/contracts/FraxlendPairDeployer.sol#L207-L210>\n\n### Vulnerability Details\n\nIn case of setting the creation code to less than 13K the creation would fail at 2 points:\n\n*   [`BytesLib.slice(_creationCode, 0, 13000)`](https://github.com/code-423n4/2022-08-frax/blob/92a8d7d331cc718cd64de6b02515b554672fb0f3/src/contracts/FraxlendPairDeployer.sol#L171) would fail since `slice()` requires that `_bytes.length` would be at least `start + length`.\n*   [`SSTORE2.read(contractAddress2)`](https://github.com/code-423n4/2022-08-frax/blob/92a8d7d331cc718cd64de6b02515b554672fb0f3/src/contracts/FraxlendPairDeployer.sol#L209) at `_deployFirst()` would fail since calling this on address without code would cause a math underflow (due to [`pointer.code.length - DATA_OFFSET`](https://github.com/code-423n4/2022-08-frax/blob/main/node_modules/@rari-capital/solmate/src/utils/SSTORE2.sol#L51))\n\n### Impact\n\nIn case the code of the pair gets smaller (e.g. optimization, moving part of the code to a library etc.) to 13K or less, it'd be impossible to set it as the new creation code (or in the case of the 2nd issue, it'd be impossible to deploy it).\n\n### Proof of Concept\n\nIn the following test I try to set creation code to a smaller mock pair.\nThe test was added to `src/test/e2e/FraxlendPairDeployerTest.sol`:\n\n```solidity\n    function testChangeCreationCodeBug() public {\n        // Setup contracts\n        setExternalContracts();\n        startHoax(COMPTROLLER_ADDRESS);\n        setWhitelistTrue();\n        vm.stopPrank();\n        console2.log(\"Mock pair size:\", type(MockPair).creationCode.length);\n\n        vm.startPrank(deployer.owner());\n        deployer.setCreationCode(type(MockPair).creationCode);\n\n        // Set initial oracle prices\n        bytes memory _rateInitData = defaultRateInitForLinear();\n        deployer.deploy(\n            abi.encode(\n                address(asset),\n                address(collateral),\n                address(oracleMultiply),\n                address(oracleDivide),\n                1e10,\n                address(linearRateContract),\n                _rateInitData\n            )\n        );\n\n    }\n```\n\nThe mock pair was created as `src/contracts/audit/MockPair.sol`:\n\n````solidity\n// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../FraxlendPairConstants.sol\";\nimport \"../libraries/VaultAccount.sol\";\nimport \"../libraries/SafeERC20.sol\";\nimport \"../interfaces/IERC4626.sol\";\nimport \"../interfaces/IFraxlendWhitelist.sol\";\nimport \"../interfaces/IRateCalculator.sol\";\nimport \"../interfaces/ISwapper.sol\";\n\n/// @title FraxlendPairCore\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\n/// @notice  An abstract contract which contains the core logic and storage for the FraxlendPair\ncontract MockPair is FraxlendPairConstants, ERC20, Ownable, Pausable, ReentrancyGuard {\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    string public version = \"1.0.0\";\n\n    // ============================================================================================\n    // Settings set by constructor() & initialize()\n    // ============================================================================================\n\n    // Asset and collateral contracts\n    IERC20 internal immutable assetContract;\n    IERC20 public immutable collateralContract;\n\n    // Oracle wrapper contract and oracleData\n    address public immutable oracleMultiply;\n    address public immutable oracleDivide;\n    uint256 public immutable oracleNormalization;\n\n    // LTV Settings\n    uint256 public immutable maxLTV;\n\n    // Liquidation Fee\n    uint256 public immutable cleanLiquidationFee;\n    uint256 public immutable dirtyLiquidationFee;\n\n    // Interest Rate Calculator Contract\n    IRateCalculator public immutable rateContract; // For complex rate calculations\n    bytes public rateInitCallData; // Optional extra data from init function to be passed to rate calculator\n\n    // Swapper\n    mapping(address => bool) public swappers; // approved swapper addresses\n\n    // Deployer\n    address public immutable DEPLOYER_ADDRESS;\n\n    // Admin contracts\n    address public immutable CIRCUIT_BREAKER_ADDRESS;\n    address public immutable COMPTROLLER_ADDRESS;\n    address public TIME_LOCK_ADDRESS;\n\n    // Dependencies\n    address public immutable FRAXLEND_WHITELIST_ADDRESS;\n\n    // ERC20 token name, accessible via name()\n    string internal nameOfContract;\n\n    // Maturity Date & Penalty Interest Rate (per Sec)\n    uint256 public immutable maturityDate;\n    uint256 public immutable penaltyRate;\n\n    // ============================================================================================\n    // Storage\n    // ============================================================================================\n\n    /// @notice Stores information about the current interest rate\n    /// @dev struct is packed to reduce SLOADs. feeToProtocolRate is 1e5 precision, ratePerSec is 1e18 precision\n    CurrentRateInfo public currentRateInfo;\n    struct CurrentRateInfo {\n        uint64 lastBlock;\n        uint64 feeToProtocolRate; // Fee amount 1e5 precision\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n    }\n\n    /// @notice Stores information about the current exchange rate. Collateral:Asset ratio\n    /// @dev Struct packed to save SLOADs. Amount of Collateral Token to buy 1e18 Asset Token\n    ExchangeRateInfo public exchangeRateInfo;\n    struct ExchangeRateInfo {\n        uint32 lastTimestamp;\n        uint224 exchangeRate; // collateral:asset ratio. i.e. how much collateral to buy 1e18 asset\n    }\n\n    // Contract Level Accounting\n    VaultAccount public totalAsset; // amount = total amount of assets, shares = total shares outstanding\n    VaultAccount public totalBorrow; // amount = total borrow amount with interest accrued, shares = total shares outstanding\n    uint256 public totalCollateral; // total amount of collateral in contract\n\n    // User Level Accounting\n    /// @notice Stores the balance of collateral for each user\n    mapping(address => uint256) public userCollateralBalance; // amount of collateral each user is backed\n    /// @notice Stores the balance of borrow shares for each user\n    mapping(address => uint256) public userBorrowShares; // represents the shares held by individuals\n    // NOTE: user shares of assets are represented as ERC-20 tokens and accessible via balanceOf()\n\n    // Internal Whitelists\n    bool public immutable borrowerWhitelistActive;\n    mapping(address => bool) public approvedBorrowers;\n\n    bool public immutable lenderWhitelistActive;\n    mapping(address => bool) public approvedLenders;\n    event Fine(uint256 line);\n    // ============================================================================================\n    // Initialize\n    // ============================================================================================\n\n    /// @notice The ```constructor``` function is called on deployment\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate date of the Pair\n    /// @param _penaltyRate The interest rate after maturity date\n    /// @param _isBorrowerWhitelistActive Enables borrower whitelist\n    /// @param _isLenderWhitelistActive Enables lender whitelist\n    constructor(\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    )  ERC20(\"\", \"\") {\n        // Handle Immutables Configuration\n        {\n            (\n                address _circuitBreaker,\n                address _comptrollerAddress,\n                address _timeLockAddress,\n                address _fraxlendWhitelistAddress\n            ) = abi.decode(_immutables, (address, address, address, address));\n\n            // Deployer contract\n            DEPLOYER_ADDRESS = msg.sender;\n            CIRCUIT_BREAKER_ADDRESS = _circuitBreaker;\n            COMPTROLLER_ADDRESS = _comptrollerAddress;\n            TIME_LOCK_ADDRESS = _timeLockAddress;\n            FRAXLEND_WHITELIST_ADDRESS = _fraxlendWhitelistAddress;\n        }\n        emit Fine(177);\n        {\n            (\n                address _asset,\n                address _collateral,\n                address _oracleMultiply,\n                address _oracleDivide,\n                uint256 _oracleNormalization,\n                address _rateContract,\n\n            ) = abi.decode(_configData, (address, address, address, address, uint256, address, bytes));\n\n            // Pair Settings\n            assetContract = IERC20(_asset);\n            collateralContract = IERC20(_collateral);\n            currentRateInfo.feeToProtocolRate = DEFAULT_PROTOCOL_FEE;\n            cleanLiquidationFee = _liquidationFee;\n            dirtyLiquidationFee = (_liquidationFee * 9000) / LIQ_PRECISION; // 90% of clean fee\n\n            if (_maxLTV >= LTV_PRECISION && !_isBorrowerWhitelistActive) revert BorrowerWhitelistRequired();\n            maxLTV = _maxLTV;\n\n            // Swapper Settings\n            swappers[FRAXSWAP_ROUTER_ADDRESS] = true;\n\n            // Oracle Settings\n            {\n                IFraxlendWhitelist _fraxlendWhitelist = IFraxlendWhitelist(FRAXLEND_WHITELIST_ADDRESS);\n                // Check that oracles are on the whitelist\n                if (_oracleMultiply != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleMultiply)) {\n                    revert NotOnWhitelist(_oracleMultiply);\n                }\n\n                if (_oracleDivide != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleDivide)) {\n                    revert NotOnWhitelist(_oracleDivide);\n                }\n\n                // Write oracleData to storage\n                oracleMultiply = _oracleMultiply;\n                oracleDivide = _oracleDivide;\n                oracleNormalization = _oracleNormalization;\n\n                // Rate Settings\n                if (!_fraxlendWhitelist.rateContractWhitelist(_rateContract)) {\n                    revert NotOnWhitelist(_rateContract);\n                }\n            }\n\n            rateContract = IRateCalculator(_rateContract);\n        }\n        emit Fine(177);\n\n\n        // Set approved borrowers whitelist\n        borrowerWhitelistActive = _isBorrowerWhitelistActive;\n\n        // Set approved lenders whitlist active\n        lenderWhitelistActive = _isLenderWhitelistActive;\n\n        // Set maturity date & penalty interest rate\n        maturityDate = _maturityDate;\n        penaltyRate = _penaltyRate;\n    }\n\n\n    function initialize(\n        string calldata _name,\n        address[] calldata _approvedBorrowers,\n        address[] calldata _approvedLenders,\n        bytes calldata _rateInitCallData\n    ) external {\n    }\n\n}\n\n\n````\n\n### Recommended Mitigation Steps\n\nIf creation code length is 13K or less:\n\n*   Don't run `BytesLib.slice()`\n*   At deployment read only from the first address\n\n**[DrakeEvans (Frax) acknowledged](https://github.com/code-423n4/2022-08-frax-findings/issues/153)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-08-frax",
  "Code": [
    {
      "filename": "src/contracts/FraxlendPairDeployer.sol",
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ====================== FraxlendPairDeployer ========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@rari-capital/solmate/src/utils/SSTORE2.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IFraxlendPair.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\n// solhint-disable no-inline-assembly\n\n/// @title FraxlendPairDeployer\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\n/// @notice Deploys and initializes new FraxlendPairs\n/// @dev Uses create2 to deploy the pairs, logs an event, and records a list of all deployed pairs\ncontract FraxlendPairDeployer is Ownable {\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n\n    // Constants\n    uint256 public DEFAULT_MAX_LTV = 75000; // 75% with 1e5 precision\n    uint256 public GLOBAL_MAX_LTV = 1e8; // 1000x (100,000%) with 1e5 precision, protects from rounding errors in LTV calc\n    uint256 public DEFAULT_LIQ_FEE = 10000; // 10% with 1e5 precision\n\n    address private contractAddress1;\n    address private contractAddress2;\n\n    // Admin contracts\n    address public CIRCUIT_BREAKER_ADDRESS;\n    address public COMPTROLLER_ADDRESS;\n    address public TIME_LOCK_ADDRESS;\n\n    // Dependencies\n    address private immutable FRAXLEND_WHITELIST_ADDRESS;\n\n    /// @notice Emits when a new pair is deployed\n    /// @notice The ```LogDeploy``` event is emitted when a new Pair is deployed\n    /// @param _name The name of the Pair\n    /// @param _address The address of the pair\n    /// @param _asset The address of the Asset Token contract\n    /// @param _collateral The address of the Collateral Token contract\n    /// @param _oracleMultiply The address of the numerator price Oracle\n    /// @param _oracleDivide The address of the denominator price Oracle\n    /// @param _rateContract The address of the Rate Calculator contract\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    event LogDeploy(\n        string indexed _name,\n        address _address,\n        address indexed _asset,\n        address indexed _collateral,\n        address _oracleMultiply,\n        address _oracleDivide,\n        address _rateContract,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate\n    );\n\n    /// @notice CREATE2 salt => deployed address\n    mapping(bytes32 => address) public deployedPairsBySalt;\n    /// @notice hash of name => deployed address\n    mapping(string => address) public deployedPairsByName;\n    /// @notice address => isCustom boolean\n    mapping(address => bool) public deployedPairCustomStatusByAddress;\n    /// @notice List of the names of all deployed Pairs\n    string[] public deployedPairsArray;\n\n    constructor(\n        address _circuitBreaker,\n        address _comptroller,\n        address _timelock,\n        address _fraxlendWhitelist\n    ) Ownable() {\n        CIRCUIT_BREAKER_ADDRESS = _circuitBreaker;\n        COMPTROLLER_ADDRESS = _comptroller;\n        TIME_LOCK_ADDRESS = _timelock;\n        FRAXLEND_WHITELIST_ADDRESS = _fraxlendWhitelist;\n    }\n\n    // ============================================================================================\n    // Functions: View Functions\n    // ============================================================================================\n\n    /// @notice The ```deployedPairsLength``` function returns the length of the deployedPairsArray\n    /// @return length of array\n    function deployedPairsLength() external view returns (uint256) {\n        return deployedPairsArray.length;\n    }\n\n    /// @notice The ```getAllPairAddresses``` function returns all pair addresses in deployedPairsArray\n    /// @return memory All deployed pair addresses\n    function getAllPairAddresses() external view returns (address[] memory) {\n        string[] memory _deployedPairsArray = deployedPairsArray;\n        uint256 _lengthOfArray = _deployedPairsArray.length;\n        address[] memory _addresses = new address[](_lengthOfArray);\n        uint256 i;\n        for (i = 0; i < _lengthOfArray; ) {\n            _addresses[i] = deployedPairsByName[_deployedPairsArray[i]];\n            unchecked {\n                i++;\n            }\n        }\n        return _addresses;\n    }\n\n    struct PairCustomStatus {\n        address _address;\n        bool _isCustom;\n    }\n\n    /// @notice The ```getCustomStatuses``` function returns an array of structs which contain the address and custom status\n    /// @param _addresses Addresses to check for custom status\n    /// @return _pairCustomStatuses memory Array of structs containing information\n    function getCustomStatuses(address[] calldata _addresses)\n        external\n        view\n        returns (PairCustomStatus[] memory _pairCustomStatuses)\n    {\n        uint256 _lengthOfArray = _addresses.length;\n        uint256 i;\n        _pairCustomStatuses = new PairCustomStatus[](_lengthOfArray);\n        for (i = 0; i < _lengthOfArray; ) {\n            _pairCustomStatuses[i] = PairCustomStatus({\n                _address: _addresses[i],\n                _isCustom: deployedPairCustomStatusByAddress[_addresses[i]]\n            });\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    // ============================================================================================\n    // Functions: Setters\n    // ============================================================================================\n\n    /// @notice The ```setCreationCode``` function sets the bytecode for the fraxlendPair\n    /// @dev splits the data if necessary to accomodate creation code that is slightly larger than 24kb\n    /// @param _creationCode The creationCode for the Fraxlend Pair\n    function setCreationCode(bytes calldata _creationCode) external onlyOwner {\n        bytes memory _firstHalf = BytesLib.slice(_creationCode, 0, 13000);\n        contractAddress1 = SSTORE2.write(_firstHalf);\n        if (_creationCode.length > 13000) {\n            bytes memory _secondHalf = BytesLib.slice(_creationCode, 13000, _creationCode.length - 13000);\n            contractAddress2 = SSTORE2.write(_secondHalf);\n        }\n    }\n\n    // ============================================================================================\n    // Functions: Internal Methods\n    // ============================================================================================\n\n    /// @notice The ```_deployFirst``` function is an internal function with deploys the pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    /// @param _isBorrowerWhitelistActive Enables borrower whitelist\n    /// @param _isLenderWhitelistActive Enables lender whitelist\n    /// @return _pairAddress The address to which the Pair was deployed\n    function _deployFirst(\n        bytes32 _saltSeed,\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    ) private returns (address _pairAddress) {\n        {\n            // _saltSeed is the same for all public pairs so duplicates cannot be created\n            bytes32 salt = keccak256(abi.encodePacked(_saltSeed, _configData));\n            require(deployedPairsBySalt[salt] == address(0), \"FraxlendPairDeployer: Pair already deployed\");\n\n            bytes memory _creationCode = BytesLib.concat(\n                SSTORE2.read(contractAddress1),\n                SSTORE2.read(contractAddress2)\n            );\n            bytes memory bytecode = abi.encodePacked(\n                _creationCode,\n                abi.encode(\n                    _configData,\n                    _immutables,\n                    _maxLTV,\n                    _liquidationFee,\n                    _maturityDate,\n                    _penaltyRate,\n                    _isBorrowerWhitelistActive,\n                    _isLenderWhitelistActive\n                )\n            );\n\n            assembly {\n                _pairAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\n            }\n            require(_pairAddress != address(0), \"FraxlendPairDeployer: create2 failed\");\n\n            deployedPairsBySalt[salt] = _pairAddress;\n        }\n\n        return _pairAddress;\n    }\n\n    /// @notice The ```_deploySecond``` function is the second part of deployment, it invoked the initialize() on the Pair\n    /// @param _name The name of the Pair\n    /// @param _pairAddress The address of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    function _deploySecond(\n        string memory _name,\n        address _pairAddress,\n        bytes memory _configData,\n        address[] memory _approvedBorrowers,\n        address[] memory _approvedLenders\n    ) private {\n        (, , , , , , bytes memory _rateInitData) = abi.decode(\n            _configData,\n            (address, address, address, address, uint256, address, bytes)\n        );\n        require(deployedPairsByName[_name] == address(0), \"FraxlendPairDeployer: Pair name must be unique\");\n        deployedPairsByName[_name] = _pairAddress;\n        deployedPairsArray.push(_name);\n\n        // Set additional values for FraxlendPair\n        IFraxlendPair _fraxlendPair = IFraxlendPair(_pairAddress);\n        _fraxlendPair.initialize(_name, _approvedBorrowers, _approvedLenders, _rateInitData);\n\n        // Transfer Ownership of FraxlendPair\n        _fraxlendPair.transferOwnership(COMPTROLLER_ADDRESS);\n    }\n\n    /// @notice The ```_logDeploy``` function emits a LogDeploy event\n    /// @param _name The name of the Pair\n    /// @param _pairAddress The address of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    function _logDeploy(\n        string memory _name,\n        address _pairAddress,\n        bytes memory _configData,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate\n    ) private {\n        (\n            address _asset,\n            address _collateral,\n            address _oracleMultiply,\n            address _oracleDivide,\n            ,\n            address _rateContract,\n\n        ) = abi.decode(_configData, (address, address, address, address, uint256, address, bytes));\n        emit LogDeploy(\n            _name,\n            _pairAddress,\n            _asset,\n            _collateral,\n            _oracleMultiply,\n            _oracleDivide,\n            _rateContract,\n            _maxLTV,\n            _liquidationFee,\n            _maturityDate\n        );\n    }\n\n    // ============================================================================================\n    // Functions: External Deploy Methods\n    // ============================================================================================\n\n    /// @notice The ```deploy``` function allows anyone to create a custom lending market between an Asset and Collateral Token\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @return _pairAddress The address to which the Pair was deployed\n    function deploy(bytes memory _configData) external returns (address _pairAddress) {\n        (address _asset, address _collateral, , , , address _rateContract, ) = abi.decode(\n            _configData,\n            (address, address, address, address, uint256, address, bytes)\n        );\n        string memory _name = string(\n            abi.encodePacked(\n                \"FraxlendV1 - \",\n                IERC20(_collateral).safeName(),\n                \"/\",\n                IERC20(_asset).safeName(),\n                \" - \",\n                IRateCalculator(_rateContract).name(),\n                \" - \",\n                (deployedPairsArray.length + 1).toString()\n            )\n        );\n\n        _pairAddress = _deployFirst(\n            keccak256(abi.encodePacked(\"public\")),\n            _configData,\n            abi.encode(CIRCUIT_BREAKER_ADDRESS, COMPTROLLER_ADDRESS, TIME_LOCK_ADDRESS, FRAXLEND_WHITELIST_ADDRESS),\n            DEFAULT_MAX_LTV,\n            DEFAULT_LIQ_FEE,\n            0,\n            0,\n            false,\n            false\n        );\n\n        _deploySecond(_name, _pairAddress, _configData, new address[](0), new address[](0));\n\n        _logDeploy(_name, _pairAddress, _configData, DEFAULT_MAX_LTV, DEFAULT_LIQ_FEE, 0);\n    }\n\n    /// @notice The ```deployCustom``` function allows whitelisted users to deploy custom Term Sheets for OTC debt structuring\n    /// @dev Caller must be added to FraxLedWhitelist\n    /// @param _name The name of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    /// @return _pairAddress The address to which the Pair was deployed\n    function deployCustom(\n        string memory _name,\n        bytes memory _configData,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        address[] memory _approvedBorrowers,\n        address[] memory _approvedLenders\n    ) external returns (address _pairAddress) {\n        require(_maxLTV <= GLOBAL_MAX_LTV, \"FraxlendPairDeployer: _maxLTV is too large\");\n        require(\n            IFraxlendWhitelist(FRAXLEND_WHITELIST_ADDRESS).fraxlendDeployerWhitelist(msg.sender),\n            \"FraxlendPairDeployer: Only whitelisted addresses\"\n        );\n\n        _pairAddress = _deployFirst(\n            keccak256(abi.encodePacked(_name)),\n            _configData,\n            abi.encode(CIRCUIT_BREAKER_ADDRESS, COMPTROLLER_ADDRESS, TIME_LOCK_ADDRESS, FRAXLEND_WHITELIST_ADDRESS),\n            _maxLTV,\n            _liquidationFee,\n            _maturityDate,\n            _penaltyRate,\n            _approvedBorrowers.length > 0,\n            _approvedLenders.length > 0\n        );\n\n        _deploySecond(_name, _pairAddress, _configData, _approvedBorrowers, _approvedLenders);\n\n        deployedPairCustomStatusByAddress[_pairAddress] = true;\n\n        _logDeploy(_name, _pairAddress, _configData, _maxLTV, _liquidationFee, _maturityDate);\n    }\n\n    // ============================================================================================\n    // Functions: Admin\n    // ============================================================================================\n\n    /// @notice The ```globalPause``` function calls the pause() function on a given set of pair addresses\n    /// @dev Ignores reverts when calling pause()\n    /// @param _addresses Addresses to attempt to pause()\n    /// @return _updatedAddresses Addresses for which pause() was successful\n    function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {\n        require(msg.sender == CIRCUIT_BREAKER_ADDRESS, \"Circuit Breaker only\");\n        address _pairAddress;\n        uint256 _lengthOfArray = _addresses.length;\n        for (uint256 i = 0; i < _lengthOfArray; ) {\n            _pairAddress = _addresses[i];\n            try IFraxlendPair(_pairAddress).pause() {\n                _updatedAddresses[i] = _addresses[i];\n            } catch {}\n            unchecked {\n                i = i + 1;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/contracts/FraxlendPairDeployer.sol",
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ====================== FraxlendPairDeployer ========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@rari-capital/solmate/src/utils/SSTORE2.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IFraxlendPair.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\n// solhint-disable no-inline-assembly\n\n/// @title FraxlendPairDeployer\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\n/// @notice Deploys and initializes new FraxlendPairs\n/// @dev Uses create2 to deploy the pairs, logs an event, and records a list of all deployed pairs\ncontract FraxlendPairDeployer is Ownable {\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n\n    // Constants\n    uint256 public DEFAULT_MAX_LTV = 75000; // 75% with 1e5 precision\n    uint256 public GLOBAL_MAX_LTV = 1e8; // 1000x (100,000%) with 1e5 precision, protects from rounding errors in LTV calc\n    uint256 public DEFAULT_LIQ_FEE = 10000; // 10% with 1e5 precision\n\n    address private contractAddress1;\n    address private contractAddress2;\n\n    // Admin contracts\n    address public CIRCUIT_BREAKER_ADDRESS;\n    address public COMPTROLLER_ADDRESS;\n    address public TIME_LOCK_ADDRESS;\n\n    // Dependencies\n    address private immutable FRAXLEND_WHITELIST_ADDRESS;\n\n    /// @notice Emits when a new pair is deployed\n    /// @notice The ```LogDeploy``` event is emitted when a new Pair is deployed\n    /// @param _name The name of the Pair\n    /// @param _address The address of the pair\n    /// @param _asset The address of the Asset Token contract\n    /// @param _collateral The address of the Collateral Token contract\n    /// @param _oracleMultiply The address of the numerator price Oracle\n    /// @param _oracleDivide The address of the denominator price Oracle\n    /// @param _rateContract The address of the Rate Calculator contract\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    event LogDeploy(\n        string indexed _name,\n        address _address,\n        address indexed _asset,\n        address indexed _collateral,\n        address _oracleMultiply,\n        address _oracleDivide,\n        address _rateContract,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate\n    );\n\n    /// @notice CREATE2 salt => deployed address\n    mapping(bytes32 => address) public deployedPairsBySalt;\n    /// @notice hash of name => deployed address\n    mapping(string => address) public deployedPairsByName;\n    /// @notice address => isCustom boolean\n    mapping(address => bool) public deployedPairCustomStatusByAddress;\n    /// @notice List of the names of all deployed Pairs\n    string[] public deployedPairsArray;\n\n    constructor(\n        address _circuitBreaker,\n        address _comptroller,\n        address _timelock,\n        address _fraxlendWhitelist\n    ) Ownable() {\n        CIRCUIT_BREAKER_ADDRESS = _circuitBreaker;\n        COMPTROLLER_ADDRESS = _comptroller;\n        TIME_LOCK_ADDRESS = _timelock;\n        FRAXLEND_WHITELIST_ADDRESS = _fraxlendWhitelist;\n    }\n\n    // ============================================================================================\n    // Functions: View Functions\n    // ============================================================================================\n\n    /// @notice The ```deployedPairsLength``` function returns the length of the deployedPairsArray\n    /// @return length of array\n    function deployedPairsLength() external view returns (uint256) {\n        return deployedPairsArray.length;\n    }\n\n    /// @notice The ```getAllPairAddresses``` function returns all pair addresses in deployedPairsArray\n    /// @return memory All deployed pair addresses\n    function getAllPairAddresses() external view returns (address[] memory) {\n        string[] memory _deployedPairsArray = deployedPairsArray;\n        uint256 _lengthOfArray = _deployedPairsArray.length;\n        address[] memory _addresses = new address[](_lengthOfArray);\n        uint256 i;\n        for (i = 0; i < _lengthOfArray; ) {\n            _addresses[i] = deployedPairsByName[_deployedPairsArray[i]];\n            unchecked {\n                i++;\n            }\n        }\n        return _addresses;\n    }\n\n    struct PairCustomStatus {\n        address _address;\n        bool _isCustom;\n    }\n\n    /// @notice The ```getCustomStatuses``` function returns an array of structs which contain the address and custom status\n    /// @param _addresses Addresses to check for custom status\n    /// @return _pairCustomStatuses memory Array of structs containing information\n    function getCustomStatuses(address[] calldata _addresses)\n        external\n        view\n        returns (PairCustomStatus[] memory _pairCustomStatuses)\n    {\n        uint256 _lengthOfArray = _addresses.length;\n        uint256 i;\n        _pairCustomStatuses = new PairCustomStatus[](_lengthOfArray);\n        for (i = 0; i < _lengthOfArray; ) {\n            _pairCustomStatuses[i] = PairCustomStatus({\n                _address: _addresses[i],\n                _isCustom: deployedPairCustomStatusByAddress[_addresses[i]]\n            });\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    // ============================================================================================\n    // Functions: Setters\n    // ============================================================================================\n\n    /// @notice The ```setCreationCode``` function sets the bytecode for the fraxlendPair\n    /// @dev splits the data if necessary to accomodate creation code that is slightly larger than 24kb\n    /// @param _creationCode The creationCode for the Fraxlend Pair\n    function setCreationCode(bytes calldata _creationCode) external onlyOwner {\n        bytes memory _firstHalf = BytesLib.slice(_creationCode, 0, 13000);\n        contractAddress1 = SSTORE2.write(_firstHalf);\n        if (_creationCode.length > 13000) {\n            bytes memory _secondHalf = BytesLib.slice(_creationCode, 13000, _creationCode.length - 13000);\n            contractAddress2 = SSTORE2.write(_secondHalf);\n        }\n    }\n\n    // ============================================================================================\n    // Functions: Internal Methods\n    // ============================================================================================\n\n    /// @notice The ```_deployFirst``` function is an internal function with deploys the pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    /// @param _isBorrowerWhitelistActive Enables borrower whitelist\n    /// @param _isLenderWhitelistActive Enables lender whitelist\n    /// @return _pairAddress The address to which the Pair was deployed\n    function _deployFirst(\n        bytes32 _saltSeed,\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    ) private returns (address _pairAddress) {\n        {\n            // _saltSeed is the same for all public pairs so duplicates cannot be created\n            bytes32 salt = keccak256(abi.encodePacked(_saltSeed, _configData));\n            require(deployedPairsBySalt[salt] == address(0), \"FraxlendPairDeployer: Pair already deployed\");\n\n            bytes memory _creationCode = BytesLib.concat(\n                SSTORE2.read(contractAddress1),\n                SSTORE2.read(contractAddress2)\n            );\n            bytes memory bytecode = abi.encodePacked(\n                _creationCode,\n                abi.encode(\n                    _configData,\n                    _immutables,\n                    _maxLTV,\n                    _liquidationFee,\n                    _maturityDate,\n                    _penaltyRate,\n                    _isBorrowerWhitelistActive,\n                    _isLenderWhitelistActive\n                )\n            );\n\n            assembly {\n                _pairAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\n            }\n            require(_pairAddress != address(0), \"FraxlendPairDeployer: create2 failed\");\n\n            deployedPairsBySalt[salt] = _pairAddress;\n        }\n\n        return _pairAddress;\n    }\n\n    /// @notice The ```_deploySecond``` function is the second part of deployment, it invoked the initialize() on the Pair\n    /// @param _name The name of the Pair\n    /// @param _pairAddress The address of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    function _deploySecond(\n        string memory _name,\n        address _pairAddress,\n        bytes memory _configData,\n        address[] memory _approvedBorrowers,\n        address[] memory _approvedLenders\n    ) private {\n        (, , , , , , bytes memory _rateInitData) = abi.decode(\n            _configData,\n            (address, address, address, address, uint256, address, bytes)\n        );\n        require(deployedPairsByName[_name] == address(0), \"FraxlendPairDeployer: Pair name must be unique\");\n        deployedPairsByName[_name] = _pairAddress;\n        deployedPairsArray.push(_name);\n\n        // Set additional values for FraxlendPair\n        IFraxlendPair _fraxlendPair = IFraxlendPair(_pairAddress);\n        _fraxlendPair.initialize(_name, _approvedBorrowers, _approvedLenders, _rateInitData);\n\n        // Transfer Ownership of FraxlendPair\n        _fraxlendPair.transferOwnership(COMPTROLLER_ADDRESS);\n    }\n\n    /// @notice The ```_logDeploy``` function emits a LogDeploy event\n    /// @param _name The name of the Pair\n    /// @param _pairAddress The address of the Pair\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate of the Pair\n    function _logDeploy(\n        string memory _name,\n        address _pairAddress,\n        bytes memory _configData,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate\n    ) private {\n        (\n            address _asset,\n            address _collateral,\n            address _oracleMultiply,\n            address _oracleDivide,\n            ,\n            address _rateContract,\n\n        ) = abi.decode(_configData, (address, address, address, address, uint256, address, bytes));\n        emit LogDeploy(\n            _name,\n            _pairAddress,\n            _asset,\n            _collateral,\n            _oracleMultiply,\n            _oracleDivide,\n            _rateContract,\n            _maxLTV,\n            _liquidationFee,\n            _maturityDate\n        );\n    }\n\n    // ============================================================================================\n    // Functions: External Deploy Methods\n    // ============================================================================================\n\n    /// @notice The ```deploy``` function allows anyone to create a custom lending market between an Asset and Collateral Token\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @return _pairAddress The address to which the Pair was deployed\n    function deploy(bytes memory _configData) external returns (address _pairAddress) {\n        (address _asset, address _collateral, , , , address _rateContract, ) = abi.decode(\n            _configData,\n            (address, address, address, address, uint256, address, bytes)\n        );\n        string memory _name = string(\n            abi.encodePacked(\n                \"FraxlendV1 - \",\n                IERC20(_collateral).safeName(),\n                \"/\",\n                IERC20(_asset).safeName"
    }
  ]
}