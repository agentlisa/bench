{
  "Title": "[G-24] Don't use `SafeMath` once the solidity version is 0.8.0 or greater",
  "Content": "\nVersion 0.8.0 introduces internal overflow checks, so using `SafeMath` is redundant and adds overhead\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/AuraBalRewardPool.sol   #1\n\n5:    import { SafeMath } from \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraBalRewardPool.sol#L5>\n\n```solidity\nFile: contracts/AuraStakingProxy.sol   #2\n\n7:    import { SafeMath } from \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraStakingProxy.sol#L7>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/AuraBalRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { AuraMath } from \"./AuraMath.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAuraLocker } from \"./Interfaces.sol\";\n\n/**\n * @title   AuraBalRewardPool\n * @author  Synthetix -> ConvexFinance -> adapted\n * @notice  This AuraBalRewardPool is deployed to support auraBAL deposits during the first 2\n *          weeks of system operation. After which, the BaseRewardPool hooked into the Booster (lockRewards)\n *          will be used for auraBAL farming.\n * @dev     Modifications from convex-platform/contracts/contracts/BaseRewardPool.sol:\n *            - Delayed start (tokens transferred then delay is enforced before notification)\n *            - One time duration of 14 days\n *            - Remove child reward contracts\n *            - Penalty on claim at 20%\n */\ncontract AuraBalRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 14 days;\n\n    address public immutable rewardManager;\n\n    IAuraLocker public immutable auraLocker;\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n    uint256 public immutable startTime;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @dev Simple constructoor\n     * @param _stakingToken  Pool LP token\n     * @param _rewardToken   $AURA\n     * @param _rewardManager Depositor\n     * @param _auraLocker    $AURA lock contract\n     * @param _penaltyForwarder Address to which penalties are sent\n     */\n    constructor(\n        address _stakingToken,\n        address _rewardToken,\n        address _rewardManager,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay\n    ) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardManager = _rewardManager;\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        rewardToken.safeApprove(_auraLocker, type(uint256).max);\n\n        require(_startDelay < 2 weeks, \"!delay\");\n        startTime = block.timestamp + _startDelay;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return AuraMath.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(\n        uint256 amount,\n        bool claim,\n        bool lock\n    ) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(lock);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Gives a staker their rewards\n     * @param _lock Lock the rewards? If false, takes a 20% haircut\n     */\n    function getReward(bool _lock) public updateReward(msg.sender) returns (bool) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            if (_lock) {\n                auraLocker.lock(msg.sender, reward);\n            } else {\n                uint256 penalty = (reward * 2) / 10;\n                pendingPenalty += penalty;\n                rewardToken.safeTransfer(msg.sender, reward - penalty);\n            }\n            emit RewardPaid(msg.sender, reward, _lock);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Forwards to the penalty forwarder for distro to Aura Lockers\n     */\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        rewardToken.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n\n    /**\n     * @dev Called once to initialise the rewards based on balance of stakeToken\n     */\n    function initialiseRewards() external returns (bool) {\n        require(msg.sender == rewardManager || block.timestamp > startTime, \"!authorized\");\n        require(rewardRate == 0, \"!one time\");\n\n        uint256 rewardsAvailable = rewardToken.balanceOf(address(this));\n        require(rewardsAvailable > 0, \"!balance\");\n\n        rewardRate = rewardsAvailable.div(duration);\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n\n        emit RewardAdded(rewardsAvailable);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/AuraStakingProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { Address } from \"@openzeppelin/contracts-0.8/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport { IAuraLocker } from \"./Interfaces.sol\";\n\ninterface ICrvDepositor {\n    function getMinOut(uint256, uint256) external view returns (uint256);\n\n    function deposit(\n        uint256,\n        uint256,\n        bool,\n        address _stakeAddress\n    ) external;\n}\n\n/**\n * @title   AuraStakingProxy\n * @author  adapted from ConvexFinance\n * @notice  Receives CRV from the Booster as overall reward, then convers to cvxCRV and distributes to vlCVX holders.\n * @dev     From CVX:\n *           - receive tokens to stake\n *           - get current staked balance\n *           - withdraw staked tokens\n *           - send rewards back to owner(cvx locker)\n *           - register token types that can be distributed\n */\ncontract AuraStakingProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    //tokens\n    address public immutable crv;\n    address public immutable cvx;\n    address public immutable cvxCrv;\n\n    address public keeper;\n    address public crvDepositorWrapper;\n    uint256 public outputBps;\n    uint256 public constant denominator = 10000;\n\n    address public rewards;\n\n    address public owner;\n    address public pendingOwner;\n    uint256 public callIncentive = 25;\n\n    event RewardsDistributed(address indexed token, uint256 amount);\n    event CallIncentiveChanged(uint256 incentive);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @param _rewards       vlCVX\n     * @param _crv           CRV token\n     * @param _cvx           CVX token\n     * @param _cvxCrv        cvxCRV token\n     * @param _crvDepositorWrapper    Wrapper that converts CRV to CRVBPT and deposits\n     * @param _outputBps     Configurable output bps where 100% == 10000\n     */\n    constructor(\n        address _rewards,\n        address _crv,\n        address _cvx,\n        address _cvxCrv,\n        address _crvDepositorWrapper,\n        uint256 _outputBps\n    ) {\n        rewards = _rewards;\n        owner = msg.sender;\n        crv = _crv;\n        cvx = _cvx;\n        cvxCrv = _cvxCrv;\n        crvDepositorWrapper = _crvDepositorWrapper;\n        outputBps = _outputBps;\n    }\n\n    /**\n     * @notice Set CrvDepositorWrapper\n     * @param   _crvDepositorWrapper CrvDepositorWrapper address\n     * @param   _outputBps Min output base points\n     */\n    function setCrvDepositorWrapper(address _crvDepositorWrapper, uint256 _outputBps) external {\n        require(msg.sender == owner, \"!auth\");\n        require(_outputBps > 9000 && _outputBps < 10000, \"Invalid output bps\");\n\n        crvDepositorWrapper = _crvDepositorWrapper;\n        outputBps = _outputBps;\n    }\n\n    /**\n     * @notice Set keeper\n     */\n    function setKeeper(address _keeper) external {\n        require(msg.sender == owner, \"!auth\");\n        keeper = _keeper;\n    }\n\n    /**\n     * @notice Set pending owner\n     */\n    function setPendingOwner(address _po) external {\n        require(msg.sender == owner, \"!auth\");\n        pendingOwner = _po;\n    }\n\n    /**\n     * @notice Apply pending owner\n     */\n    function applyPendingOwner() external {\n        require(msg.sender == owner, \"!auth\");\n        require(pendingOwner != address(0), \"invalid owner\");\n\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n     * @notice Set call incentive\n     * @param _incentive Incentive base points\n     */\n    function setCallIncentive(uint256 _incentive) external {\n        require(msg.sender == owner, \"!auth\");\n        require(_incentive <= 100, \"too high\");\n        callIncentive = _incentive;\n        emit CallIncentiveChanged(_incentive);\n    }\n\n    /**\n     * @notice Set reward address\n     */\n    function setRewards(address _rewards) external {\n        require(msg.sender == owner, \"!auth\");\n        rewards = _rewards;\n    }\n\n    /**\n     * @notice  Approve crvDepositorWrapper to transfer contract CRV\n     *          and rewards to transfer cvxCrv\n     */\n    function setApprovals() external {\n        IERC20(crv).safeApprove(crvDepositorWrapper, 0);\n        IERC20(crv).safeApprove(crvDepositorWrapper, type(uint256).max);\n\n        IERC20(cvxCrv).safeApprove(rewards, 0);\n        IERC20(cvxCrv).safeApprove(rewards, type(uint256).max);\n    }\n\n    /**\n     * @notice Transfer stuck ERC20 tokens to `_to`\n     */\n    function rescueToken(address _token, address _to) external {\n        require(msg.sender == owner, \"!auth\");\n        require(_token != crv && _token != cvx && _token != cvxCrv, \"not allowed\");\n\n        uint256 bal = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(_to, bal);\n    }\n\n    /**\n     * @dev Collects cvxCRV rewards from cvxRewardPool, converts any CRV deposited directly from\n     *      the booster, and then applies the rewards to the cvxLocker, rewarding the caller in the process.\n     */\n    function distribute() external {\n        // If keeper enabled, require\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"!auth\");\n        }\n\n        //convert crv to cvxCrv\n        uint256 crvBal = IERC20(crv).balanceOf(address(this));\n        if (crvBal > 0) {\n            uint256 minOut = ICrvDepositor(crvDepositorWrapper).getMinOut(crvBal, outputBps);\n            ICrvDepositor(crvDepositorWrapper).deposit(crvBal, minOut, true, address(0));\n        }\n\n        //distribute cvxcrv\n        uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));\n\n        if (cvxCrvBal > 0) {\n            uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);\n            cvxCrvBal = cvxCrvBal.sub(incentiveAmount);\n\n            //send incentives\n            IERC20(cvxCrv).safeTransfer(msg.sender, incentiveAmount);\n\n            //update rewards\n            IAuraLocker(rewards).queueNewRewards(cvxCrvBal);\n\n            emit RewardsDistributed(cvxCrv, cvxCrvBal);\n        }\n    }\n\n    /**\n     * @notice Allow generic token distribution in case a new reward is ever added\n     */\n    function distributeOther(IERC20 _token) external {\n        require(address(_token) != crv && address(_token) != cvxCrv, \"not allowed\");\n\n        uint256 bal = _token.balanceOf(address(this));\n\n        if (bal > 0) {\n            uint256 incentiveAmount = bal.mul(callIncentive).div(denominator);\n            bal = bal.sub(incentiveAmount);\n\n            //send incentives\n            _token.safeTransfer(msg.sender, incentiveAmount);\n\n            //approve\n            _token.safeApprove(rewards, 0);\n            _token.safeApprove(rewards, type(uint256).max);\n\n            //update rewards\n            IAuraLocker(rewards).notifyRewardAmount(address(_token), bal);\n\n            emit RewardsDistributed(address(_token), bal);\n        }\n    }\n}"
    }
  ]
}