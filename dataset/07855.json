{
  "Title": "[M-02] The tier setting parameter are unsafely downcasted from type uint256 to type uint80 / uint48 / uint40 / uint16",
  "Content": "\n<https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L240><br>\n<https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L628><br>\n<https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L689>\n\nThe tier setting parameter are unsafely downcasted from uint256 to uint80 / uint48 / uint16\n\nthe tier is setted by owner is crucial because the parameter affect how nft is minted.\n\nthe callstack is\n\n`JBTiered721Delegate.sol#initialize` -> `Store#recordAddTiers`\n\n```solidity\nfunction recordAddTiers(JB721TierParams[] memory _tiersToAdd)\n```\n\nwhat does the struct `JB721TierParams` look like? all parameter in `JB721TierParams` is uint256 type\n\n```solidity\nstruct JB721TierParams {\n  uint256 contributionFloor;\n  uint256 lockedUntil;\n  uint256 initialQuantity;\n  uint256 votingUnits;\n  uint256 reservedRate;\n  address reservedTokenBeneficiary;\n  bytes32 encodedIPFSUri;\n  bool allowManualMint;\n  bool shouldUseBeneficiaryAsDefault;\n}\n```\n\nhowever in side the function\n\n```solidity\n// Record adding the provided tiers.\nif (_pricing.tiers.length > 0) _store.recordAddTiers(_pricing.tiers);\n```\n\nall uint256 parameter are downcasted.\n\n```solidity\n// Add the tier with the iterative ID.\n_storedTierOf[msg.sender][_tierId] = JBStored721Tier({\ncontributionFloor: uint80(_tierToAdd.contributionFloor),\nlockedUntil: uint48(_tierToAdd.lockedUntil),\nremainingQuantity: uint40(_tierToAdd.initialQuantity),\ninitialQuantity: uint40(_tierToAdd.initialQuantity),\nvotingUnits: uint16(_tierToAdd.votingUnits),\nreservedRate: uint16(_tierToAdd.reservedRate),\nallowManualMint: _tierToAdd.allowManualMint\n});\n```\n\nuint256 `contributionFloor` is downcasted to uint80,\n\nuint256 `lockedUntil` is downcasted to uint48\n\nuint256 `initialQuantity` and `initialQuantity` are downcasted to uint40\n\nuint256 `votingUnits` and uint256 `reservedRate` are downcasted to uint16\n\nthis means the original setting is greatly truncated.\n\nFor example, the owner wants to set the initial supply to a number larger than uint40, but the supply is truncated to type(uint40).max\n\nThe owner wants to set the contribution floor price above uint80,but the contribution floor price is truncated to type(uint80).max, the user may underpay the price and get the NFT price at a discount.\n\n### Proof of Concept\n\nWe can add POC\n\n<https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/forge-test/NFTReward_Unit.t.sol#L1689>\n\n```solidity\n function testJBTieredNFTRewardDelegate_mintFor_mintArrayOfTiers_downcast_POC() public {\n    uint256 nbTiers = 1;\n\n    vm.mockCall(\n      mockJBProjects,\n      abi.encodeWithSelector(IERC721.ownerOf.selector, projectId),\n      abi.encode(owner)\n    );\n\n    JB721TierParams[] memory _tiers = new JB721TierParams[](nbTiers);\n    uint16[] memory _tiersToMint = new uint16[](nbTiers);\n\n    // Temp tiers, will get overwritten later (pass the constructor check)\n    uint256 originalFloorPrice = 10000000000000000000000000 ether;\n  \n    for (uint256 i; i < nbTiers; i++) {\n      _tiers[i] = JB721TierParams({\n        contributionFloor: originalFloorPrice,\n        lockedUntil: uint48(0),\n        initialQuantity: 20,\n        votingUnits: uint16(0),\n        reservedRate: uint16(0),\n        reservedTokenBeneficiary: reserveBeneficiary,\n        encodedIPFSUri: tokenUris[i],\n        allowManualMint: true, // Allow this type of mint\n        shouldUseBeneficiaryAsDefault: false\n      });\n\n      _tiersToMint[i] = uint16(i)+1;\n      _tiersToMint[_tiersToMint.length - 1 - i] = uint16(i)+1;\n    }\n\n    ForTest_JBTiered721DelegateStore _ForTest_store = new ForTest_JBTiered721DelegateStore();\n    ForTest_JBTiered721Delegate _delegate = new ForTest_JBTiered721Delegate(\n      projectId,\n      IJBDirectory(mockJBDirectory),\n      name,\n      symbol,\n      IJBFundingCycleStore(mockJBFundingCycleStore),\n      baseUri,\n      IJBTokenUriResolver(mockTokenUriResolver),\n      contractUri,\n      _tiers,\n      IJBTiered721DelegateStore(address(_ForTest_store)),\n      JBTiered721Flags({\n        lockReservedTokenChanges: false,\n        lockVotingUnitChanges: false,\n        lockManualMintingChanges: true,\n        pausable: true\n      })\n    );\n\n    _delegate.transferOwnership(owner);\n\n    uint256 floorPrice = _delegate.test_store().tier(address(_delegate), 1).contributionFloor;\n    console.log(\"original floor price\");\n    console.log(originalFloorPrice);\n    console.log(\"truncated floor price\");\n    console.log(floorPrice);\n\n}\n```\n\nnote, our initial contribution floor price setting is\n\n```solidity\nuint256 originalFloorPrice = 10000000000000000000000000 ether;\n\nfor (uint256 i; i < nbTiers; i++) {\n  _tiers[i] = JB721TierParams({\n\tcontributionFloor: originalFloorPrice,\n```\n\nthen we run our test\n\n```solidity\nforge test -vv --match testJBTieredNFTRewardDelegate_mintFor_mintArrayOfTiers_downcast_POC\n```\n\nthe result is\n\n```solidity\n[PASS] testJBTieredNFTRewardDelegate_mintFor_mintArrayOfTiers_downcast_POC() (gas: 7601212)\nLogs:\n  original floor price\n  10000000000000000000000000000000000000000000\n  truncated floor price\n  863278115882885135204352\n\nTest result: ok. 1 passed; 0 failed; finished in 10.43ms\n```\n\nclearly the floor price is unsafed downcasted and truncated.\n\n### Tools Used\n\nFoundry, Manual Review\n\n### Recommended Mitigation Steps\n\nWe recommend the project either change the data type in the struct\n\n```solidity\nstruct JB721TierParams {\n  uint256 contributionFloor;\n  uint256 lockedUntil;\n  uint256 initialQuantity;\n  uint256 votingUnits;\n  uint256 reservedRate;\n  address reservedTokenBeneficiary;\n  bytes32 encodedIPFSUri;\n  bool allowManualMint;\n  bool shouldUseBeneficiaryAsDefault;\n}\n```\n\nor safely downcast the number to make sure the number is not shortened unexpectedly.\n\n<https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast>\n\n\n**[drgorillamd (Juicebox DAO) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/31#issuecomment-1288886867):** \n> Thank you for the real poc:)\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-10-juicebox-findings/issues/31#issuecomment-1303295686):**\n > The warden showed how due to casting the original parameters could be truncated\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-juicebox-contest",
  "Code": [
    {
      "filename": "contracts/JBTiered721Delegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@jbx-protocol/juice-contracts-v3/contracts/libraries/JBFundingCycleMetadataResolver.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './abstract/JB721Delegate.sol';\nimport './interfaces/IJBTiered721Delegate.sol';\nimport './libraries/JBIpfsDecoder.sol';\nimport './libraries/JBTiered721FundingCycleMetadataResolver.sol';\nimport './structs/JBTiered721Flags.sol';\n\n/**\n  @title\n  JBTiered721Delegate\n\n  @notice\n  Delegate that offers project contributors NFTs with tiered price floors upon payment and the ability to redeem NFTs for treasury assets based based on price floor.\n\n  @dev\n  Adheres to -\n  IJBTiered721Delegate: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JB721Delegate: A generic NFT delegate.\n  Votes: A helper for voting balance snapshots.\n  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n*/\ncontract JBTiered721Delegate is IJBTiered721Delegate, JB721Delegate, Ownable {\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n\n  error NOT_AVAILABLE();\n  error OVERSPENDING();\n  error PRICING_RESOLVER_CHANGES_PAUSED();\n  error RESERVED_TOKEN_MINTING_PAUSED();\n  error TRANSFERS_PAUSED();\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The address of the origin 'JBTiered721Delegate', used to check in the init if the contract is the original or not\n  */\n  address public override codeOrigin;\n\n  /**\n    @notice\n    The contract that stores and manages the NFT's data.\n  */\n  IJBTiered721DelegateStore public override store;\n\n  /**\n    @notice\n    The contract storing all funding cycle configurations.\n  */\n  IJBFundingCycleStore public override fundingCycleStore;\n\n  /**\n    @notice\n    The contract that exposes price feeds.\n  */\n  IJBPrices public override prices;\n\n  /** \n    @notice\n    The currency that is accepted when minting tier NFTs. \n  */\n  uint256 public override pricingCurrency;\n\n  /** \n    @notice\n    The currency that is accepted when minting tier NFTs. \n  */\n  uint256 public override pricingDecimals;\n\n  /** \n    @notice\n    The amount that each address has paid that has not yet contribute to the minting of an NFT. \n\n    _address The address to which the credits belong.\n  */\n  mapping(address => uint256) public override creditsOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The first owner of each token ID, which corresponds to the address that originally contributed to the project to receive the NFT.\n\n    @param _tokenId The ID of the token to get the first owner of.\n\n    @return The first owner of the token.\n  */\n  function firstOwnerOf(uint256 _tokenId) external view override returns (address) {\n    // Get a reference to the first owner.\n    address _storedFirstOwner = store.firstOwnerOf(address(this), _tokenId);\n\n    // If the stored first owner is set, return it.\n    if (_storedFirstOwner != address(0)) return _storedFirstOwner;\n\n    // Otherwise, the first owner must be the current owner.\n    return _owners[_tokenId];\n  }\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    The total number of tokens owned by the given owner across all tiers. \n\n    @param _owner The address to check the balance of.\n\n    @return balance The number of tokens owners by the owner accross all tiers.\n  */\n  function balanceOf(address _owner) public view override returns (uint256 balance) {\n    return store.balanceOf(address(this), _owner);\n  }\n\n  /** \n    @notice\n    The metadata URI of the provided token ID.\n\n    @dev\n    Defer to the tokenUriResolver if set, otherwise, use the tokenUri set with the token's tier.\n\n    @param _tokenId The ID of the token to get the tier URI for. \n\n    @return The token URI corresponding with the tier or the tokenUriResolver URI.\n  */\n  function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n    // A token without an owner doesn't have a URI.\n    if (_owners[_tokenId] == address(0)) return '';\n\n    // Get a reference to the URI resolver.\n    IJBTokenUriResolver _resolver = store.tokenUriResolverOf(address(this));\n\n    // If a token URI resolver is provided, use it to resolve the token URI.\n    if (address(_resolver) != address(0)) return _resolver.getUri(_tokenId);\n\n    // Return the token URI for the token's tier.\n    return\n      JBIpfsDecoder.decode(\n        store.baseUriOf(address(this)),\n        store.encodedTierIPFSUriOf(address(this), _tokenId)\n      );\n  }\n\n  /** \n    @notice\n    Returns the URI where contract metadata can be found. \n\n    @return The contract's metadata URI.\n  */\n  function contractURI() external view override returns (string memory) {\n    return store.contractUriOf(address(this));\n  }\n\n  /**\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev\n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  */\n  function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\n    return\n      _interfaceId == type(IJBTiered721Delegate).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  constructor() {\n    codeOrigin = address(this);\n  }\n\n  /**\n    @param _projectId The ID of the project this contract's functionality applies to.\n    @param _directory The directory of terminals and controllers for projects.\n    @param _name The name of the token.\n    @param _symbol The symbol that the token should be represented by.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _baseUri A URI to use as a base for full token URIs.\n    @param _tokenUriResolver A contract responsible for resolving the token URI for each token ID.\n    @param _contractUri A URI where contract metadata can be found. \n    @param _pricing The tier pricing according to which token distribution will be made. Must be passed in order of contribution floor, with implied increasing value.\n    @param _store A contract that stores the NFT's data.\n    @param _flags A set of flags that help define how this contract works.\n  */\n  function initialize(\n    uint256 _projectId,\n    IJBDirectory _directory,\n    string memory _name,\n    string memory _symbol,\n    IJBFundingCycleStore _fundingCycleStore,\n    string memory _baseUri,\n    IJBTokenUriResolver _tokenUriResolver,\n    string memory _contractUri,\n    JB721PricingParams memory _pricing,\n    IJBTiered721DelegateStore _store,\n    JBTiered721Flags memory _flags\n  ) public override {\n    // Make the original un-initializable.\n    require(address(this) != codeOrigin);\n    // Stop re-initialization.\n    require(address(store) == address(0));\n\n    // Initialize the sub class.\n    JB721Delegate._initialize(_projectId, _directory, _name, _symbol);\n\n    fundingCycleStore = _fundingCycleStore;\n    store = _store;\n    pricingCurrency = _pricing.currency;\n    pricingDecimals = _pricing.decimals;\n    prices = _pricing.prices;\n\n    // Store the base URI if provided.\n    if (bytes(_baseUri).length != 0) _store.recordSetBaseUri(_baseUri);\n\n    // Set the contract URI if provided.\n    if (bytes(_contractUri).length != 0) _store.recordSetContractUri(_contractUri);\n\n    // Set the token URI resolver if provided.\n    if (_tokenUriResolver != IJBTokenUriResolver(address(0)))\n      _store.recordSetTokenUriResolver(_tokenUriResolver);\n\n    // Record adding the provided tiers.\n    if (_pricing.tiers.length > 0) _store.recordAddTiers(_pricing.tiers);\n\n    // Set the flags if needed.\n    if (\n      _flags.lockReservedTokenChanges ||\n      _flags.lockVotingUnitChanges ||\n      _flags.lockManualMintingChanges ||\n      _flags.pausable\n    ) _store.recordFlags(_flags);\n\n    // Transfer ownership to the initializer.\n    _transferOwnership(msg.sender);\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Mint reserved tokens within the tier for the provided value.\n\n    @param _mintReservesForTiersData Contains information about how many reserved tokens to mint for each tier.\n  */\n  function mintReservesFor(JBTiered721MintReservesForTiersData[] memory _mintReservesForTiersData)\n    external\n    override\n  {\n    // Keep a reference to the number of tiers there are to mint reserved for.\n    uint256 _numberOfTiers = _mintReservesForTiersData.length;\n\n    for (uint256 _i; _i < _numberOfTiers; ) {\n      // Get a reference to the data being iterated on.\n      JBTiered721MintReservesForTiersData memory _data = _mintReservesForTiersData[_i];\n\n      // Mint for the tier.\n      mintReservesFor(_data.tierId, _data.count);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Mint tokens within the tier for the provided beneficiaries.\n\n    @param _mintForTiersData Contains information about how who to mint tokens for from each tier.\n  */\n  function mintFor(JBTiered721MintForTiersData[] memory _mintForTiersData)\n    external\n    override\n    onlyOwner\n  {\n    // Keep a reference to the number of beneficiaries there are to mint for.\n    uint256 _numberOfBeneficiaries = _mintForTiersData.length;\n\n    for (uint256 _i; _i < _numberOfBeneficiaries; ) {\n      // Get a reference to the data being iterated on.\n      JBTiered721MintForTiersData memory _data = _mintForTiersData[_i];\n\n      // Mint for the tier.\n      mintFor(_data.tierIds, _data.beneficiary);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Adjust the tiers mintable through this contract, adhering to any locked tier constraints. \n\n    @dev\n    Only the contract's owner can adjust the tiers.\n\n    @param _tiersToAdd An array of tier data to add.\n    @param _tierIdsToRemove An array of tier IDs to remove.\n  */\n  function adjustTiers(JB721TierParams[] calldata _tiersToAdd, uint256[] calldata _tierIdsToRemove)\n    external\n    override\n    onlyOwner\n  {\n    // Get a reference to the number of tiers being added.\n    uint256 _numberOfTiersToAdd = _tiersToAdd.length;\n\n    // Get a reference to the number of tiers being removed.\n    uint256 _numberOfTiersToRemove = _tierIdsToRemove.length;\n\n    // Remove the tiers.\n    if (_numberOfTiersToRemove != 0) {\n      // Record the removed tiers.\n      store.recordRemoveTierIds(_tierIdsToRemove);\n\n      // Emit events for each removed tier.\n      for (uint256 _i; _i < _numberOfTiersToRemove; ) {\n        emit RemoveTier(_tierIdsToRemove[_i], msg.sender);\n        unchecked {\n          ++_i;\n        }\n      }\n    }\n\n    // Add the tiers.\n    if (_numberOfTiersToAdd != 0) {\n      // Record the added tiers in the store.\n      uint256[] memory _tierIdsAdded = store.recordAddTiers(_tiersToAdd);\n\n      // Emit events for each added tier.\n      for (uint256 _i; _i < _numberOfTiersToAdd; ) {\n        emit AddTier(_tierIdsAdded[_i], _tiersToAdd[_i], msg.sender);\n        unchecked {\n          ++_i;\n        }\n      }\n    }\n  }\n\n  /** \n    @notice\n    Sets the beneificiary of the reserved tokens for tiers where a specific beneficiary isn't set. \n\n    @dev\n    Only the contract's owner can set the default reserved token beneficiary.\n\n    @param _beneficiary The default beneificiary of the reserved tokens.\n  */\n  function setDefaultReservedTokenBeneficiary(address _beneficiary) external override onlyOwner {\n    // Set the beneficiary.\n    store.recordSetDefaultReservedTokenBeneficiary(_beneficiary);\n\n    emit SetDefaultReservedTokenBeneficiary(_beneficiary, msg.sender);\n  }\n\n  /**\n    @notice\n    Set a base token URI.\n\n    @dev\n    Only the contract's owner can set the base URI.\n\n    @param _baseUri The new base URI.\n  */\n  function setBaseUri(string memory _baseUri) external override onlyOwner {\n    // Store the new value.\n    store.recordSetBaseUri(_baseUri);\n\n    emit SetBaseUri(_baseUri, msg.sender);\n  }\n\n  /**\n    @notice\n    Set a contract metadata URI to contain opensea-style metadata.\n\n    @dev\n    Only the contract's owner can set the contract URI.\n\n    @param _contractUri The new contract URI.\n  */\n  function setContractUri(string calldata _contractUri) external override onlyOwner {\n    // Store the new value.\n    store.recordSetContractUri(_contractUri);\n\n    emit SetContractUri(_contractUri, msg.sender);\n  }\n\n  /**\n    @notice\n    Set a token URI resolver.\n\n    @dev\n    Only the contract's owner can set the token URI resolver.\n\n    @param _tokenUriResolver The new URI resolver.\n  */\n  function setTokenUriResolver(IJBTokenUriResolver _tokenUriResolver) external override onlyOwner {\n    // Store the new value.\n    store.recordSetTokenUriResolver(_tokenUriResolver);\n\n    emit SetTokenUriResolver(_tokenUriResolver, msg.sender);\n  }\n\n  //*********************************************************************//\n  // ----------------------- public transactions ----------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Mint reserved tokens within the tier for the provided value.\n\n    @param _tierId The ID of the tier to mint within.\n    @param _count The number of reserved tokens to mint. \n  */\n  function mintReservesFor(uint256 _tierId, uint256 _count) public override {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(projectId);\n\n    // Minting reserves must not be paused.\n    if (\n      JBTiered721FundingCycleMetadataResolver.mintingReservesPaused(\n        (JBFundingCycleMetadataResolver.metadata(_fundingCycle))\n      )\n    ) revert RESERVED_TOKEN_MINTING_PAUSED();\n\n    // Record the minted reserves for the tier.\n    uint256[] memory _tokenIds = store.recordMintReservesFor(_tierId, _count);\n\n    // Keep a reference to the reserved token beneficiary.\n    address _reservedTokenBeneficiary = store.reservedTokenBeneficiaryOf(address(this), _tierId);\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    for (uint256 _i; _i < _count; ) {\n      // Set the token ID.\n      _tokenId = _tokenIds[_i];\n\n      // Mint the token.\n      _mint(_reservedTokenBeneficiary, _tokenId);\n\n      emit MintReservedToken(_tokenId, _tierId, _reservedTokenBeneficiary, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Manually mint NFTs from tiers.\n\n    @param _tierIds The IDs of the tiers to mint from.\n    @param _beneficiary The address to mint to. \n\n    @return tokenIds The IDs of the newly minted tokens.\n  */\n  function mintFor(uint16[] memory _tierIds, address _beneficiary)\n    public\n    override\n    onlyOwner\n    returns (uint256[] memory tokenIds)\n  {\n    // Record the mint. The returned token IDs correspond to the tiers passed in.\n    (tokenIds, ) = store.recordMint(\n      type(uint256).max, // force the mint.\n      _tierIds,\n      true // manual mint\n    );\n\n    // Keep a reference to the number of tokens being minted.\n    uint256 _numberOfTokens = _tierIds.length;\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    for (uint256 _i; _i < _numberOfTokens; ) {\n      // Set the token ID.\n      _tokenId = tokenIds[_i];\n\n      // Mint the token.\n      _mint(_beneficiary, _tokenId);\n\n      emit Mint(_tokenId, _tierIds[_i], _beneficiary, 0, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  //*********************************************************************//\n  // ------------------------ internal functions ----------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Mints for a given contribution to the beneficiary.\n\n    @param _data The Juicebox standard project contribution data.\n  */\n  function _processPayment(JBDidPayData calldata _data) internal override {\n    // Normalize the currency.\n    uint256 _value;\n    if (_data.amount.currency == pricingCurrency) _value = _data.amount.value;\n    else if (prices != IJBPrices(address(0)))\n      _value = PRBMath.mulDiv(\n        _data.amount.value,\n        10**pricingDecimals,\n        prices.priceFor(_data.amount.currency, pricingCurrency, _data.amount.decimals)\n      );\n    else return;\n\n    // Keep a reference to the amount of credits the beneficiary already has.\n    uint256 _credits = creditsOf[_data.beneficiary];\n\n    // Set the leftover amount as the initial value, including any credits the beneficiary might already have.\n    uint256 _leftoverAmount = _value + _credits;\n\n    // Keep a reference to a flag indicating if a mint is expected from discretionary funds. Defaults to false, meaning to mint is not expected.\n    bool _expectMintFromExtraFunds;\n\n    // Keep a reference to the flag indicating if the transaction should revert if all provded funds aren't spent. Defaults to false, meaning only a minimum payment is enforced.\n    bool _dontOverspend;\n\n    // Skip the first 32 bytes which are used by the JB protocol to pass the paying project's ID when paying from a JBSplit.\n    // Check the 4 bytes interfaceId to verify the metadata is intended for this contract.\n    if (\n      _data.metadata.length > 36 &&\n      bytes4(_data.metadata[32:36]) == type(IJB721Delegate).interfaceId\n    ) {\n      // Keep a reference to the flag indicating if the transaction should not mint anything.\n      bool _dontMint;\n\n      // Keep a reference to the the specific tier IDs to mint.\n      uint16[] memory _tierIdsToMint;\n\n      // Decode the metadata.\n      (, , _dontMint, _expectMintFromExtraFunds, _dontOverspend, _tierIdsToMint) = abi.decode(\n        _data.metadata,\n        (bytes32, bytes4, bool, bool, bool, uint16[])\n      );\n\n      // Don't mint if not desired.\n      if (_dontMint) return;\n\n      // Mint rewards if they were specified.\n      if (_tierIdsToMint.length != 0)\n        _leftoverAmount = _mintAll(_leftoverAmount, _tierIdsToMint, _data.beneficiary);\n    }\n\n    // If there are funds leftover, mint the best available with it.\n    if (_leftoverAmount != 0) {\n      _leftoverAmount = _mintBestAvailableTier(\n        _leftoverAmount,\n        _data.beneficiary,\n        _expectMintFromExtraFunds\n      );\n\n      if (_leftoverAmount != 0) {\n        // Make sure there are no leftover funds after minting if not expected.\n        if (_dontOverspend) revert OVERSPENDING();\n\n        // Increment the leftover amount.\n        creditsOf[_data.beneficiary] = _leftoverAmount;\n      } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n    } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n  }\n\n  /** \n    @notice\n    A function that will run when a tokens are burned via redemption.\n\n    @param _tokenIds The IDs of the tokens that were burned.\n  */\n  function _didBurn(uint256[] memory _tokenIds) internal override {\n    // Add to burned counter.\n    store.recordBurn(_tokenIds);\n  }\n\n  /** \n    @notice\n    Mints a token in the best available tier.\n\n    @param _amount The amount to base the mint on.\n    @param _beneficiary The address to mint for.\n    @param _expectMint A flag indicating if a mint was expected.\n\n    @return  leftoverAmount The amount leftover after the mint.\n  */\n  function _mintBestAvailableTier(\n    uint256 _amount,\n    address _beneficiary,\n    bool _expectMint\n  ) internal returns (uint256 leftoverAmount) {\n    // Keep a reference to the token ID.\n    uint256 _tokenId;\n\n    // Keep a reference to the tier ID.\n    uint256 _tierId;\n\n    // Record the mint.\n    (_tokenId, _tierId, leftoverAmount) = store.recordMintBestAvailableTier(_amount);\n\n    // If there's no best tier, return or revert.\n    if (_tokenId == 0) {\n      // Make sure a mint was not expected.\n      if (_expectMint) revert NOT_AVAILABLE();\n      return leftoverAmount;\n    }\n\n    // Mint the tokens.\n    _mint(_beneficiary, _tokenId);\n\n    emit Mint(_tokenId, _tierId, _beneficiary, _amount - leftoverAmount, msg.sender);\n  }\n\n  /** \n    @notice\n    Mints a token in all provided tiers.\n\n    @param _amount The amount to base the mints on. All mints' price floors must fit in this amount.\n    @param _mintTierIds An array of tier IDs that are intended to be minted.\n    @param _beneficiary The address to mint for.\n\n    @return leftoverAmount The amount leftover after the mint.\n  */\n  function _mintAll(\n    uint256 _amount,\n    uint16[] memory _mintTierIds,\n    address _beneficiary\n  ) internal returns (uint256 leftoverAmount) {\n    // Keep a reference to the token ID.\n    uint256[] memory _tokenIds;\n\n    // Record the mint. The returned token IDs correspond to the tiers passed in.\n    (_tokenIds, leftoverAmount) = store.recordMint(\n      _amount,\n      _mintTierIds,\n      false // Not a manual mint\n    );\n\n    // Get a reference to the number of mints.\n    uint256 _mintsLength = _tokenIds.length;\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    // Loop through each token ID and mint.\n    for (uint256 _i; _i < _mintsLength; ) {\n      // Get a reference to the tier being iterated on.\n      _tokenId = _tokenIds[_i];\n\n      // Mint the tokens.\n      _mint(_beneficiary, _tokenId);\n\n      emit Mint(_tokenId, _mintTierIds[_i], _beneficiary, _amount, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    The cumulative weight the given token IDs have in redemptions compared to the `_totalRedemptionWeight`. \n\n    @param _tokenIds The IDs of the tokens to get the cumulative redemption weight of.\n\n    @return The weight.\n  */\n  function _redemptionWeightOf(uint256[] memory _tokenIds)\n    internal\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return store.redemptionWeightOf(address(this), _tokenIds);\n  }\n\n  /** \n    @notice\n    The cumulative weight that all token IDs have in redemptions. \n\n    @return The total weight.\n  */\n  function _totalRedemptionWeight() internal view virtual override returns (uint256) {\n    return store.totalRedemptionWeight(address(this));\n  }\n\n  /**\n    @notice\n    User the hook to register the first owner if it's not yet regitered.\n\n    @param _from The address where the transfer is originating.\n    @param _to The address to which the transfer is being made.\n    @param _tokenId The ID of the token being transfered.\n  */\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) internal virtual override {\n    // Transfered must not be paused when not minting or burning.\n    if (_from != address(0)) {\n      // Transfers must not be paused.\n      if (store.flagsOf(address(this)).pausable) {\n        // Get a reference to the project's current funding cycle.\n        JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(projectId);\n\n        if (\n          _to != address(0) &&\n          JBTiered721FundingCycleMetadataResolver.transfersPaused(\n            (JBFundingCycleMetadataResolver.metadata(_fundingCycle))\n          )\n        ) revert TRANSFERS_PAUSED();\n      }\n\n      // If there's no stored first owner, and the transfer isn't originating from the zero address as expected for mints, store the first owner.\n      if (store.firstOwnerOf(address(this), _tokenId) == address(0))\n        store.recordSetFirstOwnerOf(_tokenId, _from);\n    }\n\n    super._beforeTokenTransfer(_from, _to, _tokenId);\n  }\n\n  /**\n    @notice\n    Transfer voting units after the transfer of a token.\n\n    @param _from The address where the transfer is originating.\n    @param _to The address to which the transfer is being made.\n    @param _tokenId The ID of the token being transfered.\n   */\n  function _afterTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) internal virtual override {\n    // Get a reference to the tier.\n    JB721Tier memory _tier = store.tierOfTokenId(address(this), _tokenId);\n\n    // Record the transfer.\n    store.recordTransferForTier(_tier.id, _from, _to);\n\n    // Handle any other accounting (ex. account for governance voting units)\n    _afterTokenTransferAccounting(_from, _to, _tokenId, _tier);\n\n    super._afterTokenTransfer(_from, _to, _tokenId);\n  }\n\n  /**\n    @notice \n    Custom hook to handle token/tier accounting, this way we can reuse the '_tier' instead of fetching it again.\n\n    @param _from The account to transfer voting units from.\n    @param _to The account to transfer voting units to.\n    @param _tokenId The ID of the token for which voting units are being transfered.\n    @param _tier The tier the token ID is part of.\n  */\n  function _afterTokenTransferAccounting(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    JB721Tier memory _tier\n  ) internal virtual {\n    _from; // Prevents unused var compiler and natspec complaints.\n    _to;\n    _tokenId;\n    _tier;\n  }\n}"
    },
    {
      "filename": "contracts/JBTiered721DelegateStore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@jbx-protocol/juice-contracts-v3/contracts/libraries/JBConstants.sol';\nimport './interfaces/IJBTiered721DelegateStore.sol';\nimport './libraries/JBBitmap.sol';\nimport './structs/JBBitmapWord.sol';\nimport './structs/JBStored721Tier.sol';\n\n/**\n  @title\n  JBTiered721DelegateStore\n\n  @notice\n  The contract that stores and manages the NFT's data.\n\n  @dev\n  Adheres to -\n  IJBTiered721DelegateStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n*/\ncontract JBTiered721DelegateStore is IJBTiered721DelegateStore {\n  using JBBitmap for mapping(uint256=>uint256);\n  using JBBitmap for JBBitmapWord;\n\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n\n  error CANT_MINT_MANUALLY();\n  error INSUFFICIENT_AMOUNT();\n  error INSUFFICIENT_RESERVES();\n  error INVALID_TIER();\n  error NO_QUANTITY();\n  error OUT();\n  error RESERVED_RATE_NOT_ALLOWED();\n  error MANUAL_MINTING_NOT_ALLOWED();\n  error PRICING_RESOLVER_CHANGES_LOCKED();\n  error TIER_LOCKED();\n  error TIER_REMOVED();\n  error VOTING_UNITS_NOT_ALLOWED();\n  error INVALID_PRICE_SORT_ORDER();\n\n  //*********************************************************************//\n  // --------------------- internal stored properties ------------------ //\n  //*********************************************************************//\n\n  /** \n    @notice\n    The index that should come after the given index when sorting by contribution floor.\n\n    @dev\n    If empty, assume the next index should come after. \n\n    _nft The NFT contract to get tier order index from.\n    _index The index to get a tier after relative to.\n  */\n  mapping(address => mapping(uint256 => uint256)) internal _tierIdAfter;\n\n  /**\n    @notice\n    An optional beneficiary for the reserved token of a given tier.\n\n    _nft The NFT contract to which the reserved token beneficiary belongs.\n    _tierId the ID of the tier.\n  */\n  mapping(address => mapping(uint256 => address)) internal _reservedTokenBeneficiaryOf;\n\n  /** \n    @notice\n    The stored reward tier. \n\n    _nft The NFT contract to which the tiers belong.\n    _tierId The incremental ID of the tier, starting with 1.\n  */\n  mapping(address => mapping(uint256 => JBStored721Tier)) internal _storedTierOf;\n\n  /**\n    @notice\n    Flags that influence the behavior of each NFT.\n\n    _nft The NFT for which the flags apply.\n  */\n  mapping(address => JBTiered721Flags) internal _flagsOf;\n\n  /** \n    @notice\n    For each tier ID, a flag indicating if the tier has been removed. \n\n    _nft The NFT contract to which the tier belong.\n    _depth The bitmap row\n    _word The row content\n  */\n  mapping(address => mapping(uint256 => uint256)) internal _isTierRemoved;\n\n  /** \n    @notice\n    For each NFT, the tier ID that comes last when sorting. \n\n    @dev\n    If not set, it is assumed the `maxTierIdOf` is the last sorted.\n\n    _nft The NFT contract to which the tier belongs.\n  */\n  mapping(address => uint256) internal _trackedLastSortTierIdOf;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    The biggest tier ID used. \n\n    @dev\n    This may not include the last tier ID if it has been removed.\n\n    _nft The NFT contract to get the number of tiers.\n  */\n  mapping(address => uint256) public override maxTierIdOf;\n\n  /** \n    @notice\n    Each account's balance within a specific tier.\n\n    _nft The NFT contract to which the tier balances belong.\n    _owner The address to get a balance for. \n    _tierId The ID of the tier to get a balance within.\n  */\n  mapping(address => mapping(address => mapping(uint256 => uint256))) public override tierBalanceOf;\n\n  /**\n    @notice \n    The number of reserved tokens that have been minted for each tier. \n\n    _nft The NFT contract to which the reserve data belong.\n    _tierId The ID of the tier to get a minted reserved token count for.\n   */\n  mapping(address => mapping(uint256 => uint256)) public override numberOfReservesMintedFor;\n\n  /**\n    @notice \n    The number of tokens that have been burned for each tier. \n\n    _nft The NFT contract to which the burned data belong.\n    _tierId The ID of the tier to get a burned token count for.\n   */\n  mapping(address => mapping(uint256 => uint256)) public override numberOfBurnedFor;\n\n  /** \n    @notice\n    The beneficiary of reserved tokens when the tier doesn't specify a beneficiary.\n\n    _nft The NFT contract to which the reserved token beneficiary applies.\n  */\n  mapping(address => address) public override defaultReservedTokenBeneficiaryOf;\n\n  /**\n    @notice\n    The first owner of each token ID, stored on first transfer out.\n\n    _nft The NFT contract to which the token belongs.\n    _tokenId The ID of the token to get the stored first owner of.\n  */\n  mapping(address => mapping(uint256 => address)) public override firstOwnerOf;\n\n  /**\n    @notice\n    The common base for the tokenUri's\n\n    _nft The NFT for which the base URI applies.\n  */\n  mapping(address => string) public override baseUriOf;\n\n  /**\n    @notice\n    Custom token URI resolver, superceeds base URI.\n\n    _nft The NFT for which the token URI resolver applies.\n  */\n  mapping(address => IJBTokenUriResolver) public override tokenUriResolverOf;\n\n  /**\n    @notice\n    Contract metadata uri.\n\n    _nft The NFT for which the contract URI resolver applies.\n  */\n  mapping(address => string) public override contractUriOf;\n\n  /**\n    @notice\n    When using this contract to manage token uri's, those are stored as 32bytes, based on IPFS hashes stripped down.\n\n    _nft The NFT contract to which the encoded upfs uri belongs.\n    _tierId the ID of the tier\n  */\n  mapping(address => mapping(uint256 => bytes32)) public override encodedIPFSUriOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Gets an array of all the active tiers. \n\n    @param _nft The NFT contract to get tiers for.\n    @param _startingId The start index of the array of tiers sorted by contribution floor. Send 0 to start at the beginning.\n    @param _size The number of tiers to include.\n\n    @return _tiers All the tiers.\n  */\n  function tiers(\n    address _nft,\n    uint256 _startingId,\n    uint256 _size\n  ) external view override returns (JB721Tier[] memory _tiers) {\n    // Keep a reference to the last"
    }
  ]
}