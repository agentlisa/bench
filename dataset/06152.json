{
  "Title": "[M-02] `TokenManager`'s flow limit logic is broken for `ERC777` tokens",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLockUnlock.sol#L60-L67><br>\n<https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLiquidityPool.sol#L94-L101>\n\n### Vulnerability details\n\n`TokenManager` implementations inherit from the `FlowLimit` contract that keeps track of flow in and flow out. If these two values are too far away from each other, it reverts:\n\n```solidity\n    function _addFlow(\n        uint256 flowLimit,\n        uint256 slotToAdd,\n        uint256 slotToCompare,\n        uint256 flowAmount\n    ) internal {\n        uint256 flowToAdd;\n        uint256 flowToCompare;\n        assembly {\n            flowToAdd := sload(slotToAdd)\n            flowToCompare := sload(slotToCompare)\n        }\n        if (flowToAdd + flowAmount > flowToCompare + flowLimit) revert FlowLimitExceeded();\n        assembly {\n            sstore(slotToAdd, add(flowToAdd, flowAmount))\n        }\n    }\n```\n\nFlow in and flow out are increased when some tokens are transferred from one blockchain to another.\nThere are 3 different kinds of `TokenMaganer`:\n\n- Lock/Unlock\n- Mint/Burn\n- Liquidity Pool\n\nLet's see how Lock/Unlock and Liquidity Pool implementations handle cases when they have to transfer tokens to users:\n\n```solidity\nfunction _giveToken(address to, uint256 amount) internal override returns (uint256) {\n        IERC20 token = IERC20(tokenAddress());\n        uint256 balance = IERC20(token).balanceOf(to);\n\n        SafeTokenTransfer.safeTransfer(token, to, amount);\n\n        return IERC20(token).balanceOf(to) - balance;\n    }\n```\n\n```solidity\nfunction _giveToken(address to, uint256 amount) internal override returns (uint256) {\n        IERC20 token = IERC20(tokenAddress());\n        uint256 balance = IERC20(token).balanceOf(to);\n\n        SafeTokenTransferFrom.safeTransferFrom(token, liquidityPool(), to, amount);\n\n        return IERC20(token).balanceOf(to) - balance;\n    }\n```\n\nAs can be seen, they return a value equal to a balance difference before and after token transfer. This returned value is subsequently used by the `giveToken` function in order to call `_addFlowIn`:\n\n```solidity\nfunction giveToken(address destinationAddress, uint256 amount) external onlyService returns (uint256) {\n        amount = _giveToken(destinationAddress, amount);\n        _addFlowIn(amount);\n        return amount;\n    }\n```\n\nThe problem arises when `token` is `ERC777` token. In that case, the token receiver can manipulate its balance in order to increase flow in more than it should be; see POC section for more details.\n\nThere is no mechanism that will disallow someone from creating `TokenManager` with `ERC777` token as an underlying token, so it's definitely a possible scenario and the protocol would malfunction if it happens.\n\nNote that it's not an issue like \"users may deploy `TokenManager` for their malicious tokens that could even lie about `balanceOf`\". Users may simply want to deploy `TokenManager` for some `ERC777` token and bridge their `ERC777` tokens and there is nothing unusual about it.\n\n### Impact\n\nIt is possible to manipulate flow in when there is `TokenManager` of type Lock/Unlock or Liquidity Pool and the underlying token is `ERC777` token. It could be used to create DoS attacks, as it won't be possible to transfer tokens from one blockchain to another when the flow limit is reached (it may be possible to send them from one blockchain, but it will be impossible to receive them on another one due to the `revert` in the `_addFlow` function).\n\nIn order to recover, `flowLimit` could be set to `0`, but the feature was introduced in order to control flow in and flow out. Setting `flowLimit` to `0` means that the protocol won't be able to control it anymore.\n\nHere, the availability of the protocol is impacted, but an extra requirement is that there has to be `TokenManager` of Lock/Unlock or Liquidity Pool kind with `ERC777` underlying token, so I'm submitting this issue as Medium.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n1. `TokenManager` of type Lock/Unlock was deployed on blockchain `X` with underlying `ERC777` token (like FLUX, for example). Let's call this token `T`.\n\n2. Assume that blockchain `X` has low gas price (not strictly necessary, but will be helpful to visualize the issue).\n\n3. Alice wants to move their tokens (`T`) from blockchain `Y` to `X`, so they call `sendToken` from `TokenManagerLockUnlock` in order to start the process.\n\n4. Bob sees that and they also call `sendToken`, but with some dust amount of token `T`, they schedules that transaction from their smart contract called `MaliciousContract`.\n\n5. Bob's transaction is handled first and finally `TokenManagerLockUnlock::_giveToken` is called in order to give that dust amount of `T` to Bob's contract (`MaliciousContract`).\n\n6. `_giveToken`:\n\n```solidity\nfunction _giveToken(address to, uint256 amount) internal override returns (uint256) {\n        IERC20 token = IERC20(tokenAddress());\n        uint256 balance = IERC20(token).balanceOf(to);\n\n        SafeTokenTransfer.safeTransfer(token, to, amount);\n\n        return IERC20(token).balanceOf(to) - balance;\n    }\n```\n\nFirst, this records current balance of `T` of `MaliciousContract`, which happens to be `0` and calls `transfer`, which finally calls `MaliciousContract::tokensReceived` hook.\n\n7. `MaliciousContract::tokensReceived` hook looks as follows:\n\n```solidity\nfunction tokensReceived(\n    address operator,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n) external\n{\n    if (msg.sender == <TOKEN_MANAGER_ADDRESS>)\n        maliciousContractHelper.sendMeT();\n    else\n        return;\n}\n```\n\nWhere `<TOKEN_MANAGER_ADDRESS>` is the address of the relevant `TokenManager` and `maliciousContractHelper` is an instance of `MaliciousContractHelper`. That exposes the `sendMeT` function, which will send all tokens that it has to the `MaliciousContract` instance that called it.\n\n8. `maliciousContractHelper` has a lot of tokens `T`, so when `tokensReceived` returns, `T.balanceOf(MaliciousContract)` will increase a lot despite the fact that only a dust amount of `T` was sent from `TokenManager`.\n\n9.  The execution will return to `_giveToken` and returned value will be huge, since `IERC20(token).balanceOf(to) - balance` will now be a big value, despite the fact that `amount` was close to `0`.\n\n10. Flow in amount will increase a lot, so that `flowLimit` is reached and Alice's transaction will not be processed.\n\nIn short, Bob has increased the flow in amount for `TokenManager` by sending to their contract a lot of money in `ERC777` `tokensReceived` hook from their other contract. It didn't cost them much since they sent only a tiny amount of `T` between blockchains. Hence they could use almost all of their `T` tokens for the attack.\n\nOf course Bob could perform this attack without waiting for Alice to submit their transaction. The scenario presented above was just an example. In reality, Bob can do this at any moment.\n\nIt also seems possible to transfer tokens from the same blockchain to itself (by specifying wrong `destinationChain` in `sendToken` or just by specifying `destinationChain = <CURRENT_CHAIN>`), so Bob can have their tokens `T` only on one blockchain.\n\nIf gas price on that blockchain is low, Bob can perform that attack a lot of times. All they need to do is to send tokens back to `MaliciousContractHelper` after each attack (so that it can send it to `MaliciousContract` as described above). Finally, they will reach `flowLimit` for `TokenManager` and will cause denial of service.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nI would recommend doing one of the following:\n\n- Acknowledge the issue and warn users that the protocol doesn't support `ERC777` tokens (possibly even check and if `TokenManager` with `ERC777` underlying token is to be deployed - just revert)\n- Correct the value returned by `_giveTokens` to ensure that it doesn't exceed `amount`, as follows:\n\n```solidity\nuint currentBalance = IERC20(token).balanceOf(to);\nif (currentBalance - balance > amount)\n    return amount;\nreturn currentBalance - balance;\n```\n\n**[deanamiel (Axelar) confirmed and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/332#issuecomment-1694549078):**\n> Fixed so that the amount returned can never be higher than the initial amount.\n>\n> Public PR link:\n> https://github.com/axelarnetwork/interchain-token-service/pull/102\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/token-manager/implementations/TokenManagerLockUnlock.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { TokenManagerAddressStorage } from './TokenManagerAddressStorage.sol';\nimport { IERC20 } from '../../../gmp-sdk/interfaces/IERC20.sol';\n\nimport { SafeTokenTransferFrom, SafeTokenTransfer } from '../../../gmp-sdk/util/SafeTransfer.sol';\n\n/**\n * @title TokenManagerLockUnlock\n * @notice This contract is an implementation of TokenManager that locks and unlocks a specific token on behalf of the interchain token service.\n * @dev This contract extends TokenManagerAddressStorage and provides implementation for its abstract methods.\n * It uses the Axelar SDK to safely transfer tokens.\n */\ncontract TokenManagerLockUnlock is TokenManagerAddressStorage {\n    /**\n     * @dev Constructs an instance of TokenManagerLockUnlock. Calls the constructor\n     * of TokenManagerAddressStorage which calls the constructor of TokenManager.\n     * @param interchainTokenService_ The address of the interchain token service contract\n     */\n    constructor(address interchainTokenService_) TokenManagerAddressStorage(interchainTokenService_) {}\n\n    function implementationType() external pure returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Sets up the token address.\n     * @param params The setup parameters in bytes. Should be encoded with the token address.\n     */\n    function _setup(bytes calldata params) internal override {\n        // The first argument is reserved for the operator.\n        (, address tokenAddress) = abi.decode(params, (bytes, address));\n        _setTokenAddress(tokenAddress);\n    }\n\n    /**\n     * @dev Transfers a specified amount of tokens from a specified address to this contract.\n     * @param from The address to transfer tokens from\n     * @param amount The amount of tokens to transfer\n     * @return uint The actual amount of tokens transferred. This allows support for fee-on-transfer tokens.\n     */\n    function _takeToken(address from, uint256 amount) internal override returns (uint256) {\n        IERC20 token = IERC20(tokenAddress());\n        uint256 balance = token.balanceOf(address(this));\n\n        SafeTokenTransferFrom.safeTransferFrom(token, from, address(this), amount);\n\n        // Note: This allows support for fee-on-transfer tokens\n        return IERC20(token).balanceOf(address(this)) - balance;\n    }\n\n    /**\n     * @dev Transfers a specified amount of tokens from this contract to a specified address.\n     * @param to The address to transfer tokens to\n     * @param amount The amount of tokens to transfer\n     * @return uint The actual amount of tokens transferred\n     */\n    function _giveToken(address to, uint256 amount) internal override returns (uint256) {\n        IERC20 token = IERC20(tokenAddress());\n        uint256 balance = IERC20(token).balanceOf(to);\n\n        SafeTokenTransfer.safeTransfer(token, to, amount);\n\n        return IERC20(token).balanceOf(to) - balance;\n    }\n}"
    },
    {
      "filename": "contracts/its/token-manager/implementations/TokenManagerLiquidityPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { TokenManagerAddressStorage } from './TokenManagerAddressStorage.sol';\nimport { IERC20 } from '../../../gmp-sdk/interfaces/IERC20.sol';\n\nimport { SafeTokenTransferFrom } from '../../../gmp-sdk/util/SafeTransfer.sol';\n\n/**\n * @title TokenManagerLiquidityPool\n * @notice This contract is a an implementation of TokenManager that stores all tokens in a separate liquity pool\n * rather than within itself.\n * @dev This contract extends TokenManagerAddressStorage and provides implementation for its abstract methods.\n * It uses the Axelar SDK to safely transfer tokens.\n */\ncontract TokenManagerLiquidityPool is TokenManagerAddressStorage {\n    // uint256(keccak256('liquidity-pool-slot')) - 1\n    uint256 internal constant LIQUIDITY_POOL_SLOT = 0x8e02741a3381812d092c5689c9fc701c5185c1742fdf7954c4c4472be4cc4807;\n\n    /**\n     * @dev Constructs an instance of TokenManagerLiquidityPool. Calls the constructor\n     * of TokenManagerAddressStorage which calls the constructor of TokenManager.\n     * @param interchainTokenService_ The address of the interchain token service contract\n     */\n    constructor(address interchainTokenService_) TokenManagerAddressStorage(interchainTokenService_) {}\n\n    function implementationType() external pure returns (uint256) {\n        return 2;\n    }\n\n    /**\n     * @dev Sets up the token address and liquidity pool address.\n     * @param params The setup parameters in bytes. Should be encoded with the token address and the liquidity pool address.\n     */\n    function _setup(bytes calldata params) internal override {\n        // The first argument is reserved for the operator.\n        (, address tokenAddress_, address liquidityPool_) = abi.decode(params, (bytes, address, address));\n        _setTokenAddress(tokenAddress_);\n        _setLiquidityPool(liquidityPool_);\n    }\n\n    /**\n     * @dev Stores the liquidity pool address at a specific storage slot\n     * @param liquidityPool_ The address of the liquidity pool\n     */\n    function _setLiquidityPool(address liquidityPool_) internal {\n        assembly {\n            sstore(LIQUIDITY_POOL_SLOT, liquidityPool_)\n        }\n    }\n\n    /**\n     * @dev Reads the stored liquidity pool address from the specified storage slot\n     * @return liquidityPool_ The address of the liquidity pool\n     */\n    function liquidityPool() public view returns (address liquidityPool_) {\n        assembly {\n            liquidityPool_ := sload(LIQUIDITY_POOL_SLOT)\n        }\n    }\n\n    /**\n     * @dev Updates the address of the liquidity pool. Can only be called by the operator.\n     * @param newLiquidityPool The new address of the liquidity pool\n     */\n    function setLiquidityPool(address newLiquidityPool) external onlyOperator {\n        _setLiquidityPool(newLiquidityPool);\n    }\n\n    /**\n     * @dev Transfers a specified amount of tokens from a specified address to the liquidity pool.\n     * @param from The address to transfer tokens from\n     * @param amount The amount of tokens to transfer\n     * @return uint The actual amount of tokens transferred. This allows support for fee-on-transfer tokens.\n     */\n    function _takeToken(address from, uint256 amount) internal override returns (uint256) {\n        IERC20 token = IERC20(tokenAddress());\n        address liquidityPool_ = liquidityPool();\n        uint256 balance = token.balanceOf(liquidityPool_);\n\n        SafeTokenTransferFrom.safeTransferFrom(token, from, liquidityPool_, amount);\n\n        // Note: This allows support for fee-on-transfer tokens\n        return IERC20(token).balanceOf(liquidityPool_) - balance;\n    }\n\n    /**\n     * @dev Transfers a specified amount of tokens from the liquidity pool to a specified address.\n     * @param to The address to transfer tokens to\n     * @param amount The amount of tokens to transfer\n     * @return uint The actual amount of tokens transferred\n     */\n    function _giveToken(address to, uint256 amount) internal override returns (uint256) {\n        IERC20 token = IERC20(tokenAddress());\n        uint256 balance = IERC20(token).balanceOf(to);\n\n        SafeTokenTransferFrom.safeTransferFrom(token, liquidityPool(), to, amount);\n\n        return IERC20(token).balanceOf(to) - balance;\n    }\n}"
    }
  ]
}