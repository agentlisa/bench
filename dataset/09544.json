{
  "Title": "[N-02] `public` functions not called by the contract should be declared `external` instead",
  "Content": "\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n1.  File: src/BurnableMintableCappedERC20.sol (line [48](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/BurnableMintableCappedERC20.sol#L48))\n\n```solidity\n    function burn(bytes32 salt) public onlyOwner {\n```\n\n2.  File: src/MintableCappedERC20.sol (line [23](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/MintableCappedERC20.sol#L23))\n\n```solidity\n    function mint(address account, uint256 amount) public onlyOwner {\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-axelar",
  "Code": [
    {
      "filename": "src/BurnableMintableCappedERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { MintableCappedERC20 } from './MintableCappedERC20.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract BurnableMintableCappedERC20 is MintableCappedERC20 {\n    // keccak256('token-frozen')\n    bytes32 private constant PREFIX_TOKEN_FROZEN =\n        bytes32(0x1a7261d3a36c4ce4235d10859911c9444a6963a3591ec5725b96871d9810626b);\n\n    // keccak256('all-tokens-frozen')\n    bytes32 private constant KEY_ALL_TOKENS_FROZEN =\n        bytes32(0x75a31d1ce8e5f9892188befc328d3b9bd3fa5037457e881abc21f388471b8d96);\n\n    event Frozen(address indexed owner);\n    event Unfrozen(address indexed owner);\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 capacity\n    ) MintableCappedERC20(name, symbol, decimals, capacity) {}\n\n    function depositAddress(bytes32 salt) public view returns (address) {\n        /* Convert a hash which is bytes32 to an address which is 20-byte long\n        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                bytes1(0xff),\n                                owner,\n                                salt,\n                                keccak256(abi.encodePacked(type(DepositHandler).creationCode))\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function burn(bytes32 salt) public onlyOwner {\n        address account = depositAddress(salt);\n        _burn(account, balanceOf[account]);\n    }\n\n    function _beforeTokenTransfer(\n        address,\n        address,\n        uint256\n    ) internal view override {\n        require(!EternalStorage(owner).getBool(KEY_ALL_TOKENS_FROZEN), 'IS_FROZEN');\n        require(!EternalStorage(owner).getBool(keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol))), 'IS_FROZEN');\n    }\n}"
    },
    {
      "filename": "src/MintableCappedERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';\n\nimport { ERC20 } from './ERC20.sol';\nimport { ERC20Permit } from './ERC20Permit.sol';\nimport { Ownable } from './Ownable.sol';\n\ncontract MintableCappedERC20 is ERC20, ERC20Permit, Ownable, IERC20BurnFrom {\n    uint256 public cap;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 capacity\n    ) ERC20(name, symbol, decimals) ERC20Permit(name) Ownable() {\n        cap = capacity;\n    }\n\n    function mint(address account, uint256 amount) public onlyOwner {\n        uint256 capacity = cap;\n        require(capacity == 0 || totalSupply + amount <= capacity, 'CAP_EXCEEDED');\n\n        _mint(account, amount);\n    }\n\n    // TODO move burnFrom into a separate BurnableERC20 contract\n    function burnFrom(address account, uint256 amount) external onlyOwner {\n        _approve(account, owner, allowance[account][owner] - amount);\n        _burn(account, amount);\n    }\n}"
    }
  ]
}