{
  "Title": "[L-07] Misleading ERC20 queries `balanceOf()` and `totalSupply()`",
  "Content": "\n[WildcatMarketToken Line 16](https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketToken.sol#L16)\n\n[WildcatMarketToken Line 22](https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketToken.sol#L22)\n\n### Issue Description\n\nThe `WildcatMarketToken` contract includes standard `ERC20` functions, `balanceOf()` and `totalSupply()`. However, these functions return the balance of the underlying tokens instead of the market tokens. This discrepancy between the function names and their actual behavior could lead to confusion or issues when interacting with other protocols.\n\n### Recommended Mitigation Steps\n\nTo address this issue, it is recommended to rename the existing functions to `balanceOfScaled()` and `totalScaledSupply()`, and additionally implement `balanceOf()` and `totalSupply()` functions that return the balance of the market token.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/market/WildcatMarketToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketToken is WildcatMarketBase {\n  using SafeCastLib for uint256;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  /// @notice Returns the normalized balance of `account` with interest.\n  function balanceOf(address account) public view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.normalizeAmount(_accounts[account].scaledBalance);\n  }\n\n  /// @notice Returns the normalized total supply with interest.\n  function totalSupply() external view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.totalSupply();\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Actions                               */\n  /* -------------------------------------------------------------------------- */\n\n  function approve(address spender, uint256 amount) external virtual nonReentrant returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) external virtual nonReentrant returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant returns (bool) {\n    uint256 allowed = allowance[from][msg.sender];\n\n    // Saves gas for unlimited approvals.\n    if (allowed != type(uint256).max) {\n      uint256 newAllowance = allowed - amount;\n      _approve(from, msg.sender, newAllowance);\n    }\n\n    _transfer(from, to, amount);\n\n    return true;\n  }\n\n  function _approve(address approver, address spender, uint256 amount) internal virtual {\n    allowance[approver][spender] = amount;\n    emit Approval(approver, spender, amount);\n  }\n\n  function _transfer(address from, address to, uint256 amount) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) {\n      revert NullTransferAmount();\n    }\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit Transfer(from, to, amount);\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\n\ncontract WildcatMarketToken is WildcatMarketBase {\n  using SafeCastLib for uint256;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  /// @notice Returns the normalized balance of `account` with interest.\n  function balanceOf(address account) public view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.normalizeAmount(_accounts[account].scaledBalance);\n  }\n\n  /// @notice Returns the normalized total supply with interest.\n  function totalSupply() external view virtual nonReentrantView returns (uint256) {\n    (MarketState memory state, , ) = _calculateCurrentState();\n    return state.totalSupply();\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                ERC20 Actions                               */\n  /* -------------------------------------------------------------------------- */\n\n  function approve(address spender, uint256 amount) external virtual nonReentrant returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) external virtual nonReentrant returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external virtual nonReentrant returns (bool) {\n    uint256 allowed = allowance[from][msg.sender];\n\n    // Saves gas for unlimited approvals.\n    if (allowed != type(uint256).max) {\n      uint256 newAllowance = allowed - amount;\n      _approve(from, msg.sender, newAllowance);\n    }\n\n    _transfer(from, to, amount);\n\n    return true;\n  }\n\n  function _approve(address approver, address spender, uint256 amount) internal virtual {\n    allowance[approver][spender] = amount;\n    emit Approval(approver, spender, amount);\n  }\n\n  function _transfer(address from, address to, uint256 amount) internal virtual {\n    MarketState memory state = _getUpdatedState();\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (scaledAmount == 0) {\n      revert NullTransferAmount();\n    }\n\n    Account memory fromAccount = _getAccount(from);\n    fromAccount.scaledBalance -= scaledAmount;\n    _accounts[from] = fromAccount;\n\n    Account memory toAccount = _getAccount(to);\n    toAccount.scaledBalance += scaledAmount;\n    _accounts[to] = toAccount;\n\n    _writeState(state);\n    emit Transfer(from, to, amount);\n  }\n}"
    }
  ]
}