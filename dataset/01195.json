{
  "Title": "Insufficient Input Validation for Vesting Schedule",
  "Content": "The input arguments of the [`constructor`](https://github.com/oceanprotocol/vw-cli/blob/0397c74da60ae50db5c6414307849120b899af6e/contracts/VestingWalletHalving.sol#L38-L52) are not sufficiently validated. Some problematic scenarios will arise from this, including:  \n       • `startTimestamp` can be a timestamp that has already passed or is too far away in the              future.  \n       • `halfLife` can be zero, causing the [`getAmount function`](https://github.com/oceanprotocol/vw-cli/blob/0397c74da60ae50db5c6414307849120b899af6e/contracts/VestingWalletHalving.sol#L179-L187) to always revert.  \n       • `duration` can be zero, allowing a user to instantly release all allocated tokens and Ether.\n\n\nConsider adding sensible lower and upper bounds for all arguments of the constructor to ensure none of the outlined scenarios occur.\n\n\n***Update:** Resolved in pull [request #42](https://github.com/oceanprotocol/vw-cli/pull/42) at commit [a009de2](https://github.com/oceanprotocol/vw-cli/pull/42/commits/a009de280b46f865d137ff7f39757d51d75216b2).*\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/VestingWalletHalving.sol",
      "content": "// Copyright OpenZeppelin, BigchainDB GmbH and Ocean Protocol contributors\n// SPDX-License-Identifier: (Apache-2.0 AND MIT)\npragma solidity ^0.8.0;\n\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/utils/Address.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/utils/Context.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/access/Ownable.sol\";\n\n/**\n * @title VestingWalletHalving\n * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract VestingWalletHalving is Context, Ownable {\n    event EtherReleased(address indexed beneficiary, uint256 amount);\n    event ERC20Released(address indexed beneficiary, address indexed token, uint256 amount);\n    \n    event BeneficiaryChanged(address indexed newBeneficiary);\n    event RenounceVesting(address indexed token, address indexed owner, uint256 amount);\n    \n\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n    address private _beneficiary;\n    uint64 private immutable _start;\n    uint256 private immutable _halfLife;\n    uint256 private immutable _duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint256 halfLife,\n        uint256 duration\n    ) payable {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        _beneficiary = beneficiaryAddress;\n        _start = startTimestamp;\n        _halfLife = halfLife;\n        _duration = duration;\n    }\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable virtual {}\n\n    /**\n     * @dev Getter for the beneficiary address.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Getter for the start timestamp.\n     */\n    function start() public view virtual returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @dev Getter for the half life.\n     */\n    function halfLife() public view returns (uint256) {\n        return _halfLife;\n    }\n\n    /**\n     * @dev Getter for duration.\n     */\n    function duration() public view returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view virtual returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view virtual returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /**\n     * @dev Getter for the amount of releasable eth.\n     */\n    function releasable() public view virtual returns (uint256) {\n        return vestedAmount(uint64(block.timestamp)) - released();\n    }\n\n    /**\n     * @dev Getter for the amount of releasable `token` tokens. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function releasable(address token) public view virtual returns (uint256) {\n        return vestedAmount(token, uint64(block.timestamp)) - released(token);\n    }\n\n    /**\n     * @dev Release the native token (ether) that have already vested.\n     *\n     * Emits a {EtherReleased} event.\n     */\n    function release() public virtual {\n        require(\n            beneficiary() != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        uint256 amount = releasable();\n        _released += amount;\n        emit EtherReleased(beneficiary(), amount);\n        Address.sendValue(payable(beneficiary()), amount);\n    }\n\n    /**\n     * @dev Release the tokens that have already vested.\n     *\n     * Emits a {ERC20Released} event.\n     */\n    function release(address token) public virtual {\n        require(\n            beneficiary() != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        uint256 amount = releasable(token);\n        _erc20Released[token] += amount;\n        emit ERC20Released(beneficiary(), token, amount);\n        SafeERC20.safeTransfer(IERC20(token), beneficiary(), amount);\n    }\n\n    /**\n     * @dev Calculates the amount of ether that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(uint64 timestamp)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return _vestingSchedule(address(this).balance + released(), timestamp);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Approximation of half life formula (1-(0.5^(t/h)))*value\n     */\n    function getAmount(\n        uint256 value,\n        uint256 t,\n        uint256 h\n    ) public pure returns (uint256) {\n        uint256 p = value >> (t / h);\n        t %= h;\n        return value - p + (p * t) / h / 2;\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp > start() + duration()) {\n            return totalAllocation;\n        } else {\n            uint256 timePassed = timestamp - start();\n            return getAmount(totalAllocation, timePassed, halfLife());\n        }\n    }\n\n    // ----- ADMIN FUNCTIONS -----\n    function renounceVesting(address token) external onlyOwner {\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        emit RenounceVesting(token, owner(), amount);\n        SafeERC20.safeTransfer(IERC20(token), owner(), amount);\n        \n    }\n\n    function changeBeneficiary(address beneficiary) external onlyOwner {\n        require(beneficiary!= address(0),\"VestingWallet: beneficiary is zero address\");\n        _beneficiary = beneficiary;\n        emit BeneficiaryChanged(beneficiary);\n    }\n    \n}"
    },
    {
      "filename": "contracts/VestingWalletHalving.sol",
      "content": "// Copyright OpenZeppelin, BigchainDB GmbH and Ocean Protocol contributors\n// SPDX-License-Identifier: (Apache-2.0 AND MIT)\npragma solidity ^0.8.0;\n\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/utils/Address.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/utils/Context.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/access/Ownable.sol\";\n\n/**\n * @title VestingWalletHalving\n * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract VestingWalletHalving is Context, Ownable {\n    event EtherReleased(address indexed beneficiary, uint256 amount);\n    event ERC20Released(address indexed beneficiary, address indexed token, uint256 amount);\n    \n    event BeneficiaryChanged(address indexed newBeneficiary);\n    event RenounceVesting(address indexed token, address indexed owner, uint256 amount);\n    \n\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n    address private _beneficiary;\n    uint64 private immutable _start;\n    uint256 private immutable _halfLife;\n    uint256 private immutable _duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint256 halfLife,\n        uint256 duration\n    ) payable {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        _beneficiary = beneficiaryAddress;\n        _start = startTimestamp;\n        _halfLife = halfLife;\n        _duration = duration;\n    }\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable virtual {}\n\n    /**\n     * @dev Getter for the beneficiary address.\n     */\n    function beneficiary() public view virtual returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Getter for the start timestamp.\n     */\n    function start() public view virtual returns (uint256) {\n        return _start;\n    }\n\n    /**\n     * @dev Getter for the half life.\n     */\n    function halfLife() public view returns (uint256) {\n        return _halfLife;\n    }\n\n    /**\n     * @dev Getter for duration.\n     */\n    function duration() public view returns (uint256) {\n        return _duration;\n    }\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view virtual returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view virtual returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /**\n     * @dev Getter for the amount of releasable eth.\n     */\n    function releasable() public view virtual returns (uint256) {\n        return vestedAmount(uint64(block.timestamp)) - released();\n    }\n\n    /**\n     * @dev Getter for the amount of releasable `token` tokens. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function releasable(address token) public view virtual returns (uint256) {\n        return vestedAmount(token, uint64(block.timestamp)) - released(token);\n    }\n\n    /**\n     * @dev Release the native token (ether) that have already vested.\n     *\n     * Emits a {EtherReleased} event.\n     */\n    function release() public virtual {\n        require(\n            beneficiary() != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        uint256 amount = releasable();\n        _released += amount;\n        emit EtherReleased(beneficiary(), amount);\n        Address.sendValue(payable(beneficiary()), amount);\n    }\n\n    /**\n     * @dev Release the tokens that have already vested.\n     *\n     * Emits a {ERC20Released} event.\n     */\n    function release(address token) public virtual {\n        require(\n            beneficiary() != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        uint256 amount = releasable(token);\n        _erc20Released[token] += amount;\n        emit ERC20Released(beneficiary(), token, amount);\n        SafeERC20.safeTransfer(IERC20(token), beneficiary(), amount);\n    }\n\n    /**\n     * @dev Calculates the amount of ether that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(uint64 timestamp)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return _vestingSchedule(address(this).balance + released(), timestamp);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Approximation of half life formula (1-(0.5^(t/h)))*value\n     */\n    function getAmount(\n        uint256 value,\n        uint256 t,\n        uint256 h\n    ) public pure returns (uint256) {\n        uint256 p = value >> (t / h);\n        t %= h;\n        return value - p + (p * t) / h / 2;\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp > start() + duration()) {\n            return totalAllocation;\n        } else {\n            uint256 timePassed = timestamp - start();\n            return getAmount(totalAllocation, timePassed, halfLife());\n        }\n    }\n\n    // ----- ADMIN FUNCTIONS -----\n    function renounceVesting(address token) external onlyOwner {\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        emit RenounceVesting(token, owner(), amount);\n        SafeERC20.safeTransfer(IERC20(token), owner(), amount);\n        \n    }\n\n    function changeBeneficiary(address beneficiary) external onlyOwner {\n        require(beneficiary!= address(0),\"VestingWallet: beneficiary is zero address\");\n        _beneficiary = beneficiary;\n        emit BeneficiaryChanged(beneficiary);\n    }\n    \n}"
    }
  ]
}