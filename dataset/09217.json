{
  "Title": "[M-08] YearnTokenAdapter's wrap can become stuck as it uses one step approval for an arbitrary underlying",
  "Content": "_Submitted by hyh_\n\nSome tokens do not allow for approval of positive amount when allowance is positive already (to handle approval race condition, most known example is USDT).\n\nThis can cause the function to stuck whenever a combination of such a token and leftover approval be met. The latter can be possible if, for example, yearn vault is becoming full on a particular wrap() call and accepts only a part of amount, not utilizing the approval fully.\n\nThen each next safeApprove will revert and wrap becomes permanently unavailable. Setting the severity to medium as depositing (wrapping) is core functionality for the contract and its availability is affected.\n\n### Proof of Concept\n\nwrap use one step approve:\n\n[YearnTokenAdapter.sol#L30-L32](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32)<br>\n\n```solidity\n    function wrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        TokenUtils.safeApprove(underlyingToken, token, amount);\n```\n\nSome ERC20 forbid the approval of positive amount when the allowance is positive:\n\n<https://github.com/d-xo/weird-erc20#approval-race-protections>\n\nFor example, USDT is supported by Yearn and can be the underlying asset:\n\n<https://yearn.finance/#/vault/0x7Da96a3891Add058AdA2E826306D812C638D87a7>\n\n### Recommended Mitigation Steps\n\nAs the most general approach consider approving zero before doing so for the amount:\n\n```solidity\n    function wrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n+      TokenUtils.safeApprove(underlyingToken, token, 0);\n        TokenUtils.safeApprove(underlyingToken, token, amount);\n```\n\n**[0xfoobar (Alchemix) confirmed](https://github.com/code-423n4/2022-05-alchemix-findings/issues/99#issuecomment-1141378852)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/99#issuecomment-1146364671):**\n > It seems like `approve()` will fail to execute on non-standard tokens which require the approval amount to start from zero. This is valid and should be updated to handle such tokens.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/adapters/yearn/YearnTokenAdapter.sol",
      "content": "pragma solidity ^0.8.11;\n\nimport {IllegalState} from \"../../base/Errors.sol\";\n\nimport \"../../interfaces/ITokenAdapter.sol\";\nimport \"../../interfaces/external/yearn/IYearnVaultV2.sol\";\n\nimport \"../../libraries/TokenUtils.sol\";\n\n/// @title  YearnTokenAdapter\n/// @author Alchemix Finance\ncontract YearnTokenAdapter is ITokenAdapter {\n    uint256 private constant MAXIMUM_SLIPPAGE = 10000;\n    string public constant override version = \"2.1.0\";\n\n    address public immutable override token;\n    address public immutable override underlyingToken;\n\n    constructor(address _token, address _underlyingToken) {\n        token = _token;\n        underlyingToken = _underlyingToken;\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function price() external view override returns (uint256) {\n        return IYearnVaultV2(token).pricePerShare();\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function wrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        TokenUtils.safeApprove(underlyingToken, token, amount);\n\n        return IYearnVaultV2(token).deposit(amount, recipient);\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function unwrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(token, msg.sender, address(this), amount);\n\n        uint256 balanceBefore = TokenUtils.safeBalanceOf(token, address(this));\n\n        uint256 amountWithdrawn = IYearnVaultV2(token).withdraw(amount, recipient, MAXIMUM_SLIPPAGE);\n\n        uint256 balanceAfter = TokenUtils.safeBalanceOf(token, address(this));\n\n        // If the Yearn vault did not burn all of the shares then revert. This is critical in mathematical operations\n        // performed by the system because the system always expects that all of the tokens were unwrapped. In Yearn,\n        // this sometimes does not happen in cases where strategies cannot withdraw all of the requested tokens (an\n        // example strategy where this can occur is with Compound and AAVE where funds may not be accessible because\n        // they were lent out).\n        if (balanceBefore - balanceAfter != amount) {\n            revert IllegalState();\n        }\n\n        return amountWithdrawn;\n    }\n}"
    }
  ]
}