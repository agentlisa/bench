{
  "Title": "Using Custom Ownership Logic",
  "Content": "The [`enqueue`](https://github.com/ava-labs/teleporter/blob/253b833518aa7a6448650388cc288bd76d8470a7/contracts/src/Teleporter/ReceiptQueue.sol#L51) and [`dequeue`](https://github.com/ava-labs/teleporter/blob/253b833518aa7a6448650388cc288bd76d8470a7/contracts/src/Teleporter/ReceiptQueue.sol#L69) functions in the `ReceiptQueue` contract implement custom logic to ensure that only the owner of the contract (i.e., the `TeleporterMessenger` contract) is able to update the queue. Custom access control implementations are not recommended as they could introduce a larger attack surface if not implemented properly. Consider using [OpenZeppelin's `Ownable` library](https://docs.openzeppelin.com/contracts/5.x/api/access#Ownable) instead.\n\n\n***Update:** Resolved in [pull request 32](https://github.com/ava-labs/teleporter/pull/32/files). The `ReceiptQueue` contract has been adapted to be a library and no longer needs access control from those methods.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/Teleporter/ReceiptQueue.sol",
      "content": "// (c) 2023, Ava Labs, Inc. All rights reserved.\n// See the file LICENSE for licensing terms.\n\n// SPDX-License-Identifier: Ecosystem\n\npragma solidity 0.8.18;\n\nimport \"./ITeleporterMessenger.sol\";\n\n/**\n * @dev ReceiptQueue is a convenience contract that creates a queue-like interface of\n * TeleporterMessageReceipt structs. It provides FIFO properties.\n */\ncontract ReceiptQueue {\n    address public immutable owner;\n    mapping(uint256 => TeleporterMessageReceipt) public queue;\n    uint256 public first = 0;\n    uint256 public last = 0;\n\n    /**\n     * @dev Emitted when a new receipt is added to the queue.\n     */\n    event Enqueue(\n        uint256 indexed messageID,\n        address indexed relayerRewardAddress\n    );\n\n    /**\n     * @dev Emitted when a receipt is taken off the front of the queue.\n     */\n    event Dequeue(\n        uint256 indexed messageID,\n        address indexed relayerRewardAddress\n    );\n\n    // Errors\n    error Unauthorized();\n    error EmptyQueue();\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Adds a receipt to the queue.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be the owner.\n     */\n    function enqueue(TeleporterMessageReceipt calldata receipt) external {\n        if (msg.sender != owner) {\n            revert Unauthorized();\n        }\n\n        queue[last++] = receipt;\n\n        emit Enqueue(receipt.receivedMessageID, receipt.relayerRewardAddress);\n    }\n\n    /**\n     * @dev Removes the oldest open receipt from the queue.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be the owner.\n     * - The queue must be non-empty.\n     */\n    function dequeue()\n        external\n        returns (TeleporterMessageReceipt memory result)\n    {\n        if (msg.sender != owner) {\n            revert Unauthorized();\n        }\n\n        uint256 first_ = first;\n\n        if (last == first_) {\n            revert EmptyQueue(); // empty queue\n        }\n\n        result = queue[first_];\n\n        delete queue[first_];\n        first = first_ + 1;\n\n        emit Dequeue(result.receivedMessageID, result.relayerRewardAddress);\n    }\n\n    /**\n     * @dev Returns the number of open receipts in the queue.\n     */\n    function size() external view returns (uint256) {\n        return last - first;\n    }\n}"
    }
  ]
}