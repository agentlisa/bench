{
  "Title": "[L-01] CollateralizedDebt.tokenURI fails when pair's asset or collateral token have low decimals",
  "Content": "\n[NFTTokenURIScaffold.sol#L166](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166)<br>\n\nStandard ERC721 tokenURI call will fail for CollateralizedDebt pools whose underlying pair.asset() or pair.collateral() have decimals lower than 4 whenever the corresponding due quantity is lower than 1e9.\n\nPair's asset and collateral ERC20 can be arbitrary and some ERC20 contracts have decimals lower than 4, so such a combination is possible. In such cases current tokenURI implementation fails, which can be the issue for all integrations down the line as various systems routinely make tokenURI calls.\n\nPlacing severity to be medium per 'Assets not at direct risk, but the function of the protocol or its availability could be impacted', which is the case here as protocol availability is in question when EIP level functionality fails.\n\n### References\n\n<https://eips.ethereum.org/EIPS/eip-721>\n\n<https://github.com/d-xo/weird-erc20#low-decimals>\n\n### Proof of Concept\n\nNFTTokenURIScaffold.weiToPrecisionString will fail if used for a token with decimals lower than 4 as subtraction is performed without prior checks:\n\n[NFTTokenURIScaffold.sol#L166](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166)<br>\n\nNFTTokenURIScaffold.weiToPrecisionString is called by NFTTokenURIScaffold.tokenURI for pair's asset and collateral ERC20:\n\n[NFTTokenURIScaffold.sol#L16-L39](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L16-L39)<br>\n\nNFTTokenURIScaffold.tokenURI is used in CollateralizedDebt.tokenURI:\n\n[CollateralizedDebt.sol#L46](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/CollateralizedDebt.sol#L46)<br>\n\nPair's asset and collateral tokens can be arbitrary, while tokenURI is routinely requested by a variety of external systems\n\n### Recommended Mitigation Steps\n\nConsider adding the check and special care for low decimals case, for example add another naming rule similarly to how `significantDigits > 1e9` case is being handled\n\n**[amateur-dev (Timeswap) confirmed](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33)**\n\n**[vhawk19 (Timeswap) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33#issuecomment-1066298800):**\n > Have tested with zero decimals, yields in desired output as expected.\n> <img width=\"1665\" alt=\"Screenshot 2022-03-14 at 8 47 16 AM\" src=\"https://user-images.githubusercontent.com/24829996/158098919-ff03f04e-821f-4b4d-b534-1d60f67ab32d.png\">\n\n**[Mathepreneur (Timeswap) resolved](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33#issuecomment-1086577584):**\n > Am I correct in understanding that `weiAmt` is denominated using 18 decimals and not the `decimal` value provided as an input to the `weiToPrecisionString()` function? I'm curious as to why this is not an issue.\n\n**[amateur-dev (Timeswap) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33#issuecomment-1110648536):**\n > Hi, we are aware of the issue highlighted.  We have taken a conscious call for the decimals.  We have done testing and confirm that our lend, borrow and similar transactions do not have an issue.  The issue only arises once we call the URI of tokens with less than 4 decimals.  In that sense, these tokens URI will not show up properly in opensea.  The exposure is limited to that.  We do not rely on that URI for any function call in our dapp.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33#issuecomment-1112275217):**\n > As per the sponsor's comment, this issue only pertains to a token's URI which is shown in opensea. The unlikely edge case raised by the warden should only occur when tokens with less than 4 decimals are used. Because of the limited exposure to an attack, I'm inclined to mark this as `1 (Low Risk)`.\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-timeswap",
  "Code": [
    {
      "filename": "Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMetadata} from './SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {DateTime} from './DateTime.sol';\nimport './Base64.sol';\nimport {NFTSVG} from './NFTSVG.sol';\n\nlibrary NFTTokenURIScaffold {\n    using SafeMetadata for IERC20;\n    using Strings for uint256;\n\n    function tokenURI(\n        uint256 id,\n        IPair pair,\n        IPair.Due memory due,\n        uint256 maturity\n    ) public view returns (string memory) {\n        string memory uri = constructTokenSVG(\n            address(pair.asset()),\n            address(pair.collateral()),\n            id.toString(),\n            weiToPrecisionString(due.debt, pair.asset().safeDecimals()),\n            weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),\n            getReadableDateString(maturity),\n            maturity\n        );\n\n        string memory description = string(\n            abi.encodePacked(\n                'This collateralized debt position represents a debt of ',\n                weiToPrecisionString(due.debt, pair.asset().safeDecimals()),\n                ' ',\n                pair.asset().safeSymbol(),\n                ' borrowed against a collateral of ',\n                weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),\n                ' ',\n                pair.collateral().safeSymbol(),\n                '. This position will expire on ',\n                maturity.toString(),\n                ' unix epoch time.\\\\nThe owner of this NFT has the option to pay the debt before maturity time to claim the locked collateral. In case the owner choose to default on the debt payment, the collateral will be forfeited'\n            )\n        );\n        description = string(\n            abi.encodePacked(\n                description,\n                '\\\\n\\\\nAsset Address: ',\n                addressToString(address(pair.asset())),\n                '\\\\nCollateral Address: ',\n                addressToString(address(pair.collateral())),\n                '\\\\nDebt Required: ',\n                weiToPrecisionLongString(due.debt, pair.asset().safeDecimals()),\n                ' ',\n                IERC20(pair.asset()).safeSymbol(),\n                '\\\\nCollateral Locked: ',\n                weiToPrecisionLongString(due.collateral, pair.collateral().safeDecimals()),\n                ' ',\n                IERC20(pair.collateral()).safeSymbol()\n            )\n        );\n\n        string memory name = 'Timeswap Collateralized Debt';\n\n        return (constructTokenURI(name, description, uri));\n    }\n\n    function constructTokenURI(\n        string memory name,\n        string memory description,\n        string memory imageSVG\n    ) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    'data:application/json;base64,',\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"',\n                                name,\n                                '\", \"description\":\"',\n                                description,\n                                '\", \"image\": \"',\n                                'data:image/svg+xml;base64,',\n                                Base64.encode(bytes(imageSVG)),\n                                '\"}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function constructTokenSVG(\n        address asset,\n        address collateral,\n        string memory tokenId,\n        string memory assetAmount,\n        string memory collateralAmount,\n        string memory maturityDate,\n        uint256 maturityTimestamp\n    ) internal view returns (string memory) {\n        NFTSVG.SVGParams memory params = NFTSVG.SVGParams({\n            tokenId: tokenId,\n            svgTitle: string(\n                abi.encodePacked(\n                    parseSymbol(IERC20(asset).safeSymbol()),\n                    '/',\n                    parseSymbol(IERC20(collateral).safeSymbol())\n                )\n            ),\n            assetInfo: string(abi.encodePacked(parseSymbol(IERC20(asset).safeSymbol()), ': ', addressToString(asset))),\n            collateralInfo: string(\n                abi.encodePacked(parseSymbol(IERC20(collateral).safeSymbol()), ': ', addressToString(collateral))\n            ),\n            debtRequired: string(abi.encodePacked(assetAmount, ' ', parseSymbol(IERC20(asset).safeSymbol()))),\n            collateralLocked: string(\n                abi.encodePacked(collateralAmount, ' ', parseSymbol(IERC20(collateral).safeSymbol()))\n            ),\n            maturityDate: maturityDate,\n            isMatured: block.timestamp > maturityTimestamp,\n            maturityTimestampString: maturityTimestamp.toString(),\n            tokenColors: getSVGCData(asset, collateral)\n        });\n\n        return NFTSVG.constructSVG(params);\n    }\n\n    function weiToPrecisionLongString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {\n        if (decimal == 0) {\n            return string(abi.encodePacked(weiAmt.toString(), '.00'));\n        }\n\n        uint256 significantDigits = weiAmt / (10**decimal);\n        uint256 precisionDigits = weiAmt % (10**(decimal));\n\n        if (precisionDigits == 0) {\n            return string(abi.encodePacked(significantDigits.toString(), '.00'));\n        }\n\n        string memory precisionDigitsString = toStringTrimmed(precisionDigits);\n        uint256 lengthDiff = decimal - bytes(precisionDigits.toString()).length;\n        for (uint256 i; i < lengthDiff; i++) {\n            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));\n        }\n\n        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));\n    }\n\n    function weiToPrecisionString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {\n        if (decimal == 0) {\n            return string(abi.encodePacked(weiAmt.toString(), '.00'));\n        }\n\n        uint256 significantDigits = weiAmt / (10**decimal);\n        if (significantDigits > 1e9) {\n            string memory weiAmtString = weiAmt.toString();\n            uint256 len = bytes(weiAmtString).length - 9;\n            weiAmt = weiAmt / (10**len);\n            return string(abi.encodePacked(weiAmt.toString(), '...'));\n        }\n        uint256 precisionDigits = weiAmt % (10**(decimal));\n        precisionDigits = precisionDigits / (10**(decimal - 4));\n\n        if (precisionDigits == 0) {\n            return string(abi.encodePacked(significantDigits.toString(), '.00'));\n        }\n\n        string memory precisionDigitsString = toStringTrimmed(precisionDigits);\n        uint256 lengthDiff = 4 - bytes(precisionDigits.toString()).length;\n        for (uint256 i; i < lengthDiff; i++) {\n            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));\n        }\n\n        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));\n    }\n\n    function toStringTrimmed(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        uint256 flag;\n        while (temp != 0) {\n            if (flag == 0 && temp % 10 == 0) {\n                temp /= 10;\n                continue;\n            } else if (flag == 0 && temp % 10 != 0) {\n                flag++;\n                digits++;\n            } else {\n                digits++;\n            }\n\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        flag = 0;\n        while (value != 0) {\n            if (flag == 0 && value % 10 == 0) {\n                value /= 10;\n                continue;\n            } else if (flag == 0 && value % 10 != 0) {\n                flag++;\n                digits -= 1;\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            } else {\n                digits -= 1;\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            }\n\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function addressToString(address _addr) public pure returns (string memory) {\n        bytes memory data = abi.encodePacked(_addr);\n        bytes memory alphabet = '0123456789abcdef';\n\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint256 i; i < data.length; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    function getSlice(\n        uint256 begin,\n        uint256 end,\n        string memory text\n    ) public pure returns (string memory) {\n        bytes memory a = new bytes(end - begin + 1);\n        for (uint256 i; i <= end - begin; i++) {\n            a[i] = bytes(text)[i + begin - 1];\n        }\n        return string(a);\n    }\n\n    function parseSymbol(string memory symbol) public pure returns (string memory) {\n        if (bytes(symbol).length > 5) {\n            return getSlice(1, 5, symbol);\n        }\n        return symbol;\n    }\n\n    function getMonthString(uint256 _month) public pure returns (string memory) {\n        string[12] memory months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n        return months[_month];\n    }\n\n    function getReadableDateString(uint256 timestamp) public pure returns (string memory) {\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime\n            .timestampToDateTime(timestamp);\n\n        string memory result = string(\n            abi.encodePacked(\n                day.toString(),\n                ' ',\n                getMonthString(month - 1),\n                ' ',\n                year.toString(),\n                ', ',\n                padWithZero(hour),\n                ':',\n                padWithZero(minute),\n                ':',\n                padWithZero(second),\n                ' UTC'\n            )\n        );\n        return result;\n    }\n\n    function padWithZero(uint256 value) public pure returns (string memory) {\n        if (value < 10) {\n            return string(abi.encodePacked('0', value.toString()));\n        }\n        return value.toString();\n    }\n\n    function getLightColor(address token) public pure returns (string memory) {\n        string[15] memory lightColors = [\n            'F7BAF7',\n            'F7C8BA',\n            'FAE2BE',\n            'BAE1F7',\n            'EBF7BA',\n            'CEF7BA',\n            'CED2EF',\n            'CABAF7',\n            'BAF7E5',\n            'BACFF7',\n            'F7BAE3',\n            'F7E9BA',\n            'E0BAF7',\n            'F7BACF',\n            'FFFFFF'\n        ];\n        uint160 tokenValue = uint160(token) % 15;\n        return (lightColors[tokenValue]);\n    }\n\n    function getDarkColor(address token) public pure returns (string memory) {\n        string[15] memory darkColors = [\n            'DF51EC',\n            'EC7651',\n            'ECAE51',\n            '51B4EC',\n            'A4C327',\n            '59C327',\n            '5160EC',\n            '7951EC',\n            '27C394',\n            '5185EC',\n            'EC51B8',\n            'F4CB3A',\n            'B151EC',\n            'EC5184',\n            'C5C0C2'\n        ];\n        uint160 tokenValue = uint160(token) % 15;\n        return (darkColors[tokenValue]);\n    }\n\n    function getSVGCData(address asset, address collateral) public pure returns (string memory) {\n        string memory token0LightColor = string(abi.encodePacked('.C{fill:#', getLightColor(asset), '}'));\n        string memory token0DarkColor = string(abi.encodePacked('.D{fill:#', getDarkColor(asset), '}'));\n        string memory token1LightColor = string(abi.encodePacked('.E{fill:#', getLightColor(collateral), '}'));\n        string memory token1DarkColor = string(abi.encodePacked('.F{fill:#', getDarkColor(collateral), '}'));\n\n        return string(abi.encodePacked(token0LightColor, token0DarkColor, token1LightColor, token1DarkColor));\n    }\n}"
    },
    {
      "filename": "Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMetadata} from './SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {DateTime} from './DateTime.sol';\nimport './Base64.sol';\nimport {NFTSVG} from './NFTSVG.sol';\n\nlibrary NFTTokenURIScaffold {\n    using SafeMetadata for IERC20;\n    using Strings for uint256;\n\n    function tokenURI(\n        uint256 id,\n        IPair pair,\n        IPair.Due memory due,\n        uint256 maturity\n    ) public view returns (string memory) {\n        string memory uri = constructTokenSVG(\n            address(pair.asset()),\n            address(pair.collateral()),\n            id.toString(),\n            weiToPrecisionString(due.debt, pair.asset().safeDecimals()),\n            weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),\n            getReadableDateString(maturity),\n            maturity\n        );\n\n        string memory description = string(\n            abi.encodePacked(\n                'This collateralized debt position represents a debt of ',\n                weiToPrecisionString(due.debt, pair.asset().safeDecimals()),\n                ' ',\n                pair.asset().safeSymbol(),\n                ' borrowed against a collateral of ',\n                weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),\n                ' ',\n                pair.collateral().safeSymbol(),\n                '. This position will expire on ',\n                maturity.toString(),\n                ' unix epoch time.\\\\nThe owner of this NFT has the option to pay the debt before maturity time to claim the locked collateral. In case the owner choose to default on the debt payment, the collateral will be forfeited'\n            )\n        );\n        description = string(\n            abi.encodePacked(\n                description,\n                '\\\\n\\\\nAsset Address: ',\n                addressToString(address(pair.asset())),\n                '\\\\nCollateral Address: ',\n                addressToString(address(pair.collateral())),\n                '\\\\nDebt Required: ',\n                weiToPrecisionLongString(due.debt, pair.asset().safeDecimals()),\n                ' ',\n                IERC20(pair.asset()).safeSymbol(),\n                '\\\\nCollateral Locked: ',\n                weiToPrecisionLongString(due.collateral, pair.collateral().safeDecimals()),\n                ' ',\n                IERC20(pair.collateral()).safeSymbol()\n            )\n        );\n\n        string memory name = 'Timeswap Collateralized Debt';\n\n        return (constructTokenURI(name, description, uri));\n    }\n\n    function constructTokenURI(\n        string memory name,\n        string memory description,\n        string memory imageSVG\n    ) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    'data:application/json;base64,',\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"',\n                                name,\n                                '\", \"description\":\"',\n                                description,\n                                '\", \"image\": \"',\n                                'data:image/svg+xml;base64,',\n                                Base64.encode(bytes(imageSVG)),\n                                '\"}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function constructTokenSVG(\n        address asset,\n        address collateral,\n        string memory tokenId,\n        string memory assetAmount,\n        string memory collateralAmount,\n        string memory maturityDate,\n        uint256 maturityTimestamp\n    ) internal view returns (string memory) {\n        NFTSVG.SVGParams memory params = NFTSVG.SVGParams({\n            tokenId: tokenId,\n            svgTitle: string(\n                abi.encodePacked(\n                    parseSymbol(IERC20(asset).safeSymbol()),\n                    '/',\n                    parseSymbol(IERC20(collateral).safeSymbol())\n                )\n            ),\n            assetInfo: string(abi.encodePacked(parseSymbol(IERC20(asset).safeSymbol()), ': ', addressToString(asset))),\n            collateralInfo: string(\n                abi.encodePacked(parseSymbol(IERC20(collateral).safeSymbol()), ': ', addressToString(collateral))\n            ),\n            debtRequired: string(abi.encodePacked(assetAmount, ' ', parseSymbol(IERC20(asset).safeSymbol()))),\n            collateralLocked: string(\n                abi.encodePacked(collateralAmount, ' ', parseSymbol(IERC20(collateral).safeSymbol()))\n            ),\n            maturityDate: maturityDate,\n            isMatured: block.timestamp > maturityTimestamp,\n            maturityTimestampString: maturityTimestamp.toString(),\n            tokenColors: getSVGCData(asset, collateral)\n        });\n\n        return NFTSVG.constructSVG(params);\n    }\n\n    function weiToPrecisionLongString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {\n        if (decimal == 0) {\n            return string(abi.encodePacked(weiAmt.toString(), '.00'));\n        }\n\n        uint256 significantDigits = weiAmt / (10**decimal);\n        uint256 precisionDigits = weiAmt % (10**(decimal));\n\n        if (precisionDigits == 0) {\n            return string(abi.encodePacked(significantDigits.toString(), '.00'));\n        }\n\n        string memory precisionDigitsString = toStringTrimmed(precisionDigits);\n        uint256 lengthDiff = decimal - bytes(precisionDigits.toString()).length;\n        for (uint256 i; i < lengthDiff; i++) {\n            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));\n        }\n\n        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));\n    }\n\n    function weiToPrecisionString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {\n        if (decimal == 0) {\n            return string(abi.encodePacked(weiAmt.toString(), '.00'));\n        }\n\n        uint256 significantDigits = weiAmt / (10**decimal);\n        if (significantDigits > 1e9) {\n            string memory weiAmtString = weiAmt.toString();\n            uint256 len = bytes(weiAmtString).length - 9;\n            weiAmt = weiAmt / (10**len);\n            return string(abi.encodePacked(weiAmt.toString(), '...'));\n        }\n        uint256 precisionDigits = weiAmt % (10**(decimal));\n        precisionDigits = precisionDigits / (10**(decimal - 4));\n\n        if (precisionDigits == 0) {\n            return string(abi.encodePacked(significantDigits.toString(), '.00'));\n        }\n\n        string memory precisionDigitsString = toStringTrimmed(precisionDigits);\n        uint256 lengthDiff = 4 - bytes(precisionDigits.toString()).length;\n        for (uint256 i; i < lengthDiff; i++) {\n            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));\n        }\n\n        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));\n    }\n\n    function toStringTrimmed(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        uint256 flag;\n        while (temp != 0) {\n            if (flag == 0 && temp % 10 == 0) {\n                temp /= 10;\n                continue;\n            } else if (flag == 0 && temp % 10 != 0) {\n                flag++;\n                digits++;\n            } else {\n                digits++;\n            }\n\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        flag = 0;\n        while (value != 0) {\n            if (flag == 0 && value % 10 == 0) {\n                value /= 10;\n                continue;\n            } else if (flag == 0 && value % 10 != 0) {\n                flag++;\n                digits -= 1;\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            } else {\n                digits -= 1;\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            }\n\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function addressToString(address _addr) public pure returns (string memory) {\n        bytes memory data = abi.encodePacked(_addr);\n        bytes memory alphabet = '0123456789abcdef';\n\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint256 i; i < data.length; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    function getSlice(\n        uint256 begin,\n        uint256 end,\n        string memory text\n    ) public pure returns (string memory) {\n        bytes memory a = new bytes(end - begin + 1);\n        for (uint256 i; i <= end - begin; i++) {\n            a[i] = bytes(text)[i + begin - 1];\n        }\n        return string(a);\n    }\n\n    function parseSymbol(string memory symbol) public pure returns (string memory) {\n        if (bytes(symbol).length > 5) {\n            return getSlice(1, 5, symbol);\n        }\n        return symbol;\n    }\n\n    function getMonthString(uint256 _month) public pure returns (string memory) {\n        string[12] memory months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n        return months[_month];\n    }\n\n    function getReadableDateString(uint256 timestamp) public pure returns (string memory) {\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime\n            .timestampToDateTime(timestamp);\n\n        string memory result = string(\n            abi.encodePacked(\n                day.toString(),\n                ' ',\n                getMonthString(month - 1),\n                ' ',\n                year.toString(),\n                ', ',\n                padWithZero(hour),\n                ':',\n                padWithZero(minute),\n                ':',\n                padWithZero(second),\n                ' UTC'\n            )\n        );\n        return result;\n    }\n\n    function padWithZero(uint256 value) public pure returns (string memory) {\n        if (value < 10) {\n            return string(abi.encodePacked('0', value.toString()));\n        }\n        return value.toString();\n    }\n\n    function getLightColor(address token) public pure returns (string memory) {\n        string[15] memory lightColors = [\n            'F7BAF7',\n            'F7C8BA',\n            'FAE2BE',\n            'BAE1F7',\n            'EBF7BA',\n            'CEF7BA',\n            'CED2EF',\n            'CABAF7',\n            'BAF7E5',\n            'BACFF7',\n            'F7BAE3',\n            'F7E9BA',\n            'E0BAF7',\n            'F7BACF',\n            'FFFFFF'\n        ];\n        uint160 tokenValue = uint160(token) % 15;\n        return (lightColors[tokenValue]);\n    }\n\n    function getDarkColor(address token) public pure returns (string memory) {\n        string[15] memory darkColors = [\n            'DF51EC',\n            'EC7651',\n            'ECAE51',\n            '51B4EC',\n            'A4C327',\n            '59C327',\n            '5160EC',\n            '7951EC',\n            '27C394',\n            '5185EC',\n            'EC51B8',\n            'F4CB3A',\n            'B151EC',\n            'EC5184',\n            'C5C0C2'\n        ];\n        uint160 tokenValue = uint160(token) % 15;\n        return (darkColors[tokenValue]);\n    }\n\n    function getSVGCData(address asset, address collateral) public pure returns (string memory) {\n        string memory token0LightColor = string(abi.encodePacked('.C{fill:#', getLightColor(asset), '}'));\n        string memory token0DarkColor = string(abi.encodePacked('.D{fill:#', getDarkColor(asset), '}'));\n        string memory token1LightColor = string(abi.encodePacked('.E{fill:#', getLightColor(collateral), '}'));\n        string memory token1DarkColor = string(abi.encodePacked('.F{fill:#', getDarkColor(collateral), '}'));\n\n        return string(abi.encodePacked(token0LightColor, token0DarkColor, token1LightColor, token1DarkColor));\n    }\n}"
    },
    {
      "filename": "Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeMetadata} from './SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {DateTime} from './DateTime.sol';\nimport './Base64.sol';\nimport {NFTSVG} from './NFTSVG.sol';\n\nlibrary NFTTokenURIScaffold {\n    using SafeMetadata for IERC20;\n    using Strings for uint256;\n\n    function tokenURI(\n        uint256 id,\n        IPair pair,\n        IPair.Due memory due,\n        uint256 maturity\n    ) public view returns (string memory) {\n        string memory uri = constructTokenSVG(\n            address(pair.asset()),\n            address(pair.collateral()),\n            id.toString(),\n            weiToPrecisionString(due.debt, pair.asset().safeDecimals()),\n            weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),\n            getReadableDateString(maturity),\n            maturity\n        );\n\n        string memory description = string(\n            abi.encodePacked(\n                'This collateralized debt position represents a debt of ',\n                weiToPrecisionString(due.debt, pair.asset().safeDecimals()),\n                ' ',\n                pair.asset().safeSymbol(),\n                ' borrowed against a collateral of ',\n                weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),\n                ' ',\n                pair.collateral().safeSymbol(),\n                '. This position will expire on ',\n                maturity.toString(),\n                ' unix epoch time.\\\\nThe owner of this NFT has the option to pay the debt before maturity time to claim the locked collateral. In case the owner choose to default on the debt payment, the collateral will be forfeited'\n            )\n        );\n        description = string(\n            abi.encodePacked(\n                description,\n                '\\\\n\\\\nAsset Address: ',\n                addressToString(address(pair.asset())),\n                '\\\\nCollateral Address: ',\n                addressToString(address(pair.collateral())),\n                '\\\\nDebt Required: ',\n                weiToPrecisionLongString(due.debt, pair.asset().safeDecimals()),\n                ' ',\n                IERC20(pair.asset()).safeSymbol(),\n                '\\\\nCollateral Locked: ',\n                weiToPrecisionLongString(due.collateral, pair.collateral().safeDecimals()),\n                ' ',\n                IERC20(pair.collateral()).safeSymbol()\n            )\n        );\n\n        string memory name = 'Timeswap Collateralized Debt';\n\n        return (constructTokenURI(name, description, uri));\n    }\n\n    function constructTokenURI(\n        string memory name,\n        string memory description,\n        string memory imageSVG\n    ) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    'data:application/json;base64,',\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"',\n                                name,\n                                '\", \"description\":\"',\n                                description,\n                                '\", \"image\": \"',\n                                'data:image/svg+xml;base64,',\n                                Base64.encode(bytes(imageSVG)),\n                                '\"}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function constructTokenSVG(\n        address asset,\n        address collateral,\n        string memory tokenId,\n        string memory assetAmount,\n        string memory collateralAmount,\n        string memory maturityDate,\n        uint256 maturityTimestamp\n    ) internal view returns (string memory) {\n        NFTSVG.SVGParams memory params = NFTSVG.SVGParams({\n            tokenId: tokenId,\n            svgTitle: string(\n                abi.encodePacked(\n                    parseSymbol(IERC20(asset).safeSymbol()),\n                    '/',\n                    parseSymbol(IERC20(collateral).safeSymbol())\n                )\n            ),\n            assetInfo: string(abi.encodePacked(parseSymbol(IERC20(asset).safeSymbol()), ': ', addressToString(asset))),\n            collateralInfo: string(\n                abi.encodePacked(parseSymbol(IERC20(collateral).safeSymbol()), ': ', addressToString(collateral))\n            ),\n            debtRequired: string(abi.encodePacked(assetAmount, ' ', parseSymbol(IERC20(asset).safeSymbol()))),\n            collateralLocked: string(\n                abi.encodePacked(collateralAmount, ' ', parseSymbol(IERC20(collateral).safeSymbol()))\n            ),\n            maturityDate: maturityDate,\n            isMatured: block.timestamp > maturityTimestamp,\n            maturityTimestampString: maturityTimestamp.toString(),\n            tokenColors: getSVGCData(asset, collateral)\n        });\n\n        return NFTSVG.constructSVG(params);\n    }\n\n    function weiToPrecisionLongString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {\n        if (decimal == 0) {\n            return string(abi.encodePacked(weiAmt.toString(), '.00'));\n        }\n\n        uint256 significantDigits = weiAmt / (10**decimal);\n        uint256 precisionDigits = weiAmt % (10**(decimal));\n\n        if (precisionDigits == 0) {\n            return string(abi.encodePacked(significantDigits.toString(), '.00'));\n        }\n\n        string memory precisionDigitsString = toStringTrimmed(precisionDigits);\n        uint256 lengthDiff = decimal - bytes(precisionDigits.toString()).length;\n        for (uint256 i; i < lengthDiff; i++) {\n            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));\n        }\n\n        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));\n    }\n\n    function weiToPrecisionString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {\n        if (decimal == 0) {\n            return string(abi.encodePacked(weiAmt.toString(), '.00'));\n        }\n\n        uint256 significantDigits = weiAmt / (10**decimal);\n        if (significantDigits > 1e9) {\n            string memory weiAmtString = weiAmt.toString();\n            uint256 len = bytes(weiAmtString).length - 9;\n            weiAmt = weiAmt / (10**len);\n            return string(abi.encodePacked(weiAmt.toString(), '...'));\n        }\n        uint256 precisionDigits = weiAmt % (10**(decimal));\n        precisionDigits = precisionDigits / (10**(decimal - 4));\n\n        if (precisionDigits == 0) {\n            return string(abi.encodePacked(significantDigits.toString(), '.00'));\n        }\n\n        string memory precisionDigitsString = toStringTrimmed(precisionDigits);\n        uint256 lengthDiff = 4 - bytes(precisionDigits.toString()).length;\n        for (uint256 i; i < lengthDiff; i++) {\n            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));\n        }\n\n        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));\n    }\n\n    function toStringTrimmed(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n        uint256 temp = value;\n        uint256 digits;\n        uint256 flag;\n        while (temp != 0) {\n            if (flag == 0 && temp % 10 == 0) {\n                temp /= 10;\n                continue;\n            } else if (flag == 0 && temp % 10 != 0) {\n                flag++;"
    }
  ]
}