{
  "Title": "[L06] Missing and / or incomplete docstrings",
  "Content": "Some contracts and functions in the code base lack documentation or include incomplete descriptions. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. Below we list all instances detected during the audit.\n\n\nIn the `Constants` library:\n\n\n* Several constants lack their documentation stating its purpose and the reason of its value, such as the [`FCASH_ASSET_TYPE` constant](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/global/Constants.sol#L64).\n\n\nIn the `GovernorAlpha` contract:\n\n\n* The [`getReceipt` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L332-L337) is missing a docstring for the `return` value.\n* The [`state` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L341) contains an incomplete docstring for the `return` value.\n* The [`updateQuorumVotes` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L432-L436) is missing all its documentation.\n* The [`updateProposalThreshold` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L438-L442) is missing all its documentation.\n* The [`updateVotingDelayBlocks` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L444-L448) is missing all its documentation.\n* The [`updateVotingPeriodBlocks` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L450-L454) is missing all its documentation.\n* The [`constructor` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L126) is missing all its documentation.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Partially fixed in [pull request 27](https://github.com/notional-finance/contracts-v2/pull/27/files). No documentation has been added to the `Constants` library, such as on the [`FCASH_ASSET_TYPE` constant](https://github.com/notional-finance/contracts-v2/blob/d17291485837134d066558a7bec78220bb634976/contracts/global/Constants.sol#L64).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/global/Constants.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\n\n/// @title All shared constants for the Notional system should be declared here.\nlibrary Constants {\n    // Token precision used for all internal balances, TokenHandler library ensures that we\n    // limit the dust amount caused by precision mismatches\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\n\n    // ETH will be initialized as the first currency\n    uint256 internal constant ETH_CURRENCY_ID = 1;\n    int256 internal constant ETH_DECIMAL_PLACES = 18;\n    int256 internal constant ETH_DECIMALS = 1e18;\n\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\n    uint256 internal constant DELEVERAGE_BUFFER = 30000000; // 300 * Constants.BASIS_POINT\n\n    // Address of the reserve account\n    address internal constant RESERVE = address(0);\n    // NOTE: this address is hardcoded in the library, must update this on deployment\n    address constant NOTE_TOKEN_ADDRESS = 0x46B2efE8BE4a97F05826264E88148fc083D595BD;\n\n    // Most significant bit\n    bytes32 internal constant MSB =\n        0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    // Basis for percentages\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\n    // for a bitmap portfolio\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\n\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\n    uint256 internal constant DAY = 86400;\n    // We use six day weeks to ensure that all time references divide evenly\n    uint256 internal constant WEEK = DAY * 6;\n    uint256 internal constant MONTH = DAY * 30;\n    uint256 internal constant QUARTER = DAY * 90;\n    uint256 internal constant YEAR = QUARTER * 4;\n\n    // Offsets for each time chunk denominated in days\n    uint256 internal constant MAX_DAY_OFFSET = 90;\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\n\n    // Offsets for each time chunk denominated in bits\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\n\n    // This is a constant that represents the time period that all rates are normalized by, 360 days\n    uint256 internal constant IMPLIED_RATE_TIME = 31104000;\n    // Number of decimal places that rates are stored in, equals 100%\n    int256 internal constant RATE_PRECISION = 1e9;\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\n\n    // This is the ABDK64x64 representation of RATE_PRECISION\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\n\n    uint256 internal constant FCASH_ASSET_TYPE = 1;\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\n    uint256 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\n    uint256 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\n\n    bytes1 internal constant BOOL_FALSE = 0x00;\n    bytes1 internal constant BOOL_TRUE = 0x01;\n\n    // Account context flags\n    bytes1 internal constant HAS_ASSET_DEBT = 0x01;\n    bytes1 internal constant HAS_CASH_DEBT = 0x02;\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO = 0x8000;\n    bytes2 internal constant ACTIVE_IN_BALANCES = 0x4000;\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\n\n    // nToken Parameters\n    int256 internal constant DEPOSIT_PERCENT_BASIS = 1e8;\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\n    uint8 internal constant ASSET_ARRAY_LENGTH = 5;\n\n    // Liquidation parameters\n    /// @dev Default portion of collateral that a liquidator is allowed to liquidate, will be higher if the account\n    /// requires more collateral to be liquidated\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\n    /// @dev Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 10;\n    /// @dev Liquidation dust setting used during fCash liquidation\n    int256 internal constant LIQUIDATION_DUST = 10;\n\n    /// @dev Annual incentive multiplier as a percentage\n    uint256 internal constant ANNUAL_INCENTIVE_MULTIPLIER_PERCENT = 50;\n    /// @dev Caps the max incentive multiplier to 2 years (i.e. 1 + 2 years * 0.5 == 2)\n    uint256 internal constant MAX_INCENTIVE_MULTIPLIER = 2e8;\n}"
    },
    {
      "filename": "contracts/external/governance/GovernorAlpha.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../global/Constants.sol\";\nimport \"@openzeppelin/contracts/access/TimelockController.sol\";\n\n/**\n * @title Notional Governor Alpha\n * Fork of Compound Governor Alpha at commit hash\n * https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\n */\ncontract GovernorAlpha is TimelockController {\n    /// @notice The name of this contract\n    string public constant name = \"Notional Governor Alpha\";\n\n    /// @notice The address of the Notional governance token\n    NoteInterface public immutable note;\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint8 public constant proposalMaxOperations = 10;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    uint96 public quorumVotes;\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    uint96 public proposalThreshold;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    uint32 public votingDelayBlocks;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint32 public votingPeriodBlocks;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // The timestamp at which voting begins: holders must delegate their votes prior to this block\n        uint32 startBlock;\n        // The timestamp at which voting ends: votes must be cast prior to this block\n        uint32 endBlock;\n        // Current number of votes in favor of this proposal\n        uint96 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint96 againstVotes;\n        // Creator of the proposal\n        address proposer;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n        // Hash of the operation to reduce storage cost\n        bytes32 operationHash;\n    }\n\n    // Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal\n        bool support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice Receipts of ballots for the entire set of voters\n    mapping(uint256 => mapping(address => Receipt)) public receipts;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct uComp by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    /// @notice An event emitted when amount of quorum votes required is updated\n    event UpdateQuorumVotes(uint96 newQuorumVotes);\n\n    /// @notice An event emitted when a new proposal threshold has been set\n    event UpdateProposalThreshold(uint96 newProposalThreshold);\n\n    /// @notice An event emitted when a new voting delay in blocks has been set\n    event UpdateVotingDelayBlocks(uint32 newVotingDelayBlocks);\n\n    /// @notice An event emitted when a new voting period in blocks has been set\n    event UpdateVotingPeriodBlocks(uint32 newVotingPeriodBlocks);\n\n    constructor(\n        uint96 quorumVotes_,\n        uint96 proposalThreshold_,\n        uint32 votingDelayBlocks_,\n        uint32 votingPeriodBlocks_,\n        address note_,\n        address guardian_,\n        uint256 minDelay_\n    ) TimelockController(minDelay_, new address[](0), new address[](0)) {\n        quorumVotes = quorumVotes_;\n        proposalThreshold = proposalThreshold_;\n        votingDelayBlocks = votingDelayBlocks_;\n        votingPeriodBlocks = votingPeriodBlocks_;\n        note = NoteInterface(note_);\n        guardian = guardian_;\n\n        // Only the external methods can be used to execute governance\n        grantRole(PROPOSER_ROLE, address(this));\n        grantRole(EXECUTOR_ROLE, address(this));\n        revokeRole(TIMELOCK_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @notice Proposes a new governance action\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalCreated\n    /// @return newly created proposal id\n    function propose(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external returns (uint256) {\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber < type(uint32).max);\n\n        require(\n            note.getPriorVotes(msg.sender, blockNumber - 1) > proposalThreshold,\n            \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(\n            targets.length <= proposalMaxOperations,\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        {\n            uint256 latestProposalId = latestProposalIds[msg.sender];\n            if (latestProposalId != 0) {\n                ProposalState proposersLatestProposalState = state(latestProposalId);\n                require(\n                    proposersLatestProposalState != ProposalState.Active,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n                );\n                require(\n                    proposersLatestProposalState != ProposalState.Pending,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n                );\n            }\n        }\n\n        uint256 newProposalId = proposalCount + 1;\n        proposalCount = newProposalId;\n\n        uint32 startBlock = _add32(uint32(blockNumber), votingDelayBlocks);\n        uint32 endBlock = _add32(startBlock, votingPeriodBlocks);\n        bytes32 operationHash = _computeHash(targets, values, calldatas, newProposalId);\n\n        Proposal memory newProposal =\n            Proposal({\n                id: newProposalId,\n                proposer: msg.sender,\n                startBlock: startBlock,\n                endBlock: endBlock,\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false,\n                operationHash: operationHash\n            });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            calldatas,\n            startBlock,\n            endBlock\n        );\n        return newProposal.id;\n    }\n\n    /// @dev Helper method required to clear the stack for hashing operations\n    function _computeHash(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private pure returns (bytes32) {\n        return hashOperationBatch(targets, values, calldatas, \"\", bytes32(proposalId));\n    }\n\n    /// @notice Adds a proposal to the timelock queue only after its vote has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal. All proposals\n    /// will automatically be delayed `getMinDelay()` seconds.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalQueued emit:CallScheduled (per call)\n    function queueProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external {\n        require(state(proposalId) == ProposalState.Succeeded, \"Proposal must be success\");\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        {\n            Proposal storage proposal = proposals[proposalId];\n            require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        }\n\n        _scheduleBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalQueued(proposalId, getMinDelay());\n    }\n\n    /// @dev Required to clear the stack for calling the timelock controller\n    function _scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        // NOTE: this will also emit events\n        this.scheduleBatch(targets, values, calldatas, \"\", bytes32(proposalId), getMinDelay());\n    }\n\n    /// @notice Executes a proposal in the timelock queue after its delay has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalExecuted emit:CallExecuted (per call)\n    function executeProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external payable {\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        // Execute batch will revert if the call has not been scheduled\n        _executeBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalExecuted(proposalId);\n    }\n\n    /// @dev Helper function to clear the stack for the timelock controller call\n    function _executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        this.executeBatch(targets, values, calldatas, \"\", bytes32(proposalId));\n    }\n\n    /// @notice Cancels a proposal after it has been created. Can only be done if the proposer\n    /// no longer has sufficient votes (i.e. they made a proposal and then sold their tokens) or\n    /// by a guardian address if it exists.\n    /// @param proposalId unique identifier for the proposal\n    /// @dev emit:ProposalCanceled emit:Cancelled\n    function cancelProposal(uint256 proposalId) public {\n        ProposalState proposalState = state(proposalId);\n        require(proposalState != ProposalState.Executed, \"Proposal already executed\");\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0);\n        require(\n            msg.sender == guardian ||\n                note.getPriorVotes(proposal.proposer, blockNumber - 1) < proposalThreshold,\n            \"GovernorAlpha::cancel: proposer above threshold\"\n        );\n\n        proposal.canceled = true;\n        // Removes the operation hash from the timelock controller if pending.\n        if (isOperationPending(proposal.operationHash)) this.cancel(proposal.operationHash);\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /// @notice Returns the voting receipt for a voter on a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param voter address of the voter\n    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n        return receipts[proposalId][voter];\n    }\n\n    /// @notice Returns the current state of a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @return ProposalState\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"GovernorAlpha::state: invalid proposal id\"\n        );\n        Proposal memory proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (blockNumber <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (blockNumber <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\n            return ProposalState.Defeated;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (\n            proposal.forVotes > proposal.againstVotes &&\n            proposal.forVotes > quorumVotes &&\n            blockNumber >= proposal.endBlock\n        ) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @notice Cast a vote for a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @dev emit:VoteCast\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /// @notice Cast a vote for a proposal via signature\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @param v signature component\n    /// @param r signature component\n    /// @param s signature component\n    /// @dev emit:VoteCast\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /// @dev Registers a vote, calls the NOTE token to get the voting power for the voter\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorAlpha::_castVote: voting is closed\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = receipts[proposalId][voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = note.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) {\n            proposal.forVotes = _add96(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = _add96(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    function updateQuorumVotes(uint96 newQuorumVotes) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        quorumVotes = newQuorumVotes;\n        emit UpdateQuorumVotes(newQuorumVotes);\n    }\n\n    function updateProposalThreshold(uint96 newProposalThreshold) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        proposalThreshold = newProposalThreshold;\n        emit UpdateProposalThreshold(newProposalThreshold);\n    }\n\n    function updateVotingDelayBlocks(uint32 newVotingDelayBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        votingDelayBlocks = newVotingDelayBlocks;\n        emit UpdateVotingDelayBlocks(newVotingDelayBlocks);\n    }\n\n    function updateVotingPeriodBlocks(uint32 newVotingPeriodBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        votingPeriodBlocks = newVotingPeriodBlocks;\n        emit UpdateVotingPeriodBlocks(newVotingPeriodBlocks);\n    }\n\n    /// @dev Hidden public method\n    function __abdicate() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    }\n\n    /// @dev Overflow check for adding votes\n    function _add96(uint96 a, uint96 b) private pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Overflow check for adding block numbers\n    function _add32(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Helper method for signature check\n    function _getChainId() private pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\ninterface NoteInterface {\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n}"
    },
    {
      "filename": "contracts/external/governance/GovernorAlpha.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../global/Constants.sol\";\nimport \"@openzeppelin/contracts/access/TimelockController.sol\";\n\n/**\n * @title Notional Governor Alpha\n * Fork of Compound Governor Alpha at commit hash\n * https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\n */\ncontract GovernorAlpha is TimelockController {\n    /// @notice The name of this contract\n    string public constant name = \"Notional Governor Alpha\";\n\n    /// @notice The address of the Notional governance token\n    NoteInterface public immutable note;\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint8 public constant proposalMaxOperations = 10;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    uint96 public quorumVotes;\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    uint96 public proposalThreshold;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    uint32 public votingDelayBlocks;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint32 public votingPeriodBlocks;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // The timestamp at which voting begins: holders must delegate their votes prior to this block\n        uint32 startBlock;\n        // The timestamp at which voting ends: votes must be cast prior to this block\n        uint32 endBlock;\n        // Current number of votes in favor of this proposal\n        uint96 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint96 againstVotes;\n        // Creator of the proposal\n        address proposer;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n        // Hash of the operation to reduce storage cost\n        bytes32 operationHash;\n    }\n\n    // Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal\n        bool support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice Receipts of ballots for the entire set of voters\n    mapping(uint256 => mapping(address => Receipt)) public receipts;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct uComp by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    /// @notice An event emitted when amount of quorum votes required is updated\n    event UpdateQuorumVotes(uint96 newQuorumVotes);\n\n    /// @notice An event emitted when a new proposal threshold has been set\n    event UpdateProposalThreshold(uint96 newProposalThreshold);\n\n    /// @notice An event emitted when a new voting delay in blocks has been set\n    event UpdateVotingDelayBlocks(uint32 newVotingDelayBlocks);\n\n    /// @notice An event emitted when a new voting period in blocks has been set\n    event UpdateVotingPeriodBlocks(uint32 newVotingPeriodBlocks);\n\n    constructor(\n        uint96 quorumVotes_,\n        uint96 proposalThreshold_,\n        uint32 votingDelayBlocks_,\n        uint32 votingPeriodBlocks_,\n        address note_,\n        address guardian_,\n        uint256 minDelay_\n    ) TimelockController(minDelay_, new address[](0), new address[](0)) {\n        quorumVotes = quorumVotes_;\n        proposalThreshold = proposalThreshold_;\n        votingDelayBlocks = votingDelayBlocks_;\n        votingPeriodBlocks = votingPeriodBlocks_;\n        note = NoteInterface(note_);\n        guardian = guardian_;\n\n        // Only the external methods can be used to execute governance\n        grantRole(PROPOSER_ROLE, address(this));\n        grantRole(EXECUTOR_ROLE, address(this));\n        revokeRole(TIMELOCK_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @notice Proposes a new governance action\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalCreated\n    /// @return newly created proposal id\n    function propose(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external returns (uint256) {\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber < type(uint32).max);\n\n        require(\n            note.getPriorVotes(msg.sender, blockNumber - 1) > proposalThreshold,\n            \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(\n            targets.length <= proposalMaxOperations,\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        {\n            uint256 latestProposalId = latestProposalIds[msg.sender];\n            if (latestProposalId != 0) {\n                ProposalState proposersLatestProposalState = state(latestProposalId);\n                require(\n                    proposersLatestProposalState != ProposalState.Active,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n                );\n                require(\n                    proposersLatestProposalState != ProposalState.Pending,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n                );\n            }\n        }\n\n        uint256 newProposalId = proposalCount + 1;\n        proposalCount = newProposalId;\n\n        uint32 startBlock = _add32(uint32(blockNumber), votingDelayBlocks);\n        uint32 endBlock = _add32(startBlock, votingPeriodBlocks);\n        bytes32 operationHash = _computeHash(targets, values, calldatas, newProposalId);\n\n        Proposal memory newProposal =\n            Proposal({\n                id: newProposalId,\n                proposer: msg.sender,\n                startBlock: startBlock,\n                e"
    }
  ]
}