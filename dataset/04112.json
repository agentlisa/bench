{
  "Title": "Decimals Mismatch in Reserve Configuration Update",
  "Content": "##### Description\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/lendingpool/LendingPoolConfigurator.sol#L533 \n\nChanging the decimals here will not automatically change the decimals either in the aToken or in the debt tokens.\n\n```solidity\nfunction setReserveDecimals(address asset, uint256 decimals) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setDecimals(decimals);\n\n    pool.setConfiguration(asset, currentConfig.data);\n```\n\nAdditionally, the oracle must be updated simultaneously to consider the new value of the decimals. Otherwise, significant mispricing and liquidations may occur. \n##### Recommendation\nWe suggest removing this function. Alternatively, the change may be allowed only for inactive reserve and must be propagated to the tokens.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/lendingpool/LendingPoolConfigurator.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {\n  VersionedInitializable\n} from '../libraries/openzeppelin-upgradeability/VersionedInitializable.sol';\nimport {\n  InitializableAdminUpgradeabilityProxy\n} from '../libraries/openzeppelin-upgradeability/InitializableAdminUpgradeabilityProxy.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\nimport {IERC20Detailed} from '../interfaces/IERC20Detailed.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\n\n/**\n * @title LendingPoolConfigurator contract\n * @author Aave\n * @notice Executes configuration methods on the LendingPoolCore contract. Allows to enable/disable reserves\n * and set different protocol parameters.\n **/\n\ncontract LendingPoolConfigurator is VersionedInitializable {\n  using SafeMath for uint256;\n  using ReserveConfiguration for ReserveConfiguration.Map;\n\n  /**\n   * @dev emitted when a reserve is initialized.\n   * @param asset the address of the reserve\n   * @param aToken the address of the overlying aToken contract\n   * @param stableDebtToken the address of the associated stable rate debt token\n   * @param variableDebtToken the address of the associated variable rate debt token\n   * @param interestRateStrategyAddress the address of the interest rate strategy for the reserve\n   **/\n  event ReserveInitialized(\n    address indexed asset,\n    address indexed aToken,\n    address stableDebtToken,\n    address variableDebtToken,\n    address interestRateStrategyAddress\n  );\n\n  /**\n   * @dev emitted when borrowing is enabled on a reserve\n   * @param asset the address of the reserve\n   * @param stableRateEnabled true if stable rate borrowing is enabled, false otherwise\n   **/\n  event BorrowingEnabledOnReserve(address asset, bool stableRateEnabled);\n\n  /**\n   * @dev emitted when borrowing is disabled on a reserve\n   * @param asset the address of the reserve\n   **/\n  event BorrowingDisabledOnReserve(address indexed asset);\n\n  /**\n   * @dev emitted when a reserve is enabled as collateral.\n   * @param asset the address of the reserve\n   * @param ltv the loan to value of the asset when used as collateral\n   * @param liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus the bonus liquidators receive to liquidate this asset\n   **/\n  event ReserveEnabledAsCollateral(\n    address indexed asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  );\n\n  /**\n   * @dev emitted when a reserve is disabled as collateral\n   * @param asset the address of the reserve\n   **/\n  event ReserveDisabledAsCollateral(address indexed asset);\n\n  /**\n   * @dev emitted when stable rate borrowing is enabled on a reserve\n   * @param asset the address of the reserve\n   **/\n  event StableRateEnabledOnReserve(address indexed asset);\n\n  /**\n   * @dev emitted when stable rate borrowing is disabled on a reserve\n   * @param asset the address of the reserve\n   **/\n  event StableRateDisabledOnReserve(address indexed asset);\n\n  /**\n   * @dev emitted when a reserve is activated\n   * @param asset the address of the reserve\n   **/\n  event ReserveActivated(address indexed asset);\n\n  /**\n   * @dev emitted when a reserve is deactivated\n   * @param asset the address of the reserve\n   **/\n  event ReserveDeactivated(address indexed asset);\n\n  /**\n   * @dev emitted when a reserve is freezed\n   * @param asset the address of the reserve\n   **/\n  event ReserveFreezed(address indexed asset);\n\n  /**\n   * @dev emitted when a reserve is unfreezed\n   * @param asset the address of the reserve\n   **/\n  event ReserveUnfreezed(address indexed asset);\n\n  /**\n   * @dev emitted when a reserve loan to value is updated\n   * @param asset the address of the reserve\n   * @param ltv the new value for the loan to value\n   **/\n  event ReserveBaseLtvChanged(address asset, uint256 ltv);\n\n  /**\n   * @dev emitted when a reserve factor is updated\n   * @param asset the address of the reserve\n   * @param factor the new reserve factor\n   **/\n  event ReserveFactorChanged(address asset, uint256 factor);\n\n  /**\n   * @dev emitted when a reserve liquidation threshold is updated\n   * @param asset the address of the reserve\n   * @param threshold the new value for the liquidation threshold\n   **/\n  event ReserveLiquidationThresholdChanged(address asset, uint256 threshold);\n\n  /**\n   * @dev emitted when a reserve liquidation bonus is updated\n   * @param asset the address of the reserve\n   * @param bonus the new value for the liquidation bonus\n   **/\n  event ReserveLiquidationBonusChanged(address asset, uint256 bonus);\n\n  /**\n   * @dev emitted when the reserve decimals are updated\n   * @param asset the address of the reserve\n   * @param decimals the new decimals\n   **/\n  event ReserveDecimalsChanged(address asset, uint256 decimals);\n\n  /**\n   * @dev emitted when a reserve interest strategy contract is updated\n   * @param asset the address of the reserve\n   * @param strategy the new address of the interest strategy contract\n   **/\n  event ReserveInterestRateStrategyChanged(address asset, address strategy);\n\n  /**\n   * @dev emitted when an aToken implementation is upgraded\n   * @param asset the address of the reserve\n   * @param proxy the aToken proxy address\n   * @param implementation the new aToken implementation\n   **/\n  event ATokenUpgraded(address asset, address proxy, address implementation);\n\n  /**\n   * @dev emitted when the implementation of a stable debt token is upgraded\n   * @param asset the address of the reserve\n   * @param proxy the stable debt token proxy address\n   * @param implementation the new aToken implementation\n   **/\n  event StableDebtTokenUpgraded(address asset, address proxy, address implementation);\n\n  /**\n   * @dev emitted when the implementation of a variable debt token is upgraded\n   * @param asset the address of the reserve\n   * @param proxy the variable debt token proxy address\n   * @param implementation the new aToken implementation\n   **/\n  event VariableDebtTokenUpgraded(address asset, address proxy, address implementation);\n\n  ILendingPoolAddressesProvider internal addressesProvider;\n  ILendingPool internal pool;\n\n  /**\n   * @dev only the lending pool manager can call functions affected by this modifier\n   **/\n  modifier onlyAaveAdmin {\n    require(addressesProvider.getAaveAdmin() == msg.sender, Errors.CALLER_NOT_AAVE_ADMIN);\n    _;\n  }\n\n  uint256 public constant CONFIGURATOR_REVISION = 0x3;\n\n  function getRevision() internal override pure returns (uint256) {\n    return CONFIGURATOR_REVISION;\n  }\n\n  function initialize(ILendingPoolAddressesProvider provider) public initializer {\n    addressesProvider = provider;\n    pool = ILendingPool(addressesProvider.getLendingPool());\n  }\n\n  /**\n   * @dev initializes a reserve\n   * @param asset the address of the reserve to be initialized\n   * @param aTokenImpl  the address of the aToken contract implementation\n   * @param stableDebtTokenImpl the address of the stable debt token contract\n   * @param variableDebtTokenImpl the address of the variable debt token contract\n   * @param underlyingAssetDecimals the decimals of the reserve underlying asset\n   * @param interestRateStrategyAddress the address of the interest rate strategy contract for this reserve\n   **/\n  function initReserve(\n    address asset,\n    address aTokenImpl,\n    address stableDebtTokenImpl,\n    address variableDebtTokenImpl,\n    uint8 underlyingAssetDecimals,\n    address interestRateStrategyAddress\n  ) public onlyAaveAdmin {\n    address aTokenProxyAddress = _initTokenWithProxy(aTokenImpl, underlyingAssetDecimals);\n\n    address stableDebtTokenProxyAddress = _initTokenWithProxy(\n      stableDebtTokenImpl,\n      underlyingAssetDecimals\n    );\n\n    address variableDebtTokenProxyAddress = _initTokenWithProxy(\n      variableDebtTokenImpl,\n      underlyingAssetDecimals\n    );\n\n    pool.initReserve(\n      asset,\n      aTokenProxyAddress,\n      stableDebtTokenProxyAddress,\n      variableDebtTokenProxyAddress,\n      interestRateStrategyAddress\n    );\n\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setDecimals(underlyingAssetDecimals);\n\n    currentConfig.setActive(true);\n    currentConfig.setFrozen(false);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveInitialized(\n      asset,\n      aTokenProxyAddress,\n      stableDebtTokenProxyAddress,\n      variableDebtTokenProxyAddress,\n      interestRateStrategyAddress\n    );\n  }\n\n  /**\n   * @dev updates the aToken implementation for the asset\n   * @param asset the address of the reserve to be updated\n   * @param implementation the address of the new aToken implementation\n   **/\n  function updateAToken(address asset, address implementation) external onlyAaveAdmin {\n    (address aTokenAddress, , ) = pool.getReserveTokensAddresses(asset);\n\n    _upgradeTokenImplementation(asset, aTokenAddress, implementation);\n\n    emit ATokenUpgraded(asset, aTokenAddress, implementation);\n  }\n\n  /**\n   * @dev updates the stable debt token implementation for the asset\n   * @param asset the address of the reserve to be updated\n   * @param implementation the address of the new aToken implementation\n   **/\n  function updateStableDebtToken(address asset, address implementation) external onlyAaveAdmin {\n    (, address stableDebtToken, ) = pool.getReserveTokensAddresses(asset);\n\n    _upgradeTokenImplementation(asset, stableDebtToken, implementation);\n\n    emit StableDebtTokenUpgraded(asset, stableDebtToken, implementation);\n  }\n\n  /**\n   * @dev updates the variable debt token implementation for the asset\n   * @param asset the address of the reserve to be updated\n   * @param implementation the address of the new aToken implementation\n   **/\n  function updateVariableDebtToken(address asset, address implementation) external onlyAaveAdmin {\n    (, , address variableDebtToken) = pool.getReserveTokensAddresses(asset);\n\n    _upgradeTokenImplementation(asset, variableDebtToken, implementation);\n\n    emit VariableDebtTokenUpgraded(asset, variableDebtToken, implementation);\n  }\n\n  /**\n   * @dev enables borrowing on a reserve\n   * @param asset the address of the reserve\n   * @param stableBorrowRateEnabled true if stable borrow rate needs to be enabled by default on this reserve\n   **/\n  function enableBorrowingOnReserve(address asset, bool stableBorrowRateEnabled)\n    external\n    onlyAaveAdmin\n  {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setBorrowingEnabled(true);\n    currentConfig.setStableRateBorrowingEnabled(stableBorrowRateEnabled);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit BorrowingEnabledOnReserve(asset, stableBorrowRateEnabled);\n  }\n\n  /**\n   * @dev disables borrowing on a reserve\n   * @param asset the address of the reserve\n   **/\n  function disableBorrowingOnReserve(address asset) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setBorrowingEnabled(false);\n\n    pool.setConfiguration(asset, currentConfig.data);\n    emit BorrowingDisabledOnReserve(asset);\n  }\n\n  /**\n   * @dev enables a reserve to be used as collateral\n   * @param asset the address of the reserve\n   * @param ltv the loan to value of the asset when used as collateral\n   * @param liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus the bonus liquidators receive to liquidate this asset\n   **/\n  function enableReserveAsCollateral(\n    address asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  ) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setLtv(ltv);\n    currentConfig.setLiquidationThreshold(liquidationThreshold);\n    currentConfig.setLiquidationBonus(liquidationBonus);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveEnabledAsCollateral(asset, ltv, liquidationThreshold, liquidationBonus);\n  }\n\n  /**\n   * @dev disables a reserve as collateral\n   * @param asset the address of the reserve\n   **/\n  function disableReserveAsCollateral(address asset) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setLtv(0);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveDisabledAsCollateral(asset);\n  }\n\n  /**\n   * @dev enable stable rate borrowing on a reserve\n   * @param asset the address of the reserve\n   **/\n  function enableReserveStableRate(address asset) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setStableRateBorrowingEnabled(true);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit StableRateEnabledOnReserve(asset);\n  }\n\n  /**\n   * @dev disable stable rate borrowing on a reserve\n   * @param asset the address of the reserve\n   **/\n  function disableReserveStableRate(address asset) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setStableRateBorrowingEnabled(false);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit StableRateDisabledOnReserve(asset);\n  }\n\n  /**\n   * @dev activates a reserve\n   * @param asset the address of the reserve\n   **/\n  function activateReserve(address asset) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setActive(true);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveActivated(asset);\n  }\n\n  /**\n   * @dev deactivates a reserve\n   * @param asset the address of the reserve\n   **/\n  function deactivateReserve(address asset) external onlyAaveAdmin {\n    (\n      uint256 availableLiquidity,\n      uint256 totalStableDebt,\n      uint256 totalVariableDebt,\n      ,\n      ,\n      ,\n      ,\n      ,\n      ,\n\n    ) = pool.getReserveData(asset);\n    require(\n      availableLiquidity == 0 && totalStableDebt == 0 && totalVariableDebt == 0,\n      Errors.RESERVE_LIQUIDITY_NOT_0\n    );\n\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setActive(false);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveDeactivated(asset);\n  }\n\n  /**\n   * @dev freezes a reserve. A freezed reserve doesn't accept any new deposit, borrow or rate swap, but can accept repayments, liquidations, rate rebalances and redeems\n   * @param asset the address of the reserve\n   **/\n  function freezeReserve(address asset) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setFrozen(true);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveFreezed(asset);\n  }\n\n  /**\n   * @dev unfreezes a reserve\n   * @param asset the address of the reserve\n   **/\n  function unfreezeReserve(address asset) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setFrozen(false);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveUnfreezed(asset);\n  }\n\n  /**\n   * @dev updates the ltv of a reserve\n   * @param asset the address of the reserve\n   * @param ltv the new value for the loan to value\n   **/\n  function setLtv(address asset, uint256 ltv) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setLtv(ltv);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveBaseLtvChanged(asset, ltv);\n  }\n\n    /**\n   * @dev updates the reserve factor of a reserve\n   * @param asset the address of the reserve\n   * @param reserveFactor the new reserve factor of the reserve\n   **/\n  function setReserveFactor(address asset, uint256 reserveFactor) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setReserveFactor(reserveFactor);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveFactorChanged(asset, reserveFactor);\n  }\n\n\n  /**\n   * @dev updates the liquidation threshold of a reserve.\n   * @param asset the address of the reserve\n   * @param threshold the new value for the liquidation threshold\n   **/\n  function setLiquidationThreshold(address asset, uint256 threshold) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setLiquidationThreshold(threshold);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveLiquidationThresholdChanged(asset, threshold);\n  }\n\n  /**\n   * @dev updates the liquidation bonus of a reserve\n   * @param asset the address of the reserve\n   * @param bonus the new value for the liquidation bonus\n   **/\n  function setLiquidationBonus(address asset, uint256 bonus) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setLiquidationBonus(bonus);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveLiquidationBonusChanged(asset, bonus);\n  }\n\n  /**\n   * @dev updates the reserve decimals\n   * @param asset the address of the reserve\n   * @param decimals the new number of decimals\n   **/\n  function setReserveDecimals(address asset, uint256 decimals) external onlyAaveAdmin {\n    ReserveConfiguration.Map memory currentConfig = pool.getConfiguration(asset);\n\n    currentConfig.setDecimals(decimals);\n\n    pool.setConfiguration(asset, currentConfig.data);\n\n    emit ReserveDecimalsChanged(asset, decimals);\n  }\n\n  /**\n   * @dev sets the interest rate strategy of a reserve\n   * @param asset the address of the reserve\n   * @param rateStrategyAddress the new address of the interest strategy contract\n   **/\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external\n    onlyAaveAdmin\n  {\n    pool.setReserveInterestRateStrategyAddress(asset, rateStrategyAddress);\n    emit ReserveInterestRateStrategyChanged(asset, rateStrategyAddress);\n  }\n\n  /**\n   * @dev initializes a token with a proxy and a specific implementation\n   * @param implementation the address of the implementation\n   * @param decimals the decimals of the token\n   **/\n  function _initTokenWithProxy(address implementation, uint8 decimals) internal returns (address) {\n    InitializableAdminUpgradeabilityProxy proxy = new InitializableAdminUpgradeabilityProxy();\n\n    bytes memory params = abi.encodeWithSignature(\n      'initialize(uint8,string,string)',\n      decimals,\n      IERC20Detailed(implementation).name(),\n      IERC20Detailed(implementation).symbol()\n    );\n\n    proxy.initialize(implementation, address(this), params);\n\n    return address(proxy);\n  }\n\n  function _upgradeTokenImplementation(\n    address asset,\n    address proxyAddress,\n    address implementation\n  ) internal {\n    InitializableAdminUpgradeabilityProxy proxy = InitializableAdminUpgradeabilityProxy(\n      payable(proxyAddress)\n    );\n\n    (uint256 decimals, , , , , , , , , , ) = pool.getReserveConfigurationData(asset);\n\n    bytes memory params = abi.encodeWithSignature(\n      'initialize(uint8,string,string)',\n      uint8(decimals),\n      IERC20Detailed(implementation).name(),\n      IERC20Detailed(implementation).symbol()\n    );\n\n    proxy.upgradeToAndCall(implementation, params);\n  }\n\n  /**\n   * @dev pauses or unpauses LendingPool actions\n   * @param val the boolean value to set the current pause state of LendingPool\n   **/\n  function setPoolPause(bool val) external onlyAaveAdmin {\n    pool.setPause(val);\n  }\n}"
    }
  ]
}