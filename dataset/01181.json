{
  "Title": "Insufficient validation of new Fertilizer IDs allow for a denial-of-service (DoS) attack on `SeasonFacet::gm` when above peg, once the last element in the FIFO is paid",
  "Content": "**Description:** A Fertilizer NFT can be interpreted as a bond without an expiration date which is to be repaid in Beans and includes interest (Humidity). This bond is placed in a FIFO list and intended to recapitalize the $77 million in liquidity stolen during the [April 2022 exploit](https://docs.bean.money/almanac/farm/barn). One Fertilizer can be purchased for 1 USD worth of WETH: prior to BIP-38, this purchase was made using USDC.\n\nEach fertilizer is identified by an Id that depends on `s.bpf`, indicating the cumulative amount of Beans paid per Fertilizer. This value increases each time [`Sun::rewardToFertilizer`](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L153) is called, invoked by `SeasonFacet::gm` if the Bean price is above peg. Therefore, Fertilizer IDs depend on `s.bpf` [at the moment of minting](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/libraries/LibFertilizer.sol#L45-L51), in addition to the [amount of Beans to be paid](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/libraries/LibFertilizer.sol#L64-L66).\n\nThe FIFO list has following components:\n* `s.fFirst`: Fertilizer Id corresponding to the next Fertilizer to be paid.\n* `s.fLast`: The highest active Fertilizer Id which is the last Fertilizer to be paid.\n* `s.nextFid`: Mapping from Fertilizer Id to Fertilizer id, indicating the next element of a [linked list](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/beanstalk/AppStorage.sol#L477-L477). If an Id points to 0, then there is no next element.\n\nMethods related to this FIFO list include:\n`LibFertilizer::push`: Add an element to the FIFO list.\n`LibFertilizer::setNext`: Given a fertilizer id, add a pointer to next element in the list\n`LibFertilizer::getNext`: Get next element in the list.\n\nThe intended behaviour of this list is to add a new element to its end whenever a new fertilizer is minted with a new Id. Intermediate addition to the list was formerly allowed only by the Beanstalk DAO, but this functionality has since been deprecated in the current upgrade with the removal of `FertilizerFacet::addFertilizerOwner`.\n\n*Consequences of replacing BEAN:3CRV MetaPool with the BEAN:ETH Well:*\nBefore this upgrade, addition of 0 Fertilizer through `LibFertilizer::addFertilizer` was impossible due to the dependency on Curve in `LibFertilizer::addUnderlying`:\n\n```solidity\n// Previous code\n\n    function addUnderlying(uint256 amount, uint256 minAmountOut) internal {\n        //...\n        C.bean().mint(\n            address(this),\n            newDepositedBeans.add(newDepositedLPBeans)\n        );\n\n        // Add Liquidity\n        uint256 newLP = C.curveZap().add_liquidity(\n            C.CURVE_BEAN_METAPOOL, // where to add liquidity\n            [\n                newDepositedLPBeans, // BEANS to add\n                0,\n                amount, // USDC to add\n                0\n            ], // how much of each token to add\n            minAmountOut // min lp ampount to receive\n        ); // @audit-ok Does not admit depositing 0 --> https://etherscan.io/address/0x5F890841f657d90E081bAbdB532A05996Af79Fe6#code#L487\n\n        // Increment underlying balances of Unripe Tokens\n        LibUnripe.incrementUnderlying(C.UNRIPE_BEAN, newDepositedBeans);\n        LibUnripe.incrementUnderlying(C.UNRIPE_LP, newLP);\n\n        s.recapitalized = s.recapitalized.add(amount);\n    }\n```\n\nHowever, with the change of dependency involved in the Wells integration, this restriction no longer holds:\n```solidity\n    function addUnderlying(uint256 usdAmount, uint256 minAmountOut) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // Calculate how many new Deposited Beans will be minted\n        uint256 percentToFill = usdAmount.mul(C.precision()).div(\n            remainingRecapitalization()\n        );\n        uint256 newDepositedBeans;\n        if (C.unripeBean().totalSupply() > s.u[C.UNRIPE_BEAN].balanceOfUnderlying) {\n            newDepositedBeans = (C.unripeBean().totalSupply()).sub(\n                s.u[C.UNRIPE_BEAN].balanceOfUnderlying\n            );\n            newDepositedBeans = newDepositedBeans.mul(percentToFill).div(\n                C.precision()\n            );\n        }\n\n        // Calculate how many Beans to add as LP\n        uint256 newDepositedLPBeans = usdAmount.mul(C.exploitAddLPRatio()).div(\n            DECIMALS\n        );\n\n        // Mint the Deposited Beans to Beanstalk.\n        C.bean().mint(\n            address(this),\n            newDepositedBeans\n        );\n\n        // Mint the LP Beans to the Well to sync.\n        C.bean().mint(\n            address(C.BEAN_ETH_WELL),\n            newDepositedLPBeans\n        );\n\n        // @audit If nothing was previously deposited this function returns 0, IT DOES NOT REVERT\n        uint256 newLP = IWell(C.BEAN_ETH_WELL).sync(\n            address(this),\n            minAmountOut\n        );\n\n        // Increment underlying balances of Unripe Tokens\n        LibUnripe.incrementUnderlying(C.UNRIPE_BEAN, newDepositedBeans);\n        LibUnripe.incrementUnderlying(C.UNRIPE_LP, newLP);\n\n        s.recapitalized = s.recapitalized.add(usdAmount);\n    }\n```\n\nGiven that the new integration does not revert when attempting to add 0 Fertilizer, it is now possible to add a self-referential node to the end FIFO list, but only if this is the first Fertilizer NFT to be minted for the current season by twice calling `FertilizerFacet.mintFertilizer(0, 0, 0, mode)`. The [validation](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/libraries/LibFertilizer.sol#L57-L58) performed to prevent duplicate ids is erroneously bypassed given the Fertilizer amount for the given Id remains zero.\n\n```solidity\n    function push(uint128 id) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (s.fFirst == 0) {\n            // Queue is empty\n            s.season.fertilizing = true;\n            s.fLast = id;\n            s.fFirst = id;\n        } else if (id <= s.fFirst) {\n            // Add to front of queue\n            setNext(id, s.fFirst);\n            s.fFirst = id;\n        } else if (id >= s.fLast) { // @audit this block is entered twice\n            // Add to back of queue\n            setNext(s.fLast, id); // @audit the second time, a reference is added to the same id\n            s.fLast = id;\n        } else {\n            // Add to middle of queue\n            uint128 prev = s.fFirst;\n            uint128 next = getNext(prev);\n            // Search for proper place in line\n            while (id > next) {\n                prev = next;\n                next = getNext(next);\n            }\n            setNext(prev, id);\n            setNext(id, next);\n        }\n    }\n```\nDespite first perhaps seeming harmless, this element can never be remove unless otherwise overridden:\n\n```solidity\n    function pop() internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint128 first = s.fFirst;\n        s.activeFertilizer = s.activeFertilizer.sub(getAmount(first)); // @audit getAmount(first) would return 0\n        uint128 next = getNext(first);\n        if (next == 0) { // @audit next != 0, therefore this conditional block is skipped\n            // If all Unfertilized Beans have been fertilized, delete line.\n            require(s.activeFertilizer == 0, \"Still active fertilizer\");\n            s.fFirst = 0;\n            s.fLast = 0;\n            s.season.fertilizing = false;\n            return false;\n        }\n        s.fFirst = getNext(first); // @audit this gets s.first again\n        return true; // @audit always returns true for a self-referential node\n    }\n```\n\n`LibFertilizer::pop` is used in [`Sun::rewardToFertilizer`](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L132-L150) which is called through [`Sun::rewardBeans`](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L97) when fertilizing. This function is called through [`Sun::stepSun`](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L73) if the current Bean price is above peg. By preventing the last element from being popped from the list, assuming this element is reached, an infinite loop occurs given that the `while` loop continues to execute, resulting in denial-of-service on [`SeasonFacet::gm`](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L59) when above peg.\n\nThe most remarkable detail of this issue is that this state can be forced when above peg and having already been fully recapitalized. Given that it is not possible to mint additional Fertilizer with the associated Beans, this means that a DoS attack can be performed on `SeasonFacet::gm` once recapitalization is reached if the BEAN price is above peg.\n\n**Impact:** It is possible to perform a denial-of-service (DoS) attack on `SeasonFacet::gm` if the Bean price is above the peg, either once fully recapitalized or when reaching the last element of the Fertilizer FIFO list.\n\n**Proof of Concept:** [This coded PoC](https://gist.github.com/carlitox477/1b0dde178288982f4e25d40b9e43e626) can be run by:\n1. Creating file `Beantalk/protocol/test/POCs/mint0Fertilizer.test.js`\n2. Navigating to `Beantalk/protocol`\n3. Running `yarn test --grep \"DOS last fertilizer payment through minting 0 fertilizers\"`\n\n**Recommended Mitigation:** Despite being a complex issue to explain, the solution is as simple as replacing `>` with `>=` in `LibFertilizer::addFertilizer` as below:\n\n```diff\n    function addFertilizer(\n        uint128 season,\n        uint256 fertilizerAmount,\n        uint256 minLP\n    ) internal returns (uint128 id) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint128 fertilizerAmount128 = fertilizerAmount.toUint128();\n\n        // Calculate Beans Per Fertilizer and add to total owed\n        uint128 bpf = getBpf(season);\n        s.unfertilizedIndex = s.unfertilizedIndex.add(\n            fertilizerAmount.mul(bpf)\n        );\n        // Get id\n        id = s.bpf.add(bpf);\n        // Update Total and Season supply\n        s.fertilizer[id] = s.fertilizer[id].add(fertilizerAmount128);\n        s.activeFertilizer = s.activeFertilizer.add(fertilizerAmount);\n        // Add underlying to Unripe Beans and Unripe LP\n        addUnderlying(fertilizerAmount.mul(DECIMALS), minLP);\n        // If not first time adding Fertilizer with this id, return\n-       if (s.fertilizer[id] > fertilizerAmount128) return id;\n+       if (s.fertilizer[id] >= fertilizerAmount128) return id; // prevent infinite loop in `Sun::rewardToFertilizer` when attempting to add 0 Fertilizer, which could DoS `SeasonFacet::gm` when recapitalization is fulfilled\n        // If first time, log end Beans Per Fertilizer and add to Season queue.\n        push(id);\n        emit SetFertilizer(id, bpf);\n    }\n```\n\n**Beanstalk Farms:** Added a > 0 check to the `mintFertilizer` function in commit hash [4489cb8](https://github.com/BeanstalkFarms/Beanstalk/pull/655/commits/4489cb869b1a1f8a2535a04364460c79ffb75b11).\n\n**Cyfrin:** Acknowledged. The Beanstalk Farms team has opted to add validation in `FertilizerFacet::mintFertilizer`. This alternative saves more gas compared to the one suggested; however, this issue should be considered in the future if `LibFertilizer::addFertilizer` is used anywhere else. This is the case in `FertilizerFacet::addFertilizerOwner` but assumedly will not be an issue as the owner would not send this type of transaction.\n\n\n\\clearpage",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"contracts/libraries/Decimal.sol\";\nimport \"contracts/libraries/LibSafeMath32.sol\";\nimport \"contracts/libraries/LibFertilizer.sol\";\nimport \"contracts/libraries/LibSafeMath128.sol\";\nimport \"contracts/libraries/LibPRBMath.sol\";\nimport \"contracts/C.sol\";\nimport \"./Oracle.sol\";\n\n/**\n * @title Sun\n * @author Publius\n * @notice Sun controls the minting of new Beans to Fertilizer, the Field, and the Silo.\n */\ncontract Sun is Oracle {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using LibPRBMath for uint256;\n    using LibSafeMath32 for uint32;\n    using LibSafeMath128 for uint128;\n    using Decimal for Decimal.D256;\n\n    /// @dev When Fertilizer is Active, it receives 1/3 of new Bean mints.\n    uint256 private constant FERTILIZER_DENOMINATOR = 3;\n\n    /// @dev After Fertilizer, Harvestable Pods receive 1/2 of new Bean mints. \n    uint256 private constant HARVEST_DENOMINATOR = 2;\n\n    /// @dev When the Pod Rate is high, issue less Soil.\n    uint256 private constant SOIL_COEFFICIENT_HIGH = 0.5e18;\n    \n    /// @dev When the Pod Rate is low, issue more Soil.\n    uint256 private constant SOIL_COEFFICIENT_LOW = 1.5e18;\n\n    /**\n     * @notice Emitted during Sunrise when Beans are distributed to the Field, the Silo, and Fertilizer.\n     * @param season The Season in which Beans were distributed.\n     * @param toField The number of Beans distributed to the Field.\n     * @param toSilo The number of Beans distributed to the Silo.\n     * @param toFertilizer The number of Beans distributed to Fertilizer.\n     */\n    event Reward(\n        uint32 indexed season,\n        uint256 toField,\n        uint256 toSilo,\n        uint256 toFertilizer\n    );\n\n    /**\n     * @notice Emitted during Sunrise when Beanstalk adjusts the amount of available Soil.\n     * @param season The Season in which Soil was adjusted.\n     * @param soil The new amount of Soil available.\n     */\n    event Soil(\n        uint32 indexed season,\n        uint256 soil\n    );\n\n    //////////////////// SUN INTERNAL ////////////////////\n    \n    /**\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @param caseId Pre-calculated Weather case from {Weather.stepWeather}.\n     */\n    function stepSun(int256 deltaB, uint256 caseId) internal {\n        // Above peg\n        if (deltaB > 0) {\n            uint256 newHarvestable = rewardBeans(uint256(deltaB));\n            setSoilAbovePeg(newHarvestable, caseId);\n            s.season.abovePeg = true;\n        } \n\n        // Below peg\n        else {\n            setSoil(uint256(-deltaB));\n            s.season.abovePeg = false;\n        }\n    }\n\n    //////////////////// REWARD BEANS ////////////////////\n\n    /**\n     * @dev Mints and distributes Beans to Fertilizer, the Field, and the Silo.\n     */\n    function rewardBeans(uint256 newSupply) internal returns (uint256 newHarvestable) {\n        uint256 newFertilized;\n        \n        C.bean().mint(address(this), newSupply);\n\n        // Distribute first to Fertilizer if some Fertilizer are active\n        if (s.season.fertilizing) {\n            newFertilized = rewardToFertilizer(newSupply);\n            newSupply = newSupply.sub(newFertilized);\n        }\n\n        // Distribute next to the Field if some Pods are still outstanding\n        if (s.f.harvestable < s.f.pods) {\n            newHarvestable = rewardToHarvestable(newSupply);\n            newSupply = newSupply.sub(newHarvestable);\n        }\n\n        // Distribute remainder to the Silo\n        rewardToSilo(newSupply);\n\n        emit Reward(s.season.current, newHarvestable, newSupply, newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to Fertilizer.\n     */\n    function rewardToFertilizer(uint256 amount)\n        internal\n        returns (uint256 newFertilized)\n    {\n        // 1/3 of new Beans being minted\n        uint256 maxNewFertilized = amount.div(FERTILIZER_DENOMINATOR);\n\n        // Get the new Beans per Fertilizer and the total new Beans per Fertilizer\n        uint256 newBpf = maxNewFertilized.div(s.activeFertilizer);\n        uint256 oldTotalBpf = s.bpf;\n        uint256 newTotalBpf = oldTotalBpf.add(newBpf);\n\n        // Get the end Beans per Fertilizer of the first Fertilizer to run out.\n        uint256 firstEndBpf = s.fFirst;\n\n        // If the next fertilizer is going to run out, then step BPF according\n        while(newTotalBpf >= firstEndBpf) {\n            // Calculate BPF and new Fertilized when the next Fertilizer ID ends\n            newBpf = firstEndBpf.sub(oldTotalBpf);\n            newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n\n            // If there is no more fertilizer, end\n            if (!LibFertilizer.pop()) {\n                s.bpf = uint128(firstEndBpf); // SafeCast unnecessary here.\n                s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n                require(s.fertilizedIndex == s.unfertilizedIndex, \"Paid != owed\");\n                return newFertilized;\n            }\n\n            // Calculate new Beans per Fertilizer values\n            newBpf = maxNewFertilized.sub(newFertilized).div(s.activeFertilizer);\n            oldTotalBpf = firstEndBpf;\n            newTotalBpf = oldTotalBpf.add(newBpf);\n            firstEndBpf = s.fFirst;\n        }\n\n        // Distribute the rest of the Fertilized Beans\n        s.bpf = uint128(newTotalBpf); // SafeCast unnecessary here.\n        newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n        s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to the Field. The next `amount` Pods in the Pod Line\n     * become Harvestable.\n     */\n    function rewardToHarvestable(uint256 amount)\n        internal    \n        returns (uint256 newHarvestable)\n    {\n        uint256 notHarvestable = s.f.pods - s.f.harvestable; // Note: SafeMath is redundant here.\n        newHarvestable = amount.div(HARVEST_DENOMINATOR);\n        newHarvestable = newHarvestable > notHarvestable\n            ? notHarvestable\n            : newHarvestable;\n        s.f.harvestable = s.f.harvestable.add(newHarvestable);\n    }\n\n    /**\n     * @dev Distribute Beans to the Silo. Stalk & Earned Beans are created here;\n     * Farmers can claim them through {SiloFacet.plant}.\n     */\n    function rewardToSilo(uint256 amount) internal {\n        // NOTE that the Beans have already been minted (see {rewardBeans}).\n        //\n        // `s.earnedBeans` is an accounting mechanism that tracks the total number\n        // of Earned Beans that are claimable by Stalkholders. When claimed via `plant()`,\n        // it is decremented. See {Silo.sol:_plant} for more details.\n        // SafeCast not necessary as `seasonStalk.toUint128();` will fail if amount > type(uint128).max.\n        s.earnedBeans = s.earnedBeans.add(uint128(amount));\n\n        // Mint Stalk (as Earned Stalk). Farmers can claim their Earned Stalk via {SiloFacet.sol:plant}.\n        //\n        // Stalk is created here, rather than in {rewardBeans}, because only\n        // Beans that are allocated to the Silo will receive Stalk.\n        // Constant is used here rather than s.ss[BEAN].stalkIssuedPerBdv\n        // for gas savings.\n        uint256 seasonStalk = amount.mul(C.STALK_PER_BEAN);\n        s.s.stalk = s.s.stalk.add(seasonStalk);\n        // `s.newEarnedStalk` is an accounting mechanism that tracks the  number\n        // of Earned stalk that is allocated during the season. \n        // This is used in _balanceOfEarnedBeans() to linearly distrubute \n        // beans over the course of the season.\n        s.newEarnedStalk = seasonStalk.toUint128();\n        s.vestingPeriodRoots = 0;\n\n        // SafeCast not necessary as `seasonStalk.toUint128();` will fail if amount > type(uint128).max.\n        s.siloBalances[C.BEAN].deposited = s\n            .siloBalances[C.BEAN]\n            .deposited\n            .add(uint128(amount));\n\n        s.siloBalances[C.BEAN].depositedBdv = s\n            .siloBalances[C.BEAN]\n            .depositedBdv\n            .add(uint128(amount));\n    }\n\n    //////////////////// SET SOIL ////////////////////\n\n    /**\n     * @param newHarvestable The number of Beans that were minted to the Field.\n     * @param caseId The current Weather Case.\n     * @dev When above peg, Beanstalk wants to gauge demand for Soil. Here it\n     * issues the amount of Soil that would result in the same number of Pods\n     * as became Harvestable during the last Season.\n     * \n     * When the Pod Rate is high, Beanstalk issues less Soil.\n     * When the Pod Rate is low, Beanstalk issues more Soil.\n     */\n    function setSoilAbovePeg(uint256 newHarvestable, uint256 caseId) internal {\n        uint256 newSoil = newHarvestable.mul(100).div(100 + s.w.t);\n        if (caseId >= 24) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_HIGH).div(C.PRECISION); // high podrate\n        } else if (caseId < 8) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_LOW).div(C.PRECISION); // low podrate\n        }\n        setSoil(newSoil);\n    }\n\n    \n    function setSoil(uint256 amount) internal {\n        s.f.soil = amount.toUint128();\n        emit Soil(s.season.current, amount.toUint128());\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/AppStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/**\n * @title Account\n * @author Publius\n * @notice Stores Farmer-level Beanstalk state.\n * @dev {Account.State} is the primary struct that is referenced from {Storage.State}. \n * All other structs in {Account} are referenced in {Account.State}. Each unique\n * Ethereum address is a Farmer.\n */\ncontract Account {\n    /**\n     * @notice Stores a Farmer's Plots and Pod allowances.\n     * @param plots A Farmer's Plots. Maps from Plot index to Pod amount.\n     * @param podAllowances An allowance mapping for Pods similar to that of the ERC-20 standard. Maps from spender address to allowance amount.\n     */\n    struct Field {\n        mapping(uint256 => uint256) plots;\n        mapping(address => uint256) podAllowances;\n    }\n\n    /**\n     * @notice Stores a Farmer's Deposits and Seeds per Deposit, and formerly stored Withdrawals.\n     * @param withdrawals DEPRECATED: Silo V1 Withdrawals are no longer referenced.\n     * @param deposits Unripe Bean/LP Deposits (previously Bean/LP Deposits).\n     * @param depositSeeds BDV of Unripe LP Deposits / 4 (previously # of Seeds in corresponding LP Deposit).\n     */\n    struct AssetSilo {\n        mapping(uint32 => uint256) withdrawals;\n        mapping(uint32 => uint256) deposits;\n        mapping(uint32 => uint256) depositSeeds;\n    }\n\n    /**\n     * @notice Represents a Deposit of a given Token in the Silo at a given Season.\n     * @param amount The amount of Tokens in the Deposit.\n     * @param bdv The Bean-denominated value of the total amount of Tokens in the Deposit.\n     * @dev `amount` and `bdv` are packed as uint128 to save gas.\n     */\n    struct Deposit {\n        uint128 amount; // ───┐ 16\n        uint128 bdv; // ──────┘ 16 (32/32)\n    }\n\n    /**\n     * @notice Stores a Farmer's Stalk and Seeds balances.\n     * @param stalk Balance of the Farmer's Stalk.\n     * @param seeds DEPRECATED – Balance of the Farmer's Seeds. Seeds are no longer referenced as of Silo V3.\n     */\n    struct Silo {\n        uint256 stalk;\n        uint256 seeds;\n    }\n\n    /**\n     * @notice This struct stores the mow status for each Silo-able token, for each farmer. \n     * This gets updated each time a farmer mows, or adds/removes deposits.\n     * @param lastStem The last cumulative grown stalk per bdv index at which the farmer mowed.\n     * @param bdv The bdv of all of a farmer's deposits of this token type.\n     * \n     */\n    struct MowStatus {\n        int96 lastStem; // ───┐ 12\n        uint128 bdv; // ──────┘ 16 (28/32)\n    }\n\n    /**\n     * @notice Stores a Farmer's Season of Plenty (SOP) balances.\n     * @param roots The number of Roots a Farmer had when it started Raining.\n     * @param plentyPerRoot The global Plenty Per Root index at the last time a Farmer updated their Silo.\n     * @param plenty The balance of a Farmer's plenty. Plenty can be claimed directly for 3CRV.\n     */\n    struct SeasonOfPlenty {\n        uint256 roots;\n        uint256 plentyPerRoot;\n        uint256 plenty;\n    }\n    \n    /**\n     * @notice Defines the state object for a Farmer.\n     * @param field A Farmer's Field storage.\n     * @param bean A Farmer's Unripe Bean Deposits only as a result of Replant (previously held the V1 Silo Deposits/Withdrawals for Beans).\n     * @param lp A Farmer's Unripe LP Deposits as a result of Replant of BEAN:ETH Uniswap v2 LP Tokens (previously held the V1 Silo Deposits/Withdrawals for BEAN:ETH Uniswap v2 LP Tokens).\n     * @param s A Farmer's Silo storage.\n     * @param deprecated_votedUntil DEPRECATED – Replant removed on-chain governance including the ability to vote on BIPs.\n     * @param lastUpdate The Season in which the Farmer last updated their Silo.\n     * @param lastSop The last Season that a SOP occured at the time the Farmer last updated their Silo.\n     * @param lastRain The last Season that it started Raining at the time the Farmer last updated their Silo.\n     * @param deprecated_lastSIs DEPRECATED – In Silo V1.2, the Silo reward mechanism was updated to no longer need to store the number of the Supply Increases at the time the Farmer last updated their Silo.\n     * @param deprecated_proposedUntil DEPRECATED – Replant removed on-chain governance including the ability to propose BIPs.\n     * @param deprecated_sop DEPRECATED – Replant reset the Season of Plenty mechanism\n     * @param roots A Farmer's Root balance.\n     * @param deprecated_wrappedBeans DEPRECATED – Replant generalized Internal Balances. Wrapped Beans are now stored at the AppStorage level.\n     * @param deposits A Farmer's Silo Deposits stored as a map from Token address to Season of Deposit to Deposit.\n     * @param withdrawals A Farmer's Withdrawals from the Silo stored as a map from Token address to Season the Withdrawal becomes Claimable to Withdrawn amount of Tokens.\n     * @param sop A Farmer's Season of Plenty storage.\n     * @param depositAllowances A mapping of `spender => Silo token address => amount`.\n     * @param tokenAllowances Internal balance token allowances.\n     * @param depositPermitNonces A Farmer's current deposit permit nonce\n     * @param tokenPermitNonces A Farmer's current token permit nonce\n     */\n    struct State {\n        Field field; // A Farmer's Field storage.\n\n        /*\n         * @dev (Silo V1) A Farmer's Unripe Bean Deposits only as a result of Replant\n         *\n         * Previously held the V1 Silo Deposits/Withdrawals for Beans.\n\n         * NOTE: While the Silo V1 format is now deprecated, this storage slot is used for gas\n         * efficiency to store Unripe BEAN deposits. See {LibUnripeSilo} for more.\n         */\n        AssetSilo bean; \n\n        /*\n         * @dev (Silo V1) Unripe LP Deposits as a result of Replant.\n         * \n         * Previously held the V1 Silo Deposits/Withdrawals for BEAN:ETH Uniswap v2 LP Tokens.\n         * \n         * BEAN:3CRV and BEAN:LUSD tokens prior to Replant were stored in the Silo V2\n         * format in the `s.a[account].legacyDeposits` mapping.\n         *\n         * NOTE: While the Silo V1 format is now deprecated, unmigrated Silo V1 deposits are still\n         * stored in this storage slot. See {LibUnripeSilo} for more.\n         * \n         */\n        AssetSilo lp; \n\n        /*\n         * @dev Holds Silo specific state for each account.\n         */\n        Silo s;\n        \n        uint32 votedUntil; // DEPRECATED – Replant removed on-chain governance including the ability to vote on BIPs.\n        uint32 lastUpdate; // The Season in which the Farmer last updated their Silo.\n        uint32 lastSop; // The last Season that a SOP occured at the time the Farmer last updated their Silo.\n        uint32 lastRain; // The last Season that it started Raining at the time the Farmer last updated their Silo.\n        uint128 deltaRoots; // the number of roots to add, in the case where a farmer has mowed in the morning\n        SeasonOfPlenty deprecated; // DEPRECATED – Replant reset the Season of Plenty mechanism\n        uint256 roots; // A Farmer's Root balance.\n        uint256 wrappedBeans; // DEPRECATED – Replant generalized Internal Balances. Wrapped Beans are now stored at the AppStorage level.\n        mapping(address => mapping(uint32 => Deposit)) legacyDeposits; // Legacy Silo V2 Deposits stored as a map from Token address to Season of Deposit to Deposit. NOTE: While the Silo V2 format is now deprecated, unmigrated Silo V2 deposits are still stored in this mapping.\n        mapping(address => mapping(uint32 => uint256)) withdrawals; // DEPRECATED - Zero withdraw eliminates a need for withdraw mapping\n        SeasonOfPlenty sop; // A Farmer's Season Of Plenty storage.\n        mapping(address => mapping(address => uint256)) depositAllowances; // Spender => Silo Token\n        mapping(address => mapping(IERC20 => uint256)) tokenAllowances; // Token allowances\n        uint256 depositPermitNonces; // A Farmer's current deposit permit nonce\n        uint256 tokenPermitNonces; // A Farmer's current token permit nonce\n        mapping(uint256 => Deposit) deposits; // SiloV3 Deposits stored as a map from uint256 to Deposit. This is an concat of the token address and the CGSPBDV for a ERC20 deposit, and a hash for an ERC721/1155 deposit.\n        mapping(address => MowStatus) mowStatuses; // Store a MowStatus for each Whitelisted Silo token\n        mapping(address => bool) isApprovedForAll; // ERC1155 isApprovedForAll mapping \n    }\n}\n\n/**\n * @title Storage\n * @author Publius\n * @notice Stores system-level Beanstalk state.\n */\ncontract Storage {\n    /**\n     * @notice DEPRECATED: System-level contract addresses.\n     * @dev After Replant, Beanstalk stores Token addresses as constants to save gas.\n     */\n    struct Contracts {\n        address bean;\n        address pair;\n        address pegPair;\n        address weth;\n    }\n\n    /**\n     * @notice System-level Field state variables.\n     * @param soil The number of Soil currently available. Adjusted during {Sun.stepSun}.\n     * @param beanSown The number of Bean sown within the current Season. Reset during {Weather.stepWeather}.\n     * @param pods The pod index; the total number of Pods ever minted.\n     * @param harvested The harvested index; the total number of Pods that have ever been Harvested.\n     * @param harvestable The harvestable index; the total number of Pods that have ever been Harvestable. Included previously Harvested Beans.\n     */\n    struct Field {\n        uint128 soil; // ──────┐ 16\n        uint128 beanSown; // ──┘ 16 (32/32)\n        uint256 pods;\n        uint256 harvested;\n        uint256 harvestable;\n    }\n\n    /**\n     * @notice DEPRECATED: Contained data about each BIP (Beanstalk Improvement Proposal).\n     * @dev Replant moved governance off-chain. This struct is left for future reference.\n     * \n     */\n    struct Bip {\n        address proposer; // ───┐ 20\n        uint32 start; //        │ 4 (24)\n        uint32 period; //       │ 4 (28)\n        bool executed; // ──────┘ 1 (29/32)\n        int pauseOrUnpause; \n        uint128 timestamp;\n        uint256 roots;\n        uint256 endTotalRoots;\n    }\n\n    /**\n     * @notice DEPRECATED: Contained data for the DiamondCut associated with each BIP.\n     * @dev Replant moved governance off-chain. This struct is left for future reference.\n     * @dev {Storage.DiamondCut} stored DiamondCut-related data for each {Bip}.\n     */\n    struct DiamondCut {\n        IDiamondCut.FacetCut[] diamondCut;\n        address initAddress;\n        bytes initData;\n    }\n\n    /**\n     * @notice DEPRECATED: Contained all governance-related data, including a list of BIPs, votes for each BIP, and the DiamondCut needed to execute each BIP.\n     * @dev Replant moved governance off-chain. This struct is left for future reference.\n     * @dev {Storage.Governance} stored all BIPs and Farmer voting information.\n     */\n    struct Governance {\n        uint32[] activeBips;\n        uint32 bipIndex;\n        mapping(uint32 => DiamondCut) diamondCuts;\n        mapping(uint32 => mapping(address => bool)) voted;\n        mapping(uint32 => Bip) bips;\n    }\n\n    /**\n     * @notice System-level Silo state; contains deposit and withdrawal data for a particular whitelisted Token.\n     * @param deposited The total amount of this Token currently Deposited in the Silo.\n     * @param depositedBdv The total bdv of this Token currently Deposited in the Silo.\n     * @param withdrawn The total amount of this Token currently Withdrawn From the Silo.\n     * @dev {Storage.State} contains a mapping from Token address => AssetSilo.\n     * Currently, the bdv of deposits are asynchronous, and require an on-chain transaction to update.\n     * Thus, the total bdv of deposits cannot be calculated, and must be stored and updated upon a bdv change.\n     * \n     * Note that \"Withdrawn\" refers to the amount of Tokens that have been Withdrawn\n     * but not yet Claimed. This will be removed in a future BIP.\n     */\n    struct AssetSilo {\n        uint128 deposited;\n        uint128 depositedBdv;\n        uint256 withdrawn;\n    }\n\n    /**\n     * @notice System-level Silo state variables.\n     * @param stalk The total amount of active Stalk (including Earned Stalk, excluding Grown Stalk).\n     * @param deprecated_seeds DEPRECATED: The total amount of active Seeds (excluding Earned Seeds).\n     * @dev seeds are no longer used internally. Balance is wiped to 0 from the mayflower update. see {mowAndMigrate}.\n     * @param roots The total amount of Roots.\n     */\n    struct Silo {\n        uint256 stalk;\n        uint256 deprecated_seeds; \n        uint256 roots;\n    }\n\n    /**\n     * @notice System-level Curve Metapool Oracle state variables.\n     * @param initialized True if the Oracle has been initialzed. It needs to be initialized on Deployment and re-initialized each Unpause.\n     * @param startSeason The Season the Oracle started minting. Used to ramp up delta b when oracle is first added.\n     * @param balances The cumulative reserve balances of the pool at the start of the Season (used for computing time weighted average delta b).\n     * @param timestamp DEPRECATED: The timestamp of the start of the current Season. `LibCurveMinting` now uses `s.season.timestamp` instead of storing its own for gas efficiency purposes.\n     * @dev Currently refers to the time weighted average deltaB calculated from the BEAN:3CRV pool.\n     */\n    struct CurveMetapoolOracle {\n        bool initialized; // ────┐ 1\n        uint32 startSeason; // ──┘ 4 (5/32)\n        uint256[2] balances;\n        uint256 timestamp;\n    }\n\n    /**\n     * @notice System-level Rain balances. Rain occurs when P > 1 and the Pod Rate Excessively Low.\n     * @dev The `raining` storage variable is stored in the Season section for a gas efficient read operation.\n     * @param deprecated Previously held Rain start and Rain status variables. Now moved to Season struct for gas efficiency.\n     * @param pods The number of Pods when it last started Raining.\n     * @param roots The number of Roots when it last started Raining.\n     */\n    struct Rain {\n        uint256 deprecated;\n        uint256 pods;\n        uint256 roots;\n    }\n\n    /**\n     * @notice System-level Season state variables.\n     * @param current The current Season in Beanstalk.\n     * @param lastSop The Season in which the most recent consecutive series of Seasons of Plenty started.\n     * @param withdrawSeasons The number of Seasons required to Withdraw a Deposit.\n     * @param lastSopSeason The Season in which the most recent consecutive series of Seasons of Plenty ended.\n     * @param rainStart Stores the most recent Season in which Rain started.\n     * @param raining True if it is Raining (P > 1, Pod Rate Excessively Low).\n     * @param fertilizing True if Beanstalk has Fertilizer left to be paid off.\n     * @param sunriseBlock The block of the start of the current Season.\n     * @param abovePeg Boolean indicating whether the previous Season was above or below peg.\n     * @param stemStartSeason // season in which the stem storage method was introduced\n     * @param start The timestamp of the Beanstalk deployment rounded down to the nearest hour.\n     * @param period The length of each season in Beanstalk in seconds.\n     * @param timestamp The timestamp of the start of the current Season.\n     */\n    struct Season {\n        uint32 current; // ────────┐ 4  \n        uint32 lastSop; //         │ 4 (8)\n        uint8 withdrawSeasons; //  │ 1 (9)\n        uint32 lastSopSeason; //   │ 4 (13)\n        uint32 rainStart; //       │ 4 (17)\n        bool raining; //           │ 1 (18)\n        bool fertilizing; //       │ 1 (19)\n        uint32 sunriseBlock; //    │ 4 (23)\n        bool abovePeg; //          | 1 (24)\n        uint16 stemStartSeason; // ┘ 2 (26/32)\n        uint256 start;\n        uint256 period;\n        uint256 timestamp;\n    }\n\n    /**\n     * @notice System-level Weather state variables.\n     * @param deprecated 2 slots that were previously used.\n     * @param lastDSoil Delta Soil; the number of Soil purchased last Season.\n     * @param lastSowTime The number of seconds it for Soil to sell out last Season.\n     * @param thisSowTime The number of seconds it for Soil to sell out this Season.\n     * @param t The Temperature; the maximum interest rate during the current Season for sowing Beans in Soil. Adjusted each Season.\n     */\n    struct Weather {\n        uint256[2] deprecated;\n        uint128 lastDSoil;  // ───┐ 16 (16)\n        uint32 lastSowTime; //    │ 4  (20)\n        uint32 thisSowTime; //    │ 4  (24)\n        uint32 t; // ─────────────┘ 4  (28/32)\n    }\n\n    /**\n     * @notice Describes a Fundraiser.\n     * @param payee The address to be paid after the Fundraiser has been fully funded.\n     * @param token The token address that used to raise funds for the Fundraiser.\n     * @param total The total number of Tokens that need to be raised to complete the Fundraiser.\n     * @param remaining The remaining number of Tokens that need to to complete the Fundraiser.\n     * @param start The timestamp at which the Fundraiser started (Fundraisers cannot be started and funded in the same block).\n     */\n    struct Fundraiser {\n        address payee;\n        address token;\n        uint256 total;\n        uint256 remaining;\n        uint256 start;\n    }\n\n    /**\n     * @notice Describes the settings for each Token that is Whitelisted in the Silo.\n     * @param selector The encoded BDV function selector for the Token.\n     * @param seeds The Seeds Per BDV that the Silo mints in exchange for Depositing this Token.\n     * @param stalk The Stalk Per BDV that the Silo mints in exchange for Depositing this Token.\n     * @dev A Token is considered Whitelisted if there exists a non-zero {SiloSettings} selector.\n     * \n     * Note: `selector` is an encoded function selector that pertains to an \n     * external view function with the following signature:\n     * \n     * `function tokenToBdv(uint256 amount) public view returns (uint256);`\n     * \n     * It is called by {LibTokenSilo} through the use of delegate call to calculate \n     * the BDV of Tokens at the time of Deposit.\n     */\n    struct SiloSettings {\n        /*\n         * @dev: \n         * \n         * `selector` is an encoded function selector that pertains to \n         * an external view Beanstalk function with the following signature:\n         * \n         * ```\n         * function tokenToBdv(uint256 amount) public view returns (uint256);\n         * ```\n         * \n         * It is called by `LibTokenSilo` through the use of `delegatecall`\n         * to calculate a token's BDV at the time of Deposit.\n         */\n        bytes4 selector;\n        /*\n         * @dev The Stalk Per BDV Per Season represents how much Stalk one BDV of the underlying deposited token\n         * grows each season. In the past, this was represented by seeds. This is stored as 1e6, plus stalk is stored\n         *  as 1e10, so 1 legacy seed would be 1e6 * 1e10.\n         */\n        uint32 stalkEarnedPerSeason;\n        /*\n         * @dev The Stalk Per BDV that the Silo grants in exchange for Depositing this Token.\n         * previously just called stalk.\n         */\n        uint32 stalkIssuedPerBdv;\n        /*\n         * @dev The last season in which the stalkEarnedPerSeason for this token was updated\n         */\n\t\tuint32 milestoneSeason;\n        /*\n         * @dev The cumulative amount of grown stalk per BDV for this Silo depositable token at the last stalkEarnedPerSeason update\n         */\n\t\tint96 milestoneStem;\n\n        /*\n         @dev 1 byte of space is used for different encoding types.\n         */\n        bytes1 encodeType;\n\n        /// @dev  7 bytes of additional storage space is available here.\n\n    }\n\n    /**\n     * @notice Describes the settings for each Unripe Token in Beanstalk.\n     * @param underlyingToken The address of the Token underlying the Unripe Token.\n     * @param balanceOfUnderlying The number of Tokens underlying the Unripe Tokens (redemption pool).\n     * @param merkleRoot The Merkle Root used to validate a claim of Unripe Tokens.\n     * @dev An Unripe Token is a vesting Token that is redeemable for a a pro rata share\n     * of the `balanceOfUnderlying`, subject to a penalty based on the percent of\n     * Unfertilized Beans paid back.\n     * \n     * There were two Unripe Tokens added at Replant: \n     *  - Unripe Bean, with its `underlyingToken` as BEAN;\n     *  - Unripe LP, with its `underlyingToken` as BEAN:3CRV LP.\n     * \n     * Unripe Tokens are initially distributed through the use of a `merkleRoot`.\n     * \n     * The existence of a non-zero {UnripeSettings} implies that a Token is an Unripe Token.\n     */\n    struct UnripeSettings {\n        address underlyingToken;\n        uint256 balanceOfUnderlying;\n        bytes32 merkleRoot;\n    }\n}\n\n/**\n * @title AppStorage\n * @author Publius\n * @notice Defines the state object for Beanstalk.\n * @param deprecated_index DEPRECATED: Was the index of the BEAN token in the BEAN:ETH Uniswap V2 pool.\n * @param cases The 24 Weather cases (array has 32 items, but caseId = 3 (mod 4) are not cases)\n * @param paused True if Beanstalk is Paused.\n * @param pausedAt The timestamp at which Beanstalk was last paused.\n * @param season Storage.Season\n * @param c Storage.Contracts\n * @param f Storage.Field\n * @param g Storage.Governance\n * @param co Storage.CurveMetapoolOracle\n * @param r Storage.Rain\n * @param s Storage.Silo\n * @param reentrantStatus An intra-transaction state variable to protect against reentrance.\n * @param w Storage.Weather\n * @param earnedBeans The number of Beans distributed to the Silo that have not yet been Deposited as a result of the Earn function being called.\n * @param deprecated DEPRECATED - 14 slots that used to store state variables which have been deprecated through various updates. Storage slots can be left alone or reused.\n * @param a mapping (address => Account.State)\n * @param deprecated_bip0Start DEPRECATED - bip0Start was used to aid in a migration that occured alongside BIP-0.\n * @param deprecated_hotFix3Start DEPRECATED - hotFix3Start was used to aid in a migration that occured alongside HOTFIX-3.\n * @param fundraisers A mapping from Fundraiser ID to Storage.Fundraiser.\n * @param fundraiserIndex The number of Fundraisers that have occured.\n * @param deprecated_isBudget DEPRECATED - Budget Facet was removed in BIP-14. \n * @param podListings A mapping from Plot Index to the hash of the Pod Listing.\n * @param podOrders A mapping from the hash of a Pod Order to the amount of Pods that the Pod Order is still willing to buy.\n * @param siloBalances A mapping from Token address to Silo Balance storage (amount deposited and withdrawn).\n * @param ss A mapping from Token address to Silo Settings for each Whitelisted Token. If a non-zero storage exists, a Token is whitelisted.\n * @param deprecated2 DEPRECATED - 2 slots that used to store state variables which have been depreciated through various updates. Storage slots can be left alone or reused.\n * @param newEarnedStalk the amount of earned stalk issued this season. Since 1 stalk = 1 bean, it represents the earned beans as well.\n * @param sops A mapping from Season to Plenty Per Root (PPR) in that Season. Plenty Per Root is 0"
    }
  ]
}