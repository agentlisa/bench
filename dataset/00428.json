{
  "Title": "M-9: `leverageAmount` is incorrect in  `SGLLeverage.sellCollateral` function due to calculation based on the new states of YieldBox after withdrawal",
  "Content": "# Issue M-9: `leverageAmount` is incorrect in  `SGLLeverage.sellCollateral` function due to calculation based on the new states of YieldBox after withdrawal \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/61 \n\n## Found by \nbin2chen, duc\n## Summary\nSee vulnerability detail\n## Vulnerability Detail\n`SGLLeverage.sellCollateral` function attempts to remove the user's collateral in shares of YieldBox, then withdraws those collateral shares to collect collateral tokens. Subsequently, the received collateral tokens can be used to swap for asset tokens.\n\nHowever, the `leverageAmount` variable in this function does not represent the actual withdrawn tokens from the provided shares because it is calculated after the withdrawal.\n```solidity=\nyieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, calldata_.share);\nuint256 leverageAmount = yieldBox.toAmount(collateralId, calldata_.share, false);\n\namountOut = leverageExecutor.getAsset(\n    assetId, address(collateral), address(asset), leverageAmount, calldata_.from, calldata_.data\n);\n```\n`yieldBox.toAmount` after withdrawal may return different from the actual withdrawn token amount, because the states of YieldBox has changed. Because the token amount is calculated with rounding down in YieldBox, `leverageAmount` will be higher than the actual withdrawn amount.\n\nFor example, before the withdrawal, YieldBox had 100 total shares and 109 total tokens. Now this function attempt to withdraw 10 shares (`calldata_.share` = 10)\n**-> the actual withdrawn amount = 10 * 109 / 100 = 10 tokens**\nAfter that, leverageAmount will be calculated based on the new yieldBox's total shares and total tokens\n**-> leverageAmount = 10 * (109 - 10) / (100 - 10) = 11 tokens**\n\nThe same vulnerability exists in `BBLeverage.sellCollateral` function.\n\n## Impact\nBecause `leverageAmount` can be higher than the actual withdrawn collateral tokens, `leverageExecutor.getAsset()` will revert due to not having enough tokens in the contract to pull. This results in a DOS of `sellCollateral`, break this functionality.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol#L127-L128\n## Tool used\n\nManual Review\n\n## Recommendation\n`leverageAmount` should be obtained from the return value of `YieldBox.withdraw`:\n```solidity=\n(uint256 leverageAmount, ) = yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, calldata_.share);\n```\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nFixed by https://github.com/Tapioca-DAO/Tapioca-bar/pull/356\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/356.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20, IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {SGLLendingCommon} from \"./SGLLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLLeverage is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n        uint256 supplyShareToAmount;\n        if (supplyShare > 0) {\n            (supplyShareToAmount,) =\n                yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n        }\n        (, uint256 borrowShare) = _borrow(calldata_.from, address(this), calldata_.borrowAmount);\n\n        (uint256 borrowShareToAmount,) =\n            yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        amountOut = leverageExecutor.getCollateral(\n            collateralId,\n            address(asset),\n            address(collateral),\n            supplyShareToAmount + borrowShareToAmount,\n            calldata_.from,\n            calldata_.data\n        );\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralCalldata {\n        address from;\n        uint256 share;\n        bytes data;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _SellCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.share = share;\n            calldata_.data = data;\n        }\n\n        _allowedBorrow(calldata_.from, calldata_.share);\n        _removeCollateral(calldata_.from, address(this), calldata_.share);\n\n        yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, calldata_.share);\n        uint256 leverageAmount = yieldBox.toAmount(collateralId, calldata_.share, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), leverageAmount, calldata_.from, calldata_.data\n        );\n        uint256 shareOut = yieldBox.toShare(assetId, amountOut, false);\n\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(assetId, address(this), address(this), 0, shareOut);\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        uint256 partOwed = userBorrowPart[calldata_.from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(calldata_.from, calldata_.from, false, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(calldata_.from, calldata_.from, false, partOut);\n        }\n    }\n}"
    }
  ]
}