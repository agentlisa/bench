{
  "Title": "[L08] Lack of indexed parameters",
  "Content": "None of the parameters in the [`SetFactoryAdmin`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L18), [`SetAcoTokenImplementation`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L25), [`SetAcoFee`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L32) and [`SetAcoFeeDestination`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L39) events in the [`ACOFactory`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol) are indexed. The same is true for the [`ProxyAdminUpdated`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOProxy.sol#L16) and [`SetImplementation`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOProxy.sol#L23) events of the [`ACOProxy`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOProxy.sol) contract.\n\n\nIndexing parameters in these events allows the timeline of sensitive changes to be more easily tracked. Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.\n\n\n**Update:** *Partially fixed. The Auctus team decided to index event parameters in the `ACOFactory` contract in [pull request #11](https://github.com/AuctusProject/aco/pull/11), but not in `ACOProxy` as shown in [pull request #15](https://github.com/AuctusProject/aco/pull/15). Auctus’ statemement for this issue:*\n\n\n\n> \n>  We indexed parameters in the ACOFactory. About the proxy parameters, we don’t expect significant amount of data to justify changing our current proxy address.\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "smart-contracts/contracts/core/ACOFactory.sol",
      "content": "pragma solidity ^0.6.6;\n\nimport \"../libs/Address.sol\";\nimport \"../libs/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"../libs/Strings.sol\";\n\n/**\n * @title ACOFactory\n * @dev The contract is the implementation for the ACOProxy.\n */\ncontract ACOFactory {\n    \n    /**\n     * @dev Emitted when the factory admin address has been changed.\n     * @param previousFactoryAdmin Address of the previous factory admin.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    event SetFactoryAdmin(address previousFactoryAdmin, address newFactoryAdmin);\n    \n    /**\n     * @dev Emitted when the ACO token implementation has been changed.\n     * @param previousAcoTokenImplementation Address of the previous ACO token implementation.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    event SetAcoTokenImplementation(address previousAcoTokenImplementation, address newAcoTokenImplementation);\n    \n    /**\n     * @dev Emitted when the ACO fee has been changed.\n     * @param previousAcoFee Value of the previous ACO fee.\n     * @param newAcoFee Value of the new ACO fee.\n     */\n    event SetAcoFee(uint256 previousAcoFee, uint256 newAcoFee);\n    \n    /**\n     * @dev Emitted when the ACO fee destination address has been changed.\n     * @param previousAcoFeeDestination Address of the previous ACO fee destination.\n     * @param newAcoFeeDestination Address of the new ACO fee destination.\n     */\n    event SetAcoFeeDestination(address previousAcoFeeDestination, address newAcoFeeDestination);\n    \n    /**\n     * @dev Emitted when a new ACO token has been created.\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall True if the type is CALL, false for PUT.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     * @param acoToken Address of the new ACO token created.\n     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\n     */\n    event NewAcoToken(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation);\n    \n    /**\n     * @dev The ACO fee value. \n     * It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev The factory admin address.\n     */\n    address public factoryAdmin;\n    \n    /**\n     * @dev The ACO token implementation address.\n     */\n    address public acoTokenImplementation;\n    \n    /**\n     * @dev The ACO fee destination address.\n     */\n    address public acoFeeDestination;\n    \n    /**\n     * @dev Modifier to check if the `msg.sender` is the factory admin.\n     * Only factory admin address can execute.\n     */\n    modifier onlyFactoryAdmin() {\n        require(msg.sender == factoryAdmin, \"ACOFactory::onlyFactoryAdmin\");\n        _;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called through the `data` argument when creating the proxy.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _factoryAdmin Address of the factory admin.\n     * @param _acoTokenImplementation Address of the ACO token implementation.\n     * @param _acoFee Value of the ACO fee.\n     * @param _acoFeeDestination Address of the ACO fee destination.\n     */\n    function init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) public {\n        require(factoryAdmin == address(0) && acoTokenImplementation == address(0), \"ACOFactory::init: Contract already initialized.\");\n        \n        _setFactoryAdmin(_factoryAdmin);\n        _setAcoTokenImplementation(_acoTokenImplementation);\n        _setAcoFee(_acoFee);\n        _setAcoFeeDestination(_acoFeeDestination);\n    }\n\n    /**\n     * @dev Function to guarantee that the contract will not receive ether.\n     */\n    receive() external payable virtual {\n        revert();\n    }\n    \n    /**\n     * @dev Function to create a new ACO token.\n     * It deploys a minimal proxy for the ACO token implementation address. \n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall Whether the ACO token is the Call type.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     */\n    function createAcoToken(\n        address underlying, \n        address strikeAsset, \n        bool isCall,\n        uint256 strikePrice, \n        uint256 expiryTime\n    ) onlyFactoryAdmin external virtual {\n        address acoToken = _deployAcoToken(_getAcoTokenInitData(underlying, strikeAsset, isCall, strikePrice, expiryTime));\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);   \n    }\n    \n    /**\n     * @dev Function to set the factory admin address.\n     * Only can be called by the factory admin.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\n        _setFactoryAdmin(newFactoryAdmin);\n    }\n    \n    /**\n     * @dev Function to set the ACO token implementation address.\n     * Only can be called by the factory admin.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    function setAcoTokenImplementation(address newAcoTokenImplementation) onlyFactoryAdmin external virtual {\n        _setAcoTokenImplementation(newAcoTokenImplementation);\n    }\n    \n    /**\n     * @dev Function to set the ACO fee.\n     * Only can be called by the factory admin.\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n     */\n    function setAcoFee(uint256 newAcoFee) onlyFactoryAdmin external virtual {\n        _setAcoFee(newAcoFee);\n    }\n    \n    /**\n     * @dev Function to set the ACO destination address.\n     * Only can be called by the factory admin.\n     * @param newAcoFeeDestination Address of the new ACO destination.\n     */\n    function setAcoFeeDestination(address newAcoFeeDestination) onlyFactoryAdmin external virtual {\n        _setAcoFeeDestination(newAcoFeeDestination);\n    }\n    \n    /**\n     * @dev Internal function to set the factory admin address.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\n        require(newFactoryAdmin != address(0), \"ACOFactory::_setFactoryAdmin: Invalid factory admin\");\n        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\n        factoryAdmin = newFactoryAdmin;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO token implementation address.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    function _setAcoTokenImplementation(address newAcoTokenImplementation) internal virtual {\n        require(Address.isContract(newAcoTokenImplementation), \"ACOFactory::_setAcoTokenImplementation: Invalid ACO token implementation\");\n        emit SetAcoTokenImplementation(acoTokenImplementation, newAcoTokenImplementation);\n        acoTokenImplementation = newAcoTokenImplementation;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO fee.\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n     */\n    function _setAcoFee(uint256 newAcoFee) internal virtual {\n        emit SetAcoFee(acoFee, newAcoFee);\n        acoFee = newAcoFee;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO destination address.\n     * @param newAcoFeeDestination Address of the new ACO destination.\n     */\n    function _setAcoFeeDestination(address newAcoFeeDestination) internal virtual {\n        require(newAcoFeeDestination != address(0), \"ACOFactory::_setAcoFeeDestination: Invalid ACO fee destination\");\n        emit SetAcoFeeDestination(acoFeeDestination, newAcoFeeDestination);\n        acoFeeDestination = newAcoFeeDestination;\n    }\n    \n    /**\n     * @dev Internal function to get the ACO token initialize data.\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall True if the type is CALL, false for PUT.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     * @return ABI encoded with signature for initializing ACO token.\n     */\n    function _getAcoTokenInitData(\n        address underlying, \n        address strikeAsset, \n        bool isCall,\n        uint256 strikePrice, \n        uint256 expiryTime\n    ) internal view virtual returns(bytes memory) {\n        return abi.encodeWithSignature(\"init(address,address,bool,uint256,uint256,uint256,address)\",\n            underlying,\n            strikeAsset,\n            isCall,\n            strikePrice,\n            expiryTime,\n            acoFee,\n            acoFeeDestination\n        );\n    }\n    \n    /**\n     * @dev Internal function to deploy a minimal proxy using ACO token implementation.\n     * @param initData ABI encoded with signature for initializing the new ACO token.\n     * @return Address of the new minimal proxy deployed for the ACO token.\n     */\n    function _deployAcoToken(bytes memory initData) internal virtual returns(address) {\n        require(initData.length > 0, \"ACOFactory::_deployToken: Invalid init data\");\n        bytes20 implentationBytes = bytes20(acoTokenImplementation);\n        address proxy;\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), implentationBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            proxy := create(0, clone, 0x37)\n        }\n        (bool success, bytes memory returnData) = proxy.call(initData);\n        require(success, _acoTokenInititalizeError(returnData));\n        return proxy;\n    }\n    \n    /**\n     * @dev Internal function to handle the return data on initializing ACO token with an error.\n     * 4 bytes (function signature) + 32 bytes (offset) + 32 bytes (error string length) + X bytes (error string)\n     * @param data Returned data with an error.\n     * @return String with the error.\n     */\n    function _acoTokenInititalizeError(bytes memory data) internal pure virtual returns(string memory) {\n        if (data.length >= 100) {\n            bytes memory buffer = new bytes(data.length - 68);\n            uint256 index = 0;\n            for (uint256 i = 68; i < data.length; ++i) {\n                buffer[index++] = data[i];\n            }\n            return string(buffer);\n        } else {\n            return \"ACOFactory::_acoTokenInititalizeError\";\n        }  \n    }\n}"
    }
  ]
}