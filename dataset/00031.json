{
  "Title": "Gas Inefficiencies",
  "Content": "Across the codebase, there are some instances in which the code can be refactored to be more gas efficient:\n\n\n* The [`newConfig` parameter](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L1BatchBridgeGateway.sol#L242) of the `setBatchConfig` function can be made read-only. Consider changing its location from `memory` to `calldata` to save gas.\n* In order to improve code intentionality and reduce the gas cost in case of a revert, consider switching the order of the following [instructions](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L1BatchBridgeGateway.sol#L353-L356) to prioritize the [`if` statement](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L1BatchBridgeGateway.sol#L354-L356).\n* The [`feeVault`](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L1BatchBridgeGateway.sol#L163) state variable of the `L1BatchBridgeGateway` contract is not changeable, consider declaring it as `immutable`.\n\n\n***Update:** Resolved in [pull request #1334](https://github.com/scroll-tech/scroll/pull/1334) at commit [b7cc5c2](https://github.com/scroll-tech/scroll/pull/1334/commits/b7cc5c293b7984fbeb8aa7a9f105bcfe27bc77f2).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/batch-bridge/L1BatchBridgeGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport {IL1ERC20Gateway} from \"../L1/gateways/IL1ERC20Gateway.sol\";\nimport {IL1GatewayRouter} from \"../L1/gateways/IL1GatewayRouter.sol\";\nimport {IL1MessageQueue} from \"../L1/rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"../L1/IL1ScrollMessenger.sol\";\n\nimport {BatchBridgeCodec} from \"./BatchBridgeCodec.sol\";\nimport {L2BatchBridgeGateway} from \"./L2BatchBridgeGateway.sol\";\n\n/// @title L1BatchBridgeGateway\ncontract L1BatchBridgeGateway is AccessControlEnumerableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchDepositGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchDepositGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchDepositGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig memory newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal nonReentrant {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}(\"\");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/batch-bridge/L1BatchBridgeGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport {IL1ERC20Gateway} from \"../L1/gateways/IL1ERC20Gateway.sol\";\nimport {IL1GatewayRouter} from \"../L1/gateways/IL1GatewayRouter.sol\";\nimport {IL1MessageQueue} from \"../L1/rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"../L1/IL1ScrollMessenger.sol\";\n\nimport {BatchBridgeCodec} from \"./BatchBridgeCodec.sol\";\nimport {L2BatchBridgeGateway} from \"./L2BatchBridgeGateway.sol\";\n\n/// @title L1BatchBridgeGateway\ncontract L1BatchBridgeGateway is AccessControlEnumerableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchDepositGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchDepositGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchDepositGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig memory newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal nonReentrant {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The c"
    }
  ]
}