{
  "Title": "[H03] Elected validators of a group can be chosen by the validator group registrant",
  "Content": "The [`electValidatorSigners` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L814) of the [`Election` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L16) is responsible for the election of validators within validator groups. After calculating the amount of seats each validator group receives, it uses the [`getTopGroupValidators` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L850) defined in the [`Validators` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L905) to get the elected members of the group. In this specific case, the [`headN`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/AddressLinkedList.sol#L77) function is internally used by `getTopGroupValidators` to get [the first `numMembersElected[i]` elements of the `electionGroups[i]` validator group](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L851-L852).\n\n\nAs a result, this return value will be saved in the [`electedGroupValidators`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L850-L853) variable, thus assigning the validators to the [`electedValidators` mapping](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L854) and establishing them as validators of a certain epoch.\n\n\nThe problem arises from the assumption that the `members` list is [ordered](https://github.com/celo-org/celo-monorepo/blob/master/packages/docs/celo-codebase/protocol/proof-of-stake/validator-groups.md) by any value. This list can be reordered by the registrant of the group using the [`reorderMember` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L760).  \n\nThis function allows the registrant of a validator group, which is any address that makes use of the [`registerValidatorGroup` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Validators.sol#L632), to benefit whichever validator they want by ordering them in the head of the `member` list.\n\n\nTwo general issues result from this:\n\n\n* Users naively joining validator groups assuming they are secure or fair will be subject to the registrant decision on whether they will be able to be picked as validators, which could lower the user’s earnings over time.\n* A registrant or multiple colluding registrants can instantaneously reorder their group’s validators to give those validators monetary rewards, and, with enough colluding validators, control over the protocol’s consensus mechanism. This action would be publicly visible after the fact, so groups that have a reputation for doing this would likely lose voter support over time.\n\n\nConsider modifying the `members` list’s type to match the [`AddressSortedLinkedList`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/AddressSortedLinkedList.sol#L11) type in which the validators in a group are assigned by a specific value, which could be for example, the amount of locked gold of the validators. Moreover, if the ability to reorder validators in a group is important for specific use cases, such as organizations that want to change the specific machines or keys under which they validate in the case of hardware or connectivity failure, consider modifying the codebase so that this freely reorderable functionality is specifically opt-in, and not the default configuration.\n\n\n****Update:*** Not Fixed. cLabs’ statement for this issue:*\n\n\n\n> \n> A single entity that controls 2/3rds of validator groups can indeed take over the network. Such an attack would require 2/3rds of the votes to achieve, and the primary defense against this attack is the high vote threshold required. One needs to assume that a compromised validator group compromises all of the members of that validator group. The remedy for a malicious validator group is voting, and the add/remove/reorder operations of a validator group are not intended to be resilient against a malicious registrant.  \n> \n> The critical question here is, how does the mechanism of validator groups affect the overall security of the system? To explore this, let us consider a spectrum where the maximum validator group size (currently set to 5) is varied between the extremes of 1 and unlimited.  \n> \n> At one extreme, the maximum validator group size were to be lowered to 1, the system would become equivalent to the direct election of validators. One would expect a single person to own both the validator group and the validator. Validator groups would merely be a layer of indirection to allow swapping out down nodes or doing system upgrades.  \n> \n> At the other extreme, if there were no limits on validator group size, the system would become similar to parliamentary democracy. A single political party (validator group) could get a large amount of control, which would be less decentralized. However, larger validator groups have some advantages. A larger validator group is better able to do thorough vetting and security audits of validators than individual voters. It can also respond more quickly to outages or attacks. Changing significant numbers of votes is a slow process, and validator groups add an element of agility to the network. Voters might also find it easier to research a larger validator group than an individual validator. The security of the system is fundamentally derived from voting, so making voting easier increases security.  \n> \n> It is open to debate what the correct limit should be. The election of 5 errs close to the direct election extreme while hopefully maintaining some of the benefits larger validator groups.\n> \n> \n> \n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/Election.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IElection.sol\";\nimport \"./interfaces/IValidators.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/AddressSortedLinkedList.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/UsingRegistry.sol\";\n\ncontract Election is\n  IElection,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using AddressSortedLinkedList for SortedLinkedList.List;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct PendingVote {\n    // The value of the vote, in gold.\n    uint256 value;\n    // The epoch at which the vote was cast.\n    uint256 epoch;\n  }\n\n  struct GroupPendingVotes {\n    // The total number of pending votes that have been cast for this group.\n    uint256 total;\n    // Pending votes cast per voter.\n    mapping(address => PendingVote) byAccount;\n  }\n\n  // Pending votes are those for which no following elections have been held.\n  // These votes have yet to contribute to the election of validators and thus do not accrue\n  // rewards.\n  struct PendingVotes {\n    // The total number of pending votes cast across all groups.\n    uint256 total;\n    mapping(address => GroupPendingVotes) forGroup;\n  }\n\n  struct GroupActiveVotes {\n    // The total number of active votes that have been cast for this group.\n    uint256 total;\n    // The total number of active votes by a voter is equal to the number of active vote units for\n    // that voter times the total number of active votes divided by the total number of active\n    // vote units.\n    uint256 totalUnits;\n    mapping(address => uint256) unitsByAccount;\n  }\n\n  // Active votes are those for which at least one following election has been held.\n  // These votes have contributed to the election of validators and thus accrue rewards.\n  struct ActiveVotes {\n    // The total number of active votes cast across all groups.\n    uint256 total;\n    mapping(address => GroupActiveVotes) forGroup;\n  }\n\n  struct TotalVotes {\n    // A list of eligible ValidatorGroups sorted by total (pending+active) votes.\n    // Note that this list will omit ineligible ValidatorGroups, including those that may have > 0\n    // total votes.\n    SortedLinkedList.List eligible;\n  }\n\n  struct Votes {\n    PendingVotes pending;\n    ActiveVotes active;\n    TotalVotes total;\n    // Maps an account to the list of groups it's voting for.\n    mapping(address => address[]) groupsVotedFor;\n  }\n\n  struct ElectableValidators {\n    uint256 min;\n    uint256 max;\n  }\n\n  Votes private votes;\n  // Governs the minimum and maximum number of validators that can be elected.\n  ElectableValidators public electableValidators;\n  // Governs how many validator groups a single account can vote for.\n  uint256 public maxNumGroupsVotedFor;\n  // Groups must receive at least this fraction of the total votes in order to be considered in\n  // elections.\n  FixidityLib.Fraction public electabilityThreshold;\n\n  event ElectableValidatorsSet(uint256 min, uint256 max);\n\n  event MaxNumGroupsVotedForSet(uint256 maxNumGroupsVotedFor);\n\n  event ElectabilityThresholdSet(uint256 electabilityThreshold);\n\n  event ValidatorGroupMarkedEligible(address group);\n\n  event ValidatorGroupMarkedIneligible(address group);\n\n  event ValidatorGroupVoteCast(address indexed account, address indexed group, uint256 value);\n\n  event ValidatorGroupVoteActivated(address indexed account, address indexed group, uint256 value);\n\n  event ValidatorGroupVoteRevoked(address indexed account, address indexed group, uint256 value);\n\n  event EpochRewardsDistributedToVoters(address indexed group, uint256 value);\n\n  /**\n   * @notice Initializes critical variables.\n   * @param registryAddress The address of the registry contract.\n   * @param minElectableValidators The minimum number of validators that can be elected.\n   * @param _maxNumGroupsVotedFor The maximum number of groups that an acconut can vote for at once.\n   * @param _electabilityThreshold The minimum ratio of votes a group needs before its members can\n   *   be elected.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 minElectableValidators,\n    uint256 maxElectableValidators,\n    uint256 _maxNumGroupsVotedFor,\n    uint256 _electabilityThreshold\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setElectableValidators(minElectableValidators, maxElectableValidators);\n    setMaxNumGroupsVotedFor(_maxNumGroupsVotedFor);\n    setElectabilityThreshold(_electabilityThreshold);\n  }\n\n  /**\n   * @notice Updates the minimum and maximum number of validators that can be elected.\n   * @param min The minimum number of validators that can be elected.\n   * @param max The maximum number of validators that can be elected.\n   * @return True upon success.\n   */\n  function setElectableValidators(uint256 min, uint256 max) public onlyOwner returns (bool) {\n    require(0 < min, \"Minimum electable validators cannot be zero\");\n    require(min <= max, \"Maximum electable validators cannot be smaller than minimum\");\n    require(\n      min != electableValidators.min || max != electableValidators.max,\n      \"Electable validators not changed\"\n    );\n    electableValidators = ElectableValidators(min, max);\n    emit ElectableValidatorsSet(min, max);\n    return true;\n  }\n\n  /**\n   * @notice Returns the minimum and maximum number of validators that can be elected.\n   * @return The minimum and maximum number of validators that can be elected.\n   */\n  function getElectableValidators() external view returns (uint256, uint256) {\n    return (electableValidators.min, electableValidators.max);\n  }\n\n  /**\n   * @notice Updates the maximum number of groups an account can be voting for at once.\n   * @param _maxNumGroupsVotedFor The maximum number of groups an account can vote for.\n   * @return True upon success.\n   */\n  function setMaxNumGroupsVotedFor(uint256 _maxNumGroupsVotedFor) public onlyOwner returns (bool) {\n    require(_maxNumGroupsVotedFor != maxNumGroupsVotedFor, \"Max groups voted for not changed\");\n    maxNumGroupsVotedFor = _maxNumGroupsVotedFor;\n    emit MaxNumGroupsVotedForSet(_maxNumGroupsVotedFor);\n    return true;\n  }\n\n  /**\n   * @notice Sets the electability threshold.\n   * @param threshold Electability threshold as unwrapped Fraction.\n   * @return True upon success.\n   */\n  function setElectabilityThreshold(uint256 threshold) public onlyOwner returns (bool) {\n    electabilityThreshold = FixidityLib.wrap(threshold);\n    require(\n      electabilityThreshold.lt(FixidityLib.fixed1()),\n      \"Electability threshold must be lower than 100%\"\n    );\n    emit ElectabilityThresholdSet(threshold);\n    return true;\n  }\n\n  /**\n   * @notice Gets the election threshold.\n   * @return Threshold value as unwrapped fraction.\n   */\n  function getElectabilityThreshold() external view returns (uint256) {\n    return electabilityThreshold.unwrap();\n  }\n\n  /**\n   * @notice Increments the number of total and pending votes for `group`.\n   * @param group The validator group to vote for.\n   * @param value The amount of gold to use to vote.\n   * @param lesser The group receiving fewer votes than `group`, or 0 if `group` has the\n   *   fewest votes of any validator group.\n   * @param greater The group receiving more votes than `group`, or 0 if `group` has the\n   *   most votes of any validator group.\n   * @return True upon success.\n   * @dev Fails if `group` is empty or not a validator group.\n   */\n  function vote(address group, uint256 value, address lesser, address greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    require(votes.total.eligible.contains(group), \"Group not eligible\");\n    require(0 < value, \"Vote value cannot be zero\");\n    require(canReceiveVotes(group, value), \"Group cannot receive votes\");\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n\n    // Add group to the groups voted for by the account.\n    bool alreadyVotedForGroup = false;\n    address[] storage groups = votes.groupsVotedFor[account];\n    for (uint256 i = 0; i < groups.length; i = i.add(1)) {\n      alreadyVotedForGroup = alreadyVotedForGroup || groups[i] == group;\n    }\n    if (!alreadyVotedForGroup) {\n      require(groups.length < maxNumGroupsVotedFor, \"Voted for too many groups\");\n      groups.push(group);\n    }\n\n    incrementPendingVotes(group, account, value);\n    incrementTotalVotes(group, value, lesser, greater);\n    getLockedGold().decrementNonvotingAccountBalance(account, value);\n    emit ValidatorGroupVoteCast(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Converts `account`'s pending votes for `group` to active votes.\n   * @param group The validator group to vote for.\n   * @return True upon success.\n   * @dev Pending votes cannot be activated until an election has been held.\n   */\n  function activate(address group) external nonReentrant returns (bool) {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    PendingVote storage pendingVote = votes.pending.forGroup[group].byAccount[account];\n    require(pendingVote.epoch < getEpochNumber(), \"Pending vote epoch not passed\");\n    uint256 value = pendingVote.value;\n    require(value > 0, \"Vote value cannot be zero\");\n    decrementPendingVotes(group, account, value);\n    incrementActiveVotes(group, account, value);\n    emit ValidatorGroupVoteActivated(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Returns whether or not an account's votes for the specified group can be activated.\n   * @param account The account with pending votes.\n   * @param group The validator group that `account` has pending votes for.\n   * @return Whether or not `account` has activatable votes for `group`.\n   * @dev Pending votes cannot be activated until an election has been held.\n   */\n  function hasActivatablePendingVotes(address account, address group) external view returns (bool) {\n    PendingVote storage pendingVote = votes.pending.forGroup[group].byAccount[account];\n    return pendingVote.epoch < getEpochNumber() && pendingVote.value > 0;\n  }\n\n  /**\n   * @notice Revokes `value` pending votes for `group`\n   * @param group The validator group to revoke votes from.\n   * @param value The number of votes to revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *   or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return True upon success.\n   * @dev Fails if the account has not voted on a validator group.\n   */\n  function revokePending(\n    address group,\n    uint256 value,\n    address lesser,\n    address greater,\n    uint256 index\n  ) external nonReentrant returns (bool) {\n    require(group != address(0), \"Group address zero\");\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    require(0 < value, \"Vote value cannot be zero\");\n    require(\n      value <= getPendingVotesForGroupByAccount(group, account),\n      \"Vote value larger than pending votes\"\n    );\n    decrementPendingVotes(group, account, value);\n    decrementTotalVotes(group, value, lesser, greater);\n    getLockedGold().incrementNonvotingAccountBalance(account, value);\n    if (getTotalVotesForGroupByAccount(group, account) == 0) {\n      deleteElement(votes.groupsVotedFor[account], group, index);\n    }\n    emit ValidatorGroupVoteRevoked(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Revokes `value` active votes for `group`\n   * @param group The validator group to revoke votes from.\n   * @param value The number of votes to revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *   or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return True upon success.\n   * @dev Fails if the account has not voted on a validator group.\n   */\n  function revokeActive(\n    address group,\n    uint256 value,\n    address lesser,\n    address greater,\n    uint256 index\n  ) external nonReentrant returns (bool) {\n    // TODO(asa): Dedup with revokePending.\n    require(group != address(0), \"Group address zero\");\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    require(0 < value, \"Vote value cannot be zero\");\n    require(\n      value <= getActiveVotesForGroupByAccount(group, account),\n      \"Vote value larger than active votes\"\n    );\n    decrementActiveVotes(group, account, value);\n    decrementTotalVotes(group, value, lesser, greater);\n    getLockedGold().incrementNonvotingAccountBalance(account, value);\n    if (getTotalVotesForGroupByAccount(group, account) == 0) {\n      deleteElement(votes.groupsVotedFor[account], group, index);\n    }\n    emit ValidatorGroupVoteRevoked(account, group, value);\n    return true;\n  }\n\n  /**\n   * @notice Decrements `value` pending or active votes for `group` from `account`.\n   *         First revokes all pending votes and then, if `value` votes haven't\n   *         been revoked yet, revokes additional active votes.\n   *         Fundamentally calls `revokePending` and `revokeActive` but only resorts groups once.\n   * @param account The account whose votes to `group` should be decremented.\n   * @param group The validator group to decrement votes from.\n   * @param maxValue The maxinum number of votes to decrement and revoke.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *               or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *                or 0 if that group has the most votes of any validator group.\n   * @param index The index of the group in the account's voting list.\n   * @return uint256 Number of votes successfully decremented and revoked, with a max of `value`.\n   */\n  function _decrementVotes(\n    address account,\n    address group,\n    uint256 maxValue,\n    address lesser,\n    address greater,\n    uint256 index\n  ) internal returns (uint256) {\n    uint256 remainingValue = maxValue;\n    uint256 pendingVotes = getPendingVotesForGroupByAccount(group, account);\n    if (pendingVotes > 0) {\n      uint256 decrementValue = Math.min(remainingValue, pendingVotes);\n      decrementPendingVotes(group, account, decrementValue);\n      remainingValue = remainingValue.sub(decrementValue);\n    }\n    uint256 activeVotes = getActiveVotesForGroupByAccount(group, account);\n    if (activeVotes > 0 && remainingValue > 0) {\n      uint256 decrementValue = Math.min(remainingValue, activeVotes);\n      decrementActiveVotes(group, account, decrementValue);\n      remainingValue = remainingValue.sub(decrementValue);\n    }\n    uint256 decrementedValue = maxValue.sub(remainingValue);\n    if (decrementedValue > 0) {\n      decrementTotalVotes(group, decrementedValue, lesser, greater);\n      emit ValidatorGroupVoteRevoked(account, group, decrementedValue);\n      if (getTotalVotesForGroupByAccount(group, account) == 0) {\n        deleteElement(votes.groupsVotedFor[account], group, index);\n      }\n    }\n    return decrementedValue;\n  }\n\n  /**\n   * @notice Returns the total number of votes cast by an account.\n   * @param account The address of the account.\n   * @return The total number of votes cast by an account.\n   */\n  function getTotalVotesByAccount(address account) external view returns (uint256) {\n    uint256 total = 0;\n    address[] memory groups = votes.groupsVotedFor[account];\n    for (uint256 i = 0; i < groups.length; i = i.add(1)) {\n      total = total.add(getTotalVotesForGroupByAccount(groups[i], account));\n    }\n    return total;\n  }\n\n  /**\n   * @notice Returns the pending votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The pending votes for `group` made by `account`.\n   */\n  function getPendingVotesForGroupByAccount(address group, address account)\n    public\n    view\n    returns (uint256)\n  {\n    return votes.pending.forGroup[group].byAccount[account].value;\n  }\n\n  /**\n   * @notice Returns the active votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The active votes for `group` made by `account`.\n   */\n  function getActiveVotesForGroupByAccount(address group, address account)\n    public\n    view\n    returns (uint256)\n  {\n    GroupActiveVotes storage groupActiveVotes = votes.active.forGroup[group];\n    uint256 numerator = groupActiveVotes.unitsByAccount[account].mul(groupActiveVotes.total);\n    if (numerator == 0) {\n      return 0;\n    }\n    uint256 denominator = groupActiveVotes.totalUnits;\n    return numerator.div(denominator);\n  }\n\n  /**\n   * @notice Returns the total votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @return The total votes for `group` made by `account`.\n   */\n  function getTotalVotesForGroupByAccount(address group, address account)\n    public\n    view\n    returns (uint256)\n  {\n    uint256 pending = getPendingVotesForGroupByAccount(group, account);\n    uint256 active = getActiveVotesForGroupByAccount(group, account);\n    return pending.add(active);\n  }\n\n  /**\n   * @notice Returns the total votes made for `group`.\n   * @param group The address of the validator group.\n   * @return The total votes made for `group`.\n   */\n  function getTotalVotesForGroup(address group) public view returns (uint256) {\n    return votes.pending.forGroup[group].total.add(votes.active.forGroup[group].total);\n  }\n\n  /**\n   * @notice Returns the active votes made for `group`.\n   * @param group The address of the validator group.\n   * @return The active votes made for `group`.\n   */\n  function getActiveVotesForGroup(address group) public view returns (uint256) {\n    return votes.active.forGroup[group].total;\n  }\n\n  /**\n   * @notice Returns whether or not a group is eligible to receive votes.\n   * @return Whether or not a group is eligible to receive votes.\n   * @dev Eligible groups that have received their maximum number of votes cannot receive more.\n   */\n  function getGroupEligibility(address group) external view returns (bool) {\n    return votes.total.eligible.contains(group);\n  }\n\n  /**\n   * @notice Returns the amount of rewards that voters for `group` are due at the end of an epoch.\n   * @param group The group to calculate epoch rewards for.\n   * @param totalEpochRewards The total amount of rewards going to all voters.\n   * @param uptimes Array of Fixidity representations of the validators' uptimes, between 0 and 1.\n   * @return The amount of rewards that voters for `group` are due at the end of an epoch.\n   * @dev Eligible groups that have received their maximum number of votes cannot receive more.\n   */\n  function getGroupEpochRewards(\n    address group,\n    uint256 totalEpochRewards,\n    uint256[] calldata uptimes\n  ) external view returns (uint256) {\n    IValidators validators = getValidators();\n    // The group must meet the balance requirements for their voters to receive epoch rewards.\n    if (!validators.meetsAccountLockedGoldRequirements(group) || votes.active.total <= 0) {\n      return 0;\n    }\n\n    FixidityLib.Fraction memory votePortion = FixidityLib.newFixedFraction(\n      votes.active.forGroup[group].total,\n      votes.active.total\n    );\n    FixidityLib.Fraction memory score = FixidityLib.wrap(\n      validators.calculateGroupEpochScore(uptimes)\n    );\n    FixidityLib.Fraction memory slashingMultiplier = FixidityLib.wrap(\n      validators.getValidatorGroupSlashingMultiplier(group)\n    );\n    return\n      FixidityLib\n        .newFixed(totalEpochRewards)\n        .multiply(votePortion)\n        .multiply(score)\n        .multiply(slashingMultiplier)\n        .fromFixed();\n  }\n\n  /**\n   * @notice Distributes epoch rewards to voters for `group` in the form of active votes.\n   * @param group The group whose voters will receive rewards.\n   * @param value The amount of rewards to distribute to voters for the group.\n   * @param lesser The group receiving fewer votes than `group` after the rewards are added.\n   * @param greater The group receiving more votes than `group` after the rewards are added.\n   * @dev Can only be called directly by the protocol.\n   */\n  function distributeEpochRewards(address group, uint256 value, address lesser, address greater)\n    external\n  {\n    require(msg.sender == address(0), \"Only VM can call\");\n    _distributeEpochRewards(group, value, lesser, greater);\n  }\n\n  /**\n   * @notice Distributes epoch rewards to voters for `group` in the form of active votes.\n   * @param group The group whose voters will receive rewards.\n   * @param value The amount of rewards to distribute to voters for the group.\n   * @param lesser The group receiving fewer votes than `group` after the rewards are added.\n   * @param greater The group receiving more votes than `group` after the rewards are added.\n   */\n  function _distributeEpochRewards(address group, uint256 value, address lesser, address greater)\n    internal\n  {\n    if (votes.total.eligible.contains(group)) {\n      uint256 newVoteTotal = votes.total.eligible.getValue(group).add(value);\n      votes.total.eligible.update(group, newVoteTotal, lesser, greater);\n    }\n\n    votes.active.forGroup[group].total = votes.active.forGroup[group].total.add(value);\n    votes.active.total = votes.active.total.add(value);\n    emit EpochRewardsDistributedToVoters(group, value);\n  }\n\n  /**\n   * @notice Increments the number of total votes for `group` by `value`.\n   * @param group The validator group whose vote total should be incremented.\n   * @param value The number of votes to increment.\n   * @param lesser The group receiving fewer votes than the group for which the vote was cast,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was cast,\n   *   or 0 if that group has the most votes of any validator group.\n   */\n  function incrementTotalVotes(address group, uint256 value, address lesser, address greater)\n    private\n  {\n    uint256 newVoteTotal = votes.total.eligible.getValue(group).add(value);\n    votes.total.eligible.update(group, newVoteTotal, lesser, greater);\n  }\n\n  /**\n   * @notice Decrements the number of total votes for `group` by `value`.\n   * @param group The validator group whose vote total should be decremented.\n   * @param value The number of votes to decrement.\n   * @param lesser The group receiving fewer votes than the group for which the vote was revoked,\n   *   or 0 if that group has the fewest votes of any validator group.\n   * @param greater The group receiving more votes than the group for which the vote was revoked,\n   *   or 0 if that group has the most votes of any validator group.\n   */\n  function decrementTotalVotes(address group, uint256 value, address lesser, address greater)\n    private\n  {\n    if (votes.total.eligible.contains(group)) {\n      uint256 newVoteTotal = votes.total.eligible.getValue(group).sub(value);\n      votes.total.eligible.update(group, newVoteTotal, lesser, greater);\n    }\n  }\n\n  /**\n   * @notice Marks a group ineligible for electing validators.\n   * @param group The address of the validator group.\n   * @dev Can only be called by the registered \"Validators\" contract.\n   */\n  function markGroupIneligible(address group)\n    external\n    onlyRegisteredContract(VALIDATORS_REGISTRY_ID)\n  {\n    votes.total.eligible.remove(group);\n    emit ValidatorGroupMarkedIneligible(group);\n  }\n\n  /**\n   * @notice Marks a group eligible for electing validators.\n   * @param group The address of the validator group.\n   * @param lesser The address of the group that has received fewer votes than this group.\n   * @param greater The address of the group that has received more votes than this group.\n   */\n  function markGroupEligible(address group, address lesser, address greater)\n    external\n    onlyRegisteredContract(VALIDATORS_REGISTRY_ID)\n  {\n    uint256 value = getTotalVotesForGroup(group);\n    votes.total.eligible.insert(group, value, lesser, greater);\n    emit ValidatorGroupMarkedEligible(group);\n  }\n\n  /**\n   * @notice Increments the number of pending votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @param value The number of votes.\n   */\n  function incrementPendingVotes(address group, address account, uint256 value) private {\n    PendingVotes storage pending = votes.pending;\n    pending.total = pending.total.add(value);\n\n    GroupPendingVotes storage groupPending = pending.forGroup[group];\n    groupPending.total = groupPending.total.add(value);\n\n    PendingVote storage pendingVote = groupPending.byAccount[account];\n    pendingVote.value = pendingVote.value.add(value);\n    pendingVote.epoch = getEpochNumber();\n  }\n\n  /**\n   * @notice Decrements the number of pending votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @param value The number of votes.\n   */\n  function decrementPendingVotes(address group, address account, uint256 value) private {\n    PendingVotes storage pending = votes.pending;\n    pending.total = pending.total.sub(value);\n\n    GroupPendingVotes storage groupPending = pending.forGroup[group];\n    groupPending.total = groupPending.total.sub(value);\n\n    PendingVote storage pendingVote = groupPending.byAccount[account];\n    pendingVote.value = pendingVote.value.sub(value);\n    if (pendingVote.value == 0) {\n      pendingVote.epoch = 0;\n    }\n  }\n\n  /**\n   * @notice Increments the number of active votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @param value The number of votes.\n   */\n  function incrementActiveVotes(address group, address account, uint256 value) private {\n    ActiveVotes storage active = votes.active;\n    active.total = active.total.add(value);\n\n    uint256 unitsDelta = getActiveVotesUnitsDelta(group, value);\n\n    GroupActiveVotes storage groupActive = active.forGroup[group];\n    groupActive.total = groupActive.total.add(value);\n\n    groupActive.totalUnits = groupActive.totalUnits.add(unitsDelta);\n    groupActive.unitsByAccount[account] = groupActive.unitsByAccount[account].add(unitsDelta);\n  }\n\n  /**\n   * @notice Decrements the number of active votes for `group` made by `account`.\n   * @param group The address of the validator group.\n   * @param account The address of the voting account.\n   * @param value The number of votes.\n   */\n  function decrementActiveVotes(address group, address account, uint256 value) private {\n    ActiveVotes storage active = votes.active;\n    active.total = active.total.sub(value);\n\n    uint256 unitsDelta = getActiveVotesUnitsDelta(group, value);\n\n    GroupActiveVotes storage groupActive = active.forGroup[group];\n    groupActive.total = groupActive.total.sub(value);\n\n    groupActive.totalUnits = groupActive.totalUnits.sub(unitsDelta);\n    groupActive.unitsByAccount[account] = groupActive.unitsByAccount[account].sub(unitsDelta);\n  }\n\n  /**\n   * @notice Returns the delta in active vote denominator for `group`.\n   * @param group The address of the validator group.\n   * @param value The number of active votes being added.\n   * @return The delta in active vote denominator for `group`.\n   * @dev Preserves unitsDelta / totalUnits = value / total\n   */\n  function getActiveVotesUnitsDelta(address group, uint256 value) private view returns (uint256) {\n    if (votes.active.forGroup[group].total == 0) {\n      return value;\n    } else {\n      return\n        value.mul(votes.active.forGroup[group].totalUnits).div(votes.active.forGroup[group].total);\n    }\n  }\n\n  /**\n   * @notice Returns the groups that `account` has voted for.\n   * @param account The address of the account casting votes.\n   * @return The groups that `account` has voted for.\n   */\n  function getGroupsVotedForByAccount(address account) external view returns (address[] memory) {\n    return votes.groupsVotedFor[account];\n  }\n\n  /**\n   * @notice Deletes an element from a list of addresses.\n   * @param list The list of addresses.\n   * @param element The address to delete.\n   * @param index The index of `element` in the list.\n   */\n  function deleteElement(address[] storage list, address element, uint256 index) private {\n    // TODO(asa): Move this to a library to be shared.\n    require(index < list.length && list[index] == element, \"Bad index\");\n    uint256 lastIndex = list.length.sub(1);\n    list[index] = list[lastIndex];\n    list.length = lastIndex;\n  }\n\n  /**\n   * @notice Returns whether or not a group can receive the specified number of votes.\n   * @param group The address of the group.\n   * @param value The number of votes.\n   * @return Whether or not a group can receive the specified number of votes.\n   * @dev Votes are not allowed to be cast that would increase a group's proportion of locked gold\n   *   voting for it to greater than\n   *   (numGroupMembers + 1) / min(maxElectableValidators, numRegisteredValidators)\n   * @dev Note that groups may still receive additional votes via rewards even if this function\n   *   returns false.\n   */\n  function canReceiveVotes(address group, uint256 value) public view returns (bool) {\n    uint256 totalVotesForGroup = getTotalVotesForGroup(group).add(value);\n    uint256 left = totalVotesForGroup.mul(\n      Math.min(electableValidators.max, getValidators().getNumRegisteredValidators())\n    );\n    uint256 right = getValidators().getGroupNumMembers(group).add(1).mul(\n      getLockedGold().getTotalLockedGold()\n    );\n    return left <= right;\n  }\n\n  /**\n   * @notice Returns the number of votes that a group can receive.\n   * @param group The address of the group.\n   * @return The number of votes that a group can receive.\n   * @dev Votes are not allowed to be cast that would increase a group's proportion of locked gold\n   *   voting for it to greater than\n   *   (numGroupMembers + 1) / min(maxElectableValidators, numRegisteredValidators)\n   * @dev Note that a group's vote total may exceed this number through rewards or config changes.\n   */\n  function getNumVotesReceivable(address group) external view returns (uint256) {\n    uint256 numerator = getValidators().getGroupNumMembers(group).add(1).mul(\n      getLockedGold().getTotalLockedGold()\n    );\n    uint256 denominator = Math.min(\n      electableValidators.max,\n      getValidators().getNumRegisteredValidators()\n    );\n    return numerator.div(denominator);\n  }\n\n  /**\n   * @notice Returns the total votes received across all groups.\n   * @return The total votes received across all groups.\n   */\n  function getTotalVotes() public view returns (uint256) {\n    return votes.active.total.add(votes.pending.total);\n  }\n\n  /**\n   * @notice Returns the active votes received across all groups.\n   * @return The active votes received across all groups.\n   */\n  function getActiveVotes() public view returns (uint256) {\n    return votes.active.total;\n  }\n\n  /**\n   * @notice Returns the list of validator groups eligible to elect validators.\n   * @return The list of validator groups eligible to elect validators.\n   */\n  function getEligibleValidatorGroups() external view returns (address[] memory) {\n    return votes.total.eligible.getKeys();\n  }\n\n  /**\n   * @notice Returns lists of all validator groups and the number of votes they've received.\n   * @return Lists of all validator groups and the number of votes they've received.\n   */\n  function getTotalVotesForEligibleValidatorGroups()\n    external\n    view\n    returns (address[] memory groups, uint256[] memory values)\n  {\n    return votes.total.eligible.getElements();\n  }\n\n  /**\n   * @notice Returns a list of elected validators wit"
    }
  ]
}