{
  "Title": "[L14] Casting between types without overflow checks",
  "Content": "Throughout the codebase, there are instances of larger `uint` types being cast to smaller `uint` types without overflow checks. For example:\n\n\n* In both the [`RibbonThetaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L238) and the [`RibbonDeltaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L250), the sum of `delay` and `block.timestamp` is cast to a `uint32`. Even with a small `delay`, in approximately 80 years this cast will overflow.\n* In [`RibbonThetaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol) the `uint256` `lockedBalance` is [cast to a `uint104`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L269) without checking if it can fit.\n* In [`RibbonVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol), the `unit256` `balanceOf` an IERC20 `asset` is [cast it to a `uint104`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L144-L145) without checking that it can fit.\n* In [`RibbonVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol), the `uint128` `vaultState.totalPending` is cast to a `uint256`. Then the `uint256` `amount`, is added to it. The [sum is cast to a `uint128`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L298) without checking that it can fit.\n* In [`RibbonVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol), the `uint128` `vaultState.queuedWithdrawShares` is cast to a `uint256`. Then the `uint128` `shares`, is added to it. The [sum is cast to a `uint128`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L343) without checking that it can fit.\n\n\nTo ensure that type casts cannot corrupt values and lead to undesirable system behavior, consider using the [OpenZeppelin `SafeCast` library](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) for casting operations where possible.\n\n\n**Update**: *Fixed in [commit `ca15ff53c62d9f86de417e1060ba778939fe6892` of PR#103](https://github.com/ribbon-finance/ribbon-v2/pull/103/commits/ca15ff53c62d9f86de417e1060ba778939fe6892). Although the Ribbon Finance team did not use the recommended OpenZeppelin library, they did add overflow checks for the instances identified above*.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/RibbonThetaVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../libraries/GnosisAuction.sol\";\nimport {OptionsThetaVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\n\ncontract RibbonThetaVault is RibbonVault, OptionsThetaVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    // oTokenFactory is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable OTOKEN_FACTORY;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address manager\n    );\n\n    event NewOptionStrikeSelected(uint256 strikePrice, uint256 delta);\n\n    event PremiumDiscountSet(\n        uint256 premiumDiscount,\n        uint256 newPremiumDiscount\n    );\n\n    event AuctionDurationSet(\n        uint256 auctionDuration,\n        uint256 newAuctionDuration\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint16 round\n    );\n\n    event InitiateGnosisAuction(\n        address auctioningToken,\n        address biddingToken,\n        uint256 auctionCounter,\n        address manager\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _oTokenFactory is the contract address for minting new opyn option types (strikes, asset, expiry)\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction\n        )\n    {\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        OTOKEN_FACTORY = _oTokenFactory;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        address _optionsPremiumPricer,\n        address _strikeSelection,\n        uint32 _premiumDiscount,\n        uint256 _auctionDuration,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n        require(_optionsPremiumPricer != address(0), \"!_optionsPremiumPricer\");\n        require(_strikeSelection != address(0), \"!_strikeSelection\");\n        require(\n            _premiumDiscount > 0 && _premiumDiscount < 1000,\n            \"!_premiumDiscount\"\n        );\n        require(_auctionDuration >= 1 hours, \"!_auctionDuration\");\n        optionsPremiumPricer = _optionsPremiumPricer;\n        strikeSelection = _strikeSelection;\n        premiumDiscount = _premiumDiscount;\n        auctionDuration = _auctionDuration;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new discount on premiums for options we are selling\n     * @param newPremiumDiscount is the premium discount\n     */\n    function setPremiumDiscount(uint16 newPremiumDiscount) external onlyOwner {\n        require(\n            newPremiumDiscount > 0 && newPremiumDiscount < 1000,\n            \"Invalid discount\"\n        );\n\n        emit PremiumDiscountSet(premiumDiscount, newPremiumDiscount);\n\n        premiumDiscount = newPremiumDiscount;\n    }\n\n    /**\n     * @notice Sets the new auction duration\n     * @param newAuctionDuration is the auction duration\n     */\n    function setAuctionDuration(uint256 newAuctionDuration) external onlyOwner {\n        require(newAuctionDuration >= 1 hours, \"Invalid auction duration\");\n\n        emit AuctionDurationSet(auctionDuration, newAuctionDuration);\n\n        auctionDuration = newAuctionDuration;\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint16 currentRound = vaultState.round;\n        require(amount > 0, \"!amount\");\n        require(depositReceipt.round == currentRound, \"Invalid round\");\n\n        uint104 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"Exceed amount\");\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = uint104(uint256(receiptAmount).sub(amount));\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).sub(amount)\n        );\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        transferAsset(msg.sender, amount);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external onlyOwner nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        VaultLifecycle.CloseParams memory closeParams =\n            VaultLifecycle.CloseParams({\n                OTOKEN_FACTORY: OTOKEN_FACTORY,\n                USDC: USDC,\n                currentOption: oldOption,\n                delay: delay,\n                lastStrikeOverride: lastStrikeOverride,\n                overriddenStrikePrice: overriddenStrikePrice\n            });\n\n        (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        ) =\n            VaultLifecycle.commitAndClose(\n                strikeSelection,\n                optionsPremiumPricer,\n                premiumDiscount,\n                closeParams,\n                vaultParams,\n                vaultState\n            );\n\n        emit NewOptionStrikeSelected(strikePrice, delta);\n\n        ShareMath.assertUint104(premium);\n        currentOtokenPremium = uint104(premium);\n        optionState.nextOption = otokenAddress;\n        optionState.nextOptionReadyAt = uint32(block.timestamp.add(delay));\n\n        _closeShort(oldOption);\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort(address oldOption) private {\n        optionState.currentOption = address(0);\n\n        uint104 lockedAmount = vaultState.lockedAmount;\n        vaultState.lastLockedAmount = lockedAmount > 0\n            ? lockedAmount\n            : vaultState.lastLockedAmount;\n\n        vaultState.lockedAmount = 0;\n\n        if (oldOption != address(0)) {\n            uint256 withdrawAmount =\n                VaultLifecycle.settleShort(GAMMA_CONTROLLER);\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external nonReentrant {\n        (address newOption, uint256 lockedBalance) = _rollToNextOption();\n\n        vaultState.lockedAmount = uint104(lockedBalance);\n\n        emit OpenShort(newOption, lockedBalance, msg.sender);\n\n        VaultLifecycle.createShort(\n            GAMMA_CONTROLLER,\n            MARGIN_POOL,\n            newOption,\n            lockedBalance\n        );\n\n        startAuction();\n    }\n\n    /**\n     * @notice Initiate the gnosis auction.\n     */\n    function startAuction() public onlyOwner {\n        GnosisAuction.AuctionDetails memory auctionDetails;\n\n        uint256 currOtokenPremium = currentOtokenPremium;\n\n        require(currOtokenPremium > 0, \"!currentOtokenPremium\");\n\n        auctionDetails.oTokenAddress = optionState.currentOption;\n        auctionDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        auctionDetails.asset = vaultParams.asset;\n        auctionDetails.assetDecimals = vaultParams.decimals;\n        auctionDetails.oTokenPremium = currOtokenPremium;\n        auctionDetails.duration = auctionDuration;\n\n        optionAuctionID = VaultLifecycle.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from gnosis auction.\n     */\n    function burnRemainingOTokens() external onlyOwner nonReentrant {\n        uint256 numOTokensToBurn =\n            IERC20(optionState.currentOption).balanceOf(address(this));\n        require(numOTokensToBurn > 0, \"!otokens\");\n        uint256 unlockedAssedAmount =\n            VaultLifecycle.burnOtokens(GAMMA_CONTROLLER, numOTokensToBurn);\n        vaultState.lockedAmount = uint104(\n            uint256(vaultState.lockedAmount).sub(unlockedAssedAmount)\n        );\n    }\n\n    /**\n     * @notice Optionality to set strike price manually\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(strikePrice > 0, \"!strikePrice\");\n        overriddenStrikePrice = strikePrice;\n        lastStrikeOverride = vaultState.round;\n    }\n}"
    }
  ]
}