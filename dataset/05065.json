{
  "Title": "[05] Use modifier `onlyHostChain`",
  "Content": "\nIn `TapToken` there is a modifier `onlyHostChain` to check that the operation is done on the `governanceEid`-chain. This is used in the call `setTwTAP`.\n\nIt is, however, not used in the call [`TapToken::emitForWeek`](https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/tokens/TapToken.sol#L385):\n\n```solidity\nFile: tap-token/contracts/tokens/TapToken.sol\n\n385:        if (_getChainId() != governanceEid) revert NotValid();\n```\n\nConsider using the modifier `onlyHostChain` there as well.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/tokens/TapToken.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//LZ\nimport {IMessagingChannel} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\";\nimport {MessagingReceipt, OFTReceipt} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OAppReceiver} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\n\n// External\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n// Tapioca\nimport {BaseTapiocaOmnichainEngine} from \"tapioca-periph/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainSender} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol\";\nimport {ERC20PermitStruct, ITapToken, LZSendParam} from \"tap-token/tokens/ITapToken.sol\";\nimport {ModuleManager} from \"./module/ModuleManager.sol\";\nimport {TapTokenReceiver} from \"./TapTokenReceiver.sol\";\nimport {TwTAP} from \"tap-token/governance/twTAP.sol\";\nimport {TapTokenSender} from \"./TapTokenSender.sol\";\nimport {BaseTapToken} from \"./BaseTapToken.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/// @title Tapioca OFTv2 token\n/// @notice OFT compatible TAP token\n/// @dev Emissions E(x)= E(x-1) - E(x-1) * D with E being total supply a x week, and D the initial decay rate\ncontract TapToken is BaseTapToken, ModuleManager, ERC20Permit, Pausable {\n    uint256 public constant INITIAL_SUPPLY = 46_686_595 * 1e18; // Everything minus DSO\n    uint256 public dso_supply = 53_313_405 * 1e18; // Emission supply for DSO\n\n    /// @notice the a parameter used in the emission function;\n    uint256 constant decay_rate = 8800000000000000; // 0.88%\n    uint256 constant DECAY_RATE_DECIMAL = 1e18;\n\n    /// @notice seconds in a week\n    uint256 public constant EPOCH_DURATION = 1 weeks; // 604800\n\n    /// @notice starts time for emissions\n    /// @dev initialized in the constructor with block.timestamp\n    uint256 public immutable emissionsStartTime;\n\n    /// @notice returns the amount of emitted TAP for a specific week\n    /// @dev week is computed using (timestamp - emissionStartTime) / WEEK\n    mapping(uint256 => uint256) public emissionForWeek;\n\n    /// @notice returns the amount minted for a specific week\n    /// @dev week is computed using (timestamp - emissionStartTime) / WEEK\n    mapping(uint256 => uint256) public mintedInWeek;\n\n    /// @notice returns the minter address\n    address public minter;\n\n    /// @notice LayerZero governance chain identifier\n    uint256 public governanceEid;\n\n    // ==========\n    // *EVENTS*\n    // ==========\n    /// @notice event emitted when a new minter is set\n    event MinterUpdated(address _old, address _new);\n    /// @notice event emitted when a new emission is called\n    event Emitted(uint256 indexed week, uint256 amount);\n    /// @notice event emitted when new TAP is minted\n    event Minted(address indexed _by, address indexed _to, uint256 _amount);\n    /// @notice event emitted when new TAP is burned\n    event Burned(address indexed _from, uint256 _amount);\n\n    event BoostedTAP(uint256 _amount);\n\n    error OnlyHostChain();\n\n    // ==========\n    // *ERRORS*\n    // ==========\n    error NotValid(); // Generic error for simple functions\n    error AddressWrong();\n    error SupplyNotValid(); // Initial supply is not valid\n    error AllowanceNotValid();\n    error OnlyMinter();\n    error TwTapAlreadySet();\n    error InsufficientEmissions();\n\n    // ===========\n    // *MODIFIERS*\n    // ===========\n    modifier onlyMinter() {\n        if (msg.sender != minter) revert OnlyMinter();\n        _;\n    }\n\n    modifier onlyHostChain() {\n        if (_getChainId() != governanceEid) revert OnlyHostChain();\n        _;\n    }\n\n    /**\n     * @notice Creates a new TAP OFT type token\n     * @dev The initial supply of 100M is not minted here as we have the wrap method\n     *\n     * Allocation:\n     * ============\n     * DSO: 53,313,405\n     * DAO: 8m\n     * Contributors: 15m\n     * Early supporters: 3,686,595\n     * Supporters: 12.5m\n     * LBP: 5m\n     * Airdrop: 2.5m\n     * == 100M ==\n     *\n     * @param _data.endpoint The layer zero address endpoint deployed on the current chain.\n     * @param _data.contributors Address of the  contributors. 15m TAP.\n     * @param _data.earlySupporters Address of early supporters. 3,686,595 TAP.\n     * @param _data.supporters Address of supporters. 12.5m TAP.\n     * @param _data.aoTap Address of the LBP redemption token, aoTap. 5m TAP.\n     * @param _data.dao Address of the DAO. 8m TAP.\n     * @param _data.airdrop Address of the airdrop contract. 2.5m TAP.\n     * @param _data.governanceEid Governance chain endpoint ID. Should be EID of the twTAP chain.\n     * @param _data.owner Address of the conservator/owner.\n     * @param _data.tapTokenSenderModule Address of the TapTokenSenderModule.\n     * @param _data.tapTokenReceiverModule Address of the TapTokenReceiverModule.\n     * @param _data.extExec Address of the external executor.\n     */\n    constructor(ITapToken.TapTokenConstructorData memory _data)\n        BaseTapToken(\"TapToken\", \"TAP\", _data.endpoint, _data.owner, _data.extExec, _data.pearlmit)\n        ERC20Permit(\"TAP\")\n    {\n        _transferOwnership(_data.owner);\n\n        if (_data.endpoint == address(0)) revert AddressWrong();\n        governanceEid = _data.governanceEid;\n\n        // Mint only on the governance chain\n        if (_getChainId() == _data.governanceEid) {\n            _mint(_data.contributors, 1e18 * 15_000_000);\n            _mint(_data.earlySupporters, 1e18 * 3_686_595);\n            _mint(_data.supporters, 1e18 * 12_500_000);\n            _mint(_data.aoTap, 1e18 * 5_000_000);\n            _mint(_data.dao, 1e18 * 8_000_000);\n            _mint(_data.airdrop, 1e18 * 2_500_000);\n            if (totalSupply() != INITIAL_SUPPLY) revert SupplyNotValid();\n        }\n        emissionsStartTime = block.timestamp;\n\n        // Initialize modules\n        if (_data.tapTokenSenderModule == address(0)) revert NotValid();\n        if (_data.tapTokenReceiverModule == address(0)) revert NotValid();\n\n        _setModule(uint8(ITapToken.Module.TapTokenSender), _data.tapTokenSenderModule);\n        _setModule(uint8(ITapToken.Module.TapTokenReceiver), _data.tapTokenReceiverModule);\n    }\n\n    /**\n     * @inheritdoc BaseTapiocaOmnichainEngine\n     */\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override(BaseTapiocaOmnichainEngine, ERC20)\n        returns (bool)\n    {\n        return BaseTapiocaOmnichainEngine.transferFrom(from, to, value);\n    }\n\n    /// =====================\n    /// Module setup\n    /// =====================\n\n    /**\n     * @dev Fallback function should handle calls made by endpoint, which should go to the receiver module.\n     */\n    fallback() external payable {\n        /// @dev Call the receiver module on fallback, assume it's gonna be called by endpoint.\n        _executeModule(uint8(ITapToken.Module.TapTokenReceiver), msg.data, false);\n    }\n\n    receive() external payable {}\n\n    /**\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, // @dev unused in the default implementation.\n        bytes calldata _extraData // @dev unused in the default implementation.\n    ) public payable override {\n        // Call the internal OApp implementation of lzReceive.\n        _executeModule(\n            uint8(ITapToken.Module.TapTokenReceiver),\n            abi.encodeWithSelector(OAppReceiver.lzReceive.selector, _origin, _guid, _message, _executor, _extraData),\n            false\n        );\n    }\n\n    /**\n     * @notice Execute a call to a module.\n     * @dev Example on how `_data` should be encoded:\n     *      - abi.encodeCall(IERC20.transfer, (to, amount));\n     * @dev Use abi.encodeCall to encode the function call and its parameters with type safety.\n     *\n     * @param _module The module to execute.\n     * @param _data The data to execute. Should be ABI encoded with the selector.\n     * @param _forwardRevert If true, forward the revert message from the module.\n     *\n     * @return returnData The return data from the module execution, if any.\n     */\n    function executeModule(ITapToken.Module _module, bytes memory _data, bool _forwardRevert)\n        external\n        payable\n        returns (bytes memory returnData)\n    {\n        return _executeModule(uint8(_module), _data, _forwardRevert);\n    }\n\n    /// ========================\n    /// Frequently used modules\n    /// ========================\n\n    /**\n     * @dev Slightly modified version of the OFT send() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @dev Executes the send operation.\n     * @param _lzSendParam The parameters for the send operation.\n     *      - _sendParam: The parameters for the send operation.\n     *          - dstEid::uint32: Destination endpoint ID.\n     *          - to::bytes32: Recipient address.\n     *          - amountToSendLD::uint256: Amount to send in local decimals.\n     *          - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     *      - _fee: The calculated fee for the send() operation.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     *      - _extraOptions::bytes: Additional options for the send() operation.\n     *      - refundAddress::address: The address to refund the native fee to.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     *\n     * @return msgReceipt The receipt for the send operation.\n     *      - guid::bytes32: The unique identifier for the sent message.\n     *      - nonce::uint64: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     * @return oftReceipt The OFT receipt information.\n     *      - amountDebitLD::uint256: Amount of tokens ACTUALLY debited in local decimals.\n     *      - amountCreditLD::uint256: Amount of tokens to be credited on the remote side.\n     */\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        public\n        payable\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        (msgReceipt, oftReceipt) = abi.decode(\n            _executeModule(\n                uint8(ITapToken.Module.TapTokenSender),\n                abi.encodeCall(TapiocaOmnichainSender.sendPacket, (_lzSendParam, _composeMsg)),\n                false\n            ),\n            (MessagingReceipt, OFTReceipt)\n        );\n    }\n\n    /// =====================\n    /// View\n    /// =====================\n\n    /**\n     * @notice returns token's decimals\n     */\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @notice Returns the current week\n     */\n    function getCurrentWeek() external view returns (uint256) {\n        return _timestampToWeek(block.timestamp);\n    }\n\n    /**\n     * @notice Returns the current week emission\n     */\n    function getCurrentWeekEmission() external view returns (uint256) {\n        return emissionForWeek[_timestampToWeek(block.timestamp)];\n    }\n\n    /**\n     * @notice Returns the current week given a timestamp\n     * @param timestamp The timestamp to use to compute the week\n     */\n    function timestampToWeek(uint256 timestamp) external view returns (uint256) {\n        if (timestamp == 0) {\n            timestamp = block.timestamp;\n        }\n        if (timestamp < emissionsStartTime) return 0;\n\n        return _timestampToWeek(timestamp);\n    }\n\n    /**\n     * @dev Returns the hash of the struct used by the permit function.\n     * @param _permitData Struct containing permit data.\n     */\n    function getTypedDataHash(ERC20PermitStruct calldata _permitData) public view returns (bytes32) {\n        bytes32 permitTypeHash_ =\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n        bytes32 structHash_ = keccak256(\n            abi.encode(\n                permitTypeHash_,\n                _permitData.owner,\n                _permitData.spender,\n                _permitData.value,\n                _permitData.nonce,\n                _permitData.deadline\n            )\n        );\n        return _hashTypedDataV4(structHash_);\n    }\n\n    /// =====================\n    /// External\n    /// =====================\n\n    /**\n     * @notice Mint TAP for the current week. Follow the emission function.\n     *\n     * @param _to Address to send the minted TAP to\n     * @param _amount TAP amount\n     */\n    function extractTAP(address _to, uint256 _amount) external onlyMinter whenNotPaused {\n        if (_amount == 0) revert NotValid();\n\n        uint256 week = _timestampToWeek(block.timestamp);\n        if (emissionForWeek[week] < mintedInWeek[week] + _amount) {\n            revert InsufficientEmissions();\n        }\n        _mint(_to, _amount);\n        mintedInWeek[week] += _amount;\n        emit Minted(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice Burns TAP.\n     * @param _amount TAP amount.\n     */\n    function removeTAP(uint256 _amount) external whenNotPaused {\n        _burn(msg.sender, _amount);\n        emit Burned(msg.sender, _amount);\n    }\n\n    /// =====================\n    /// Minter\n    /// =====================\n\n    /**\n     * @notice Emit the TAP for the current week. Follow the emission function.\n     * If there are unclaimed emissions from the previous week, they are added to the current week.\n     * If there are some TAP in the contract, use it as boosted TAP.\n     *\n     * @return the emitted amount.\n     */\n    function emitForWeek() external onlyMinter returns (uint256) {\n        if (_getChainId() != governanceEid) revert NotValid();\n\n        uint256 week = _timestampToWeek(block.timestamp);\n        if (emissionForWeek[week] > 0) return 0;\n\n        // Compute unclaimed emission from last week and add it to the current week emission\n        uint256 unclaimed;\n        if (week > 0) {\n            // Update DSO supply from last minted emissions\n            dso_supply -= mintedInWeek[week - 1];\n\n            // Push unclaimed emission from last week to the current week\n            unclaimed = emissionForWeek[week - 1] - mintedInWeek[week - 1];\n        }\n        uint256 emission = _computeEmission();\n        emission += unclaimed;\n\n        // Boosted TAP is burned and added to the emission to be minted on demand later on in `extractTAP()`\n        uint256 boostedTAP = balanceOf(address(this));\n        if (boostedTAP > 0) {\n            _burn(address(this), boostedTAP);\n            emission += boostedTAP; // Add TAP in the contract as boosted TAP\n            emit BoostedTAP(boostedTAP);\n        }\n\n        emissionForWeek[week] = emission;\n        emit Emitted(week, emission);\n\n        return emission;\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice Sets a new minter address.\n     * @param _minter the new address\n     */\n    function setMinter(address _minter) external onlyOwner {\n        if (_minter == address(0)) revert NotValid();\n        minter = _minter;\n        emit MinterUpdated(minter, _minter);\n    }\n\n    /**\n     * @notice set the twTAP address, can be done only once.\n     */\n    function setTwTAP(address _twTap) external override onlyOwner onlyHostChain {\n        if (address(twTap) != address(0)) {\n            revert TwTapAlreadySet();\n        }\n        twTap = TwTAP(_twTap);\n    }\n\n    /**\n     * @notice Un/Pauses this contract.\n     */\n    function setPause(bool _pauseState) external onlyOwner {\n        if (_pauseState) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// =====================\n    /// Internal\n    /// =====================\n\n    /**\n     * @dev Returns the current week given a timestamp\n     * @param timestamp The timestamp to use to compute the week\n     */\n    function _timestampToWeek(uint256 timestamp) internal view returns (uint256) {\n        return ((timestamp - emissionsStartTime) / EPOCH_DURATION);\n    }\n\n    /**\n     *  @notice returns the available emissions for a given supply\n     */\n    function _computeEmission() internal view returns (uint256 result) {\n        result = (dso_supply * decay_rate) / DECAY_RATE_DECIMAL;\n    }\n\n    /**\n     * @notice Return the current chain EID.\n     */\n    function _getChainId() internal view override returns (uint32) {\n        return IMessagingChannel(endpoint).eid();\n    }\n}"
    }
  ]
}