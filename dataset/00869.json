{
  "Title": "M-5: SdtRewardReceiver#_withdrawRewards has incorrect slippage protection and withdraws can be sandwiched",
  "Content": "# Issue M-5: SdtRewardReceiver#_withdrawRewards has incorrect slippage protection and withdraws can be sandwiched \n\nSource: https://github.com/sherlock-audit/2023-11-convergence-judging/issues/180 \n\n## Found by \n0x52, 0xkaden, Bauer, CL001, FarmerRick, caventa, cducrest-brainbot, detectiveking, hash, lemonmon, r0ck3tz\n## Summary\n\nThe _min_dy parameter of poolCvgSDT.exchange is set via the poolCvgSDT.get_dy method. The problem with this is that get_dy is a relative output that is executed at runtime. This means that no matter the state of the pool, this slippage check will never work.\n\n## Vulnerability Detail\n\n[SdtRewardReceiver.sol#L229-L236](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtRewardReceiver.sol#L229-L236)\n\n            if (isMint) {\n                /// @dev Mint cvgSdt 1:1 via CvgToke contract\n                cvgSdt.mint(receiver, rewardAmount);\n            } else {\n                ICrvPoolPlain _poolCvgSDT = poolCvgSDT;\n                /// @dev Only swap if the returned amount in CvgSdt is gretear than the amount rewarded in SDT\n                _poolCvgSDT.exchange(0, 1, rewardAmount, _poolCvgSDT.get_dy(0, 1, rewardAmount), receiver);\n            }\n\nWhen swapping from SDT to cvgSDT, get_dy is used to set _min_dy inside exchange. The issue is that get_dy is the CURRENT amount that would be received when swapping as shown below:\n\n    @view\n    @external\n    def get_dy(i: int128, j: int128, dx: uint256) -> uint256:\n        \"\"\"\n        @notice Calculate the current output dy given input dx\n        @dev Index values can be found via the `coins` public getter method\n        @param i Index value for the coin to send\n        @param j Index valie of the coin to recieve\n        @param dx Amount of `i` being exchanged\n        @return Amount of `j` predicted\n        \"\"\"\n        rates: uint256[N_COINS] = self.rate_multipliers\n        xp: uint256[N_COINS] = self._xp_mem(rates, self.balances)\n    \n        x: uint256 = xp[i] + (dx * rates[i] / PRECISION)\n        y: uint256 = self.get_y(i, j, x, xp, 0, 0)\n        dy: uint256 = xp[j] - y - 1\n        fee: uint256 = self.fee * dy / FEE_DENOMINATOR\n        return (dy - fee) * PRECISION / rates[j]\n\nThe return value is EXACTLY the result of a regular swap, which is where the problem is. There is no way that the exchange call can ever revert. Assume the user is swapping because the current exchange ratio is 1:1.5. Now assume their withdraw is sandwich attacked. The ratio is change to 1:0.5 which is much lower than expected. When get_dy is called it will simulate the swap and return a ratio of 1:0.5. This in turn doesn't protect the user at all and their swap will execute at the poor price.\n\n## Impact\n\nSDT rewards will be sandwiched and can lose the entire balance\n\n## Code Snippet\n\n[SdtRewardReceiver.sol#L213-L245](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtRewardReceiver.sol#L213-L245)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow the user to set _min_dy directly so they can guarantee they get the amount they want\n\n\n\n## Discussion\n\n**shalbe-cvg**\n\nHello,\n\nThanks a lot for your attention.\n\nAfter an in-depth review, we have to consider your issue as Confirmed.\nNot only users can get sandwiched but in most cases this exchange directly on the pool level would rarely succeed as `get_dy` returns the exact amount the user could get. We will add a slippage that users will setup.\n\nRegards,\nConvergence Team\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/126",
  "Code": [
    {
      "filename": "sherlock-cvg/contracts/Staking/StakeDAO/SdtRewardReceiver.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\n\n/// @title  Cvg-Finance - SdtReceiver\n/// @notice Receives all StakeDAO rewards from SdtBuffer & CvgSdtBuffer.\n/// @dev Optimize gas cost on claim on several contract by limiting ERC20 transfers.\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../interfaces/ISdtStakingPositionService.sol\";\nimport \"../../interfaces/ISdtStakingPositionManager.sol\";\nimport \"../../interfaces/ISdAssets.sol\";\nimport \"../../interfaces/ICvgControlTower.sol\";\nimport \"../../interfaces/ICvg.sol\";\nimport \"../../interfaces/ICrvPoolPlain.sol\";\n\n/// @title Cvg-Finance - SdtRewardReceiver\n/// @notice Contracts receiving StakeDao rewards from SdtBuffers & CvgSdtBuffer.\n///\n/// @dev\ncontract SdtRewardReceiver is Ownable2StepUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @dev Convergence Control Tower\n    ICvgControlTower public cvgControlTower;\n\n    /// @dev StakeDao token\n    IERC20 public sdt;\n\n    /// @dev StakeDao token\n    ICvg public cvg;\n\n    /// @notice CvgSdt token contract\n    IERC20Mintable public cvgSdt;\n\n    /// @notice CvgSdt/Sdt stable pool contract on Curve\n    ICrvPoolPlain public poolCvgSDT;\n\n    ISdtStakingPositionManager public sdtStakingPositionManager;\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        INITIALIZE\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(ICvgControlTower _cvgControlTower) external initializer {\n        cvgControlTower = _cvgControlTower;\n        IERC20 _sdt = _cvgControlTower.sdt();\n        address treasuryDao = _cvgControlTower.treasuryDao();\n        ICvg _cvg = _cvgControlTower.cvgToken();\n        IERC20Mintable _cvgSdt = _cvgControlTower.cvgSDT();\n        ISdtStakingPositionManager _sdtStakingPositionManager = _cvgControlTower.sdtStakingPositionManager();\n\n        require(address(_sdt) != address(0), \"SDT_ZERO\");\n        sdt = _sdt;\n\n        require(address(_cvg) != address(0), \"CVG_ZERO\");\n        cvg = _cvg;\n\n        require(address(_cvgSdt) != address(0), \"CVG_SDT_ZERO\");\n        cvgSdt = _cvgSdt;\n\n        require(address(_sdtStakingPositionManager) != address(0), \"SDT_POSITION_MNGR_ZERO\");\n        sdtStakingPositionManager = _sdtStakingPositionManager;\n\n        require(treasuryDao != address(0), \"TREASURY_DAO_ZERO\");\n        _transferOwnership(treasuryDao);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        EXTERNALS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     * @notice Mint CVG & distribute StakeDao rewards for a receiver, owner of a Staking Position\n     * @dev    Function used when only one Staking Position is involved for a claiming.\n     * @param receiver List of contracts having a list of tokenID with a list of cycleID to claim rewards on.\n     * @param totalCvgClaimable List of contracts having a list of tokenID with a list of cycleID to claim rewards on.\n     * @param totalSdtRewardsClaimable List of contracts having a list of tokenID with a list of cycleID to claim rewards on.\n     * @param isConvert      If true, converts all SDT into CvgSDT.\n     * @param isMint         If true, mints CvgSDT 1:1, else swap into stablePool\n     */\n    function claimCvgSdtSimple(\n        address receiver,\n        uint256 totalCvgClaimable,\n        ICommonStruct.TokenAmount[] memory totalSdtRewardsClaimable,\n        bool isConvert,\n        bool isMint\n    ) external {\n        require(cvgControlTower.isStakingContract(msg.sender), \"NOT_STAKING\");\n        _withdrawRewards(receiver, totalCvgClaimable, totalSdtRewardsClaimable, isConvert, isMint);\n    }\n\n    /**\n     * @notice Claims rewards from StakeDao integration on several cycles for several tokenID on different SdtStakingPositionService.\n     *         Allows the users to claim all the rewards from the StakeDao integration in 1 Tx.\n     *         All CVG to mint are accumulated in one value.\n     *         All StakeDao rewards are merged in one array.\n     * @param claimContracts  List of contracts having a list of tokenID with a list of cycleID to claim rewards on.\n     * @param isConvert       If true, converts all SDT into CvgSDT.\n     * @param isMint          If true, mints CvgSDT 1:1, else swap into stablePool\n     * @param sdtRewardCount This parameter must be configured through the front-end.\n     */\n    function claimMultipleStaking(\n        ISdtStakingPositionManager.ClaimSdtStakingContract[] calldata claimContracts,\n        bool isConvert,\n        bool isMint,\n        uint256 sdtRewardCount\n    ) external {\n        /// @dev Checks for all positions input in data : Token ownership & verify positions are linked to the right staking service & verify timelocking\n        sdtStakingPositionManager.checkMultipleClaimCompliance(claimContracts, msg.sender);\n\n        /// @dev Accumulates amounts of CVG coming from all claims.\n        uint256 _totalCvgClaimable;\n\n        /// @dev Array merging & accumulating rewards coming from diferent claims.\n        ICommonStruct.TokenAmount[] memory _totalSdtClaimable = new ICommonStruct.TokenAmount[](sdtRewardCount);\n\n        /// @dev Iterate over all staking service\n        for (uint256 stakingIndex; stakingIndex < claimContracts.length; ) {\n            ISdtStakingPositionService sdtStaking = claimContracts[stakingIndex].stakingContract;\n            uint256 tokensLength = claimContracts[stakingIndex].tokenIds.length;\n            /// @dev Iterate over all tokens linked to the iterated cycle.\n            for (uint256 tokenIdIndex; tokenIdIndex < tokensLength; ) {\n                /** @dev Claims Cvg & Sdt\n                 *       Returns the amount of CVG claimed on the position.\n                 *       Returns the array of all SDT rewards claimed on the position.\n                 */\n                (uint256 cvgClaimable, ICommonStruct.TokenAmount[] memory _sdtRewards) = sdtStaking.claimCvgSdtMultiple(\n                    claimContracts[stakingIndex].tokenIds[tokenIdIndex],\n                    msg.sender\n                );\n                /// @dev increments the amount to mint at the end of function\n                _totalCvgClaimable += cvgClaimable;\n\n                uint256 sdtRewardsLength = _sdtRewards.length;\n                /// @dev Iterate over all SDT rewards claimed on the iterated position\n                for (uint256 positionRewardIndex; positionRewardIndex < sdtRewardsLength; ) {\n                    /// @dev Is the claimable amount is 0 on this token\n                    ///      We bypass the process to save gas\n                    if (_sdtRewards[positionRewardIndex].amount != 0) {\n                        /// @dev Iterate ower the final array to merge the iterated SdtRewards in the totalSdtClaimable\n                        for (uint256 totalRewardIndex; totalRewardIndex < sdtRewardCount; ) {\n                            address iteratedTotatClaimableToken = address(_totalSdtClaimable[totalRewardIndex].token);\n                            /// @dev If the token is not already in the totalSdtClaimable.\n                            if (iteratedTotatClaimableToken == address(0)) {\n                                /// @dev Push the token in the totalClaimable array.\n                                _totalSdtClaimable[totalRewardIndex] = ICommonStruct.TokenAmount({\n                                    token: _sdtRewards[positionRewardIndex].token,\n                                    amount: _sdtRewards[positionRewardIndex].amount\n                                });\n                                /// @dev Pass to the next token\n                                break;\n                            }\n                            /// @dev If the token is already in the totalSdtClaimable.\n                            if (iteratedTotatClaimableToken == address(_sdtRewards[positionRewardIndex].token)) {\n                                /// @dev Increments the claimable amount.\n                                _totalSdtClaimable[totalRewardIndex].amount += _sdtRewards[positionRewardIndex].amount;\n                                /// @dev Pass to the next token\n                                break;\n                            }\n\n                            /// @dev If the token is not found in the totalRewards and we are at the end of the array.\n                            ///      it means the sdtRewardCount is not properly configured.\n                            require(totalRewardIndex != sdtRewardCount - 1, \"REWARD_COUNT_TOO_SMALL\");\n\n                            unchecked {\n                                ++totalRewardIndex;\n                            }\n                        }\n                    }\n\n                    unchecked {\n                        ++positionRewardIndex;\n                    }\n                }\n\n                unchecked {\n                    ++tokenIdIndex;\n                }\n            }\n            unchecked {\n                ++stakingIndex;\n            }\n        }\n\n        _withdrawRewards(msg.sender, _totalCvgClaimable, _totalSdtClaimable, isConvert, isMint);\n    }\n\n    /** @dev Mint accumulated CVG & Transfers StakeDao rewards to the claimer of Stakings\n     *  @param receiver                 Receiver of the claim\n     *  @param totalCvgClaimable        Amount of CVG to mint to the receiver\n     *  @param totalSdtRewardsClaimable Array of all StakeDao rewards to send to the receiver\n     *  @param isConvert                If true, converts all SDT into CvgSDT.\n     *  @param isMint                   If true, mints CvgSDT 1:1, else swap into stablePool\n     *\n     */\n    function _withdrawRewards(\n        address receiver,\n        uint256 totalCvgClaimable,\n        ICommonStruct.TokenAmount[] memory totalSdtRewardsClaimable,\n        bool isConvert,\n        bool isMint\n    ) internal {\n        /// @dev Mints accumulated CVG and claim StakeDao rewards\n        IERC20 _sdt = sdt;\n        if (totalCvgClaimable > 0) {\n            cvg.mintStaking(receiver, totalCvgClaimable);\n        }\n        for (uint256 i; i < totalSdtRewardsClaimable.length; ) {\n            uint256 rewardAmount = totalSdtRewardsClaimable[i].amount;\n            if (rewardAmount > 0) {\n                if (isConvert && totalSdtRewardsClaimable[i].token == _sdt) {\n                    if (isMint) {\n                        /// @dev Mint cvgSdt 1:1 via CvgToke contract\n                        cvgSdt.mint(receiver, rewardAmount);\n                    } else {\n                        ICrvPoolPlain _poolCvgSDT = poolCvgSDT;\n                        /// @dev Only swap if the returned amount in CvgSdt is gretear than the amount rewarded in SDT\n                        _poolCvgSDT.exchange(0, 1, rewardAmount, _poolCvgSDT.get_dy(0, 1, rewardAmount), receiver);\n                    }\n                } else {\n                    totalSdtRewardsClaimable[i].token.safeTransfer(receiver, rewardAmount);\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     *  @notice Set the CvgSdt/Sdt stable pool. Approve SDT tokens to be transfered from the CvgSdt LP.\n     *  @dev    The approval has to be done to perform swaps from SDT to CvgSdt during claims.\n     *  @param _poolCvgSDT Address of the CvgSdt/Sdt stable pool to set\n     *  @param amount      Amount of SDT to approve on the Stable pool\n     */\n    function setPoolCvgSdtAndApprove(ICrvPoolPlain _poolCvgSDT, uint256 amount) external onlyOwner {\n        poolCvgSDT = _poolCvgSDT;\n        sdt.approve(address(_poolCvgSDT), amount);\n        sdt.approve(address(cvgSdt), amount);\n    }\n}"
    },
    {
      "filename": "sherlock-cvg/contracts/Staking/StakeDAO/SdtRewardReceiver.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\n\n/// @title  Cvg-Finance - SdtReceiver\n/// @notice Receives all StakeDAO rewards from SdtBuffer & CvgSdtBuffer.\n/// @dev Optimize gas cost on claim on several contract by limiting ERC20 transfers.\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../interfaces/ISdtStakingPositionService.sol\";\nimport \"../../interfaces/ISdtStakingPositionManager.sol\";\nimport \"../../interfaces/ISdAssets.sol\";\nimport \"../../interfaces/ICvgControlTower.sol\";\nimport \"../../interfaces/ICvg.sol\";\nimport \"../../interfaces/ICrvPoolPlain.sol\";\n\n/// @title Cvg-Finance - SdtRewardReceiver\n/// @notice Contracts receiving StakeDao rewards from SdtBuffers & CvgSdtBuffer.\n///\n/// @dev\ncontract SdtRewardReceiver is Ownable2StepUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @dev Convergence Control Tower\n    ICvgControlTower public cvgControlTower;\n\n    /// @dev StakeDao token\n    IERC20 public sdt;\n\n    /// @dev StakeDao token\n    ICvg public cvg;\n\n    /// @notice CvgSdt token contract\n    IERC20Mintable public cvgSdt;\n\n    /// @notice CvgSdt/Sdt stable pool contract on Curve\n    ICrvPoolPlain public poolCvgSDT;\n\n    ISdtStakingPositionManager public sdtStakingPositionManager;\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        INITIALIZE\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(ICvgControlTower _cvgControlTower) external initializer {\n        cvgControlTower = _cvgControlTower;\n        IERC20 _sdt = _cvgControlTower.sdt();\n        address treasuryDao = _cvgControlTower.treasuryDao();\n        ICvg _cvg = _cvgControlTower.cvgToken();\n        IERC20Mintable _cvgSdt = _cvgControlTower.cvgSDT();\n        ISdtStakingPositionManager _sdtStakingPositionManager = _cvgControlTower.sdtStakingPositionManager();\n\n        require(address(_sdt) != address(0), \"SDT_ZERO\");\n        sdt = _sdt;\n\n        require(address(_cvg) != address(0), \"CVG_ZERO\");\n        cvg = _cvg;\n\n        require(address(_cvgSdt) != address(0), \"CVG_SDT_ZERO\");\n        cvgSdt = _cvgSdt;\n\n        require(address(_sdtStakingPositionManager) != address(0), \"SDT_POSITION_MNGR_ZERO\");\n        sdtStakingPositionManager = _sdtStakingPositionManager;\n\n        require(treasuryDao != address(0), \"TREASURY_DAO_ZERO\");\n        _transferOwnership(treasuryDao);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        EXTERNALS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     * @notice Mint CVG & distribute StakeDao rewards for a receiver, owner of a Staking Position\n     * @dev    Function used when only one Staking Position is involved for a claiming.\n     * @param receiver List of contracts having a list of tokenID with a list of cycleID to claim rewards on.\n     * @param totalCvgClaimable List of contracts having a list of tokenID with a list of cycleID to claim rewards on.\n     * @param totalSdtRewardsClaimable List of contracts having a list of tokenID with a list of cycleID to claim rewards on.\n     * @param isConvert      If true, converts all SDT into CvgSDT.\n     * @param isMint         If true, mints CvgSDT 1:1, else swap into stablePool\n     */\n    function claimCvgSdtSimple(\n        address receiver,\n        uint256 totalCvgClaimable,\n        ICommonStruct.TokenAmount[] memory totalSdtRewardsClaimable,\n        bool isConvert,\n        bool isMint\n    ) external {\n        require(cvgControlTower.isStakingContract(msg.sender), \"NOT_STAKING\");\n        _withdrawRewards(receiver, totalCvgClaimable, totalSdtRewardsClaimable, isConvert, isMint);\n    }\n\n    /**\n     * @notice Claims rewards from StakeDao integration on several cycles for several tokenID on different SdtStakingPositionService.\n     *         Allows the users to claim all the rewards from the StakeDao integration in 1 Tx.\n     *         All CVG to mint are accumulated in one value.\n     *         All StakeDao rewards are merged in one array.\n     * @param claimContracts  List of contracts having a list of tokenID with a list of cycleID to claim rewards on.\n     * @param isConvert       If true, converts all SDT into CvgSDT.\n     * @param isMint          If true, mints CvgSDT 1:1, else swap into stablePool\n     * @param sdtRewardCount This parameter must be configured through the front-end.\n     */\n    function claimMultipleStaking(\n        ISdtStakingPositionManager.ClaimSdtStakingContract[] calldata claimContracts,\n        bool isConvert,\n        bool isMint,\n        uint256 sdtRewardCount\n    ) external {\n        /// @dev Checks for all positions input in data : Token ownership & verify positions are linked to the right staking service & verify timelocking\n        sdtStakingPositionManager.checkMultipleClaimCompliance(claimContracts, msg.sender);\n\n        /// @dev Accumulates amounts of CVG coming from all claims.\n        uint256 _totalCvgClaimable;\n\n        /// @dev Array merging & accumulating rewards coming from diferent claims.\n        ICommonStruct.TokenAmount[] memory _totalSdtClaimable = new ICommonStruct.TokenAmount[](sdtRewardCount);\n\n        /// @dev Iterate over all staking service\n        for (uint256 stakingIndex; stakingIndex < claimContracts.length; ) {\n            ISdtStakingPositionService sdtStaking = claimContracts[stakingIndex].stakingContract;\n            uint256 tokensLength = claimContracts[stakingIndex].tokenIds.length;\n            /// @dev Iterate over all tokens linked to the iterated cycle.\n            for (uint256 tokenIdIndex; tokenIdIndex < tokensLength; ) {\n                /** @dev Claims Cvg & Sdt\n                 *       Returns the amount of CVG claimed on the position.\n                 *       Returns the array of all SDT rewards claimed on the position.\n                 */\n                (uint256 cvgClaimable, ICommonStruct.TokenAmount[] memory _sdtRewards) = sdtStaking.claimCvgSdtMultiple(\n                    claimContracts[stakingIndex].tokenIds[tokenIdIndex],\n                    msg.sender\n                );\n                /// @dev increments the amount to mint at the end of function\n                _totalCvgClaimable += cvgClaimable;\n\n                uint256 sdtRewardsLength = _sdtRewards.length;\n                /// @dev Iterate over all SDT rewards claimed on the iterated position\n                for (uint256 positionRewardIndex; positionRewardIndex < sdtRewardsLength; ) {\n                    /// @dev Is the claimable amount is 0 on this token\n                    ///      We bypass the process to save gas\n                    if (_sdtRewards[positionRewardIndex].amount != 0) {\n                        /// @dev Iterate ower the final array to merge the iterated SdtRewards in the totalSdtClaimable\n                        for (uint256 totalRewardIndex; totalRewardIndex < sdtRewardCount; ) {\n                            address iteratedTotatClaimableToken = address(_totalSdtClaimable[totalRewardIndex].token);\n                            /// @dev If the token is not already in the totalSdtClaimable.\n                            if (iteratedTotatClaimableToken == address(0)) {\n                                /// @dev Push the token in the totalClaimable array.\n                                _totalSdtClaimable[totalRewardIndex] = ICommonStruct.TokenAmount({\n                                    token: _sdtRewards[positionRewardIndex].token,\n                                    amount: _sdtRewards[positionRewardIndex].amount\n                                });\n                                /// @dev Pass to the next token\n                                break;\n                            }\n                            /// @dev If the token is already in the totalSdtClaimable.\n                            if (iteratedTotatClaimableToken == address(_sdtRewards[positionRewardIndex].token)) {\n                                /// @dev Increments the claimable amount.\n                                _totalSdtClaimable[totalRewardIndex].amount += _sdtRewards[positionRewardIndex].amount;\n                                /// @dev Pass to the next token\n                                break;\n                            }\n\n                            /// @dev If the token is not found in the totalRewards and we are at the end of the array.\n                            ///      it means the sdtRewardCount is not properly configured.\n                            require(totalRewardIndex != sdtRewardCount - 1, \"REWARD_COUNT_TOO_SMALL\");\n\n                            unchecked {\n                                ++totalRewardIndex;\n                            }\n                        }\n                    }\n\n                    unchecked {\n                        ++positionRewardIndex;\n                    }\n                }\n\n                unchecked {\n                    ++tokenIdIndex;\n                }\n            }\n            unchecked {\n                ++stakingIndex;\n            }\n        }\n\n        _withdrawRewards(msg.sender, _totalCvgClaimable, _totalSdtClaimable, isConvert, isMint);\n    }\n\n    /** @dev Mint accumulated CVG & Transfers StakeDao rewards to the claimer of Stakings\n     *  @param receiver                 Receiver of the claim\n     *  @param totalCvgClaimable        Amount of CVG to mint to the receiver\n     *  @param totalSdtRewardsClaimable Array of all StakeDao rewards to send to the receiver\n     *  @param isConvert                If true, converts all SDT into CvgSDT.\n     *  @param isMint                   If true, mints CvgSDT 1:1, else swap into stablePool\n     *\n     */\n    function _withdrawRewards(\n        address receiver,\n        uint256 totalCvgClaimable,\n        ICommonStruct.TokenAmount[] memory totalSdtRewardsClaimable,\n        bool isConvert,\n        bool isMint\n    ) internal {\n        /// @dev Mints accumulated CVG and claim StakeDao rewards\n        IERC20 _sdt = sdt;\n        if (totalCvgClaimable > 0) {\n            cvg.mintStaking(receiver, totalCvgClaimable);\n        }\n        for (uint256 i; i < totalSdtRewardsClaimable.length; ) {\n            uint256 rewardAmount = totalSdtRewardsClaimable[i].amount;\n            if (rewardAmount > 0) {\n                if (isConvert && totalSdtRewardsClaimable[i].token == _sdt) {\n                    if (isMint) {\n                        /// @dev Mint cvgSdt 1:1 via CvgToke contract\n                        cvgSdt.mint(receiver, rewardAmount);\n                    } else {\n                        ICrvPoolPlain _poolCvgSDT = poolCvgSDT;\n                        /// @dev Only swap if the returned amount in CvgSdt is gretear than the amount rewarded in SDT\n                        _poolCvgSDT.exchange(0, 1, rewardAmount, _poolCvgSDT.get_dy(0, 1, rewardAmount), receiver);\n                    }\n                } else {\n                    totalSdtRewardsClaimable[i].token.safeTransfer(receiver, rewardAmount);\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     *  @notice Set the CvgSdt/Sdt stable pool. Approve SDT tokens to be transfered from the CvgSdt LP.\n     *  @dev    The approval has to be done to perform swaps from SDT to CvgSdt during claims.\n     *  @param _poolCvgSDT Address of the CvgSdt/Sdt stable pool to set\n     *  @param amount      Amount of SDT to approve on the Stable pool\n     */\n    function setPoolCvgSdtAndApprove(ICrvPoolPlain _poolCvgSDT, uint256 amount) external onlyOwner {\n        poolCvgSDT = _poolCvgSDT;\n        sdt.approve(address(_poolCvgSDT), amount);\n        sdt.approve(address(cvgSdt), amount);\n    }\n}"
    }
  ]
}