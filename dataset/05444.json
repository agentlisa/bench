{
  "Title": "[04] `gUSDC` onboarder can allow implementation of other markets (eg. `gWETH`)",
  "Content": "\nThere will be many `LendingTermOnboarding.sol` contracts for every `CREDIT` token used, but there is no check whether the implementation passed to `allowImplementation` function is from the same market. \n\nThere can be case when certain `gWETH` implementation is not allowed in the `LendingTermOnboarding` for `gWETH`, but mistakenly allowed in the `LendingTermOnboarding` for `gUSDC`. The result will be fully functioning `LendingTerm` onboarded from wrong contract and potentially malicious behaviour. \n\n[LendingTermOnboarding.sol#L92-L102](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L92-L102)\n\n```solidity\nfunction allowImplementation(\n        address implementation,\n        bool allowed\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        implementations[implementation] = allowed;\n        emit ImplementationAllowChanged(\n            block.timestamp,\n            implementation,\n            allowed\n        );\n    }\n```\n\n### Recommendation\n\nConsider checking if the implementation passed is with the same `CREDIT` token as one in the used in this particular `LendingTermOnboarding`.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/governance/LendingTermOnboarding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Governor, IGovernor} from \"@openzeppelin/contracts/governance/Governor.sol\";\n\nimport {Core} from \"@src/core/Core.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {GuildGovernor} from \"@src/governance/GuildGovernor.sol\";\n\n/// @notice Utils to onboard a LendingTerm. Also acts as a LendingTerm factory.\n/// This contract acts as Governor, but users cannot queue arbitrary proposals,\n/// they can only queue LendingTerm onboarding proposals.\n/// When a vote is successful, the LendingTerm onboarding is queued in the Timelock,\n/// where CREDIT holders can veto the onboarding.\n/// Only terms that have been deployed through this factory can be onboarded.\n/// A term can be onboarded for the first time, or re-onboarded after it has been offboarded.\ncontract LendingTermOnboarding is GuildGovernor {\n    /// @notice minimum delay between proposals of onboarding of a given term\n    uint256 public constant MIN_DELAY_BETWEEN_PROPOSALS = 7 days;\n    /// @notice time of last proposal of a given term\n    mapping(address => uint256) public lastProposal;\n\n    /// @notice mapping of allowed LendingTerm implementations\n    mapping(address => bool) public implementations;\n    /// @notice immutable reference to the guild token\n    address public immutable guildToken;\n    /// @notice immutable reference to the gauge type to use for the terms onboarded\n    uint256 public immutable gaugeType;\n\n    /// @notice timestamp of creation of a term\n    /// (used to check that a term has been created by this factory)\n    mapping(address => uint256) public created;\n\n    /// @notice reference to profitManager to set in created lending terms\n    address public immutable profitManager;\n    /// @notice reference to auctionHouse to set in created lending terms\n    address public immutable auctionHouse;\n    /// @notice reference to creditMinter to set in created lending terms\n    address public immutable creditMinter;\n    /// @notice reference to creditToken to set in created lending terms\n    address public immutable creditToken;\n\n    /// @notice emitted when a lending term implementation's \"allowed\" status changes\n    event ImplementationAllowChanged(\n        uint256 indexed when,\n        address indexed implementation,\n        bool allowed\n    );\n    /// @notice emitted when a term is created\n    event TermCreated(\n        uint256 indexed when,\n        address indexed implementation,\n        address indexed term,\n        LendingTerm.LendingTermParams params\n    );\n\n    constructor(\n        LendingTerm.LendingTermReferences memory _lendingTermReferences,\n        uint256 _gaugeType,\n        address _core,\n        address _timelock,\n        uint256 initialVotingDelay,\n        uint256 initialVotingPeriod,\n        uint256 initialProposalThreshold,\n        uint256 initialQuorum\n    )\n        GuildGovernor(\n            _core,\n            _timelock,\n            _lendingTermReferences.guildToken,\n            initialVotingDelay,\n            initialVotingPeriod,\n            initialProposalThreshold,\n            initialQuorum\n        )\n    {\n        guildToken = _lendingTermReferences.guildToken;\n        gaugeType = _gaugeType;\n        profitManager = _lendingTermReferences.profitManager;\n        auctionHouse = _lendingTermReferences.auctionHouse;\n        creditMinter = _lendingTermReferences.creditMinter;\n        creditToken = _lendingTermReferences.creditToken;\n    }\n\n    /// @notice Allow or disallow a given implemenation\n    function allowImplementation(\n        address implementation,\n        bool allowed\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        implementations[implementation] = allowed;\n        emit ImplementationAllowChanged(\n            block.timestamp,\n            implementation,\n            allowed\n        );\n    }\n\n    /// @notice Create a new LendingTerm and initialize it.\n    function createTerm(\n        address implementation,\n        LendingTerm.LendingTermParams calldata params\n    ) external returns (address) {\n        require(\n            implementations[implementation],\n            \"LendingTermOnboarding: invalid implementation\"\n        );\n        // must be an ERC20 (maybe, at least it prevents dumb input mistakes)\n        (bool success, bytes memory returned) = params.collateralToken.call(\n            abi.encodeWithSelector(IERC20.totalSupply.selector)\n        );\n        require(\n            success && returned.length == 32,\n            \"LendingTermOnboarding: invalid collateralToken\"\n        );\n\n        require(\n            params.maxDebtPerCollateralToken != 0, // must be able to mint non-zero debt\n            \"LendingTermOnboarding: invalid maxDebtPerCollateralToken\"\n        );\n\n        require(\n            params.interestRate < 1e18, // interest rate [0, 100[% APR\n            \"LendingTermOnboarding: invalid interestRate\"\n        );\n\n        require(\n            // 31557601 comes from the constant LendingTerm.YEAR() + 1\n            params.maxDelayBetweenPartialRepay < 31557601, // periodic payment every [0, 1 year]\n            \"LendingTermOnboarding: invalid maxDelayBetweenPartialRepay\"\n        );\n\n        require(\n            params.minPartialRepayPercent < 1e18, // periodic payment sizes [0, 100[%\n            \"LendingTermOnboarding: invalid minPartialRepayPercent\"\n        );\n\n        require(\n            params.openingFee <= 0.1e18, // open fee expected [0, 10]%\n            \"LendingTermOnboarding: invalid openingFee\"\n        );\n\n        require(\n            params.hardCap != 0, // non-zero hardcap\n            \"LendingTermOnboarding: invalid hardCap\"\n        );\n\n        address term = Clones.clone(implementation);\n        LendingTerm(term).initialize(\n            address(core()),\n            LendingTerm.LendingTermReferences({\n                profitManager: profitManager,\n                guildToken: guildToken,\n                auctionHouse: auctionHouse,\n                creditMinter: creditMinter,\n                creditToken: creditToken\n            }),\n            params\n        );\n        created[term] = block.timestamp;\n        emit TermCreated(block.timestamp, implementation, term, params);\n        return term;\n    }\n\n    /// @dev override to prevent arbitrary calls to be proposed\n    function propose(\n        address[] memory /* targets*/,\n        uint256[] memory /* values*/,\n        bytes[] memory /* calldatas*/,\n        string memory /* description*/\n    ) public pure override(IGovernor, Governor) returns (uint256) {\n        revert(\"LendingTermOnboarding: cannot propose arbitrary actions\");\n    }\n\n    /// @notice Propose the onboarding of a term\n    function proposeOnboard(\n        address term\n    ) external whenNotPaused returns (uint256 proposalId) {\n        // Check that the term has been created by this factory\n        require(created[term] != 0, \"LendingTermOnboarding: invalid term\");\n\n        // Check that the term was not subject to an onboard vote recently\n        require(\n            lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp,\n            \"LendingTermOnboarding: recently proposed\"\n        );\n        lastProposal[term] = block.timestamp;\n\n        // Check that the term is not already active\n        // note that terms that have been offboarded in the past can be re-onboarded\n        // and won't fail this check. This is intentional, because some terms might be offboarded\n        // due to specific market conditions, and it might be desirable to re-onboard them\n        // at a later date.\n        bool isGauge = GuildToken(guildToken).isGauge(term);\n        require(!isGauge, \"LendingTermOnboarding: active term\");\n\n        // Generate calldata for the proposal\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            string memory description\n        ) = getOnboardProposeArgs(term);\n\n        // propose\n        return Governor.propose(targets, values, calldatas, description);\n    }\n\n    /// @notice Generate the calldata for the onboarding of a term\n    function getOnboardProposeArgs(\n        address term\n    )\n        public\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            string memory description\n        )\n    {\n        targets = new address[](3);\n        values = new uint256[](3);\n        calldatas = new bytes[](3);\n        description = string.concat(\n            \"[\",\n            Strings.toString(block.number),\n            \"]\",\n            \" Enable term \",\n            Strings.toHexString(term)\n        );\n\n        // 1st call: guild.addGauge(term)\n        targets[0] = guildToken;\n        calldatas[0] = abi.encodeWithSelector(\n            GuildToken.addGauge.selector,\n            gaugeType,\n            term\n        );\n\n        // 2nd call: core.grantRole(term, RATE_LIMITED_CREDIT_MINTER)\n        address _core = address(core());\n        targets[1] = _core;\n        calldatas[1] = abi.encodeWithSelector(\n            AccessControl.grantRole.selector,\n            CoreRoles.RATE_LIMITED_CREDIT_MINTER,\n            term\n        );\n\n        // 3rd call: core.grantRole(term, GAUGE_PNL_NOTIFIER)\n        targets[2] = _core;\n        calldatas[2] = abi.encodeWithSelector(\n            AccessControl.grantRole.selector,\n            CoreRoles.GAUGE_PNL_NOTIFIER,\n            term\n        );\n    }\n}"
    }
  ]
}