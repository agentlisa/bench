{
  "Title": "M-4: All transactions to claim assets from the vault will revert in some situations due to double subtraction of the claimed assets in market position allocations calculation.",
  "Content": "# Issue M-4: All transactions to claim assets from the vault will revert in some situations due to double subtraction of the claimed assets in market position allocations calculation. \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/11 \n\n## Found by \npanprog\n## Summary\n\nWhen assets are claimed from the vault (`Vault.update(0,0,x)` called), the vault rebalances its collateral. There is an issue with market positions allocation calculations: the assets (\"total position\") subtract claimed amount twice. This leads to revert in case this incorrect `assets` amount is less than `minAssets` (caused by market's `minPosition`). In situations when the vault can't redeem due to some market's position being at the `minPosition` (because of the market's skew, which disallows makers to reduce their positions), this will lead to all users being unable to claim any assets which were already redeemed and settled.\n\n## Vulnerability Detail\n\n`Vault.update` rebalances collateral by calling `_manage`:\n```solidity\n_manage(context, depositAssets, claimAmount, !depositAssets.isZero() || !redeemShares.isZero());\n```\n\nIn the rebalance calculations, collateral and assets (assets here stands for \"total vault position\") are calculated as following:\n```solidity\n  UFixed6 collateral = UFixed6Lib.unsafeFrom(strategy.totalCollateral).add(deposit).unsafeSub(withdrawal);\n  UFixed6 assets = collateral.unsafeSub(ineligable);\n\n  if (collateral.lt(strategy.totalMargin)) revert StrategyLibInsufficientCollateralError();\n  if (assets.lt(strategy.minAssets)) revert StrategyLibInsufficientAssetsError();\n```\n\n`ineligable` is calculated as following:\n```solidity\nfunction _ineligable(Context memory context, UFixed6 withdrawal) private pure returns (UFixed6) {\n    // assets eligable for redemption\n    UFixed6 redemptionEligable = UFixed6Lib.unsafeFrom(context.totalCollateral)\n        .unsafeSub(withdrawal)\n        .unsafeSub(context.global.assets)\n        .unsafeSub(context.global.deposit);\n\n    return redemptionEligable\n        // approximate assets up for redemption\n        .mul(context.global.redemption.unsafeDiv(context.global.shares.add(context.global.redemption)))\n        // assets pending claim\n        .add(context.global.assets)\n        // assets withdrawing\n        .add(withdrawal);\n}\n```\n\nNotice that `ineligable` adds `withdrawal` in the end (which is the assets claimed by the user). Now back to collateral and assets calculation:\n- `collateral = totalCollateral + deposit - withdrawal`\n- `assets = collateral - ineligable = collateral - (redemptionEligable * redemption / (redemption + shares) + global.assets + withdrawal)`\n- `assets = totalCollateral + deposit - withdrawal - [redemptionIneligable] - global.assets - withdrawal`\n- `assets = totalCollateral + deposit - [redemptionIneligable] - global.assets - 2 * withdrawal`\n\nSee that `withdrawal` (assets claimed by the user) is subtracted twice in assets calculations. This means that assets calculated are smaller than it should. In particular, assets might become less than minAssets thus reverting in the following line:\n```solidity\n  if (assets.lt(strategy.minAssets)) revert StrategyLibInsufficientAssetsError();\n```\n\nPossible scenario for this issue to cause inability to claim funds:\n1. Some vault market's has a high skew (|long - short|), which means that minimum maker position is limited by the skew.\n2. User redeems large amount from the vault, reducing vault's position in that market so that market maker ~= |long - short|. This means that further redeems from the vault are not possible because the vault can't reduce its position in the market.\n3. After that, the user tries to claim what he has redeemed, but all attempts to redeem will revert (both for this user and for any other user that might want to claim)\n\n## Impact\n\nIn certain situations (redeem not possible from the vault due to high skew in some underlying market) claiming assets from the vault will revert for all users, temporarily (and sometimes permanently) locking user funds in the contract.\n\n## Proof of concept\n\nThe scenario above is demonstrated in the test, change the following test in test/integration/vault/Vault.test.ts:\n```ts\n    it('simple deposits and redemptions', async () => {\n...\n      // Now we should have opened positions.\n      // The positions should be equal to (smallDeposit + largeDeposit) * leverage originalOraclePrice.\n      expect(await position()).to.equal(\n        smallDeposit.add(largeDeposit).mul(leverage).mul(4).div(5).div(originalOraclePrice),\n      )\n      expect(await btcPosition()).to.equal(\n        smallDeposit.add(largeDeposit).mul(leverage).div(5).div(btcOriginalOraclePrice),\n      )\n\n      /*** remove all lines after this and replace with the following code: ***/\n\n      var half = smallDeposit.add(largeDeposit).div(2).add(smallDeposit);\n      await vault.connect(user).update(user.address, 0, half, 0)\n\n      await updateOracle()\n      await vault.connect(user2).update(user2.address, smallDeposit, 0, 0) // this will create min position in the market\n      await vault.connect(user).update(user.address, 0, 0, half) // this will revert even though it's just claiming\n    })\n```\n\nThe last line in the test will revert, even though it's just claiming assets. If the pre-last line is commented out (no \"min position\" created in the market), it will work normally.\n\n## Code Snippet\n\nIneligable amount calculation adds `withdrawal`:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/Vault.sol#L431\n\n`withdrawal` is subtracted twice - once directly from collateral, 2nd time via ineligable amount subtractions:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L118-L119\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove `add(withdrawal)` from `_ineligable` calculation in the vault.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/303\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/Vault.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IVaultFactory.sol\";\nimport \"./types/Account.sol\";\nimport \"./types/Checkpoint.sol\";\nimport \"./types/Registration.sol\";\nimport \"./types/VaultParameter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./lib/StrategyLib.sol\";\n\n/// @title Vault\n/// @notice Deploys underlying capital by weight in maker positions across registered markets\n/// @dev Vault deploys and rebalances collateral between the registered markets, while attempting to\n///      maintain `targetLeverage` with its open maker positions at any given time. Deposits are only gated in so much\n///      as to cap the maximum amount of assets in the vault.\n///\n///      All registered markets are expected to be on the same \"clock\", i.e. their oracle.current() is always equal.\n///\n///      The vault has a \"delayed settlement\" mechanism. After depositing to or redeeming from the vault, a user must\n///      wait until the next settlement of all underlying markets in order for vault settlement to be available.\ncontract Vault is IVault, Instance {\n    /// @dev The vault's name\n    string private _name;\n\n    /// @dev The underlying asset\n    Token18 public asset;\n\n    /// @dev The vault parameter set\n    VaultParameterStorage private _parameter;\n\n    /// @dev The total number of registered markets\n    uint256 public totalMarkets;\n\n    /// @dev Per-market registration state variables\n    mapping(uint256 => RegistrationStorage) private _registrations;\n\n    /// @dev Per-account accounting state variables\n    mapping(address => AccountStorage) private _accounts;\n\n    /// @dev Per-id accounting state variables\n    mapping(uint256 => CheckpointStorage) private _checkpoints;\n\n    /// @dev DEPRECATED SLOT -- previously the mappings\n    bytes32 private __unused0__;\n\n    /// @notice Initializes the vault\n    /// @param asset_ The underlying asset\n    /// @param initialMarket The initial market to register\n    /// @param name_ The vault's name\n    function initialize(\n        Token18 asset_,\n        IMarket initialMarket,\n        UFixed6 cap,\n        string calldata name_\n    ) external initializer(1) {\n        __Instance__initialize();\n\n        asset = asset_;\n        _name = name_;\n        _register(initialMarket);\n        _updateParameter(VaultParameter(cap));\n    }\n\n    /// @notice Returns the vault parameter set\n    /// @return The vault parameter set\n    function parameter() external view returns (VaultParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the registration for a given market\n    /// @param marketId The market id\n    /// @return The registration for the given market\n    function registrations(uint256 marketId) external view returns (Registration memory) {\n        return _registrations[marketId].read();\n    }\n\n    /// @notice Returns the account state for a account\n    /// @param account The account to query\n    /// @return The account state for the given account\n    function accounts(address account) external view returns (Account memory) {\n        return _accounts[account].read();\n    }\n\n    /// @notice Returns the checkpoint for a given id\n    /// @param id The id to query\n    /// @return The checkpoint for the given id\n    function checkpoints(uint256 id) external view returns (Checkpoint memory) {\n        return _checkpoints[id].read();\n    }\n\n    /// @notice Returns the name of the vault\n    /// @return The name of the vault\n    function name() external view returns (string memory) {\n        return string(abi.encodePacked(\"Perennial V2 Vault: \", _name));\n    }\n\n    /// @notice Returns the total number of underlying assets at the last checkpoint\n    /// @return The total number of underlying assets at the last checkpoint\n    function totalAssets() public view returns (Fixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.assets\n            .add(Fixed6Lib.from(checkpoint.deposit))\n            .sub(Fixed6Lib.from(checkpoint.toAssetsGlobal(checkpoint.redemption)));\n    }\n\n    /// @notice Returns the total number of shares at the last checkpoint\n    /// @return The total number of shares at the last checkpoint\n    function totalShares() public view returns (UFixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.shares\n            .add(checkpoint.toSharesGlobal(checkpoint.deposit))\n            .sub(checkpoint.redemption);\n    }\n\n    /// @notice Converts a given amount of assets to shares\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets\n    function convertToShares(UFixed6 assets) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.unsafeFrom(totalAssets()), totalShares());\n        return _totalShares.isZero() ? assets : assets.muldiv(_totalShares, _totalAssets);\n    }\n\n    /// @notice Converts a given amount of shares to assets\n    /// @param shares Number of shares to convert to assets\n    /// @return Amount of assets for the given shares\n    function convertToAssets(UFixed6 shares) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.unsafeFrom(totalAssets()), totalShares());\n        return _totalShares.isZero() ? shares : shares.muldiv(_totalAssets, _totalShares);\n    }\n\n    /// @notice Registers a new market\n    /// @param market The market to register\n    function register(IMarket market) external onlyOwner {\n        rebalance(address(0));\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (_registrations[marketId].read().market == market) revert VaultMarketExistsError();\n        }\n\n        _register(market);\n    }\n\n    /// @notice Handles the registration for a new market\n    /// @param market The market to register\n    function _register(IMarket market) private {\n        if (!IVaultFactory(address(factory())).marketFactory().instances(market)) revert VaultNotMarketError();\n        if (!market.token().eq(asset)) revert VaultIncorrectAssetError();\n\n        asset.approve(address(market));\n\n        uint256 newMarketId = _registerMarket(market);\n        _updateMarket(newMarketId, newMarketId == 0 ? UFixed6Lib.ONE : UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Processes the state changes for a market registration\n    /// @param market The market to register\n    /// @return newMarketId The new market id\n    function _registerMarket(IMarket market) private returns (uint256 newMarketId) {\n        newMarketId = totalMarkets++;\n        _registrations[newMarketId].store(Registration(market, UFixed6Lib.ZERO, UFixed6Lib.ZERO));\n        emit MarketRegistered(newMarketId, market);\n    }\n\n    /// @notice Processes the state changes for a market update\n    /// @param marketId The market id\n    /// @param newWeight The new weight for the market\n    /// @param newLeverage The new leverage for the market\n    function _updateMarket(uint256 marketId, UFixed6 newWeight, UFixed6 newLeverage) private {\n        Registration memory registration = _registrations[marketId].read();\n        registration.weight = newWeight.eq(UFixed6Lib.MAX) ? registration.weight : newWeight;\n        registration.leverage = newLeverage.eq(UFixed6Lib.MAX) ? registration.leverage : newLeverage;\n        _registrations[marketId].store(registration);\n        emit MarketUpdated(marketId, registration.weight, registration.leverage);\n    }\n\n    /// @notice Settles, then updates the registration parameters for a given market\n    /// @param marketId The market id\n    /// @param newLeverage The new leverage\n    function updateLeverage(uint256 marketId, UFixed6 newLeverage) external onlyOwner {\n        rebalance(address(0));\n\n        if (marketId >= totalMarkets) revert VaultMarketDoesNotExistError();\n\n        _updateMarket(marketId, UFixed6Lib.MAX, newLeverage);\n    }\n\n    /// @notice Updates the set of market weights for the vault\n    /// @param newWeights The new set of market weights\n    function updateWeights(UFixed6[] calldata newWeights) external onlyOwner {\n        rebalance(address(0));\n\n        if (newWeights.length != totalMarkets) revert VaultMarketDoesNotExistError();\n\n        UFixed6 totalWeight;\n        for(uint256 i; i < totalMarkets; i++) {\n            _updateMarket(i, newWeights[i], UFixed6Lib.MAX);\n            totalWeight = totalWeight.add(newWeights[i]);\n        }\n\n        if (!totalWeight.eq(UFixed6Lib.ONE)) revert VaultAggregateWeightError();\n    }\n\n    /// @notice Settles, then updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function updateParameter(VaultParameter memory newParameter) external onlyOwner {\n        rebalance(address(0));\n        _updateParameter(newParameter);\n    }\n\n    /// @notice Updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function _updateParameter(VaultParameter memory newParameter) private {\n        _parameter.store(newParameter);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @dev Rebalances only the collateral of the vault\n    /// @param account The account that should be synced\n    function settle(address account) public whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _saveContext(context, account);\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @dev Rebalances only the collateral of the vault\n    /// @param account The account that should be synced\n    function rebalance(address account) public whenNotPaused {\n        _updateUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _manage(context, UFixed6Lib.ZERO, UFixed6Lib.ZERO, false);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates `account`, depositing `depositAssets` assets, redeeming `redeemShares` shares, and claiming `claimAssets` assets\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function update(\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) external whenNotPaused {\n        _updateUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _checkpoint(context);\n        _update(context, account, depositAssets, redeemShares, claimAssets);\n        _saveContext(context, account);\n    }\n\n    /// @notice Loads or initializes the current checkpoint\n    /// @param context The context to use\n    function _checkpoint(Context memory context) private view {\n        context.currentId = context.global.current;\n        context.currentCheckpoint = _checkpoints[context.currentId].read();\n\n        if (context.currentTimestamp > context.currentCheckpoint.timestamp) {\n            context.currentId++;\n            context.currentCheckpoint.next(context.currentTimestamp, context.global);\n        }\n    }\n\n    /// @notice Handles updating the account's position\n    /// @param context The context to use\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) private {\n        // magic values\n        if (claimAssets.eq(UFixed6Lib.MAX)) claimAssets = context.local.assets;\n        if (redeemShares.eq(UFixed6Lib.MAX)) redeemShares = context.local.shares;\n\n        // invariant\n        if (msg.sender != account && !IVaultFactory(address(factory())).operators(account, msg.sender))\n            revert VaultNotOperatorError();\n        if (!depositAssets.add(redeemShares).add(claimAssets).eq(depositAssets.max(redeemShares).max(claimAssets)))\n            revert VaultNotSingleSidedError();\n        if (depositAssets.gt(_maxDeposit(context)))\n            revert VaultDepositLimitExceededError();\n        if (!depositAssets.isZero() && depositAssets.lt(context.settlementFee))\n            revert VaultInsufficientMinimumError();\n        if (!redeemShares.isZero() && context.latestCheckpoint.toAssets(redeemShares, context.settlementFee).isZero())\n            revert VaultInsufficientMinimumError();\n        if (context.local.current != context.local.latest) revert VaultExistingOrderError();\n\n        // asses socialization\n        UFixed6 claimAmount = _socialize(context, claimAssets);\n\n        // update positions\n        context.global.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.local.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.currentCheckpoint.update(depositAssets, redeemShares);\n\n        // manage assets\n        asset.pull(msg.sender, UFixed18Lib.from(depositAssets));\n        _manage(context, depositAssets, claimAmount, !depositAssets.isZero() || !redeemShares.isZero());\n        asset.push(msg.sender, UFixed18Lib.from(claimAmount));\n\n        emit Updated(msg.sender, account, context.currentId, depositAssets, redeemShares, claimAssets);\n    }\n\n    /// @notice Returns the claim amount after socialization\n    /// @param context The context to use\n    /// @param claimAssets The amount of assets to claim\n    function _socialize(Context memory context, UFixed6 claimAssets) private pure returns (UFixed6) {\n        return context.global.assets.isZero() ?\n            UFixed6Lib.ZERO :\n            claimAssets.muldiv(\n                UFixed6Lib.unsafeFrom(context.totalCollateral).min(context.global.assets),\n                context.global.assets\n            );\n    }\n\n    /// @notice Handles settling the vault's underlying markets\n    function _settleUnderlying() private {\n        for (uint256 marketId; marketId < totalMarkets; marketId++)\n            _registrations[marketId].read().market.settle(address(this));\n    }\n\n    /// @notice Handles updating the vault's underlying markets\n    function _updateUnderlying() private {\n        for (uint256 marketId; marketId < totalMarkets; marketId++)\n            _registrations[marketId].read().market.update(\n                address(this),\n                UFixed6Lib.MAX,\n                UFixed6Lib.ZERO,\n                UFixed6Lib.ZERO,\n                Fixed6Lib.ZERO,\n                false\n            );\n    }\n\n    /// @notice Handles settling the vault state\n    /// @dev Run before every stateful operation to settle up the latest global state of the vault\n    /// @param context The context to use\n    function _settle(Context memory context, address account) private {\n        Checkpoint memory nextCheckpoint;\n\n        // settle global positions\n        while (\n            context.global.current > context.global.latest &&\n            context.latestTimestamp >= (nextCheckpoint = _checkpoints[context.global.latest + 1].read()).timestamp\n        ) {\n            nextCheckpoint.complete(_checkpointAtId(context, nextCheckpoint.timestamp));\n            context.global.processGlobal(\n                context.global.latest + 1,\n                nextCheckpoint,\n                nextCheckpoint.deposit,\n                nextCheckpoint.redemption\n            );\n            _checkpoints[context.global.latest].store(nextCheckpoint);\n            context.latestCheckpoint = nextCheckpoint;\n        }\n\n        if (account == address(0)) return;\n\n        // settle local position\n        if (\n            context.local.current > context.local.latest &&\n            context.latestTimestamp >= (nextCheckpoint = _checkpoints[context.local.current].read()).timestamp\n        )\n            context.local.processLocal(\n                context.local.current,\n                nextCheckpoint,\n                context.local.deposit,\n                context.local.redemption\n            );\n    }\n\n    /// @notice Manages the internal collateral and position strategy of the vault\n    /// @param deposit The amount of assets that are being deposited into the vault\n    /// @param withdrawal The amount of assets that need to be withdrawn from the markets into the vault\n    /// @param rebalance Whether to rebalance the vault's position\n    function _manage(Context memory context, UFixed6 deposit, UFixed6 withdrawal, bool rebalance) private {\n        if (context.totalCollateral.lt(Fixed6Lib.ZERO)) return;\n\n        StrategyLib.MarketTarget[] memory targets = StrategyLib\n            .load(context.registrations)\n            .allocate(\n                deposit,\n                withdrawal,\n                _ineligable(context, withdrawal)\n            );\n\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.lt(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId], rebalance);\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.gte(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId], rebalance);\n    }\n\n    /// @notice Returns the amount of collateral is ineligable for allocation\n    /// @param context The context to use\n    /// @param withdrawal The amount of assets that need to be withdrawn from the markets into the vault\n    /// @return The amount of assets that are ineligable from being allocated\n    function _ineligable(Context memory context, UFixed6 withdrawal) private pure returns (UFixed6) {\n        // assets eligable for redemption\n        UFixed6 redemptionEligable = UFixed6Lib.unsafeFrom(context.totalCollateral)\n            .unsafeSub(withdrawal)\n            .unsafeSub(context.global.assets)\n            .unsafeSub(context.global.deposit);\n\n        return redemptionEligable\n            // approximate assets up for redemption\n            .mul(context.global.redemption.unsafeDiv(context.global.shares.add(context.global.redemption)))\n            // assets pending claim\n            .add(context.global.assets)\n            // assets withdrawing\n            .add(withdrawal);\n    }\n\n    /// @notice Adjusts the position on `market` to `targetPosition`\n    /// @param registration The registration of the market to use\n    /// @param target The new state to target\n    /// @param rebalance Whether to rebalance the vault's position\n    function _retarget(\n        Registration memory registration,\n        StrategyLib.MarketTarget memory target,\n        bool rebalance\n    ) private {\n        registration.market.update(\n            address(this),\n            rebalance ? target.position : UFixed6Lib.MAX,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            target.collateral,\n            false\n        );\n    }\n\n    /// @notice Loads the context for the given `account`\n    /// @param account Account to load the context for\n    /// @return context The context\n    function _loadContext(address account) private view returns (Context memory context) {\n        context.parameter = _parameter.read();\n\n        context.latestTimestamp = type(uint256).max;\n        context.currentTimestamp = type(uint256).max;\n        context.registrations = new Registration[](totalMarkets);\n        context.collaterals = new Fixed6[](totalMarkets);\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            // parameter\n            Registration memory registration = _registrations[marketId].read();\n            MarketParameter memory marketParameter = registration.market.parameter();\n            context.registrations[marketId] = registration;\n            context.settlementFee = context.settlementFee.add(marketParameter.settlementFee);\n\n            // version\n            (OracleVersion memory oracleVersion, uint256 currentTimestamp) = registration.market.oracle().status();\n            context.latestTimestamp = Math.min(context.latestTimestamp, oracleVersion.timestamp);\n            if (context.currentTimestamp == type(uint256).max) context.currentTimestamp = currentTimestamp;\n            else if (currentTimestamp != context.currentTimestamp) revert VaultCurrentOutOfSyncError();\n\n            // local\n            Local memory local = registration.market.locals(address(this));\n            context.collaterals[marketId] = local.collateral;\n            context.totalCollateral = context.totalCollateral.add(local.collateral);\n        }\n\n        if (account != address(0)) context.local = _accounts[account].read();\n        context.global = _accounts[address(0)].read();\n        context.latestCheckpoint = _checkpoints[context.global.latest].read();\n    }\n\n    /// @notice Saves the context into storage\n    /// @param context Context to use\n    /// @param account Account to save the context for\n    function _saveContext(Context memory context, address account) private {\n        if (account != address(0)) _accounts[account].store(context.local);\n        _accounts[address(0)].store(context.global);\n        _checkpoints[context.currentId].store(context.currentCheckpoint);\n    }\n\n    /// @notice The maximum available deposit amount\n    /// @param context Context to use in calculation\n    /// @return Maximum available deposit amount\n    function _maxDeposit(Context memory context) private view returns (UFixed6) {\n        return context.latestCheckpoint.unhealthy() ?\n            UFixed6Lib.ZERO :\n            context.parameter.cap.unsafeSub(UFixed6Lib.unsafeFrom(totalAssets()).add(context.global.deposit));\n    }\n\n    /// @notice Returns the aggregate perennial checkpoint for the vault at position\n    /// @param context Context to use\n    /// @param timestamp The timestamp to use\n    /// @return checkpoint The checkpoint at the given position\n    function _checkpointAtId(\n        Context memory context,\n        uint256 timestamp\n    ) public view returns (PerennialCheckpoint memory checkpoint) {\n        for (uint256 marketId; marketId < context.registrations.length; marketId++) {\n            PerennialCheckpoint memory marketCheckpoint = context.registrations[marketId].market\n                .checkpoints(address(this), timestamp);\n\n            (checkpoint.collateral, checkpoint.tradeFee, checkpoint.settlementFee) = (\n                checkpoint.collateral.add(marketCheckpoint.collateral),\n                checkpoint.tradeFee.add(marketCheckpoint.tradeFee),\n                checkpoint.settlementFee.add(marketCheckpoint.settlementFee)\n            );\n        }\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport {\n    MarketParameter,\n    RiskParameter,\n    Local,\n    Global,\n    Position,\n    PositionLib,\n    Order,\n    OracleVersion\n} from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Registration } from \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev Registration of the market\n    Registration registration;\n\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n\n    // @dev minimum position size before crossing the net position\n    UFixed6 minPosition;\n\n    // @dev maximum position size before crossing the maker limit\n    UFixed6 maxPosition;\n}\n\nstruct Strategy {\n    UFixed6 totalMargin;\n\n    Fixed6 totalCollateral;\n\n    UFixed6 minAssets;\n\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    error StrategyLibInsufficientCollateralError();\n    error StrategyLibInsufficientAssetsError();\n\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @notice Loads the strategy context of each of the underlying markets\n    /// @param registrations The registrations of the underlying markets\n    /// @return strategy The strategy contexts of the vault\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n            strategy.totalMargin = strategy.totalMargin.add(strategy.marketContexts[marketId].margin);\n            strategy.totalCollateral = strategy.totalCollateral.add(strategy.marketContexts[marketId].local.collateral);\n            strategy.minAssets = strategy.minAssets.max(\n                (registrations[marketId].leverage.isZero() || registrations[marketId].weight.isZero()) ?\n                    UFixed6Lib.ZERO : // skip if no leverage or weight\n                    strategy.marketContexts[marketId].minPosition\n                        .muldiv(strategy.marketContexts[marketId].latestPrice.abs(), registrations[marketId].leverage)\n                        .div(registrations[marketId].weight)\n            );\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param deposit The amount of assets that are being deposited into the vault\n    /// @param withdrawal The amount of assets to make available for withdrawal\n    /// @param ineligable The amount of assets that are inapplicable for allocation\n    function allocate(\n        Strategy memory strategy,\n        UFixed6 deposit,\n        UFixed6 withdrawal,\n        UFixed6 ineligable\n    ) internal pure returns (MarketTarget[] memory targets) {\n        UFixed6 collateral = UFixed6Lib.unsafeFrom(strategy.totalCollateral).add(deposit).unsafeSub(withdrawal);\n        UFixed6 assets = collateral.unsafeSub(ineligable);\n\n        if (collateral.lt(strategy.totalMargin)) revert StrategyLibInsufficientCollateralError();\n        if (assets.lt(strategy.minAssets)) revert StrategyLibInsufficientAssetsError();\n\n        targets = new MarketTarget[](strategy.marketContexts.length);\n        UFixed6 totalMarketCollateral;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            UFixed6 marketCollateral;\n            (targets[marketId], marketCollateral) = _allocateMarket(\n                strategy.marketContexts[marketId],\n                strategy.totalMargin,\n                collateral,\n                assets\n            );\n            totalMarketCollateral = totalMarketCollateral.add(marketCollateral);\n        }\n\n        if (strategy.marketContexts.length != 0)\n            targets[0].collateral = targets[0].collateral.add(Fixed6Lib.from(collateral.sub(totalMarketCollateral)));\n    }\n\n    /// @notice Compute the target allocation for a market\n    /// @param marketContext The context of the market\n    /// @param totalMargin The total margin requirement of the vault\n    /// @param collateral The total amount of collateral of the vault\n    /// @param assets The total amount of collateral available for allocation\n    function _allocateMarket(\n        MarketStrategyContext memory marketContext,\n        UFixed6 totalMargin,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) private pure returns (MarketTarget memory target, UFixed6 marketCollateral) {\n        marketCollateral = marketContext.margin\n            .add(collateral.sub(totalMargin).mul(marketContext.registration.weight));\n\n        UFixed6 marketAssets = assets\n            .mul(marketContext.registration.weight)\n            .min(marketCollateral.mul(LEVERAGE_BUFFER));\n\n        target.collateral = Fixed6Lib.from(marketCollateral).sub(marketContext.local.collateral);\n\n        UFixed6 minAssets = marketContext.riskParameter.minMargin\n            .unsafeDiv(marketContext.registration.leverage.mul(marketContext.riskParameter.maintenance));\n\n        if (marketContext.marketParameter.closed || marketAssets.lt(minAssets)) marketAssets = UFixed6Lib.ZERO;\n\n        target.position = marketAssets\n            .muldiv(marketContext.registration.leverage, marketContext.latestPrice.abs())\n            .max(marketContext.minPosition)\n            .min(marketContext.maxPosition);\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(\n        Registration memory registration\n    ) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.registration = registration;\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        OracleVersion memory latestVersion = registration.market.oracle().latest();\n\n        marketContext.latestAccountPosition = registration.market.positions(address(this));\n        marketContext.currentAccountPosition = marketContext.latestAccountPosition.clone();\n\n        Order memory pendingLocal = registration.market.pendings(address(this));\n        marketContext.currentAccountPosition.update(pendingLocal);\n\n        marketContext.margin = PositionLib.margin(\n            marketContext.latestAccountPosition.magnitude().add(pendingLocal.pos()),\n            latestVersion,\n            marketContext.riskParameter\n        );\n        marketContext.latestPrice = latestVersion.price;\n\n        marketContext.closable = marketContext.latestAccountPosition.magnitude().sub(pendingLocal.neg());\n\n        // current position\n        Order memory pendingGlobal = registration.market.pendings(address(this));\n        marketContext.currentPosition = registration.market.position();\n        marketContext.currentPosition.update(pendingGlobal);\n        marketContext.minPosition = marketContext.currentAccountPosition.maker\n            .unsafeSub(marketContext.currentPosition.maker\n                .unsafeSub(marketContext.currentPosition.skew().abs()).min(marketContext.closable));\n        marketContext.maxPosition = marketContext.currentAccountPosition.maker\n            .add(marketContext.riskParameter.makerLimit.unsafeSub(marketContext.currentPosition.maker));\n    }\n}"
    }
  ]
}