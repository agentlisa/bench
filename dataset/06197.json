{
  "Title": "[M-09] High Prizes might not be claimed",
  "Content": "\n### Lines of code\n\n<https://github.com/GenerationSoftware/pt-v5-claimer/blob/57a381aef690a27c9198f4340747155a71cae753/src/Claimer.sol#L210>\n<https://github.com/GenerationSoftware/pt-v5-claimer/blob/57a381aef690a27c9198f4340747155a71cae753/src/Claimer.sol#L173>\n\n### Impact\n\nPoolTogether V5 delegates the task of claiming the prizes to a network of `Claimers` that are incentivized to claim prizes for a share of the prize won.\nThe fees the Claimant receives is calculated based on a Dutch Auction, but then limited by the minimum prize of the prize pool.\n\nfee `=` min (fee in auction `= % maxFeePortionOfPrize * minPrize`).\n\nWhen the gas costs exceed the `minPrize`, the solver has no incentives to claim the price. Notice that the number of prizes only adjusts *after* very few prizes are claimed.\n\n### Proof of Concept\n\nGas prices will then rise well above the `minPrize`. The highest prize is suddenly drawn that day. The solvers have no incentive to claim the prize and the winner does not monitor the contract. As a result, no one claims the top prize. The protocol suffers a loss of reputation.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nThe problem is that the incentives are not exactly aligned. The user is willing to pay anything up to their price to receive their price. But the maximum the solver receives is the minimum price. We can align the two incentives by using each user's price as an upper bound.\n\n```diff\nfunction _computeMaxFee(uint8 _tier, uint8 _numTiers) internal view returns (uint256) {\n    uint8 _canaryTier = _numTiers - 1;\n    if (_tier != _canaryTier) {\n      // canary tier\n-     return _computeMaxFee(prizePool.getTierPrizeSize(_canaryTier - 1));\n+\t  return _computeMaxFee(prizePool.getTierPrizeSize(_tier));\n\t} else {\n      return _computeMaxFee(prizePool.getTierPrizeSize(_canaryTier));\n    }\n  }\n\n```\n\nSince we already validate the inputs in [`claimPrize`](https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/4bc8a12b857856828c018510b5500d722b79ca3a/src/PrizePool.sol#L417-L419), the attacker can not claim more than the prize is worth.\n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/415#issuecomment-1644725651)**\n\n**[PoolTogether mitigated](https://github.com/code-423n4/2023-08-pooltogether-mitigation#individual-prs):**\n> Made `maxFee` a function of the tier's prize size, not the smallest prize size.<br>\n> PR: https://github.com/GenerationSoftware/pt-v5-claimer/pull/7\n\n**Status**: Mitigation error. Full details in report from [dirk\\_y](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/15), and in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-pooltogether",
  "Code": [
    {
      "filename": "src/Claimer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { SD59x18 } from \"prb-math/SD59x18.sol\";\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { UD60x18 } from \"prb-math/UD60x18.sol\";\nimport { PrizePool } from \"v5-prize-pool/PrizePool.sol\";\nimport { Multicall } from \"openzeppelin/utils/Multicall.sol\";\n\nimport { LinearVRGDALib } from \"./libraries/LinearVRGDALib.sol\";\nimport { Vault } from \"v5-vault/Vault.sol\";\n\n/// @title Variable Rate Gradual Dutch Auction (VRGDA) Claimer\n/// @author PoolTogether Inc. Team\n/// @notice This contract uses a variable rate gradual dutch auction to inventivize prize claims on behalf of others\ncontract Claimer is Multicall {\n  /// @notice The Prize Pool that this Claimer is claiming prizes for\n  PrizePool public immutable prizePool;\n\n  /// @notice The maximum fee that can be charged as a portion of the smallest prize size. Fixed point 18 number\n  UD2x18 public immutable maxFeePortionOfPrize;\n\n  /// @notice The VRGDA decay constant computed in the constructor\n  SD59x18 public immutable decayConstant;\n\n  /// @notice The minimum fee that will be charged\n  uint256 public immutable minimumFee;\n\n  uint256 public immutable timeToReachMaxFee;\n\n  /// @notice Constructs a new Claimer\n  /// @param _prizePool The prize pool to claim for\n  /// @param _minimumFee The minimum fee that should be charged\n  /// @param _maximumFee The maximum fee that should be charged\n  /// @param _timeToReachMaxFee The time it should take to reach the maximum fee (for example should be the draw period in seconds)\n  /// @param _maxFeePortionOfPrize The maximum fee that can be charged as a portion of the smallest prize size. Fixed point 18 number\n  constructor(\n    PrizePool _prizePool,\n    uint256 _minimumFee,\n    uint256 _maximumFee,\n    uint256 _timeToReachMaxFee,\n    UD2x18 _maxFeePortionOfPrize\n  ) {\n    prizePool = _prizePool;\n    maxFeePortionOfPrize = _maxFeePortionOfPrize;\n    decayConstant = LinearVRGDALib.getDecayConstant(\n      LinearVRGDALib.getMaximumPriceDeltaScale(_minimumFee, _maximumFee, _timeToReachMaxFee)\n    );\n    minimumFee = _minimumFee;\n    timeToReachMaxFee = _timeToReachMaxFee;\n  }\n\n  /// @notice Allows the call to claim prizes on behalf of others.\n  /// @param vault The vault to claim from\n  /// @param tier The tier to claim for\n  /// @param winners The array of winners to claim for\n  /// @param prizeIndices The array of prize indices to claim for each winner (length should match winners)\n  /// @param _feeRecipient The address to receive the claim fees\n  /// @return totalFees The total fees collected across all successful claims\n  function claimPrizes(\n    Vault vault,\n    uint8 tier,\n    address[] calldata winners,\n    uint32[][] calldata prizeIndices,\n    address _feeRecipient\n  ) external returns (uint256 totalFees) {\n    uint256 claimCount;\n    for (uint i = 0; i < winners.length; i++) {\n      claimCount += prizeIndices[i].length;\n    }\n\n    uint96 feePerClaim = uint96(\n      _computeFeePerClaim(\n        _computeMaxFee(tier, prizePool.numberOfTiers()),\n        claimCount,\n        prizePool.claimCount()\n      )\n    );\n\n    vault.claimPrizes(tier, winners, prizeIndices, feePerClaim, _feeRecipient);\n\n    return feePerClaim * claimCount;\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @return The total fees for those claims\n  function computeTotalFees(uint8 _tier, uint _claimCount) external view returns (uint256) {\n    return\n      _computeFeePerClaim(\n        _computeMaxFee(_tier, prizePool.numberOfTiers()),\n        _claimCount,\n        prizePool.claimCount()\n      ) * _claimCount;\n  }\n\n  /// @notice Computes the total fees for the given number of claims if a number of claims have already been made.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for those claims\n  function computeTotalFees(\n    uint8 _tier,\n    uint _claimCount,\n    uint _claimedCount\n  ) external view returns (uint256) {\n    return\n      _computeFeePerClaim(\n        _computeMaxFee(_tier, prizePool.numberOfTiers()),\n        _claimCount,\n        _claimedCount\n      ) * _claimCount;\n  }\n\n  /// @notice Computes the fees for several claims.\n  /// @param _maxFee the maximum fee that can be charged\n  /// @param _claimCount the number of claims to check\n  /// @return The fees for the claims\n  function computeFeePerClaim(uint256 _maxFee, uint _claimCount) external view returns (uint256) {\n    return _computeFeePerClaim(_maxFee, _claimCount, prizePool.claimCount());\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _maxFee The maximum fee\n  /// @param _claimCount The number of claims to check\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for the claims\n  function _computeFeePerClaim(\n    uint256 _maxFee,\n    uint _claimCount,\n    uint _claimedCount\n  ) internal view returns (uint256) {\n    if (_claimCount == 0) {\n      return 0;\n    }\n    SD59x18 perTimeUnit = LinearVRGDALib.getPerTimeUnit(\n      prizePool.estimatedPrizeCount(),\n      timeToReachMaxFee\n    );\n    uint256 elapsed = block.timestamp - (prizePool.lastClosedDrawAwardedAt());\n    uint256 fee;\n\n    for (uint i = 0; i < _claimCount; i++) {\n      fee += _computeFeeForNextClaim(\n        minimumFee,\n        decayConstant,\n        perTimeUnit,\n        elapsed,\n        _claimedCount + i,\n        _maxFee\n      );\n    }\n\n    return fee / _claimCount;\n  }\n\n  /// @notice Computes the maximum fee that can be charged.\n  /// @param _tier The tier to compute the max fee for\n  /// @return The maximum fee that can be charged\n  function computeMaxFee(uint8 _tier) public view returns (uint256) {\n    return _computeMaxFee(_tier, prizePool.numberOfTiers());\n  }\n\n  /// @notice Computes the max fee given the tier and number of tiers.\n  /// @param _tier The tier to compute the max fee for\n  /// @param _numTiers The total number of tiers\n  /// @return The maximum fee that will be charged for a prize claim for the given tier\n  function _computeMaxFee(uint8 _tier, uint8 _numTiers) internal view returns (uint256) {\n    uint8 _canaryTier = _numTiers - 1;\n    if (_tier != _canaryTier) {\n      // canary tier\n      return _computeMaxFee(prizePool.getTierPrizeSize(_canaryTier - 1));\n    } else {\n      return _computeMaxFee(prizePool.getTierPrizeSize(_canaryTier));\n    }\n  }\n\n  /// @notice Computes the maximum fee that can be charged.\n  /// @param _prize The prize to compute the max fee for\n  /// @return The maximum fee that can be charged\n  function _computeMaxFee(uint256 _prize) internal view returns (uint256) {\n    // compute the maximum fee that can be charged\n    return UD60x18.unwrap(maxFeePortionOfPrize.intoUD60x18().mul(UD60x18.wrap(_prize)));\n  }\n\n  /// @notice Computes the fee for the next claim.\n  /// @param _minimumFee The minimum fee that should be charged\n  /// @param _decayConstant The VRGDA decay constant\n  /// @param _perTimeUnit The num to be claimed per second\n  /// @param _elapsed The number of seconds that have elapsed\n  /// @param _sold The number of prizes that were claimed\n  /// @param _maxFee The maximum fee that can be charged\n  /// @return The fee to charge for the next claim\n  function _computeFeeForNextClaim(\n    uint256 _minimumFee,\n    SD59x18 _decayConstant,\n    SD59x18 _perTimeUnit,\n    uint256 _elapsed,\n    uint256 _sold,\n    uint256 _maxFee\n  ) internal pure returns (uint256) {\n    uint256 fee = LinearVRGDALib.getVRGDAPrice(\n      _minimumFee,\n      _elapsed,\n      _sold,\n      _perTimeUnit,\n      _decayConstant\n    );\n    return fee > _maxFee ? _maxFee : fee;\n  }\n}"
    },
    {
      "filename": "src/Claimer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { SD59x18 } from \"prb-math/SD59x18.sol\";\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { UD60x18 } from \"prb-math/UD60x18.sol\";\nimport { PrizePool } from \"v5-prize-pool/PrizePool.sol\";\nimport { Multicall } from \"openzeppelin/utils/Multicall.sol\";\n\nimport { LinearVRGDALib } from \"./libraries/LinearVRGDALib.sol\";\nimport { Vault } from \"v5-vault/Vault.sol\";\n\n/// @title Variable Rate Gradual Dutch Auction (VRGDA) Claimer\n/// @author PoolTogether Inc. Team\n/// @notice This contract uses a variable rate gradual dutch auction to inventivize prize claims on behalf of others\ncontract Claimer is Multicall {\n  /// @notice The Prize Pool that this Claimer is claiming prizes for\n  PrizePool public immutable prizePool;\n\n  /// @notice The maximum fee that can be charged as a portion of the smallest prize size. Fixed point 18 number\n  UD2x18 public immutable maxFeePortionOfPrize;\n\n  /// @notice The VRGDA decay constant computed in the constructor\n  SD59x18 public immutable decayConstant;\n\n  /// @notice The minimum fee that will be charged\n  uint256 public immutable minimumFee;\n\n  uint256 public immutable timeToReachMaxFee;\n\n  /// @notice Constructs a new Claimer\n  /// @param _prizePool The prize pool to claim for\n  /// @param _minimumFee The minimum fee that should be charged\n  /// @param _maximumFee The maximum fee that should be charged\n  /// @param _timeToReachMaxFee The time it should take to reach the maximum fee (for example should be the draw period in seconds)\n  /// @param _maxFeePortionOfPrize The maximum fee that can be charged as a portion of the smallest prize size. Fixed point 18 number\n  constructor(\n    PrizePool _prizePool,\n    uint256 _minimumFee,\n    uint256 _maximumFee,\n    uint256 _timeToReachMaxFee,\n    UD2x18 _maxFeePortionOfPrize\n  ) {\n    prizePool = _prizePool;\n    maxFeePortionOfPrize = _maxFeePortionOfPrize;\n    decayConstant = LinearVRGDALib.getDecayConstant(\n      LinearVRGDALib.getMaximumPriceDeltaScale(_minimumFee, _maximumFee, _timeToReachMaxFee)\n    );\n    minimumFee = _minimumFee;\n    timeToReachMaxFee = _timeToReachMaxFee;\n  }\n\n  /// @notice Allows the call to claim prizes on behalf of others.\n  /// @param vault The vault to claim from\n  /// @param tier The tier to claim for\n  /// @param winners The array of winners to claim for\n  /// @param prizeIndices The array of prize indices to claim for each winner (length should match winners)\n  /// @param _feeRecipient The address to receive the claim fees\n  /// @return totalFees The total fees collected across all successful claims\n  function claimPrizes(\n    Vault vault,\n    uint8 tier,\n    address[] calldata winners,\n    uint32[][] calldata prizeIndices,\n    address _feeRecipient\n  ) external returns (uint256 totalFees) {\n    uint256 claimCount;\n    for (uint i = 0; i < winners.length; i++) {\n      claimCount += prizeIndices[i].length;\n    }\n\n    uint96 feePerClaim = uint96(\n      _computeFeePerClaim(\n        _computeMaxFee(tier, prizePool.numberOfTiers()),\n        claimCount,\n        prizePool.claimCount()\n      )\n    );\n\n    vault.claimPrizes(tier, winners, prizeIndices, feePerClaim, _feeRecipient);\n\n    return feePerClaim * claimCount;\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @return The total fees for those claims\n  function computeTotalFees(uint8 _tier, uint _claimCount) external view returns (uint256) {\n    return\n      _computeFeePerClaim(\n        _computeMaxFee(_tier, prizePool.numberOfTiers()),\n        _claimCount,\n        prizePool.claimCount()\n      ) * _claimCount;\n  }\n\n  /// @notice Computes the total fees for the given number of claims if a number of claims have already been made.\n  /// @param _tier The tier to claim prizes from\n  /// @param _claimCount The number of claims\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for those claims\n  function computeTotalFees(\n    uint8 _tier,\n    uint _claimCount,\n    uint _claimedCount\n  ) external view returns (uint256) {\n    return\n      _computeFeePerClaim(\n        _computeMaxFee(_tier, prizePool.numberOfTiers()),\n        _claimCount,\n        _claimedCount\n      ) * _claimCount;\n  }\n\n  /// @notice Computes the fees for several claims.\n  /// @param _maxFee the maximum fee that can be charged\n  /// @param _claimCount the number of claims to check\n  /// @return The fees for the claims\n  function computeFeePerClaim(uint256 _maxFee, uint _claimCount) external view returns (uint256) {\n    return _computeFeePerClaim(_maxFee, _claimCount, prizePool.claimCount());\n  }\n\n  /// @notice Computes the total fees for the given number of claims.\n  /// @param _maxFee The maximum fee\n  /// @param _claimCount The number of claims to check\n  /// @param _claimedCount The number of prizes already claimed\n  /// @return The total fees for the claims\n  function _computeFeePerClaim(\n    uint256 _maxFee,\n    uint _claimCount,\n    uint _claimedCount\n  ) internal view returns (uint256) {\n    if (_claimCount == 0) {\n      return 0;\n    }\n    SD59x18 perTimeUnit = LinearVRGDALib.getPerTimeUnit(\n      prizePool.estimatedPrizeCount(),\n      timeToReachMaxFee\n    );\n    uint256 elapsed = block.timestamp - (prizePool.lastClosedDrawAwardedAt());\n    uint256 fee;\n\n    for (uint i = 0; i < _claimCount; i++) {\n      fee += _computeFeeForNextClaim(\n        minimumFee,\n        decayConstant,\n        perTimeUnit,\n        elapsed,\n        _claimedCount + i,\n        _maxFee\n      );\n    }\n\n    return fee / _claimCount;\n  }\n\n  /// @notice Computes the maximum fee that can be charged.\n  /// @param _tier The tier to compute the max fee for\n  /// @return The maximum fee that can be charged\n  function computeMaxFee(uint8 _tier) public view returns (uint256) {\n    return _computeMaxFee(_tier, prizePool.numberOfTiers());\n  }\n\n  /// @notice Computes the max fee given the tier and number of tiers.\n  /// @param _tier The tier to compute the max fee for\n  /// @param _numTiers The total number of tiers\n  /// @return The maximum fee that will be charged for a prize claim for the given tier\n  function _computeMaxFee(uint8 _tier, uint8 _numTiers) internal view returns (uint256) {\n    uint8 _canaryTier = _numTiers - 1;\n    if (_tier != _canaryTier) {\n      // canary tier\n      return _computeMaxFee(prizePool.getTierPrizeSize(_canaryTier - 1));\n    } else {\n      return _computeMaxFee(prizePool.getTierPrizeSize(_canaryTier));\n    }\n  }\n\n  /// @notice Computes the maximum fee that can be charged.\n  /// @param _prize The prize to compute the max fee for\n  /// @return The maximum fee that can be charged\n  function _computeMaxFee(uint256 _prize) internal view returns (uint256) {\n    // compute the maximum fee that can be charged\n    return UD60x18.unwrap(maxFeePortionOfPrize.intoUD60x18().mul(UD60x18.wrap(_prize)));\n  }\n\n  /// @notice Computes the fee for the next claim.\n  /// @param _minimumFee The minimum fee that should be charged\n  /// @param _decayConstant The VRGDA decay constant\n  /// @param _perTimeUnit The num to be claimed per second\n  /// @param _elapsed The number of seconds that have elapsed\n  /// @param _sold The number of prizes that were claimed\n  /// @param _maxFee The maximum fee that can be charged\n  /// @return The fee to charge for the next claim\n  function _computeFeeForNextClaim(\n    uint256 _minimumFee,\n    SD59x18 _decayConstant,\n    SD59x18 _perTimeUnit,\n    uint256 _elapsed,\n    uint256 _sold,\n    uint256 _maxFee\n  ) internal pure returns (uint256) {\n    uint256 fee = LinearVRGDALib.getVRGDAPrice(\n      _minimumFee,\n      _elapsed,\n      _sold,\n      _perTimeUnit,\n      _decayConstant\n    );\n    return fee > _maxFee ? _maxFee : fee;\n  }\n}"
    },
    {
      "filename": "src/PrizePool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"forge-std/console2.sol\";\n\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { E, SD59x18, sd, toSD59x18, fromSD59x18 } from \"prb-math/SD59x18.sol\";\nimport { UD60x18, ud, toUD60x18, fromUD60x18, intoSD59x18 } from \"prb-math/UD60x18.sol\";\nimport { UD2x18, intoUD60x18 } from \"prb-math/UD2x18.sol\";\nimport { SD1x18, unwrap, UNIT } from \"prb-math/SD1x18.sol\";\nimport { UD34x4, fromUD60x18 as fromUD60x18toUD34x4, intoUD60x18 as fromUD34x4toUD60x18, toUD34x4 } from \"./libraries/UD34x4.sol\";\n\nimport { TwabController } from \"v5-twab-controller/TwabController.sol\";\nimport { DrawAccumulatorLib, Observation } from \"./libraries/DrawAccumulatorLib.sol\";\nimport { TieredLiquidityDistributor, Tier } from \"./abstract/TieredLiquidityDistributor.sol\";\nimport { TierCalculationLib } from \"./libraries/TierCalculationLib.sol\";\n\n/// @notice Emitted when someone tries to set the draw manager.\nerror DrawManagerAlreadySet();\n\n/// @notice Emitted when someone tries to claim a prize that was already claimed.\n/// @param winner The winner of the prize\n/// @param tier The prize tier\nerror AlreadyClaimedPrize(\n  address vault,\n  address winner,\n  uint8 tier,\n  uint32 prizeIndex,\n  address recipient\n);\n\n/// @notice Emitted when someone tries to withdraw too many rewards.\n/// @param requested The requested reward amount to withdraw\n/// @param available The total reward amount available for the caller to withdraw\nerror InsufficientRewardsError(uint256 requested, uint256 available);\n\n/// @notice Emitted when an address did not win the specified prize on a vault when claiming.\n/// @param winner The address checked for the prize\n/// @param vault The vault address\n/// @param tier The prize tier\n/// @param prizeIndex The prize index\nerror DidNotWin(address vault, address winner, uint8 tier, uint32 prizeIndex);\n\n/// @notice Emitted when the fee being claimed is larger than the max allowed fee.\n/// @param fee The fee being claimed\n/// @param maxFee The max fee that can be claimed\nerror FeeTooLarge(uint256 fee, uint256 maxFee);\n\n/// @notice Emitted when the initialized smoothing number is not less than one.\n/// @param smoothing The unwrapped smoothing value that exceeds the limit\nerror SmoothingGTEOne(int64 smoothing);\n\n/// @notice Emitted when the contributed amount is more than the available, un-accounted balance.\n/// @param amount The contribution amount that is being claimed\n/// @param available The available un-accounted balance that can be claimed as a contribution\nerror ContributionGTDeltaBalance(uint256 amount, uint256 available);\n\n/// @notice Emitted when the withdraw amount is greater than the available reserve.\n/// @param amount The amount being withdrawn\n/// @param reserve The total reserve available for withdrawal\nerror InsufficientReserve(uint104 amount, uint104 reserve);\n\n/// @notice Emitted when the winning random number is zero.\nerror RandomNumberIsZero();\n\n/// @notice Emitted when the draw cannot be closed since it has not finished.\n/// @param drawEndsAt The timestamp in seconds at which the draw ends\n/// @param errorTimestamp The timestamp in seconds at which the error occured\nerror DrawNotFinished(uint64 drawEndsAt, uint64 errorTimestamp);\n\n/// @notice Emitted when prize index is greater or equal to the max prize count for the tier.\n/// @param invalidPrizeIndex The invalid prize index\n/// @param prizeCount The prize count for the tier\n/// @param tier The tier number\nerror InvalidPrizeIndex(uint32 invalidPrizeIndex, uint32 prizeCount, uint8 tier);\n\n/// @notice Emitted when there are no closed draws when a computation requires a closed draw.\nerror NoClosedDraw();\n\n/// @notice Emitted when attempting to claim from a tier that does not exist.\n/// @param tier The tier number that does not exist\n/// @param numberOfTiers The current number of tiers\nerror InvalidTier(uint8 tier, uint8 numberOfTiers);\n\n/// @notice Emitted when the caller is not the draw manager.\n/// @param caller The caller address\n/// @param drawManager The drawManager address\nerror CallerNotDrawManager(address caller, address drawManager);\n\n/**\n * @notice Constructor Parameters\n * @param prizeToken The token to use for prizes\n * @param twabController The Twab Controller to retrieve time-weighted average balances from\n * @param drawManager The address of the draw manager for the prize pool\n * @param drawPeriodSeconds The number of seconds between draws. E.g. a Prize Pool with a daily draw should have a draw period of 86400 seconds.\n * @param firstDrawStartsAt The timestamp at which the first draw will start.\n * @param numberOfTiers The number of tiers to start with. Must be greater than or equal to the minimum number of tiers.\n * @param tierShares The number of shares to allocate to each tier\n * @param canaryShares The number of shares to allocate to the canary tier.\n * @param reserveShares The number of shares to allocate to the reserve.\n * @param claimExpansionThreshold The percentage of prizes that must be claimed to bump the number of tiers. This threshold is used for both standard prizes and canary prizes.\n * @param smoothing The amount of smoothing to apply to vault contributions. Must be less than 1. A value of 0 is no smoothing, while greater values smooth until approaching infinity\n */\nstruct ConstructorParams {\n  IERC20 prizeToken;\n  TwabController twabController;\n  address drawManager;\n  uint32 drawPeriodSeconds;\n  uint64 firstDrawStartsAt;\n  uint8 numberOfTiers;\n  uint8 tierShares;\n  uint8 canaryShares;\n  uint8 reserveShares;\n  UD2x18 claimExpansionThreshold;\n  SD1x18 smoothing;\n}\n\n/**\n * @title PoolTogether V5 Prize Pool\n * @author PoolTogether Inc Team\n * @notice The Prize Pool holds the prize liquidity and allows vaults to claim prizes.\n */\ncontract PrizePool is TieredLiquidityDistributor {\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /// @notice Emitted when a prize is claimed.\n  /// @param vault The address of the vault that claimed the prize.\n  /// @param winner The address of the winner\n  /// @param recipient The address of the prize recipient\n  /// @param drawId The draw ID of the draw that was claimed.\n  /// @param tier The prize tier that was claimed.\n  /// @param payout The amount of prize tokens that were paid out to the winner\n  /// @param fee The amount of prize tokens that were paid to the claimer\n  /// @param feeRecipient The address that the claim fee was sent to\n  event ClaimedPrize(\n    address indexed vault,\n    address indexed winner,\n    address indexed recipient,\n    uint16 drawId,\n    uint8 tier,\n    uint32 prizeIndex,\n    uint152 payout,\n    uint96 fee,\n    address feeRecipient\n  );\n\n  /// @notice Emitted when a draw is closed.\n  /// @param drawId The ID of the draw that was closed\n  /// @param winningRandomNumber The winning random number for the closed draw\n  /// @param numTiers The number of prize tiers in the closed draw\n  /// @param nextNumTiers The number of tiers for the next draw\n  /// @param reserve The resulting reserve available for the next draw\n  /// @param prizeTokensPerShare The amount of prize tokens per share for the next draw\n  /// @param drawStartedAt The start timestamp of the draw\n  event DrawClosed(\n    uint16 indexed drawId,\n    uint256 winningRandomNumber,\n    uint8 numTiers,\n    uint8 nextNumTiers,\n    uint104 reserve,\n    UD34x4 prizeTokensPerShare,\n    uint64 drawStartedAt\n  );\n\n  /// @notice Emitted when any amount of the reserve is withdrawn.\n  /// @param to The address the assets are transferred to\n  /// @param amount The amount of assets transferred\n  event WithdrawReserve(address indexed to, uint256 amount);\n\n  /// @notice Emitted when the reserve is manually increased.\n  /// @param user The user who increased the reserve\n  /// @param amount The amount of assets transferred\n  event IncreaseReserve(address user, uint256 amount);\n\n  /// @notice Emitted when a vault contributes prize tokens to the pool.\n  /// @param vault The address of the vault that is contributing tokens\n  /// @param drawId The ID of the first draw that the tokens will be applied to\n  /// @param amount The amount of tokens contributed\n  event ContributePrizeTokens(address indexed vault, uint16 indexed drawId, uint256 amount);\n\n  /// @notice Emitted when an address withdraws their prize claim rewards.\n  /// @param to The address the rewards are sent to\n  /// @param amount The amount withdrawn\n  /// @param available The total amount that was available to withdraw before the transfer\n  event WithdrawClaimRewards(address indexed to, uint256 amount, uint256 available);\n\n  /// @notice Emitted when an address receives new prize claim rewards.\n  /// @param to The address the rewards are given to\n  /// @param amount The amount increased\n  event IncreaseClaimRewards(address indexed to, uint256 amount);\n\n  /// @notice Emitted when the drawManager is set.\n  /// @param drawManager The draw manager\n  event DrawManagerSet(address indexed drawManager);\n\n  /* ============ State ============ */\n\n  /// @notice The DrawAccumulator that tracks the exponential moving average of the contributions by a vault.\n  mapping(address => DrawAccumulatorLib.Accumulator) internal vaultAccumulator;\n\n  /// @notice Records the claim record for a winner.\n  /// @dev vault => account => drawId => tier => prizeIndex => claimed\n  mapping(address => mapping(address => mapping(uint16 => mapping(uint8 => mapping(uint32 => bool)))))\n    internal claimedPrizes;\n\n  /// @notice Tracks the total fees accrued to each claimer.\n  mapping(address => uint256) internal claimerRewards;\n\n  /// @notice The degree of POOL contribution smoothing. 0 = no smoothing, ~1 = max smoothing. Smoothing spreads out vault contribution over multiple draws; the higher the smoothing the more draws.\n  SD1x18 public immutable smoothing;\n\n  /// @notice The token that is being contributed and awarded as prizes.\n  IERC20 public immutable prizeToken;\n\n  /// @notice The Twab Controller to use to retrieve historic balances.\n  TwabController public immutable twabController;\n\n  /// @notice The draw manager address.\n  address public drawManager;\n\n  /// @notice The number of seconds between draws.\n  uint32 public immutable drawPeriodSeconds;\n\n  /// @notice Percentage of prizes that must be claimed to bump the number of tiers.\n  UD2x18 public immutable claimExpansionThreshold;\n\n  /// @notice The exponential weighted average of all vault contributions.\n  DrawAccumulatorLib.Accumulator internal totalAccumulator;\n\n  /// @notice The total amount of prize tokens that have been claimed for all time.\n  uint256 internal _totalWithdrawn;\n\n  /// @notice The winner random number for the last closed draw.\n  uint256 internal _winningRandomNumber;\n\n  /// @notice The number of prize claims for the last closed draw.\n  uint32 public claimCount;\n\n  /// @notice The number of canary prize claims for the last closed draw.\n  uint32 public canaryClaimCount;\n\n  /// @notice The largest tier claimed so far for the last closed draw.\n  uint8 public largestTierClaimed;\n\n  /// @notice The timestamp at which the last closed draw started.\n  uint64 internal _lastClosedDrawStartedAt;\n\n  /// @notice The timestamp at which the last closed draw was awarded.\n  uint64 internal _lastClosedDrawAwardedAt;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Constructs a new Prize Pool.\n  /// @param params A struct of constructor parameters\n  constructor(\n    ConstructorParams memory params\n  )\n    TieredLiquidityDistributor(\n      params.numberOfTiers,\n      params.tierShares,\n      params.canaryShares,\n      params.reserveShares\n    )\n  {\n    if (unwrap(params.smoothing) >= unwrap(UNIT)) {\n      revert SmoothingGTEOne(unwrap(params.smoothing));\n    }\n    prizeToken = params.prizeToken;\n    twabController = params.twabController;\n    smoothing = params.smoothing;\n    claimExpansionThreshold = params.claimExpansionThreshold;\n    drawPeriodSeconds = params.drawPeriodSeconds;\n    _lastClosedDrawStartedAt = params.firstDrawStartsAt;\n\n    drawManager = params.drawManager;\n    if (params.drawManager != address(0)) {\n      emit DrawManagerSet(params.drawManager);\n    }\n  }\n\n  /* ============ Modifiers ============ */\n\n  /// @notice Modifier that throws if sender is not the draw manager.\n  modifier onlyDrawManager() {\n    if (msg.sender != drawManager) {\n      revert CallerNotDrawManager(msg.sender, drawManager);\n    }\n    _;\n  }\n\n  /* ============ External Write Functions ============ */\n\n  /// @notice Allows a caller to set the DrawManager if not already set.\n  /// @dev Notice that this can be front-run: make sure to verify the drawManager after construction\n  /// @param _drawManager The draw manager\n  function setDrawManager(address _drawManager) external {\n    if (drawManager != address(0)) {\n      revert DrawManagerAlreadySet();\n    }\n    drawManager = _drawManager;\n\n    emit DrawManagerSet(_drawManager);\n  }\n\n  /// @notice Contributes prize tokens on behalf of the given vault. The tokens should have already been transferred to the prize pool.\n  /// The prize pool balance will be checked to ensure there is at least the given amount to deposit.\n  /// @return The amount of available prize tokens prior to the contribution.\n  function contributePrizeTokens(address _prizeVault, uint256 _amount) external returns (uint256) {\n    uint256 _deltaBalance = prizeToken.balanceOf(address(this)) - _accountedBalance();\n    if (_deltaBalance < _amount) {\n      revert ContributionGTDeltaBalance(_amount, _deltaBalance);\n    }\n    DrawAccumulatorLib.add(\n      vaultAccumulator[_prizeVault],\n      _amount,\n      lastClosedDrawId + 1,\n      smoothing.intoSD59x18()\n    );\n    DrawAccumulatorLib.add(\n      totalAccumulator,\n      _amount,\n      lastClosedDrawId + 1,\n      smoothing.intoSD59x18()\n    );\n    emit ContributePrizeTokens(_prizeVault, lastClosedDrawId + 1, _amount);\n    return _deltaBalance;\n  }\n\n  /// @notice Allows the Manager to withdraw tokens from the reserve.\n  /// @param _to The address to send the tokens to\n  /// @param _amount The amount of tokens to withdraw\n  function withdrawReserve(address _to, uint104 _amount) external onlyDrawManager {\n    if (_amount > _reserve) {\n      revert InsufficientReserve(_amount, _reserve);\n    }\n    _reserve -= _amount;\n    _transfer(_to, _amount);\n    emit WithdrawReserve(_to, _amount);\n  }\n\n  /// @notice Allows the Manager to close the current open draw and open the next one.\n  ///         Updates the number of tiers, the winning random number and the prize pool reserve.\n  /// @param winningRandomNumber_ The winning random number for the current draw\n  /// @return The ID of the closed draw\n  function closeDraw(uint256 winningRandomNumber_) external onlyDrawManager returns (uint16) {\n    // check winning random number\n    if (winningRandomNumber_ == 0) {\n      revert RandomNumberIsZero();\n    }\n    if (block.timestamp < _openDrawEndsAt()) {\n      revert DrawNotFinished(_openDrawEndsAt(), uint64(block.timestamp));\n    }\n\n    uint8 _numTiers = numberOfTiers;\n    uint8 _nextNumberOfTiers = _numTiers;\n\n    if (lastClosedDrawId != 0) {\n      _nextNumberOfTiers = _computeNextNumberOfTiers(_numTiers);\n    }\n\n    uint64 openDrawStartedAt_ = _openDrawStartedAt();\n\n    _nextDraw(_nextNumberOfTiers, uint96(_contributionsForDraw(lastClosedDrawId + 1)));\n\n    _winningRandomNumber = winningRandomNumber_;\n    claimCount = 0;\n    canaryClaimCount = 0;\n    largestTierClaimed = 0;\n    _lastClosedDrawStartedAt = openDrawStartedAt_;\n    _lastClosedDrawAwardedAt = uint64(block.timestamp);\n\n    emit DrawClosed(\n      lastClosedDrawId,\n      winningRandomNumber_,\n      _numTiers,\n      _nextNumberOfTiers,\n      _reserve,\n      prizeTokenPerShare,\n      _lastClosedDrawStartedAt\n    );\n\n    return lastClosedDrawId;\n  }\n\n  /**\n   * @dev Claims a prize for a given winner and tier.\n   * This function takes in an address _winner, a uint8 _tier, a uint96 _fee, and an\n   * address _feeRecipient. It checks if _winner is actually the winner of the _tier for the calling vault.\n   * If so, it calculates the prize size and transfers it to the winner. If not, it reverts with an error message.\n   * The function then checks the claim record of _winner to see if they have already claimed the prize for the\n   * current draw. If not, it updates the claim record with the claimed tier and emits a ClaimedPrize event with\n   * information about the claim.\n   * Note that this function can modify the state of the contract by updating the claim record, changing the largest\n   * tier claimed and the claim count, and transferring prize tokens. The function is marked as external which\n   * means that it can be called from outside the contract.\n   * @param _tier The tier of the prize to be claimed.\n   * @param _winner The address of the eligible winner\n   * @param _prizeIndex The prize to claim for the winner. Must be less than the prize count for the tier.\n   * @param _prizeRecipient The recipient of the prize\n   * @par"
    }
  ]
}