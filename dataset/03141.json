{
  "Title": "Missed events",
  "Content": "##### Description\nThere are missed events for claim, deposit, withdraw, join/quit farming.\nhttps://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/FarmingPool.sol#L66\nhttps://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/FarmingPool.sol#L72\nhttps://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/FarmingPool.sol#L78\nhttps://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/ERC20Farmable.sol#L58\nhttps://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/ERC20Farmable.sol#L75\nhttps://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/ERC20Farmable.sol#L93\n##### Recommendation\nWe recommend emitting the events above.\n\n***\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/FarmingPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IFarmingPool.sol\";\nimport \"./accounting/FarmAccounting.sol\";\nimport \"./accounting/UserAccounting.sol\";\n\ncontract FarmingPool is IFarmingPool, Ownable, ERC20 {\n    using SafeERC20 for IERC20;\n    using FarmAccounting for FarmAccounting.Info;\n    using UserAccounting for UserAccounting.Info;\n\n    event DistributorChanged(address oldDistributor, address newDistributor);\n    event RewardAdded(uint256 reward, uint256 duration);\n\n    IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardsToken;\n\n    address public distributor;\n    FarmAccounting.Info public farmInfo;\n    UserAccounting.Info public userInfo;\n\n    constructor(IERC20Metadata stakingToken_, IERC20 rewardsToken_)\n        ERC20(\n            string(abi.encodePacked(\"Farming of \", stakingToken_.name())),\n            string(abi.encodePacked(\"farm\", stakingToken_.symbol()))\n        )\n    {\n        stakingToken = stakingToken_;\n        rewardsToken = rewardsToken_;\n    }\n\n    function setDistributor(address distributor_) external onlyOwner {\n        address oldDistributor = distributor;\n        require(distributor_ != oldDistributor, \"FP: distributor is already set\");\n        emit DistributorChanged(oldDistributor, distributor_);\n        distributor = distributor_;\n    }\n\n    function startFarming(uint256 amount, uint256 period) external {\n        require(msg.sender == distributor, \"FP: access denied\");\n        rewardsToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 reward = farmInfo.startFarming(amount, period, _updateCheckpoint);\n        emit RewardAdded(reward, period);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(address(stakingToken)).decimals();\n    }\n\n    function farmedPerToken() public view override returns (uint256) {\n        return userInfo.farmedPerToken(address(0), _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address account) external view override returns (uint256) {\n        return userInfo.farmed(account, balanceOf(account), farmedPerToken());\n    }\n\n    function deposit(uint256 amount) external override {\n        require(amount > 0, \"FP: zero deposit\");\n        _mint(msg.sender, amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public override {\n        require(amount > 0, \"FP: zero withdraw\");\n        _burn(msg.sender, amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n    }\n\n    function claim() public override {\n        uint256 fpt = farmedPerToken();\n        uint256 balance = balanceOf(msg.sender);\n        uint256 amount = userInfo.farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            userInfo.eraseFarmed(msg.sender, balance, fpt);\n            rewardsToken.safeTransfer(msg.sender, amount);\n        }\n    }\n\n    function exit() external override {\n        withdraw(balanceOf(msg.sender));\n        claim();\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            userInfo.updateBalances(farmedPerToken(), from, to, amount, from != address(0), to != address(0));\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address /* context */) private view returns(uint256) {\n        return totalSupply();\n    }\n\n    function _lazyGetFarmed(address /* context */, uint256 checkpoint) private view returns(uint256) {\n        return farmInfo.farmedSinceCheckpointScaled(checkpoint);\n    }\n\n    // FarmAccounting bindings\n\n    function _updateCheckpoint() private {\n        userInfo.updateCheckpoint(farmedPerToken());\n    }\n}"
    },
    {
      "filename": "contracts/FarmingPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IFarmingPool.sol\";\nimport \"./accounting/FarmAccounting.sol\";\nimport \"./accounting/UserAccounting.sol\";\n\ncontract FarmingPool is IFarmingPool, Ownable, ERC20 {\n    using SafeERC20 for IERC20;\n    using FarmAccounting for FarmAccounting.Info;\n    using UserAccounting for UserAccounting.Info;\n\n    event DistributorChanged(address oldDistributor, address newDistributor);\n    event RewardAdded(uint256 reward, uint256 duration);\n\n    IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardsToken;\n\n    address public distributor;\n    FarmAccounting.Info public farmInfo;\n    UserAccounting.Info public userInfo;\n\n    constructor(IERC20Metadata stakingToken_, IERC20 rewardsToken_)\n        ERC20(\n            string(abi.encodePacked(\"Farming of \", stakingToken_.name())),\n            string(abi.encodePacked(\"farm\", stakingToken_.symbol()))\n        )\n    {\n        stakingToken = stakingToken_;\n        rewardsToken = rewardsToken_;\n    }\n\n    function setDistributor(address distributor_) external onlyOwner {\n        address oldDistributor = distributor;\n        require(distributor_ != oldDistributor, \"FP: distributor is already set\");\n        emit DistributorChanged(oldDistributor, distributor_);\n        distributor = distributor_;\n    }\n\n    function startFarming(uint256 amount, uint256 period) external {\n        require(msg.sender == distributor, \"FP: access denied\");\n        rewardsToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 reward = farmInfo.startFarming(amount, period, _updateCheckpoint);\n        emit RewardAdded(reward, period);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(address(stakingToken)).decimals();\n    }\n\n    function farmedPerToken() public view override returns (uint256) {\n        return userInfo.farmedPerToken(address(0), _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address account) external view override returns (uint256) {\n        return userInfo.farmed(account, balanceOf(account), farmedPerToken());\n    }\n\n    function deposit(uint256 amount) external override {\n        require(amount > 0, \"FP: zero deposit\");\n        _mint(msg.sender, amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public override {\n        require(amount > 0, \"FP: zero withdraw\");\n        _burn(msg.sender, amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n    }\n\n    function claim() public override {\n        uint256 fpt = farmedPerToken();\n        uint256 balance = balanceOf(msg.sender);\n        uint256 amount = userInfo.farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            userInfo.eraseFarmed(msg.sender, balance, fpt);\n            rewardsToken.safeTransfer(msg.sender, amount);\n        }\n    }\n\n    function exit() external override {\n        withdraw(balanceOf(msg.sender));\n        claim();\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            userInfo.updateBalances(farmedPerToken(), from, to, amount, from != address(0), to != address(0));\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address /* context */) private view returns(uint256) {\n        return totalSupply();\n    }\n\n    function _lazyGetFarmed(address /* context */, uint256 checkpoint) private view returns(uint256) {\n        return farmInfo.farmedSinceCheckpointScaled(checkpoint);\n    }\n\n    // FarmAccounting bindings\n\n    function _updateCheckpoint() private {\n        userInfo.updateCheckpoint(farmedPerToken());\n    }\n}"
    },
    {
      "filename": "contracts/FarmingPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IFarmingPool.sol\";\nimport \"./accounting/FarmAccounting.sol\";\nimport \"./accounting/UserAccounting.sol\";\n\ncontract FarmingPool is IFarmingPool, Ownable, ERC20 {\n    using SafeERC20 for IERC20;\n    using FarmAccounting for FarmAccounting.Info;\n    using UserAccounting for UserAccounting.Info;\n\n    event DistributorChanged(address oldDistributor, address newDistributor);\n    event RewardAdded(uint256 reward, uint256 duration);\n\n    IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardsToken;\n\n    address public distributor;\n    FarmAccounting.Info public farmInfo;\n    UserAccounting.Info public userInfo;\n\n    constructor(IERC20Metadata stakingToken_, IERC20 rewardsToken_)\n        ERC20(\n            string(abi.encodePacked(\"Farming of \", stakingToken_.name())),\n            string(abi.encodePacked(\"farm\", stakingToken_.symbol()))\n        )\n    {\n        stakingToken = stakingToken_;\n        rewardsToken = rewardsToken_;\n    }\n\n    function setDistributor(address distributor_) external onlyOwner {\n        address oldDistributor = distributor;\n        require(distributor_ != oldDistributor, \"FP: distributor is already set\");\n        emit DistributorChanged(oldDistributor, distributor_);\n        distributor = distributor_;\n    }\n\n    function startFarming(uint256 amount, uint256 period) external {\n        require(msg.sender == distributor, \"FP: access denied\");\n        rewardsToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 reward = farmInfo.startFarming(amount, period, _updateCheckpoint);\n        emit RewardAdded(reward, period);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(address(stakingToken)).decimals();\n    }\n\n    function farmedPerToken() public view override returns (uint256) {\n        return userInfo.farmedPerToken(address(0), _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address account) external view override returns (uint256) {\n        return userInfo.farmed(account, balanceOf(account), farmedPerToken());\n    }\n\n    function deposit(uint256 amount) external override {\n        require(amount > 0, \"FP: zero deposit\");\n        _mint(msg.sender, amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public override {\n        require(amount > 0, \"FP: zero withdraw\");\n        _burn(msg.sender, amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n    }\n\n    function claim() public override {\n        uint256 fpt = farmedPerToken();\n        uint256 balance = balanceOf(msg.sender);\n        uint256 amount = userInfo.farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            userInfo.eraseFarmed(msg.sender, balance, fpt);\n            rewardsToken.safeTransfer(msg.sender, amount);\n        }\n    }\n\n    function exit() external override {\n        withdraw(balanceOf(msg.sender));\n        claim();\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            userInfo.updateBalances(farmedPerToken(), from, to, amount, from != address(0), to != address(0));\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address /* context */) private view returns(uint256) {\n        return totalSupply();\n    }\n\n    function _lazyGetFarmed(address /* context */, uint256 checkpoint) private view returns(uint256) {\n        return farmInfo.farmedSinceCheckpointScaled(checkpoint);\n    }\n\n    // FarmAccounting bindings\n\n    function _updateCheckpoint() private {\n        userInfo.updateCheckpoint(farmedPerToken());\n    }\n}"
    },
    {
      "filename": "contracts/ERC20Farmable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\";\n\nimport \"./interfaces/IERC20Farmable.sol\";\nimport \"./accounting/UserAccounting.sol\";\nimport \"./accounting/FarmAccounting.sol\";\n\nabstract contract ERC20Farmable is ERC20, IERC20Farmable {\n    using AddressArray for AddressArray.Data;\n    using AddressSet for AddressSet.Data;\n    using UserAccounting for UserAccounting.Info;\n\n    mapping(address => UserAccounting.Info) private _userInfo;\n    mapping(address => uint256) private _farmTotalSupply;\n    mapping(address => AddressSet.Data) private _userFarms;\n\n    /// @dev Use this method for signaling on bad farms even in static calls (for stats)\n    function onError(string memory /* error */) external view {\n        require(msg.sender == address(this), \"ERC20F: access denied\");\n    }\n\n    function farmTotalSupply(address farm_) public view virtual returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function farmBalanceOf(address farm_, address account) public view virtual returns (uint256) {\n        return _userFarms[account].contains(farm_) ? balanceOf(account) : 0;\n    }\n\n    function userIsFarming(address account, address farm_) public view virtual returns(bool) {\n        return _userFarms[account].contains(farm_);\n    }\n\n    function userFarmsCount(address account) public view virtual returns(uint256) {\n        return _userFarms[account].length();\n    }\n\n    function userFarmsAt(address account, uint256 index) public view virtual returns(address) {\n        return _userFarms[account].at(index);\n    }\n\n    function userFarms(address account) public view virtual returns(address[] memory) {\n        return _userFarms[account].items.get();\n    }\n\n    function farmedPerToken(address farm_) public view virtual returns(uint256 fpt) {\n        return _userInfo[farm_].farmedPerToken(farm_, _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address farm_, address account) public view virtual returns(uint256) {\n        return _userInfo[farm_].farmed(account, farmBalanceOf(farm_, account), farmedPerToken(farm_));\n    }\n\n    function join(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].add(farm_), \"ERC20F: already farming\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), address(0), msg.sender, balance, false, true);\n        _farmTotalSupply[farm_] += balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function quitAll() public virtual {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        for (uint256 i = 0; i < farms.length; i++) {\n            quit(farms[i]);\n        }\n    }\n\n    function quit(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].remove(address(farm_)), \"ERC20F: already exited\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), msg.sender, address(0), balance, true, false);\n        _farmTotalSupply[farm_] -= balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function claimAll() public virtual returns(uint256[] memory amounts) {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        amounts = new uint256[](farms.length);\n        for (uint256 i = 0; i < farms.length; i++) {\n            amounts[i] = claim(farms[i]);\n        }\n    }\n\n    function claim(address farm_) public virtual returns(uint256) {\n        uint256 fpt = farmedPerToken(farm_);\n        uint256 balance = farmBalanceOf(farm_, msg.sender);\n        uint256 amount = _userInfo[farm_].farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            _userInfo[farm_].eraseFarmed(msg.sender, balance, fpt);\n            IFarm(farm_).claimFor(msg.sender, amount);\n        }\n        return amount;\n    }\n\n    function updateCheckpoint() public virtual {\n        _userInfo[msg.sender].updateCheckpoint(farmedPerToken(msg.sender));\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override virtual {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            address[] memory a = _userFarms[from].items.get();\n            address[] memory b = _userFarms[to].items.get();\n\n            for (uint256 i = 0; i < a.length; i++) {\n                address farm_ = a[i];\n\n                uint256 j;\n                for (j = 0; j < b.length; j++) {\n                    if (farm_ == b[j]) {\n                        // Both parties are farming the same token\n                        _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, true);\n                        b[j] = address(0);\n                        break;\n                    }\n                }\n\n                if (j == b.length) {\n                    // Sender is farming a token, but receiver is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, false);\n                    _farmTotalSupply[farm_] -= amount;\n                }\n            }\n\n            for (uint256 j = 0; j < b.length; j++) {\n                address farm_ = b[j];\n                if (farm_ != address(0)) {\n                    // Receiver is farming a token, but sender is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, false, true);\n                    _farmTotalSupply[farm_] += amount;\n                }\n            }\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address farm_) internal view returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function _lazyGetFarmed(address farm_, uint256 checkpoint) internal view returns(uint256) {\n        try IFarm(farm_).farmedSinceCheckpointScaled{ gas: 200_000 }(checkpoint) returns(uint256 amount) {\n            if (amount <= FarmAccounting._MAX_REWARD_AMOUNT * 1e18) {\n                return amount;\n            }\n            else {\n                this.onError(\"farm.farmedSinceCheckpoint() result overflowed\");\n            }\n        }\n        catch {\n            this.onError(\"farm.farmedSinceCheckpoint() failed\");\n        }\n        return 0;\n    }\n}"
    },
    {
      "filename": "contracts/ERC20Farmable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\";\n\nimport \"./interfaces/IERC20Farmable.sol\";\nimport \"./accounting/UserAccounting.sol\";\nimport \"./accounting/FarmAccounting.sol\";\n\nabstract contract ERC20Farmable is ERC20, IERC20Farmable {\n    using AddressArray for AddressArray.Data;\n    using AddressSet for AddressSet.Data;\n    using UserAccounting for UserAccounting.Info;\n\n    mapping(address => UserAccounting.Info) private _userInfo;\n    mapping(address => uint256) private _farmTotalSupply;\n    mapping(address => AddressSet.Data) private _userFarms;\n\n    /// @dev Use this method for signaling on bad farms even in static calls (for stats)\n    function onError(string memory /* error */) external view {\n        require(msg.sender == address(this), \"ERC20F: access denied\");\n    }\n\n    function farmTotalSupply(address farm_) public view virtual returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function farmBalanceOf(address farm_, address account) public view virtual returns (uint256) {\n        return _userFarms[account].contains(farm_) ? balanceOf(account) : 0;\n    }\n\n    function userIsFarming(address account, address farm_) public view virtual returns(bool) {\n        return _userFarms[account].contains(farm_);\n    }\n\n    function userFarmsCount(address account) public view virtual returns(uint256) {\n        return _userFarms[account].length();\n    }\n\n    function userFarmsAt(address account, uint256 index) public view virtual returns(address) {\n        return _userFarms[account].at(index);\n    }\n\n    function userFarms(address account) public view virtual returns(address[] memory) {\n        return _userFarms[account].items.get();\n    }\n\n    function farmedPerToken(address farm_) public view virtual returns(uint256 fpt) {\n        return _userInfo[farm_].farmedPerToken(farm_, _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address farm_, address account) public view virtual returns(uint256) {\n        return _userInfo[farm_].farmed(account, farmBalanceOf(farm_, account), farmedPerToken(farm_));\n    }\n\n    function join(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].add(farm_), \"ERC20F: already farming\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), address(0), msg.sender, balance, false, true);\n        _farmTotalSupply[farm_] += balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function quitAll() public virtual {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        for (uint256 i = 0; i < farms.length; i++) {\n            quit(farms[i]);\n        }\n    }\n\n    function quit(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].remove(address(farm_)), \"ERC20F: already exited\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), msg.sender, address(0), balance, true, false);\n        _farmTotalSupply[farm_] -= balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function claimAll() public virtual returns(uint256[] memory amounts) {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        amounts = new uint256[](farms.length);\n        for (uint256 i = 0; i < farms.length; i++) {\n            amounts[i] = claim(farms[i]);\n        }\n    }\n\n    function claim(address farm_) public virtual returns(uint256) {\n        uint256 fpt = farmedPerToken(farm_);\n        uint256 balance = farmBalanceOf(farm_, msg.sender);\n        uint256 amount = _userInfo[farm_].farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            _userInfo[farm_].eraseFarmed(msg.sender, balance, fpt);\n            IFarm(farm_).claimFor(msg.sender, amount);\n        }\n        return amount;\n    }\n\n    function updateCheckpoint() public virtual {\n        _userInfo[msg.sender].updateCheckpoint(farmedPerToken(msg.sender));\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override virtual {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            address[] memory a = _userFarms[from].items.get();\n            address[] memory b = _userFarms[to].items.get();\n\n            for (uint256 i = 0; i < a.length; i++) {\n                address farm_ = a[i];\n\n                uint256 j;\n                for (j = 0; j < b.length; j++) {\n                    if (farm_ == b[j]) {\n                        // Both parties are farming the same token\n                        _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, true);\n                        b[j] = address(0);\n                        break;\n                    }\n                }\n\n                if (j == b.length) {\n                    // Sender is farming a token, but receiver is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, false);\n                    _farmTotalSupply[farm_] -= amount;\n                }\n            }\n\n            for (uint256 j = 0; j < b.length; j++) {\n                address farm_ = b[j];\n                if (farm_ != address(0)) {\n                    // Receiver is farming a token, but sender is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, false, true);\n                    _farmTotalSupply[farm_] += amount;\n                }\n            }\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address farm_) internal view returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function _lazyGetFarmed(address farm_, uint256 checkpoint) internal view returns(uint256) {\n        try IFarm(farm_).farmedSinceCheckpointScaled{ gas: 200_000 }(checkpoint) returns(uint256 amount) {\n            if (amount <= FarmAccounting._MAX_REWARD_AMOUNT * 1e18) {\n                return amount;\n            }\n            else {\n                this.onError(\"farm.farmedSinceCheckpoint() result overflowed\");\n            }\n        }\n        catch {\n            this.onError(\"farm.farmedSinceCheckpoint() failed\");\n        }\n        return 0;\n    }\n}"
    },
    {
      "filename": "contracts/ERC20Farmable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\";\n\nimport \"./interfaces/IERC20Farmable.sol\";\nimport \"./accounting/UserAccounting.sol\";\nimport \"./accounting/FarmAccounting.sol\";\n\nabstract contract ERC20Farmable is ERC20, IERC20Farmable {\n    using AddressArray for AddressArray.Data;\n    using AddressSet for AddressSet.Data;\n    using UserAccounting for UserAccounting.Info;\n\n    mapping(address => UserAccounting.Info) private _userInfo;\n    mapping(address => uint256) private _farmTotalSupply;\n    mapping(address => AddressSet.Data) private _userFarms;\n\n    /// @dev Use this method for signaling on bad farms even in static calls (for stats)\n    function onError(string memory /* error */) external view {\n        require(msg.sender == address(this), \"ERC20F: access denied\");\n    }\n\n    function farmTotalSupply(address farm_) public view virtual returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function farmBalanceOf(address farm_, address account) public view virtual returns (uint256) {\n        return _userFarms[account].contains(farm_) ? balanceOf(account) : 0;\n    }\n\n    function userIsFarming(address account, address farm_) public view virtual returns(bool) {\n        return _userFarms[account].contains(farm_);\n    }\n\n    function userFarmsCount(address account) public view virtual returns(uint256) {\n        return _userFarms[account].length();\n    }\n\n    function userFarmsAt(address account, uint256 index) public view virtual returns(address) {\n        return _userFarms[account].at(index);\n    }\n\n    function userFarms(address account) public view virtual returns(address[] memory) {\n        return _userFarms[account].items.get();\n    }\n\n    function farmedPerToken(address farm_) public view virtual returns(uint256 fpt) {\n        return _userInfo[farm_].farmedPerToken(farm_, _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address farm_, address account) public view virtual returns(uint256) {\n        return _userInfo[farm_].farmed(account, farmBalanceOf(farm_, account), farmedPerToken(farm_));\n    }\n\n    function join(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].add(farm_), \"ERC20F: already farming\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), address(0), msg.sender, balance, false, true);\n        _farmTotalSupply[farm_] += balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function quitAll() public virtual {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        for (uint256 i = 0; i < farms.length; i++) {\n            quit(farms[i]);\n        }\n    }\n\n    function quit(address farm_) public virtual returns(uint256) {\n        require(farm_ != address(0), \"ERC20F: farm is zero\");\n        require(_userFarms[msg.sender].remove(address(farm_)), \"ERC20F: already exited\");\n\n        uint256 balance = balanceOf(msg.sender);\n        _userInfo[farm_].updateBalances(farmedPerToken(farm_), msg.sender, address(0), balance, true, false);\n        _farmTotalSupply[farm_] -= balance;\n        return _userFarms[msg.sender].length();\n    }\n\n    function claimAll() public virtual returns(uint256[] memory amounts) {\n        address[] memory farms = _userFarms[msg.sender].items.get();\n        amounts = new uint256[](farms.length);\n        for (uint256 i = 0; i < farms.length; i++) {\n            amounts[i] = claim(farms[i]);\n        }\n    }\n\n    function claim(address farm_) public virtual returns(uint256) {\n        uint256 fpt = farmedPerToken(farm_);\n        uint256 balance = farmBalanceOf(farm_, msg.sender);\n        uint256 amount = _userInfo[farm_].farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            _userInfo[farm_].eraseFarmed(msg.sender, balance, fpt);\n            IFarm(farm_).claimFor(msg.sender, amount);\n        }\n        return amount;\n    }\n\n    function updateCheckpoint() public virtual {\n        _userInfo[msg.sender].updateCheckpoint(farmedPerToken(msg.sender));\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override virtual {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            address[] memory a = _userFarms[from].items.get();\n            address[] memory b = _userFarms[to].items.get();\n\n            for (uint256 i = 0; i < a.length; i++) {\n                address farm_ = a[i];\n\n                uint256 j;\n                for (j = 0; j < b.length; j++) {\n                    if (farm_ == b[j]) {\n                        // Both parties are farming the same token\n                        _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, true);\n                        b[j] = address(0);\n                        break;\n                    }\n                }\n\n                if (j == b.length) {\n                    // Sender is farming a token, but receiver is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, true, false);\n                    _farmTotalSupply[farm_] -= amount;\n                }\n            }\n\n            for (uint256 j = 0; j < b.length; j++) {\n                address farm_ = b[j];\n                if (farm_ != address(0)) {\n                    // Receiver is farming a token, but sender is not\n                    _userInfo[farm_].updateBalances(farmedPerToken(farm_), from, to, amount, false, true);\n                    _farmTotalSupply[farm_] += amount;\n                }\n            }\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address farm_) internal view returns(uint256) {\n        return _farmTotalSupply[farm_];\n    }\n\n    function _lazyGetFarmed(address farm_, uint256 checkpoint) internal view returns(uint256) {\n        try IFarm(farm_).farmedSinceCheckpointScaled{ gas: 200_000 }(checkpoint) returns(uint256 amount) {\n            if (amount <= FarmAccounting._MAX_REWARD_AMOUNT * 1e18) {\n                return amount;\n            }\n            else {\n                this.onError(\"farm.farmedSinceCheckpoint() result overflowed\");\n            }\n        }\n        catch {\n            this.onError(\"farm.farmedSinceCheckpoint() failed\");\n        }\n        return 0;\n    }\n}"
    }
  ]
}