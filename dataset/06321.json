{
  "Title": "[08] Missing permissions in `getPermissionName()`",
  "Content": "\nThe function `getPermissionName()` retrieves the string equivalent of permissions. This is used for error messages.\nHowever, some permissions are missing.\n\n### Proof of Concept\n[LSP6Utils.sol#L226-L247](https://github.com/lukso-network/lsp-smart-contracts/blob/v0.10.2/contracts/LSP6KeyManager/LSP6Utils.sol#L226-L247)\n```solidity\n    function getPermissionName(bytes32 permission) internal pure returns (string memory errorMessage) {\n        if (permission == _PERMISSION_CHANGEOWNER) return \"TRANSFEROWNERSHIP\";\n        if (permission == _PERMISSION_EDITPERMISSIONS) return \"EDITPERMISSIONS\";\n        if (permission == _PERMISSION_ADDCONTROLLER) return \"ADDCONTROLLER\";\n        if (permission == _PERMISSION_ADDEXTENSIONS) return \"ADDEXTENSIONS\";\n        if (permission == _PERMISSION_CHANGEEXTENSIONS)\n            return \"CHANGEEXTENSIONS\";\n        if (permission == _PERMISSION_ADDUNIVERSALRECEIVERDELEGATE)\n            return \"ADDUNIVERSALRECEIVERDELEGATE\";\n        if (permission == _PERMISSION_CHANGEUNIVERSALRECEIVERDELEGATE)\n            return \"CHANGEUNIVERSALRECEIVERDELEGATE\";\n        if (permission == _PERMISSION_REENTRANCY) return \"REENTRANCY\";\n        if (permission == _PERMISSION_SETDATA) return \"SETDATA\";\n        if (permission == _PERMISSION_CALL) return \"CALL\";\n        if (permission == _PERMISSION_STATICCALL) return \"STATICCALL\";\n        if (permission == _PERMISSION_DELEGATECALL) return \"DELEGATECALL\";\n        if (permission == _PERMISSION_DEPLOY) return \"DEPLOY\";\n        if (permission == _PERMISSION_TRANSFERVALUE) return \"TRANSFERVALUE\";\n        if (permission == _PERMISSION_SIGN) return \"SIGN\";\n    }\n```\n\n### Recommended Mitigation Steps\nAdd the missing permissions:\n```diff\nfunction getPermissionNameComplete(bytes32 permission) internal pure returns (string memory errorMessage) {\n    ...\n+   if (permission == _PERMISSION_SUPER_TRANSFERVALUE) return \"SUPER_TRANSFERVALUE\";\n+   if (permission == _PERMISSION_SUPER_TRANSFERVALUE) return \"SUPER_TRANSFERVALUE\";\n+   if (permission == _PERMISSION_SUPER_CALL) return \"SUPER_CALL\";\n+   if (permission == _PERMISSION_SUPER_STATICCALL) return \"SUPER_STATICCALL\";\n+   if (permission == _PERMISSION_SUPER_DELEGATECALL) return \"SUPER_DELEGATECALL\";\n+   if (permission == _PERMISSION_SUPER_SETDATA) return \"SUPER_SETDATA\";\n+   if (permission == _PERMISSION_ENCRYPT) return \"ENCRYPT\";\n+   if (permission == _PERMISSION_DECRYPT) return \"DECRYPT\";\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "contracts/LSP6KeyManager/LSP6Utils.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {\n    IERC725Y\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\nimport {ILSP6KeyManager} from \"./ILSP6KeyManager.sol\";\n\n// libraries\nimport {LSP2Utils} from \"../LSP2ERC725YJSONSchema/LSP2Utils.sol\";\n\n// constants\nimport \"./LSP6Constants.sol\";\n\nlibrary LSP6Utils {\n    using LSP2Utils for bytes12;\n\n    /**\n     * @dev read the permissions of a `caller` on an ERC725Y `target` contract.\n     * @param target an `IERC725Y` contract where to read the permissions.\n     * @param caller the controller address to read the permissions from.\n     * @return a `bytes32` BitArray containing the permissions of a controller address.\n     */\n    function getPermissionsFor(\n        IERC725Y target,\n        address caller\n    ) internal view returns (bytes32) {\n        bytes memory permissions = target.getData(\n            LSP2Utils.generateMappingWithGroupingKey(\n                _LSP6KEY_ADDRESSPERMISSIONS_PERMISSIONS_PREFIX,\n                bytes20(caller)\n            )\n        );\n\n        return bytes32(permissions);\n    }\n\n    function getAllowedCallsFor(\n        IERC725Y target,\n        address from\n    ) internal view returns (bytes memory) {\n        return\n            target.getData(\n                LSP2Utils.generateMappingWithGroupingKey(\n                    _LSP6KEY_ADDRESSPERMISSIONS_ALLOWEDCALLS_PREFIX,\n                    bytes20(from)\n                )\n            );\n    }\n\n    /**\n     * @dev read the Allowed ERC725Y data keys of a `caller` on an ERC725Y `target` contract.\n     * @param target an `IERC725Y` contract where to read the permissions.\n     * @param caller the controller address to read the permissions from.\n     * @return an abi-encoded array of allowed ERC725 keys that the controller address is allowed to interact with.\n     */\n    function getAllowedERC725YDataKeysFor(\n        IERC725Y target,\n        address caller\n    ) internal view returns (bytes memory) {\n        return\n            target.getData(\n                LSP2Utils.generateMappingWithGroupingKey(\n                    _LSP6KEY_ADDRESSPERMISSIONS_AllowedERC725YDataKeys_PREFIX,\n                    bytes20(caller)\n                )\n            );\n    }\n\n    /**\n     * @dev compare the permissions `addressPermissions` of an address\n     *      to check if they includes the permissions `permissionToCheck`\n     * @param addressPermission the permissions of an address stored on an ERC725 account\n     * @param permissionToCheck the permissions to check\n     * @return true if `addressPermissions` includes `permissionToCheck`, false otherwise\n     */\n    function hasPermission(\n        bytes32 addressPermission,\n        bytes32 permissionToCheck\n    ) internal pure returns (bool) {\n        return (addressPermission & permissionToCheck) == permissionToCheck;\n    }\n\n    /**\n     * @dev same as LSP2Utils.isCompactBytesArray with the additional requirement that each element must be 28 bytes long.\n     *\n     * @param allowedCallsCompacted a compact bytes array of tuples (bytes4,address,bytes4) to check.\n     * @return true if the value passed is a valid compact bytes array of bytes28 elements according to LSP2, false otherwise.\n     */\n    function isCompactBytesArrayOfAllowedCalls(\n        bytes memory allowedCallsCompacted\n    ) internal pure returns (bool) {\n        uint256 pointer = 0;\n\n        while (pointer < allowedCallsCompacted.length) {\n            if (pointer + 1 >= allowedCallsCompacted.length) return false;\n            uint256 elementLength = uint16(\n                bytes2(\n                    abi.encodePacked(\n                        allowedCallsCompacted[pointer],\n                        allowedCallsCompacted[pointer + 1]\n                    )\n                )\n            );\n            // each entries in the allowedCalls (compact) array must be 32 bytes long\n            if (elementLength != 32) return false;\n            pointer += elementLength + 2;\n        }\n        if (pointer == allowedCallsCompacted.length) return true;\n        return false;\n    }\n\n    /**\n     * @dev same as LSP2Utils.isCompactBytesArray with the additional requirement that each element must be from 1 to 32 bytes long.\n     *\n     * @param allowedERC725YDataKeysCompacted a compact bytes array of ERC725Y Data Keys (full bytes32 data keys or bytesN prefix) to check.\n     * @return true if the value passed is a valid compact bytes array of ERC725Y Data Keys, false otherwise.\n     */\n    function isCompactBytesArrayOfAllowedERC725YDataKeys(\n        bytes memory allowedERC725YDataKeysCompacted\n    ) internal pure returns (bool) {\n        uint256 pointer = 0;\n\n        while (pointer < allowedERC725YDataKeysCompacted.length) {\n            if (pointer + 1 >= allowedERC725YDataKeysCompacted.length)\n                return false;\n            uint256 elementLength = uint16(\n                bytes2(\n                    abi.encodePacked(\n                        allowedERC725YDataKeysCompacted[pointer],\n                        allowedERC725YDataKeysCompacted[pointer + 1]\n                    )\n                )\n            );\n            // the length of the allowed data key must be not under 33 bytes and not 0\n            if (elementLength == 0 || elementLength > 32) return false;\n            pointer += elementLength + 2;\n        }\n        if (pointer == allowedERC725YDataKeysCompacted.length) return true;\n        return false;\n    }\n\n    /**\n     * @dev use the `setData(bytes32[],bytes[])` via the KeyManager of the target\n     * @param keyManagerAddress the address of the KeyManager\n     * @param keys the array of data keys\n     * @param values the array of data values\n     */\n    function setDataViaKeyManager(\n        address keyManagerAddress,\n        bytes32[] memory keys,\n        bytes[] memory values\n    ) internal returns (bytes memory result) {\n        bytes memory payload = abi.encodeWithSelector(\n            IERC725Y.setDataBatch.selector,\n            keys,\n            values\n        );\n        result = ILSP6KeyManager(keyManagerAddress).execute(payload);\n    }\n\n    /**\n     * @dev combine multiple permissions into a single bytes32\n     * Make sure that the sum of the values of the input array is less than 2^256-1 to avoid overflow.\n     * @param permissions the array of permissions to combine\n     * @return a bytes32 containing the combined permissions\n     */\n    function combinePermissions(\n        bytes32[] memory permissions\n    ) internal pure returns (bytes32) {\n        uint256 result = 0;\n        for (uint256 i = 0; i < permissions.length; i++) {\n            result += uint256(permissions[i]);\n        }\n        return bytes32(result);\n    }\n\n    /**\n     * @dev Generate a new set of 3 x LSP6 permission data keys to add a new `controller` on `account`\n     * @param account the ERC725Y contract to add the controller into (used to fetch the `LSP6Permissions[]` length)\n     * @param controller the address of the controller to grant permissions to\n     * @param permissions the BitArray of permissions to grant to the controller\n     * @return keys an array of 3 x data keys containing:\n     *  - keys[0] = `AddressPermissions[]` (array length)\n     *  - keys[1] = `AddressPermissions[index]` (where to store the controller address)\n     *  - keys[2] = `AddressPermissions:Permissions:<controller>`\n     *\n     * @return values : an array of 3 x data values containing:\n     *  - values[0] = the new array length of `AddressPermissions[]`\n     *  - values[1] = the address of the controller\n     *  - values[2] = the `permissions` passed as param\n     */\n    function generateNewPermissionsKeys(\n        IERC725Y account,\n        address controller,\n        bytes32 permissions\n    ) internal view returns (bytes32[] memory keys, bytes[] memory values) {\n        keys = new bytes32[](3);\n        values = new bytes[](3);\n\n        uint128 arrayLength = uint128(\n            bytes16(account.getData(_LSP6KEY_ADDRESSPERMISSIONS_ARRAY))\n        );\n        uint128 newArrayLength = arrayLength + 1;\n\n        keys[0] = _LSP6KEY_ADDRESSPERMISSIONS_ARRAY;\n        values[0] = abi.encodePacked(newArrayLength);\n\n        keys[1] = LSP2Utils.generateArrayElementKeyAtIndex(\n            _LSP6KEY_ADDRESSPERMISSIONS_ARRAY,\n            arrayLength\n        );\n        values[1] = abi.encodePacked(controller);\n\n        keys[2] = LSP2Utils.generateMappingWithGroupingKey(\n            _LSP6KEY_ADDRESSPERMISSIONS_PERMISSIONS_PREFIX,\n            bytes20(controller)\n        );\n        values[2] = abi.encodePacked(permissions);\n    }\n\n    /**\n     * @dev returns the name of the permission as a string\n     */\n    function getPermissionName(\n        bytes32 permission\n    ) internal pure returns (string memory errorMessage) {\n        if (permission == _PERMISSION_CHANGEOWNER) return \"TRANSFEROWNERSHIP\";\n        if (permission == _PERMISSION_EDITPERMISSIONS) return \"EDITPERMISSIONS\";\n        if (permission == _PERMISSION_ADDCONTROLLER) return \"ADDCONTROLLER\";\n        if (permission == _PERMISSION_ADDEXTENSIONS) return \"ADDEXTENSIONS\";\n        if (permission == _PERMISSION_CHANGEEXTENSIONS)\n            return \"CHANGEEXTENSIONS\";\n        if (permission == _PERMISSION_ADDUNIVERSALRECEIVERDELEGATE)\n            return \"ADDUNIVERSALRECEIVERDELEGATE\";\n        if (permission == _PERMISSION_CHANGEUNIVERSALRECEIVERDELEGATE)\n            return \"CHANGEUNIVERSALRECEIVERDELEGATE\";\n        if (permission == _PERMISSION_REENTRANCY) return \"REENTRANCY\";\n        if (permission == _PERMISSION_SETDATA) return \"SETDATA\";\n        if (permission == _PERMISSION_CALL) return \"CALL\";\n        if (permission == _PERMISSION_STATICCALL) return \"STATICCALL\";\n        if (permission == _PERMISSION_DELEGATECALL) return \"DELEGATECALL\";\n        if (permission == _PERMISSION_DEPLOY) return \"DEPLOY\";\n        if (permission == _PERMISSION_TRANSFERVALUE) return \"TRANSFERVALUE\";\n        if (permission == _PERMISSION_SIGN) return \"SIGN\";\n    }\n}"
    }
  ]
}