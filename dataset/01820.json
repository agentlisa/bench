{
  "Title": "M-6: An Oracle Signer can never be removed even if he becomes malicious",
  "Content": "# Issue M-6: An Oracle Signer can never be removed even if he becomes malicious \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/205 \n\n## Found by \nChinmay\n## Summary\nThe call flow of removeOracleSIgner incorrectly compares the hash of (\"removeOracleSigner\", account) with the hash of (\"addOracleSigner\", account) for validating that an action is actually initiated. This validation always fails because the hashes can never match. \n\n## Vulnerability Detail\nThe process of removing oracle signers is 2 stage. First function ```signalRemoveOracleSigner``` is called by the TimelockAdmin which stores a time-delayed timestamp corresponding to the keccak256 hash of (\"removeOracleSigner\", account) - a bytes32 value called actionKey in the pendingActions mapping. \n\nThen the Admin needs to call function ```removeOracleSignerAfterSignal``` but this function calls ```_addOracleSignerActionKey``` instead of ```_removeOracleSignerActionKey``` for calculating the bytes32 action key value. Now the actionKey is calculated as keccak256 hash of (\"addOracleSigner\", account) and this hash is used for checking if this action is actually pending by ensuring its timestamp is not zero inside the ```_validateAction``` function called via ```_validateAndClearAction``` function at Line 122. The hash of (\"removeOracleSigner\", account) can never match hash of (\"addOracleSigner\", account) and thus this validation will fail.\n\n```solidity\n function removeOracleSignerAfterSignal(address account) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _addOracleSignerActionKey(account);\n        _validateAndClearAction(actionKey, \"removeOracleSigner\");\n\n        oracleStore.removeSigner(account);\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventEmitter.emitEventLog1(\n            \"RemoveOracleSigner\",\n            actionKey,\n            eventData\n        );\n    }\n```\n\n## Impact\nThe process of removing an Oracle Signer will always revert and this breaks an important safety measure if a certain oracle signer becomes malicious the TimelockAdmin could do nothing(these functions are meant for this). Hence, important functionality is permanently broken.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/06ccd8c7ee4cadc46e3ac412dcf141eefdced42f/gmx-synthetics/contracts/config/Timelock.sol#L117\n\n## Tool used\n\nManual Review\n\n## Recommendation\nReplace the call to _addOracleSignerActionKey at Line 118 by call to _removeOracleSignerActionKey\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/config/Timelock.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../utils/BasicMulticall.sol\";\nimport \"../oracle/OracleStore.sol\";\n\n// @title Timelock\ncontract Timelock is ReentrancyGuard, RoleModule, BasicMulticall {\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    uint256 public constant MAX_TIMELOCK_DELAY = 5 days;\n\n    DataStore public immutable dataStore;\n    EventEmitter public immutable eventEmitter;\n    OracleStore public immutable oracleStore;\n    uint256 public timelockDelay;\n\n    mapping (bytes32 => uint256) public pendingActions;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OracleStore _oracleStore,\n        uint256 _timelockDelay\n    ) RoleModule(_roleStore) {\n        dataStore = _dataStore;\n        eventEmitter = _eventEmitter;\n        oracleStore = _oracleStore;\n        timelockDelay = _timelockDelay;\n    }\n\n    // @dev immediately revoke the role of an account\n    // @param account the account to revoke the role for\n    // @param roleKey the role to revoke\n    function revokeRole(address account, bytes32 roleKey) external onlyTimelockMultisig nonReentrant {\n        roleStore.revokeRole(account, roleKey);\n    }\n\n    // @dev increase the timelock delay\n    // @param the new timelock delay\n    function increaseTimelockDelay(uint256 _timelockDelay) external onlyTimelockAdmin nonReentrant {\n        if (_timelockDelay <= timelockDelay) {\n            revert Errors.InvalidTimelockDelay(_timelockDelay);\n        }\n\n        if (_timelockDelay > MAX_TIMELOCK_DELAY) {\n            revert Errors.MaxTimelockDelayExceeded(_timelockDelay);\n        }\n\n        timelockDelay = _timelockDelay;\n    }\n\n    function signalAddOracleSigner(address account) external onlyTimelockAdmin nonReentrant {\n        if (account == address(0)) {\n            revert Errors.InvalidOracleSigner(account);\n        }\n\n        bytes32 actionKey = _addOracleSignerActionKey(account);\n        _signalPendingAction(actionKey, \"addOracleSigner\");\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventEmitter.emitEventLog1(\n            \"SignalAddOracleSigner\",\n            actionKey,\n            eventData\n        );\n    }\n\n    function addOracleSignerAfterSignal(address account) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _addOracleSignerActionKey(account);\n        _validateAndClearAction(actionKey, \"addOracleSigner\");\n\n        oracleStore.addSigner(account);\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventEmitter.emitEventLog1(\n            \"AddOracleSigner\",\n            actionKey,\n            eventData\n        );\n    }\n\n    function signalRemoveOracleSigner(address account) external onlyTimelockAdmin nonReentrant {\n        if (account == address(0)) {\n            revert Errors.InvalidOracleSigner(account);\n        }\n\n        bytes32 actionKey = _removeOracleSignerActionKey(account);\n        _signalPendingAction(actionKey, \"removeOracleSigner\");\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventEmitter.emitEventLog1(\n            \"SignalRemoveOracleSigner\",\n            actionKey,\n            eventData\n        );\n    }\n\n    function removeOracleSignerAfterSignal(address account) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _addOracleSignerActionKey(account);\n        _validateAndClearAction(actionKey, \"removeOracleSigner\");\n\n        oracleStore.removeSigner(account);\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventEmitter.emitEventLog1(\n            \"RemoveOracleSigner\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev signal setting of the fee receiver\n    // @param account the new fee receiver\n    function signalSetFeeReceiver(address account) external onlyTimelockAdmin nonReentrant {\n        if (account == address(0)) {\n            revert Errors.InvalidFeeReceiver(account);\n        }\n\n        bytes32 actionKey = _setFeeReceiverActionKey(account);\n        _signalPendingAction(actionKey, \"setFeeReceiver\");\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventEmitter.emitEventLog1(\n            \"SignalSetFeeReceiver\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev set the fee receiver\n    // @param account the new fee receiver\n    function setFeeReceiverAfterSignal(address account) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _setFeeReceiverActionKey(account);\n        _validateAndClearAction(actionKey, \"setFeeReceiver\");\n\n        dataStore.setAddress(Keys.FEE_RECEIVER, account);\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventEmitter.emitEventLog1(\n            \"SetFeeReceiver\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev signal granting of a role\n    // @param account the account to grant the role\n    // @param roleKey the role to grant\n    function signalGrantRole(address account, bytes32 roleKey) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _grantRoleActionKey(account, roleKey);\n        _signalPendingAction(actionKey, \"grantRole\");\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"roleKey\", roleKey);\n        eventEmitter.emitEventLog1(\n            \"SignalGrantRole\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev grant a role\n    // @param account the account to grant the role\n    // @param roleKey the role to grant\n    function grantRoleAfterSignal(address account, bytes32 roleKey) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _grantRoleActionKey(account, roleKey);\n        _validateAndClearAction(actionKey, \"grantRole\");\n\n        roleStore.grantRole(account, roleKey);\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"roleKey\", roleKey);\n        eventEmitter.emitEventLog1(\n            \"GrantRole\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev signal revoking of a role\n    // @param account the account to revoke the role for\n    // @param roleKey the role to revoke\n    function signalRevokeRole(address account, bytes32 roleKey) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _revokeRoleActionKey(account, roleKey);\n        _signalPendingAction(actionKey, \"revokeRole\");\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"roleKey\", roleKey);\n        eventEmitter.emitEventLog1(\n            \"SignalRevokeRole\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev revoke a role\n    // @param account the account to revoke the role for\n    // @param roleKey the role to revoke\n    function revokeRoleAfterSignal(address account, bytes32 roleKey) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _revokeRoleActionKey(account, roleKey);\n        _validateAndClearAction(actionKey, \"revokeRole\");\n\n        roleStore.revokeRole(account, roleKey);\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(1);\n        eventData.addressItems.setItem(0, \"account\", account);\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"roleKey\", roleKey);\n        eventEmitter.emitEventLog1(\n            \"RevokeRole\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev signal setting of a price feed\n    // @param token the token to set the price feed for\n    // @param priceFeed the address of the price feed\n    // @param priceFeedMultiplier the multiplier to apply to the price feed results\n    // @param stablePrice the stable price to set a range for the price feed results\n    function signalSetPriceFeed(\n        address token,\n        address priceFeed,\n        uint256 priceFeedMultiplier,\n        uint256 priceFeedHeartbeatDuration,\n        uint256 stablePrice\n    ) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _setPriceFeedActionKey(\n            token,\n            priceFeed,\n            priceFeedMultiplier,\n            priceFeedHeartbeatDuration,\n            stablePrice\n        );\n\n        _signalPendingAction(actionKey, \"setPriceFeed\");\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(2);\n        eventData.addressItems.setItem(0, \"token\", token);\n        eventData.addressItems.setItem(1, \"priceFeed\", priceFeed);\n        eventData.uintItems.initItems(3);\n        eventData.uintItems.setItem(0, \"priceFeedMultiplier\", priceFeedMultiplier);\n        eventData.uintItems.setItem(1, \"priceFeedHeartbeatDuration\", priceFeedHeartbeatDuration);\n        eventData.uintItems.setItem(2, \"stablePrice\", stablePrice);\n        eventEmitter.emitEventLog1(\n            \"SignalSetPriceFeed\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev sets a price feed\n    // @param token the token to set the price feed for\n    // @param priceFeed the address of the price feed\n    // @param priceFeedMultiplier the multiplier to apply to the price feed results\n    // @param stablePrice the stable price to set a range for the price feed results\n    function setPriceFeedAfterSignal(\n        address token,\n        address priceFeed,\n        uint256 priceFeedMultiplier,\n        uint256 priceFeedHeartbeatDuration,\n        uint256 stablePrice\n    ) external onlyTimelockAdmin nonReentrant {\n        bytes32 actionKey = _setPriceFeedActionKey(\n            token,\n            priceFeed,\n            priceFeedMultiplier,\n            priceFeedHeartbeatDuration,\n            stablePrice\n        );\n\n        _validateAndClearAction(actionKey, \"setPriceFeed\");\n\n        dataStore.setAddress(Keys.priceFeedKey(token), priceFeed);\n        dataStore.setUint(Keys.priceFeedMultiplierKey(token), priceFeedMultiplier);\n        dataStore.setUint(Keys.priceFeedHeartbeatDurationKey(token), priceFeedHeartbeatDuration);\n        dataStore.setUint(Keys.stablePriceKey(token), stablePrice);\n\n        EventUtils.EventLogData memory eventData;\n        eventData.addressItems.initItems(2);\n        eventData.addressItems.setItem(0, \"token\", token);\n        eventData.addressItems.setItem(1, \"priceFeed\", priceFeed);\n        eventData.uintItems.initItems(3);\n        eventData.uintItems.setItem(0, \"priceFeedMultiplier\", priceFeedMultiplier);\n        eventData.uintItems.setItem(1, \"priceFeedHeartbeatDuration\", priceFeedHeartbeatDuration);\n        eventData.uintItems.setItem(2, \"stablePrice\", stablePrice);\n        eventEmitter.emitEventLog1(\n            \"SetPriceFeed\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev cancels a previously signalled pending action\n    // @param actionKey the key of the action to cancel\n    function cancelAction(bytes32 actionKey) external onlyTimelockAdmin nonReentrant {\n        _clearAction(actionKey, \"cancelAction\");\n    }\n\n    // @dev signal a pending action\n    // @param actionKey the key of the action\n    // @param actionLabel a label for the action\n    function _signalPendingAction(bytes32 actionKey, string memory actionLabel) internal {\n        if (pendingActions[actionKey] != 0) {\n            revert Errors.ActionAlreadySignalled();\n        }\n\n        pendingActions[actionKey] = Chain.currentTimestamp() + timelockDelay;\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"actionKey\", actionKey);\n\n        eventData.stringItems.initItems(1);\n        eventData.stringItems.setItem(0, \"actionLabel\", actionLabel);\n\n        eventEmitter.emitEventLog1(\n            \"SignalPendingAction\",\n            actionKey,\n            eventData\n        );\n    }\n\n    // @dev the key for the addOracleSigner action\n    function _addOracleSignerActionKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"addOracleSigner\", account));\n    }\n\n    // @dev the key for the removeOracleSigner action\n    function _removeOracleSignerActionKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"removeOracleSigner\", account));\n    }\n\n    // @dev the key for the setFeeReceiver action\n    function _setFeeReceiverActionKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"setFeeReceiver\", account));\n    }\n\n    // @dev the key for the grantRole action\n    function _grantRoleActionKey(address account, bytes32 roleKey) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"grantRole\", account, roleKey));\n    }\n\n    // @dev the key for the revokeRole action\n    function _revokeRoleActionKey(address account, bytes32 roleKey) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"revokeRole\", account, roleKey));\n    }\n\n    // @dev the key for the setPriceFeed action\n    function _setPriceFeedActionKey(\n        address token,\n        address priceFeed,\n        uint256 priceFeedMultiplier,\n        uint256 priceFeedHeartbeatDuration,\n        uint256 stablePrice\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            \"setPriceFeed\",\n            token,\n            priceFeed,\n            priceFeedMultiplier,\n            priceFeedHeartbeatDuration,\n            stablePrice\n        ));\n    }\n\n    // @dev validate that the action has been signalled and sufficient time has\n    // passed, clear the action after\n    function _validateAndClearAction(bytes32 actionKey, string memory actionLabel) internal {\n        _validateAction(actionKey);\n        _clearAction(actionKey, actionLabel);\n    }\n\n    // @dev validate that the action has been signalled and sufficient time has passed\n    function _validateAction(bytes32 actionKey) internal view {\n        if (pendingActions[actionKey] == 0) {\n            revert Errors.ActionNotSignalled();\n        }\n\n        if (pendingActions[actionKey] > Chain.currentTimestamp()) {\n            revert Errors.SignalTimeNotYetPassed(pendingActions[actionKey]);\n        }\n    }\n\n    // @dev clear a previously signalled action\n    function _clearAction(bytes32 actionKey, string memory actionLabel) internal {\n        if (pendingActions[actionKey] == 0) {\n            revert Errors.ActionNotSignalled();\n        }\n        delete pendingActions[actionKey];\n\n        EventUtils.EventLogData memory eventData;\n\n        eventData.bytes32Items.initItems(1);\n        eventData.bytes32Items.setItem(0, \"actionKey\", actionKey);\n\n        eventData.stringItems.initItems(1);\n        eventData.stringItems.setItem(0, \"actionLabel\", actionLabel);\n\n        eventEmitter.emitEventLog1(\n            \"ClearPendingAction\",\n            actionKey,\n            eventData\n        );\n    }\n}"
    }
  ]
}