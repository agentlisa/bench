{
  "Title": "Temperature and caseId are incorrectly adjusted when oracle fails ",
  "Content": "# Temperature and caseId are incorrectly adjusted when oracle fails \n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L51\">https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L51</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L75-L78\">https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L75-L78</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/libraries/LibDibbler.sol#L372-L388\">https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/libraries/LibDibbler.sol#L372-L388</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/libraries/Oracle/LibEthUsdOracle.sol#L69\">https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/libraries/Oracle/LibEthUsdOracle.sol#L69</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/libraries/Minting/LibWellMinting.sol#L172\">https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/libraries/Minting/LibWellMinting.sol#L172</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/libraries/Minting/LibWellMinting.sol#L181\">https://github.com/BeanstalkFarms/Beanstalk/blob/6855a4702e920ae2e43fd4d0809dadee85e6ff6c/protocol/contracts/libraries/Minting/LibWellMinting.sol#L181</a>\n\n\n## Summary\nWhen user calls `gm` and the call for the chainlink oracle fails, it will return 0 for the `deltaB` value and this will cause a cascade effect, making the calculation of `caseId`  = `3` and using the incorrect `caseId` to set up the new temperature on Weather.sol \n```\nfunction updateTemperature(int8 bT, uint256 caseId) private {\n        uint256 t = s.w.t;\n        if (bT < 0) {\n            if (t <= uint256(-bT)) {\n                // if (change < 0 && t <= uint32(-change)),\n                // then 0 <= t <= type(int8).max because change is an int8.\n                // Thus, downcasting t to an int8 will not cause overflow.\n                bT = 1 - int8(t);\n                s.w.t = 1;\n            } else {\n                s.w.t = uint32(t - uint256(-bT));\n            }\n        } else {\n            s.w.t = uint32(t + uint256(bT));\n        }\n\n        emit TemperatureChange(s.season.current, caseId, bT);\n    }\n```\nEvery consumer of the temperature on the protocol will be affected like: \n\n- `LibDibbler.morningTemperature`\n- `LibDibbler.beansToPods`\n- `LibDibbler.remainingPods`\n- `Sun.setSoilAbovePeg`\n- `Sun.stepSun`\n- `FieldFacet.maxTemperature`\n- `FieldFacet.totalSoil`\n- `FieldFacet._totalSoilAndTemperature`\n- `FieldFacet.sowWithMin\n\n## Vulnerability Details\n`gm` function uses the incorrect `deltaB`(0) to calculate the `caseId` which is then used to set the temperature. \n```solidity\n   function gm(address account, LibTransfer.To mode) public payable returns (uint256) {\n        int256 deltaB = stepOracle(); // @audit here if oracle failed, we update the season.timestamp and return deltaB zero here\n        uint256 caseId = calcCaseIdandUpdate(deltaB); // @audit caseId will be 3 here if deltaB is zero\n        LibGerminate.endTotalGermination(season, LibWhitelistedTokens.getWhitelistedTokens());\n        LibGauge.stepGauge();\n        stepSun(deltaB, caseId); // @audit wrong deltaB and caseId used here, setting the abovePeg to false and soil to zero\n    }\n```\n\n\n## Impact\n> The interest rate will be wrongly decreased to 1, compromising the protocol peg mechanism when it needs to be maintained with a high interest rate/ temperature.\n\n> Sow will be calculated with the lowest temperature, also compromising the peg mechanism due to the wrong exchange of Beans -> Sow -> Pods\n\n> Remaining pods function will return zero and users will have an inaccurate number representing their actual pods. \n## PoC\n\n1. Prepare the environment to work with Foundry + Updated Mocks\nhttps://gist.github.com/h0lydev/fcdb00c797adfdf8e4816031e095fd6c\n\n2. Make sure to have the mainnet forked through Anvil: `anvil --fork-url https://rpc.ankr.com/eth`\n\n3. Create the `SeasonTemperature.t.sol` file under the folder `foundry` and paste the code below. Then run `forge test --match-contract SeasonTemperatureTest -vv`. \n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport { Sun } from \"contracts/beanstalk/sun/SeasonFacet/Sun.sol\";\nimport { MockSeasonFacet } from \"contracts/mocks/mockFacets/MockSeasonFacet.sol\";\nimport { MockSiloFacet } from \"contracts/mocks/mockFacets/MockSiloFacet.sol\";\nimport { MockFieldFacet } from \"contracts/mocks/mockFacets/MockFieldFacet.sol\";\nimport { MockWhitelistFacet } from \"contracts/mocks/mockFacets/MockWhitelistFacet.sol\";\nimport {LibWhitelist} from \"contracts/libraries/Silo/LibWhitelist.sol\";\nimport { Utils } from \"./utils/Utils.sol\";\nimport \"./utils/TestHelper.sol\";\nimport \"contracts/libraries/LibSafeMath32.sol\";\nimport \"contracts/C.sol\";\n\ncontract SeasonTemperatureTest is MockSeasonFacet, TestHelper {\n    using SafeMath for uint256;\n    using LibSafeMath32 for uint32;\n\n    bool oracleFailed;\n  \n    function setUp() public {\n        console.log(\"diamondSetup\");\n        vm.createSelectFork('local');\n        oracleFailed = false;\n        setupDiamond();\n        dewhitelistCurvePool();\n        mintUnripeLPToUser1();   \n        mintUnripeBeanToUser1();\n        setOraclePrices(false, 1000e6, 1000e6, 1000e6);\n        _setReservesForWell(1000000e6, 1000e18);\n       \n        // user / tokens\n        mintTokenForUsers();\n        setTokenApprovalForUsers();\n       \n        enableFertilizerAndMintActiveFertilizers();\n\n        callSunriseForUser1();\n    }\n\n\n    ////////////     Setup functions     ////////////\n\n    function setTokenApprovalForUsers() internal { \n        approveTokensForUser(deployer);\n        approveTokensForUser(user1);\n        approveTokensForUser(user2);\n        approveTokensForUser(user3);\n        approveTokensForUser(user4);\n        approveTokensForUser(user5);\n    }\n\n    function mintTokenForUsers() internal { \n        mintWETHtoUser(deployer);\n        mintWETHtoUser(user1);\n        mintWETHtoUser(user2);\n        mintWETHtoUser(user3);\n        mintWETHtoUser(user4);\n        mintWETHtoUser(user5);\n\n        // mint C.bean() to users\n        C.bean().mint(deployer, 10e6);\n        C.bean().mint(user1, 10e6);\n        C.bean().mint(user2, 10e6);\n        C.bean().mint(user3, 10e6);\n        C.bean().mint(user4, 10e6);\n        C.bean().mint(user5, 10e6);\n    }\n\n    function approveTokensForUser(address user) prank(user) internal { \n        mockWETH.approve(address(diamond), type(uint256).max);\n        unripeLP.approve(address(diamond), type(uint256).max);\n        unripeBean.approve(address(diamond), type(uint256).max);\n        well.approve(address(diamond), type(uint256).max);\n        C.bean().approve(address(field), type(uint256).max);\n        C.bean().approve(address(field), type(uint256).max);\n    }\n\n    function dewhitelistCurvePool() public {\n        vm.prank(deployer);\n        whitelist.dewhitelistToken(C.CURVE_BEAN_METAPOOL);\n    }\n\n    function mintWETHtoUser(address user) prank(user) internal {\n        mockWETH.mint(user, 1000e18);\n    }\n\n    function mintUnripeLPToUser1() internal { \n        unripeLP.mint(user1, 1000e6);\n    }\n\n    function mintUnripeBeanToUser1() internal { \n        unripeBean.mint(user1, 1000e6);\n    }\n\n    function enableFertilizerAndMintActiveFertilizers() internal { \n        // second parameter is the unfertilizedIndex\n        fertilizer.setFertilizerE(true, 10000e6);\n\n        vm.prank(deployer);\n        fertilizer.addFertilizerOwner(7500, 1e11, 99);\n\n        vm.prank(deployer);\n        fertilizer.addFertilizerOwner(6200, 1e11, 99);\n\n        addUnripeTokensToFacet();\n    }\n\n    function addUnripeTokensToFacet() prank(deployer) internal { \n        unripe.addUnripeToken(C.UNRIPE_BEAN, C.BEAN, bytes32(0));\n        unripe.addUnripeToken(C.UNRIPE_LP, C.BEAN_ETH_WELL, bytes32(0));\n    }\n\n    function callSunriseForUser1() prank(user1) internal {\n        _ensurePreConditions();\n        _advanceInTime(2 hours);\n        season.sunrise();\n    }\n\n    function setOraclePrices(bool makeOracleFail, int256 chainlinkPrice, uint256 ethUsdtPrice, uint256 ethUsdcPrice) internal { \n        if (makeOracleFail) { \n            _addEthUsdPriceChainlink(0);\n            oracleFailed = true;\n        } else { \n            oracleFailed = false;\n            _addEthUsdPriceChainlink(chainlinkPrice);\n            _setEthUsdtPrice(ethUsdtPrice);\n            _setEthUsdcPrice(ethUsdcPrice);\n        }\n    }\n\n    ////////////////////////////////////////// TESTS //////////////////////////////////////////\n\n    function testWrongCalcId_whenOracleFails() public { \n        _prepareForAbovePeg();\n        _advanceInTime(1 hours);\n        uint256 _snapId = vm.snapshot();\n        \n        // When sunrise succeeds\n        vm.prank(user4);\n        season.sunrise();\n\n        // Then print results\n        _printProtocolState();\n        assertEq(season.getT(), 5, \"when succeeds t should be 5\");\n        \n        // Then revert it to prepare for the season that will fail\n        vm.revertTo(_snapId);\n\n        // Prepare for the season that will fail\n        setOraclePrices(true, 0, 0, 0);\n\n        // When sunrise fails\n        vm.prank(user4);\n        season.sunrise();\n\n        console.log(\"Oracle failed, see results\");\n        _printProtocolState();\n        assertEq(season.getT(), 1, \"when succeeds t should be 1\");\n\n    }\n\n    function _printProtocolState() internal { \n        console.log(\"-------------- Results --------------\");\n        console.log(\"\");\n        console.log(\"thisSowTime: \", season.thisSowTime());\n        console.log(\"lastSowTime: \", season.lastSowTime());\n        console.log(\"getUsdTokenPrice: \", season.getUsdTokenPrice());\n        console.log(\"getReserve0: \", season.getReserve0());\n        console.log(\"getReserve1: \", season.getReserve1());\n        console.log(\"getAbovePeg: \", season.getAbovePeg());\n        console.log(\"getSoil: \", season.getSoil());\n        console.log(\"lastDSoil: \", season.lastDSoil());\n        console.log(\"s.w.t: \", season.getT());\n        console.log(\"remaining pods: \", field.remainingPods());\n    }   \n\n    function _prepareForAbovePeg() internal { \n        season.mockSetSopWell(address(well));\n        season.captureWellE(address(well)); \n        season.setYieldE(5); // s.w.t\n        setOraclePrices(false, 1000e6, 1000e6, 1000e6);\n\n        season.setLastSowTimeE(1);\n        season.setNextSowTimeE(10);\n        season.calcCaseIdE(1e18, 1);\n        season.setAbovePegE(true);\n    }\n\n    ////////////////////////////////////////// HELPERS //////////////////////////////////////////\n\n    function _ensurePreConditions() internal { \n        assertTrue(season.thisSowTime() == type(uint32).max, \"thisSowTime should be max\");\n        assertTrue(season.lastSowTime() == type(uint32).max, \"thisLastSowTime should be max\");\n        assertEq(season.getIsFarm(), 1, \"isFarm should be 1\");\n        assertEq(season.getUsdTokenPrice(), 1, \"usdTokenPrice should be 1\");\n        assertEq(season.getReserve0(), 1, \"reserve0 should be 1\");\n        assertEq(season.getReserve1(), 1, \"reserve1 should be 1\");\n        assertFalse(season.getAbovePeg(), \"pre - abovePeg should be false\");\n        assertEq(season.getSoil(), 0, \"soil should be == 0\");\n    }\n}\n```\nOutput: \n```\n handleRain caseId: 0\n -------------- Results --------------\n  \n  thisSowTime:  4294967295\n  lastSowTime:  4294967295\n  getUsdTokenPrice:  1\n  getReserve0:  1\n  getReserve1:  1\n  getAbovePeg:  false\n  getSoil:  462832752243\n  lastDSoil:  0\n  s.w.t:  5\n  remaining pods:  467461079765\n\nhandleRain caseId: 3\n Oracle failed, see results\n  -------------- Results --------------\n  \n  thisSowTime:  4294967295\n  lastSowTime:  4294967295\n  getUsdTokenPrice:  1\n  getReserve0:  1\n  getReserve1:  1\n  getAbovePeg:  false\n  getSoil:  0\n  lastDSoil:  0\n  s.w.t:  1\n  remaining pods:  0\n\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 29.45s (3.32ms CPU time)\n```\nps: a console.log was added to the `handleRain` function to print the caseId. \n\nResult: In a normal scenario the temperature would have remained at the value `5` but in this case was set to `1` and remaining pods/soil are also set to zero when in fact they should not. \n\n## Tools Used\nManual Review & Foundry\n\n## Recommendations\nIt is noticed that the developers have the intention of never reverting the sunrise function to decrease the risk of depeg and breaking the incentive for users calling it. But at the same time, those state variables shouldn't be updated as if the system is working correctly because they will impact the next season as stated in this finding. \n\nIt is tricky to propose a simple fix to the problem without impacting the system as a whole. Here are a few ideas that could be used: \n\n1. (Recommended) An effective solution could be store the latest response from chainlink and in case it fails and the timeout(a limit that you can be added to accept a previous response from the oracle) is not reached yet, protocol could use the previous response. Liquity Protocol uses this approach, an example here: https://github.com/liquity/dev/blob/main/packages/contracts/contracts/PriceFeed.sol\nThis solution will be effective for the protocol because the oracle is also called in different places like when minting fertilizers(`getMintFertilizerOut`), getting the well price(`getRatiosAndBeanIndex`), and `getConstantProductWell`. As the oracle is used along the protocol in many places, the `latest successful price` would be often up-to-date and within the limit time defined to use the previous price when the chainlink oracle fails. \n\n- Additionally, consider handling the errors properly before updating the `deltaB` and `abovePeg` variables, as these disrupt the peg mechanism logic. ",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clsxlpte900074r5et7x6kh96",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {Weather, SafeMath, C} from \"./Weather.sol\";\nimport {LibIncentive} from \"contracts/libraries/LibIncentive.sol\";\nimport {LibTransfer} from \"contracts/libraries/Token/LibTransfer.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\nimport {LibGauge} from \"contracts/libraries/LibGauge.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\nimport {LibGerminate} from \"contracts/libraries/Silo/LibGerminate.sol\";\n\n/**\n * @title SeasonFacet\n * @author Publius, Chaikitty, Brean\n * @notice Holds the Sunrise function and handles all logic for Season changes.\n */\ncontract SeasonFacet is Weather {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Emitted when the Season changes.\n     * @param season The new Season number\n     */\n    event Sunrise(uint256 indexed season);\n\n    //////////////////// SUNRISE ////////////////////\n\n    /**\n     * @notice Advances Beanstalk to the next Season, sending reward Beans to the caller's circulating balance.\n     * @return reward The number of beans minted to the caller.\n     */\n    function sunrise() external payable returns (uint256) {\n        return gm(msg.sender, LibTransfer.To.EXTERNAL);\n    }\n\n    /**\n     * @notice Advances Beanstalk to the next Season, sending reward Beans to a specified address & balance.\n     * @param account Indicates to which address reward Beans should be sent\n     * @param mode Indicates whether the reward beans are sent to internal or circulating balance\n     * @return reward The number of Beans minted to the caller.\n     */\n    function gm(address account, LibTransfer.To mode) public payable returns (uint256) {\n        uint256 initialGasLeft = gasleft();\n\n        require(!s.paused, \"Season: Paused.\");\n        require(seasonTime() > s.season.current, \"Season: Still current Season.\");\n        uint32 season = stepSeason();\n        int256 deltaB = stepOracle();\n        uint256 caseId = calcCaseIdandUpdate(deltaB);\n        LibGerminate.endTotalGermination(season, LibWhitelistedTokens.getWhitelistedTokens());\n        LibGauge.stepGauge();\n        stepSun(deltaB, caseId);\n\n        return incentivize(account, initialGasLeft, mode);\n    }\n\n    /**\n     * @notice Returns the expected Season number given the current block timestamp.\n     * {sunrise} can be called when `seasonTime() > s.season.current`.\n     */\n    function seasonTime() public view virtual returns (uint32) {\n        if (block.timestamp < s.season.start) return 0;\n        if (s.season.period == 0) return type(uint32).max;\n        return uint32((block.timestamp - s.season.start) / s.season.period); // Note: SafeMath is redundant here.\n    }\n\n    //////////////////// SEASON INTERNAL ////////////////////\n\n    /**\n     * @dev Moves the Season forward by 1.\n     */\n    function stepSeason() private returns (uint32 season) {\n        s.season.current += 1;\n        season = s.season.current;\n        s.season.sunriseBlock = uint32(block.number); // Note: Will overflow in the year 3650.\n        emit Sunrise(season);\n    }\n\n    /**\n     * @param account The address to which the reward beans are sent, may or may not\n     * be the same as the caller of `sunrise()`\n     * @param initialGasLeft The amount of gas left at the start of the transaction\n     * @param mode Send reward beans to Internal or Circulating balance\n     * @dev Mints Beans to `account` as a reward for calling {sunrise()}.\n     */\n    function incentivize(\n        address account,\n        uint256 initialGasLeft,\n        LibTransfer.To mode\n    ) private returns (uint256) {\n        // Number of blocks the sunrise is late by\n        // Assumes that each block timestamp is exactly `C.BLOCK_LENGTH_SECONDS` apart.\n        uint256 blocksLate = block\n            .timestamp\n            .sub(s.season.start.add(s.season.period.mul(s.season.current)))\n            .div(C.BLOCK_LENGTH_SECONDS);\n\n        // Read the Bean / Eth price calculated by the Minting Well.\n        uint256 beanEthPrice = LibWell.getWellPriceFromTwaReserves(C.BEAN_ETH_WELL);\n\n        // reset USD Token prices and TWA reserves in storage for all whitelisted Well LP Tokens.\n        address[] memory whitelistedWells = LibWhitelistedTokens.getWhitelistedWellLpTokens();\n        for (uint256 i; i < whitelistedWells.length; i++) {\n            LibWell.resetUsdTokenPriceForWell(whitelistedWells[i]);\n            LibWell.resetTwaReservesForWell(whitelistedWells[i]);\n        }\n\n        uint256 incentiveAmount = LibIncentive.determineReward(\n            initialGasLeft,\n            blocksLate,\n            beanEthPrice\n        );\n\n        LibTransfer.mintToken(C.bean(), incentiveAmount, account, mode);\n\n        emit LibIncentive.Incentivization(account, incentiveAmount);\n        return incentiveAmount;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibEvaluate} from \"contracts/libraries/LibEvaluate.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {LibCases} from \"contracts/libraries/LibCases.sol\";\nimport {Sun, SafeMath, C} from \"./Sun.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IBeanstalkWellFunction} from \"contracts/interfaces/basin/IBeanstalkWellFunction.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\nimport {IWell, Call} from \"contracts/interfaces/basin/IWell.sol\";\nimport {IInstantaneousPump} from \"contracts/interfaces/basin/pumps/IInstantaneousPump.sol\";\nimport {SignedSafeMath} from \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\n/**\n * @title Weather\n * @author Publius\n * @notice Weather controls the Temperature and Grown Stalk to LP on the Farm.\n */\ncontract Weather is Sun {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using LibSafeMath128 for uint128;\n\n    uint128 internal constant MAX_BEAN_LP_GP_PER_BDV_RATIO = 100e18;\n\n    /**\n     * @notice Emitted when the Temperature (fka \"Weather\") changes.\n     * @param season The current Season\n     * @param caseId The Weather case, which determines how much the Temperature is adjusted.\n     * @param absChange The absolute change in Temperature.\n     * @dev formula: T_n = T_n-1 +/- bT\n     */\n    event TemperatureChange(uint256 indexed season, uint256 caseId, int8 absChange);\n\n    /**\n     * @notice Emitted when the grownStalkToLP changes.\n     * @param season The current Season\n     * @param caseId The Weather case, which determines how the BeanToMaxLPGpPerBDVRatio is adjusted.\n     * @param absChange The absolute change in the BeanToMaxLPGpPerBDVRatio.\n     * @dev formula: L_n = L_n-1 +/- bL\n     */\n    event BeanToMaxLpGpPerBdvRatioChange(uint256 indexed season, uint256 caseId, int80 absChange);\n\n    /**\n     * @notice Emitted when Beans are minted during the Season of Plenty.\n     * @param season The Season in which Beans were minted for distribution.\n     * @param well The Well that the SOP occurred in.\n     * @param token The token that was swapped for Beans.\n     * @param amount The amount of 3CRV which was received for swapping Beans.\n     * @param toField The amount of Beans which were distributed to remaining Pods in the Field.\n     */\n    event SeasonOfPlenty(uint256 indexed season, address well, address token, uint256 amount, uint256 toField);\n\n    //////////////////// WEATHER INTERNAL ////////////////////\n\n    /**\n     * @notice from deltaB, podRate, change in soil demand, and liquidity to supply ratio,\n     * calculate the caseId, and update the temperature and grownStalkPerBdvToLp.\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @dev A detailed explanation of the temperature and grownStalkPerBdvToLp\n     * mechanism can be found in the Beanstalk whitepaper.\n     * An explanation of state variables can be found in {AppStorage}.\n     */\n    function calcCaseIdandUpdate(int256 deltaB) internal returns (uint256) {\n        uint256 beanSupply = C.bean().totalSupply();\n        // prevents infinite L2SR and podrate\n        if (beanSupply == 0) {\n            s.w.t = 1;\n            return 9; // Reasonably low\n        }\n        // Calculate Case Id\n        (uint256 caseId, address sopWell) = LibEvaluate.evaluateBeanstalk(deltaB, beanSupply);\n        updateTemperatureAndBeanToMaxLpGpPerBdvRatio(caseId);\n        handleRain(caseId, sopWell);\n        return caseId;\n    }\n\n    /**\n     * @notice updates the temperature and BeanToMaxLpGpPerBdvRatio, based on the caseId.\n     * @param caseId the state beanstalk is in, based on the current season.\n     */\n    function updateTemperatureAndBeanToMaxLpGpPerBdvRatio(uint256 caseId) internal {\n        LibCases.CaseData memory cd = LibCases.decodeCaseData(caseId);\n        updateTemperature(cd.bT, caseId);\n        updateBeanToMaxLPRatio(cd.bL, caseId);\n    }\n\n    /**\n     * @notice Changes the current Temperature `s.w.t` based on the Case Id.\n     * @dev bT are set during edge cases such that the event emitted is valid.\n     */\n    function updateTemperature(int8 bT, uint256 caseId) private {\n        uint256 t = s.w.t;\n        if (bT < 0) {\n            if (t <= uint256(-bT)) {\n                // if (change < 0 && t <= uint32(-change)),\n                // then 0 <= t <= type(int8).max because change is an int8.\n                // Thus, downcasting t to an int8 will not cause overflow.\n                bT = 1 - int8(t);\n                s.w.t = 1;\n            } else {\n                s.w.t = uint32(t - uint256(-bT));\n            }\n        } else {\n            s.w.t = uint32(t + uint256(bT));\n        }\n\n        emit TemperatureChange(s.season.current, caseId, bT);\n    }\n\n    /**\n     * @notice Changes the grownStalkPerBDVPerSeason based on the CaseId.\n     * @dev bL are set during edge cases such that the event emitted is valid.\n     */\n    function updateBeanToMaxLPRatio(int80 bL, uint256 caseId) private {\n        uint128 beanToMaxLpGpPerBdvRatio = s.seedGauge.beanToMaxLpGpPerBdvRatio;\n        if (bL < 0) {\n            if (beanToMaxLpGpPerBdvRatio <= uint128(-bL)) {\n                bL = -int80(beanToMaxLpGpPerBdvRatio);\n                s.seedGauge.beanToMaxLpGpPerBdvRatio = 0;\n            } else {\n                s.seedGauge.beanToMaxLpGpPerBdvRatio = beanToMaxLpGpPerBdvRatio.sub(uint128(-bL));\n            }\n        } else {\n            if (beanToMaxLpGpPerBdvRatio.add(uint128(bL)) >= MAX_BEAN_LP_GP_PER_BDV_RATIO) {\n                // if (change > 0 && 100e18 - beanToMaxLpGpPerBdvRatio <= bL),\n                // then bL cannot overflow.\n                bL = int80(MAX_BEAN_LP_GP_PER_BDV_RATIO.sub(beanToMaxLpGpPerBdvRatio));\n                s.seedGauge.beanToMaxLpGpPerBdvRatio = MAX_BEAN_LP_GP_PER_BDV_RATIO;\n            } else {\n                s.seedGauge.beanToMaxLpGpPerBdvRatio = beanToMaxLpGpPerBdvRatio.add(uint128(bL));\n            }\n        }\n\n        emit BeanToMaxLpGpPerBdvRatioChange(s.season.current, caseId, bL);\n    }\n\n    /**\n     * @dev Oversaturated was previously referred to as Raining and thus code\n     * references mentioning Rain really refer to Oversaturation. If P > 1 and the\n     * Pod Rate is less than 5%, the Farm is Oversaturated. If it is Oversaturated\n     * for a Season, each Season in which it continues to be Oversaturated, it Floods.\n     */\n    function handleRain(uint256 caseId, address well) internal {\n        // cases % 36  3-8 represent the case where the pod rate is less than 5% and P > 1.\n        if (caseId.mod(36) < 3 || caseId.mod(36) > 8) {\n            if (s.season.raining) {\n                s.season.raining = false;\n            }\n            return;\n        } else if (!s.season.raining) {\n            s.season.raining = true;\n            // Set the plenty per root equal to previous rain start.\n            s.sops[s.season.current] = s.sops[s.season.rainStart];\n            s.season.rainStart = s.season.current;\n            s.r.pods = s.f.pods;\n            s.r.roots = s.s.roots;\n        } else {\n            if (s.r.roots > 0) {\n                // initalize sopWell if it is not already set.\n                if (s.sopWell == address(0)) s.sopWell = well;\n                sop();\n            }\n        }\n    }\n\n    /**\n     * @dev Flood was previously called a \"Season of Plenty\" (SOP for short).\n     * When Beanstalk has been Oversaturated for a Season, Beanstalk returns the\n     * Bean price to its peg by minting additional Beans and selling them directly\n     * on the sop well. Proceeds from the sale in the form of WETH are distributed to\n     * Stalkholders at the beginning of a Season in proportion to their Stalk\n     * ownership when the Farm became Oversaturated. Also, at the beginning of the\n     * Flood, all Pods that were minted before the Farm became Oversaturated Ripen\n     * and become Harvestable.\n     * For more information On Oversaturation see {Weather.handleRain}.\n     */\n    function sop() private {\n        // calculate the beans from a sop.\n        // sop beans uses the min of the current and instantaneous reserves of the sop well,\n        // rather than the twaReserves in order to get bean back to peg.\n        address sopWell = s.sopWell;\n        (uint256 newBeans, IERC20 sopToken) = calculateSop(sopWell);\n        if (newBeans == 0) return;\n\n        uint256 sopBeans = uint256(newBeans);\n        uint256 newHarvestable;\n\n        // Pay off remaining Pods if any exist.\n        if (s.f.harvestable < s.r.pods) {\n            newHarvestable = s.r.pods - s.f.harvestable;\n            s.f.harvestable = s.f.harvestable.add(newHarvestable);\n            C.bean().mint(address(this), newHarvestable.add(sopBeans));\n        } else {\n            C.bean().mint(address(this), sopBeans);\n        }\n\n        // Approve and Swap Beans for the non-bean token of the SOP well.\n        C.bean().approve(sopWell, sopBeans);\n        uint256 amountOut = IWell(sopWell).swapFrom(\n            C.bean(),\n            sopToken, \n            sopBeans, \n            0,\n            address(this),\n            type(uint256).max\n        );\n        rewardSop(amountOut);\n        emit SeasonOfPlenty(s.season.current, sopWell, address(sopToken), amountOut, newHarvestable);\n    }\n\n    /**\n     * @dev Allocate `sop token` during a Season of Plenty.\n     */\n    function rewardSop(uint256 amount) private {\n        s.sops[s.season.rainStart] = s.sops[s.season.lastSop].add(\n            amount.mul(C.SOP_PRECISION).div(s.r.roots)\n        );\n        s.season.lastSop = s.season.rainStart;\n        s.season.lastSopSeason = s.season.current;\n    }\n    \n    /**\n     * Calculates the amount of beans that should be minted in a sop. \n     * @dev the instanteous EMA reserves are used rather than the twa reserves\n     * as the twa reserves are not indiciative of the current deltaB in the pool.\n     * \n     * Generalized for a single well. Sop does not support multiple wells.\n     */\n    function calculateSop(address well) private view returns (uint256 sopBeans, IERC20 sopToken){\n\n        // if the sopWell was not initalized, the should not occur.\n        if (well == address(0)) return (0, IERC20(0));\n        IWell sopWell = IWell(well);\n        IERC20[] memory tokens = sopWell.tokens();\n        Call[] memory pumps = sopWell.pumps();\n        IInstantaneousPump pump = IInstantaneousPump(pumps[0].target);\n        uint256[] memory instantaneousReserves = pump.readInstantaneousReserves(well, pumps[0].data);\n        uint256[] memory currentReserves = sopWell.getReserves();\n        Call memory wellFunction = sopWell.wellFunction();\n        (\n            uint256[] memory ratios, \n            uint256 beanIndex, \n            bool success\n        ) = LibWell.getRatiosAndBeanIndex(tokens);\n        // If the USD Oracle oracle call fails, the sop should not occur.\n        // return 0 rather than revert to prevent sunrise from failing.\n        if (!success) return (0, IERC20(0));\n\n        // compare the beans at peg using the instantaneous reserves,\n        // and the current reserves.\n        uint256 instantaneousBeansAtPeg = IBeanstalkWellFunction(wellFunction.target)\n            .calcReserveAtRatioSwap(\n                instantaneousReserves,\n                beanIndex,\n                ratios,\n                wellFunction.data\n            );\n        \n        uint256 currentBeansAtPeg = IBeanstalkWellFunction(wellFunction.target)\n            .calcReserveAtRatioSwap(\n                currentReserves,\n                beanIndex,\n                ratios,\n                wellFunction.data\n            );\n\n        // Calculate the signed Sop beans for the two reserves.\n        int256 lowestSopBeans = int256(instantaneousBeansAtPeg).sub(int256(instantaneousReserves[beanIndex]));\n        int256 currentSopBeans = int256(currentBeansAtPeg).sub(int256(currentReserves[beanIndex]));\n\n        // Use the minimum of the two.\n        if (lowestSopBeans > currentSopBeans) {\n            lowestSopBeans = currentSopBeans;\n        }\n\n        // If the sopBeans is negative, the sop should not occur.\n        if (lowestSopBeans < 0) return (0, IERC20(0));\n\n        // SafeCast not necessary due to above check.\n        sopBeans = uint256(lowestSopBeans);\n\n        // the sopToken is the non bean token in the well.\n        sopToken = tokens[beanIndex == 0 ? 1 : 0];\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/LibDibbler.sol",
      "content": "// SPDX-License-Identifier: MIT\n \npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibAppStorage, AppStorage} from \"./LibAppStorage.sol\";\nimport {LibSafeMath128} from \"./LibSafeMath128.sol\";\nimport {LibSafeMath32} from \"./LibSafeMath32.sol\";\nimport {LibPRBMath} from \"./LibPRBMath.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n/**\n * @title LibDibbler\n * @author Publius, Brean\n * @notice Calculates the amount of Pods received for Sowing under certain conditions.\n * Provides functions to calculate the instantaneous Temperature, which is adjusted by the\n * Morning Auction functionality. Provides math helpers for scaling Soil.\n */\nlibrary LibDibbler {\n    using SafeMath for uint256;\n    using LibPRBMath for uint256;\n    using LibSafeMath32 for uint32;\n    using LibSafeMath128 for uint128;\n\n    /// @dev Morning Auction scales temperature by 1e6.\n    uint256 internal constant TEMPERATURE_PRECISION = 1e6; \n\n    /// @dev Simplifies conversion of Beans to Pods:\n    /// `pods = beans * (1 + temperature)`\n    /// `pods = beans * (100% + temperature) / 100%`\n    uint256 private constant ONE_HUNDRED_PCT = 100 * TEMPERATURE_PRECISION;\n\n    /// @dev If less than `SOIL_SOLD_OUT_THRESHOLD` Soil is left, consider \n    /// Soil to be \"sold out\"; affects how Temperature is adjusted.\n    uint256 private constant SOIL_SOLD_OUT_THRESHOLD = 1e6;\n    \n    event Sow(\n        address indexed account,\n        uint256 index,\n        uint256 beans,\n        uint256 pods\n    );\n\n    //////////////////// SOW ////////////////////\n\n    /**\n     * @param beans The number of Beans to Sow\n     * @param _morningTemperature Pre-calculated {morningTemperature()}\n     * @param account The account sowing Beans\n     * @param abovePeg Whether the TWA deltaB of the previous season was positive (true) or negative (false)\n     * @dev \n     * \n     * ## Above Peg \n     * \n     * | t   | Max pods  | s.f.soil              | soil                    | temperature              | maxTemperature |\n     * |-----|-----------|-----------------------|-------------------------|--------------------------|----------------|\n     * | 0   | 500e6     | ~37e6 500e6/(1+1250%) | ~495e6 500e6/(1+1%))    | 1e6 (1%)                 | 1250 (1250%)   |\n     * | 12  | 500e6     | ~37e6                 | ~111e6 500e6/(1+348%))  | 348.75e6 (27.9% * 1250)  | 1250           |\n     * | 300 | 500e6     | ~37e6                 |  ~37e6 500e6/(1+1250%)  | 1250e6                   | 1250           |\n     * \n     * ## Below Peg\n     * \n     * | t   | Max pods                        | soil  | temperature                   | maxTemperature     |\n     * |-----|---------------------------------|-------|-------------------------------|--------------------|\n     * | 0   | 505e6 (500e6 * (1+1%))          | 500e6 | 1e6 (1%)                      | 1250 (1250%)       |\n     * | 12  | 2243.75e6 (500e6 * (1+348.75%)) | 500e6 | 348.75e6 (27.9% * 1250 * 1e6) | 1250               |\n     * | 300 | 6750e6 (500e6 * (1+1250%))      | 500e6 | 1250e6                        | 1250               |\n     */\n    function sow(uint256 beans, uint256 _morningTemperature, address account, bool abovePeg) internal returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        uint256 pods;\n        if (abovePeg) {\n            uint256 maxTemperature = uint256(s.w.t).mul(TEMPERATURE_PRECISION);\n            // amount sown is rounded up, because \n            // 1: temperature is rounded down.\n            // 2: pods are rounded down.\n            beans = scaleSoilDown(beans, _morningTemperature, maxTemperature);\n            pods = beansToPods(beans, maxTemperature);\n        } else {\n            pods = beansToPods(beans, _morningTemperature);\n        }\n\n        // we use trySub here because in the case of an overflow, its equivalent to having no soil left. \n        (, s.f.soil) = s.f.soil.trySub(uint128(beans));\n\n        return sowNoSoil(account, beans, pods);\n    }\n\n    /**\n     * @dev Sows a new Plot, increments total Pods, updates Sow time.\n     */\n    function sowNoSoil(address account, uint256 beans, uint256 pods)\n        internal\n        returns (uint256)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        _sowPlot(account, beans, pods);\n        s.f.pods = s.f.pods.add(pods);\n        _saveSowTime();\n        return pods;\n    }\n\n    /**\n     * @dev Create a Plot.\n     */\n    function _sowPlot(address account, uint256 beans, uint256 pods) private {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.a[account].field.plots[s.f.pods] = pods;\n        emit Sow(account, s.f.pods, beans, pods);\n    }\n\n    /** \n     * @dev Stores the time elapsed from the start of the Season to the time\n     * at which Soil is \"sold out\", i.e. the remaining Soil is less than a \n     * threshold `SOIL_SOLD_OUT_THRESHOLD`.\n     * \n     * RATIONALE: Beanstalk utilizes the time elapsed for Soil to \"sell out\" to \n     * gauge demand for Soil, which affects how the Temperature is adjusted. For\n     * example, if all Soil is Sown in 1 second vs. 1 hour, Beanstalk assumes \n     * that the former shows more demand than the latter.\n     *\n     * `thisSowTime` represents the target time of the first Sow for the *next*\n     * Season to be considered increasing in demand.\n     * \n     * `thisSowTime` should only be updated if:\n     *  (a) there is less than 1 Soil available after this Sow, and \n     *  (b) it has not yet been updated this Season.\n     * \n     * Note that:\n     *  - `s.f.soil` was decremented in the upstream {sow} function.\n     *  - `s.w.thisSowTime` is set to `type(uint32).max` during {sunrise}.\n     */\n    function _saveSowTime() private {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        // s.f.soil is now the soil remaining after this Sow.\n        if (s.f.soil > SOIL_SOLD_OUT_THRESHOLD || s.w.thisSowTime < type(uint32).max) {\n            // haven't sold enough soil, or already set thisSowTime for this Season.\n            return;\n        }\n\n        s.w.thisSowTime = uint32(block.timestamp.sub(s.season.timestamp));\n    }\n\n    //////////////////// TEMPERATURE ////////////////////\n    \n    /**\n     * @dev Returns the temperature `s.w.t` scaled down based on the block delta.\n     * Precision level 1e6, as soil has 1e6 precision (1% = 1e6)\n     * the formula `log51(A * MAX_BLOCK_ELAPSED + 1)` is applied, where:\n     * `A = 2`\n     * `MAX_BLOCK_ELAPSED = 25`\n     */\n    function morningTemperature() internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 delta = block.number.sub(s.season.sunriseBlock);\n\n        // check most likely case first\n        if (delta > 24) {\n            return uint256(s.w.t).mul(TEMPERATURE_PRECISION);\n        }\n\n        // Binary Search\n        if (delta < 13) {\n            if (delta < 7) { \n                if (delta < 4) {\n                    if (delta < 2) {\n                        // delta == 0, same block as sunrise\n                        if (delta < 1) {\n                            return TEMPERATURE_PRECISION;\n                        }\n                        // delta == 1\n                        else {\n                            return _scaleTemperature(279415312704);\n                        }\n                    }\n                    if (delta == 2) {\n                       return _scaleTemperature(409336034395);\n                    }\n                    else { // delta == 3\n                        return _scaleTemperature(494912626048);\n                    }\n                }\n                if (delta < 6) {\n                    if (delta == 4) {\n                        return _scaleTemperature(558830625409);\n                    }\n                    else { // delta == 5\n                        return _scaleTemperature(609868162219);\n                    }\n                }\n                else { // delta == 6\n                    return _scaleTemperature(652355825780); \n                }\n            }\n            if (delta < 10) {\n                if (delta < 9) {\n                    if (delta == 7) {\n                        return _scaleTemperature(688751347100);\n                    }\n                    else { // delta == 8\n                        return _scaleTemperature(720584687295);\n                    }\n                }\n                else { // delta == 9\n                    return _scaleTemperature(748873234524); \n                }\n            }\n            if (delta < 12) {\n                if (delta == 10) {\n                    return _scaleTemperature(774327938752);\n                }\n                else { // delta == 11\n                    return _scaleTemperature(797465225780); \n                }\n            }\n            else { // delta == 12\n                return _scaleTemperature(818672068791); \n            }\n        } \n        if (delta < 19){\n            if (delta < 16) {\n                if (delta < 15) {\n                    if (delta == 13) {\n                        return _scaleTemperature(838245938114); \n                    }\n                    else { // delta == 14\n                        return _scaleTemperature(856420437864);\n                    }\n                }\n                else { // delta == 15\n                    return _scaleTemperature(873382373802);\n                }\n            }\n            if (delta < 18) {\n                if (delta == 16) {\n                    return _scaleTemperature(889283474924);\n                }\n                else { // delta == 17\n                    return _scaleTemperature(904248660443);\n                }\n            }\n            else { // delta == 18\n                return _scaleTemperature(918382006208); \n            }\n        }\n        if (delta < 22) {\n            if (delta < 21) {\n                if (delta == 19) {\n                    return _scaleTemperature(931771138485); \n                }\n                else { // delta == 20\n                    return _scaleTemperature(944490527707);\n                }\n            } \n            else { // delta = 21\n                return _scaleTemperature(956603996980); \n            }\n        }\n        if (delta <= 23){ \n            if (delta == 22) {\n                return _scaleTemperature(968166659804);\n            }\n            else { // delta == 23\n                return _scaleTemperature(979226436102);\n            }\n        }\n        else { // delta == 24\n            return _scaleTemperature(989825252096);\n        }\n    }\n\n    /**\n     * @param pct The percentage to scale down by, measured to 1e12.\n     * @return scaledTemperature The scaled temperature, measured to 1e8 = 100e6 = 100% = 1.\n     * @dev Scales down `s.w.t` and imposes a minimum of 1e6 (1%) unless \n     * `s.w.t` is 0%.\n     */\n    function _scaleTemperature(uint256 pct) private view returns (uint256 scaledTemperature) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint256 maxTemperature = s.w.t;\n        if(maxTemperature == 0) return 0; \n\n        scaledTemperature = LibPRBMath.max(\n            // To save gas, `pct` is pre-calculated to 12 digits. Here we\n            // perform the following transformation:\n            // (1e2)    maxTemperature\n            // (1e12)    * pct\n            // (1e6)     / TEMPERATURE_PRECISION\n            // (1e8)     = scaledYield\n            maxTemperature.mulDiv(\n                pct, \n                TEMPERATURE_PRECISION,\n                LibPRBMath.Rounding.Up\n            ),\n            // Floor at TEMPERATURE_PRECISION (1%)\n            TEMPERATURE_PRECISION\n        );\n    }\n\n    /**\n     * @param beans The number of Beans to convert to Pods.\n     * @param _morningTemperature The current Temperature, measured to 1e8. \n     * @dev Converts Beans to Pods based on `_morningTemperature`.\n     * \n     * `pods = beans * (100e6 + _morningTemperature) / 100e6`\n     * `pods = beans * (1 + _morningTemperature / 100e6)`\n     *\n     * Beans and Pods are measured to 6 decimals.\n     * \n     * 1e8 = 100e6 = 100% = 1.\n     */\n    function beansToPods(uint256 beans, uint256 _morningTemperature)\n        internal\n        pure\n        returns (uint256 pods)\n    {\n        pods = beans.mulDiv(\n            _morningTemperature.add(ONE_HUNDRED_PCT),\n            ONE_HUNDRED_PCT\n        );\n    }\n\n    /**\n     * @dev Scales Soil up when Beanstalk is above peg.\n     * `(1 + maxTemperature) / (1 + morningTemperature)`\n     */\n    function scaleSoilUp(\n        uint256 soil, \n        uint256 maxTemperature,\n        uint256 _morningTemperature\n    ) internal pure returns (uint256) {\n        return soil.mulDiv(\n            maxTemperature.add(ONE_HUNDRED_PCT),\n            _morningTemperature.add(ONE_HUNDRED_PCT)\n        );\n    }\n    \n    /**\n     * @dev Scales Soil down when Beanstalk is above peg.\n     * \n     * When Beanstalk is above peg, the Soil issued changes. Example:\n     * \n     * If 500 Soil is issued when `s.w.t = 100e2 = 100%`\n     * At delta = 0: \n     *  morningTemperature() = 1%\n     *  Soil = `500*(100 + 100%)/(100 + 1%)` = 990.09901 soil\n     *\n     * If someone sow'd ~495 soil, it's equilivant to sowing 250 soil at t > 25.\n     * Thus when someone sows during this time, the amount subtracted from s.f.soil\n     * should be scaled down.\n     * \n     * Note: param ordering matches the mulDiv operation\n     */\n    function scaleSoilDown(\n        uint256 soil, \n        uint256 _morningTemperature, \n        uint256 maxTemperature\n    ) internal pure returns (uint256) {\n        return soil.mulDiv(\n            _morningTemperature.add(ONE_HUNDRED_PCT),\n            maxTemperature.add(ONE_HUNDRED_PCT),\n            LibPRBMath.Rounding.Up\n        );\n    }\n\n    /**\n     * @notice Returns the remaining Pods that could be issued this Season.\n     */\n    function remainingPods() internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        // Above peg: number of Pods is fixed, Soil adjusts\n        if(s.season.abovePeg) {\n            return beansToPods(\n                s.f.soil, // 1 bean = 1 soil\n                uint256(s.w.t).mul(TEMPERATURE_PRECISION) // 1e2 -> 1e8\n            );\n        } else {\n            // Below peg: amount of Soil is fixed, temperature adjusts\n            return beansToPods(\n                s.f.soil, // 1 bean = 1 soil\n                morningTemperature()\n            );\n        }\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Oracle/LibEthUsdOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibChainlinkOracle} from \"./LibChainlinkOracle.sol\";\nimport {LibUniswapOracle} from \"./LibUniswapOracle.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibAppStorage, AppStorage} from \"contracts/libraries/LibAppStorage.sol\";\nimport {C} from \"contracts/C.sol\";\n/**\n * @title Eth Usd Oracle Library\n * @notice Contains functionalty to fetch a manipulation resistant ETH/USD price.\n * @dev\n * The Oracle uses a greedy approach to return the average price between the\n * current price returned ETH/USD Chainlink Oracle and either the ETH/USDC\n * Uniswap V3 0.05% fee pool and the ETH/USDT Uniswap V3 0.05% fee pool depending\n * on whic"
    }
  ]
}