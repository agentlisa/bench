{
  "Title": "[06] `minimumOutputAmount` in CurveAdaptor can be integrated into the curve functionalities",
  "Content": "\nThe Curve Adapters interact with curve pool through three functions, `exchange()`, `remove_liquidity_one_coin()` and `add_liquidity()`. The last parameter of these functions are set to zero, which is the slippage parameter.\n\n```\n ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n```\n\nOcean protocol takes care of it by checking the slippage right at the end, but it can also be integrated right into the curve functions.\n\n```\n        if (uint256(minimumOutputAmount) > outputAmount) revert SLIPPAGE_LIMIT_EXCEEDED();\n```\n\n[CurveTricryptoAdapter.sol#L201-L203](https://github.com/code-423n4/2023-11-shellprotocol/blob/485de7383cdf88284ee6bcf2926fb7c19e9fb257/src/adapters/CurveTricryptoAdapter.sol#L201-L203)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-11-shellprotocol",
  "Code": [
    {
      "filename": "src/adapters/CurveTricryptoAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Cowri Labs Inc.\n\npragma solidity 0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./ICurveTricrypto.sol\";\nimport \"./OceanAdapter.sol\";\n\ninterface IWETH {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external payable;\n}\n\nenum ComputeType {\n    Deposit,\n    Swap,\n    Withdraw\n}\n\n/**\n * @notice\n *   curve tricrypto adapter contract enabling swapping, adding liquidity & removing liquidity for the curve usdt-wbtc-eth pool\n */\ncontract CurveTricryptoAdapter is OceanAdapter {\n    /////////////////////////////////////////////////////////////////////\n    //                             Errors                              //\n    /////////////////////////////////////////////////////////////////////\n    error INVALID_COMPUTE_TYPE();\n    error SLIPPAGE_LIMIT_EXCEEDED();\n\n    /////////////////////////////////////////////////////////////////////\n    //                             Events                              //\n    /////////////////////////////////////////////////////////////////////\n    event Swap(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Deposit(\n        uint256 inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n    event Withdraw(\n        uint256 outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 slippageProtection,\n        address user,\n        bool computeOutput\n    );\n\n    /// @notice x token Ocean ID\n    uint256 public immutable xToken;\n\n    /// @notice y token Ocean ID\n    uint256 public immutable yToken;\n\n    /// @notice z token Ocean ID\n    uint256 public immutable zToken;\n\n    /// @notice lp token Ocean ID\n    uint256 public immutable lpTokenId;\n\n    /// @notice map token Ocean IDs to corresponding Curve pool indices\n    mapping(uint256 => uint256) indexOf;\n\n    /// @notice The underlying token decimals wrt to the Ocean ID\n    mapping(uint256 => uint8) decimals;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice only initializing the immutables, mappings & approves tokens\n     */\n    constructor(address ocean_, address primitive_) OceanAdapter(ocean_, primitive_) {\n        address xTokenAddress = ICurveTricrypto(primitive).coins(0);\n        xToken = _calculateOceanId(xTokenAddress, 0);\n        underlying[xToken] = xTokenAddress;\n        decimals[xToken] = IERC20Metadata(xTokenAddress).decimals();\n        _approveToken(xTokenAddress);\n\n        address yTokenAddress = ICurveTricrypto(primitive).coins(1);\n        yToken = _calculateOceanId(yTokenAddress, 0);\n        indexOf[yToken] = 1;\n        underlying[yToken] = yTokenAddress;\n        decimals[yToken] = IERC20Metadata(yTokenAddress).decimals();\n        _approveToken(yTokenAddress);\n\n        address wethAddress = ICurveTricrypto(primitive).coins(2);\n        zToken = _calculateOceanId(address(0x4574686572), 0); // hexadecimal(ascii(\"Ether\"))\n        indexOf[zToken] = 2;\n        underlying[zToken] = wethAddress;\n        decimals[zToken] = NORMALIZED_DECIMALS;\n        _approveToken(wethAddress);\n\n        address lpTokenAddress = ICurveTricrypto(primitive).token();\n        lpTokenId = _calculateOceanId(lpTokenAddress, 0);\n        underlying[lpTokenId] = lpTokenAddress;\n        decimals[lpTokenId] = IERC20Metadata(lpTokenAddress).decimals();\n        _approveToken(lpTokenAddress);\n    }\n\n    /**\n     * @dev wraps the underlying token into the Ocean\n     * @param tokenId Ocean ID of token to wrap\n     * @param amount wrap amount\n     */\n    function wrapToken(uint256 tokenId, uint256 amount) internal override {\n        Interaction memory interaction;\n\n        if (tokenId == zToken) {\n            interaction = Interaction({\n                interactionTypeAndAddress: 0,\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: 0,\n                metadata: bytes32(0)\n            });\n            IOceanInteractions(ocean).doInteraction{ value: amount }(interaction);\n        } else {\n            interaction = Interaction({\n                interactionTypeAndAddress: _fetchInteractionId(underlying[tokenId], uint256(InteractionType.WrapErc20)),\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: amount,\n                metadata: bytes32(0)\n            });\n            IOceanInteractions(ocean).doInteraction(interaction);\n        }\n    }\n\n    /**\n     * @dev unwraps the underlying token from the Ocean\n     * @param tokenId Ocean ID of token to unwrap\n     * @param amount unwrap amount\n     */\n    function unwrapToken(uint256 tokenId, uint256 amount) internal override {\n        Interaction memory interaction;\n\n        if (tokenId == zToken) {\n            interaction = Interaction({\n                interactionTypeAndAddress: _fetchInteractionId(address(0), uint256(InteractionType.UnwrapEther)),\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: amount,\n                metadata: bytes32(0)\n            });\n        } else {\n            interaction = Interaction({\n                interactionTypeAndAddress: _fetchInteractionId(underlying[tokenId], uint256(InteractionType.UnwrapErc20)),\n                inputToken: 0,\n                outputToken: 0,\n                specifiedAmount: amount,\n                metadata: bytes32(0)\n            });\n        }\n\n        IOceanInteractions(ocean).doInteraction(interaction);\n    }\n\n    /**\n     * @dev swaps/add liquidity/remove liquidity from Curve Tricrypto Pool\n     * @param inputToken The user is giving this token to the pool\n     * @param outputToken The pool is giving this token to the user\n     * @param inputAmount The amount of the inputToken the user is giving to the pool\n     * @param minimumOutputAmount The minimum amount of tokens expected back after the exchange\n     */\n    function primitiveOutputAmount(\n        uint256 inputToken,\n        uint256 outputToken,\n        uint256 inputAmount,\n        bytes32 minimumOutputAmount\n    )\n        internal\n        override\n        returns (uint256 outputAmount)\n    {\n        uint256 rawInputAmount = _convertDecimals(NORMALIZED_DECIMALS, decimals[inputToken], inputAmount);\n\n        ComputeType action = _determineComputeType(inputToken, outputToken);\n\n        uint256 _balanceBefore = _getBalance(underlying[outputToken]);\n\n        // avoid multiple SLOADS\n        uint256 indexOfInputAmount = indexOf[inputToken];\n        uint256 indexOfOutputAmount = indexOf[outputToken];\n\n        if (action == ComputeType.Swap) {\n            bool useEth = inputToken == zToken || outputToken == zToken;\n\n            ICurveTricrypto(primitive).exchange{ value: inputToken == zToken ? rawInputAmount : 0 }(\n                indexOfInputAmount, indexOfOutputAmount, rawInputAmount, 0, useEth\n            );\n        } else if (action == ComputeType.Deposit) {\n            uint256[3] memory inputAmounts;\n            inputAmounts[indexOfInputAmount] = rawInputAmount;\n\n            if (inputToken == zToken) IWETH(underlying[zToken]).deposit{ value: rawInputAmount }();\n\n            ICurveTricrypto(primitive).add_liquidity(inputAmounts, 0);\n        } else {\n            if (outputToken == zToken) {\n                uint256 wethBalance = IERC20Metadata(underlying[zToken]).balanceOf(address(this));\n                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n                IWETH(underlying[zToken]).withdraw(\n                    IERC20Metadata(underlying[zToken]).balanceOf(address(this)) - wethBalance\n                );\n            } else {\n                ICurveTricrypto(primitive).remove_liquidity_one_coin(rawInputAmount, indexOfOutputAmount, 0);\n            }\n        }\n\n        uint256 rawOutputAmount = _getBalance(underlying[outputToken]) - _balanceBefore;\n\n        outputAmount = _convertDecimals(decimals[outputToken], NORMALIZED_DECIMALS, rawOutputAmount);\n\n        if (uint256(minimumOutputAmount) > outputAmount) revert SLIPPAGE_LIMIT_EXCEEDED();\n\n        if (action == ComputeType.Swap) {\n            emit Swap(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else if (action == ComputeType.Deposit) {\n            emit Deposit(inputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        } else {\n            emit Withdraw(outputToken, inputAmount, outputAmount, minimumOutputAmount, primitive, true);\n        }\n    }\n\n    /**\n     * @dev Approves token to be spent by the Ocean and the Curve pool\n     */\n    function _approveToken(address tokenAddress) private {\n        IERC20Metadata(tokenAddress).approve(ocean, type(uint256).max);\n        IERC20Metadata(tokenAddress).approve(primitive, type(uint256).max);\n    }\n\n    /**\n     * @dev fetches underlying token balances\n     */\n    function _getBalance(address tokenAddress) internal view returns (uint256 balance) {\n        if (tokenAddress == underlying[zToken]) {\n            return address(this).balance;\n        } else {\n            return IERC20Metadata(tokenAddress).balanceOf(address(this));\n        }\n    }\n\n    /**\n     * @dev Uses the inputToken and outputToken to determine the ComputeType\n     *  (input: xToken, output: yToken) | (input: yToken, output: xToken) => SWAP\n     *  base := xToken | yToken\n     *  (input: base, output: lpToken) => DEPOSIT\n     *  (input: lpToken, output: base) => WITHDRAW\n     */\n    function _determineComputeType(\n        uint256 inputToken,\n        uint256 outputToken\n    )\n        private\n        view\n        returns (ComputeType computeType)\n    {\n        if (\n            ((inputToken == xToken && outputToken == yToken) || (inputToken == yToken && outputToken == xToken))\n                || ((inputToken == xToken && outputToken == zToken) || (inputToken == zToken && outputToken == xToken))\n                || ((inputToken == yToken && outputToken == zToken) || (inputToken == zToken && outputToken == yToken))\n        ) {\n            return ComputeType.Swap;\n        } else if (\n            ((inputToken == xToken) || (inputToken == yToken) || (inputToken == zToken)) && (outputToken == lpTokenId)\n        ) {\n            return ComputeType.Deposit;\n        } else if (\n            (inputToken == lpTokenId) && ((outputToken == xToken) || (outputToken == yToken) || (outputToken == zToken))\n        ) {\n            return ComputeType.Withdraw;\n        } else {\n            revert INVALID_COMPUTE_TYPE();\n        }\n    }\n\n    fallback() external payable { }\n}"
    }
  ]
}