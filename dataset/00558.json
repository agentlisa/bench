{
  "Title": "Temporarily Unusable ETH [samples]",
  "Content": "The `TokenPaymaster` includes [a mechanism](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/TokenPaymaster.sol#L213) to receive ETH donations. However, they cannot be used or withdrawn until they are deposited to the `EntryPoint`. Therefore, the ETH remains unusable until the [deposit balance falls low enough](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/samples/TokenPaymaster.sol#L197) and user operation triggers the refill mechanism.\n\n\nSince the ETH will eventually become a deposit with the `EntryPoint`, consider removing this function and instead requiring donations to use the [existing `deposit` mechanism](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/BasePaymaster.sol#L98).\n\n\n***Update:** Resolved in [pull request #420](https://github.com/eth-infinitism/account-abstraction/pull/420), [pull request #433](https://github.com/eth-infinitism/account-abstraction/pull/433). The Ethereum Foundation team stated:*\n\n\n\n> *TokenPaymaster receives eth, but that's not for \"donations\" but part of its business logic: when converting tokens, it converts them to WETH and then to ETH, which is sent through this \"receive\" function. Then the paymaster uses these funds to replenish its deposit in the EntryPoint. We did add a method so that it would be able to withdraw any Eth that got accumulated there.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/samples/TokenPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n// Import the required libraries and contracts\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"../core/BasePaymaster.sol\";\nimport \"../core/UserOperationLib.sol\";\nimport \"./utils/UniswapHelper.sol\";\nimport \"./utils/OracleHelper.sol\";\n\n/// @title Sample ERC-20 Token Paymaster for ERC-4337\n/// This Paymaster covers gas fees in exchange for ERC20 tokens charged using allowance pre-issued by ERC-4337 accounts.\n/// The contract refunds excess tokens if the actual gas cost is lower than the initially provided amount.\n/// The token price cannot be queried in the validation code due to storage access restrictions of ERC-4337.\n/// The price is cached inside the contract and is updated in the 'postOp' stage if the change is >10%.\n/// It is theoretically possible the token has depreciated so much since the last 'postOp' the refund becomes negative.\n/// The contract reverts the inner user transaction in that case but keeps the charge.\n/// The contract also allows honest clients to prepay tokens at a higher price to avoid getting reverted.\n/// It also allows updating price configuration and withdrawing tokens by the contract owner.\n/// The contract uses an Oracle to fetch the latest token prices.\n/// @dev Inherits from BasePaymaster.\ncontract TokenPaymaster is BasePaymaster, UniswapHelper, OracleHelper {\n\n    struct TokenPaymasterConfig {\n        /// @notice The price markup percentage applied to the token price (1e6 = 100%)\n        uint256 priceMarkup;\n\n        /// @notice Exchange tokens to native currency if the EntryPoint balance of this Paymaster falls below this value\n        uint128 minEntryPointBalance;\n\n        /// @notice Estimated gas cost for refunding tokens after the transaction is completed\n        uint48 refundPostopCost;\n\n        /// @notice Transactions are only valid as long as the cached price is not older than this value\n        uint48 priceMaxAge;\n    }\n\n    event ConfigUpdated(TokenPaymasterConfig tokenPaymasterConfig);\n\n    event UserOperationSponsored(address indexed user, uint256 actualTokenCharge, uint256 actualGasCost, uint256 actualTokenPrice);\n\n    event Received(address indexed sender, uint256 value);\n\n    /// @notice All 'price' variables are multiplied by this value to avoid rounding up\n    uint256 private constant PRICE_DENOMINATOR = 1e26;\n\n    TokenPaymasterConfig private tokenPaymasterConfig;\n\n    /// @notice Initializes the TokenPaymaster contract with the given parameters.\n    /// @param _token The ERC20 token used for transaction fee payments.\n    /// @param _entryPoint The EntryPoint contract used in the Account Abstraction infrastructure.\n    /// @param _wrappedNative The ERC-20 token that wraps the native asset for current chain.\n    /// @param _uniswap The Uniswap V3 SwapRouter contract.\n    /// @param _tokenPaymasterConfig The configuration for the Token Paymaster.\n    /// @param _oracleHelperConfig The configuration for the Oracle Helper.\n    /// @param _uniswapHelperConfig The configuration for the Uniswap Helper.\n    /// @param _owner The address that will be set as the owner of the contract.\n    constructor(\n        IERC20Metadata _token,\n        IEntryPoint _entryPoint,\n        IERC20 _wrappedNative,\n        ISwapRouter _uniswap,\n        TokenPaymasterConfig memory _tokenPaymasterConfig,\n        OracleHelperConfig memory _oracleHelperConfig,\n        UniswapHelperConfig memory _uniswapHelperConfig,\n        address _owner\n    )\n    BasePaymaster(\n    _entryPoint\n    )\n    OracleHelper(\n    _oracleHelperConfig\n    )\n    UniswapHelper(\n    _token,\n    _wrappedNative,\n    _uniswap,\n    10 ** _token.decimals(),\n    _uniswapHelperConfig\n    )\n    {\n        setTokenPaymasterConfig(_tokenPaymasterConfig);\n        transferOwnership(_owner);\n    }\n\n    /// @notice Updates the configuration for the Token Paymaster.\n    /// @param _tokenPaymasterConfig The new configuration struct.\n    function setTokenPaymasterConfig(\n        TokenPaymasterConfig memory _tokenPaymasterConfig\n    ) public onlyOwner {\n        require(_tokenPaymasterConfig.priceMarkup <= 2 * PRICE_DENOMINATOR, \"TPM: price markup too high\");\n        require(_tokenPaymasterConfig.priceMarkup >= PRICE_DENOMINATOR, \"TPM: price markup too low\");\n        tokenPaymasterConfig = _tokenPaymasterConfig;\n        emit ConfigUpdated(_tokenPaymasterConfig);\n    }\n\n    function setUniswapConfiguration(\n        UniswapHelperConfig memory _uniswapHelperConfig\n    ) external onlyOwner {\n        _setUniswapHelperConfiguration(_uniswapHelperConfig);\n    }\n\n    /// @notice Allows the contract owner to withdraw a specified amount of tokens from the contract.\n    /// @param to The address to transfer the tokens to.\n    /// @param amount The amount of tokens to transfer.\n    function withdrawToken(address to, uint256 amount) external onlyOwner {\n        SafeERC20.safeTransfer(token, to, amount);\n    }\n\n    /// @notice Validates a paymaster user operation and calculates the required token amount for the transaction.\n    /// @param userOp The user operation data.\n    /// @param requiredPreFund The amount of tokens required for pre-funding.\n    /// @return context The context containing the token amount and user sender address (if applicable).\n    /// @return validationResult A uint256 value indicating the result of the validation (always 0 in this implementation).\n    function _validatePaymasterUserOp(PackedUserOperation calldata userOp, bytes32, uint256 requiredPreFund)\n    internal\n    override\n    returns (bytes memory context, uint256 validationResult) {unchecked {\n            uint256 priceMarkup = tokenPaymasterConfig.priceMarkup;\n            uint256 paymasterAndDataLength = userOp.paymasterAndData.length - PAYMASTER_DATA_OFFSET;\n            require(paymasterAndDataLength == 0 || paymasterAndDataLength == 32,\n                \"TPM: invalid data length\"\n            );\n            uint256 preChargeNative = requiredPreFund + (tokenPaymasterConfig.refundPostopCost * userOp.maxFeePerGas);\n        // note: as price is in ether-per-token and we want more tokens increasing it means dividing it by markup\n            uint256 cachedPriceWithMarkup = cachedPrice * PRICE_DENOMINATOR / priceMarkup;\n            if (paymasterAndDataLength == 32) {\n                uint256 clientSuppliedPrice = uint256(bytes32(userOp.paymasterAndData[PAYMASTER_DATA_OFFSET : PAYMASTER_DATA_OFFSET + 32]));\n                if (clientSuppliedPrice < cachedPriceWithMarkup) {\n                    // note: smaller number means 'more ether per token'\n                    cachedPriceWithMarkup = clientSuppliedPrice;\n                }\n            }\n            uint256 tokenAmount = weiToToken(preChargeNative, cachedPriceWithMarkup);\n            SafeERC20.safeTransferFrom(token, userOp.sender, address(this), tokenAmount);\n            context = abi.encode(tokenAmount, userOp.sender);\n            validationResult = _packValidationData(\n                false,\n                uint48(cachedPriceTimestamp + tokenPaymasterConfig.priceMaxAge),\n                0\n            );\n        }\n    }\n\n    /// @notice Performs post-operation tasks, such as updating the token price and refunding excess tokens.\n    /// @dev This function is called after a user operation has been executed or reverted.\n    /// @param context The context containing the token amount and user sender address.\n    /// @param actualGasCost The actual gas cost of the transaction.\n    /// @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n    //      and maxPriorityFee (and basefee)\n    //      It is not the same as tx.gasprice, which is what the bundler pays.\n    function _postOp(PostOpMode, bytes calldata context, uint256 actualGasCost, uint actualUserOpFeePerGas) internal override {\n        unchecked {\n            uint256 priceMarkup = tokenPaymasterConfig.priceMarkup;\n            (\n                uint256 preCharge,\n                address userOpSender\n            ) = abi.decode(context, (uint256, address));\n            uint256 _cachedPrice = updateCachedPrice(false);\n        // note: as price is in ether-per-token and we want more tokens increasing it means dividing it by markup\n            uint256 cachedPriceWithMarkup = _cachedPrice * PRICE_DENOMINATOR / priceMarkup;\n        // Refund tokens based on actual gas cost\n            uint256 actualChargeNative = actualGasCost + tokenPaymasterConfig.refundPostopCost * actualUserOpFeePerGas;\n            uint256 actualTokenNeeded = weiToToken(actualChargeNative, cachedPriceWithMarkup);\n            if (preCharge > actualTokenNeeded) {\n                // If the initially provided token amount is greater than the actual amount needed, refund the difference\n                SafeERC20.safeTransfer(\n                    token,\n                    userOpSender,\n                    preCharge - actualTokenNeeded\n                );\n            } else if (preCharge < actualTokenNeeded) {\n                // Attempt to cover Paymaster's gas expenses by withdrawing the 'overdraft' from the client\n                // If the transfer reverts also revert the 'postOp' to remove the incentive to cheat\n                SafeERC20.safeTransferFrom(\n                    token,\n                    userOpSender,\n                    address(this),\n                    actualTokenNeeded - preCharge\n                );\n            }\n\n            emit UserOperationSponsored(userOpSender, actualTokenNeeded, actualGasCost, _cachedPrice);\n            refillEntryPointDeposit(_cachedPrice);\n        }\n    }\n\n    /// @notice If necessary this function uses this Paymaster's token balance to refill the deposit on EntryPoint\n    /// @param _cachedPrice the token price that will be used to calculate the swap amount.\n    function refillEntryPointDeposit(uint256 _cachedPrice) private {\n        uint256 currentEntryPointBalance = entryPoint.balanceOf(address(this));\n        if (\n            currentEntryPointBalance < tokenPaymasterConfig.minEntryPointBalance\n        ) {\n            uint256 swappedWeth = _maybeSwapTokenToWeth(token, _cachedPrice);\n            unwrapWeth(swappedWeth);\n            entryPoint.depositTo{value: address(this).balance}(address(this));\n        }\n    }\n\n    function getGasPrice(uint256 maxFeePerGas, uint256 maxPriorityFeePerGas) internal view returns (uint256) {\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            // legacy mode (for networks that don't support the 'basefee' opcode)\n            return maxFeePerGas;\n        }\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n    }\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n}"
    },
    {
      "filename": "contracts/core/BasePaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./Helpers.sol\";\nimport \"./UserOperationLib.sol\";\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * Validates that the postOp is called only by the entryPoint.\n */\nabstract contract BasePaymaster is IPaymaster, Ownable {\n    IEntryPoint public immutable entryPoint;\n\n    uint256 internal constant PAYMASTER_VALIDATION_GAS_OFFSET = UserOperationLib.PAYMASTER_VALIDATION_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_POSTOP_GAS_OFFSET = UserOperationLib.PAYMASTER_POSTOP_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_DATA_OFFSET = UserOperationLib.PAYMASTER_DATA_OFFSET;\n\n    constructor(IEntryPoint _entryPoint) Ownable(msg.sender) {\n        _validateEntryPointInterface(_entryPoint);\n        entryPoint = _entryPoint;\n    }\n\n    //sanity check: make sure this EntryPoint was compiled against the same\n    // IEntryPoint of this paymaster\n    function _validateEntryPointInterface(IEntryPoint _entryPoint) internal virtual {\n        require(IERC165(address(_entryPoint)).supportsInterface(type(IEntryPoint).interfaceId), \"IEntryPoint interface mismatch\");\n    }\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external override returns (bytes memory context, uint256 validationData) {\n        _requireFromEntryPoint();\n        return _validatePaymasterUserOp(userOp, userOpHash, maxCost);\n    }\n\n    /**\n     * Validate a user operation.\n     * @param userOp     - The user operation.\n     * @param userOpHash - The hash of the user operation.\n     * @param maxCost    - The maximum cost of the user operation.\n     */\n    function _validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal virtual returns (bytes memory context, uint256 validationData);\n\n    /// @inheritdoc IPaymaster\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost, actualUserOpFeePerGas);\n    }\n\n    /**\n     * Post-operation handler.\n     * (verified to be called only through the entryPoint)\n     * @dev If subclass returns a non-empty context from validatePaymasterUserOp,\n     *      it must also implement this method.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. still has to pay for gas.\n     *                        postOpReverted - User op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                                         Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n\n     */\n    function _postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) internal virtual {\n        (mode, context, actualGasCost, actualUserOpFeePerGas); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /**\n     * Add a deposit for this paymaster, used for paying for transaction fees.\n     */\n    function deposit() public payable {\n        entryPoint.depositTo{value: msg.value}(address(this));\n    }\n\n    /**\n     * Withdraw value from the deposit.\n     * @param withdrawAddress - Target to send to.\n     * @param amount          - Amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) public onlyOwner {\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * Add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - The unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        entryPoint.addStake{value: msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * Return current paymaster's deposit on the entryPoint.\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * Unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\n     */\n    function unlockStake() external onlyOwner {\n        entryPoint.unlockStake();\n    }\n\n    /**\n     * Withdraw the entire paymaster's stake.\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\n        entryPoint.withdrawStake(withdrawAddress);\n    }\n\n    /**\n     * Validate the call is made from a valid entrypoint\n     */\n    function _requireFromEntryPoint() internal virtual {\n        require(msg.sender == address(entryPoint), \"Sender not EntryPoint\");\n    }\n}"
    }
  ]
}