{
  "Title": "H-1: Bypass the blacklist restriction because the blacklist check is not done when minting or burning",
  "Content": "# Issue H-1: Bypass the blacklist restriction because the blacklist check is not done when minting or burning \n\nSource: https://github.com/sherlock-audit/2023-06-dinari-judging/issues/64 \n\n## Found by \nctf\\_sec, dirk\\_y, p-tsanev, toshii\n## Summary\n\nBypass the blacklist restriction because the blacklist check is not done when minting or burning\n\n## Vulnerability Detail\n\nIn the whitepaper:\n\n> the protocol emphasis that they implement a blacklist feature for enforcing OFAC, AML and other account security requirements\nA blacklisted will not able to send or receive tokens\n\nthe protocol want to use the whitelist feature to be compliant to not let the blacklisted address send or receive dSahres\n\nFor this reason, before token transfer, the protocol check if address from or address to is blacklisted and the blacklisted address can still create buy order or sell order\n\n```solidity\n   function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n        // Restrictions ignored for minting and burning\n        // If transferRestrictor is not set, no restrictions are applied\n\n        // @audit\n        // why don't you not apply mint and burn in blacklist?\n        if (from == address(0) || to == address(0) || address(transferRestrictor) == address(0)) {\n            return;\n        }\n\n        // Check transfer restrictions\n        transferRestrictor.requireNotRestricted(from, to);\n    }\n```\n\nthis is calling\n\n```solidity\nfunction requireNotRestricted(address from, address to) external view virtual {\n\t// Check if either account is restricted\n\tif (blacklist[from] || blacklist[to]) {\n\t\trevert AccountRestricted();\n\t}\n\t// Otherwise, do nothing\n}\n```\n\nbut as we can see, when the dShare token is burned or minted, the blacklist does not apply to address(to)\n\nthis allows the blacklisted receiver to bypass the blacklist restriction and still send and receive dShares and cash out their dShares\n\n**because the minting dShares is not blacklisted**\n\na blacklisted user create a buy order with payment token and set the order receiver to a non-blacklisted address\n\nthen later when the [buy order is filled](https://github.com/sherlock-audit/2023-06-dinari/blob/4851cb7ebc86a7bc26b8d0d399a7dd7f9520f393/sbt-contracts/src/issuer/BuyOrderIssuer.sol#L189), the new dShares is transferred and minted to an not-blacklisted address\n\n**because the burning dShares is not blacklisted**\n\nbefore the user is blacklisted, a user can frontrun the blacklist transaction to create a sell order and [transfer the dShares into the OrderProcessor](https://github.com/sherlock-audit/2023-06-dinari/blob/4851cb7ebc86a7bc26b8d0d399a7dd7f9520f393/sbt-contracts/src/issuer/SellOrderProcessor.sol#L88)\n\nthen later when the sell order is filled, the dShares in [burnt from the SellOrderProcess](https://github.com/sherlock-audit/2023-06-dinari/blob/4851cb7ebc86a7bc26b8d0d399a7dd7f9520f393/sbt-contracts/src/issuer/SellOrderProcessor.sol#L115) escrow are burnt and the user can receive the payment token\n\n## Impact\n\nBypass the blacklist restriction because the blacklist check is not done when minting or burning\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-dinari/blob/4851cb7ebc86a7bc26b8d0d399a7dd7f9520f393/sbt-contracts/src/issuer/SellOrderProcessor.sol#L88\n\nhttps://github.com/sherlock-audit/2023-06-dinari/blob/4851cb7ebc86a7bc26b8d0d399a7dd7f9520f393/sbt-contracts/src/issuer/SellOrderProcessor.sol#L115\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nimplement proper check when burning and minting of the dShares to not let user game the blacklist system, checking if the receiver of the dShares is blacklisted when minting, before filling sell order and burn the dShares, check if the requestor of the sell order is blacklisted\n\ndo not let blacklisted address create buy order and sell order\n\n\n\n\n\n## Discussion\n\n**jaketimothy**\n\nFixes for this should be considered in combination with #55 as it creates more opportunities for locking up orders.\n\n**jaketimothy**\n\nFixed in \n- https://github.com/dinaricrypto/sbt-contracts/pull/126\n- https://github.com/dinaricrypto/sbt-contracts/pull/131\n\n**ctf-sec**\n\nPR #131 fix goods good\n\nPR #126 only fix only check if the recipient or requestor is blocklisted by the asset token transferRestrictor\n\n```solidity\n  if (\n            BridgedERC20(orderRequest.assetToken).isBlacklisted(orderRequest.recipient)\n                || BridgedERC20(orderRequest.assetToken).isBlacklisted(msg.sender)\n        ) revert Blacklist();\n``` \n\nthe protocol may want to consider checking if the orderRequest.recipient or msg.sender is blocklisted by the payment token as well\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/98",
  "Code": [
    {
      "filename": "sbt-contracts/src/issuer/BuyOrderIssuer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"prb-math/Common.sol\" as PrbMath;\nimport {OrderProcessor} from \"./OrderProcessor.sol\";\nimport {IMintBurn} from \"../IMintBurn.sol\";\n\n/// @notice Contract managing market purchase orders for bridged assets\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/BuyOrderIssuer.sol)\n/// This order processor emits market orders to buy the underlying asset that are good until cancelled\n/// Fees are calculated upfront and held back from the order amount\n/// The payment is escrowed until the order is filled or cancelled\n/// Payment is automatically refunded if the order is cancelled\n/// Implicitly assumes that asset tokens are BridgedERC20 and can be minted\ncontract BuyOrderIssuer is OrderProcessor {\n    // Handle token transfers safely\n    using SafeERC20 for IERC20;\n\n    /// ------------------ Types ------------------ ///\n\n    struct FeeState {\n        // Percentage fees are calculated upfront and accumulated as order is filled\n        uint256 remainingPercentageFees;\n        // Total fees earned including flat fee\n        uint256 feesEarned;\n    }\n\n    /// @dev Order is too small to pay fees\n    error OrderTooSmall();\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev orderId => FeeState\n    mapping(bytes32 => FeeState) private _feeState;\n\n    /// ------------------ Getters ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function getOrderRequestForOrder(Order calldata order) public pure override returns (OrderRequest memory) {\n        return OrderRequest({\n            recipient: order.recipient,\n            assetToken: order.assetToken,\n            paymentToken: order.paymentToken,\n            // Add fees back to order quantity to recover total quantityIn\n            quantityIn: order.paymentTokenQuantity + order.fee,\n            price: order.price\n        });\n    }\n\n    /// @notice Get fees for an order\n    /// @param token Payment token for order\n    /// @param inputValue Total input value subject to fees\n    /// @return flatFee Flat fee for order\n    /// @return percentageFee Percentage fee for order\n    /// @dev Fees zero if no orderFees contract is set\n    function getFeesForOrder(address token, uint256 inputValue)\n        public\n        view\n        returns (uint256 flatFee, uint256 percentageFee)\n    {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) {\n            return (0, 0);\n        }\n\n        // Calculate fees\n        flatFee = orderFees.flatFeeForOrder(token);\n        // If input value is greater than flat fee, calculate percentage fee on remaining value\n        if (inputValue > flatFee) {\n            percentageFee = orderFees.percentageFeeForValue(inputValue - flatFee);\n        } else {\n            percentageFee = 0;\n        }\n    }\n\n    /// @notice Get the raw input value and fees that produce a final order value\n    /// @param token Payment token for order\n    /// @param orderValue Final order value\n    /// @return inputValue Total input value subject to fees\n    /// @return flatFee Flat fee for order\n    /// @return percentageFee Percentage fee for order\n    /// @dev Fees zero if no orderFees contract is set\n    function getInputValueForOrderValue(address token, uint256 orderValue)\n        external\n        view\n        returns (uint256 inputValue, uint256 flatFee, uint256 percentageFee)\n    {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) {\n            return (orderValue, 0, 0);\n        }\n\n        // Calculate input value after flat fee\n        uint256 recoveredValue = orderFees.recoverInputValueFromRemaining(orderValue);\n        // Calculate fees\n        percentageFee = orderFees.percentageFeeForValue(recoveredValue);\n        flatFee = orderFees.flatFeeForOrder(token);\n        // Calculate raw input value\n        inputValue = recoveredValue + flatFee;\n    }\n\n    /// ------------------ Order Lifecycle ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function _requestOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId)\n        internal\n        virtual\n        override\n        returns (Order memory order)\n    {\n        // Determine fees\n        (uint256 flatFee, uint256 percentageFee) = getFeesForOrder(orderRequest.paymentToken, orderRequest.quantityIn);\n        uint256 totalFees = flatFee + percentageFee;\n        // Fees must not exceed order input value\n        if (totalFees >= orderRequest.quantityIn) revert OrderTooSmall();\n\n        // Initialize fee state for order\n        _feeState[orderId] = FeeState({remainingPercentageFees: percentageFee, feesEarned: flatFee});\n\n        // Construct order\n        order = Order({\n            recipient: orderRequest.recipient,\n            assetToken: orderRequest.assetToken,\n            paymentToken: orderRequest.paymentToken,\n            // Buy order\n            sell: false,\n            // Market order\n            orderType: OrderType.MARKET,\n            assetTokenQuantity: 0,\n            // Hold fees back from order amount\n            paymentTokenQuantity: orderRequest.quantityIn - totalFees,\n            price: orderRequest.price,\n            // Good until cancelled\n            tif: TIF.GTC,\n            // Emit fees held back from order amount\n            fee: totalFees\n        });\n\n        // Escrow payment for purchase\n        IERC20(orderRequest.paymentToken).safeTransferFrom(msg.sender, address(this), orderRequest.quantityIn);\n    }\n\n    /// @inheritdoc OrderProcessor\n    // slither-disable-next-line dead-code\n    function _fillOrderAccounting(\n        OrderRequest calldata orderRequest,\n        bytes32 orderId,\n        OrderState memory orderState,\n        uint256 fillAmount,\n        uint256 receivedAmount\n    ) internal virtual override {\n        // Calculate fees and mint asset\n        _fillBuyOrder(orderRequest, orderId, orderState, fillAmount, receivedAmount);\n\n        // Claim payment\n        IERC20(orderRequest.paymentToken).safeTransfer(msg.sender, fillAmount);\n    }\n\n    /// @dev Fill buy order accounting and mint asset\n    function _fillBuyOrder(\n        OrderRequest calldata orderRequest,\n        bytes32 orderId,\n        OrderState memory orderState,\n        uint256 fillAmount,\n        uint256 receivedAmount\n    ) internal virtual {\n        FeeState memory feeState = _feeState[orderId];\n        uint256 remainingOrder = orderState.remainingOrder - fillAmount;\n        // If order is done, close order and transfer fees\n        if (remainingOrder == 0) {\n            _closeOrder(orderId, orderRequest.paymentToken, feeState.remainingPercentageFees + feeState.feesEarned);\n        } else {\n            // Otherwise accumulate fees for fill\n            // Calculate fees\n            uint256 collection = 0;\n            if (feeState.remainingPercentageFees > 0) {\n                // fee = remainingPercentageFees * fillAmount / remainingOrder\n                collection = PrbMath.mulDiv(feeState.remainingPercentageFees, fillAmount, orderState.remainingOrder);\n            }\n            // Update fee state\n            if (collection > 0) {\n                _feeState[orderId].remainingPercentageFees = feeState.remainingPercentageFees - collection;\n                _feeState[orderId].feesEarned = feeState.feesEarned + collection;\n            }\n        }\n\n        // Mint asset\n        IMintBurn(orderRequest.assetToken).mint(orderRequest.recipient, receivedAmount);\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _cancelOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId, OrderState memory orderState)\n        internal\n        virtual\n        override\n    {\n        FeeState memory feeState = _feeState[orderId];\n        // If no fills, then full refund\n        // This addition is required to check for any fills\n        uint256 refund = orderState.remainingOrder + feeState.remainingPercentageFees;\n        // If any fills, then orderState.remainingOrder would not be large enough to satisfy this condition\n        // feesEarned is always needed to recover flat fee\n        if (refund + feeState.feesEarned == orderRequest.quantityIn) {\n            _closeOrder(orderId, orderRequest.paymentToken, 0);\n            // Refund full payment\n            refund = orderRequest.quantityIn;\n        } else {\n            // Otherwise close order and transfer fees\n            _closeOrder(orderId, orderRequest.paymentToken, feeState.feesEarned);\n        }\n\n        // Return escrow\n        IERC20(orderRequest.paymentToken).safeTransfer(orderRequest.recipient, refund);\n    }\n\n    /// @dev Close order and transfer fees\n    function _closeOrder(bytes32 orderId, address paymentToken, uint256 feesEarned) private {\n        // Clear fee state\n        delete _feeState[orderId];\n\n        // Transfer earneds fees to treasury\n        if (feesEarned > 0) {\n            IERC20(paymentToken).safeTransfer(treasury, feesEarned);\n        }\n    }\n}"
    },
    {
      "filename": "sbt-contracts/src/issuer/SellOrderProcessor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"prb-math/Common.sol\" as PrbMath;\nimport {OrderProcessor} from \"./OrderProcessor.sol\";\nimport {IMintBurn} from \"../IMintBurn.sol\";\n\n/// @notice Contract managing market sell orders for bridged assets\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/issuer/SellOrderProcessor.sol)\n/// This order processor emits market orders to sell the underlying asset that are good until cancelled\n/// Fee obligations are accumulated as order is filled\n/// Fees are taken from the proceeds of the sale\n/// The asset token is escrowed until the order is filled or cancelled\n/// The asset token is automatically refunded if the order is cancelled\n/// Implicitly assumes that asset tokens are BridgedERC20 and can be burned\ncontract SellOrderProcessor is OrderProcessor {\n    using SafeERC20 for IERC20;\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev orderId => feesEarned\n    mapping(bytes32 => uint256) private _feesEarned;\n\n    /// ------------------ Getters ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function getOrderRequestForOrder(Order calldata order) public pure override returns (OrderRequest memory) {\n        return OrderRequest({\n            recipient: order.recipient,\n            assetToken: order.assetToken,\n            paymentToken: order.paymentToken,\n            quantityIn: order.assetTokenQuantity,\n            price: order.price\n        });\n    }\n\n    /// @notice Get flat fee for an order\n    /// @param token Payment token for order\n    /// @dev Fee zero if no orderFees contract is set\n    function getFlatFeeForOrder(address token) public view returns (uint256) {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) return 0;\n        // Calculate fees\n        return orderFees.flatFeeForOrder(token);\n    }\n\n    /// @notice Get percentage fee for an order\n    /// @param value Value of order subject to percentage fee\n    /// @dev Fee zero if no orderFees contract is set\n    function getPercentageFeeForOrder(uint256 value) public view returns (uint256) {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) return 0;\n        // Calculate fees\n        return orderFees.percentageFeeForValue(value);\n    }\n\n    /// ------------------ Order Lifecycle ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function _requestOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId)\n        internal\n        virtual\n        override\n        returns (Order memory order)\n    {\n        // Accumulate initial flat fee obligation\n        _feesEarned[orderId] = getFlatFeeForOrder(orderRequest.paymentToken);\n\n        // Construct order\n        order = Order({\n            recipient: orderRequest.recipient,\n            assetToken: orderRequest.assetToken,\n            paymentToken: orderRequest.paymentToken,\n            // Sell order\n            sell: true,\n            // Market order\n            orderType: OrderType.MARKET,\n            assetTokenQuantity: orderRequest.quantityIn,\n            paymentTokenQuantity: 0,\n            price: orderRequest.price,\n            // Good until cancelled\n            tif: TIF.GTC,\n            fee: 0\n        });\n\n        // Escrow asset for sale\n        IERC20(orderRequest.assetToken).safeTransferFrom(msg.sender, address(this), orderRequest.quantityIn);\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _fillOrderAccounting(\n        OrderRequest calldata orderRequest,\n        bytes32 orderId,\n        OrderState memory orderState,\n        uint256 fillAmount,\n        uint256 receivedAmount\n    ) internal virtual override {\n        // Accumulate fee obligations at each sill then take all at end\n        uint256 collection = getPercentageFeeForOrder(receivedAmount);\n        uint256 feesEarned = _feesEarned[orderId] + collection;\n        // If order completely filled, clear fee data\n        uint256 remainingOrder = orderState.remainingOrder - fillAmount;\n        if (remainingOrder == 0) {\n            // Clear fee state\n            delete _feesEarned[orderId];\n        } else {\n            // Update fee state with earned fees\n            if (collection > 0) {\n                _feesEarned[orderId] = feesEarned;\n            }\n        }\n\n        // Burn asset\n        IMintBurn(orderRequest.assetToken).burn(fillAmount);\n        // Transfer raw proceeds of sale here\n        IERC20(orderRequest.paymentToken).safeTransferFrom(msg.sender, address(this), receivedAmount);\n        // Distribute if order completely filled\n        if (remainingOrder == 0) {\n            _distributeProceeds(\n                orderRequest.paymentToken, orderRequest.recipient, orderState.received + receivedAmount, feesEarned\n            );\n        }\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _cancelOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId, OrderState memory orderState)\n        internal\n        virtual\n        override\n    {\n        // If no fills, then full refund\n        uint256 refund;\n        if (orderState.remainingOrder == orderRequest.quantityIn) {\n            // Full refund\n            refund = orderRequest.quantityIn;\n        } else {\n            // Otherwise distribute proceeds, take accumulated fees, and refund remaining order\n            _distributeProceeds(\n                orderRequest.paymentToken, orderRequest.recipient, orderState.received, _feesEarned[orderId]\n            );\n            // Partial refund\n            refund = orderState.remainingOrder;\n        }\n\n        // Clear fee data\n        delete _feesEarned[orderId];\n\n        // Return escrow\n        IERC20(orderRequest.assetToken).safeTransfer(orderRequest.recipient, refund);\n    }\n\n    /// @dev Distribute proceeds and fees\n    function _distributeProceeds(address paymentToken, address recipient, uint256 totalReceived, uint256 feesEarned)\n        private\n    {\n        // Check if accumulated fees are larger than total received\n        uint256 proceeds = 0;\n        uint256 collection = 0;\n        if (totalReceived > feesEarned) {\n            // Take fees from total received before distributing\n            proceeds = totalReceived - feesEarned;\n            collection = feesEarned;\n        } else {\n            // If accumulated fees are larger than total received, then no proceeds go to recipient\n            collection = totalReceived;\n        }\n\n        // Transfer proceeds to recipient\n        if (proceeds > 0) {\n            IERC20(paymentToken).safeTransfer(recipient, proceeds);\n        }\n        // Transfer fees to treasury\n        if (collection > 0) {\n            IERC20(paymentToken).safeTransfer(treasury, collection);\n        }\n    }\n}"
    },
    {
      "filename": "sbt-contracts/src/issuer/SellOrderProcessor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"prb-math/Common.sol\" as PrbMath;\nimport {OrderProcessor} from \"./OrderProcessor.sol\";\nimport {IMintBurn} from \"../IMintBurn.sol\";\n\n/// @notice Contract managing market sell orders for bridged assets\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/issuer/SellOrderProcessor.sol)\n/// This order processor emits market orders to sell the underlying asset that are good until cancelled\n/// Fee obligations are accumulated as order is filled\n/// Fees are taken from the proceeds of the sale\n/// The asset token is escrowed until the order is filled or cancelled\n/// The asset token is automatically refunded if the order is cancelled\n/// Implicitly assumes that asset tokens are BridgedERC20 and can be burned\ncontract SellOrderProcessor is OrderProcessor {\n    using SafeERC20 for IERC20;\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev orderId => feesEarned\n    mapping(bytes32 => uint256) private _feesEarned;\n\n    /// ------------------ Getters ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function getOrderRequestForOrder(Order calldata order) public pure override returns (OrderRequest memory) {\n        return OrderRequest({\n            recipient: order.recipient,\n            assetToken: order.assetToken,\n            paymentToken: order.paymentToken,\n            quantityIn: order.assetTokenQuantity,\n            price: order.price\n        });\n    }\n\n    /// @notice Get flat fee for an order\n    /// @param token Payment token for order\n    /// @dev Fee zero if no orderFees contract is set\n    function getFlatFeeForOrder(address token) public view returns (uint256) {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) return 0;\n        // Calculate fees\n        return orderFees.flatFeeForOrder(token);\n    }\n\n    /// @notice Get percentage fee for an order\n    /// @param value Value of order subject to percentage fee\n    /// @dev Fee zero if no orderFees contract is set\n    function getPercentageFeeForOrder(uint256 value) public view returns (uint256) {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) return 0;\n        // Calculate fees\n        return orderFees.percentageFeeForValue(value);\n    }\n\n    /// ------------------ Order Lifecycle ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function _requestOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId)\n        internal\n        virtual\n        override\n        returns (Order memory order)\n    {\n        // Accumulate initial flat fee obligation\n        _feesEarned[orderId] = getFlatFeeForOrder(orderRequest.paymentToken);\n\n        // Construct order\n        order = Order({\n            recipient: orderRequest.recipient,\n            assetToken: orderRequest.assetToken,\n            paymentToken: orderRequest.paymentToken,\n            // Sell order\n            sell: true,\n            // Market order\n            orderType: OrderType.MARKET,\n            assetTokenQuantity: orderRequest.quantityIn,\n            paymentTokenQuantity: 0,\n            price: orderRequest.price,\n            // Good until cancelled\n            tif: TIF.GTC,\n            fee: 0\n        });\n\n        // Escrow asset for sale\n        IERC20(orderRequest.assetToken).safeTransferFrom(msg.sender, address(this), orderRequest.quantityIn);\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _fillOrderAccounting(\n        OrderRequest calldata orderRequest,\n        bytes32 orderId,\n        OrderState memory orderState,\n        uint256 fillAmount,\n        uint256 receivedAmount\n    ) internal virtual override {\n        // Accumulate fee obligations at each sill then take all at end\n        uint256 collection = getPercentageFeeForOrder(receivedAmount);\n        uint256 feesEarned = _feesEarned[orderId] + collection;\n        // If order completely filled, clear fee data\n        uint256 remainingOrder = orderState.remainingOrder - fillAmount;\n        if (remainingOrder == 0) {\n            // Clear fee state\n            delete _feesEarned[orderId];\n        } else {\n            // Update fee state with earned fees\n            if (collection > 0) {\n                _feesEarned[orderId] = feesEarned;\n            }\n        }\n\n        // Burn asset\n        IMintBurn(orderRequest.assetToken).burn(fillAmount);\n        // Transfer raw proceeds of sale here\n        IERC20(orderRequest.paymentToken).safeTransferFrom(msg.sender, address(this), receivedAmount);\n        // Distribute if order completely filled\n        if (remainingOrder == 0) {\n            _distributeProceeds(\n                orderRequest.paymentToken, orderRequest.recipient, orderState.received + receivedAmount, feesEarned\n            );\n        }\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _cancelOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId, OrderState memory orderState)\n        internal\n        virtual\n        override\n    {\n        // If no fills, then full refund\n        uint256 refund;\n        if (orderState.remainingOrder == orderRequest.quantityIn) {\n            // Full refund\n            refund = orderRequest.quantityIn;\n        } else {\n            // Otherwise distribute proceeds, take accumulated fees, and refund remaining order\n            _distributeProceeds(\n                orderRequest.paymentToken, orderRequest.recipient, orderState.received, _feesEarned[orderId]\n            );\n            // Partial refund\n            refund = orderState.remainingOrder;\n        }\n\n        // Clear fee data\n        delete _feesEarned[orderId];\n\n        // Return escrow\n        IERC20(orderRequest.assetToken).safeTransfer(orderRequest.recipient, refund);\n    }\n\n    /// @dev Distribute proceeds and fees\n    function _distributeProceeds(address paymentToken, address recipient, uint256 totalReceived, uint256 feesEarned)\n        private\n    {\n        // Check if accumulated fees are larger than total received\n        uint256 proceeds = 0;\n        uint256 collection = 0;\n        if (totalReceived > feesEarned) {\n            // Take fees from total received before distributing\n            proceeds = totalReceived - feesEarned;\n            collection = feesEarned;\n        } else {\n            // If accumulated fees are larger than total received, then no proceeds go to recipient\n            collection = totalReceived;\n        }\n\n        // Transfer proceeds to recipient\n        if (proceeds > 0) {\n            IERC20(paymentToken).safeTransfer(recipient, proceeds);\n        }\n        // Transfer fees to treasury\n        if (collection > 0) {\n            IERC20(paymentToken).safeTransfer(treasury, collection);\n        }\n    }\n}"
    },
    {
      "filename": "sbt-contracts/src/issuer/SellOrderProcessor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"prb-math/Common.sol\" as PrbMath;\nimport {OrderProcessor} from \"./OrderProcessor.sol\";\nimport {IMintBurn} from \"../IMintBurn.sol\";\n\n/// @notice Contract managing market sell orders for bridged assets\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/issuer/SellOrderProcessor.sol)\n/// This order processor emits market orders to sell the underlying asset that are good until cancelled\n/// Fee obligations are accumulated as order is filled\n/// Fees are taken from the proceeds of the sale\n/// The asset token is escrowed until the order is filled or cancelled\n/// The asset token is automatically refunded if the order is cancelled\n/// Implicitly assumes that asset tokens are BridgedERC20 and can be burned\ncontract SellOrderProcessor is OrderProcessor {\n    using SafeERC20 for IERC20;\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev orderId => feesEarned\n    mapping(bytes32 => uint256) private _feesEarned;\n\n    /// ------------------ Getters ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function getOrderRequestForOrder(Order calldata order) public pure override returns (OrderRequest memory) {\n        return OrderRequest({\n            recipient: order.recipient,\n            assetToken: order.assetToken,\n            paymentToken: order.paymentToken,\n            quantityIn: order.assetTokenQuantity,\n            price: order.price\n        });\n    }\n\n    /// @notice Get flat fee for an order\n    /// @param token Payment token for order\n    /// @dev Fee zero if no orderFees contract is set\n    function getFlatFeeForOrder(address token) public view returns (uint256) {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) return 0;\n        // Calculate fees\n        return orderFees.flatFeeForOrder(token);\n    }\n\n    /// @notice Get percentage fee for an order\n    /// @param value Value of order subject to percentage fee\n    /// @dev Fee zero if no orderFees contract is set\n    function getPercentageFeeForOrder(uint256 value) public view returns (uint256) {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) return 0;\n        // Calculate fees\n        return orderFees.percentageFeeForValue(value);\n    }\n\n    /// ------------------ Order Lifecycle ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function _requestOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId)\n        internal\n        virtual\n        override\n        returns (Order memory order)\n    {\n        // Accumulate initial flat fee obligation\n        _feesEarned[orderId] = getFlatFeeForOrder(orderRequest.paymentToken);\n\n        // Construct order\n        order = Order({\n            recipient: orderRequest.recipient,\n            assetToken: orderRequest.assetToken,\n            paymentToken: orderRequest.paymentToken,\n            // Sell order\n            sell: true,\n            // Market order\n            orderType: OrderType.MARKET,\n            assetTokenQuantity: orderRequest.quantityIn,\n            paymentTokenQuantity: 0,\n            price: orderRequest.price,\n            // Good until cancelled\n            tif: TIF.GTC,\n            fee: 0\n        });\n\n        // Escrow asset for sale\n        IERC20(orderRequest.assetToken).safeTransferFrom(msg.sender, address(this), orderRequest.quantityIn);\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _fillOrderAccounting(\n        OrderRequest calldata orderRequest,\n        bytes32 orderId,\n        OrderState memory orderState,\n        uint256 fillAmount,\n        uint256 receivedAmount\n    ) internal virtual override {\n        // Accumulate fee obligations at each sill then take all at end\n        uint256 collection = getPercentageFeeForOrder(receivedAmount);\n        uint256 feesEarned = _feesEarned[orderId] + collection;\n        // If order completely filled, clear fee data\n        uint256 remainingOrder = orderState.remainingOrder - fillAmount;\n        if (remainingOrder == 0) {\n            // Clear fee state\n            delete _feesEarned[orderId];\n        } else {\n            // Update fee state with earned fees\n            if (collection > 0) {\n                _feesEarned[orderId] = feesEarned;\n            }\n        }\n\n        // Burn asset\n        IMintBurn(orderRequest.assetToken).burn(fillAmount);\n        // Transfer raw proceeds of sale here\n        IERC20(orderRequest.paymentToken).safeTransferFrom(msg.sender, address(this), receivedAmount);\n        // Distribute if order completely filled\n        if (remainingOrder == 0) {\n            _distributeProceeds(\n                orderRequest.paymentToken, orderRequest.recipient, orderState.received + receivedAmount, feesEarned\n            );\n        }\n    }\n\n    /// @inheritdoc OrderProcessor\n    function _cancelOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId, OrderState memory orderState)\n        internal\n        virtual\n        override\n    {\n        // If no fills, then full refund\n        uint256 refund;\n        if (orderState.remainingOrder == orderRequest.quantityIn) {\n            // Full refund\n            refund = orderRequest.quantityIn;\n        } else {\n            // Otherwise distribute proceeds, take accumulated fees, and refund remaining order\n            _distributeProceeds(\n                orderRequest.paymentToken, orderRequest.recipient, orderState.received, _feesEarned[orderId]\n            );\n            // Partial refund\n            refund = orderState.remainingOrder;\n        }\n\n        // Clear fee data\n        delete _feesEarned[orderId];\n\n        // Return escrow\n        IERC20(orderRequest.assetToken).safeTransfer(orderRequest.recipient, refund);\n    }\n\n    /// @dev Distribute proceeds and fees\n    function _distributeProceeds(address paymentToken, address recipient, uint256 totalReceived, uint256 feesEarned)\n        private\n    {\n        // Check if accumulated fees are larger than total received\n        uint256 proceeds = 0;\n        uint256 collection = 0;\n        if (totalReceived > feesEarned) {\n            // Take fees from total received before distributing\n            proceeds = totalReceived - feesEarned;\n            collection = feesEarned;\n        } else {\n            // If accumulated fees are larger than total received, then no proceeds go to recipient\n            collection = totalReceived;\n        }\n\n        // Transfer proceeds to recipient\n        if (proceeds > 0) {\n            IERC20(paymentToken).safeTransfer(recipient, proceeds);\n        }\n        // Transfer fees to treasury\n        if (collection > 0) {\n            IERC20(paymentToken).safeTransfer(treasury, collection);\n        }\n    }\n}"
    },
    {
      "filename": "sbt-contracts/src/issuer/SellOrderProcessor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\nimport {SafeERC20, IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"prb-math/Common.sol\" as PrbMath;\nimport {OrderProcessor} from \"./OrderProcessor.sol\";\nimport {IMintBurn} from \"../IMintBurn.sol\";\n\n/// @notice Contract managing market sell orders for bridged assets\n/// @author Dinari (https://github.com/dinaricrypto/sbt-contracts/blob/main/src/issuer/SellOrderProcessor.sol)\n/// This order processor emits market orders to sell the underlying asset that are good until cancelled\n/// Fee obligations are accumulated as order is filled\n/// Fees are taken from the proceeds of the sale\n/// The asset token is escrowed until the order is filled or cancelled\n/// The asset token is automatically refunded if the order is cancelled\n/// Implicitly assumes that asset tokens are BridgedERC20 and can be burned\ncontract SellOrderProcessor is OrderProcessor {\n    using SafeERC20 for IERC20;\n\n    /// ------------------ State ------------------ ///\n\n    /// @dev orderId => feesEarned\n    mapping(bytes32 => uint256) private _feesEarned;\n\n    /// ------------------ Getters ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function getOrderRequestForOrder(Order calldata order) public pure override returns (OrderRequest memory) {\n        return OrderRequest({\n            recipient: order.recipient,\n            assetToken: order.assetToken,\n            paymentToken: order.paymentToken,\n            quantityIn: order.assetTokenQuantity,\n            price: order.price\n        });\n    }\n\n    /// @notice Get flat fee for an order\n    /// @param token Payment token for order\n    /// @dev Fee zero if no orderFees contract is set\n    function getFlatFeeForOrder(address token) public view returns (uint256) {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) return 0;\n        // Calculate fees\n        return orderFees.flatFeeForOrder(token);\n    }\n\n    /// @notice Get percentage fee for an order\n    /// @param value Value of order subject to percentage fee\n    /// @dev Fee zero if no orderFees contract is set\n    function getPercentageFeeForOrder(uint256 value) public view returns (uint256) {\n        // Check if fee contract is set\n        if (address(orderFees) == address(0)) return 0;\n        // Calculate fees\n        return orderFees.percentageFeeForValue(value);\n    }\n\n    /// ------------------ Order Lifecycle ------------------ ///\n\n    /// @inheritdoc OrderProcessor\n    function _requestOrderAccounting(OrderRequest calldata orderRequest, bytes32 orderId)\n        internal\n        virtual\n        override\n        returns (Order memory order)\n    {\n        // Accumulate initial flat fee obligation\n        _feesEarned[orderId] = getFlatFeeForOr"
    }
  ]
}