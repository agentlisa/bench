{
  "Title": "M-28: Collateral tokens that cannot be automatically swapped to the PnL token, cannot have slippage applied to them",
  "Content": "# Issue M-28: Collateral tokens that cannot be automatically swapped to the PnL token, cannot have slippage applied to them \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/144 \n\n## Found by \nIllIllI\n\n## Summary\n\nCollateral tokens that cannot be automatically swapped to the PnL token, cannot have slippage applied to them, since the `minOutputAmount` is in units of the output token, not the secondary token.\n\n\n## Vulnerability Detail\n\nIf a user's order uses the `Order.DecreasePositionSwapType.SwapCollateralTokenToPnlToken` flag, it's possible for the swap to fail (e.g. because the token is paused), and in such cases, the collateral token is sent back as-is, without being converted to the PnL token. In such cases, it's not possible for the code, as it is written, to support slippage in such scenarios, because there is only one order slippage argument, `minOutputAmount`, and it's in units of the PnL token, not the collateral token.\n\n\n## Impact\n\nA user that has a resting order open with the flag set, so that they can take profit at the appropriate time, will be forced to incur any price impact slippage present, even if they had specified a valid `minOutputAmount` that would otherwise have prevented the sub-optimal execution.\n\n\n## Code Snippet\n\nIf the swap goes through, the `secondaryOutputAmount` is cleared and added to the outputAmount, but if the swap fails, it's kept as the `values.output.secondaryOutputAmount`:\n```solidity\n// File: gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol : DecreasePositionCollateralUtils.swapWithdrawnCollateralToPnlToken()   #1\n\n383                try params.contracts.swapHandler.swap(\n...\n396                ) returns (address tokenOut, uint256 swapOutputAmount) {\n397                    if (tokenOut != values.output.secondaryOutputToken) {\n398                        revert InvalidOutputToken(tokenOut, values.output.secondaryOutputToken);\n399                    }\n400                    // combine the values into outputToken and outputAmount\n401                    values.output.outputToken = tokenOut;\n402 @>                 values.output.outputAmount = values.output.secondaryOutputAmount + swapOutputAmount;\n403                    values.output.secondaryOutputAmount = 0;\n404                } catch Error(string memory reason) {\n405 @>                 emit SwapUtils.SwapReverted(reason, \"\");\n406                } catch (bytes memory reasonBytes) {\n407                    (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n408 @>                 emit SwapUtils.SwapReverted(reason, reasonBytes);\n409                }\n410            }\n411    \n412            return values;\n413:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol#L383-L413\n\nAnd is sent separately, with no slippage [checks](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/DecreaseOrderUtils.sol#L57-L73).\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nConvert the USD value of `secondaryOutputAmount` to `outputAmount`, and ensure that the slippage checks against that total\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/108\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\n// @title DecreasePositionCollateralUtils\n// @dev Library for functions to help with the calculations when decreasing a position\nlibrary DecreasePositionCollateralUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    error InsufficientCollateral(int256 remainingCollateralAmount);\n    error InvalidOutputToken(address tokenOut, address expectedTokenOut);\n\n    struct ProcessCollateralCache {\n        int256 adjustedPositionPnlUsd;\n        uint256 adjustedPriceImpactDiffUsd;\n        uint256 adjustedPriceImpactDiffAmount;\n        uint256 pnlDiffAmount;\n    }\n\n    // @dev handle the collateral changes of the position\n    // @param params PositionUtils.UpdatePositionParams\n    // @param cache DecreasePositionCache\n    // @return (PositionUtils.DecreasePositionCollateralValues, PositionPricingUtils.PositionFees)\n    function processCollateral(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCache memory cache\n    ) external returns (\n        PositionUtils.DecreasePositionCollateralValues memory,\n        PositionPricingUtils.PositionFees memory\n    ) {\n        ProcessCollateralCache memory collateralCache;\n        PositionUtils.DecreasePositionCollateralValues memory values;\n        values.remainingCollateralAmount = cache.initialCollateralAmount.toInt256();\n\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(params.order.initialCollateralToken(), params.market, cache.prices);\n\n        (values.executionPrice, values.priceImpactAmount, values.priceImpactDiffUsd) = getExecutionPrice(params, cache.prices, params.order.sizeDeltaUsd());\n\n        (values.positionPnlUsd, values.sizeDeltaInTokens) = PositionUtils.getPositionPnlUsd(\n            params.contracts.dataStore,\n            params.market,\n            cache.prices,\n            params.position,\n            values.executionPrice,\n            params.order.sizeDeltaUsd()\n        );\n\n        collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd;\n        collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd;\n\n        if (values.positionPnlUsd > 0 && values.priceImpactDiffUsd > 0) {\n            if (values.positionPnlUsd > values.priceImpactDiffUsd.toInt256()) {\n                collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd - values.priceImpactDiffUsd.toInt256();\n                collateralCache.adjustedPriceImpactDiffUsd = 0;\n            } else {\n                collateralCache.adjustedPositionPnlUsd = 0;\n                collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd - values.positionPnlUsd.toUint256();\n            }\n        }\n\n        collateralCache.adjustedPriceImpactDiffAmount = collateralCache.adjustedPriceImpactDiffUsd / collateralTokenPrice.max;\n\n        if (collateralCache.adjustedPriceImpactDiffUsd > 0 && params.order.initialCollateralDeltaAmount() > 0) {\n            uint256 initialCollateralDeltaAmount = params.order.initialCollateralDeltaAmount();\n\n            if (collateralCache.adjustedPriceImpactDiffAmount > params.order.initialCollateralDeltaAmount()) {\n                params.order.setInitialCollateralDeltaAmount(0);\n            } else {\n                params.order.setInitialCollateralDeltaAmount(params.order.initialCollateralDeltaAmount() - collateralCache.adjustedPriceImpactDiffAmount);\n            }\n\n            OrderEventUtils.emitOrderCollateralDeltaAmountAutoUpdated(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                initialCollateralDeltaAmount,\n                params.order.initialCollateralDeltaAmount()\n            );\n        }\n\n        values.remainingCollateralAmount -= params.order.initialCollateralDeltaAmount().toInt256();\n        values.output.outputToken = params.position.collateralToken();\n        values.output.outputAmount = params.order.initialCollateralDeltaAmount();\n        values.output.secondaryOutputToken = cache.pnlToken;\n\n        if (collateralCache.adjustedPositionPnlUsd < 0) {\n            // position realizes a loss\n            // deduct collateral from user, transfer it to the pool\n            values.pnlTokenForPool = params.position.collateralToken();\n            values.pnlAmountForPool = -values.positionPnlUsd / collateralTokenPrice.min.toInt256();\n            values.remainingCollateralAmount -= values.pnlAmountForPool;\n        } else {\n            // position realizes a profit\n            // deduct the pnl from the pool\n            values.pnlTokenForPool = cache.pnlToken;\n            values.pnlAmountForPool = -values.positionPnlUsd / cache.pnlTokenPrice.max.toInt256();\n            values.pnlAmountForUser = collateralCache.adjustedPositionPnlUsd.toUint256() / cache.pnlTokenPrice.max;\n\n            // if the price impact was capped send the difference to a holding area\n            collateralCache.pnlDiffAmount = (-values.pnlAmountForPool - values.pnlAmountForUser.toInt256()).toUint256();\n            if (collateralCache.pnlDiffAmount > 0) {\n                MarketUtils.incrementClaimableCollateralAmount(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.market.marketToken,\n                    cache.pnlToken,\n                    params.order.receiver(),\n                    collateralCache.pnlDiffAmount\n                );\n            }\n\n            // swap profit to the collateral token here so that the profit can be used\n            // to pay for the totalNetCostAmount from the fees\n            (bool wasSwapped, uint256 swapOutputAmount) = swapProfitToCollateralToken(\n                params,\n                cache.pnlToken,\n                values.pnlAmountForUser\n            );\n\n            if (wasSwapped) {\n                values.output.outputAmount += swapOutputAmount;\n            } else {\n                if (params.position.collateralToken() == cache.pnlToken) {\n                    values.output.outputAmount += values.pnlAmountForUser;\n                } else {\n                    // store the pnlAmountForUser separately as it differs from the collateralToken\n                    values.output.secondaryOutputAmount = values.pnlAmountForUser;\n                }\n            }\n        }\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            collateralTokenPrice,\n            params.market.longToken,\n            params.market.shortToken,\n            params.order.sizeDeltaUsd()\n        );\n\n        // if there is a positive outputAmount, use the outputAmount to pay for fees and price impact\n        // the values.output.outputToken should be the same as the position.collateralToken at this point\n        if (values.output.outputToken == params.position.collateralToken() && values.output.outputAmount > 0) {\n            if (values.output.outputAmount > fees.totalNetCostAmount) {\n                values.output.outputAmount -= fees.totalNetCostAmount;\n                fees.totalNetCostAmount = 0;\n            } else {\n                fees.totalNetCostAmount -= values.output.outputAmount;\n                values.output.outputAmount = 0;\n            }\n        }\n\n        // deduct remaining fees from the position's collateral\n        values.remainingCollateralAmount -= fees.totalNetCostAmount.toInt256();\n\n        // if there is insufficient collateral remaining then prioritize using the collateral to pay\n        // funding fees, the rest of the collateral is sent to the pool\n        // paying of closing fees should be safe to skip\n        // any difference in the paying of borrowing fees should be accounted for\n        // from the transfer of collateral to the pool and by the update of the\n        // pending borrowing fees\n        // any difference in pending negative PnL should similarly be accounted for\n        // through the transfer fo collateral to the pool and by the update of the\n        // pending pnl\n        // paying of price impact should also be safe to skip, it would be the same as\n        // closing the position with zero price impact, just that if there were any collateral that could\n        // partially pay for negative price impact, it would be sent to the pool instead\n        if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && values.remainingCollateralAmount < 0) {\n            PositionPricingUtils.emitPositionFeesInfo(\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                false,\n                fees\n            );\n\n            PositionEventUtils.emitLiquidationInfo(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                params.position.collateralAmount(),\n                values.positionPnlUsd,\n                values.remainingCollateralAmount\n            );\n\n            return getLiquidationValues(params, values, fees);\n        }\n\n        if (values.remainingCollateralAmount < 0) {\n            revert InsufficientCollateral(values.remainingCollateralAmount);\n        }\n\n        // if there is a positive impact, the impact pool amount should be reduced\n        // if there is a negative impact, the impact pool amount should be increased\n        MarketUtils.applyDeltaToPositionImpactPool(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            -values.priceImpactAmount\n        );\n\n        // if the price impact was capped, deduct the difference from the collateral\n        // and send it to a holding area\n        if (collateralCache.adjustedPriceImpactDiffAmount > 0) {\n            if (values.remainingCollateralAmount.toUint256() < collateralCache.adjustedPriceImpactDiffAmount) {\n                collateralCache.adjustedPriceImpactDiffAmount = values.remainingCollateralAmount.toUint256();\n            }\n\n            values.remainingCollateralAmount -= collateralCache.adjustedPriceImpactDiffAmount.toInt256();\n\n            MarketUtils.incrementClaimableCollateralAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                params.order.receiver(),\n                collateralCache.adjustedPriceImpactDiffAmount\n            );\n        }\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeReceiverAmount,\n            Keys.POSITION_FEE\n        );\n\n        return (values, fees);\n    }\n\n    function getExecutionPrice(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices,\n        uint256 sizeDeltaUsd\n    ) internal view returns (uint256, int256, uint256) {\n        int256 priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                params.market.indexToken,\n                params.market.longToken,\n                params.market.shortToken,\n                -sizeDeltaUsd.toInt256(),\n                params.order.isLong()\n            )\n        );\n\n        priceImpactUsd = MarketUtils.getCappedPositionImpactUsd(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            prices.indexTokenPrice,\n            priceImpactUsd,\n            sizeDeltaUsd\n        );\n\n        uint256 priceImpactDiffUsd;\n        if (priceImpactUsd < 0) {\n            uint256 maxPriceImpactFactor = MarketUtils.getMaxPositionImpactFactor(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                false\n            );\n\n            // convert the max price impact to the min negative value\n            int256 minPriceImpactUsd = -Precision.applyFactor(sizeDeltaUsd, maxPriceImpactFactor).toInt256();\n\n            if (priceImpactUsd < minPriceImpactUsd) {\n                priceImpactDiffUsd = (minPriceImpactUsd - priceImpactUsd).toUint256();\n                priceImpactUsd = minPriceImpactUsd;\n            }\n        }\n\n        uint256 executionPrice = BaseOrderUtils.getExecutionPrice(\n            params.contracts.oracle.getCustomPrice(params.market.indexToken),\n            sizeDeltaUsd,\n            priceImpactUsd,\n            params.order.acceptablePrice(),\n            params.position.isLong(),\n            false\n        );\n\n        int256 priceImpactAmount = PositionPricingUtils.getPriceImpactAmount(\n            sizeDeltaUsd,\n            executionPrice,\n            prices.indexTokenPrice,\n            params.position.isLong(),\n            false\n        );\n\n        return (executionPrice, priceImpactAmount, priceImpactDiffUsd);\n    }\n\n    function getLiquidationValues(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCollateralValues memory values,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal returns (\n        PositionUtils.DecreasePositionCollateralValues memory,\n        PositionPricingUtils.PositionFees memory\n    ) {\n        if (fees.funding.fundingFeeAmount > params.position.collateralAmount()) {\n            values.pnlAmountForPool = 0;\n            // the case where this is insufficient collateral to pay funding fees\n            // should be rare, and the difference should be small\n            // in case it happens, the pool should be topped up with the required amount using\n            // an insurance fund or similar mechanism\n            PositionEventUtils.emitInsufficientFundingFeePayment(\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                fees.funding.fundingFeeAmount,\n                params.position.collateralAmount()\n            );\n        } else {\n            values.pnlAmountForPool = (params.position.collateralAmount() - fees.funding.fundingFeeAmount).toInt256();\n        }\n\n        PositionPricingUtils.PositionFees memory _fees;\n\n        PositionUtils.DecreasePositionCollateralValues memory _values = PositionUtils.DecreasePositionCollateralValues(\n            values.pnlTokenForPool,\n            values.executionPrice, // executionPrice\n            0, // remainingCollateralAmount\n            values.positionPnlUsd, // positionPnlUsd\n            values.pnlAmountForPool, // pnlAmountForPool\n            0, // pnlAmountForUser\n            values.sizeDeltaInTokens, // sizeDeltaInTokens\n            values.priceImpactAmount, // priceImpactAmount\n            0, // priceImpactDiffUsd\n            0, // priceImpactDiffAmount\n            PositionUtils.DecreasePositionCollateralValuesOutput(\n                address(0),\n                0,\n                address(0),\n                0\n            )\n        );\n\n        return (_values, _fees);\n    }\n\n    // swap the withdrawn collateral from collateralToken to pnlToken if needed\n    function swapWithdrawnCollateralToPnlToken(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCollateralValues memory values\n    ) external returns (PositionUtils.DecreasePositionCollateralValues memory) {\n        if (params.order.decreasePositionSwapType() == Order.DecreasePositionSwapType.SwapCollateralTokenToPnlToken) {\n            Market.Props[] memory swapPathMarkets = new Market.Props[](1);\n            swapPathMarkets[0] = params.market;\n\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(params.market.marketToken)),\n                    params.position.collateralToken(), // tokenIn\n                    values.output.outputAmount, // amountIn\n                    swapPathMarkets, // markets\n                    0, // minOutputAmount\n                    params.market.marketToken, // receiver\n                    false // shouldUnwrapNativeToken\n                )\n            ) returns (address tokenOut, uint256 swapOutputAmount) {\n                if (tokenOut != values.output.secondaryOutputToken) {\n                    revert InvalidOutputToken(tokenOut, values.output.secondaryOutputToken);\n                }\n                // combine the values into outputToken and outputAmount\n                values.output.outputToken = tokenOut;\n                values.output.outputAmount = values.output.secondaryOutputAmount + swapOutputAmount;\n                values.output.secondaryOutputAmount = 0;\n            } catch Error(string memory reason) {\n                emit SwapUtils.SwapReverted(reason, \"\");\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                emit SwapUtils.SwapReverted(reason, reasonBytes);\n            }\n        }\n\n        return values;\n    }\n\n    // swap the realized profit from the pnlToken to the collateralToken if needed\n    function swapProfitToCollateralToken(\n        PositionUtils.UpdatePositionParams memory params,\n        address pnlToken,\n        uint256 profitAmount\n    ) internal returns (bool, uint256) {\n        if (params.order.decreasePositionSwapType() == Order.DecreasePositionSwapType.SwapPnlTokenToCollateralToken) {\n            Market.Props[] memory swapPathMarkets = new Market.Props[](1);\n            swapPathMarkets[0] = params.market;\n\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(params.market.marketToken)),\n                    pnlToken, // tokenIn\n                    profitAmount, // amountIn\n                    swapPathMarkets, // markets\n                    0, // minOutputAmount\n                    params.market.marketToken, // receiver\n                    false // shouldUnwrapNativeToken\n                )\n            ) returns (address /* tokenOut */, uint256 swapOutputAmount) {\n                return (true, swapOutputAmount);\n            } catch Error(string memory reason) {\n                emit SwapUtils.SwapReverted(reason, \"\");\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                emit SwapUtils.SwapReverted(reason, reasonBytes);\n            }\n        }\n\n        return (false, 0);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/DecreaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../position/DecreasePositionUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title DecreaseOrderUtils\n// @dev Library for functions to help with processing a decrease order\nlibrary DecreaseOrderUtils {\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a decrease order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        Order.Props memory order = params.order;\n        MarketUtils.validateEnabledMarket(params.contracts.dataStore, params.market);\n        MarketUtils.validatePositionMarket(params.market);\n\n        bytes32 positionKey = PositionUtils.getPositionKey(order.account(), order.market(), order.initialCollateralToken(), order.isLong());\n        Position.Props memory position = PositionStoreUtils.get(params.contracts.dataStore, positionKey);\n        PositionUtils.validateNonEmptyPosition(position);\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            order.orderType(),\n            order.updatedAtBlock(),\n            position.increasedAtBlock(),\n            position.decreasedAtBlock()\n        );\n\n        DecreasePositionUtils.DecreasePositionResult memory result = DecreasePositionUtils.decreasePosition(\n            PositionUtils.UpdatePositionParams(\n                params.contracts,\n                params.market,\n                order,\n                params.key,\n                position,\n                positionKey\n            )\n        );\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, order.account());\n\n        // if the pnlToken and the collateralToken are different\n        // and if a swap fails or no swap was requested\n        // then it is possible to receive two separate tokens from decreasing\n        // the position\n        // transfer the two tokens to the user in this case and skip processing\n        // the swapPath\n        if (result.secondaryOutputAmount > 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.secondaryOutputToken,\n                order.receiver(),\n                result.secondaryOutputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            return;\n        }\n\n        if (order.swapPath().length == 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n        } else {\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(order.market())),\n                    result.outputToken,\n                    result.outputAmount,\n                    params.swapPathMarkets,\n                    order.minOutputAmount(),\n                    order.receiver(),\n                    order.shouldUnwrapNativeToken()\n                )\n            ) returns (address /* tokenOut */, uint256 /* swapOutputAmount */) {\n            } catch Error(string memory reason) {\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    \"\"\n                );\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    reasonBytes\n                );\n            }\n        }\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    // @param positionIncreasedAtBlock the block at which the position was last increased\n    // @param positionDecreasedAtBlock the block at which the position was last decreased\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock,\n        uint256 positionIncreasedAtBlock,\n        uint256 positionDecreasedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketDecrease) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        if (orderType == Order.OrderType.Liquidation) {\n            uint256 latestUpdatedAtBlock = positionIncreasedAtBlock > positionDecreasedAtBlock ? positionIncreasedAtBlock : positionDecreasedAtBlock;\n\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    function _handleSwapError(\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n}"
    }
  ]
}