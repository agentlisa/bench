{
  "Title": "[16] `revert` CAN BE CALLED INSTEAD OF `assert` TO PROVIDE CLEARER REASON FOR REVERSION",
  "Content": "When the `ProxyAdmin.upgrade` function reverts due to `assert(false)`, it can be less clear about why such reversion happens since no reason is returned. To provide clearer reason for such reversion, please consider updating the `ProxyAdmin.upgrade` function to call `revert` with an appropriate reason string instead of executing `assert(false)` in the corresponding `else` block.\n\nhttps://github.com/ethereum-optimism/optimism/blob/3b8fcafab4438b17e019c72391f829450a94a434/packages/contracts-bedrock/contracts/universal/ProxyAdmin.sol#L211-L229\n```solidity\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).upgradeTo(_implementation);\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            L1ChugSplashProxy(_proxy).setStorage(\n                // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\n                bytes32(uint256(uint160(_implementation)))\n            );\n        } else if (ptype == ProxyType.RESOLVED) {\n            string memory name = implementationName[_proxy];\n            addressManager.setAddress(name, _implementation);\n        } else {\n            // It should not be possible to retrieve a ProxyType value which is not matched by\n            // one of the previous conditions.\n            assert(false);\n        }\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-base",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/universal/ProxyAdmin.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Proxy } from \"./Proxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\n\n/**\n * @title IStaticERC1967Proxy\n * @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\n */\ninterface IStaticERC1967Proxy {\n    function implementation() external view returns (address);\n\n    function admin() external view returns (address);\n}\n\n/**\n * @title IStaticL1ChugSplashProxy\n * @notice IStaticL1ChugSplashProxy is a static version of the ChugSplash proxy interface.\n */\ninterface IStaticL1ChugSplashProxy {\n    function getImplementation() external view returns (address);\n\n    function getOwner() external view returns (address);\n}\n\n/**\n * @title ProxyAdmin\n * @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\n *         based on the OpenZeppelin implementation. It has backwards compatibility logic to work\n *         with the various types of proxies that have been deployed by Optimism in the past.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @notice The proxy types that the ProxyAdmin can manage.\n     *\n     * @custom:value ERC1967    Represents an ERC1967 compliant transparent proxy interface.\n     * @custom:value CHUGSPLASH Represents the Chugsplash proxy interface (legacy).\n     * @custom:value RESOLVED   Represents the ResolvedDelegate proxy (legacy).\n     */\n    enum ProxyType {\n        ERC1967,\n        CHUGSPLASH,\n        RESOLVED\n    }\n\n    /**\n     * @notice A mapping of proxy types, used for backwards compatibility.\n     */\n    mapping(address => ProxyType) public proxyType;\n\n    /**\n     * @notice A reverse mapping of addresses to names held in the AddressManager. This must be\n     *         manually kept up to date with changes in the AddressManager for this contract\n     *         to be able to work as an admin for the ResolvedDelegateProxy type.\n     */\n    mapping(address => string) public implementationName;\n\n    /**\n     * @notice The address of the address manager, this is required to manage the\n     *         ResolvedDelegateProxy type.\n     */\n    AddressManager public addressManager;\n\n    /**\n     * @notice A legacy upgrading indicator used by the old Chugsplash Proxy.\n     */\n    bool internal upgrading;\n\n    /**\n     * @param _owner Address of the initial owner of this contract.\n     */\n    constructor(address _owner) Ownable() {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Sets the proxy type for a given address. Only required for non-standard (legacy)\n     *         proxy types.\n     *\n     * @param _address Address of the proxy.\n     * @param _type    Type of the proxy.\n     */\n    function setProxyType(address _address, ProxyType _type) external onlyOwner {\n        proxyType[_address] = _type;\n    }\n\n    /**\n     * @notice Sets the implementation name for a given address. Only required for\n     *         ResolvedDelegateProxy type proxies that have an implementation name.\n     *\n     * @param _address Address of the ResolvedDelegateProxy.\n     * @param _name    Name of the implementation for the proxy.\n     */\n    function setImplementationName(address _address, string memory _name) external onlyOwner {\n        implementationName[_address] = _name;\n    }\n\n    /**\n     * @notice Set the address of the AddressManager. This is required to manage legacy\n     *         ResolvedDelegateProxy type proxy contracts.\n     *\n     * @param _address Address of the AddressManager.\n     */\n    function setAddressManager(AddressManager _address) external onlyOwner {\n        addressManager = _address;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Set an address in the address manager. Since only the owner of the AddressManager\n     *         can directly modify addresses and the ProxyAdmin will own the AddressManager, this\n     *         gives the owner of the ProxyAdmin the ability to modify addresses directly.\n     *\n     * @param _name    Name to set within the AddressManager.\n     * @param _address Address to attach to the given name.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {\n        addressManager.setAddress(_name, _address);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Set the upgrading status for the Chugsplash proxy type.\n     *\n     * @param _upgrading Whether or not the system is upgrading.\n     */\n    function setUpgrading(bool _upgrading) external onlyOwner {\n        upgrading = _upgrading;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy function used to tell ChugSplashProxy contracts if an upgrade is happening.\n     *\n     * @return Whether or not there is an upgrade going on. May not actually tell you whether an\n     *         upgrade is going on, since we don't currently plan to use this variable for anything\n     *         other than a legacy indicator to fix a UX bug in the ChugSplash proxy.\n     */\n    function isUpgrading() external view returns (bool) {\n        return upgrading;\n    }\n\n    /**\n     * @notice Returns the implementation of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the implementation of.\n     *\n     * @return Address of the implementation of the proxy.\n     */\n    function getProxyImplementation(address _proxy) external view returns (address) {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            return IStaticERC1967Proxy(_proxy).implementation();\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            return IStaticL1ChugSplashProxy(_proxy).getImplementation();\n        } else if (ptype == ProxyType.RESOLVED) {\n            return addressManager.getAddress(implementationName[_proxy]);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @notice Returns the admin of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the admin of.\n     *\n     * @return Address of the admin of the proxy.\n     */\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            return IStaticERC1967Proxy(_proxy).admin();\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            return IStaticL1ChugSplashProxy(_proxy).getOwner();\n        } else if (ptype == ProxyType.RESOLVED) {\n            return addressManager.owner();\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @notice Updates the admin of the given proxy address.\n     *\n     * @param _proxy    Address of the proxy to update.\n     * @param _newAdmin Address of the new proxy admin.\n     */\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).changeAdmin(_newAdmin);\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            L1ChugSplashProxy(_proxy).setOwner(_newAdmin);\n        } else if (ptype == ProxyType.RESOLVED) {\n            addressManager.transferOwnership(_newAdmin);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     */\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).upgradeTo(_implementation);\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            L1ChugSplashProxy(_proxy).setStorage(\n                // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\n                bytes32(uint256(uint160(_implementation)))\n            );\n        } else if (ptype == ProxyType.RESOLVED) {\n            string memory name = implementationName[_proxy];\n            addressManager.setAddress(name, _implementation);\n        } else {\n            // It should not be possible to retrieve a ProxyType value which is not matched by\n            // one of the previous conditions.\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract and delegatecalls the new implementation\n     *         with some given data. Useful for atomic upgrade-and-initialize calls.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     * @param _data           Data to trigger the new implementation with.\n     */\n    function upgradeAndCall(\n        address payable _proxy,\n        address _implementation,\n        bytes memory _data\n    ) external payable onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\n        } else {\n            // reverts if proxy type is unknown\n            upgrade(_proxy, _implementation);\n            (bool success, ) = _proxy.call{ value: msg.value }(_data);\n            require(success, \"ProxyAdmin: call to proxy after upgrade failed\");\n        }\n    }\n}"
    }
  ]
}