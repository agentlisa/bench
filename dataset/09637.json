{
  "Title": "[G-01] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
  "Content": "\n1.  File: core-contracts/contracts/ERC721Payable.sol (lines [21-24](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L21-L24))\n\n```solidity\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n```\n\n2.  File: core-contracts/contracts/ERC721Payable.sol (lines [29-32](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L29-L32))\n\n```solidity\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n```\n\n3.  File: core-contracts/contracts/ERC721Claimable.sol (line [23](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L23))\n\n```solidity\n    require(!claimableSet(), 'ERC721Claimable: Claimable is already set');\n```\n\n4.  File: core-contracts/contracts/CoreCollection.sol (line [47](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L47))\n\n```solidity\n        require(!initialized, \"CoreCollection: Already initialized\");\n```\n\n5.  File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55))\n\n```solidity\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n```\n\n6.  File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146))\n\n```solidity\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n```\n\n7.  File: core-contracts/contracts/CoreCollection.sol (lines [189-192](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L189-L192))\n\n```solidity\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n```\n\n8.  File: core-contracts/contracts/CoreCollection.sol (lines [204-207](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L204-L207))\n\n```solidity\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n```\n\n9.  File: core-contracts/contracts/CoreCollection.sol (lines [220-223](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L220-L223))\n\n```solidity\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n```\n\n10. File: core-contracts/contracts/CoreFactory.sol (lines [35-38](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L35-L38))\n\n```solidity\n    require(\n      projects[_projectId].creator == address(0),\n      'CoreFactory: Unavailable project id'\n    );\n```\n\n11. File: core-contracts/contracts/CoreFactory.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L43-L46))\n\n```solidity\n    require(\n      projects[_projectId].creator == msg.sender,\n      'CoreFactory: Not an owner of the project'\n    );\n```\n\n12. File: core-contracts/contracts/CoreFactory.sol (lines [51-54](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L51-L54))\n\n```solidity\n    require(\n      collections[_collectionId] == address(0),\n      'CoreFactory: Unavailable collection id'\n    );\n```\n\n13. File: core-contracts/contracts/CoreFactory.sol (lines [74-77](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L74-L77))\n\n```solidity\n    require(\n      _collections.length > 0,\n      'CoreFactory: should have more at least one collection'\n    );\n```\n\n14. File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37))\n\n```solidity\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n```\n\n15. File: royalty-vault/contracts/RoyaltyVault.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L46))\n\n```solidity\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n```\n\n16. File: royalty-vault/contracts/RoyaltyVault.sol (lines [47-50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L47-L50))\n\n```solidity\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n```\n\n17. File: royalty-vault/contracts/RoyaltyVault.sol (lines [51-57](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51-L57))\n\n```solidity\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n```\n\n18. File: splits/contracts/SplitFactory.sol (lines [48-51](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L48-L51))\n\n```solidity\n    require(\n      splits[_splitId] == address(0),\n      'SplitFactory : Split ID already in use'\n    );\n```\n\n19. File: splits/contracts/SplitFactory.sol (lines [81-84](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L81-L84))\n\n```solidity\n    require(\n      ICoreCollection(_collectionContract).owner() == msg.sender,\n      'Transaction sender is not collection owner'\n    );\n```\n\n20. File: splits/contracts/Splitter.sol (lines [118-121](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L118-L121))\n\n```solidity\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-03-joyn-contest",
  "Code": [
    {
      "filename": "core-contracts/contracts/ERC721Payable.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nabstract contract ERC721Payable {\n  uint256 public mintFee;\n  IERC20 public payableToken;\n  bool public isForSale;\n  address public royaltyVault;\n  address public splitFactory;\n  event NewPayment(\n    address from,\n    address to,\n    uint256 amount,\n    bool royaltyVaultPayment\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyVaultUninitialized() {\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n    _;\n  }\n\n  modifier onlyVaultInitialized() {\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function royaltyVaultInitialized() public view returns (bool) {\n    return royaltyVault != address(0);\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  /**\n   * @notice Handles the transfer of ERC20 tokens when a token gets minted\n   * @dev Tokens are transferred to the Royalty Vault if the vault is set\n   * Otherwise, tokens get transferred to the ERC721 collection contract\n   * @param _amount The amount of ERC20 to be transferred\n   */\n  function _handlePayment(uint256 _amount) internal {\n    address recipient = royaltyVaultInitialized()\n      ? royaltyVault\n      : address(this);\n    payableToken.transferFrom(msg.sender, recipient, _amount);\n    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());\n  }\n}"
    },
    {
      "filename": "core-contracts/contracts/ERC721Payable.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nabstract contract ERC721Payable {\n  uint256 public mintFee;\n  IERC20 public payableToken;\n  bool public isForSale;\n  address public royaltyVault;\n  address public splitFactory;\n  event NewPayment(\n    address from,\n    address to,\n    uint256 amount,\n    bool royaltyVaultPayment\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyVaultUninitialized() {\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n    _;\n  }\n\n  modifier onlyVaultInitialized() {\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function royaltyVaultInitialized() public view returns (bool) {\n    return royaltyVault != address(0);\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  /**\n   * @notice Handles the transfer of ERC20 tokens when a token gets minted\n   * @dev Tokens are transferred to the Royalty Vault if the vault is set\n   * Otherwise, tokens get transferred to the ERC721 collection contract\n   * @param _amount The amount of ERC20 to be transferred\n   */\n  function _handlePayment(uint256 _amount) internal {\n    address recipient = royaltyVaultInitialized()\n      ? royaltyVault\n      : address(this);\n    payableToken.transferFrom(msg.sender, recipient, _amount);\n    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());\n  }\n}"
    },
    {
      "filename": "core-contracts/contracts/ERC721Claimable.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\n\nabstract contract ERC721Claimable {\n  bytes32 private _merkleRoot;\n  mapping(address => uint256) private _claimedAmount;\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyValidRoot(bytes32 root) {\n    require(root != bytes32(0), 'ERC721Claimable: Not valid root');\n    _;\n  }\n\n  modifier onlyClaimableSet() {\n    require(claimableSet(), 'ERC721Claimable: No claimable');\n    _;\n  }\n\n  modifier onlyNotClaimableSet() {\n    require(!claimableSet(), 'ERC721Claimable: Claimable is already set');\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function claimableSet() public view returns (bool) {\n    return getMerkleRoot() != bytes32(0);\n  }\n\n  function verifyProof(\n    bytes32[] memory proof,\n    bytes32 root,\n    bytes32 leaf\n  ) public pure returns (bool) {\n    return MerkleProof.verify(proof, root, leaf);\n  }\n\n  function processProof(bytes32[] memory proof, bytes32 leaf)\n    public\n    pure\n    returns (bytes32)\n  {\n    return MerkleProof.processProof(proof, leaf);\n  }\n\n  /**\n   * @notice Verifies whether an address can claim tokens\n   * @dev \n   * @param who Claimer address\n   * @param claimableAmount Amount airdropped to claimer\n   * @param claimedAmount Amount of tokens claimer wants to claim\n   * @param merkleProof Proof\n   */\n  function canClaim(\n    address who,\n    uint256 claimableAmount,\n    uint256 claimedAmount,\n    bytes32[] calldata merkleProof\n  ) public view returns (bool) {\n    require(\n      verifyProof(merkleProof, getMerkleRoot(), getNode(who, claimableAmount)),\n      'ERC721Claimable: Invalid proof'\n    );\n\n    return _claimedAmount[who] + claimedAmount <= claimableAmount;\n  }\n\n  function getMerkleRoot() public view returns (bytes32) {\n    return _merkleRoot;\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  function _setMerkelRoot(bytes32 root) internal {\n    _merkleRoot = root;\n  }\n\n  function _claim(address claimer, uint256 claimedAmount) internal {\n    _claimedAmount[claimer] += claimedAmount;\n  }\n\n  // ---------------- PRIVATE ----------------\n\n  /**\n   * @dev get Node hash of given data.\n   * @param who {address} Membership contract address\n   * @param claimableAmount {uint256} token id which claiming person owns\n   * @return {bytes32} node hash\n   */\n  function getNode(address who, uint256 claimableAmount)\n    private\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(who, claimableAmount));\n  }\n}"
    },
    {
      "filename": "core-contracts/contracts/CoreCollection.sol",
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\r\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\r\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\r\n\r\ncontract CoreCollection is\r\n    Ownable,\r\n    ERC721Claimable,\r\n    ERC721Enumerable,\r\n    ERC721Payable\r\n{\r\n    bool public initialized;\r\n    string private _name;\r\n    string private _symbol;\r\n    string private _baseUri;\r\n    uint256 public maxSupply;\r\n    uint256 public startingIndex;\r\n    uint256 public startingIndexBlock;\r\n    string public HASHED_PROOF = \"\";\r\n\r\n    event ClaimInitialized(bytes32 root);\r\n    event NewCollectionMeta(string name, string symbol);\r\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\r\n    event StartingIndexSet(uint256 index);\r\n    event RoyaltyVaultInitialized(address royaltyVault);\r\n    event NewHashedProof(string proof);\r\n    event NewWithdrawal(address to, uint256 amount);\r\n\r\n    constructor() ERC721(\"\", \"\") {}\r\n\r\n    // ----------------- MODIFIER -----------------\r\n\r\n    modifier onlyInitialized() {\r\n        require(initialized, \"CoreCollection: Not initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnInitialized() {\r\n        require(!initialized, \"CoreCollection: Already initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidSupply(uint256 _maxSupply) {\r\n        require(\r\n            _maxSupply > 0,\r\n            \"CoreCollection: Max supply should be greater than 0\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier tokenExists(uint256 _tokenId) {\r\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\r\n        _;\r\n    }\r\n\r\n    // ----------------- EXTERNAL -----------------\r\n\r\n    /**\r\n     * @notice Initializes the collection\r\n     * @dev This method is being called from the CoreFactory contract\r\n     * @param _collectionName Name of the collection\r\n     * @param _collectionSymbol Symbol of the collection\r\n     * @param _collectionURI Base URI for the collection\r\n     * @param _maxSupply The maximum number of tokens that can be minted\r\n     * @param _mintFee The price of a token in this collection\r\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\r\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\r\n     * @param _splitFactory base URI for the collection\r\n     */\r\n    function initialize(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol,\r\n        string memory _collectionURI,\r\n        uint256 _maxSupply,\r\n        uint256 _mintFee,\r\n        address _payableToken,\r\n        bool _isForSale,\r\n        address _splitFactory\r\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        _baseUri = _collectionURI;\r\n        maxSupply = _maxSupply;\r\n        mintFee = _mintFee;\r\n        payableToken = IERC20(_payableToken);\r\n        isForSale = _isForSale;\r\n        splitFactory = _splitFactory;\r\n        initialized = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to airdrop tokens\r\n     * @dev The Merkle tree defines for each address how much token can be claimed\r\n     * @dev This method can only be called once\r\n     * @param _root A Merkle root\r\n     */\r\n    function initializeClaims(bytes32 _root)\r\n        external\r\n        onlyOwner\r\n        onlyNotClaimableSet\r\n        onlyValidRoot(_root)\r\n    {\r\n        _setMerkelRoot(_root);\r\n        emit ClaimInitialized(_root);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to change the collection's name and symbol\r\n     * @dev This function is only callable by the collection's owner\r\n     * @param _collectionName A collection name\r\n     * @param _collectionSymbol A collection symbol\r\n     */\r\n    function setCollectionMeta(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol\r\n    ) external onlyOwner {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called to mint tokens from this ERC721 collection\r\n     * @dev The collection must be initialized first\r\n     * @param to Token recipient\r\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\r\n     * @param claimableAmount The amount of tokens the user has been airdropped\r\n     * @param amount The amount of tokens the user wants to mint\r\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\r\n     */\r\n    function mintToken(\r\n        address to,\r\n        bool isClaim,\r\n        uint256 claimableAmount,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) external onlyInitialized {\r\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\r\n        require(\r\n            totalSupply() + amount <= maxSupply,\r\n            \"CoreCollection: Over Max Supply\"\r\n        );\r\n\r\n        if (isClaim) {\r\n            require(claimableSet(), \"CoreCollection: No claimable\");\r\n            require(\r\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\r\n                \"CoreCollection: Can't claim\"\r\n            );\r\n            _claim(msg.sender, amount);\r\n        } else {\r\n            require(isForSale, \"CoreCollection: Not for sale\");\r\n            if (mintFee > 0) {\r\n                _handlePayment(mintFee * amount);\r\n            }\r\n        }\r\n\r\n        batchMint(to, amount, isClaim);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\r\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        uint256 amount = payableToken.balanceOf(address(this));\r\n        payableToken.transferFrom(address(this), msg.sender, amount);\r\n        emit NewWithdrawal(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set royalty vault address for collection\r\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \r\n     * from the collection are transferred to the vault when the vault is initialized\r\n     * @param _royaltyVault The address of the royalty vault\r\n     */\r\n    function setRoyaltyVault(address _royaltyVault)\r\n        external\r\n        onlyVaultUninitialized\r\n    {\r\n        require(\r\n            msg.sender == splitFactory || msg.sender == owner(),\r\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\r\n        );\r\n        royaltyVault = _royaltyVault;\r\n        emit RoyaltyVaultInitialized(_royaltyVault);\r\n    }\r\n\r\n    /**\r\n     * @notice Set a provenance hash\r\n     * @dev This hash is used to verify the minting ordering of a collection (à la BAYC)\r\n     * This hash is generated off-chain\r\n     * @param _proof The SHA256 generated hash\r\n     */\r\n    function setHashedProof(string calldata _proof) external onlyOwner {\r\n        require(\r\n            bytes(HASHED_PROOF).length == 0,\r\n            \"CoreCollection: Hashed Proof is set\"\r\n        );\r\n\r\n        HASHED_PROOF = _proof;\r\n        emit NewHashedProof(_proof);\r\n    }\r\n\r\n    // ----------------- PUBLIC -----------------\r\n\r\n    /**\r\n     * @notice Set the mint starting index\r\n     * @dev The starting index can only be generated once\r\n     */\r\n    function setStartingIndex() public {\r\n        require(\r\n            startingIndex == 0,\r\n            \"CoreCollection: Starting index is already set\"\r\n        );\r\n\r\n        startingIndex =\r\n            (uint256(\r\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\r\n            ) % maxSupply) +\r\n            1;\r\n        startingIndexBlock = uint256(block.number);\r\n        emit StartingIndexSet(startingIndex);\r\n    }\r\n\r\n    // ---------------- VIEW ----------------\r\n\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function baseURI() public view returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    // ---------------- PRIVATE ----------------\r\n\r\n    /**\r\n     * @notice Mint token\r\n     * @dev A starting index is calculated at the time of first mint\r\n     * returns a tokenId\r\n     * @param _to Token recipient\r\n     */\r\n    function mint(address _to) private returns (uint256 tokenId) {\r\n        if (startingIndex == 0) {\r\n            setStartingIndex();\r\n        }\r\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\r\n        _mint(_to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint tokens in batch\r\n     * @param _to Token recipient\r\n     * @param _amount Number of tokens to include in batch\r\n     * @param _isClaim Whether the batch mint is an airdrop or not\r\n     */\r\n    function batchMint(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _isClaim\r\n    ) private {\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            uint256 tokenId = mint(_to);\r\n            if (_isClaim) {\r\n                emit NewClaim(msg.sender, _to, tokenId);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ---------------- INTERNAL ----------------\r\n\r\n    /**\r\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\r\n     * @dev The split contract is a contract that allows a team to share revenue together\r\n     * @param _from Transfer sender\r\n     * @param _to Transfer recipient\r\n     * @param _tokenId TokenId of token being transferred\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(_from, _to, _tokenId);\r\n\r\n        if (\r\n            royaltyVault != address(0) &&\r\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\r\n        ) {\r\n            IRoyaltyVault(royaltyVault).sendToSplitter();\r\n        }\r\n    }\r\n}"
    },
    {
      "filename": "core-contracts/contracts/CoreCollection.sol",
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\r\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\r\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\r\n\r\ncontract CoreCollection is\r\n    Ownable,\r\n    ERC721Claimable,\r\n    ERC721Enumerable,\r\n    ERC721Payable\r\n{\r\n    bool public initialized;\r\n    string private _name;\r\n    string private _symbol;\r\n    string private _baseUri;\r\n    uint256 public maxSupply;\r\n    uint256 public startingIndex;\r\n    uint256 public startingIndexBlock;\r\n    string public HASHED_PROOF = \"\";\r\n\r\n    event ClaimInitialized(bytes32 root);\r\n    event NewCollectionMeta(string name, string symbol);\r\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\r\n    event StartingIndexSet(uint256 index);\r\n    event RoyaltyVaultInitialized(address royaltyVault);\r\n    event NewHashedProof(string proof);\r\n    event NewWithdrawal(address to, uint256 amount);\r\n\r\n    constructor() ERC721(\"\", \"\") {}\r\n\r\n    // ----------------- MODIFIER -----------------\r\n\r\n    modifier onlyInitialized() {\r\n        require(initialized, \"CoreCollection: Not initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnInitialized() {\r\n        require(!initialized, \"CoreCollection: Already initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidSupply(uint256 _maxSupply) {\r\n        require(\r\n            _maxSupply > 0,\r\n            \"CoreCollection: Max supply should be greater than 0\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier tokenExists(uint256 _tokenId) {\r\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\r\n        _;\r\n    }\r\n\r\n    // ----------------- EXTERNAL -----------------\r\n\r\n    /**\r\n     * @notice Initializes the collection\r\n     * @dev This method is being called from the CoreFactory contract\r\n     * @param _collectionName Name of the collection\r\n     * @param _collectionSymbol Symbol of the collection\r\n     * @param _collectionURI Base URI for the collection\r\n     * @param _maxSupply The maximum number of tokens that can be minted\r\n     * @param _mintFee The price of a token in this collection\r\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\r\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\r\n     * @param _splitFactory base URI for the collection\r\n     */\r\n    function initialize(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol,\r\n        string memory _collectionURI,\r\n        uint256 _maxSupply,\r\n        uint256 _mintFee,\r\n        address _payableToken,\r\n        bool _isForSale,\r\n        address _splitFactory\r\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        _baseUri = _collectionURI;\r\n        maxSupply = _maxSupply;\r\n        mintFee = _mintFee;\r\n        payableToken = IERC20(_payableToken);\r\n        isForSale = _isForSale;\r\n        splitFactory = _splitFactory;\r\n        initialized = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to airdrop tokens\r\n     * @dev The Merkle tree defines for each address how much token can be claimed\r\n     * @dev This method can only be called once\r\n     * @param _root A Merkle root\r\n     */\r\n    function initializeClaims(bytes32 _root)\r\n        external\r\n        onlyOwner\r\n        onlyNotClaimableSet\r\n        onlyValidRoot(_root)\r\n    {\r\n        _setMerkelRoot(_root);\r\n        emit ClaimInitialized(_root);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to change the collection's name and symbol\r\n     * @dev This function is only callable by the collection's owner\r\n     * @param _collectionName A collection name\r\n     * @param _collectionSymbol A collection symbol\r\n     */\r\n    function setCollectionMeta(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol\r\n    ) external onlyOwner {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called to mint tokens from this ERC721 collection\r\n     * @dev The collection must be initialized first\r\n     * @param to Token recipient\r\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\r\n     * @param claimableAmount The amount of tokens the user has been airdropped\r\n     * @param amount The amount of tokens the user wants to mint\r\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\r\n     */\r\n    function mintToken(\r\n        address to,\r\n        bool isClaim,\r\n        uint256 claimableAmount,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) external onlyInitialized {\r\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\r\n        require(\r\n            totalSupply() + amount <= maxSupply,\r\n            \"CoreCollection: Over Max Supply\"\r\n        );\r\n\r\n        if (isClaim) {\r\n            require(claimableSet(), \"CoreCollection: No claimable\");\r\n            require(\r\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\r\n                \"CoreCollection: Can't claim\"\r\n            );\r\n            _claim(msg.sender, amount);\r\n        } else {\r\n            require(isForSale, \"CoreCollection: Not for sale\");\r\n            if (mintFee > 0) {\r\n                _handlePayment(mintFee * amount);\r\n            }\r\n        }\r\n\r\n        batchMint(to, amount, isClaim);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\r\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        uint256 amount = payableToken.balanceOf(address(this));\r\n        payableToken.transferFrom(address(this), msg.sender, amount);\r\n        emit NewWithdrawal(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set royalty vault address for collection\r\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \r\n     * from the collection are transferred to the vault when the vault is initialized\r\n     * @param _royaltyVault The address of the royalty vault\r\n     */\r\n    function setRoyaltyVault(address _royaltyVault)\r\n        external\r\n        onlyVaultUninitialized\r\n    {\r\n        require(\r\n            msg.sender == splitFactory || msg.sender == owner(),\r\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\r\n        );\r\n        royaltyVault = _royaltyVault;\r\n        emit RoyaltyVaultInitialized(_royaltyVault);\r\n    }\r\n\r\n    /**\r\n     * @notice Set a provenance hash\r\n     * @dev This hash is used to verify the minting ordering of a collection (à la BAYC)\r\n     * This hash is generated off-chain\r\n     * @param _proof The SHA256 generated hash\r\n     */\r\n    function setHashedProof(string calldata _proof) external onlyOwner {\r\n        require(\r\n            bytes(HASHED_PROOF).length == 0,\r\n            \"CoreCollection: Hashed Proof is set\"\r\n        );\r\n\r\n        HASHED_PROOF = _proof;\r\n        emit NewHashedProof(_proof);\r\n    }\r\n\r\n    // ----------------- PUBLIC -----------------\r\n\r\n    /**\r\n     * @notice Set the mint starting index\r\n     * @dev The starting index can only be generated once\r\n     */\r\n    function setStartingIndex() public {\r\n        require(\r\n            startingIndex == 0,\r\n            \"CoreCollection: Starting index is already set\"\r\n        );\r\n\r\n        startingIndex =\r\n            (uint256(\r\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\r\n            ) % maxSupply) +\r\n            1;\r\n        startingIndexBlock = uint256(block.number);\r\n        emit StartingIndexSet(startingIndex);\r\n    }\r\n\r\n    // ---------------- VIEW ----------------\r\n\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function baseURI() public view returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    // ---------------- PRIVATE ----------------\r\n\r\n    /**\r\n     * @notice Mint token\r\n     * @dev A starting index is calculated at the time of first mint\r\n     * returns a tokenId\r\n     * @param _to Token recipient\r\n     */\r\n    function mint(address _to) private returns (uint256 tokenId) {\r\n        if (startingIndex == 0) {\r\n            setStartingIndex();\r\n        }\r\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\r\n        _mint(_to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint tokens in batch\r\n     * @param _to Token recipient\r\n     * @param _amount Number of tokens to include in batch\r\n     * @param _isClaim Whether the batch mint is an airdrop or not\r\n     */\r\n    function batchMint(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _isClaim\r\n    ) private {\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            uint256 tokenId = mint(_to);\r\n            if (_isClaim) {\r\n                emit NewClaim(msg.sender, _to, tokenId);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ---------------- INTERNAL ----------------\r\n\r\n    /**\r\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\r\n     * @dev The split contract is a contract that allows a team to share revenue together\r\n     * @param _from Transfer sender\r\n     * @param _to Transfer recipient\r\n     * @param _tokenId TokenId of token being transferred\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(_from, _to, _tokenId);\r\n\r\n        if (\r\n            royaltyVault != address(0) &&\r\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\r\n        ) {\r\n            IRoyaltyVault(royaltyVault).sendToSplitter();\r\n        }\r\n    }\r\n}"
    },
    {
      "filename": "core-contracts/contracts/CoreCollection.sol",
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\r\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\r\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\r\n\r\ncontract CoreCollection is\r\n    Ownable,\r\n    ERC721Claimable,\r\n    ERC721Enumerable,\r\n    ERC721Payable\r\n{\r\n    bool public initialized;\r\n    string private _name;\r\n    string private _symbol;\r\n    string private _baseUri;\r\n    uint256 public maxSupply;\r\n    uint256 public startingIndex;\r\n    uint256 public startingIndexBlock;\r\n    string public HASHED_PROOF = \"\";\r\n\r\n    event ClaimInitialized(bytes32 root);\r\n    event NewCollectionMeta(string name, string symbol);\r\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\r\n    event StartingIndexSet(uint256 index);\r\n    event RoyaltyVaultInitialized(address royaltyVault);\r\n    event NewHashedProof(string proof);\r\n    event NewWithdrawal(address to, uint256 amount);\r\n\r\n    constructor() ERC721(\"\", \"\") {}\r\n\r\n    // ----------------- MODIFIER -----------------\r\n\r\n    modifier onlyInitialized() {\r\n        require(initialized, \"CoreCollection: Not initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnInitialized() {\r\n        require(!initialized, \"CoreCollection: Already initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidSupply(uint256 _maxSupply) {\r\n        require(\r\n            _maxSupply > 0,\r\n            \"CoreCollection: Max supply should be greater than 0\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier tokenExists(uint256 _tokenId) {\r\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\r\n        _;\r\n    }\r\n\r\n    // ----------------- EXTERNAL -----------------\r\n\r\n    /**\r\n     * @notice Initializes the collection\r\n     * @dev This method is being called from the CoreFactory contract\r\n     * @param _collectionName Name of the collection\r\n     * @param _collectionSymbol Symbol of the collection\r\n     * @param _collectionURI Base URI for the collection\r\n     * @param _maxSupply The maximum number of tokens that can be minted\r\n     * @param _mintFee The price of a token in this collection\r\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\r\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\r\n     * @param _splitFactory base URI for the collection\r\n     */\r\n    function initialize(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol,\r\n        string memory _collectionURI,\r\n        uint256 _maxSupply,\r\n        uint256 _mintFee,\r\n        address _payableToken,\r\n        bool _isForSale,\r\n        address _splitFactory\r\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        _baseUri = _collectionURI;\r\n        maxSupply = _maxSupply;\r\n        mintFee = _mintFee;\r\n        payableToken = IERC20(_payableToken);\r\n        isForSale = _isForSale;\r\n        splitFactory = _splitFactory;\r\n        initialized = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to airdrop tokens\r\n     * @dev The Merkle tree defines for each address how much token can be claimed\r\n     * @dev This method can only be called once\r\n     * @param _root A Merkle root\r\n     */\r\n    function initializeClaims(bytes32 _root)\r\n        external\r\n        onlyOwner\r\n        onlyNotClaimableSet\r\n        onlyValidRoot(_root)\r\n    {\r\n        _setMerkelRoot(_root);\r\n        emit ClaimInitialized(_root);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the collection owner to change the collection's name and symbol\r\n     * @dev This function is only callable by the collection's owner\r\n     * @param _collectionName A collection name\r\n     * @param _collectionSymbol A collection symbol\r\n     */\r\n    function setCollectionMeta(\r\n        string memory _collectionName,\r\n        string memory _collectionSymbol\r\n    ) external onlyOwner {\r\n        _name = _collectionName;\r\n        _symbol = _collectionSymbol;\r\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called to mint tokens from this ERC721 collection\r\n     * @dev The collection must be initialized first\r\n     * @param to Token recipient\r\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\r\n     * @param claimableAmount The amount of tokens the user has been airdropped\r\n     * @param amount The amount of tokens the user wants to mint\r\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\r\n     */\r\n    function mintToken(\r\n        address to,\r\n        bool isClaim,\r\n        uint256 claimableAmount,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) external onlyInitialized {\r\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\""
    }
  ]
}