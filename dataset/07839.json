{
  "Title": "[M-09] `HolographERC20` breaks composability by forcing usage of draft proposal EIP-4524",
  "Content": "\n[HolographERC20.sol#L539](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L539)<br>\n\nHolographERC20 is the ERC20 enforcer for Holograph. In  the safeTransferFrom operation, it calls \\_checkOnERC20Received:\n\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data));\n    }\n    _transfer(account, recipient, amount);\n    require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(SourceERC20().afterSafeTransfer(account, recipient, amount, data));\n    }\n\nThe checkOnERC20Received function:\n\n    if (_isContract(recipient)) {\n      try ERC165(recipient).supportsInterface(ERC165.supportsInterface.selector) returns (bool erc165support) {\n        require(erc165support, \"ERC20: no ERC165 support\");\n        // we have erc165 support\n        if (ERC165(recipient).supportsInterface(0x534f5876)) {\n          // we have eip-4524 support\n          try ERC20Receiver(recipient).onERC20Received(address(this), account, amount, data) returns (bytes4 retv\n            return retval == ERC20Receiver.onERC20Received.selector;\n          } catch (bytes memory reason) {\n            if (reason.length == 0) {\n              revert(\"ERC20: non ERC20Receiver\");\n            } else {\n              assembly {\n                revert(add(32, reason), mload(reason))\n              }\n            }\n          }\n        } else {\n          revert(\"ERC20: eip-4524 not supported\");\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC20: no ERC165 support\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n\nIn essence, if the target is a contract, the enforcer requires it to fully implement EIP-4524. The problem is that [this](https://eips.ethereum.org/EIPS/eip-4524) EIP is just a draft proposal, which the project cannot assume to be supported by any receiver contract, and definitely not every receiver contract.\n\nThe specs warn us:\n\n```\n⚠️ This EIP is not recommended for general use or implementation as it is likely to change.\n\n```\n\nTherefore, it is a very dangerous requirement to add in an ERC20 enforcer, and must be left to the implementation to do if it so desires.\n\n### Impact\n\nERC20s enforced by HolographERC20 are completely uncomposable. They cannot be used for almost any DeFi application, making it basically useless.\n\n### Recommended Mitigation Steps\n\nRemove the EIP-4524 requirements altogether.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/440#issuecomment-1297240122):**\n > Low risk unless this is not a design decision.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/440#issuecomment-1306639824):**\n > Originally a design choice, but it can be updated to not revert if the EIP is not supported.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/440#issuecomment-1306719396):**\n > Will argue that philosophically any code is originally a design choice. If it's later made clear the choice has unintended dire consequences then the finding should not be penalized because of that alone. \n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/440#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-holograph-contest",
  "Code": [
    {
      "filename": "contracts/enforcer/HolographERC20.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/EIP712.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/NonReentrant.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../enum/HolographERC20Event.sol\";\nimport \"../enum/InterfaceType.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/ERC20Burnable.sol\";\nimport \"../interface/HolographERC20Interface.sol\";\nimport \"../interface/ERC20Metadata.sol\";\nimport \"../interface/ERC20Permit.sol\";\nimport \"../interface/ERC20Receiver.sol\";\nimport \"../interface/ERC20Safer.sol\";\nimport \"../interface/ERC165.sol\";\nimport \"../interface/Holographable.sol\";\nimport \"../interface/HolographedERC20.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/Ownable.sol\";\n\nimport \"../library/ECDSA.sol\";\n\n/**\n * @title Holograph Bridgeable ERC-20 Token\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographERC20 is Admin, Owner, Initializable, NonReentrant, EIP712, HolographERC20Interface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @dev Mapping of all the addresse's balances.\n   */\n  mapping(address => uint256) private _balances;\n\n  /**\n   * @dev Mapping of all authorized operators, and capped amounts.\n   */\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  /**\n   * @dev Total number of token in circulation.\n   */\n  uint256 private _totalSupply;\n\n  /**\n   * @dev Token name.\n   */\n  string private _name;\n\n  /**\n   * @dev Token ticker symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Token number of decimal places.\n   */\n  uint8 private _decimals;\n\n  /**\n   * @dev List of used up nonces. Used in the ERC20Permit interface functionality.\n   */\n  mapping(address => uint256) private _nonces;\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"ERC20: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"ERC20: source only call\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"ERC20: already initialized\");\n    InitializableInterface sourceContract;\n    assembly {\n      sstore(_reentrantSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (\n      string memory contractName,\n      string memory contractSymbol,\n      uint8 contractDecimals,\n      uint256 eventConfig,\n      string memory domainSeperator,\n      string memory domainVersion,\n      bool skipInit,\n      bytes memory initCode\n    ) = abi.decode(initPayload, (string, string, uint8, uint256, string, string, bool, bytes));\n    _name = contractName;\n    _symbol = contractSymbol;\n    _decimals = contractDecimals;\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"ERC20: could not init source\");\n    }\n    _setInitialized();\n    _eip712_init(domainSeperator, domainVersion);\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Although EIP-165 is not required for ERC20 contracts, we still decided to implement it.\n   *\n   * This makes it easier for external smart contracts to easily identify a valid ERC20 token contract.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    HolographInterfacesInterface interfaces = HolographInterfacesInterface(_interfaces());\n    ERC165 erc165Contract;\n    assembly {\n      erc165Contract := sload(_sourceContractSlot)\n    }\n    if (\n      interfaces.supportsInterface(InterfaceType.ERC20, interfaceId) || erc165Contract.supportsInterface(interfaceId) // check global interfaces // check if source supports interface\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function allowance(address account, address spender) public view returns (uint256) {\n    return _allowances[account][spender];\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function nonces(address account) public view returns (uint256) {\n    return _nonces[account];\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(msg.sender, spender, amount));\n    }\n    _approve(msg.sender, spender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(msg.sender, spender, amount));\n    }\n    return true;\n  }\n\n  function burn(uint256 amount) public {\n    if (_isEventRegistered(HolographERC20Event.beforeBurn)) {\n      require(SourceERC20().beforeBurn(msg.sender, amount));\n    }\n    _burn(msg.sender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterBurn)) {\n      require(SourceERC20().afterBurn(msg.sender, amount));\n    }\n  }\n\n  function burnFrom(address account, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[account][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n    unchecked {\n      _allowances[account][msg.sender] = currentAllowance - amount;\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeBurn)) {\n      require(SourceERC20().beforeBurn(account, amount));\n    }\n    _burn(account, amount);\n    if (_isEventRegistered(HolographERC20Event.afterBurn)) {\n      require(SourceERC20().afterBurn(account, amount));\n    }\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased below zero\");\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance - subtractedValue;\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(msg.sender, spender, newAllowance));\n    }\n    _approve(msg.sender, spender, newAllowance);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(msg.sender, spender, newAllowance));\n    }\n    return true;\n  }\n\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n    (address from, address to, uint256 amount, bytes memory data) = abi.decode(\n      payload,\n      (address, address, uint256, bytes)\n    );\n    _mint(to, amount);\n    if (_isEventRegistered(HolographERC20Event.bridgeIn)) {\n      require(SourceERC20().bridgeIn(fromChain, from, to, amount, data), \"HOLOGRAPH: bridge in failed\");\n    }\n    return Holographable.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n    (address from, address to, uint256 amount) = abi.decode(payload, (address, address, uint256));\n    if (sender != from) {\n      uint256 currentAllowance = _allowances[from][sender];\n      require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n      unchecked {\n        _allowances[from][sender] = currentAllowance - amount;\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.bridgeOut)) {\n      data = SourceERC20().bridgeOut(toChain, from, to, amount);\n    }\n    _burn(from, amount);\n    return (Holographable.bridgeOut.selector, abi.encode(from, to, amount, data));\n  }\n\n  /**\n   * @dev Allows the bridge to mint tokens (used for hTokens only).\n   */\n  function holographBridgeMint(address to, uint256 amount) external onlyBridge returns (bytes4) {\n    _mint(to, amount);\n    return HolographERC20Interface.holographBridgeMint.selector;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance + addedValue;\n    }\n    unchecked {\n      require(newAllowance >= currentAllowance, \"ERC20: increased above max value\");\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(msg.sender, spender, newAllowance));\n    }\n    _approve(msg.sender, spender, newAllowance);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(msg.sender, spender, newAllowance));\n    }\n    return true;\n  }\n\n  function onERC20Received(\n    address account,\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  ) public returns (bytes4) {\n    require(_isContract(account), \"ERC20: operator not contract\");\n    if (_isEventRegistered(HolographERC20Event.beforeOnERC20Received)) {\n      require(SourceERC20().beforeOnERC20Received(account, sender, address(this), amount, data));\n    }\n    try ERC20(account).balanceOf(address(this)) returns (uint256 balance) {\n      require(balance >= amount, \"ERC20: balance check failed\");\n    } catch {\n      revert(\"ERC20: failed getting balance\");\n    }\n    if (_isEventRegistered(HolographERC20Event.afterOnERC20Received)) {\n      require(SourceERC20().afterOnERC20Received(account, sender, address(this), amount, data));\n    }\n    return ERC20Receiver.onERC20Received.selector;\n  }\n\n  function permit(\n    address account,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    require(block.timestamp <= deadline, \"ERC20: expired deadline\");\n    bytes32 structHash = keccak256(\n      abi.encode(\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\n        account,\n        spender,\n        amount,\n        _useNonce(account),\n        deadline\n      )\n    );\n    bytes32 hash = _hashTypedDataV4(structHash);\n    address signer = ECDSA.recover(hash, v, r, s);\n    require(signer == account, \"ERC20: invalid signature\");\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(account, spender, amount));\n    }\n    _approve(account, spender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(account, spender, amount));\n    }\n  }\n\n  function safeTransfer(address recipient, uint256 amount) public returns (bool) {\n    return safeTransfer(recipient, amount, \"\");\n  }\n\n  function safeTransfer(\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(SourceERC20().beforeSafeTransfer(msg.sender, recipient, amount, data));\n    }\n    _transfer(msg.sender, recipient, amount);\n    require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(SourceERC20().afterSafeTransfer(msg.sender, recipient, amount, data));\n    }\n    return true;\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount\n  ) public returns (bool) {\n    return safeTransferFrom(account, recipient, amount, \"\");\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      if (msg.sender != _holograph().getBridge() && msg.sender != _holograph().getOperator()) {\n        uint256 currentAllowance = _allowances[account][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n        unchecked {\n          _allowances[account][msg.sender] = currentAllowance - amount;\n        }\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data));\n    }\n    _transfer(account, recipient, amount);\n    require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(SourceERC20().afterSafeTransfer(account, recipient, amount, data));\n    }\n    return true;\n  }\n\n  /**\n   * @dev Allows for source smart contract to burn tokens.\n   */\n  function sourceBurn(address from, uint256 amount) external onlySource {\n    _burn(from, amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint tokens.\n   */\n  function sourceMint(address to, uint256 amount) external onlySource {\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of token amounts.\n   */\n  function sourceMintBatch(address[] calldata wallets, uint256[] calldata amounts) external onlySource {\n    for (uint256 i = 0; i < wallets.length; i++) {\n      _mint(wallets[i], amounts[i]);\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to transfer tokens.\n   */\n  function sourceTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) external onlySource {\n    _transfer(from, to, amount);\n  }\n\n  function transfer(address recipient, uint256 amount) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeTransfer)) {\n      require(SourceERC20().beforeTransfer(msg.sender, recipient, amount));\n    }\n    _transfer(msg.sender, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterTransfer)) {\n      require(SourceERC20().afterTransfer(msg.sender, recipient, amount));\n    }\n    return true;\n  }\n\n  function transferFrom(\n    address account,\n    address recipient,\n    uint256 amount\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      if (msg.sender != _holograph().getBridge() && msg.sender != _holograph().getOperator()) {\n        uint256 currentAllowance = _allowances[account][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n        unchecked {\n          _allowances[account][msg.sender] = currentAllowance - amount;\n        }\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeTransfer)) {\n      require(SourceERC20().beforeTransfer(account, recipient, amount));\n    }\n    _transfer(account, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterTransfer)) {\n      require(SourceERC20().afterTransfer(account, recipient, amount));\n    }\n    return true;\n  }\n\n  function _approve(\n    address account,\n    address spender,\n    uint256 amount\n  ) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(spender != address(0), \"ERC20: spender is zero address\");\n    _allowances[account][spender] = amount;\n    emit Approval(account, spender, amount);\n  }\n\n  function _burn(address account, uint256 amount) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _checkOnERC20Received(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) private nonReentrant returns (bool) {\n    if (_isContract(recipient)) {\n      try ERC165(recipient).supportsInterface(ERC165.supportsInterface.selector) returns (bool erc165support) {\n        require(erc165support, \"ERC20: no ERC165 support\");\n        // we have erc165 support\n        if (ERC165(recipient).supportsInterface(0x534f5876)) {\n          // we have eip-4524 support\n          try ERC20Receiver(recipient).onERC20Received(address(this), account, amount, data) returns (bytes4 retval) {\n            return retval == ERC20Receiver.onERC20Received.selector;\n          } catch (bytes memory reason) {\n            if (reason.length == 0) {\n              revert(\"ERC20: non ERC20Receiver\");\n            } else {\n              assembly {\n                revert(add(32, reason), mload(reason))\n              }\n            }\n          }\n        } else {\n          revert(\"ERC20: eip-4524 not supported\");\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC20: no ERC165 support\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @notice Mints tokens.\n   * @dev Mint a specific amount of tokens to a specific address.\n   * @param to Address to mint to.\n   * @param amount Amount of tokens to mint.\n   */\n  function _mint(address to, uint256 amount) private {\n    require(to != address(0), \"ERC20: minting to burn address\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _transfer(\n    address account,\n    address recipient,\n    uint256 amount\n  ) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(recipient != address(0), \"ERC20: recipient is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _balances[recipient] += amount;\n    emit Transfer(account, recipient, amount);\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n   *\n   * _Available since v4.1._\n   */\n  function _useNonce(address account) private returns (uint256 current) {\n    current = _nonces[account];\n    _nonces[account]++;\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Get the source smart contract as bridgeable interface.\n   */\n  function SourceERC20() private view returns (HolographedERC20 sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Get the interfaces contract address.\n   */\n  function _interfaces() private view returns (address) {\n    return _holograph().getInterfaces();\n  }\n\n  function owner() public view override returns (address) {\n    Ownable ownableContract;\n    assembly {\n      ownableContract := sload(_sourceContractSlot)\n    }\n    return ownableContract.owner();\n  }\n\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function _isEventRegistered(HolographERC20Event _eventName) private view returns (bool) {\n    return ((_eventConfig >> uint256(_eventName)) & uint256(1) == 1 ? true : false);\n  }\n}"
    }
  ]
}