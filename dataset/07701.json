{
  "Title": "[M-01] Yul `call` return value not checked",
  "Content": "\n[Exchange.sol#L212-L227](https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212-L227)<br>\n\nThe Yul `call` return value on function `_returnDust` is not checked, which could leads to the `sender` lose funds\n\n### Proof of Concept\n\nThe caller of the functions `bulkExecute` and `execute` could be a contract who may not implement the `fallback` or `receive` functions or reject the `call`, when a call to it with value sent in the function `_returnDust`, it will revert, thus it would fail to receive the `dust` ether\n\nProof:\n- A contract use `bulkExecute`\n- One of the executions fails\n- The `Exchange` contract send the `dust`(Exchange balance) back to the contract\n- This one for any reason reject the call\n- The `dust` stay in the `Exchange` contract\n- In the next call of `bulkExecute` or `execute` the balance of the `Exchange` contract(including the old `dust`) will send to the new caller\n- The second sender will get the funds of the first contract\n\n### Recommended Mitigation Steps\n\n```diff\n+    error ReturnDustFail();\n+\nfunction _returnDust() private {\nuint256 _remainingETH = remainingETH;\n+        bool success;\nassembly {\nif gt(_remainingETH, 0) {\n-                let callStatus := call(\n+                success := call(\ngas(),\ncaller(),\nselfbalance(),\n0,\n0,\n0,\n0\n)\n}\n}\n+        if (!success) revert ReturnDustFail();\n}\n```\n\n**[nonfungible47 (Blur) confirmed and commented](https://github.com/code-423n4/2022-11-non-fungible-findings/issues/90#issuecomment-1341618491):**\n> Mitigation to check call status and revert if unsuccessful was implemented.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-11-non-fungible",
  "Code": [
    {
      "filename": "contracts/Exchange.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./lib/ReentrancyGuarded.sol\";\nimport \"./lib/EIP712.sol\";\nimport \"./lib/MerkleVerifier.sol\";\nimport \"./interfaces/IExchange.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IExecutionDelegate.sol\";\nimport \"./interfaces/IPolicyManager.sol\";\nimport \"./interfaces/IMatchingPolicy.sol\";\nimport {\n  Side,\n  SignatureVersion,\n  AssetType,\n  Fee,\n  Order,\n  Input,\n  Execution\n} from \"./lib/OrderStructs.sol\";\n\n/**\n * @title Exchange\n * @dev Core exchange contract\n */\ncontract Exchange is IExchange, ReentrancyGuarded, EIP712, OwnableUpgradeable, UUPSUpgradeable {\n\n    /* Auth */\n    uint256 public isOpen;\n\n    modifier whenOpen() {\n        require(isOpen == 1, \"Closed\");\n        _;\n    }\n\n    modifier setupExecution() {\n        remainingETH = msg.value;\n        isInternal = true;\n        _;\n        remainingETH = 0;\n        isInternal = false;\n    }\n\n    modifier internalCall() {\n        require(isInternal, \"This function should not be called directly\");\n        _;\n    }\n\n    event Opened();\n    event Closed();\n\n    function open() external onlyOwner {\n        isOpen = 1;\n        emit Opened();\n    }\n    function close() external onlyOwner {\n        isOpen = 0;\n        emit Closed();\n    }\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n\n    /* Constants */\n    string public constant NAME = \"Exchange\";\n    string public constant VERSION = \"1.0\";\n    uint256 public constant INVERSE_BASIS_POINT = 10_000;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant POOL = 0xF66CfDf074D2FFD6A4037be3A669Ed04380Aef2B;\n\n\n    /* Variables */\n    IExecutionDelegate public executionDelegate;\n    IPolicyManager public policyManager;\n    address public oracle;\n    uint256 public blockRange;\n\n\n    /* Storage */\n    mapping(bytes32 => bool) public cancelledOrFilled;\n    mapping(address => uint256) public nonces;\n\n\n    /* Events */\n    event OrdersMatched(\n        address indexed maker,\n        address indexed taker,\n        Order sell,\n        bytes32 sellHash,\n        Order buy,\n        bytes32 buyHash\n    );\n\n    event OrderCancelled(bytes32 hash);\n    event NonceIncremented(address indexed trader, uint256 newNonce);\n\n    event NewExecutionDelegate(IExecutionDelegate indexed executionDelegate);\n    event NewPolicyManager(IPolicyManager indexed policyManager);\n    event NewOracle(address indexed oracle);\n    event NewBlockRange(uint256 blockRange);\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /* Constructor (for ERC1967) */\n    function initialize(\n        IExecutionDelegate _executionDelegate,\n        IPolicyManager _policyManager,\n        address _oracle,\n        uint _blockRange\n    ) external initializer {\n        __Ownable_init();\n        isOpen = 1;\n\n        DOMAIN_SEPARATOR = _hashDomain(EIP712Domain({\n            name              : NAME,\n            version           : VERSION,\n            chainId           : block.chainid,\n            verifyingContract : address(this)\n        }));\n\n        executionDelegate = _executionDelegate;\n        policyManager = _policyManager;\n        oracle = _oracle;\n        blockRange = _blockRange;\n    }\n\n    // temporary function for testing\n    function updateDomainSeparator() external {\n        DOMAIN_SEPARATOR = _hashDomain(EIP712Domain({\n            name              : NAME,\n            version           : VERSION,\n            chainId           : block.chainid,\n            verifyingContract : address(this)\n        }));\n    }\n\n\n    /* External Functions */\n    bool public isInternal = false;\n    uint256 public remainingETH = 0;\n\n    /**\n     * @dev _execute wrapper \n     * @param sell Sell input\n     * @param buy Buy input\n     */\n    function execute(Input calldata sell, Input calldata buy)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        _execute(sell, buy);\n        _returnDust();\n    }\n\n    /**\n     * @dev Bulk execute multiple matches\n     * @param executions Potential buy/sell matches\n     */\n    function bulkExecute(Execution[] calldata executions)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        /*\n        REFERENCE\n        uint256 executionsLength = executions.length;\n        for (uint8 i=0; i < executionsLength; i++) {\n            bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);\n            (bool success,) = address(this).delegatecall(data);\n        }\n        _returnDust(remainingETH);\n        */\n        uint256 executionsLength = executions.length;\n        for (uint8 i = 0; i < executionsLength; i++) {\n            assembly {\n                let memPointer := mload(0x40)\n\n                let order_location := calldataload(add(executions.offset, mul(i, 0x20)))\n                let order_pointer := add(executions.offset, order_location)\n\n                let size\n                switch eq(add(i, 0x01), executionsLength)\n                case 1 {\n                    size := sub(calldatasize(), order_pointer)\n                }\n                default {\n                    let next_order_location := calldataload(add(executions.offset, mul(add(i, 0x01), 0x20)))\n                    let next_order_pointer := add(executions.offset, next_order_location)\n                    size := sub(next_order_pointer, order_pointer)\n                }\n\n                mstore(memPointer, 0xe04d94ae00000000000000000000000000000000000000000000000000000000) // _execute\n                calldatacopy(add(0x04, memPointer), order_pointer, size)\n                // must be put in separate transaction to bypass failed executions\n                // must be put in delegatecall to maintain the authorization from the caller\n                let result := delegatecall(gas(), address(), memPointer, add(size, 0x04), 0, 0)\n            }\n        }\n        _returnDust();\n    }\n\n    function _returnDust() private {\n        uint256 _remainingETH = remainingETH;\n        assembly {\n            if gt(_remainingETH, 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n    }\n\n    /**\n     * @dev Match two orders, ensuring validity of the match, and execute all associated state transitions. Protected against reentrancy by a contract-global lock. Must be called internally.\n     * @param sell Sell input\n     * @param buy Buy input\n     */\n    function _execute(Input calldata sell, Input calldata buy)\n        public\n        payable\n        reentrancyGuard\n        internalCall\n    {\n        require(sell.order.side == Side.Sell);\n\n        bytes32 sellHash = _hashOrder(sell.order, nonces[sell.order.trader]);\n        bytes32 buyHash = _hashOrder(buy.order, nonces[buy.order.trader]);\n\n        require(_validateSignatures(sell, sellHash), \"Sell failed authorization\");\n        require(_validateSignatures(buy, buyHash), \"Buy failed authorization\");\n\n        require(_validateOrderParameters(sell.order, sellHash), \"Sell has invalid parameters\");\n        require(_validateOrderParameters(buy.order, buyHash), \"Buy has invalid parameters\");\n\n        (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType) = _canMatchOrders(sell.order, buy.order);\n\n        /* Mark orders as filled. */\n        cancelledOrFilled[sellHash] = true;\n        cancelledOrFilled[buyHash] = true;\n\n        _executeFundsTransfer(\n            sell.order.trader,\n            buy.order.trader,\n            sell.order.paymentToken,\n            sell.order.fees,\n            price\n        );\n        _executeTokenTransfer(\n            sell.order.collection,\n            sell.order.trader,\n            buy.order.trader,\n            tokenId,\n            amount,\n            assetType\n        );\n\n        emit OrdersMatched(\n            sell.order.listingTime <= buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order.listingTime > buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order,\n            sellHash,\n            buy.order,\n            buyHash\n        );\n\n        // return (price);\n    }\n\n    /**\n     * @dev Cancel an order, preventing it from being matched. Must be called by the trader of the order\n     * @param order Order to cancel\n     */\n    function cancelOrder(Order calldata order) public {\n        /* Assert sender is authorized to cancel order. */\n        require(msg.sender == order.trader);\n\n        bytes32 hash = _hashOrder(order, nonces[order.trader]);\n\n        require(!cancelledOrFilled[hash], \"Order already cancelled or filled\");\n\n        /* Mark order as cancelled, preventing it from being matched. */\n        cancelledOrFilled[hash] = true;\n        emit OrderCancelled(hash);\n    }\n\n    /**\n     * @dev Cancel multiple orders\n     * @param orders Orders to cancel\n     */\n    function cancelOrders(Order[] calldata orders) external {\n        for (uint8 i = 0; i < orders.length; i++) {\n            cancelOrder(orders[i]);\n        }\n    }\n\n    /**\n     * @dev Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order\n     */\n    function incrementNonce() external {\n        nonces[msg.sender] += 1;\n        emit NonceIncremented(msg.sender, nonces[msg.sender]);\n    }\n\n\n    /* Setters */\n\n    function setExecutionDelegate(IExecutionDelegate _executionDelegate)\n        external\n        onlyOwner\n    {\n        require(address(_executionDelegate) != address(0), \"Address cannot be zero\");\n        executionDelegate = _executionDelegate;\n        emit NewExecutionDelegate(executionDelegate);\n    }\n\n    function setPolicyManager(IPolicyManager _policyManager)\n        external\n        onlyOwner\n    {\n        require(address(_policyManager) != address(0), \"Address cannot be zero\");\n        policyManager = _policyManager;\n        emit NewPolicyManager(policyManager);\n    }\n\n    function setOracle(address _oracle)\n        external\n        onlyOwner\n    {\n        require(_oracle != address(0), \"Address cannot be zero\");\n        oracle = _oracle;\n        emit NewOracle(oracle);\n    }\n\n    function setBlockRange(uint256 _blockRange)\n        external\n        onlyOwner\n    {\n        blockRange = _blockRange;\n        emit NewBlockRange(blockRange);\n    }\n\n\n    /* Internal Functions */\n\n    /**\n     * @dev Verify the validity of the order parameters\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateOrderParameters(Order calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n        return (\n            /* Order must have a trader. */\n            (order.trader != address(0)) &&\n            /* Order must not be cancelled or filled. */\n            (!cancelledOrFilled[orderHash]) &&\n            /* Order must be settleable. */\n            (order.listingTime < block.timestamp) &&\n            (block.timestamp < order.expirationTime)\n        );\n    }\n\n    /**\n     * @dev Verify the validity of the signatures\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateSignatures(Input calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n\n        if (order.order.trader == msg.sender) {\n          return true;\n        }\n\n        /* Check user authorization. */\n        if (\n            !_validateUserAuthorization(\n                orderHash,\n                order.order.trader,\n                order.v,\n                order.r,\n                order.s,\n                order.signatureVersion,\n                order.extraSignature\n            )\n        ) {\n            return false;\n        }\n\n        if (order.order.extraParams.length > 0 && order.order.extraParams[0] == 0x01) {\n            /* Check oracle authorization. */\n            require(block.number - order.blockNumber < blockRange, \"Signed block number out of range\");\n            if (\n                !_validateOracleAuthorization(\n                    orderHash,\n                    order.signatureVersion,\n                    order.extraSignature,\n                    order.blockNumber\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Verify the validity of the user signature\n     * @param orderHash hash of the order\n     * @param trader order trader who should be the signer\n     * @param v v\n     * @param r r\n     * @param s s\n     * @param signatureVersion signature version\n     * @param extraSignature packed merkle path\n     */\n    function _validateUserAuthorization(\n        bytes32 orderHash,\n        address trader,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature\n    ) internal view returns (bool) {\n        bytes32 hashToSign;\n        if (signatureVersion == SignatureVersion.Single) {\n            /* Single-listing authentication: Order signed by trader */\n            hashToSign = _hashToSign(orderHash);\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* Bulk-listing authentication: Merkle root of orders signed by trader */\n            (bytes32[] memory merklePath) = abi.decode(extraSignature, (bytes32[]));\n\n            bytes32 computedRoot = MerkleVerifier._computeRoot(orderHash, merklePath);\n            hashToSign = _hashToSignRoot(computedRoot);\n        }\n\n        return _verify(trader, hashToSign, v, r, s);\n    }\n\n    /**\n     * @dev Verify the validity of oracle signature\n     * @param orderHash hash of the order\n     * @param signatureVersion signature version\n     * @param extraSignature packed oracle signature\n     * @param blockNumber block number used in oracle signature\n     */\n    function _validateOracleAuthorization(\n        bytes32 orderHash,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature,\n        uint256 blockNumber\n    ) internal view returns (bool) {\n        bytes32 oracleHash = _hashToSignOracle(orderHash, blockNumber);\n\n        uint8 v; bytes32 r; bytes32 s;\n        if (signatureVersion == SignatureVersion.Single) {\n            assembly {\n                v := calldataload(extraSignature.offset)\n                r := calldataload(add(extraSignature.offset, 0x20))\n                s := calldataload(add(extraSignature.offset, 0x40))\n            }\n            /*\n            REFERENCE\n            (v, r, s) = abi.decode(extraSignature, (uint8, bytes32, bytes32));\n            */\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* If the signature was a bulk listing the merkle path must be unpacked before the oracle signature. */\n            assembly {\n                v := calldataload(add(extraSignature.offset, 0x20))\n                r := calldataload(add(extraSignature.offset, 0x40))\n                s := calldataload(add(extraSignature.offset, 0x60))\n            }\n            /*\n            REFERENCE\n            uint8 _v, bytes32 _r, bytes32 _s;\n            (bytes32[] memory merklePath, uint8 _v, bytes32 _r, bytes32 _s) = abi.decode(extraSignature, (bytes32[], uint8, bytes32, bytes32));\n            v = _v; r = _r; s = _s;\n            */\n        }\n\n        return _verify(oracle, oracleHash, v, r, s);\n    }\n\n    /**\n     * @dev Verify ECDSA signature\n     * @param signer Expected signer\n     * @param digest Signature preimage\n     * @param v v\n     * @param r r\n     * @param s s\n     */\n    function _verify(\n        address signer,\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (bool) {\n        require(v == 27 || v == 28, \"Invalid v parameter\");\n        address recoveredSigner = ecrecover(digest, v, r, s);\n        if (recoveredSigner == address(0)) {\n          return false;\n        } else {\n          return signer == recoveredSigner;\n        }\n    }\n\n    /**\n     * @dev Call the matching policy to check orders can be matched and get execution parameters\n     * @param sell sell order\n     * @param buy buy order\n     */\n    function _canMatchOrders(Order calldata sell, Order calldata buy)\n        internal\n        view\n        returns (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType)\n    {\n        bool canMatch;\n        if (sell.listingTime <= buy.listingTime) {\n            /* Seller is maker. */\n            require(policyManager.isPolicyWhitelisted(sell.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(sell.matchingPolicy).canMatchMakerAsk(sell, buy);\n        } else {\n            /* Buyer is maker. */\n            require(policyManager.isPolicyWhitelisted(buy.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(buy.matchingPolicy).canMatchMakerBid(buy, sell);\n        }\n        require(canMatch, \"Orders cannot be matched\");\n\n        return (price, tokenId, amount, assetType);\n    }\n\n    /**\n     * @dev Execute all ERC20 token / ETH transfers associated with an order match (fees and buyer => seller transfer)\n     * @param seller seller\n     * @param buyer buyer\n     * @param paymentToken payment token\n     * @param fees fees\n     * @param price price\n     */\n    function _executeFundsTransfer(\n        address seller,\n        address buyer,\n        address paymentToken,\n        Fee[] calldata fees,\n        uint256 price\n    ) internal {\n        if (msg.sender == buyer && paymentToken == address(0)) {\n            require(remainingETH >= price);\n            remainingETH -= price;\n        }\n\n        /* Take fee. */\n        uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);\n\n        /* Transfer remainder to seller. */\n        _transferTo(paymentToken, buyer, seller, receiveAmount);\n    }\n\n    /**\n     * @dev Charge a fee in ETH or WETH\n     * @param fees fees to distribute\n     * @param paymentToken address of token to pay in\n     * @param from address to charge fees\n     * @param price price of token\n     */\n    function _transferFees(\n        Fee[] calldata fees,\n        address paymentToken,\n        address from,\n        uint256 price\n    ) internal returns (uint256) {\n        uint256 totalFee = 0;\n        for (uint8 i = 0; i < fees.length; i++) {\n            uint256 fee = (price * fees[i].rate) / INVERSE_BASIS_POINT;\n            _transferTo(paymentToken, from, fees[i].recipient, fee);\n            totalFee += fee;\n        }\n\n        require(totalFee <= price, \"Total amount of fees are more than the price\");\n\n        /* Amount that will be received by seller. */\n        uint256 receiveAmount = price - totalFee;\n        return (receiveAmount);\n    }\n\n    /**\n     * @dev Transfer amount in ETH or WETH\n     * @param paymentToken address of token to pay in\n     * @param from token sender\n     * @param to token recipient\n     * @param amount amount to transfer\n     */\n    function _transferTo(\n        address paymentToken,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (paymentToken == address(0)) {\n            /* Transfer funds in ETH. */\n            require(to != address(0), \"Transfer to zero address\");\n            (bool success,) = payable(to).call{value: amount}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else if (paymentToken == POOL) {\n            /* Transfer Pool funds. */\n            bool success = IPool(POOL).transferFrom(from, to, amount);\n            require(success, \"Pool transfer failed\");\n        } else if (paymentToken == WETH) {\n            /* Transfer funds in WETH. */\n            executionDelegate.transferERC20(WETH, from, to, amount);\n        } else {\n            revert(\"Invalid payment token\");\n        }\n    }\n\n    /**\n     * @dev Execute call through delegate proxy\n     * @param collection collection contract address\n     * @param from seller address\n     * @param to buyer address\n     * @param tokenId tokenId\n     * @param assetType asset type of the token\n     */\n    function _executeTokenTransfer(\n        address collection,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        AssetType assetType\n    ) internal {\n        /* Call execution delegate. */\n        if (assetType == AssetType.ERC721) {\n            executionDelegate.transferERC721(collection, from, to, tokenId);\n        } else if (assetType == AssetType.ERC1155) {\n            executionDelegate.transferERC1155(collection, from, to, tokenId, amount);\n        }\n    }\n}"
    }
  ]
}