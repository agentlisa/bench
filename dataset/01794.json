{
  "Title": "`AggregateStablePrice` can be manipulated",
  "Content": "##### Description\n\nIf there is not enough liquidity in the pools or there are no pools, then `10**18` is returned as the price in `AggregateStablePrice`.\n\n- https://github.com/curvefi/curve-stablecoin/blob/0d9265cc2dbd221b0f27f880fac1c590e1f12d28/contracts/price_oracles/AggregateStablePrice.vy#L151\n\n```\nif Dsum == 0:\n    return 10**18\n```\n\nIt is supposed to be used to manipulate the price. At an early stage of the project, this can be significant.\n\n##### Recommendation\nWe recommend taking these conditions into account when deploying contracts.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/price_oracles/AggregateStablePrice.vy",
      "content": "# @version 0.3.7\n# Returns price of stablecoin in \"dollars\" based on multiple redeemable stablecoins\n# Recommended to use 3+ price sources\n\ninterface Stableswap:\n    def price_oracle() -> uint256: view\n    def coins(i: uint256) -> address: view\n    def get_virtual_price() -> uint256: view\n    def totalSupply() -> uint256: view\n\n\nstruct PricePair:\n    pool: Stableswap\n    is_inverse: bool\n\n\nevent AddPricePair:\n    n: uint256\n    pool: Stableswap\n    is_inverse: bool\n\nevent RemovePricePair:\n    n: uint256\n\nevent MovePricePair:\n    n_from: uint256\n    n_to: uint256\n\nMAX_PAIRS: constant(uint256) = 20\nMIN_LIQUIDITY: constant(uint256) = 100_000 * 10**18  # Only take into account pools with enough liquidity\n\nSTABLECOIN: immutable(address)\nSIGMA: immutable(uint256)\nprice_pairs: public(PricePair[MAX_PAIRS])\nn_price_pairs: uint256\nADMIN: immutable(address)\n\n\n@external\ndef __init__(stablecoin: address, sigma: uint256, admin: address):\n    STABLECOIN = stablecoin\n    SIGMA = sigma  # The change is so rare that we can change the whole thing altogether\n    ADMIN = admin\n\n\n@external\n@view\ndef admin() -> address:\n    return ADMIN\n\n\n@external\n@view\ndef sigma() -> uint256:\n    return SIGMA\n\n\n@external\n@view\ndef stablecoin() -> address:\n    return STABLECOIN\n\n\n@external\ndef add_price_pair(_pool: Stableswap):\n    assert msg.sender == ADMIN\n    price_pair: PricePair = empty(PricePair)\n    price_pair.pool = _pool\n    coins: address[2] = [_pool.coins(0), _pool.coins(1)]\n    if coins[0] == STABLECOIN:\n        price_pair.is_inverse = True\n    else:\n        assert coins[1] == STABLECOIN\n    n: uint256 = self.n_price_pairs\n    self.price_pairs[n] = price_pair  # Should revert if too many pairs\n    self.n_price_pairs = n + 1\n    log AddPricePair(n, _pool, price_pair.is_inverse)\n\n\n@external\ndef remove_price_pair(n: uint256):\n    assert msg.sender == ADMIN\n    n_max: uint256 = self.n_price_pairs - 1\n    assert n <= n_max\n\n    if n < n_max:\n        self.price_pairs[n] = self.price_pairs[n_max]\n        log MovePricePair(n_max, n)\n    self.n_price_pairs = n_max\n    log RemovePricePair(n)\n\n\n@internal\n@view\ndef exp(power: int256) -> uint256:\n    if power <= -42139678854452767551:\n        return 0\n\n    if power >= 135305999368893231589:\n        raise \"exp overflow\"\n\n    x: int256 = unsafe_div(unsafe_mul(power, 2**96), 10**18)\n\n    k: int256 = unsafe_div(\n        unsafe_add(\n            unsafe_div(unsafe_mul(x, 2**96), 54916777467707473351141471128),\n            2**95),\n        2**96)\n    x = unsafe_sub(x, unsafe_mul(k, 54916777467707473351141471128))\n\n    y: int256 = unsafe_add(x, 1346386616545796478920950773328)\n    y = unsafe_add(unsafe_div(unsafe_mul(y, x), 2**96), 57155421227552351082224309758442)\n    p: int256 = unsafe_sub(unsafe_add(y, x), 94201549194550492254356042504812)\n    p = unsafe_add(unsafe_div(unsafe_mul(p, y), 2**96), 28719021644029726153956944680412240)\n    p = unsafe_add(unsafe_mul(p, x), (4385272521454847904659076985693276 * 2**96))\n\n    q: int256 = x - 2855989394907223263936484059900\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 50020603652535783019961831881945)\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 533845033583426703283633433725380)\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 3604857256930695427073651918091429)\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 14423608567350463180887372962807573)\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 26449188498355588339934803723976023)\n\n    return shift(\n        unsafe_mul(convert(unsafe_div(p, q), uint256), 3822833074963236453042738258902158003155416615667),\n        unsafe_sub(k, 195))\n\n\n@external\n@view\ndef price() -> uint256:\n    n: uint256 = self.n_price_pairs\n    prices: uint256[MAX_PAIRS] = empty(uint256[MAX_PAIRS])\n    D: uint256[MAX_PAIRS] = empty(uint256[MAX_PAIRS])\n    Dsum: uint256 = 0\n    DPsum: uint256 = 0\n    for i in range(MAX_PAIRS):\n        if i == n:\n            break\n        price_pair: PricePair = self.price_pairs[i]\n        pool_supply: uint256 = price_pair.pool.totalSupply()\n        if pool_supply >= MIN_LIQUIDITY:\n            p: uint256 = price_pair.pool.price_oracle()\n            if price_pair.is_inverse:\n                p = 10**36 / p\n            prices[i] = p\n            _D: uint256 = price_pair.pool.get_virtual_price() * pool_supply / 10**18\n            D[i] = _D\n            Dsum += _D\n            DPsum += _D * p\n    if Dsum == 0:\n        return 10**18  # Placeholder for no active pools\n    p_avg: uint256 = DPsum / Dsum\n    e: uint256[MAX_PAIRS] = empty(uint256[MAX_PAIRS])\n    e_min: uint256 = max_value(uint256)\n    for i in range(MAX_PAIRS):\n        if i == n:\n            break\n        p: uint256 = prices[i]\n        e[i] = (max(p, p_avg) - min(p, p_avg))**2 / (SIGMA**2 / 10**18)\n        e_min = min(e[i], e_min)\n    wp_sum: uint256 = 0\n    w_sum: uint256 = 0\n    for i in range(MAX_PAIRS):\n        if i == n:\n            break\n        w: uint256 = D[i] * self.exp(-convert(e[i] - e_min, int256)) / 10**18\n        w_sum += w\n        wp_sum += w * prices[i]\n    return wp_sum / w_sum"
    }
  ]
}