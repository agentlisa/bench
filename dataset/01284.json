{
  "Title": "M-4: MultiInvoker liquidation action will revert most of the time due to incorrect closable amount initialization",
  "Content": "# Issue M-4: MultiInvoker liquidation action will revert most of the time due to incorrect closable amount initialization \n\nSource: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/44 \n\n## Found by \npanprog\n\nThe fix to [issue 49 of the main contest](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/49) introduced new invalidation system and additional condition: liquidations must close maximum `closable` amount, which is the amount which can be maximally closed based on the latest settled position.\n\nThe problem is that `MultiInvoker` incorrectly calculates `closableAmount` (it's not initialized and thus will often return 0 instead of correct magnitude) and thus most `LIQUIDATION` actions will revert.\n\n## Vulnerability Detail\n\n`MultiInvoker` calculates the `closable` amount in its `_latest` function incorrectly. In particular, it doesn't initialize `closableAmount`, so it's set to 0 initially. It then scans pending positions, settling those which should be settled, and reducing `closableAmount` if necessary for remaining pending positions:\n```solidity\nfunction _latest(\n    IMarket market,\n    address account\n) internal view returns (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) {\n    // load parameters from the market\n    IPayoffProvider payoff = market.payoff();\n\n    // load latest settled position and price\n    uint256 latestTimestamp = market.oracle().latest().timestamp;\n    latestPosition = market.positions(account);\n    latestPrice = market.global().latestPrice;\n    UFixed6 previousMagnitude = latestPosition.magnitude();\n\n    // @audit-issue Should add:\n    // closableAmount = previousMagnitude;\n    // otherwise if no position is settled in the following loop, closableAmount incorrectly remains 0\n\n    // scan pending position for any ready-to-be-settled positions\n    Local memory local = market.locals(account);\n    for (uint256 id = local.latestId + 1; id <= local.currentId; id++) {\n\n        // load pending position\n        Position memory pendingPosition = market.pendingPositions(account, id);\n        pendingPosition.adjust(latestPosition);\n\n        // load oracle version for that position\n        OracleVersion memory oracleVersion = market.oracle().at(pendingPosition.timestamp);\n        if (address(payoff) != address(0)) oracleVersion.price = payoff.payoff(oracleVersion.price);\n\n        // virtual settlement\n        if (pendingPosition.timestamp <= latestTimestamp) {\n            if (!oracleVersion.valid) latestPosition.invalidate(pendingPosition);\n            latestPosition.update(pendingPosition);\n            if (oracleVersion.valid) latestPrice = oracleVersion.price;\n\n            previousMagnitude = latestPosition.magnitude();\n@@@         closableAmount = previousMagnitude;\n\n        // process pending positions\n        } else {\n            closableAmount = closableAmount\n                .sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n            previousMagnitude = latestPosition.magnitude();\n        }\n    }\n}\n```\n\nNotice, that `closableAmount` is initialized to `previousMagnitude` **only if there is at least one position that needs to be settled**. However, if `local.latestId == local.currentId` (which is the case for most of the liquidations - position becomes liquidatable due to price changes without any pending positions created by the user), this loop is skipped entirely, never setting `closableAmount`, so it's incorrectly returned as 0, although it's not 0 (it should be the latest settled position magnitude).\n\nSince `LIQUIDATE` action of `MultiInvoker` uses `_latest` to calculate `closableAmount` and `liquidationFee`, these values will be calculated incorrectly and will revert when trying to update the market. See the `_liquidate` market update reducing `currentPosition` by `closable` (which is 0 when it must be bigger):\n```solidity\nmarket.update(\n    account,\n    currentPosition.maker.isZero() ? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n    currentPosition.long.isZero() ? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n    currentPosition.short.isZero() ? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n    Fixed6Lib.from(-1, liquidationFee),\n    true\n);\n```\n\nThis line will revert because `Market._invariant` verifies that `closableAmount` must be 0 after updating liquidated position:\n```solidity\nif (protected && (\n@@@ !closableAmount.isZero() ||\n    context.latestPosition.local.maintained(\n        context.latestVersion,\n        context.riskParameter,\n        collateralAfterFees.sub(collateral)\n    ) ||\n    collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context, newOrder)))\n)) revert MarketInvalidProtectionError();\n```\n\n## Impact\n\nAll `MultiInvoker` liquidation actions will revert if trying to liquidate users without positions which can be settled, which can happen in 2 cases:\n1. Liquidated user doesn't have any pending positions at all (`local.latestId == local.currentId`). This is the most common case (price has changed and user is liquidated without doing any actions) and we can reasonably expect that this will be the case for at least 50% of liquidations (probably more, like 80-90%).\n2. Liquidated user does have pending positions, but no pending position is ready to be settled yet. For example, if liquidator commits unrequested oracle version which liquidates user, even if the user already has pending position (but which is not yet ready to be settled).\n\nSince this breaks important `MultiInvoker` functionality in most cases and causes loss of funds to liquidator (revert instead of getting liquidation fee), I believe this should be High severity.\n\n## Code Snippet\n\nThere is no initialization of `closableAmount` in `MultiInvoker._latest` before the pending positions loop:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L361-L375\n\nInitialization only happens when settling position:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L393\n\nHowever, the loop will often be skipped entirely if there are no pending positions at all, thus `closableAmount` will be returned uninitialized (0):\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L376\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInitialize `closableAmount` to `previousMagnitude`:\n```solidity\n    function _latest(\n        IMarket market,\n        address account\n    ) internal view returns (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) {\n        // load parameters from the market\n        IPayoffProvider payoff = market.payoff();\n\n        // load latest settled position and price\n        uint256 latestTimestamp = market.oracle().latest().timestamp;\n        latestPosition = market.positions(account);\n        latestPrice = market.global().latestPrice;\n        UFixed6 previousMagnitude = latestPosition.magnitude();\n+       closableAmount = previousMagnitude;\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**polarzero** commented:\n> High. This would both cause a loss of funds and a malfunction in the protocol.\n\n\n\n**kbrizzle**\n\nSince standalone `settle` was dropped in v2, I believe it's actually impossible for a local account to have no pending positions once initialized, since a new pending position is always created at `current` when settling `latest` and `current != latest`.\n\nNonetheless we've fixed this [here](https://github.com/equilibria-xyz/perennial-v2/pull/110) to remain consistent with the implementation in `Market`, which provides better safety in case we ever decide to bring back a standalone `settle` functionality in future versions.\n\n**panprog**\n\n> Since standalone `settle` was dropped in v2, I believe it's actually impossible for a local account to have no pending positions once initialized, since a new pending position is always created at `current` when settling `latest` and `current != latest`.\n\nAgree, didn't think about it but indeed it's not possible to make them equal. Still, it can happen as described in point 2 in the report: if liquidator commits oracle unrequested (so the latest is before the first position settlement of the account), then the loop will never enter the \"virtual settlement\" part and `closableAmount` will remain 0.\n\nSince it can still happen but only in certain edge case, this should be downgraded to medium.\n\n**panprog**\n\nFixed\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/112",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { IPythOracle } from \"@equilibria/perennial-v2-oracle/contracts/interfaces/IPythOracle.sol\";\nimport { IVault } from \"@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol\";\nimport \"./interfaces/IMultiInvoker.sol\";\nimport \"./types/TriggerOrder.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept.sol\";\n\n\n/// @title MultiInvoker\n/// @notice Extension to handle batched calls to the Perennial protocol\ncontract MultiInvoker is IMultiInvoker, Kept {\n    /// @dev Gas buffer estimating remaining execution gas to include in fee to cover further instructions\n    uint256 public constant GAS_BUFFER = 100000; // solhint-disable-line var-name-mixedcase\n\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Protocol factory to validate market approvals\n    IFactory public immutable marketFactory;\n\n    /// @dev Vault factory to validate vault approvals\n    IFactory public immutable vaultFactory;\n\n    /// @dev Batcher address\n    IBatcher public immutable batcher;\n\n    /// @dev Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev multiplier to charge accounts on top of gas cost for keeper executions\n    UFixed6 public immutable keeperMultiplier;\n\n    /// @dev UID for an order\n    uint256 public latestNonce;\n\n    /// @dev State for the order data\n    mapping(address => mapping(IMarket => mapping(uint256 => TriggerOrderStorage))) private _orders;\n\n    /// @notice Constructs the MultiInvoker contract\n    /// @param usdc_ USDC stablecoin address\n    /// @param dsu_ DSU address\n    /// @param marketFactory_ Protocol factory to validate market approvals\n    /// @param vaultFactory_ Protocol factory to validate vault approvals\n    /// @param batcher_ Batcher address\n    /// @param reserve_ Reserve address\n    /// @param keeperMultiplier_ multiplier to charge accounts on top of gas cost for keeper executions\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        UFixed6 keeperMultiplier_\n    ) {\n        USDC = usdc_;\n        DSU = dsu_;\n        marketFactory = marketFactory_;\n        vaultFactory = vaultFactory_;\n        batcher = batcher_;\n        reserve = reserve_;\n        keeperMultiplier = keeperMultiplier_;\n    }\n\n    /// @notice Initialize the contract\n    /// @param ethOracle_ Chainlink ETH/USD oracle address\n    function initialize(AggregatorV3Interface ethOracle_) external initializer(1) {\n        __UKept__initialize(ethOracle_, DSU);\n\n        if (address(batcher) != address(0)) {\n            DSU.approve(address(batcher));\n            USDC.approve(address(batcher));\n        }\n\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @notice View function to get order state\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    function orders(address account, IMarket market, uint256 nonce) public view returns (TriggerOrder memory) {\n        return _orders[account][market][nonce].read();\n    }\n\n    /// @notice Returns whether an order can be executed\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    /// @return canFill Whether the order can be executed\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n        TriggerOrder memory order = orders(account, market, nonce);\n        if (order.fee.isZero()) return false;\n        (, Fixed6 latestPrice, ) = _latest(market, account);\n        return order.fillable(latestPrice);\n    }\n\n    /// @notice entry to perform invocations\n    /// @param invocations List of actions to execute in order\n    function invoke(Invocation[] calldata invocations) external payable {\n        for(uint i = 0; i < invocations.length; ++i) {\n            Invocation memory invocation = invocations[i];\n\n            if (invocation.action == PerennialAction.UPDATE_POSITION) {\n                (\n                    IMarket market,\n                    UFixed6 newMaker,\n                    UFixed6 newLong,\n                    UFixed6 newShort,\n                    Fixed6 collateral,\n                    bool wrap\n                ) = abi.decode(invocation.args, (IMarket, UFixed6, UFixed6, UFixed6, Fixed6, bool));\n\n                _update(market, newMaker, newLong, newShort, collateral, wrap);\n            } else if (invocation.action == PerennialAction.UPDATE_VAULT) {\n                (IVault vault, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets, bool wrap)\n                    = abi.decode(invocation.args, (IVault, UFixed6, UFixed6, UFixed6, bool));\n\n                _vaultUpdate(vault, depositAssets, redeemShares, claimAssets, wrap);\n            } else if (invocation.action == PerennialAction.PLACE_ORDER) {\n                (IMarket market, TriggerOrder memory order) = abi.decode(invocation.args, (IMarket, TriggerOrder));\n\n                _placeOrder(msg.sender, market, order);\n            } else if (invocation.action == PerennialAction.CANCEL_ORDER) {\n                (IMarket market, uint256 nonce) = abi.decode(invocation.args, (IMarket, uint256));\n\n                _cancelOrder(msg.sender, market, nonce);\n            } else if (invocation.action == PerennialAction.EXEC_ORDER) {\n                (address account, IMarket market, uint256 nonce) =\n                    abi.decode(invocation.args, (address, IMarket, uint256));\n\n                _executeOrder(account, market, nonce);\n            } else if (invocation.action == PerennialAction.COMMIT_PRICE) {\n                (address oracleProvider, uint256 value, uint256 index, uint256 version, bytes memory data, bool revertOnFailure) =\n                    abi.decode(invocation.args, (address, uint256, uint256, uint256, bytes, bool));\n\n                _commitPrice(oracleProvider, value, index, version, data, revertOnFailure);\n            } else if (invocation.action == PerennialAction.LIQUIDATE) {\n                (IMarket market, address account) = abi.decode(invocation.args, (IMarket, address));\n\n                _liquidate(IMarket(market), account);\n            } else if (invocation.action == PerennialAction.APPROVE) {\n                (address target) = abi.decode(invocation.args, (address));\n\n                _approve(target);\n            } else if (invocation.action == PerennialAction.CHARGE_FEE) {\n                (address to, UFixed6 amount) = abi.decode(invocation.args, (address, UFixed6));\n\n                USDC.pullTo(msg.sender, to, amount);\n                emit FeeCharged(msg.sender, to, amount);\n            }\n        }\n    }\n\n    /// @notice Updates market on behalf of msg.sender\n    /// @param market Address of market up update\n    /// @param newMaker New maker position for msg.sender in `market`\n    /// @param newLong New long position for msg.sender in `market`\n    /// @param newShort New short position for msg.sender in `market`\n    /// @param collateral Net change in collateral for msg.sender in `market`\n    /// @param wrap Wheather to wrap/unwrap collateral on deposit/withdrawal\n    function _update(\n        IMarket market,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool wrap\n    ) internal isMarketInstance(market) {\n        Fixed18 balanceBefore =  Fixed18Lib.from(DSU.balanceOf());\n        // collateral is transferred from this address to the market, transfer from msg.sender to here\n        if (collateral.sign() == 1) _deposit(collateral.abs(), wrap);\n\n        market.update(msg.sender, newMaker, newLong, newShort, collateral, false);\n\n        Fixed6 withdrawAmount = Fixed6Lib.from(Fixed18Lib.from(DSU.balanceOf()).sub(balanceBefore));\n        // collateral is transferred from the market to this address, transfer to msg.sender from here\n        if (!withdrawAmount.isZero()) _withdraw(msg.sender, withdrawAmount.abs(), wrap);\n    }\n\n    /// @notice Update vault on behalf of msg.sender\n    /// @param vault Address of vault to update\n    /// @param depositAssets Amount of assets to deposit into vault\n    /// @param redeemShares Amount of shares to redeem from vault\n    /// @param claimAssets Amount of assets to claim from vault\n    /// @param wrap Whether to wrap assets before depositing\n    function _vaultUpdate(\n        IVault vault,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets,\n        bool wrap\n    ) internal isVaultInstance(vault) {\n        if (!depositAssets.isZero()) {\n            _deposit(depositAssets, wrap);\n        }\n\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        vault.update(msg.sender, depositAssets, redeemShares, claimAssets);\n\n        // handle socialization, settlement fees, and magic values\n        UFixed6 claimAmount = claimAssets.isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(DSU.balanceOf().sub(balanceBefore));\n\n        if (!claimAmount.isZero()) {\n            _withdraw(msg.sender, claimAmount, wrap);\n        }\n    }\n\n    /// @notice Liquidates an account for a specific market\n    /// @param market Market to liquidate account in\n    /// @param account Address of market to liquidate\n    function _liquidate(IMarket market, address account) internal isMarketInstance(market) {\n        (UFixed6 liquidationFee, UFixed6 closable) = _liquidationFee(market, account);\n\n        Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n\n        market.update(\n            account,\n            currentPosition.maker.isZero() ? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n            currentPosition.long.isZero() ? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n            currentPosition.short.isZero() ? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n            Fixed6Lib.from(-1, liquidationFee),\n            true\n        );\n\n        _withdraw(msg.sender, liquidationFee, true);\n    }\n\n    /// @notice Helper to max approve DSU for usage in a market or vault deployed by the registered factories\n    /// @param target Market or Vault to approve\n    function _approve(address target) internal {\n        if (\n            !marketFactory.instances(IInstance(target)) &&\n            !vaultFactory.instances(IInstance(target))\n        ) revert MultiInvokerInvalidInstanceError();\n\n        DSU.approve(target);\n    }\n\n    /// @notice Pull DSU or wrap and deposit USDC from msg.sender to this address for market usage\n    /// @param amount Amount to transfer\n    /// @param wrap Flag to wrap USDC to DSU\n    function _deposit(UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            USDC.pull(msg.sender, amount);\n            _wrap(address(this), UFixed18Lib.from(amount));\n        } else {\n            DSU.pull(msg.sender, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Push DSU or unwrap DSU to push USDC from this address to `account`\n    /// @param account Account to push DSU or USDC to\n    /// @param amount Amount to transfer\n    /// @param wrap flag to unwrap DSU to USDC\n    function _withdraw(address account, UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            _unwrap(account, UFixed18Lib.from(amount));\n        } else {\n            DSU.push(account, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Helper function to wrap `amount` USDC from `msg.sender` into DSU using the batcher or reserve\n    /// @param receiver Address to receive the DSU\n    /// @param amount Amount of USDC to wrap\n    function _wrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or  doesn't have enough for this wrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(DSU.balanceOf(address(batcher)))) {\n            reserve.mint(amount);\n            if (receiver != address(this)) DSU.push(receiver, amount);\n        } else {\n            // Wrap the USDC into DSU and return to the receiver\n            batcher.wrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to unwrap `amount` DSU into USDC and send to `receiver`\n    /// @param receiver Address to receive the USDC\n    /// @param amount Amount of DSU to unwrap\n    function _unwrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or doesn't have enough for this unwrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(UFixed18Lib.from(USDC.balanceOf(address(batcher))))) {\n            reserve.redeem(amount);\n            if (receiver != address(this)) USDC.push(receiver, UFixed6Lib.from(amount));\n        } else {\n            // Unwrap the DSU into USDC and return to the receiver\n            batcher.unwrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to commit a price to an oracle\n    /// @param oracleProvider Address of oracle provider\n    /// @param value The ether value to pass on with the commit sub-call\n    /// @param version Version of oracle to commit to\n    /// @param data Data to commit to oracle\n    /// @param revertOnFailure Whether to revert on sub-call failure\n    function _commitPrice(\n        address oracleProvider,\n        uint256 value,\n        uint256 index,\n        uint256 version,\n        bytes memory data,\n        bool revertOnFailure\n    ) internal {\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        if (revertOnFailure) {\n            IPythOracle(oracleProvider).commit{value: value}(index, version, data);\n        } else {\n            try IPythOracle(oracleProvider).commit{value: value}(index, version, data) { }\n            catch { }\n        }\n\n        // Return through keeper reward if any\n        DSU.push(msg.sender, DSU.balanceOf().sub(balanceBefore));\n    }\n\n    /// @notice Helper function to compute the liquidation fee for an account\n    /// @param market Market to compute liquidation fee for\n    /// @param account Account to compute liquidation fee for\n    /// @return liquidationFee Liquidation fee for the account\n    /// @return closable The amount of the position that can be closed\n    function _liquidationFee(IMarket market, address account) internal view returns (UFixed6, UFixed6) {\n        // load information about liquidation\n        RiskParameter memory riskParameter = market.riskParameter();\n        (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) = _latest(market, account);\n\n        // create placeholder order for liquidation fee calculation (fee is charged the same on all sides)\n        Order memory placeholderOrder;\n        placeholderOrder.maker = Fixed6Lib.from(closableAmount);\n\n        return (\n            placeholderOrder\n                .liquidationFee(OracleVersion(latestPosition.timestamp, latestPrice, true), riskParameter)\n                .min(UFixed6Lib.from(market.token().balanceOf(address(market)))),\n            closableAmount\n        );\n    }\n\n    /// @notice Helper function to compute the latest position and oracle version without a settlement\n    /// @param market Market to compute latest position and oracle version for\n    /// @param account Account to compute latest position and oracle version for\n    /// @return latestPosition Latest position for the account\n    /// @return latestPrice Latest oracle price for the account\n    /// @return closableAmount Amount of position that can be closed\n    function _latest(\n        IMarket market,\n        address account\n    ) internal view returns (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) {\n        // load parameters from the market\n        IPayoffProvider payoff = market.payoff();\n\n        // load latest settled position and price\n        uint256 latestTimestamp = market.oracle().latest().timestamp;\n        latestPosition = market.positions(account);\n        latestPrice = market.global().latestPrice;\n        UFixed6 previousMagnitude = latestPosition.magnitude();\n\n        // scan pending position for any ready-to-be-settled positions\n        Local memory local = market.locals(account);\n        for (uint256 id = local.latestId + 1; id <= local.currentId; id++) {\n\n            // load pending position\n            Position memory pendingPosition = market.pendingPositions(account, id);\n            pendingPosition.adjust(latestPosition);\n\n            // load oracle version for that position\n            OracleVersion memory oracleVersion = market.oracle().at(pendingPosition.timestamp);\n            if (address(payoff) != address(0)) oracleVersion.price = payoff.payoff(oracleVersion.price);\n\n            // virtual settlement\n            if (pendingPosition.timestamp <= latestTimestamp) {\n                if (!oracleVersion.valid) latestPosition.invalidate(pendingPosition);\n                latestPosition.update(pendingPosition);\n                if (oracleVersion.valid) latestPrice = oracleVersion.price;\n\n                previousMagnitude = latestPosition.magnitude();\n                closableAmount = previousMagnitude;\n\n            // process pending positions\n            } else {\n                closableAmount = closableAmount\n                    .sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n                previousMagnitude = latestPosition.magnitude();\n            }\n        }\n    }\n\n    /**\n     * @notice executes an `account's` open order for a `market` and pays a fee to `msg.sender`\n     * @param account Account to execute order of\n     * @param market Market to execute order for\n     * @param nonce Id of open order to index\n     */\n    function _executeOrder(\n        address account,\n        IMarket market,\n        uint256 nonce\n    ) internal keep (\n        UFixed18Lib.from(keeperMultiplier),\n        GAS_BUFFER,\n        \"\",\n        abi.encode(account, market, orders(account, market, nonce).fee)\n    ) {\n        if (!canExecuteOrder(account, market, nonce)) revert MultiInvokerCantExecuteError();\n\n        Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n        orders(account, market, nonce).execute(currentPosition);\n\n        market.update(\n            account,\n            currentPosition.maker,\n            currentPosition.long,\n            currentPosition.short,\n            Fixed6Lib.ZERO,\n            false\n        );\n\n        delete _orders[account][market][nonce];\n        emit OrderExecuted(account, market, nonce, market.locals(account).currentId);\n    }\n\n    /// @notice Helper function to raise keeper fee\n    /// @param keeperFee Keeper fee to raise\n    /// @param data Data to raise keeper fee with\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory data) internal override {\n        (address account, address market, UFixed6 fee) = abi.decode(data, (address, address, UFixed6));\n        if (keeperFee.gt(UFixed18Lib.from(fee))) revert MultiInvokerMaxFeeExceededError();\n\n        IMarket(market).update(\n            account,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            Fixed6Lib.from(Fixed18Lib.from(-1, keeperFee), true),\n            false\n        );\n\n    }\n\n    /// @notice Places order on behalf of msg.sender from the invoker\n    /// @param account Account to place order for\n    /// @param market Market to place order in\n    /// @param order Order state to place\n    function _placeOrder(address account, IMarket market, TriggerOrder memory order) internal isMarketInstance(market) {\n        if (order.fee.isZero()) revert MultiInvokerInvalidOrderError();\n        if (order.comparison != -1 && order.comparison != 1) revert MultiInvokerInvalidOrderError();\n        if (order.side != 1 && order.side != 2) revert MultiInvokerInvalidOrderError();\n\n        _orders[account][market][++latestNonce].store(order);\n        emit OrderPlaced(account, market, latestNonce, order);\n    }\n\n    /// @notice Cancels an open order for msg.sender\n    /// @param account Account to cancel order for\n    /// @param market Market order is open in\n    /// @param nonce UID of order\n    function _cancelOrder(address account, IMarket market, uint256 nonce) internal {\n        delete _orders[account][market][nonce];\n        emit OrderCancelled(account, market, nonce);\n    }\n\n    /// @notice Target market must be created by MarketFactory\n    modifier isMarketInstance(IMarket market) {\n        if(!marketFactory.instances(market))\n            revert MultiInvokerInvalidInstanceError();\n        _;\n    }\n\n    /// @notice Target vault must be created by VaultFactory\n    modifier isVaultInstance(IVault vault) {\n        if(!vaultFactory.instances(vault))\n            revert MultiInvokerInvalidInstanceError();\n            _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { IPythOracle } from \"@equilibria/perennial-v2-oracle/contracts/interfaces/IPythOracle.sol\";\nimport { IVault } from \"@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol\";\nimport \"./interfaces/IMultiInvoker.sol\";\nimport \"./types/TriggerOrder.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept.sol\";\n\n\n/// @title MultiInvoker\n/// @notice Extension to handle batched calls to the Perennial protocol\ncontract MultiInvoker is IMultiInvoker, Kept {\n    /// @dev Gas buffer estimating remaining execution gas to include in fee to cover further instructions\n    uint256 public constant GAS_BUFFER = 100000; // solhint-disable-line var-name-mixedcase\n\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Protocol factory to validate market approvals\n    IFactory public immutable marketFactory;\n\n    /// @dev Vault factory to validate vault approvals\n    IFactory public immutable vaultFactory;\n\n    /// @dev Batcher address\n    IBatcher public immutable batcher;\n\n    /// @dev Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev multiplier to charge accounts on top of gas cost for keeper executions\n    UFixed6 public immutable keeperMultiplier;\n\n    /// @dev UID for an order\n    uint256 public latestNonce;\n\n    /// @dev State for the order data\n    mapping(address => mapping(IMarket => mapping(uint256 => TriggerOrderStorage))) private _orders;\n\n    /// @notice Constructs the MultiInvoker contract\n    /// @param usdc_ USDC stablecoin address\n    /// @param dsu_ DSU address\n    /// @param marketFactory_ Protocol factory to validate market approvals\n    /// @param vaultFactory_ Protocol factory to validate vault approvals\n    /// @param batcher_ Batcher address\n    /// @param reserve_ Reserve address\n    /// @param keeperMultiplier_ multiplier to charge accounts on top of gas cost for keeper executions\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        UFixed6 keeperMultiplier_\n    ) {\n        USDC = usdc_;\n        DSU = dsu_;\n        marketFactory = marketFactory_;\n        vaultFactory = vaultFactory_;\n        batcher = batcher_;\n        reserve = reserve_;\n        keeperMultiplier = keeperMultiplier_;\n    }\n\n    /// @notice Initialize the contract\n    /// @param ethOracle_ Chainlink ETH/USD oracle address\n    function initialize(AggregatorV3Interface ethOracle_) external initializer(1) {\n        __UKept__initialize(ethOracle_, DSU);\n\n        if (address(batcher) != address(0)) {\n            DSU.approve(address(batcher));\n            USDC.approve(address(batcher));\n        }\n\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @notice View function to get order state\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    function orders(address account, IMarket market, uint256 nonce) public view returns (TriggerOrder memory) {\n        return _orders[account][market][nonce].read();\n    }\n\n    /// @notice Returns whether an order can be executed\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    /// @return canFill Whether the order can be executed\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n        TriggerOrder memory order = orders(account, market, nonce);\n        if (order.fee.isZero()) return false;\n        (, Fixed6 latestPrice, ) = _latest(market, account);\n        return order.fillable(latestPrice);\n    }\n\n    /// @notice entry to perform invocations\n    /// @param invocations List of actions to execute in order\n    function invoke(Invocation[] calldata invocations) external payable {\n        for(uint i = 0; i < invocations.length; ++i) {\n            Invocation memory invocation = invocations[i];\n\n            if (invocation.action == PerennialAction.UPDATE_POSITION) {\n                (\n                    IMarket market,\n                    UFixed6 newMaker,\n                    UFixed6 newLong,\n                    UFixed6 newShort,\n                    Fixed6 collateral,\n                    bool wrap\n                ) = abi.decode(invocation.args, (IMarket, UFixed6, UFixed6, UFixed6, Fixed6, bool));\n\n                _update(market, newMaker, newLong, newShort, collateral, wrap);\n            } else if (invocation.action == PerennialAction.UPDATE_VAULT) {\n                (IVault vault, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets, bool wrap)\n                    = abi.decode(invocation.args, (IVault, UFixed6, UFixed6, UFixed6, bool));\n\n                _vaultUpdate(vault, depositAssets, redeemShares, claimAssets, wrap);\n            } else if (invocation.action == PerennialAction.PLACE_ORDER) {\n                (IMarket market, TriggerOrder memory order) = abi.decode(invocation.args, (IMarket, TriggerOrder));\n\n                _placeOrder(msg.sender, market, order);\n            } else if (invocation.action == PerennialAction.CANCEL_ORDER) {\n                (IMarket market, uint256 nonce) = abi.decode(invocation.args, (IMarket, uint256));\n\n                _cancelOrder(msg.sender, market, nonce);\n            } else if (invocation.action == PerennialAction.EXEC_ORDER) {\n                (address account, IMarket market, uint256 nonce) =\n                    abi.decode(invocation.args, (address, IMarket, uint256));\n\n                _executeOrder(account, market, nonce);\n            } else if (invocation.action == PerennialAction.COMMIT_PRICE) {\n                (address oracleProvider, uint256 value, uint256 index, uint256 version, bytes memory data, bool revertOnFailure) =\n                    abi.decode(invocation.args, (address, uint256, uint256, uint256, bytes, bool));\n\n                _commitPrice(oracleProvider, value, index, version, data, revertOnFailure);\n            } else if (invocation.action == PerennialAction.LIQUIDATE) {\n                (IMarket market, address account) = abi.decode(invocation.args, (IMarket, address));\n\n                _liquidate(IMarket(market), account);\n            } else if (invocation.action == PerennialAction.APPROVE) {\n                (address target) = abi.decode(invocation.args, (address));\n\n                _approve(target);\n            } else if (invocation.action == PerennialAction.CHARGE_FEE) {\n                (address to, UFixed6 amount) = abi.decode(invocation.args, (address, UFixed6));\n\n                USDC.pullTo(msg.sender, to, amount);\n                emit FeeCharged(msg.sender, to, amount);\n            }\n        }\n    }\n\n    /// @notice Updates market on behalf of msg.sender\n    /// @param market Address of market up update\n    /// @param newMaker New maker position for msg.sender in `market`\n    /// @param newLong New long position for msg.sender in `market`\n    /// @param newShort New short position for msg.sender in `market`\n    /// @param collateral Net change in collateral for msg.sender in `market`\n    /// @param wrap Wheather to wrap/unwrap collateral on deposit/withdrawal\n    function _update(\n        IMarket market,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool wrap\n    ) internal isMarketInstance(market) {\n        Fixed18 balanceBefore =  Fixed18Lib.from(DSU.balanceOf());\n        // collateral is transferred from this address to the market, transfer from msg.sender to here\n        if (collateral.sign() == 1) _deposit(collateral.abs(), wrap);\n\n        market.update(msg.sender, newMaker, newLong, newShort, collateral, false);\n\n        Fixed6 withdrawAmount = Fixed6Lib.from(Fixed18Lib.from(DSU.balanceOf()).sub(balanceBefore));\n        // collateral is transferred from the market to this address, transfer to msg.sender from here\n        if (!withdrawAmount.isZero()) _withdraw(msg.sender, withdrawAmount.abs(), wrap);\n    }\n\n    /// @notice Update vault on behalf of msg.sender\n    /// @param vault Address of vault to update\n    /// @param depositAssets Amount of assets to deposit into vault\n    /// @param redeemShares Amount of shares to redeem from vault\n    /// @param claimAssets Amount of assets to claim from vault\n    /// @param wrap Whether to wrap assets before depositing\n    function _vaultUpdate(\n        IVault vault,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets,\n        bool wrap\n    ) internal isVaultInstance(vault) {\n        if (!depositAssets.isZero()) {\n            _deposit(depositAssets, wrap);\n        }\n\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        vault.update(msg.sender, depositAssets, redeemShares, claimAssets);\n\n        // handle socialization, settlement fees, and magic values\n        UFixed6 claimAmount = claimAssets.isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(DSU.balanceOf().sub(balanceBefore));\n\n        if (!claimAmount.isZero()) {\n            _withdraw(msg.sender, claimAmount, wrap);\n        }\n    }\n\n    /// @notice Liquidates an account for a specific market\n    /// @param market Market to liquidate account in\n    /// @param account Address of market to liquidate\n    function _liquidate(IMarket market, address account) internal isMarketInstance(market) {\n        (UFixed6 liquidationFee, UFixed6 closable) = _liquidationFee(market, account);\n\n        Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n\n        market.update(\n            account,\n            currentPosition.maker.isZero() ? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n            currentPosition.long.isZero() ? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n            currentPosition.short.isZero() ? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n            Fixed6Lib.from(-1, liquidationFee),\n            true\n        );\n\n        _withdraw(msg.sender, liquidationFee, true);\n    }\n\n    /// @notice Helper to max approve DSU for usage in a market or vault deployed by the registered factories\n    /// @param target Market or Vault to approve\n    function _approve(address target) internal {\n        if (\n            !marketFactory.instances(IInstance(target)) &&\n            !vaultFactory.instances(IInstance(target))\n        ) revert"
    }
  ]
}