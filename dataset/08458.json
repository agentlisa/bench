{
  "Title": "[M-03] Error in allowance logic",
  "Content": "_Submitted by 0xDjango, also found by 0x1f8b, 8olidity, arcoun, Bahurum, caventa, csanuragjain, hansfriese, joestakey, jonatascm, Lambda, oyc&#95;109, and ronnyx2017_\n\n<https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Tokens/ZcToken.sol#L112-L114>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Tokens/ZcToken.sol#L132-L133>\n\n### Impact\n\nThere is an error in the allowance functionality to allow a non-owner to withdraw or redeem ZcTokens for the owner. Taking `ZcToken.redeem()` as an example, behold the following if/else block:\n\n            if (holder == msg.sender) {\n                return redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, principalAmount);\n            }\n            else {\n                uint256 allowed = allowance[holder][msg.sender];\n                if (allowed >= principalAmount) { revert Approvals(allowed, principalAmount); }\n                allowance[holder][msg.sender] -= principalAmount;  \n                return redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, principalAmount);\n\nIf the `msg.sender` is the holder, no check for allowance is needed. If the sender is not the holder, then their allowance is checked.\n\nThe error lies in the if statement `if (allowed >= principalAmount) { revert Approvals(allowed, principalAmount); }`. This states that if the sender has equal to or more allowance than the principalAmount, revert.\n\nTherefore, if the sender has the proper allowance or more allowance than necessary, the transaction will revert. If the sender has less allowance than necessary, the transaction will still revert because of the `allowance[holder][msg.sender] -= principalAmount;` clause.\n\nIn conclusion, there is no way to `withdraw()` or `redeem()` on behalf of another user.\n\n### Recommended Mitigation Steps\n\nThe fix is to simply change `>=` to `<`.\n\n\n**[JTraversa (Swivel) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/129#issuecomment-1189926148):**\n > Approval workflow doesnt leave funds at risk but is a nice to have, that plus scope and this *might* end up Low risk but I think Medium is appropriate as well.\n\n**[bghughes (judge) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/129#issuecomment-1200480311):**\n > This is a good issue and I agree with the severity. I decided against making this High severity due to the fact that funds are not necessarily at risk; it's just intended allowance functionality will not behave as expected. \n\n**[robrobbins (Swivel) resolved and commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/129#issuecomment-1203288875):**\n > See [#180](https://github.com/code-423n4/2022-07-swivel-findings/issues/180). \n\n**[bghughes (judge) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/129#issuecomment-1203389433):**\n > Making this the main issue for the allowance flipped sign.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-swivel-v3-contest",
  "Code": [
    {
      "filename": "Tokens/ZcToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Erc20.sol\";\nimport \"./Compounding.sol\";\nimport \"./IERC5095.sol\";  \nimport \"./IRedeemer.sol\";\n\n// Utilizing an external custody contract to allow for backwards compatability with some projects.\n// Assumes interest generated post maturity using an internal Compounding library.\ncontract ZcToken is Erc20, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev uint8 associated with a given protocol in Swivel\n    uint8 public immutable protocol;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address of a cToken\n    address public immutable cToken;\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    IRedeemer public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    error Approvals(uint256 approved, uint256 amount);\n\n    error Authorized(address owner);\n\n    constructor(uint8 _protocol, address _underlying, uint256 _maturity, address _cToken, address _redeemer, string memory _name, string memory _symbol, uint8 _decimals) \n    Erc20( _name, _symbol, _decimals) {\n        protocol = _protocol;\n        underlying = _underlying;\n        maturity = _maturity;\n        cToken = _cToken;\n        redeemer = IRedeemer(_redeemer);\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner]);\n    }\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner] * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        uint256 previewAmount = this.previewWithdraw(underlyingAmount);\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        // Transfer logic\n        // If holder is msg.sender, skip approval check\n        if (holder == msg.sender) {\n            redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, previewAmount);\n            return previewAmount;\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= previewAmount) {\n                revert Approvals(allowed, previewAmount);\n            }\n            allowance[holder][msg.sender] -= previewAmount;\n            redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, previewAmount); \n            return previewAmount;\n        }\n    }\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param principalAmount The amount of principal tokens being redeemed\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) { revert Maturity(maturity); }\n        // some 5095 tokens may have custody of underlying and can can just burn PTs and transfer underlying out, while others rely on external custody\n        if (holder == msg.sender) {\n            return redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= principalAmount) { revert Approvals(allowed, principalAmount); }\n            allowance[holder][msg.sender] -= principalAmount;  \n            return redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, principalAmount);\n        }\n    }\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    function burn(address f, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    function mint(address t, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    modifier onlyAdmin(address a) {\n    if (msg.sender != a) { revert Authorized(a); }\n    _;\n  }\n}"
    },
    {
      "filename": "Tokens/ZcToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Erc20.sol\";\nimport \"./Compounding.sol\";\nimport \"./IERC5095.sol\";  \nimport \"./IRedeemer.sol\";\n\n// Utilizing an external custody contract to allow for backwards compatability with some projects.\n// Assumes interest generated post maturity using an internal Compounding library.\ncontract ZcToken is Erc20, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev uint8 associated with a given protocol in Swivel\n    uint8 public immutable protocol;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address of a cToken\n    address public immutable cToken;\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    IRedeemer public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    error Approvals(uint256 approved, uint256 amount);\n\n    error Authorized(address owner);\n\n    constructor(uint8 _protocol, address _underlying, uint256 _maturity, address _cToken, address _redeemer, string memory _name, string memory _symbol, uint8 _decimals) \n    Erc20( _name, _symbol, _decimals) {\n        protocol = _protocol;\n        underlying = _underlying;\n        maturity = _maturity;\n        cToken = _cToken;\n        redeemer = IRedeemer(_redeemer);\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner]);\n    }\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner] * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        uint256 previewAmount = this.previewWithdraw(underlyingAmount);\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        // Transfer logic\n        // If holder is msg.sender, skip approval check\n        if (holder == msg.sender) {\n            redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, previewAmount);\n            return previewAmount;\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= previewAmount) {\n                revert Approvals(allowed, previewAmount);\n            }\n            allowance[holder][msg.sender] -= previewAmount;\n            redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, previewAmount); \n            return previewAmount;\n        }\n    }\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param principalAmount The amount of principal tokens being redeemed\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) { revert Maturity(maturity); }\n        // some 5095 tokens may have custody of underlying and can can just burn PTs and transfer underlying out, while others rely on external custody\n        if (holder == msg.sender) {\n            return redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= principalAmount) { revert Approvals(allowed, principalAmount); }\n            allowance[holder][msg.sender] -= principalAmount;  \n            return redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, principalAmount);\n        }\n    }\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    function burn(address f, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    function mint(address t, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    modifier onlyAdmin(address a) {\n    if (msg.sender != a) { revert Authorized(a); }\n    _;\n  }\n}"
    }
  ]
}