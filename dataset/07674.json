{
  "Title": "[H-02] Rewards of GiantMevAndFeesPool can be locked for all users",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L172\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L8\n\n\n# Vulnerability details\n\n## Impact\nAny malicious user could make the rewards in GiantMevAndFeesPool inaccessible to all other users...\n\n## Proof of Concept\n\nhttps://gist.github.com/clems4ever/9b05391cc2192c1b6e8178faa38dfe41\n\nCopy the file in the test suite and run the test.\n\n## Tools Used\n\nforge test\n\n## Recommended Mitigation Steps\n\nProtect the inherited functions of the ERC20 tokens (GiantLP and LPToken) because `transfer` is not protected and can trigger the `before` and `after` hooks. There is the same issue with LPToken and StakingFundsVault.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/GiantMevAndFeesPool.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}"
    },
    {
      "filename": "contracts/liquid-staking/GiantLP.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\ncontract GiantLP is ERC20 {\n\n    /// @notice Address of giant pool that deployed the giant LP token\n    address public pool;\n\n    /// @notice Optional address of contract that will process transfers of giant LP\n    ITransferHookProcessor public transferHookProcessor;\n\n    /// @notice Last interacted timestamp for a given address\n    mapping(address => uint256) public lastInteractedTimestamp;\n\n    constructor(\n        address _pool,\n        address _transferHookProcessor,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        pool = _pool;\n        transferHookProcessor = ITransferHookProcessor(_transferHookProcessor);\n    }\n\n    function mint(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _mint(_recipient, _amount);\n    }\n\n    function burn(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _burn(_recipient, _amount);\n    }\n\n    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        lastInteractedTimestamp[_from] = block.timestamp;\n        lastInteractedTimestamp[_to] = block.timestamp;\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).afterTokenTransfer(_from, _to, _amount);\n    }\n}"
    }
  ]
}