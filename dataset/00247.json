{
  "Title": "Missing Type Conversion",
  "Content": "The [`NewWithdrawal`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-chain-ops/crossdomain/withdrawal.go#L38-L53) function of OP-Chains-Ops returns a `Withdrawal` struct with filled values. The [`Data`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-chain-ops/crossdomain/withdrawal.go#L34) field, which is of type `hexutil.Bytes`, is assigned [`data`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-chain-ops/crossdomain/withdrawal.go#L51) of type `[]byte`. However, the assigned value should first be converted to the correct type using the `hexutil.Bytes` function.\n\n\nConsider converting the `data` parameter to the `hexutil.Bytes` type.\n\n\n***Update:** Not resolved. The Mantle team stated:*\n\n\n\n> *Not a valid issue.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "op-chain-ops/crossdomain/withdrawal.go",
      "content": "package crossdomain\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/bindings\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/common/hexutil\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n)\n\nvar (\n\tSentMessageEventABI               = \"SentMessage(address,address,bytes,uint256)\"\n\tSentMessageEventABIHash           = crypto.Keccak256Hash([]byte(SentMessageEventABI))\n\tSentMessageExtension1EventABI     = \"SentMessage(address,uint256,uint256)\"\n\tSentMessageExtension1EventABIHash = crypto.Keccak256Hash([]byte(SentMessageExtension1EventABI))\n\tMessagePassedEventABI             = \"MessagePassed(uint256,address,address,uint256,uint256,uint256,bytes,bytes32)\"\n\tMessagePassedEventABIHash         = crypto.Keccak256Hash([]byte(MessagePassedEventABI))\n)\n\nvar _ WithdrawalMessage = (*Withdrawal)(nil)\n\n// Withdrawal represents a withdrawal transaction on L2\ntype Withdrawal struct {\n\tNonce    *big.Int        `json:\"nonce\"`\n\tSender   *common.Address `json:\"sender\"`\n\tTarget   *common.Address `json:\"target\"`\n\tMNTValue *big.Int        `json:\"mntValue\"`\n\tETHValue *big.Int        `json:\"ethValue\"`\n\tGasLimit *big.Int        `json:\"gasLimit\"`\n\tData     hexutil.Bytes   `json:\"data\"`\n}\n\n// NewWithdrawal will create a Withdrawal\nfunc NewWithdrawal(\n\tnonce *big.Int,\n\tsender, target *common.Address,\n\tmntValue, ethValue, gasLimit *big.Int,\n\tdata []byte,\n) *Withdrawal {\n\treturn &Withdrawal{\n\t\tNonce:    nonce,\n\t\tSender:   sender,\n\t\tTarget:   target,\n\t\tMNTValue: mntValue,\n\t\tETHValue: ethValue,\n\t\tGasLimit: gasLimit,\n\t\tData:     data,\n\t}\n}\n\n// Encode will serialize the Withdrawal so that it is suitable for hashing.\nfunc (w *Withdrawal) Encode() ([]byte, error) {\n\targs := abi.Arguments{\n\t\t{Name: \"nonce\", Type: Uint256Type},\n\t\t{Name: \"sender\", Type: AddressType},\n\t\t{Name: \"target\", Type: AddressType},\n\t\t{Name: \"mntValue\", Type: Uint256Type},\n\t\t{Name: \"ethValue\", Type: Uint256Type},\n\t\t{Name: \"gasLimit\", Type: Uint256Type},\n\t\t{Name: \"data\", Type: BytesType},\n\t}\n\tenc, err := args.Pack(w.Nonce, w.Sender, w.Target, w.MNTValue, w.ETHValue, w.GasLimit, []byte(w.Data))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot encode withdrawal: %w\", err)\n\t}\n\treturn enc, nil\n}\n\n// Decode will deserialize a Withdrawal\nfunc (w *Withdrawal) Decode(data []byte) error {\n\targs := abi.Arguments{\n\t\t{Name: \"nonce\", Type: Uint256Type},\n\t\t{Name: \"sender\", Type: AddressType},\n\t\t{Name: \"target\", Type: AddressType},\n\t\t{Name: \"mntValue\", Type: Uint256Type},\n\t\t{Name: \"ethValue\", Type: Uint256Type},\n\t\t{Name: \"gasLimit\", Type: Uint256Type},\n\t\t{Name: \"data\", Type: BytesType},\n\t}\n\tdecoded, err := args.Unpack(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnonce, ok := decoded[0].(*big.Int)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode nonce\")\n\t}\n\tsender, ok := decoded[1].(common.Address)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode sender\")\n\t}\n\ttarget, ok := decoded[2].(common.Address)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode target\")\n\t}\n\tmntValue, ok := decoded[3].(*big.Int)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode mntValue\")\n\t}\n\tethValue, ok := decoded[4].(*big.Int)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode ethValue\")\n\t}\n\tgasLimit, ok := decoded[5].(*big.Int)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode gasLimit\")\n\t}\n\tmsgData, ok := decoded[6].([]byte)\n\tif !ok {\n\t\treturn errors.New(\"cannot abi decode data\")\n\t}\n\n\tw.Nonce = nonce\n\tw.Sender = &sender\n\tw.Target = &target\n\tw.ETHValue = ethValue\n\tw.MNTValue = mntValue\n\tw.GasLimit = gasLimit\n\tw.Data = hexutil.Bytes(msgData)\n\treturn nil\n}\n\n// Hash will hash the Withdrawal. This is the hash that is computed in\n// the L2ToL1MessagePasser. The encoding is the same as the v1 cross domain\n// message encoding without the 4byte selector prepended.\nfunc (w *Withdrawal) Hash() (common.Hash, error) {\n\tencoded, err := w.Encode()\n\tif err != nil {\n\t\treturn common.Hash{}, err\n\t}\n\thash := crypto.Keccak256(encoded)\n\treturn common.BytesToHash(hash), nil\n}\n\n// StorageSlot will compute the storage slot that will be set to\n// true in the L2ToL1MessagePasser. The withdrawal proof sent to\n// L1 will prove that this storage slot is set to \"true\".\nfunc (w *Withdrawal) StorageSlot() (common.Hash, error) {\n\thash, err := w.Hash()\n\tif err != nil {\n\t\treturn common.Hash{}, err\n\t}\n\tpreimage := make([]byte, 64)\n\tcopy(preimage, hash.Bytes())\n\n\tslot := crypto.Keccak256(preimage)\n\treturn common.BytesToHash(slot), nil\n}\n\n// WithdrawalTransaction will convert the Withdrawal to a type\n// suitable for sending a transaction.\nfunc (w *Withdrawal) WithdrawalTransaction() bindings.TypesWithdrawalTransaction {\n\treturn bindings.TypesWithdrawalTransaction{\n\t\tNonce:    w.Nonce,\n\t\tSender:   *w.Sender,\n\t\tTarget:   *w.Target,\n\t\tEthValue: w.ETHValue,\n\t\tMntValue: w.MNTValue,\n\t\tGasLimit: w.GasLimit,\n\t\tData:     []byte(w.Data),\n\t}\n}"
    }
  ]
}