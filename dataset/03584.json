{
  "Title": "[M01] Documentation issues",
  "Content": "Although many functions in the codebase are well documented, there are numerous other functions that are lacking sufficient inline documentation. For example:\n\n\n* Missing NatSpec for all functions of [`VaultLifecycle`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L493).\n* Missing NatSpec for the [return value of `accountVaultBalance`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L567) in `RibbonVault`.\n* Missing NatSpec params for [`initialize`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L105) in `RibbonThetaVault`.\n* Missing NatSpec for return value of [`burnOtokens`](https://simple.ripley.cl/lavadora-secadora-winia-dwc-k9630w-2000379945740p?color_80=blanco&s=o) in `VaultLifecycle`.\n* In `RibbonThetaVault`, block comments are used to group functions into categories. [`withdrawInstantly`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L175) is incorrectly categorized as a `SETTER`, and [`setStrikePrice`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L321) is incorrectly categorized as a `VAULT OPERATION`.\n\n\nThere are also instances of misleading documentation. For example:\n\n\n* The comment [`address to transfer to`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L367) should be `address to transfer from`.\n* The comment [`3 decimals`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L169) should be `2 decimals`.\n* The comment [`Burning all otokens that are left from the gnosis auction`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L359), is misleading. In fact the *provided* `amount` of oTokens are burned.\n* The comment that references [`closeShort`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L252) is confusing. That is not the name of a function and it is unclear if this should be `_closeShort`, `settleShort`, or the name of the action being sent to the `gammaController`.\n* The comment [`we need this contract to receive so we can swap at the end`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L214) is misleading, as the value that this comment is referring to is not used by the `OpenVault` action.\n* The comment [`but gnosis will transfer all the otokens`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/GnosisAuction.sol#L201) should be `otokens will be transferred to gnosis`.\n\n\nTo further clarify intent and improve overall code readability, consider adding additional inline documentation, fixing documentation mistakes, and carefully verifying all documentation throughout the codebase.\n\n\n**Update**: *Fixed in commit [`8b7bcedd0050823842b2b65c5d459fc90542c82a` of PR#80](https://github.com/ribbon-finance/ribbon-v2/pull/80/commits/8b7bcedd0050823842b2b65c5d459fc90542c82a). However, this PR also introduces a few unaudited functions such as `getVaultFees` in `VaultLifecycle`, `setOptionsPremiumPricer` in `RibbonThetaVault`, and others. Additionally, the `verifyOtoken` function was [modified to accept additional arguments](https://github.com/ribbon-finance/ribbon-v2/pull/80/files#diff-b7d6dd759664ddd07407cab3f859ce50c12fbaa6c29373612cc32f17fbb40272R121), but those arguments are not supplied [where the function is used](https://github.com/ribbon-finance/ribbon-v2/blob/8b7bcedd0050823842b2b65c5d459fc90542c82a/contracts/libraries/VaultLifecycle.sol#L544).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/VaultLifecycle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../interfaces/IRibbon.sol\";\nimport {GnosisAuction} from \"./GnosisAuction.sol\";\nimport {\n    IOtokenFactory,\n    IOtoken,\n    IController,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\nimport {\n    SupportsNonCompliantERC20\n} from \"../libraries/SupportsNonCompliantERC20.sol\";\n\nlibrary VaultLifecycle {\n    using SafeMath for uint256;\n    using SupportsNonCompliantERC20 for IERC20;\n\n    struct CloseParams {\n        address OTOKEN_FACTORY;\n        address USDC;\n        address currentOption;\n        uint256 delay;\n        uint16 lastStrikeOverride;\n        uint256 overriddenStrikePrice;\n    }\n\n    function commitAndClose(\n        address strikeSelection,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount,\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry;\n\n        // uninitialized state\n        if (closeParams.currentOption == address(0)) {\n            expiry = getNextFriday(block.timestamp);\n        } else {\n            expiry = getNextFriday(\n                IOtoken(closeParams.currentOption).expiryTimestamp()\n            );\n        }\n\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\n\n        bool isPut = vaultParams.isPut;\n        address underlying = vaultParams.underlying;\n        address asset = vaultParams.asset;\n\n        (strikePrice, delta) = closeParams.lastStrikeOverride ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        otokenAddress = getOrDeployOtoken(\n            closeParams,\n            underlying,\n            asset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        premium = GnosisAuction.getOTokenPremium(\n            otokenAddress,\n            optionsPremiumPricer,\n            premiumDiscount\n        );\n\n        require(premium > 0, \"!premium\");\n    }\n\n    function verifyOtoken(address otokenAddress, uint256 delay) private view {\n        require(otokenAddress != address(0), \"!otokenAddress\");\n\n        IOtoken otoken = IOtoken(otokenAddress);\n        uint256 readyAt = block.timestamp.add(delay);\n        require(otoken.expiryTimestamp() >= readyAt, \"Expiry before delay\");\n    }\n\n    function rollover(\n        uint256 currentSupply,\n        address asset,\n        uint8 decimals,\n        uint256 initialSharePrice,\n        uint256 pendingAmount,\n        uint128 queuedWithdrawShares\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares\n        )\n    {\n        uint256 currentBalance = IERC20(asset).balanceOf(address(this));\n        uint256 roundStartBalance = currentBalance.sub(pendingAmount);\n\n        uint256 singleShare = 10**uint256(decimals);\n\n        newPricePerShare = getPPS(\n            currentSupply,\n            roundStartBalance,\n            singleShare,\n            initialSharePrice\n        );\n\n        // After closing the short, if the options expire in-the-money\n        // vault pricePerShare would go down because vault's asset balance decreased.\n        // This ensures that the newly-minted shares do not take on the loss.\n        uint256 _mintShares =\n            pendingAmount.mul(singleShare).div(newPricePerShare);\n\n        uint256 newSupply = currentSupply.add(_mintShares);\n\n        uint256 queuedWithdrawAmount =\n            newSupply > 0\n                ? uint256(queuedWithdrawShares).mul(currentBalance).div(\n                    newSupply\n                )\n                : 0;\n\n        return (\n            currentBalance.sub(queuedWithdrawAmount),\n            newPricePerShare,\n            _mintShares\n        );\n    }\n\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Otoken.sol#L70\n    uint256 private constant OTOKEN_DECIMALS = 10**8;\n\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID =\n            (controller.getAccountVaultCounter(address(this))).add(1);\n\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals =\n            uint256(IERC20Detailed(collateralAsset).decimals());\n        uint256 mintAmount;\n\n        if (oToken.isPut()) {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount = depositAmount\n                .mul(OTOKEN_DECIMALS)\n                .mul(DSWAD) // we use 10**18 to give extra precision\n                .div(\n                oToken.strikePrice().mul(10**(18 - (8 - collateralDecimals)))\n            );\n        } else {\n            mintAmount = depositAmount;\n            uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\n\n            if (mintAmount > scaleBy && collateralDecimals > 8) {\n                mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\n            }\n        }\n\n        // double approve to fix non-compliant ERC20s\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApprove(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](3);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver -  we need this contract to receive so we can swap at the end\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // deposited asset\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `closeShort` deletes vaults,\n     * this assumption should hold.\n     */\n    function settleShort(address gammaController) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.SettleVault,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(0), // not used\n            vaultID, // vaultId\n            0, // not used\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\n     * It calls the `Redeem` action to claim the payout.\n     */\n    function settleLong(\n        address gammaController,\n        address oldOption,\n        address asset\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\n\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\n            return 0;\n        }\n\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        // If it is after expiry, we need to redeem the profits\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.Redeem,\n            address(0), // not used\n            address(this), // address to send profits to\n            oldOption, // address of otoken\n            0, // not used\n            oldOptionBalance, // otoken balance\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        return endAssetBalance.sub(startAssetBalance);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time.\n     */\n    function burnOtokens(address gammaController, uint256 amount)\n        external\n        returns (uint256)\n    {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // Burning all otokens that are left from the gnosis auction,\n        // then withdrawing the corresponding collateral amount from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](2);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.BurnShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(vault.shortOtokens[0]), // otoken address\n            vaultID, // vaultId\n            amount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.WithdrawCollateral,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(collateralToken), // withdrawn asset\n            vaultID, // vaultId\n            vault.collateralAmounts[0].mul(amount).div(vault.shortAmounts[0]), // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    function getOrDeployOtoken(\n        CloseParams calldata closeParams,\n        address underlying,\n        address collateralAsset,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    ) internal returns (address) {\n        IOtokenFactory factory = IOtokenFactory(closeParams.OTOKEN_FACTORY);\n\n        address otokenFromFactory =\n            factory.getOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        if (otokenFromFactory != address(0)) {\n            return otokenFromFactory;\n        }\n\n        address otoken =\n            factory.createOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        verifyOtoken(otoken, closeParams.delay);\n\n        return otoken;\n    }\n\n    function startAuction(GnosisAuction.AuctionDetails calldata auctionDetails)\n        external\n        returns (uint256)\n    {\n        return GnosisAuction.startAuction(auctionDetails);\n    }\n\n    function placeBid(GnosisAuction.BidDetails calldata bidDetails)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint64\n        )\n    {\n        return GnosisAuction.placeBid(bidDetails);\n    }\n\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) external {\n        GnosisAuction.claimAuctionOtokens(\n            auctionSellOrder,\n            gnosisEasyAuction,\n            counterpartyThetaVault\n        );\n    }\n\n    function verifyConstructorParams(\n        address owner,\n        address feeRecipient,\n        uint256 performanceFee,\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) external pure {\n        require(owner != address(0), \"!owner\");\n        require(feeRecipient != address(0), \"!feeRecipient\");\n        require(performanceFee > 0, \"!performanceFee\");\n        require(performanceFee < 10**8, \"performanceFee >= 100%\");\n        require(bytes(tokenName).length > 0, \"!tokenName\");\n        require(bytes(tokenSymbol).length > 0, \"!tokenSymbol\");\n\n        require(_vaultParams.asset != address(0), \"!asset\");\n        require(_vaultParams.underlying != address(0), \"!underlying\");\n        require(_vaultParams.minimumSupply > 0, \"!minimumSupply\");\n        require(_vaultParams.cap > 0, \"!cap\");\n        require(_vaultParams.initialSharePrice > 0, \"!initialSharePrice\");\n    }\n\n    /**\n     * @notice Gets the next options expiry timestamp\n     * @param currentExpiry is the expiry timestamp of the current option\n     * Reference: https://codereview.stackexchange.com/a/33532\n     * Examples:\n     * getNextFriday(week 1 thursday) -> week 1 friday\n     * getNextFriday(week 1 friday) -> week 2 friday\n     * getNextFriday(week 1 saturday) -> week 2 friday\n     */\n    function getNextFriday(uint256 currentExpiry)\n        internal\n        pure\n        returns (uint256)\n    {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((currentExpiry / 1 days) + 4) % 7;\n        uint256 nextFriday = currentExpiry + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the passed currentExpiry is day=Friday hour>8am, we simply increment it by a week to next Friday\n        if (currentExpiry >= friday8am) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n\n    function getPPS(\n        uint256 currentSupply,\n        uint256 roundStartBalance,\n        uint256 singleShare,\n        uint256 initialSharePrice\n    ) internal pure returns (uint256 newPricePerShare) {\n        newPricePerShare = currentSupply > 0\n            ? singleShare.mul(roundStartBalance).div(currentSupply)\n            : initialSharePrice;\n    }\n\n    /***\n     * DSMath Copy paste\n     */\n\n    uint256 constant DSWAD = 10**18;\n\n    function dsadd(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function dsmul(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function dswdiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        z = dsadd(dsmul(x, DSWAD), y / 2) / y;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/base/RibbonVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {OptionsVaultStorage} from \"../../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {IOtoken} from \"../../interfaces/GammaInterface.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IGnosisAuction} from \"../../interfaces/IGnosisAuction.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../../interfaces/IRibbon.sol\";\n\ncontract RibbonVault is OptionsVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    address public immutable WETH;\n    address public immutable USDC;\n\n    uint256 public constant delay = 1 hours;\n\n    uint256 public constant period = 7 days;\n\n    uint128 internal constant PLACEHOLDER_UINT = 1;\n\n    // Number of weeks per year = 52.142857 weeks * 10**6 = 52142857\n    // Dividing by weeks per year requires doing num.mul(10**6).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(address account, uint256 shares, uint256 round);\n\n    event Redeem(address indexed account, uint256 share, uint16 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap, address manager);\n\n    event Withdraw(address account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function baseInitialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) internal initializer {\n        VaultLifecycle.verifyConstructorParams(\n            _owner,\n            _feeRecipient,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(tokenName, tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        feeRecipient = _feeRecipient;\n        performanceFee = _performanceFee;\n        managementFee = _managementFee.mul(10**6).div(WEEKS_PER_YEAR);\n        vaultParams = _vaultParams;\n        vaultState.lastLockedAmount = uint104(\n            IERC20(vaultParams.asset).balanceOf(address(this))\n        );\n\n        vaultState.round = 1;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(newManagementFee < 100 * 10**6, \"Invalid management fee\");\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n\n        // We are dividing annualized management fee by num weeks in a year\n        managementFee = newManagementFee.mul(10**6).div(WEEKS_PER_YEAR);\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(newPerformanceFee < 100 * 10**6, \"Invalid performance fee\");\n\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint104 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        uint256 oldCap = vaultParams.cap;\n        vaultParams.cap = newCap;\n        emit CapSet(oldCap, newCap, msg.sender);\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares. Reverts if the asset is not WETH.\n     */\n    function depositETH() external payable nonReentrant {\n        require(vaultParams.asset == WETH, \"!WETH\");\n        require(msg.value > 0, \"!value\");\n\n        _depositFor(msg.value, msg.sender);\n\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        _depositFor(amount, msg.sender);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(uint256 amount, address creditor)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"!amount\");\n        require(creditor != address(0));\n\n        _depositFor(amount, creditor);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance().add(amount);\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = uint104(amount);\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount).add(amount);\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            processed: false,\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: unredeemedShares\n        });\n\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).add(amount)\n        );\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param shares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint128 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool topup = withdrawal.round == currentRound;\n\n        emit InitiateWithdraw(msg.sender, shares, currentRound);\n\n        uint256 withdrawalShares = uint256(withdrawal.shares);\n\n        if (topup) {\n            uint256 increasedShares = withdrawalShares.add(shares);\n            ShareMath.assertUint128(increasedShares);\n            withdrawals[msg.sender].shares = uint128(increasedShares);\n        } else if (withdrawalShares == 0) {\n            withdrawals[msg.sender].shares = shares;\n            withdrawals[msg.sender].round = uint16(currentRound);\n        } else {\n            // If we have an old withdrawal, we revert\n            // The user has to process the withdrawal\n            revert(\"Existing withdraw\");\n        }\n\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).add(shares)\n        );\n\n        _transfer(msg.sender, address(this), shares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).sub(withdrawalShares)\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToUnderlying(\n                withdrawalShares,\n                roundPricePerShare[uint16(withdrawalRound)],\n                vaultParams.decimals\n            );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        require(withdrawAmount > 0, \"!withdrawAmount\");\n        transferAsset(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem\n     */\n    function redeem(uint256 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n        _redeem(shares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 shares, bool isMax) internal {\n        ShareMath.assertUint104(shares);"
    }
  ]
}