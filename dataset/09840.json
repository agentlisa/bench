{
  "Title": "[L-02] Incorrect opcode specification documentation",
  "Content": "\n### Line References\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/cross-chain-contracts/README.md#op-code-specification>\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/cross-chain-contracts/terra/contracts/wormhole-bridge/src/contract.rs#L99-L125>\n\n### Description\n\nIt is unclear if the full opcode values include the flags as well. If so, they should be 8 bits in length, which isnâ€™t the case. Their decimal representations are also incorrect.\n\n```markdown\n| Opcode | Flags | Full Opcode | Decimal |\n|:-------|:------|:------------|:-------|\n| Deposit Stable | `FLAG_BOTH_TRANSFERS` | `0b110000` | `192` |\n| Redeem Stable | `FLAG_BOTH_TRANSFERS` | `0b110001` | `193` |\n| Repay Stable | `FLAG_INCOMING_TRANSFER` | `0b1000000` | `64` |\n| Lock Collateral | `FLAG_INCOMING_TRANSFER` | `0b1000001` | `65` |\n| Unlock Collateral | `FLAG_OUTGOING_TRANSFER` | `0b0100000` | `32` |\n| Borrow Stable | `FlAG_OUTGOING_TRANSFER` | `0b0100001` | `33` |\n| Claim Rewards | `FLAG_OUTGOING_TRANSFER` | `0b0100010` | `34` |\n```\n\nThe opcodes were also not updated in the comments of the wormhole bridge terra contract.\n\n### Recommended Mitigation Steps\n\nUpdate the comments to reflect the latest changes.\n\n```markdown\n| Opcode | Flags | Full Opcode | Decimal |\n|:-------|:------|:------------|:-------|\n| Deposit Stable | `FLAG_BOTH_TRANSFERS` | `0b11000000` | `192` |\n| Redeem Stable | `FLAG_BOTH_TRANSFERS` | `0b11000001` | `193` |\n| Repay Stable | `FLAG_INCOMING_TRANSFER` | `0b10000000` | `128` |\n| Lock Collateral | `FLAG_INCOMING_TRANSFER` | `0b10000001` | `129` |\n| Unlock Collateral | `FLAG_OUTGOING_TRANSFER` | `0b01000000` | `64` |\n| Borrow Stable | `FlAG_OUTGOING_TRANSFER` | `0b01000001` | `65` |\n| Claim Rewards | `FLAG_OUTGOING_TRANSFER` | `0b01000010` | `66` |\n```\n\n```rust\n/*\nstruct Instruction {\n  uint8 op_code; // [1 byte]\n  bytes32 sender_address; // [32 bytes]\n  one_of {\n    // [deposit_stable] opcode = 192\n    uint64 sequence; // [8 bytes]\n\n    // [repay_stable] opcode = 128\n    uint64 sequence; // [8 bytes]\n\n    // [unlock_collateral] opcode = 64\n    bytes32 collorateral_token_address; // [32 bytes]\n    uint128 amount; // [16 bytes]\n\n    // [borrow_stable] opcode = 65\n    uint256 amount; // [16 bytes]\n\n    // [claim rewards] opcode = 66\n    // N/A for now\n\n    // [redeem_stable] opcode = 193\n    uint64 sequence; // [8 bytes]\n\n    // [lock_collateral] opcode = 129\n    uint64 sequence; // [8 bytes]\n  }\n}\n*/\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/cross-chain-contracts/README.md",
      "content": "# xAnchor Deployment\n\n## Compiling contracts:\n\n```shell\nnpm run compile_eth\nnpm run compile_terra\n```\n\n## Deploying contracts:\n\n`env.json` contains all relevant information for a testnet deployment. To deploy xAnchor to testnet:\n\n```shell\nnpm run deploy\n```\n\nThis will also rewrite the contract addresses in `env.json` with the most recently deployed set\n\n## Testing:\n\n```\nnpm run test\n```\n\nThis will run tests against the deployed contracts in `env.json`\n\n## Migration\n\nDeploying everything takes a while. Since both of ETH and Terra side contracts are upgradable, we can update them in place to speed up our iteration time.\n\n```\nnpm run migrate_terra\nnpm run migrate_eth\n```\n\n## OP Code Specification\n\nOpcodes are specified as 8-bit unsigned integers. We split the opcode into two parts:\n\n- The first 6 least significant bits are the opcode itself\n- The last 2 bits are the flag bits\n\nWe have the following flags defined:\n\n- `0b10`: `FLAG_INCOMING_TRANSFER`\n- `0b01`: `FLAG_OUTGOING_TRANSFER`\n- `0b11`: `FLAG_BOTH_TRANSFERS`\n- `0b00`: `FLAG_NO_ASSC_TRANSFERS`\n\nWe have the following opcodes:\n| Opcode | Flags | Full Opcode | Decimal |\n|:-------|:------|:------------|:-------|\n| Deposit Stable | `FLAG_BOTH_TRANSFERS` | `0b110000` | `192` |\n| Redeem Stable | `FLAG_BOTH_TRANSFERS` | `0b110001` | `193` |\n| Repay Stable | `FLAG_INCOMING_TRANSFER` | `0b1000000` | `64` |\n| Lock Collateral | `FLAG_INCOMING_TRANSFER` | `0b1000001` | `65` |\n| Unlock Collateral | `FLAG_OUTGOING_TRANSFER` | `0b0100000` | `32` |\n| Borrow Stable | `FlAG_OUTGOING_TRANSFER` | `0b0100001` | `33` |\n| Claim Rewards | `FLAG_OUTGOING_TRANSFER` | `0b0100010` | `34` |"
    },
    {
      "filename": "contracts/cross-chain-contracts/terra/contracts/wormhole-bridge/src/contract.rs",
      "content": "use std::vec;\n\nuse crate::state::{\n    Config, OutgoingTokenTransferInfo, SequenceInfo, CHAIN_ID_TO_ANCHOR_BRIDGE_ADDRESS_MAP,\n    COMPLETED_INSTRUCTIONS, CONFIG, SEQUENCE_STORE, TERRA_CHAIN_ID,\n    TMP_OUTGOING_TOKEN_TRANSFER_INFO,\n};\nuse crate::util::{\n    get_next_sequence, ANCHOR_BORROW_OPS, FLAG_INCOMING_TRANSFER, FLAG_OUTGOING_TRANSFER,\n    OP_CODE_BORROW_STABLE, OP_CODE_CLAIM_REWARDS, OP_CODE_DEPOSIT_STABLE, OP_CODE_REDEEM_STABLE,\n    OP_CODE_REPAY_STABLE, OP_CODE_UNLOCK_COLLATERAL,\n};\nuse cosmwasm_std::{\n    entry_point, to_binary, Binary, Coin, ContractResult, CosmosMsg, Deps, DepsMut, Env,\n    MessageInfo, Reply, Response, StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\nuse crossanchor::bridge::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\nuse crossanchor::byte_utils::{extend_terra_address_to_32, ByteUtils};\nuse crossanchor::core;\nuse crossanchor::wormhole::{\n    Action, ParsedVAA, TokenBridgeMessage, TransferInfo, WormholeCoreBridgeExecuteMsg,\n    WormholeCoreBridgeQueryMsg, WormholeTokenBridgeExecuteMsg,\n};\nuse cw_storage_plus::U16Key;\nuse terraswap::asset::{Asset, AssetInfo};\n\nstatic TOKEN_TRANSFER_SUBMIT_VAA_MSG_ID: u64 = 0;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    CONFIG.save(\n        deps.storage,\n        &Config {\n            owner: deps.api.addr_validate(&msg.owner)?,\n            wormhole_core_bridge_addr: deps.api.addr_validate(&msg.wormhole_core_bridge_addr)?,\n            wormhole_token_bridge_addr: deps.api.addr_validate(&msg.wormhole_token_bridge_addr)?,\n            cross_anchor_core_addr: deps.api.addr_validate(&msg.cross_anchor_core_addr)?,\n            aust_cw20_addr: deps.api.addr_validate(&msg.aust_cw20_addr)?,\n        },\n    )?;\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> StdResult<Response> {\n    match msg {\n        // execute instructions from the e side\n        ExecuteMsg::ProcessAnchorMessage {\n            instruction_vaa,\n            option_token_transfer_vaa,\n        } => process_anchor_message(deps, env, instruction_vaa, option_token_transfer_vaa),\n        ExecuteMsg::SendAsset { asset } => send_asset(deps, env, info, asset),\n        ExecuteMsg::RegisterWormholeChainInfo { chain_id, address } => {\n            register_wormhole_chain_info(deps, info, chain_id, address)\n        }\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::SequenceInfo { chain_id, sequence } => to_binary(&SEQUENCE_STORE.load(\n            deps.storage,\n            (&chain_id.to_be_bytes(), &sequence.to_be_bytes()),\n        )?),\n    }\n}\n\nfn register_wormhole_chain_info(\n    deps: DepsMut,\n    info: MessageInfo,\n    chain_id: u16,\n    address: Vec<u8>,\n) -> StdResult<Response> {\n    let cfg = CONFIG.load(deps.storage)?;\n    if info.sender.as_str() != cfg.owner.as_str() {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n    CHAIN_ID_TO_ANCHOR_BRIDGE_ADDRESS_MAP.save(deps.storage, U16Key::from(chain_id), &address)?;\n    Ok(Response::default())\n}\n\nfn get_parsed_vaa(deps: Deps, env: &Env, config: &Config, vaa: &Binary) -> StdResult<ParsedVAA> {\n    deps.querier.query_wasm_smart(\n        config.wormhole_core_bridge_addr.clone(),\n        &WormholeCoreBridgeQueryMsg::VerifyVAA {\n            vaa: vaa.clone(),\n            block_time: env.block.time.seconds(),\n        },\n    )\n}\n\n/*\nstruct Instruction {\n    uint8 op_code; // [1 byte]\n    bytes32 sender_address; // [32 bytes]\n    one_of {\n        // [deposit_stable] opcode = 0\n        uint64 sequence; // [8 bytes]\n\n        // [repay_stable] opcode = 1\n        uint64 sequence; // [8 bytes]\n\n        // [unlock_collateral] opcode = 2\n        bytes32 collorateral_token_address; // [32 bytes]\n        uint128 amount; // [16 bytes]\n\n        // [borrow_stable] opcode = 3\n        uint256 amount; // [16 bytes]\n\n        // [claim rewards] opcode = 4\n        // N/A for now\n\n        // [redeem_stable] opcode = 5\n        uint64 sequence; // [8 bytes]\n\n        // [lock_collateral] opcode = 6\n        uint64 sequence; // [8 bytes]\n    }\n}\n*/\n\nfn create_core_execute_message(\n    config: &Config,\n    msg: core::ExecuteMsg,\n    funds: Vec<Coin>,\n) -> CosmosMsg {\n    CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.cross_anchor_core_addr.to_string(),\n        msg: to_binary(&msg).unwrap(),\n        funds,\n    })\n}\n\nfn process_anchor_message(\n    deps: DepsMut,\n    env: Env,\n    // generic message\n    instruction_vaa: Binary,\n    // accompanying token transfer\n    option_token_transfer_vaa: Option<Binary>,\n) -> StdResult<Response> {\n    let config = CONFIG.load(deps.storage)?;\n    let parsed_instruction_vaa = get_parsed_vaa(deps.as_ref(), &env, &config, &instruction_vaa)?;\n    let expected_anchor_bridge_address = CHAIN_ID_TO_ANCHOR_BRIDGE_ADDRESS_MAP.load(\n        deps.storage,\n        U16Key::from(parsed_instruction_vaa.emitter_chain),\n    )?;\n    if parsed_instruction_vaa.emitter_address != expected_anchor_bridge_address {\n        return Err(StdError::generic_err(\"unexpected Anchor bridge address\"));\n    }\n\n    // block replay attacks\n    let completed = COMPLETED_INSTRUCTIONS\n        .load(deps.storage, parsed_instruction_vaa.hash.as_slice())\n        .unwrap_or(false);\n    if completed {\n        return Err(StdError::generic_err(\"instruction already completed\"));\n    }\n    COMPLETED_INSTRUCTIONS.save(deps.storage, parsed_instruction_vaa.hash.as_slice(), &true)?;\n\n    static OP_CODE_INDEX: usize = 0;\n    static SENDER_ADDRESS_INDEX: usize = 1;\n    static ADDRESS_LEN: usize = 32;\n    static OP_SPECIFIC_PAYLOAD_INDEX: usize = 33;\n    let op_code = parsed_instruction_vaa\n        .payload\n        .as_slice()\n        .get_u8(OP_CODE_INDEX);\n    let sender_chain = parsed_instruction_vaa.emitter_chain;\n    let sender_address = parsed_instruction_vaa.payload.as_slice()\n        [SENDER_ADDRESS_INDEX..SENDER_ADDRESS_INDEX + ADDRESS_LEN]\n        .to_vec();\n\n    // this contract is going to call crossanchor-core\n    // crossanchor-core will send tokens to this address and this contract\n    // is expected to forward those tokens over the wormhole\n    // take note of the recipient here\n    if op_code & FLAG_OUTGOING_TRANSFER != 0 {\n        let outgoing_token_transfer_info = OutgoingTokenTransferInfo {\n            chain_id: sender_chain,\n            token_recipient_address: sender_address.clone(),\n            token_transfer_sequence: get_next_sequence(\n                deps.as_ref(),\n                &config,\n                &config.wormhole_token_bridge_addr,\n            )?,\n            instruction_sequence: parsed_instruction_vaa.sequence,\n        };\n        TMP_OUTGOING_TOKEN_TRANSFER_INFO.save(deps.storage, &outgoing_token_transfer_info)?;\n    }\n\n    // record an ack on the terra side\n    SEQUENCE_STORE.save(\n        deps.storage,\n        (\n            &sender_chain.to_be_bytes(),\n            &parsed_instruction_vaa.sequence.to_be_bytes(),\n        ),\n        &SequenceInfo {\n            outgoing_sequence_expected: op_code & FLAG_OUTGOING_TRANSFER != 0,\n            outgoing_sequence: None,\n        },\n    )?;\n\n    let mut response = Response::new();\n    // borrow ops are routed through an address proxy contract\n    // make sure its initialized; if its already initialized this is a no-op\n    if ANCHOR_BORROW_OPS.contains(&op_code) {\n        response = response.add_message(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: config.cross_anchor_core_addr.to_string(),\n            msg: to_binary(&core::ExecuteMsg::InitializeAddressProxy {\n                chain_id: sender_chain,\n                address: sender_address.clone(),\n            })?,\n            funds: vec![],\n        }));\n    }\n\n    // ensure the incoming asset has been properly sent\n    if op_code & FLAG_INCOMING_TRANSFER != 0 {\n        let expected_sequence = parsed_instruction_vaa\n            .payload\n            .as_slice()\n            .get_u64(OP_SPECIFIC_PAYLOAD_INDEX);\n        let token_transfer_vaa = option_token_transfer_vaa.unwrap();\n        let asset = process_token_transfer_message(\n            deps.as_ref(),\n            env,\n            &config,\n            sender_chain,\n            expected_sequence,\n            &token_transfer_vaa,\n        )?;\n        // attempt to complete the transfer; if it has already been completed, no-op\n        response = response.add_submessage(SubMsg {\n            id: TOKEN_TRANSFER_SUBMIT_VAA_MSG_ID,\n            msg: CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: config.wormhole_token_bridge_addr.to_string(),\n                funds: vec![],\n                msg: to_binary(&WormholeTokenBridgeExecuteMsg::SubmitVaa {\n                    data: token_transfer_vaa,\n                })?,\n            }),\n            gas_limit: None,\n            reply_on: cosmwasm_std::ReplyOn::Error,\n        });\n\n        // forward appropriate message to core\n        if op_code == OP_CODE_DEPOSIT_STABLE {\n            response = response.add_message(create_core_execute_message(\n                &config,\n                core::ExecuteMsg::DepositStable {\n                    sender_chain,\n                    sender_address,\n                },\n                vec![asset.deduct_tax(&deps.querier)?],\n            ));\n        } else if op_code == OP_CODE_REPAY_STABLE {\n            response = response.add_message(create_core_execute_message(\n                &config,\n                core::ExecuteMsg::RepayStable {\n                    sender_chain,\n                    sender_address,\n                },\n                vec![asset.deduct_tax(&deps.querier)?],\n            ));\n        } else if let AssetInfo::Token { contract_addr } = asset.info {\n            let cw20_hook_msg = if op_code == OP_CODE_REDEEM_STABLE {\n                core::Cw20HookMsg::RedeemStable {\n                    sender_chain,\n                    sender_address,\n                }\n            } else {\n                core::Cw20HookMsg::LockCollateral {\n                    sender_chain,\n                    sender_address,\n                }\n            };\n            response = response.add_message(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr,\n                msg: to_binary(&cw20::Cw20ExecuteMsg::Send {\n                    contract: config.cross_anchor_core_addr.to_string(),\n                    amount: asset.amount,\n                    msg: to_binary(&cw20_hook_msg)?,\n                })?,\n                funds: vec![],\n            }));\n        } else {\n            return Err(StdError::generic_err(\n                \"expecting a Terra cw20 token but received Terra native token\",\n            ));\n        }\n    } else {\n        match op_code {\n            OP_CODE_UNLOCK_COLLATERAL => {\n                response = response.add_message(create_core_execute_message(\n                    &config,\n                    core::ExecuteMsg::UnlockCollateral {\n                        sender_chain,\n                        sender_address,\n                        asset: Asset {\n                            info: AssetInfo::Token {\n                                contract_addr: deps\n                                    .api\n                                    .addr_humanize(\n                                        &parsed_instruction_vaa\n                                            .payload\n                                            .as_slice()\n                                            .get_address(OP_SPECIFIC_PAYLOAD_INDEX),\n                                    )?\n                                    .to_string(),\n                            },\n                            amount: Uint128::from(\n                                parsed_instruction_vaa\n                                    .payload\n                                    .as_slice()\n                                    .get_u128_be(OP_SPECIFIC_PAYLOAD_INDEX + ADDRESS_LEN),\n                            ),\n                        },\n                    },\n                    vec![],\n                ));\n            }\n            OP_CODE_BORROW_STABLE => {\n                response = response.add_message(create_core_execute_message(\n                    &config,\n                    core::ExecuteMsg::BorrowStable {\n                        sender_chain,\n                        sender_address,\n                        borrow_amount: parsed_instruction_vaa\n                            .payload\n                            .as_slice()\n                            .get_uint256(OP_SPECIFIC_PAYLOAD_INDEX),\n                    },\n                    vec![],\n                ));\n            }\n            OP_CODE_CLAIM_REWARDS => {\n                response = response.add_message(create_core_execute_message(\n                    &config,\n                    core::ExecuteMsg::ClaimRewards {\n                        sender_chain,\n                        sender_address,\n                    },\n                    vec![],\n                ));\n            }\n            _ => unreachable!(),\n        }\n    }\n\n    Ok(response)\n}\n\nfn process_token_transfer_message(\n    deps: Deps,\n    env: Env,\n    config: &Config,\n    expected_emitter_chain: u16,\n    expected_sequence: u64,\n    token_transfer_vaa: &Binary,\n) -> StdResult<Asset> {\n    let parsed_token_transfer_vaa = get_parsed_vaa(deps, &env, config, token_transfer_vaa)?;\n    if expected_emitter_chain != parsed_token_transfer_vaa.emitter_chain {\n        return Err(StdError::generic_err(\n            \"unexpected token transfer emitter chain\",\n        ));\n    }\n\n    // NOTE: no need to validate the emitter address; this is automatically done\n    // when trying to complete the transfer\n    if expected_sequence != parsed_token_transfer_vaa.sequence {\n        return Err(StdError::generic_err(\"unexpected token transfer sequence\"));\n    }\n    let token_bridge_message = TokenBridgeMessage::deserialize(&parsed_token_transfer_vaa.payload)?;\n    if token_bridge_message.action != Action::TRANSFER {\n        return Err(StdError::generic_err(\"unexpected token transfer action\"));\n    }\n    let transfer_info = TransferInfo::deserialize(&token_bridge_message.payload)?;\n    if transfer_info.recipient_chain != TERRA_CHAIN_ID\n        || transfer_info.recipient\n            != extend_terra_address_to_32(\n                &deps.api.addr_canonicalize(env.contract.address.as_str())?,\n            )\n    {\n        return Err(StdError::generic_err(\"unexpected token transfer recipient\"));\n    }\n    parse_token_transfer_asset(deps, transfer_info)\n}\n\nfn parse_token_transfer_asset(deps: Deps, transfer_info: TransferInfo) -> StdResult<Asset> {\n    if transfer_info.token_chain != TERRA_CHAIN_ID {\n        return Err(StdError::generic_err(\n            \"transferred token is not a Terra token\",\n        ));\n    }\n    let (_, mut amount) = transfer_info.amount;\n    let (_, fee) = transfer_info.fee;\n    amount = amount.checked_sub(fee).unwrap();\n\n    static WORMHOLE_TERRA_NATIVE_TOKEN_INDICATOR: u8 = 1;\n    let asset =\n        if transfer_info.token_address.as_slice()[0] == WORMHOLE_TERRA_NATIVE_TOKEN_INDICATOR {\n            let mut token_address = transfer_info.token_address;\n            let token_address = token_address.as_mut_slice();\n            token_address[0] = 0;\n            let mut denom = token_address.to_vec();\n            denom.retain(|&c| c != 0);\n            let mut asset = Asset {\n                info: AssetInfo::NativeToken {\n                    denom: String::from_utf8(denom)?,\n                },\n                amount: Uint128::from(amount),\n            };\n            // This accounts for tax deducted for the transfer from the token bridge to this Anchor bridge contract.\n            asset.amount = asset.deduct_tax(&deps.querier)?.amount;\n            asset\n        } else {\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: deps\n                        .api\n                        .addr_humanize(&transfer_info.token_address.as_slice().get_address(0))?\n                        .to_string(),\n                },\n                amount: Uint128::from(amount),\n            }\n        };\n    Ok(asset)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(_deps: DepsMut, _env: Env, msg: Reply) -> StdResult<Response> {\n    if msg.id != TOKEN_TRANSFER_SUBMIT_VAA_MSG_ID {\n        return Err(StdError::generic_err(\"unexpected reply id\"));\n    }\n    if let ContractResult::Err(err) = msg.result {\n        if err == \"Generic error: VaaAlreadyExecuted: execute wasm contract failed\" {\n            Ok(Response::default())\n        } else {\n            Err(StdError::generic_err(err))\n        }\n    } else {\n        Err(StdError::generic_err(\"unexpected success reply msg\"))\n    }\n}\n\n// crossanchor-core hits this method when it wants to relay assets back over the bridge\nfn send_asset(deps: DepsMut, env: Env, info: MessageInfo, mut asset: Asset) -> StdResult<Response> {\n    let config = CONFIG.load(deps.storage)?;\n    if info.sender.as_str() != config.cross_anchor_core_addr.as_str() {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut response = Response::new();\n    if asset.is_native_token() {\n        let coin_after_tax = asset.deduct_tax(&deps.querier)?;\n        response = response.add_message(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: config.wormhole_token_bridge_addr.to_string(),\n            msg: to_binary(&WormholeTokenBridgeExecuteMsg::DepositTokens {})?,\n            funds: vec![coin_after_tax.clone()],\n        }));\n        asset.amount = coin_after_tax.amount;\n    } else if let AssetInfo::Token { contract_addr } = asset.clone().info {\n        response = response.add_message(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr,\n            msg: to_binary(&cw20::Cw20ExecuteMsg::IncreaseAllowance {\n                spender: config.wormhole_token_bridge_addr.to_string(),\n                amount: asset.amount,\n                expires: None,\n            })?,\n            funds: vec![],\n        }))\n    }\n\n    const TOKEN_TRANSFER_NONCE: u32 = 135792468u32;\n    const TOKEN_TRANSFER_INFO_NONCE: u32 = 24680135u32;\n    let outgoing_token_transfer_info = TMP_OUTGOING_TOKEN_TRANSFER_INFO.load(deps.storage)?;\n    let cross_bridge_address = CHAIN_ID_TO_ANCHOR_BRIDGE_ADDRESS_MAP.load(\n        deps.storage,\n        U16Key::from(outgoing_token_transfer_info.chain_id),\n    )?;\n\n    let outgoing_sequence = get_next_sequence(deps.as_ref(), &config, &env.contract.address)?;\n\n    // record sequence number of outgoing instruction\n    SEQUENCE_STORE.save(\n        deps.storage,\n        (\n            &outgoing_token_transfer_info.chain_id.to_be_bytes(),\n            &outgoing_token_transfer_info\n                .instruction_sequence\n                .to_be_bytes(),\n        ),\n        &SequenceInfo {\n            outgoing_sequence_expected: true,\n            outgoing_sequence: Some(outgoing_sequence),\n        },\n    )?;\n\n    response = response.add_messages(vec![\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: config.wormhole_token_bridge_addr.to_string(),\n            msg: to_binary(&WormholeTokenBridgeExecuteMsg::InitiateTransfer {\n                asset,\n                recipient_chain: outgoing_token_transfer_info.chain_id,\n                // transfer to the appropriate bridge on the other side\n                recipient: cross_bridge_address.as_slice().into(),\n                fee: Uint128::zero(),\n                nonce: TOKEN_TRANSFER_NONCE,\n            })?,\n            funds: vec![],\n        }),\n        // associated generic message provides info about who can claim it from the bridge\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: config.wormhole_core_bridge_addr.to_string(),\n            msg: to_binary(&WormholeCoreBridgeExecuteMsg::PostMessage {\n                message: Binary::from(outgoing_token_transfer_info.serialize()),\n                nonce: TOKEN_TRANSFER_INFO_NONCE,\n            })?,\n            funds: vec![],\n        }),\n    ]);\n\n    Ok(response)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -> StdResult<Response> {\n    Ok(Response::default())\n}"
    }
  ]
}