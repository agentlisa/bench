{
  "Title": "M-1: Unsafe type casting of `poolValue` can malfunction the whole market",
  "Content": "# Issue M-1: Unsafe type casting of `poolValue` can malfunction the whole market \n\nSource: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/45 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nWhen `poolValue` is a negative number due to loss in `valueChange` and `funding`, the unsafe type casting from `int256` to `uint256` will result in a huge number close to `2**255` which will revert `_rebalancePoolsAndExecuteBatchedActions()` due to overflow when multiplied by 1e18 at L163.\n\n## Vulnerability Detail\n\nIf the funding rate is 100% per year and the `EPOCH_LENGTH` is 4 days, the funding fee for each epoch can be as much as ~1% on the effectiveValue.\n\nPlus, the loss from `valueChange` is capped at 99%, but combining both can still result in a negative `poolValue` at L146.\n\nAt L163 `uint256 price = uint256(poolValue).div(tokenSupply);` the type casting from `int256` to `uint256` will result in a huge number close to `2**255`.\n\n`MathUintFloat.div()` will overflow when a number as large as `2**255` is multiplied by 1e18.\n\n## Impact\n\n`_rebalancePoolsAndExecuteBatchedActions` will revert and cause the malfunction of the whole market.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L118-L185\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a new function to properly handle the bankruptcy of a specific pool.\n\n## Discussion\n\n**JasoonS**\n\nWe seed the pools initially with sufficient un-extractable capital such that this shouldn't be an issue (it should never get close to 0 - even after millions of years and trillions of transactions that may have rounding down and all users withdrawing their funds).\n\nWe could create a safe cast function to check - but we made `poolValue` an int256 so that it is easier to operate on with other signed integers - not because it is ever possible for it to be negative. So it would be redundant in this case.\n\n**moose-code**\n\n@JasoonS Want to relook at this. @WooSungD @Stentonian maybe you also have thoughts. \n\nI believe watchpug is explaining something different. \n\nThey are saying that poolValue can be negative, as a 99% capped loss of poolValue, in conjunction with a 1% funding fee (imagine the side is very overbalanced), will result in the pool value losing more than 100% in total. \n\nA safe guard would be to check that with BOTH funding and value change, 99% is the maximum a pool can lose in any single iteration. \n\nGiven system parameterizations, where epoch length will never be that long and funding rate should never be that high, its unlikely this would be an issue in practice, but likely still worth making a change for. \n\nLet me know if anyone has thoughts \n\n**JasoonS**\n\nYes, you're right, went through these too fast.\n\nWe've discussed this internally a few times. This point should've made it into the readme.\n\nWe could add checks to the epoch length on construction to ensure were safe\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/15",
  "Code": [
    {
      "filename": "contracts/market/template/MarketCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nimport \"./MarketStorage.sol\";\n\n/// @title Main market contract with all the main functionality\ncontract MarketCore is AccessControlledAndUpgradeableModifiers, IMarketCommon, IMarketCore, MarketStorage, ProxyNonPayable {\n  using SafeERC20 for IERC20;\n  using MathUintFloat for uint256;\n  using MathIntFloat for int256;\n\n  /*╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝*/\n\n  function gemCollectingModifierLogic(address user) internal {\n    IGEMS(gems).gm(user);\n  }\n\n  modifier gemCollecting(address user) {\n    gemCollectingModifierLogic(user);\n    _;\n  }\n\n  modifier checkMarketNotDeprecated() {\n    if (marketDeprecated) revert MarketDeprecated();\n    _;\n  }\n\n  /*╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝*/\n\n  /// @notice This calculates the value transfer from the overbalanced to underbalanced side (i.e. the funding rate)\n  /// This is a further incentive measure to balanced markets. This may be present on some and not other pool token markets.\n  /// @param overbalancedIndex poolType with more liquidity.\n  /// @param overbalancedValue Side with more liquidity.\n  /// @param underbalancedValue Side with less liquidity.\n  /// @return fundingAmount The amount the overbalanced side needs to pay the underbalanced.\n  function _calculateFundingAmount(\n    uint256 overbalancedIndex,\n    uint256 overbalancedValue,\n    uint256 underbalancedValue\n  ) internal view returns (int256[2] memory fundingAmount) {\n    /*\n    totalFunding is calculated on the notional of between long and short liquidity and 2x long and short liquidity. \n    The notional on which funding is calculated increaseas as the imbalance increases.\n    The split of funding paid between underbalanced and overbalanced is 50/50 when long = short liq and moves\n    linearly to 100% paid by the overbalanced beyong the point where liquidity is 2:1 ratio\n    (liquidity in overbalanced side is more than double liquidity in underbalanced side)\n    This modular function is logical but naive implementation that will likely change somewhat upon more indepth \n    modelling results that are still pending. \n    */\n\n    // fundingRateMultiplier is in basis points so need to divide by 10,000.\n    uint256 totalFunding = (2 * overbalancedValue * fundingRateMultiplier * oracleManager.EPOCH_LENGTH()) / (365.25 days * 10000);\n\n    uint256 overbalancedFunding = Math.min(\n      totalFunding,\n      (totalFunding * ((2 * overbalancedValue) - underbalancedValue)) / (overbalancedValue + underbalancedValue)\n    );\n    uint256 underbalancedFunding = totalFunding - overbalancedFunding;\n\n    if (overbalancedIndex == SHORT_TYPE) fundingAmount = [-int256(overbalancedFunding), int256(underbalancedFunding)];\n    else fundingAmount = [-int256(underbalancedFunding), int256(overbalancedFunding)];\n  }\n\n  function _getValueChangeAndFunding(\n    uint256 effectiveValueLong,\n    uint256 effectiveValueShort,\n    int256 previousPrice,\n    int256 currentPrice\n  ) internal view returns (int256 floatPoolLeverage, ValueChangeAndFunding memory params) {\n    uint256 floatPoolLiquidity = pools[PoolType.FLOAT][0].value;\n    // We set the floating tranche leverage to the exact leverage that ensure effectiveValueLong = effectiveValueShort when taking\n    //     into the floating liquidity added the underbalanced side.\n    floatPoolLeverage = (int256(effectiveValueShort) - int256(effectiveValueLong)).div(int256(floatPoolLiquidity));\n\n    // If there is a large diff between long and short liquidity or little floatPoolLiquidity, then the float pool leverage\n    // may be set to a very high amount. Here we cap it such that floatPoolLeverage is between -5x and 5x.\n    // This give Market Makers who deposit in the floatPool certain garuntees on the maximum delta they will be exposed to.\n    if (floatPoolLeverage > 5e18) floatPoolLeverage = 5e18;\n    else if (floatPoolLeverage < -5e18) floatPoolLeverage = -5e18;\n\n    // NOTE - we are dividing by previous price before multiplying this value again in _rebalancePoolsAndExecuteBatchedActions - this means some accuracy is lost - however we deem this insignificant.\n    int256 priceMovement_e18 = (currentPrice - previousPrice).div(previousPrice);\n\n    // A really large price movement could bankrupt a 5x leveraged pool. We contrain the price movement to a max percentage\n    // that ensure no pool will be underwater. This limimts the gain/loss on any single price movement. In practice\n    // maxPercentChange is about 20% for a 5x pool, and we don't expect to see 20% price changes in one epoch, but if we do,\n    // The system is able to tolerate it.\n    if (priceMovement_e18 > maxPercentChange) priceMovement_e18 = maxPercentChange;\n    else if (priceMovement_e18 < -maxPercentChange) priceMovement_e18 = -maxPercentChange;\n\n    // Value change (amount to transfer between Short and Long pools) is based on the price movement multiplied by the\n    // Notional value of the smaller side (long or short). Given the float pool should in most cases make the liquidity of long and short\n    // exactly equal, the only case where long and short liquidity is different is when the float pool leverage is constrained to its 5x or -5x cap.\n    // If this is the case, the side with greater liquidity will have a reduced exposure or delta of their position. I.e. If $1m long and $500k short,\n    // Longs will only get 50% ($500k) long exposure.\n    if (effectiveValueShort > effectiveValueLong) {\n      params.fundingAmount = _calculateFundingAmount(SHORT_TYPE, effectiveValueShort, effectiveValueLong);\n      params.valueChange = priceMovement_e18.mul(int256(effectiveValueLong + uint256(floatPoolLeverage).mul(floatPoolLiquidity)));\n      params.underBalancedSide = LONG_TYPE;\n    } else {\n      params.fundingAmount = _calculateFundingAmount(LONG_TYPE, effectiveValueLong, effectiveValueShort);\n      params.valueChange = priceMovement_e18.mul(int256(effectiveValueShort + uint256(-floatPoolLeverage).mul(floatPoolLiquidity)));\n      params.underBalancedSide = SHORT_TYPE;\n    }\n  }\n\n  /// @notice Reblances the pool given the epoch execution information and can also perform batched actions from the epoch.\n  /// @param epochIndex The index of the epoch to execute\n  /// @param totalEffectiveLiquidityPoolType Effective liquidity of short (0) and long (1) pools\n  /// @param params Compact struct with all parameters needed for rebalance\n  /// @return nextTotalEffectiveLiquidityPoolType Updated short and long liquidities\n  /// @return poolStates Compact struct of pool states after rebalance\n  function _rebalancePoolsAndExecuteBatchedActions(\n    uint32 epochIndex,\n    uint128[2] memory totalEffectiveLiquidityPoolType,\n    int256 floatPoolLeverage,\n    ValueChangeAndFunding memory params\n  ) internal returns (uint128[2] memory nextTotalEffectiveLiquidityPoolType, PoolState[] memory poolStates) {\n    poolStates = new PoolState[](_totalNumberOfPoolTiers);\n    uint8 currentPoolStateIndex;\n\n    // Correctly account for liquidity in long and short by adding the float liquidity to the underbalanced side.\n    totalEffectiveLiquidityPoolType[params.underBalancedSide] += uint128(uint256(pools[PoolType.FLOAT][0].value).mul(floatPoolLeverage.abs()));\n\n    // For every pool (long pools, short pools and float pool)\n    // 1) Adjust poolValue based on price movements and funding (and fees for float pool)\n    // 2) Batch process all new entries and exits in pool\n    for (uint256 poolType = SHORT_TYPE; poolType < POOL_TYPE_UPPER_BOUND; ++poolType) {\n      for (uint256 poolTier = 0; poolTier < _numberOfPoolsOfType[poolType]; ++poolTier) {\n        int256 poolValue = int256(pools[PoolType(poolType)][poolTier].value);\n        PoolFixedConfig memory poolFixedConfig = pools[PoolType(poolType)][poolTier].fixedConfig;\n\n        if (poolType != FLOAT_TYPE) {\n          // To correctly apportion funding owed for the underblananced tiers, we need to remove the float liquidity contribution\n          int256 actualTotalEffectiveLiquidityForPoolType = int256(\n            (uint256(totalEffectiveLiquidityPoolType[poolType]) -\n              (poolType == params.underBalancedSide ? uint256(pools[PoolType.FLOAT][0].value).mul(floatPoolLeverage.abs()) : 0))\n          );\n\n          // Long and short pools both pay funding\n          poolValue +=\n            (((poolValue * poolFixedConfig.leverage * params.valueChange) / int128(totalEffectiveLiquidityPoolType[poolType])) -\n              ((poolValue * poolFixedConfig.leverage * params.fundingAmount[poolType]) / (actualTotalEffectiveLiquidityForPoolType))) /\n            1e18;\n        } else {\n          // Float pool recieves all funding and fees.\n          poolValue +=\n            ((poolValue * floatPoolLeverage * params.valueChange) /\n              (int256(uint256(totalEffectiveLiquidityPoolType[params.underBalancedSide])) * 1e18)) +\n            -params.fundingAmount[SHORT_TYPE] + // funding value is negative for short side (double negative to add it)\n            params.fundingAmount[LONG_TYPE] +\n            int256(feesToDistribute[epochIndex & 1]);\n\n          feesToDistribute[epochIndex & 1] = 0;\n        }\n\n        uint256 tokenSupply = IPoolToken(poolFixedConfig.token).totalSupply();\n        uint256 price = uint256(poolValue).div(tokenSupply);\n\n        // All entries and exits to the pool are processed at latest price based on newly calculated poolValue\n        poolValue += _processAllBatchedEpochActions(epochIndex, PoolType(poolType), poolTier, price, poolFixedConfig.token);\n\n        // We calculate the new total liquidity always excluding the floating tranche.\n        if (poolType != FLOAT_TYPE)\n          nextTotalEffectiveLiquidityPoolType[poolType] += uint128(uint256(poolValue).mul(int256(poolFixedConfig.leverage).abs()));\n\n        pools[PoolType(poolType)][poolTier].value = uint256(poolValue);\n\n        // Token price snapshot for this epoch is used to calculate amount individual token allocation retrospectively for entrants/exits\n        poolToken_priceSnapshot[epochIndex][PoolType(poolType)][poolTier] = price;\n\n        // This structure is purely to emit event info as easily as possible for the indexer.\n        poolStates[currentPoolStateIndex++] = PoolState({\n          poolId: MarketHelpers.packPoolId(PoolType(poolType), uint8(poolTier)),\n          tokenPrice: price,\n          value: poolValue\n        });\n      }\n    }\n  }\n\n  /// @notice System state update function that verifies (instead of trying to find) oracle prices\n  /// @param oracleRoundIdsToExecute The oracle prices that will be the prices for each epoch\n  function updateSystemStateUsingValidatedOracleRoundIds(uint80[] memory oracleRoundIdsToExecute) external checkMarketNotDeprecated {\n    uint32 latestExecutedEpochIndex = epochInfo.latestExecutedEpochIndex;\n    (int256 previousPrice, int256[] memory epochPrices) = oracleManager.validateAndReturnMissedEpochInformation(\n      latestExecutedEpochIndex,\n      epochInfo.latestExecutedOracleRoundId,\n      oracleRoundIdsToExecute\n    );\n\n    uint256 numberOfEpochsToExecute = epochPrices.length;\n\n    uint128[2] memory totalEffectiveLiquidityPoolType = effectiveLiquidityForPoolType;\n\n    for (uint256 i = 0; i < numberOfEpochsToExecute; ) {\n      /* i is incremented later in scope*/\n      (int256 floatPoolLeverage, ValueChangeAndFunding memory rebalanceParams) = _getValueChangeAndFunding(\n        totalEffectiveLiquidityPoolType[LONG_TYPE],\n        totalEffectiveLiquidityPoolType[SHORT_TYPE],\n        // this is the previous execution price, not the previous oracle update price\n        previousPrice,\n        epochPrices[i]\n      );\n\n      previousPrice = epochPrices[i];\n\n      PoolState[] memory poolStates;\n      (totalEffectiveLiquidityPoolType, poolStates) = _rebalancePoolsAndExecuteBatchedActions(\n        latestExecutedEpochIndex + uint32(++i),\n        totalEffectiveLiquidityPoolType,\n        floatPoolLeverage,\n        rebalanceParams\n      );\n\n      emit EpochUpdated(latestExecutedEpochIndex + uint32(i), previousPrice, rebalanceParams.valueChange, rebalanceParams.fundingAmount, poolStates);\n    }\n\n    // Saving the final state of liquidity and info once all epochs have been executed.\n    // In practive, keepers should ensure that the above loop length is only ever 1,\n    // and we are never catching up multiple epochs. This arcitecture is built such that the\n    // the system can gracefully handle missed upkeep fairly.\n    effectiveLiquidityForPoolType = totalEffectiveLiquidityPoolType;\n    epochInfo = EpochInfo({\n      latestExecutedEpochIndex: latestExecutedEpochIndex + uint32(numberOfEpochsToExecute),\n      latestExecutedOracleRoundId: oracleRoundIdsToExecute[oracleRoundIdsToExecute.length - 1]\n    });\n  }\n\n  /*╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Calculates the fees for the mint amount depending on the market\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function _calculateStabilityFees(uint256 amount) internal view returns (uint256 amountFees) {\n    // stability fee is based on effectiveLiquidity added (takes into account leverage)\n    amountFees = (amount * stabilityFee_basisPoints) / (10000);\n  }\n\n  /// @notice Allows users to mint pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @dev We have to check market not deprecated after system state update because that is the function that determines whether the market should be deprecated.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function _mint(\n    uint112 amount,\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) internal {\n    // ASIDE: This check also checks that the poolType is valid - since if it is invalid it will be zero - and no uint can be less than zero\n    if (uint256(poolTier) >= _numberOfPoolsOfType[uint256(poolType)]) revert InvalidPool();\n\n    if (mintingPaused) revert MintingPaused();\n\n    // Due to get amount of payment token calculation we must have amount * 1e18 > poolTokenPriceInPaymentTokens otherwise we get 0\n    // In fact, all the decimals of amount * 1e18 that are less than poolTokenPriceInPaymentTokens get cut off\n    if (amount < 1e18) revert InvalidActionAmount(amount);\n\n    IERC20(paymentToken).safeTransferFrom(msg.sender, liquidityManager, amount);\n\n    uint256 fees = _calculateStabilityFees(uint256(amount).mul(int256(pools[poolType][poolTier].fixedConfig.leverage).abs()));\n    amount -= uint112(fees);\n\n    uint32 currentEpoch = uint32(oracleManager.getCurrentEpochIndex());\n\n    // Actions cannot take place if upkeep has fallen behind and there are already 2 oustanding epochs needing to be executed\n    if (currentEpoch > epochInfo.latestExecutedEpochIndex + 2)\n      revert MarketStale({currentEpoch: currentEpoch, latestExecutedEpoch: epochInfo.latestExecutedEpochIndex});\n\n    // Before minting we ensure user recieves tokens from any already executed mints in previous epochs.\n    // This ensures the userAction_depositPaymentToken[user][poolType][poolTier] struct will be up to date\n    // and correctly handle to new mint.\n    settlePoolUserMints(user, poolType, poolTier);\n\n    UserAction memory userAction = userAction_depositPaymentToken[user][poolType][poolTier];\n\n    /// NOTE: userAction.amount > 0 IFF userAction.correspondingEpoch <= currentEpoch - this check is redundant for safety.\n    if (userAction.amount > 0 && userAction.correspondingEpoch < currentEpoch) {\n      // This case occurs when a user minted in the previous epoch and upkeep has still not yet\n      // occured and therefore this previous order has not been processed.\n      // This is likely to happen if the user mints early on in a new epoch when enough time has not\n      // passed (see MEWT) for the previous epoch to be executed.\n      userAction.nextEpochAmount += amount;\n    } else {\n      userAction.amount += amount;\n      userAction.correspondingEpoch = currentEpoch;\n    }\n\n    // NOTE: `currentEpoch & 1` and `currentEpoch % 2` are equivalent, but the former is more efficient using bitwise operations.\n    // Since there can only ever be oustanding mint and redeem orders in two consecutive epochs (cannot have oustanding orders in 3 epochs etc)\n    // We use an odd even batch scheme to easily batch orders.\n    pools[poolType][poolTier].batchedAmount[currentEpoch & 1].paymentToken_deposit += amount;\n    feesToDistribute[currentEpoch & 1] += fees;\n\n    userAction_depositPaymentToken[user][poolType][poolTier] = userAction;\n\n    emit Deposit(MarketHelpers.packPoolId(poolType, uint8(poolTier)), amount, fees, user, currentEpoch);\n  }\n\n  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintLong(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _mint(amount, msg.sender, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows users to mint short pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintShort(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _mint(amount, msg.sender, PoolType.SHORT, poolTier);\n  }\n\n  /// @notice Allows users to mint float pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintFloatPool(uint112 amount) external {\n    _checkRole(FLOAT_POOL_ROLE, msg.sender);\n    _mint(amount, msg.sender, PoolType.FLOAT, 0); // There is always only one float pool at poolTier index 0\n  }\n\n  /// @notice Allows mint long pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  /// @param user Address of the user.\n  function mintLongFor(\n    uint256 poolTier,\n    uint112 amount,\n    address user\n  ) external override gemCollecting(user) {\n    _mint(amount, user, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows mint short pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  /// @param user Address of the user.\n  function mintShortFor(\n    uint256 poolTier,\n    uint112 amount,\n    address user\n  ) external gemCollecting(user) {\n    _mint(amount, user, PoolType.SHORT, poolTier);\n  }\n\n  /*╔═══════════════════════════╗\n    ║       REDEEM POSITION     ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Allows users to mint pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @dev We have to check market not deprecated after system state update because that is the function that determines whether the market should be deprecated.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function _redeem(\n    uint112 amount,\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) internal checkMarketNotDeprecated {\n    // In this function, amount refers to the amount of poolToken.\n    // In the _mint function amount refers to the amount of paymentToken\n    // This function is very similar to _mint. See _mint for comprehensive commenting\n    if (amount < 1e12) revert InvalidActionAmount(amount);\n\n    uint32 currentEpoch = uint32(oracleManager.getCurrentEpochIndex());\n    if (currentEpoch > epochInfo.latestExecutedEpochIndex + 2)\n      revert MarketStale({currentEpoch: currentEpoch, latestExecutedEpoch: epochInfo.latestExecutedEpochIndex});\n\n    settlePoolUserRedeems(user, poolType, poolTier);\n\n    //slither-disable-next-line unchecked-transfer\n    // If an invalid poolType and poolTier is passed, this will revert.\n    IPoolToken(pools[poolType][poolTier].fixedConfig.token).transferFrom(user, address(this), amount);\n\n    UserAction memory userAction = userAction_redeemPoolToken[user][poolType][poolTier];\n\n    if (userAction.amount > 0 && userAction.correspondingEpoch < currentEpoch) {\n      userAction.nextEpochAmount += amount;\n    } else {\n      userAction.amount += amount;\n      userAction.correspondingEpoch = currentEpoch;\n    }\n\n    // NOTE: `currentEpoch & 1` and `currentEpoch % 2` are equivalent, but the former is more efficient using bitwise operations.\n    pools[poolType][poolTier].batchedAmount[currentEpoch & 1].poolToken_redeem += amount;\n\n    userAction_redeemPoolToken[user][poolType][poolTier] = userAction;\n\n    emit Redeem(MarketHelpers.packPoolId(poolType, uint8(poolTier)), amount, user, currentEpoch);\n  }\n\n  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  function redeemLong(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _redeem(amount, msg.sender, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows users to redeem short pool token assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to redeem pool token assets at next price.\n  function redeemShort(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _redeem(amount, msg.sender, PoolType.SHORT, poolTier);\n  }\n\n  /// @notice Allows users to redeem float pool token assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to redeem pool token assets at next price.\n  function redeemFloatPool(uint112 amount) external {\n    _redeem(amount, msg.sender, PoolType.FLOAT, 0);\n  }\n\n  /*╔═════════════════════╗\n    ║  USER SETTLEMENTS   ║\n    ╚═════════════════════╝*/\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their mints during that epoch to that user.\n  /// @param user Address of the user.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function settlePoolUserMints(\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) public {\n    /*\n      NOTE: please reflect any changes made to this function to the `getUsersConfirmedButNotSettledPoolTokenBalance` function too.\n\n     Users can have mints in two consecutive epochs (with both not yet being executed). In this case we say both there primary,\n     and seconday order slot are full. Once upkeep has been performed on those epochs, this function can be called at a later stage,\n     asynchronusly (generally when a user mints again or uses their tokens), in order to calculate and send the tokens owed to the user\n     based on their mints in the primiary and secondary slot (the secondary slot may not always exist).\n\n     Corresponding epoch refers to the epoch associated with the primary slot action.\n    */\n\n    UserAction memory userAction = userAction_depositPaymentToken[user][poolType][poolTier];\n\n    // Case if the primary order can be executed.\n    if (userAction.correspondingEpoch != 0 && userAction.correspondingEpoch <= epochInfo.latestExecutedEpochIndex) {\n      uint256 poolToken_price = poolToken_priceSnapshot[userAction.correspondingEpoch][poolType][poolTier];\n      uint256 amountPoolTokenToMint = uint256(userAction.amount).div(poolToken_price);\n\n      // If secondary order exists\n      if (userAction.nextEpochAmount > 0) {\n        uint32 secondaryOrderEpoch = userAction.correspondingEpoch + 1;\n\n        // If its possible to also execute the secondary order slot\n        if (secondaryOrderEpoch <= epochInfo.latestExecutedEpochIndex) {\n          // then also execute\n          poolToken_price = poolToken_priceSnapshot[secondaryOrderEpoch][poolType][poolTier];\n          amountPoolTokenToMint += uint256(userAction.nextEpochAmount).div(poolToken_price);\n\n          userAction.amount = 0;\n          userAction.correspondingEpoch = 0;\n        } else {\n          // If secondary order cannot be executed, bump it to the primary slot.\n          userAction.amount = userAction.nextEpochAmount;\n          userAction.correspondingEpoch = secondaryOrderEpoch;\n        }\n        // has to zero as either executed or bumped to primary slot\n        userAction.nextEpochAmount = 0;\n      } else {\n        // If user has no pending mints then simply wipe\n        userAction.amount = 0;\n        userAction.correspondingEpoch = 0;\n      }\n\n      //slither-disable-next-line unchecked-transfer\n      IPoolToken(pools[poolType][poolTier].fixedConfig.token).transfer(user, amountPoolTokenToMint);\n\n      userAction_depositPaymentToken[user][poolType][poolTier] = userAction;\n\n      emit ExecuteEpochSettlementMintUser(\n        MarketHelpers.packPoolId(poolType, uint8(poolTier)),\n        user,\n        epochInfo.latestExecutedEpochIndex,\n        amountPoolTokenToMint\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their redeems during that epoch to that user.\n  /// @param user Address of the user.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function settlePoolUserRedeems(\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) public {\n    // Functions almost identically to settlePoolUserMints. See settlePoolUserMints for comprehensive comments.\n    UserAction memory userAction = userAction_redeemPoolToken[user][poolType][poolTier];\n\n    // Case if the primary order can be executed.\n    if (userAction.amount > 0 && userAction.correspondingEpoch <= epochInfo.latestExecutedEpochIndex) {\n      uint256 poolToken_price = poolToken_priceSnapshot[userAction.correspondingEpoch][poolType][poolTier];\n\n      uint256 amountPaymentTokenToSend = uint256(userAction.amount).mul(poolToken_price);\n\n      if (userAction.nextEpochAmount > 0) {\n        uint32 secondaryOrderEpoch = userAction.correspondingEpoch + 1;\n\n        if (secondaryOrderEpoch <= epochInfo.latestExecutedEpochIndex) {\n          poolToken_price = poolToken_priceSnapshot[secondaryOrderEpoch][poolType][poolTier];\n          amountPaymentTokenToSend += uint256(userAction.nextEpochAmount).mul(poolToken_price);\n\n          userAction.amount = 0;\n          userAction.correspondingEpoch = 0;\n        } else {\n          userAction.amount = userAction.nextEpochAmount;\n          userAction.correspondingEpoch = secondaryOrderEpoch;\n        }\n        // has to zero as either executed or bumped to primary slot\n        userAction.nextEpochAmount = 0;\n      } else {\n        // If user has no pending redeems then simply wipe\n        userAction.amount = 0;\n        userAction.correspondingEpoch = 0;\n      }\n\n      userAction_redeemPoolToken[user][poolType][poolTier] = userAction;\n\n      ILiquidityManager(liquidityManager).transferPaymentTokensToUser(user, amountPaymentTokenToSend);\n\n      emit ExecuteEpochSettlementRedeemUser(\n        MarketHelpers.packPoolId(poolType, uint8(poolTier)),\n        user,\n        epochInfo.latestExecutedEpochIndex,\n        amountPaymentTokenToSend\n      );\n    }\n  }\n\n  /*╔═══════════════════╗\n    ║   BATCH ACTIONS   ║\n    ╚═══════════════════╝*/\n\n  /// @notice Either mints or burns pool token supply.\n  /// @param poolToken Address of the pool token.\n  /// @param changeInPoolTokensTotalSupply Positive indicates amount to be minted and negative indicates amount to be burned.\n  function _handleChangeInPoolTokensTotalSupply(address poolToken, int256 changeInPoolTokensTotalSupply) internal {\n    if (changeInPoolTokensTotalSupply > 0) {\n      IPoolToken(poolToken).mint(address(this), uint256(changeInPoolTokensTotalSupply));\n    } else if (changeInPoolTokensTotalSupply < 0) {\n      IPoolToken(poolToken).burn(uint256(-changeInPoolTokensTotalSupply));\n    }\n  }\n\n  /// @notice For a given pool, updates the value depending on the batched deposits and redeems that took place during the epoch\n  /// @param associatedEpochIndex Index of epoch where the batched actions were performed.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index.\n  /// @param price Price of the pool token.\n  function _processAllBatchedEpochActions(\n    uint256 associatedEpochIndex,\n    PoolType poolType,\n    uint256 poolTier,\n    uint256 price,\n    address poolToken\n  ) internal returns (int256 changeInMarketValue_inPaymentToken) {\n    // QUESTION: is it worth the gas saving this storage pointer - we only use 'pool' twice in this function.\n    Pool storage pool = pools[poolType][poolTier];\n\n    BatchedActions memory batch = pool.batchedAmount[associatedEpochIndex & 1];\n\n    // Only if mints or redeems exist is it necessary to adjust supply and collateral.\n    if (batch.paymentToken_deposit > 0 || batch.poolToken_redeem > 0) {\n      changeInMarketValue_inPaymentToken = int128(batch.paymentToken_deposit) - int256(uint256(batch.poolToken_redeem).mul(price));\n\n      int256 changeInSupply_poolToken = int256(uint256(batch.paymentToken_deposit).div(price)) - int128(batch.poolToken_redeem);\n\n      pool.batchedAmount[associatedEpochIndex & 1] = BatchedActions(0, 0);\n\n      _handleChangeInPoolTokensTotalSupply(poolToken, changeInSupply_poolToken);\n    }\n  }\n\n  /*╔═══════════════════════════╗\n    ║ DEPRECATED MARKET ACTIONS ║\n    ╚═══════════════════════════╝*/\n\n  /*\n  In the case that upkeep contiously fails (could be because of chainlink failing, the chain going offline etc.),\n  which will most likely happen if no chainlink price is recieved within an epoch, therefore no valid price is available\n  to execute and process all oustanding orders and value transfer - The markets gracefully go into a state of deprecation. \n  When this happens, all normal mints and redeems are suspended. It is only possible to burn all poolTokens and redeem collateral. \n  The tokens will no longer change value according any price feed, or pay funding etc, the token price will simply stay constant.\n  This seems the safest way to handle a blackswan event. That being said EPOCH_LENGTH will be set to ensure its highly unlikely\n  price events don't ocur during an epoch.\n  */\n\n  /// @notice Place the market in a state where no more price updates or mints are allowed\n  function _deprecateMarket() internal {\n    ValueChangeAndFunding memory emptyValueChangeAndFunding;\n\n    uint128[2] memory newEffectiveLiquidity = effectiveLiquidityForPoolType;\n\n    // Here we rebalance the ma"
    }
  ]
}