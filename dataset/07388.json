{
  "Title": "[N-06]  NatSpec is incomplete",
  "Content": "\n*There are 7 instances of this issue:*\n\n```solidity\nFile: src/modules/GroupBuy.sol\n\n/// @audit Missing: '@return'\n344       /// @param _poolId ID of the pool\n345       /// @param _bidId ID of the bid in queue\n346       function getBidInQueue(uint256 _poolId, uint256 _bidId)\n347           public\n348           view\n349           returns (\n350               uint256 bidId,\n351               address owner,\n352               uint256 price,\n353:              uint256 quantity\n\n/// @audit Missing: '@return'\n363       /// @notice Gets minimum bid price of queue for given pool\n364       /// @param _poolId ID of the pool\n365:      function getMinPrice(uint256 _poolId) public view returns (uint256) {\n\n/// @audit Missing: '@return'\n369       /// @notice Gets next bidId in queue of given pool\n370       /// @param _poolId ID of the pool\n371:      function getNextBidId(uint256 _poolId) public view returns (uint256) {\n\n/// @audit Missing: '@return'\n375       /// @notice Gets total number of bids in queue for given pool\n376       /// @param _poolId ID of the pool\n377:      function getNumBids(uint256 _poolId) public view returns (uint256) {\n\n/// @audit Missing: '@return'\n382       /// @param _poolId ID of the pool\n383       /// @param _bidId ID of the bid in queue\n384:      function getBidQuantity(uint256 _poolId, uint256 _bidId) public view returns (uint256) {\n\n/// @audit Missing: '@return'\n389       /// @param _poolId ID of the pool\n390       /// @param _owner Address of the owner\n391       function getOwnerToBidIds(uint256 _poolId, address _owner)\n392           public\n393           view\n394:          returns (uint256[] memory)\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L344-L353\n\n```solidity\nFile: src/punks/protoforms/PunksMarketBuyer.sol\n\n/// @audit Missing: '@return'\n44        /// @param _order Bytes value of the necessary order parameters\n45        /// return vault Address of the deployed vault\n46:       function execute(bytes memory _order) external payable returns (address vault) {\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/punks/protoforms/PunksMarketBuyer.sol#L44-L46\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-12-tessera",
  "Code": [
    {
      "filename": "src/modules/GroupBuy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ERC165Checker} from \"openzeppelin-contracts/utils/introspection/ERC165Checker.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {MerkleProof} from \"openzeppelin-contracts/utils/cryptography/MerkleProof.sol\";\nimport {MinPriorityQueue, Bid} from \"../lib/MinPriorityQueue.sol\";\nimport {Minter} from \"../modules/Minter.sol\";\n\nimport {ICryptoPunk} from \"../punks/interfaces/ICryptoPunk.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IGroupBuy, PoolInfo} from \"../interfaces/IGroupBuy.sol\";\nimport {IMarketBuyer} from \"../interfaces/IMarketBuyer.sol\";\n\n/// @title GroupBuy\n/// @author Tessera\n/// @notice Module contract for pooling group funds to purchase and vault NFTs\n/// - The bidding mechanism used here is a slightly modified implementation of the\n///   Smart Batched Auction: https://github.com/FrankieIsLost/smart-batched-auction\ncontract GroupBuy is IGroupBuy, MerkleBase, Minter {\n    /// @dev Use MinPriorityQueue library for Queue types\n    using MinPriorityQueue for MinPriorityQueue.Queue;\n    /// @dev Interface ID for ERC-721 tokens\n    bytes4 constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /// @notice Current pool ID\n    uint256 public currentId;\n    /// @notice Mapping of pool ID to vault address\n    mapping(uint256 => address) public poolToVault;\n    /// @notice Mapping of pool ID to PoolInfo struct\n    mapping(uint256 => PoolInfo) public poolInfo;\n    /// @notice Mapping of pool ID to the priority queue of valid bids\n    mapping(uint256 => MinPriorityQueue.Queue) public bidPriorityQueues;\n    /// @notice Mapping of pool ID to amount of Raes currently filled for the pool\n    mapping(uint256 => uint256) public filledQuantities;\n    /// @notice Mapping of pool ID to minimum ether price of any bid\n    mapping(uint256 => uint256) public minBidPrices;\n    /// @notice Mapping of pool ID to minimum reserve prices\n    mapping(uint256 => uint256) public minReservePrices;\n    /// @notice Mapping of pool ID to total amount of ether contributed\n    mapping(uint256 => uint256) public totalContributions;\n    /// @notice Mapping of pool ID to user address to total amount of ether contributed\n    mapping(uint256 => mapping(address => uint256)) public userContributions;\n    /// @notice Mapping of user address to pending balance available for withdrawal\n    mapping(address => uint256) public pendingBalances;\n\n    /// @dev Initializes supply contract and minimum bid price\n    constructor(address _supply) Minter(_supply) {}\n\n    /// @notice Creates a new pool\n    /// @param _nftContract Address of the NFT contract\n    /// @param _tokenIds List of tokenIds permitted to be purchased\n    /// @param _initialPrice Initial price of the NFT(s)\n    /// @param _totalSupply Total amount of Raes to be minted\n    /// @param _duration Time period of pool existing before termination\n    /// @param _quantity Amount of Raes being bid on\n    /// @param _raePrice Ether price per Rae\n    function createPool(\n        address _nftContract,\n        uint256[] calldata _tokenIds,\n        uint256 _initialPrice,\n        uint48 _totalSupply,\n        uint40 _duration,\n        uint256 _quantity,\n        uint256 _raePrice\n    ) external payable {\n        // Reverts if list of tokenIds is empty\n        uint256 length = _tokenIds.length;\n        if (length == 0) revert InsufficientTokenIds();\n\n        // Generates merkle root based on list size of tokenIds\n        bytes32 merkleRoot = (length == 1) ? bytes32(_tokenIds[0]) : _generateRoot(_tokenIds);\n\n        // Sets mapping of poolId to PoolInfo\n        poolInfo[++currentId] = PoolInfo(\n            _nftContract,\n            _totalSupply,\n            uint40(block.timestamp) + _duration,\n            false,\n            merkleRoot\n        );\n\n        // Calculates minimum bid price based on initial price of NFT and desired total supply\n        minBidPrices[currentId] = _initialPrice / _totalSupply;\n\n        // Initializes first bid in queue\n        bidPriorityQueues[currentId].initialize();\n\n        // Emits event for creating new pool\n        emit Create(currentId, _nftContract, _tokenIds, msg.sender, _totalSupply, _duration);\n\n        // Contributes ether into new pool\n        contribute(currentId, _quantity, _raePrice);\n    }\n\n    /// @notice Contributes to an existing pool\n    /// @param _poolId ID of the pool\n    /// @param _quantity Amount of Raes being bid on\n    /// @param _price Ether price per Rae\n    function contribute(\n        uint256 _poolId,\n        uint256 _quantity,\n        uint256 _price\n    ) public payable {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if NFT has already been purchased OR termination period has passed\n        (, uint48 totalSupply, , , ) = _verifyUnsuccessfulState(_poolId);\n        // Reverts if ether contribution amount per Rae is less than minimum bid price per Rae\n        if (msg.value < _quantity * minBidPrices[_poolId] || _quantity == 0)\n            revert InvalidContribution();\n        // Reverts if ether payment amount is not equal to total amount being contributed\n        if (msg.value != _quantity * _price) revert InvalidPayment();\n\n        // Updates user and pool contribution amounts\n        userContributions[_poolId][msg.sender] += msg.value;\n        totalContributions[_poolId] += msg.value;\n\n        // Calculates remaining supply based on total possible supply and current filled quantity amount\n        uint256 remainingSupply = totalSupply - filledQuantities[_poolId];\n        // Calculates quantity amount being filled at any price\n        uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity;\n\n        // Checks if quantity amount being filled is greater than 0\n        if (fillAtAnyPriceQuantity > 0) {\n            // Inserts bid into end of queue\n            bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity);\n            // Increments total amount of filled quantities\n            filledQuantities[_poolId] += fillAtAnyPriceQuantity;\n        }\n\n        // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount\n        uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity;\n        // Processes bids in queue to recalculate unfilled quantity amount\n        unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price);\n\n        // Recalculates filled quantity amount based on updated unfilled quantity amount\n        uint256 filledQuantity = _quantity - unfilledQuantity;\n        // Updates minimum reserve price if filled quantity amount is greater than 0\n        if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId);\n\n        // Emits event for contributing ether to pool based on desired quantity amount and price per Rae\n        emit Contribute(\n            _poolId,\n            msg.sender,\n            msg.value,\n            _quantity,\n            _price,\n            minReservePrices[_poolId]\n        );\n    }\n\n    /// @notice Purchases NFT once contribution amount has been met\n    /// @param _poolId ID of the pool\n    /// @param _market Address of the market buyer contract\n    /// @param _nftContract Address of the NFT contract\n    /// @param _tokenId ID of the token\n    /// @param _price Total ether price of the listed NFT\n    /// @param _purchaseOrder Bytes data of the purchase order parameters\n    /// @param _purchaseProof Merkle proof of the tokenId in the list of permitted tokenIds\n    function purchase(\n        uint256 _poolId,\n        address _market,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _price,\n        bytes memory _purchaseOrder,\n        bytes32[] memory _purchaseProof\n    ) external {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if NFT has already been purchased OR termination period has passed\n        (\n            address nftContract,\n            uint48 totalSupply,\n            ,\n            ,\n            bytes32 merkleRoot\n        ) = _verifyUnsuccessfulState(_poolId);\n        // Reverts if NFT contract is not equalt to NFT contract set on pool creation\n        if (_nftContract != nftContract) revert InvalidContract();\n        // Reverts if price is greater than total contribution amount of pool\n        if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])\n            revert InvalidPurchase();\n\n        // Checks merkle proof based on size of array\n        if (_purchaseProof.length == 0) {\n            // Hashes tokenId to verify merkle root if proof is empty\n            if (bytes32(_tokenId) != merkleRoot) revert InvalidProof();\n        } else {\n            // Verifies merkle proof based on position of leaf node in tree\n            bytes32 leaf = keccak256(abi.encode(_tokenId));\n            if (!MerkleProof.verify(_purchaseProof, merkleRoot, leaf)) revert InvalidProof();\n        }\n\n        // Decrements actual price from total pool contributions\n        totalContributions[_poolId] -= _price;\n\n        // Encodes NFT contract and tokenId into purchase order\n        bytes memory nftData = abi.encode(_nftContract, _tokenId);\n        // Encodes arbitrary amount of data based on market buyer to execute purchase\n        _purchaseOrder = abi.encodePacked(nftData, _purchaseOrder);\n\n        // Executes purchase order transaction through market buyer contract and deploys new vault\n        address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder);\n\n        // Checks if NFT contract supports ERC165 and interface ID of ERC721 tokens\n        if (ERC165Checker.supportsInterface(_nftContract, _INTERFACE_ID_ERC721)) {\n            // Verifes vault is owner of ERC-721 token\n            if (IERC721(_nftContract).ownerOf(_tokenId) != vault) revert UnsuccessfulPurchase();\n        } else {\n            // Verifies vault is owner of CryptoPunk token\n            if (ICryptoPunk(_nftContract).punkIndexToAddress(_tokenId) != vault)\n                revert UnsuccessfulPurchase();\n        }\n\n        // Stores mapping value of poolId to newly deployed vault\n        poolToVault[_poolId] = vault;\n        // Sets pool state to successful\n        poolInfo[_poolId].success = true;\n\n        // Emits event for purchasing NFT at given price\n        emit Purchase(_poolId, vault, _nftContract, _tokenId, _price);\n    }\n\n    /// @notice Mints Raes based on contribution amount and refunds remaining ether\n    /// @param _poolId ID of the pool\n    /// @param _mintProof Merkle proof for executing minting of Rae tokens\n    function claim(uint256 _poolId, bytes32[] calldata _mintProof) external {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if purchase has not been made AND termination period has not passed\n        (, , , bool success, ) = _verifySuccessfulState(_poolId);\n        // Reverts if contribution balance of user is insufficient\n        uint256 contribution = userContributions[_poolId][msg.sender];\n        if (contribution == 0) revert InsufficientBalance();\n\n        // Deletes user contribution from storage\n        delete userContributions[_poolId][msg.sender];\n\n        // Set up scoped values for iteration\n        uint256 totalQty;\n        uint256 reservePrice = minReservePrices[_poolId];\n        uint256[] memory bidIds = getOwnerToBidIds(_poolId, msg.sender);\n        uint256 length = bidIds.length;\n\n        // Iterates through all active bidIds of the caller\n        if (success) {\n            for (uint256 i; i < length; ++i) {\n                // Gets bid quantity from storage\n                Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[bidIds[i]];\n                uint256 quantity = bid.quantity;\n                // Resets bid quantity amount\n                bid.quantity = 0;\n                // Increments total quantity of Raes to be minted\n                totalQty += quantity;\n                // Decrements quantity price from total user contribution balance\n                contribution -= quantity * reservePrice;\n            }\n\n            // Mints total quantity of Raes to caller\n            _mintRaes(poolToVault[_poolId], msg.sender, totalQty, _mintProof);\n        }\n\n        // Transfers remaining contribution balance back to caller\n        payable(msg.sender).call{value: contribution}(\"\");\n\n        // Withdraws pending balance of caller if available\n        if (pendingBalances[msg.sender] > 0) withdrawBalance();\n\n        // Emits event for claiming tokens and receiving ether refund\n        emit Claim(_poolId, msg.sender, totalQty, contribution);\n    }\n\n    function withdrawBalance() public {\n        // Reverts if caller balance is insufficient\n        uint256 balance = pendingBalances[msg.sender];\n        if (balance == 0) revert InsufficientBalance();\n\n        // Resets pending balance amount\n        delete pendingBalances[msg.sender];\n\n        // Transfers pending ether balance to caller\n        payable(msg.sender).call{value: balance}(\"\");\n    }\n\n    /// @notice Attempts to accept bid for specifc quantity and price\n    /// @param _poolId ID of the pool\n    /// @param _quantity Amount of Raes being filled\n    /// @param _price Price of ether per Rae token\n    /// @return quantity Unfilled quantity amount\n    function processBidsInQueue(\n        uint256 _poolId,\n        uint256 _quantity,\n        uint256 _price\n    ) private returns (uint256 quantity) {\n        quantity = _quantity;\n        while (quantity > 0) {\n            // Retrieves lowest bid in queue\n            Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();\n            // Breaks out of while loop if given price is less than than lowest bid price\n            if (_price < lowestBid.price) {\n                break;\n            }\n\n            uint256 lowestBidQuantity = lowestBid.quantity;\n            // Checks if lowest bid quantity amount is greater than given quantity amount\n            if (lowestBidQuantity > quantity) {\n                // Decrements given quantity amount from lowest bid quantity\n                lowestBid.quantity -= quantity;\n                // Calculates partial contribution of bid by quantity amount and price\n                uint256 contribution = quantity * lowestBid.price;\n\n                // Decrements partial contribution amount of lowest bid from total and user contributions\n                totalContributions[_poolId] -= contribution;\n                userContributions[_poolId][lowestBid.owner] -= contribution;\n                // Increments pending balance of lowest bid owner\n                pendingBalances[lowestBid.owner] += contribution;\n\n                // Inserts new bid with given quantity amount into proper position of queue\n                bidPriorityQueues[_poolId].insert(msg.sender, _price, quantity);\n                // Resets quantity amount to exit while loop\n                quantity = 0;\n            } else {\n                // Calculates total contribution of bid by quantity amount and price\n                uint256 contribution = lowestBid.quantity * lowestBid.price;\n\n                // Decrements full contribution amount of lowest bid from total and user contributions\n                totalContributions[_poolId] -= contribution;\n                userContributions[_poolId][lowestBid.owner] -= contribution;\n                // Increments pending balance of lowest bid owner\n                pendingBalances[lowestBid.owner] += contribution;\n\n                // Removes lowest bid in queue\n                bidPriorityQueues[_poolId].delMin();\n                // Inserts new bid with lowest bid quantity amount into proper position of queue\n                bidPriorityQueues[_poolId].insert(msg.sender, _price, lowestBidQuantity);\n                // Decrements lowest bid quantity from total quantity amount\n                quantity -= lowestBidQuantity;\n            }\n        }\n    }\n\n    /// @notice Gets bid values in queue of given pool\n    /// @param _poolId ID of the pool\n    /// @param _bidId ID of the bid in queue\n    function getBidInQueue(uint256 _poolId, uint256 _bidId)\n        public\n        view\n        returns (\n            uint256 bidId,\n            address owner,\n            uint256 price,\n            uint256 quantity\n        )\n    {\n        Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[_bidId];\n        bidId = bid.bidId;\n        owner = bid.owner;\n        price = bid.price;\n        quantity = bid.quantity;\n    }\n\n    /// @notice Gets minimum bid price of queue for given pool\n    /// @param _poolId ID of the pool\n    function getMinPrice(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].getMin().price;\n    }\n\n    /// @notice Gets next bidId in queue of given pool\n    /// @param _poolId ID of the pool\n    function getNextBidId(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].nextBidId;\n    }\n\n    /// @notice Gets total number of bids in queue for given pool\n    /// @param _poolId ID of the pool\n    function getNumBids(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].numBids;\n    }\n\n    /// @notice Gets quantity of Raes for bid of given pool\n    /// @param _poolId ID of the pool\n    /// @param _bidId ID of the bid in queue\n    function getBidQuantity(uint256 _poolId, uint256 _bidId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].bidIdToBidMap[_bidId].quantity;\n    }\n\n    /// @notice Gets list of bidIds for address of given pool\n    /// @param _poolId ID of the pool\n    /// @param _owner Address of the owner\n    function getOwnerToBidIds(uint256 _poolId, address _owner)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return bidPriorityQueues[_poolId].ownerToBidIds[_owner];\n    }\n\n    /// @notice Logs entire queue of given pool\n    /// @dev Must include console log to debug\n    /// @param _poolId ID of the pool\n    function printQueue(uint256 _poolId) public view {\n        uint256 counter;\n        uint256 index = 1;\n        MinPriorityQueue.Queue storage queue = bidPriorityQueues[_poolId];\n        uint256 numBids = queue.numBids;\n        while (counter < numBids) {\n            Bid memory bid = queue.bidIdToBidMap[index];\n            if (bid.bidId == 0) {\n                ++index;\n                continue;\n            }\n            ++index;\n            ++counter;\n        }\n    }\n\n    /// @dev Generates merkle root for list of tokenIds\n    function _generateRoot(uint256[] calldata _tokenIds)\n        internal\n        pure\n        returns (bytes32 merkleRoot)\n    {\n        // Creates empty leaf nodes array based on size of tokenIds\n        uint256 length = _tokenIds.length;\n        bytes32[] memory leaves = new bytes32[](length);\n        unchecked {\n            for (uint256 i; i < length; ++i) {\n                // Hashes each tokenId into leaf node and set at index position of array\n                leaves[i] = keccak256(abi.encode(_tokenIds[i]));\n            }\n        }\n        // Generates merkle root from given leaf nodes\n        merkleRoot = getRoot(leaves);\n    }\n\n    /// @dev Reverts if pool ID is not valid\n    function _verifyPool(uint256 _poolId) internal view {\n        if (_poolId == 0 || _poolId > currentId) revert InvalidPool();\n    }\n\n    // Reverts if NFT has already been purchased OR termination period has passed\n    function _verifyUnsuccessfulState(uint256 _poolId)\n        internal\n        view\n        returns (\n            address,\n            uint48,\n            uint40,\n            bool,\n            bytes32\n        )\n    {\n        PoolInfo memory pool = poolInfo[_poolId];\n        if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();\n        return (\n            pool.nftContract,\n            pool.totalSupply,\n            pool.terminationPeriod,\n            pool.success,\n            pool.merkleRoot\n        );\n    }\n\n    // Reverts if NFT has not been purchased AND termination period has not passed\n    function _verifySuccessfulState(uint256 _poolId)\n        internal\n        view\n        returns (\n            address,\n            uint48,\n            uint40,\n            bool,\n            bytes32\n        )\n    {\n        PoolInfo memory pool = poolInfo[_poolId];\n        if (!pool.success && block.timestamp < pool.terminationPeriod) revert InvalidState();\n        return (\n            pool.nftContract,\n            pool.totalSupply,\n            pool.terminationPeriod,\n            pool.success,\n            pool.merkleRoot\n        );\n    }\n}"
    },
    {
      "filename": "src/punks/protoforms/PunksMarketBuyer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Protoform} from \"../../protoforms/Protoform.sol\";\n\nimport {ICryptoPunk} from \"../interfaces/ICryptoPunk.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IPunksMarketBuyer} from \"../interfaces/IPunksMarketBuyer.sol\";\nimport {IOptimisticListingPunks} from \"../interfaces/IOptimisticListingPunks.sol\";\nimport {IVaultRegistry} from \"../../interfaces/IVaultRegistry.sol\";\nimport {IWrappedPunk} from \"../interfaces/IWrappedPunk.sol\";\n\n/// @title PunksMarketBuyer\n/// @author Tessera\n/// @notice Protoform contract for executing CryptoPunk purchase orders and deploying vaults\ncontract PunksMarketBuyer is IPunksMarketBuyer, Protoform {\n    /// @notice Address of the VaultRegistry\n    address public immutable registry;\n    /// @notice Address of the WrappedPunk contract\n    address public immutable wrapper;\n    /// @notice Address of the WrappedPunk proxy contract\n    address public immutable proxy;\n    /// @notice Address of the OptimisticListingPunks module contract\n    address public immutable listing;\n\n    /// @dev Initializes contracts and registers wrapper proxy\n    constructor(\n        address _registry,\n        address _wrapper,\n        address _listing\n    ) {\n        registry = _registry;\n        wrapper = _wrapper;\n        listing = _listing;\n\n        IWrappedPunk(wrapper).registerProxy();\n        proxy = IWrappedPunk(wrapper).proxyInfo(address(this));\n    }\n\n    /// @dev Fallback for receiving either when calldata is empty\n    receive() external payable {}\n\n    /// @notice Executes an arbitrary purchase order for a CryptoPunk\n    /// @param _order Bytes value of the necessary order parameters\n    /// return vault Address of the deployed vault\n    function execute(bytes memory _order) external payable returns (address vault) {\n        // Decodes punks contract and tokenId from purchase order data\n        (address punks, uint256 tokenId) = abi.decode(_order, (address, uint256));\n\n        // Purchases punk from CryptoPunksMarket contract\n        ICryptoPunk(payable(punks)).buyPunk{value: msg.value}(tokenId);\n\n        // Transfers punk to proxy\n        ICryptoPunk(punks).transferPunk(proxy, tokenId);\n\n        // Mints wrapped punk\n        IWrappedPunk(wrapper).mint(tokenId);\n\n        // Deploys new vault with set permissions\n        bytes32[] memory unwrapProof;\n        (vault, unwrapProof) = _deployVault(tokenId);\n\n        // Transfers wrapped punk from this contract to vault\n        IERC721(wrapper).safeTransferFrom(address(this), vault, tokenId);\n\n        // Registers vault with punk on OptimisticListingPunks module\n        IOptimisticListingPunks(listing).register(vault, tokenId, unwrapProof);\n    }\n\n    /// @dev Deploys new vault with set permissions\n    function _deployVault(uint256 _punkId)\n        internal\n        returns (address vault, bytes32[] memory unwrapProof)\n    {\n        // Builds list of modules to activate on the vault\n        address[] memory modules = new address[](2);\n        modules[0] = msg.sender;\n        modules[1] = listing;\n\n        // Generates merkle tree and root from list of modules\n        bytes32[] memory leafNodes = generateMerkleTree(modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n\n        // Generates merkle proof of leaf node at index 2 for unwrapping punk\n        unwrapProof = getProof(leafNodes, 2);\n\n        // Creates new vault with predetermined modules\n        vault = IVaultRegistry(registry).create(merkleRoot);\n\n        // Emits event for modules activated on the vault\n        emit ActiveModules(vault, modules);\n    }\n}"
    }
  ]
}