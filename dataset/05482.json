{
  "Title": "[H-03] The price of rsETH could be manipulated by the first staker",
  "Content": "\n<https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L95-L110><br>\n<https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTOracle.sol#L52-L79>\n\nThe first staker can potentially manipulate the price of rsETH through a donation attack, causing subsequent stakers to receive no rsETH after depositing. The first staker can exploit this method to siphon funds from other users.\n\n### Proof of Concept\n\nThe mining amount of rsETH is calculated in function `getRsETHAmountToMint` which directly utilizes the total value of the asset divided by the price of a single rsETH.\n\n```solidity\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n```\n\nSubsequently, the price of rsETH is related to its totalSupply and the total value of deposited assets.\n\n```solidity\n    function getRSETHPrice() external view returns (uint256 rsETHPrice) {\n        address rsETHTokenAddress = lrtConfig.rsETH();\n        uint256 rsEthSupply = IRSETH(rsETHTokenAddress).totalSupply();\n\n        if (rsEthSupply == 0) {\n            return 1 ether;\n        }\n\n        uint256 totalETHInPool;\n        address lrtDepositPoolAddr = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        address[] memory supportedAssets = lrtConfig.getSupportedAssetList();\n        uint256 supportedAssetCount = supportedAssets.length;\n\n        for (uint16 asset_idx; asset_idx < supportedAssetCount;) {\n            address asset = supportedAssets[asset_idx];\n            uint256 assetER = getAssetPrice(asset);\n\n            uint256 totalAssetAmt = ILRTDepositPool(lrtDepositPoolAddr).getTotalAssetDeposits(asset);\n            totalETHInPool += totalAssetAmt * assetER;\n\n            unchecked {\n                ++asset_idx;\n            }\n        }\n//@audit the price of rsETH is calculated based on the asset and totalSupply\n        return totalETHInPool / rsEthSupply;\n    }\n```\n\nThe total value of deposited assets comprises three parts: the assets in `LRTDepositPool`, the assets in `NodeDelagator`, and the assets in the eigenlayer. Anyone can directly contribute asset tokens to `LRTDepositPool` or `NodeDelegator` to augment the total value of deposited assets.\n\n```solidity\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\n\n### Case\n\nTherefore, the price of rsETH is susceptible to manipulation by the first staker, considering the following scenario:\n\n- Alice is the first staker and she deposits 1 USDC (the price of USDC is set to \\$1), she will get 1 wei rsETH, and the totalSupply of rsETH is 1 wei. \n\nHere is the test, add it to `test/LRTDepositPoolTest.t.sol` and run with `forge test --match-test test_ControlPrice -vv`.\n\n```diff\ndiff --git a/test/LRTDepositPoolTest.t.sol b/test/LRTDepositPoolTest.t.sol\nindex 40abc93..63349c2 100644\n--- a/test/LRTDepositPoolTest.t.sol\n+++ b/test/LRTDepositPoolTest.t.sol\n@@ -9,10 +9,11 @@ import { ILRTDepositPool } from \"src/interfaces/ILRTDepositPool.sol\";\n\n import { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n import { ProxyAdmin } from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n+import \"forge-std/console.sol\";\n\n contract LRTOracleMock {\n     function getAssetPrice(address) external pure returns (uint256) {\n-        return 1e18;\n+        return 1;\n     }\n\n     function getRSETHPrice() external pure returns (uint256) {\n@@ -109,6 +110,23 @@ contract LRTDepositPoolDepositAsset is LRTDepositPoolTest {\n         lrtDepositPool.depositAsset(rETHAddress, 2 ether);\n     }\n\n+    function test_ControlPrice() external {\n+        vm.startPrank(alice);\n+\n+        // alice balance of rsETH before deposit\n+        uint256 aliceBalanceBefore = rseth.balanceOf(address(alice));\n+\n+        rETH.approve(address(lrtDepositPool), 1 ether);\n+        lrtDepositPool.depositAsset(rETHAddress, 1 ether);\n+\n+        // alice balance of rsETH after deposit\n+        uint256 aliceBalanceAfter = rseth.balanceOf(address(alice));\n+        vm.stopPrank();\n+\n+        console.log(\" rsETH of Alice: \", aliceBalanceAfter - aliceBalanceBefore);\n+\n+    }\n+\n     function test_DepositAsset() external {\n         vm.startPrank(alice);\n```\n\n*   Alice donates 10000 USDC to the `LRTDepositPool` to inflate the price of rsETH. Now the price of rsETH is: (10000 + 1)ether / 1 wei = 10001 ether\n\n*   Any subsequent staker who deposits assets worth less than 10001 USDC will not receive any rsETH, and they won't be able to withdraw the deposited assets either. Alice can directly siphon off these funds.\n\nFor example, if Bob deposit 10000 USDC, then the `rsethAmountToMint` is `(10000 ether * 1) / (10001)ether = 0`\n\n    rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n\nMoreover, there is no check on the actual amount of rsETH received by the user, and the execution continues even if this amount is zero.\n\n        function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {\n            (rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);\n\n            address rsethToken = lrtConfig.rsETH();\n            // mint rseth for user\n            //@audit sender could receive 0 token\n            IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n        }\n\n### Recommended Mitigation Steps\n\nIt is recommended to pre-mint some rsETH tokens to prevent price manipulation or ensure that the `rsethAmountToMint` is greater than zero.\n\n**[gus (Kelp) disagreed with severity and commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/42#issuecomment-1825350085):**\n > We agree this is an issue. We also agree that it should be of a MEDIUM severity as it is an edge case that happens on the first protocol interaction.\n\n**[manoj9april (Kelp) confirmed](https://github.com/code-423n4/2023-11-kelp-findings/issues/42#issuecomment-1825451322)**\n\n**[0xDjango (judge) commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/42#issuecomment-1836453373):**\n > Judging as HIGH. While it is an edge case, the potential loss of funds is present. Vault donation attacks have been judged as high in the majority of C4 audits where no safeguards are implemented.\n\n**[manoj9april (Kelp) commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/42#issuecomment-1837395661):**\n > Initial minting is a way of mitigating this issue. And this mitigation could be done after deployment. Hence no safeguard were added in contract. Hence request to decrease to medium.\n\n**[0xDjango (judge) commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/42#issuecomment-1838882957):**\n > > *Initial minting is a way of mitigating this issue. And this mitigation could be done after deployment. Hence no safeguard were added in contract. Hence request to decrease to medium.*\n> \n> Based on the implementation, this issue will remain HIGH. Funds are at risk until Kelp takes subsequent action to mitigate.\n\n**[gus (Kelp) confirmed and commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/62#issuecomment-1850480282):**\n >We disagree with the severity of this issue. Every protocol has to setup the contracts first before publicizing that contracts are ready for public usage. We take measures to ensure the exchange rate is closer to 1 before users interact with contracts.\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-11-kelp",
  "Code": [
    {
      "filename": "src/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorCount;\n\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorCount = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount staked in eigen layer through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    function depositAsset(\n        address asset,\n        uint256 depositAmount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        if (depositAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n            revert TokenTransferFailed();\n        }\n\n        // interactions\n        uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);\n\n        emit AssetDeposit(asset, depositAmount, rsethAmountMinted);\n    }\n\n    /// @dev private function to mint rseth. It calculates rseth amount to mint based on asset amount and asset exchange\n    /// rates from oracle\n    /// @param _asset Asset address\n    /// @param _amount Asset amount to mint rseth\n    /// @return rsethAmountToMint Amount of rseth minted\n    function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {\n        (rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);\n\n        address rsethToken = lrtConfig.rsETH();\n        // mint rseth for user\n        IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n    }\n\n    /// @notice add new node delegator contract addresses\n    /// @dev only callable by LRT manager\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContracts) external onlyLRTAdmin {\n        uint256 length = nodeDelegatorContracts.length;\n        if (nodeDelegatorQueue.length + length > maxNodeDelegatorCount) {\n            revert MaximumNodeDelegatorCountReached();\n        }\n\n        for (uint256 i; i < length;) {\n            UtilLib.checkNonZeroAddress(nodeDelegatorContracts[i]);\n            nodeDelegatorQueue.push(nodeDelegatorContracts[i]);\n            emit NodeDelegatorAddedinQueue(nodeDelegatorContracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice transfers asset lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param asset Asset address\n    /// @param amount Asset amount to transfer\n    function transferAssetToNodeDelegator(\n        uint256 ndcIndex,\n        address asset,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice update max node delegator count\n    /// @dev only callable by LRT admin\n    /// @param maxNodeDelegatorCount_ Maximum count of node delegator\n    function updateMaxNodeDelegatorCount(uint256 maxNodeDelegatorCount_) external onlyLRTAdmin {\n        maxNodeDelegatorCount = maxNodeDelegatorCount_;\n        emit MaxNodeDelegatorCountUpdated(maxNodeDelegatorCount);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/LRTOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { IPriceFetcher } from \"./interfaces/IPriceFetcher.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/// @title LRTOracle Contract\n/// @notice oracle contract that calculates the exchange rate of assets\ncontract LRTOracle is ILRTOracle, LRTConfigRoleChecker, PausableUpgradeable {\n    mapping(address asset => address priceOracle) public override assetPriceOracle;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides Asset/ETH exchange rate\n    /// @dev reads from priceFetcher interface which may fetch price from any supported oracle\n    /// @param asset the asset for which exchange rate is required\n    /// @return assetPrice exchange rate of asset\n    function getAssetPrice(address asset) public view onlySupportedAsset(asset) returns (uint256) {\n        return IPriceFetcher(assetPriceOracle[asset]).getAssetPrice(asset);\n    }\n\n    /// @notice Provides RSETH/ETH exchange rate\n    /// @dev calculates based on stakedAsset value received from eigen layer\n    /// @return rsETHPrice exchange rate of RSETH\n    function getRSETHPrice() external view returns (uint256 rsETHPrice) {\n        address rsETHTokenAddress = lrtConfig.rsETH();\n        uint256 rsEthSupply = IRSETH(rsETHTokenAddress).totalSupply();\n\n        if (rsEthSupply == 0) {\n            return 1 ether;\n        }\n\n        uint256 totalETHInPool;\n        address lrtDepositPoolAddr = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        address[] memory supportedAssets = lrtConfig.getSupportedAssetList();\n        uint256 supportedAssetCount = supportedAssets.length;\n\n        for (uint16 asset_idx; asset_idx < supportedAssetCount;) {\n            address asset = supportedAssets[asset_idx];\n            uint256 assetER = getAssetPrice(asset);\n\n            uint256 totalAssetAmt = ILRTDepositPool(lrtDepositPoolAddr).getTotalAssetDeposits(asset);\n            totalETHInPool += totalAssetAmt * assetER;\n\n            unchecked {\n                ++asset_idx;\n            }\n        }\n\n        return totalETHInPool / rsEthSupply;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev add/update the price oracle of any supported asset\n    /// @dev only LRTManager is allowed\n    /// @param asset asset address for which oracle price needs to be added/updated\n    function updatePriceOracleFor(\n        address asset,\n        address priceOracle\n    )\n        external\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        UtilLib.checkNonZeroAddress(priceOracle);\n        assetPriceOracle[asset] = priceOracle;\n        emit AssetPriceOracleUpdate(asset, priceOracle);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    }
  ]
}