{
  "Title": "[G-01] Redundant state variable getters",
  "Content": "\nGetters for public state variables are automatically generated by the solidity compiler so there is no need to code them manually as this increases deployment cost.\n\n*There are 3 instances of this issue:*\n\n1. Make `authorizedAddresses` mapping variable `private` or `internal` since a getter function was defined for it.\n\n    https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/AddressProvider.sol#L112\n\n```solidity\nfile: contracts/src/core/AddressProvider.sol\n\n35:    mapping(bytes32 => address) public authorizedAddresses;  //@audit generates a redundant getter function\n.\n.\n.\n112:    function getAuthorizedAddress(bytes32 _key) external view returns (address) {\n113:        return authorizedAddresses[_key];\n114:    }\n```\n\nThe solidity compiler would automatically create a getter function for the `authorizedAddresses` mapping above since it is declared as a `public` variable. However, a getter function `getAuthorizedAddress()` was also declared in the contract for the same variable; thereby, making two getter functions for the same variable in the contract. We could rectify this issue by making the `authorizedAddresses` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:\n\n```diff\ndiff --git a/contracts/src/core/AddressProvider.sol b/contracts/src/core/AddressProvider.sol\nindex 5ec51f9..7d3a9d7 100644\n--- a/contracts/src/core/AddressProvider.sol\n+++ b/contracts/src/core/AddressProvider.sol\n@@ -32,7 +32,7 @@ contract AddressProvider {\n      * @notice keccak256 hash of authorizedAddress keys mapped to their addresses\n      * @dev authorizedAddresses are updatable by governance\n      */\n-    mapping(bytes32 => address) public authorizedAddresses;\n+    mapping(bytes32 => address) internal authorizedAddresses;\n```\n\n2. Make the `registries` mapping variable `private` or `internal` since a getter function was defined for it.\n\n    https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/AddressProvider.sol#L121\n\n```solidity\nfile: contracts/src/core/AddressProvider.sol\n\n41:     mapping(bytes32 => address) public registries;  //@audit generates a redundant getter function\n.\n.\n.\n121:    function getRegistry(bytes32 _key) external view returns (address) {\n122:        return registries[_key];\n123:    }\n```\n\nThe solidity compiler would automatically create a getter function for the `registries` mapping above since it is declared as a `public` variable. However, a getter function `getRegistry()` was also declared in the contract for the same variable; thereby, making two getter functions for the same variable in the contract. We could rectify this issue by making the `registries` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:\n\n```diff\ndiff --git a/contracts/src/core/AddressProvider.sol b/contracts/src/core/AddressProvider.sol\nindex 5ec51f9..0a2381b 100644\n--- a/contracts/src/core/AddressProvider.sol\n+++ b/contracts/src/core/AddressProvider.sol\n@@ -38,7 +38,7 @@ contract AddressProvider {\n      * @notice keccak256 hash of registry keys mapped to their addresses\n      * @dev registries are only set once by governance and immutable\n      */\n-    mapping(bytes32 => address) public registries;\n+    mapping(bytes32 => address) internal registries;\n```\n\n3. Make `registries` mapping variable `private` or `internal` since a getter function was defined for it.\n\n    https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/registries/WalletRegistry.sol#L63\n\n```solidity\nfile: contracts/src/core/registries/WalletRegistry.sol\n\n25:    mapping(address wallet => address[] subAccountList) public walletToSubAccountList;  //@audit generates a redundant getter function\n\n63:    function getSubAccountsForWallet(address _wallet) external view returns (address[] memory) {\n64:        return walletToSubAccountList[_wallet];\n65;    }\n```\n\nThe solidity compiler would automatically create a getter function for the `walletToSubAccountList` mapping above since it is declared as a `public` variable. However, a getter function `getSubAccountsForWallet()` was also declared in the contract for the same variable; thereby, making two getter functions for the same variable in the contract. We could rectify this issue by making the `walletToSubAccountList` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:\n\n```diff\ndiff --git a/contracts/src/core/registries/WalletRegistry.sol b/contracts/src/core/registries/WalletRegistry.sol\nindex afc2b7d..4554b7c 100644\n--- a/contracts/src/core/registries/WalletRegistry.sol\n+++ b/contracts/src/core/registries/WalletRegistry.sol\n@@ -22,7 +22,7 @@ contract WalletRegistry is AddressProviderService {\n     /// @notice subAccount addresses mapped to owner wallet\n     mapping(address subAccount => address wallet) public subAccountToWallet;\n     /// @notice wallet addresses mapped to list of subAccounts\n-    mapping(address wallet => address[] subAccountList) public walletToSubAccountList;\n+    mapping(address wallet => address[] subAccountList) internal walletToSubAccountList;\n     /// @notice address of wallet mapped to boolean indicating if it's a wallet\n     mapping(address => bool) public isWallet;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/src/core/AddressProvider.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {IAddressProviderService} from \"interfaces/IAddressProviderService.sol\";\n\n/**\n * @title AddressProvider\n * @author Brahma.fi\n * @notice Single source of truth for resolving addresses of core components and external contracts\n */\ncontract AddressProvider {\n    error RegistryAlreadyExists();\n    error AddressProviderUnsupported();\n    error NotGovernance(address);\n    error NotPendingGovernance(address);\n    error NullAddress();\n\n    event RegistryInitialised(address indexed registry, bytes32 indexed key);\n    event AuthorizedAddressInitialised(address indexed authorizedAddress, bytes32 indexed key);\n    event GovernanceTransferRequested(address indexed previousGovernance, address indexed newGovernance);\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\n\n    /// @notice address of governance\n    address public governance;\n    /// @notice address of pending governance before accepting\n    address public pendingGovernance;\n\n    /**\n     * @notice keccak256 hash of authorizedAddress keys mapped to their addresses\n     * @dev authorizedAddresses are updatable by governance\n     */\n    mapping(bytes32 => address) public authorizedAddresses;\n\n    /**\n     * @notice keccak256 hash of registry keys mapped to their addresses\n     * @dev registries are only set once by governance and immutable\n     */\n    mapping(bytes32 => address) public registries;\n\n    constructor(address _governance) {\n        _notNull(_governance);\n        governance = _governance;\n    }\n\n    /**\n     * @notice Governance setter\n     * @param _newGovernance address of new governance\n     */\n    function setGovernance(address _newGovernance) external {\n        _notNull(_newGovernance);\n        _onlyGov();\n        emit GovernanceTransferRequested(governance, _newGovernance);\n        pendingGovernance = _newGovernance;\n    }\n\n    /**\n     * @notice Governance accepter\n     */\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernance) {\n            revert NotPendingGovernance(msg.sender);\n        }\n        emit GovernanceTransferred(governance, msg.sender);\n        governance = msg.sender;\n        delete pendingGovernance;\n    }\n\n    /**\n     * @notice Authorized address setter\n     * @param _key key of authorizedAddress\n     * @param _authorizedAddress address to set\n     * @param _overrideCheck overrides check for supported address provider\n     */\n    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {\n        _onlyGov();\n        _notNull(_authorizedAddress);\n\n        /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true\n        if (!_overrideCheck) {\n            /// @dev skips checks for supported `addressProvider()` if `_authorizedAddress` is an EOA\n            if (_authorizedAddress.code.length != 0) _ensureAddressProvider(_authorizedAddress);\n        }\n\n        authorizedAddresses[_key] = _authorizedAddress;\n\n        emit AuthorizedAddressInitialised(_authorizedAddress, _key);\n    }\n\n    /**\n     * @notice Registry address setter\n     * @param _key key of registry address\n     * @param _registry address to set\n     */\n    function setRegistry(bytes32 _key, address _registry) external {\n        _onlyGov();\n        _ensureAddressProvider(_registry);\n\n        if (registries[_key] != address(0)) revert RegistryAlreadyExists();\n        registries[_key] = _registry;\n\n        emit RegistryInitialised(_registry, _key);\n    }\n\n    /**\n     * @notice Authorized address getter\n     * @param _key key of authorized address\n     * @return address of authorized address\n     */\n    function getAuthorizedAddress(bytes32 _key) external view returns (address) {\n        return authorizedAddresses[_key];\n    }\n\n    /**\n     * @notice Registry address getter\n     * @param _key key of registry address\n     * @return address of registry address\n     */\n    function getRegistry(bytes32 _key) external view returns (address) {\n        return registries[_key];\n    }\n\n    /**\n     * @notice Ensures that the new address supports the AddressProviderService interface\n     * and is pointing to this AddressProvider\n     * @param _newAddress address to check\n     */\n    function _ensureAddressProvider(address _newAddress) internal view {\n        if (IAddressProviderService(_newAddress).addressProviderTarget() != address(this)) {\n            revert AddressProviderUnsupported();\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is governance\n     */\n    function _onlyGov() internal view {\n        if (msg.sender != governance) revert NotGovernance(msg.sender);\n    }\n\n    /**\n     * @notice Checks and reverts if address is null\n     * @param addr address to check if null\n     */\n    function _notNull(address addr) internal pure {\n        if (addr == address(0)) revert NullAddress();\n    }\n}"
    },
    {
      "filename": "contracts/src/core/AddressProvider.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {IAddressProviderService} from \"interfaces/IAddressProviderService.sol\";\n\n/**\n * @title AddressProvider\n * @author Brahma.fi\n * @notice Single source of truth for resolving addresses of core components and external contracts\n */\ncontract AddressProvider {\n    error RegistryAlreadyExists();\n    error AddressProviderUnsupported();\n    error NotGovernance(address);\n    error NotPendingGovernance(address);\n    error NullAddress();\n\n    event RegistryInitialised(address indexed registry, bytes32 indexed key);\n    event AuthorizedAddressInitialised(address indexed authorizedAddress, bytes32 indexed key);\n    event GovernanceTransferRequested(address indexed previousGovernance, address indexed newGovernance);\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\n\n    /// @notice address of governance\n    address public governance;\n    /// @notice address of pending governance before accepting\n    address public pendingGovernance;\n\n    /**\n     * @notice keccak256 hash of authorizedAddress keys mapped to their addresses\n     * @dev authorizedAddresses are updatable by governance\n     */\n    mapping(bytes32 => address) public authorizedAddresses;\n\n    /**\n     * @notice keccak256 hash of registry keys mapped to their addresses\n     * @dev registries are only set once by governance and immutable\n     */\n    mapping(bytes32 => address) public registries;\n\n    constructor(address _governance) {\n        _notNull(_governance);\n        governance = _governance;\n    }\n\n    /**\n     * @notice Governance setter\n     * @param _newGovernance address of new governance\n     */\n    function setGovernance(address _newGovernance) external {\n        _notNull(_newGovernance);\n        _onlyGov();\n        emit GovernanceTransferRequested(governance, _newGovernance);\n        pendingGovernance = _newGovernance;\n    }\n\n    /**\n     * @notice Governance accepter\n     */\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernance) {\n            revert NotPendingGovernance(msg.sender);\n        }\n        emit GovernanceTransferred(governance, msg.sender);\n        governance = msg.sender;\n        delete pendingGovernance;\n    }\n\n    /**\n     * @notice Authorized address setter\n     * @param _key key of authorizedAddress\n     * @param _authorizedAddress address to set\n     * @param _overrideCheck overrides check for supported address provider\n     */\n    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {\n        _onlyGov();\n        _notNull(_authorizedAddress);\n\n        /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true\n        if (!_overrideCheck) {\n            /// @dev skips checks for supported `addressProvider()` if `_authorizedAddress` is an EOA\n            if (_authorizedAddress.code.length != 0) _ensureAddressProvider(_authorizedAddress);\n        }\n\n        authorizedAddresses[_key] = _authorizedAddress;\n\n        emit AuthorizedAddressInitialised(_authorizedAddress, _key);\n    }\n\n    /**\n     * @notice Registry address setter\n     * @param _key key of registry address\n     * @param _registry address to set\n     */\n    function setRegistry(bytes32 _key, address _registry) external {\n        _onlyGov();\n        _ensureAddressProvider(_registry);\n\n        if (registries[_key] != address(0)) revert RegistryAlreadyExists();\n        registries[_key] = _registry;\n\n        emit RegistryInitialised(_registry, _key);\n    }\n\n    /**\n     * @notice Authorized address getter\n     * @param _key key of authorized address\n     * @return address of authorized address\n     */\n    function getAuthorizedAddress(bytes32 _key) external view returns (address) {\n        return authorizedAddresses[_key];\n    }\n\n    /**\n     * @notice Registry address getter\n     * @param _key key of registry address\n     * @return address of registry address\n     */\n    function getRegistry(bytes32 _key) external view returns (address) {\n        return registries[_key];\n    }\n\n    /**\n     * @notice Ensures that the new address supports the AddressProviderService interface\n     * and is pointing to this AddressProvider\n     * @param _newAddress address to check\n     */\n    function _ensureAddressProvider(address _newAddress) internal view {\n        if (IAddressProviderService(_newAddress).addressProviderTarget() != address(this)) {\n            revert AddressProviderUnsupported();\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is governance\n     */\n    function _onlyGov() internal view {\n        if (msg.sender != governance) revert NotGovernance(msg.sender);\n    }\n\n    /**\n     * @notice Checks and reverts if address is null\n     * @param addr address to check if null\n     */\n    function _notNull(address addr) internal pure {\n        if (addr == address(0)) revert NullAddress();\n    }\n}"
    },
    {
      "filename": "contracts/src/core/registries/WalletRegistry.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {AddressProviderService} from \"../AddressProviderService.sol\";\n\n/**\n * @title WalletRegistry\n * @author Brahma.fi\n * @notice Registry for wallet and sub account addresses\n */\ncontract WalletRegistry is AddressProviderService {\n    error AlreadyRegistered();\n    error InvalidSender();\n    error IsSubAccount();\n\n    event RegisterWallet(address indexed wallet);\n    event RegisterSubAccount(address indexed wallet, address indexed subAccount);\n\n    /// @notice subAccount addresses mapped to owner wallet\n    mapping(address subAccount => address wallet) public subAccountToWallet;\n    /// @notice wallet addresses mapped to list of subAccounts\n    mapping(address wallet => address[] subAccountList) public walletToSubAccountList;\n    /// @notice address of wallet mapped to boolean indicating if it's a wallet\n    mapping(address => bool) public isWallet;\n\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\n\n    /**\n     * @notice Registers a wallet\n     * @dev Can only be called by safe deployer or the wallet itself\n     */\n    function registerWallet() external {\n        if (isWallet[msg.sender]) revert AlreadyRegistered();\n        if (subAccountToWallet[msg.sender] != address(0)) revert IsSubAccount();\n        isWallet[msg.sender] = true;\n        emit RegisterWallet(msg.sender);\n    }\n\n    /**\n     * @notice Registers a sub account for a Safe\n     * @param _wallet Console account address, owner of sub account\n     * @param _subAccount Sub account address to register\n     * @dev Can only be called by safe deployer\n     */\n\n    function registerSubAccount(address _wallet, address _subAccount) external {\n        if (msg.sender != AddressProviderService._getAuthorizedAddress(_SAFE_DEPLOYER_HASH)) revert InvalidSender();\n        if (subAccountToWallet[_subAccount] != address(0)) revert AlreadyRegistered();\n        subAccountToWallet[_subAccount] = _wallet;\n        walletToSubAccountList[_wallet].push(_subAccount);\n        emit RegisterSubAccount(_wallet, _subAccount);\n    }\n\n    /**\n     * @notice sub account list getter\n     * @dev returns sub account list associated with _wallet\n     * @param _wallet safe address\n     * @return list of subAccounts for wallet\n     */\n    function getSubAccountsForWallet(address _wallet) external view returns (address[] memory) {\n        return walletToSubAccountList[_wallet];\n    }\n\n    /**\n     * @notice checks if _wallet owns _subAccount\n     * @param _wallet address of wallet\n     * @param _subAccount address of subAccount\n     * @return isWalletOwnerOfSubAccount\n     */\n    function isOwner(address _wallet, address _subAccount) external view returns (bool) {\n        return subAccountToWallet[_subAccount] == _wallet;\n    }\n}"
    }
  ]
}