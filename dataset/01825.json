{
  "Title": "M-11: Calc.boundedAdd used intitally but later regular subtraction used",
  "Content": "# Issue M-11: Calc.boundedAdd used intitally but later regular subtraction used \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/269 \n\n## Found by \nstent\n## Summary\n\nIn MarketDecrease order flow the funding amount per size calculation uses `Calc.boundedAdd` but further down the call path there is a calculation that does not use `Calc.boundedSubtract` but rather a regular `-`, which could cause overflow errors.\n\n## Vulnerability Detail\n\nIn `MarketUtils.getNextFundingAmountPerSize` the funding amount per size variables in the `GetNextFundingAmountPerSizeResult` variable are calculated using `Calc.boundedAdd(a,b)`. If the inputs to the function are `(type(int256).min+10,-12)`, for example, then the value returned will be `type(int256).min` i.e. it will not cause an arithmetic overflow, like it would if the values were just added normally with `+`.\n\nFurther down the call path of MarketDecrease in `MarketUtils.getFundingFeeAmount` the funding amount is negated, and negating `type(int256).min` results in an arithmetic overflow.\n\nIf the point of defending overflow of the funding amount per size variables was to allow execution to pass without failure then all calculations involving the funding amount per size variables should use `Calc.boundedAdd` or `Calc.boundedSub`.\n\n## Impact\n\nMarketDecrease orders that would be expected to pass would fail, causing them to be cancelled.\n\n## Code Snippet\n\n```solidity\n// contract & func: MarketUtils.getNextFundingAmountPerSize\n\n            result.fundingAmountPerSize_LongCollateral_LongPosition = Calc.boundedAdd(\n                result.fundingAmountPerSize_LongCollateral_LongPosition,\n                cache.fps.fundingAmountPerSizeDelta_LongCollateral_LongPosition.toInt256()\n            );\n```\nhttps://github.com/gmx-io/gmx-synthetics/blob/a2e331f6d0a3b59aaac5ead975b206840369a723/contracts/market/MarketUtils.sol#L1074\n\n```solidity\n// contract: Calc\n\n    function boundedAdd(int256 a, int256 b) internal pure returns (int256) {\n        // if either a or b is zero or if the signs are different there should not be any overflows\n        if (a == 0 || b == 0 || (a < 0 && b > 0) || (a > 0 && b < 0)) {\n            return a + b;\n        }\n\n        // if adding `b` to `a` would result in a value less than the min int256 value\n        // then return the min int256 value\n        if (a < 0 && b <= type(int256).min - a) {\n            return type(int256).min;\n        }\n\n        // if adding `b` to `a` would result in a value more than the max int256 value\n        // then return the max int256 value\n        if (a > 0 && b >= type(int256).max - a) {\n            return type(int256).max;\n        }\n\n        return a + b;\n    }\n```\nhttps://github.com/gmx-io/gmx-synthetics/blob/a2e331f6d0a3b59aaac5ead975b206840369a723/contracts/utils/Calc.sol#L90\n\n```solidity\n// contract: MarketUtils\n\n    function getFundingFeeAmount(\n        int256 latestFundingAmountPerSize,\n        int256 positionFundingAmountPerSize,\n        uint256 positionSizeInUsd\n    ) internal pure returns (int256) {\n        int256 fundingDiffFactor = (latestFundingAmountPerSize - positionFundingAmountPerSize);\n```\nhttps://github.com/gmx-io/gmx-synthetics/blob/a2e331f6d0a3b59aaac5ead975b206840369a723/contracts/market/MarketUtils.sol#L1345\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `Calc.boundedAdd` & `Calc.boundedSub` on all calculations involving addition and subtraction with funding amount per size variables.\n\n\n\n## Discussion\n\n**IllIllI000**\n\nwill let sponsor review\n\n**xvi10**\n\nit seems the market could get bricked if reaching this state, despite attempts at avoiding that, the likelihood of this should be quite small\n\nif the market reaches this state, the market may not function correctly, it may be preferable to update the funding fee factors to prevent this state instead of handling this in the contracts, to avoid the complexity of handling this case for this scope\n\nthe contracts could be updated in the future to properly handle this case\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "contracts/market/MarketUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../bank/StrictBank.sol\";\n\nimport \"./Market.sol\";\nimport \"./MarketPoolValueInfo.sol\";\nimport \"./MarketToken.sol\";\nimport \"./MarketEventUtils.sol\";\nimport \"./MarketStoreUtils.sol\";\n\nimport \"../position/Position.sol\";\nimport \"../order/Order.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../price/Price.sol\";\n\nimport \"../utils/Calc.sol\";\nimport \"../utils/Precision.sol\";\n\n// @title MarketUtils\n// @dev Library for market functions\nlibrary MarketUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Market for Market.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev struct to store the prices of tokens of a market\n    // @param indexTokenPrice price of the market's index token\n    // @param longTokenPrice price of the market's long token\n    // @param shortTokenPrice price of the market's short token\n    struct MarketPrices {\n        Price.Props indexTokenPrice;\n        Price.Props longTokenPrice;\n        Price.Props shortTokenPrice;\n    }\n\n    // @dev struct for the result of the getNextFundingAmountPerSize call\n    // @param longsPayShorts whether longs pay shorts or shorts pay longs\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding amount per\n    // size for users with a long position using long collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding amount per\n    // size for users with a short position using long collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding amount per\n    // size for users with a long position using short collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding amount per\n    // size for users with a short position using short collateral\n    struct GetNextFundingAmountPerSizeResult {\n        bool longsPayShorts;\n        uint256 fundingFactorPerSecond;\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n    }\n\n    // @dev GetNextFundingAmountPerSizeCache struct used in getNextFundingAmountPerSize\n    // to avoid stack too deep errors\n    //\n    // @param durationInSeconds duration in seconds since the last funding update\n    //\n    // @param diffUsd the absolute difference in long and short open interest for the market\n    // @param totalOpenInterest the total long and short open interest for the market\n    // @param fundingUsd the funding amount in USD\n    //\n    // @param fundingUsdForLongCollateral the funding amount in USD for positions using the long token as collateral\n    // @param fundingUsdForShortCollateral the funding amount in USD for positions using the short token as collateral\n    struct GetNextFundingAmountPerSizeCache {\n        GetNextFundingAmountPerSizeOpenInterestCache oi;\n        GetNextFundingAmountPerSizeFundingPerSizeCache fps;\n\n        uint256 durationInSeconds;\n\n        uint256 diffUsd;\n        uint256 totalOpenInterest;\n        uint256 sizeOfLargerSide;\n        uint256 fundingUsd;\n\n        uint256 fundingUsdForLongCollateral;\n        uint256 fundingUsdForShortCollateral;\n\n        uint256 fundingAmountForLongCollateral;\n        uint256 fundingAmountForShortCollateral;\n    }\n\n    // @param longOpenInterestWithLongCollateral amount of long open interest using the long token as collateral\n    // @param longOpenInterestWithShortCollateral amount of long open interest using the short token as collateral\n    // @param shortOpenInterestWithLongCollateral amount of short open interest using the long token as collateral\n    // @param shortOpenInterestWithShortCollateral amount of short open interest using the short token as collateral\n    //\n    // @param longOpenInterest total long open interest for the market\n    // @param shortOpenInterest total short open interest for the market\n    struct GetNextFundingAmountPerSizeOpenInterestCache {\n        uint256 longOpenInterestWithLongCollateral;\n        uint256 longOpenInterestWithShortCollateral;\n        uint256 shortOpenInterestWithLongCollateral;\n        uint256 shortOpenInterestWithShortCollateral;\n\n        uint256 longOpenInterest;\n        uint256 shortOpenInterest;\n    }\n\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding per size for longs using the long token as collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding per size for shorts using the long token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding per size for longs using the short token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding per size for shorts using the short token as collateral\n    //\n    // @param fundingAmountPerSizeDelta_LongCollateral_LongPosition the next funding amount per size for longs using the long token as collateral\n    // @param fundingAmountPerSizeDelta_LongCollateral_ShortPosition the next funding amount per size for longs using the short token as collateral\n    // @param fundingAmountPerSizeDelta_ShortCollateral_LongPosition the next funding amount per size for shorts using the long token as collateral\n    // @param fundingAmountPerSizeDelta_ShortCollateral_ShortPosition the next funding amount per size for shorts using the short token as collateral\n    struct GetNextFundingAmountPerSizeFundingPerSizeCache {\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n\n        uint256 fundingAmountPerSizeDelta_LongCollateral_LongPosition;\n        uint256 fundingAmountPerSizeDelta_ShortCollateral_LongPosition;\n        uint256 fundingAmountPerSizeDelta_LongCollateral_ShortPosition;\n        uint256 fundingAmountPerSizeDelta_ShortCollateral_ShortPosition;\n    }\n\n    struct GetExpectedMinTokenBalanceCache {\n        uint256 poolAmount;\n        uint256 collateralForLongs;\n        uint256 collateralForShorts;\n        uint256 swapImpactPoolAmount;\n        uint256 claimableCollateralAmount;\n        uint256 claimableFeeAmount;\n        uint256 claimableUiFeeAmount;\n        uint256 affiliateRewardAmount;\n    }\n\n    // @dev get the market token's price\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longTokenPrice the price of the long token\n    // @param shortTokenPrice the price of the short token\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the market token price\n    // @return returns the market token's price\n    function getMarketTokenPrice(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory indexTokenPrice,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) external view returns (int256, MarketPoolValueInfo.Props memory) {\n        MarketPoolValueInfo.Props memory poolValueInfo = getPoolValueInfo(\n            dataStore,\n            market,\n            indexTokenPrice,\n            longTokenPrice,\n            shortTokenPrice,\n            pnlFactorType,\n            maximize\n        );\n\n        if (poolValueInfo.poolValue == 0) { return (0, poolValueInfo); }\n\n        if (poolValueInfo.poolValue < 0) {\n            revert Errors.UnexpectedPoolValueForTokenPriceCalculation(poolValueInfo.poolValue);\n        }\n\n        uint256 supply = getMarketTokenSupply(MarketToken(payable(market.marketToken)));\n\n        if (supply == 0) {\n            revert Errors.UnexpectedSupplyForTokenPriceCalculation();\n        }\n\n        return (poolValueInfo.poolValue * Precision.WEI_PRECISION.toInt256() / supply.toInt256(), poolValueInfo);\n    }\n\n    // @dev get the total supply of the marketToken\n    // @param marketToken the marketToken\n    // @return the total supply of the marketToken\n    function getMarketTokenSupply(MarketToken marketToken) internal view returns (uint256) {\n        return marketToken.totalSupply();\n    }\n\n    // @dev get the opposite token of the market\n    // if the inputToken is the longToken return the shortToken and vice versa\n    // @param inputToken the input token\n    // @param market the market values\n    // @return the opposite token\n    function getOppositeToken(address inputToken, Market.Props memory market) internal pure returns (address) {\n        if (inputToken == market.longToken) {\n            return market.shortToken;\n        }\n\n        if (inputToken == market.shortToken) {\n            return market.longToken;\n        }\n\n        revert Errors.UnableToGetOppositeToken(inputToken, market.marketToken);\n    }\n\n    function validateSwapMarket(Market.Props memory market) internal pure {\n        if (market.longToken == market.shortToken) {\n            revert Errors.InvalidSwapMarket(market.marketToken);\n        }\n    }\n\n    // @dev get the token price from the stored MarketPrices\n    // @param token the token to get the price for\n    // @param the market values\n    // @param the market token prices\n    // @return the token price from the stored MarketPrices\n    function getCachedTokenPrice(address token, Market.Props memory market, MarketPrices memory prices) internal pure returns (Price.Props memory) {\n        if (token == market.longToken) {\n            return prices.longTokenPrice;\n        }\n        if (token == market.shortToken) {\n            return prices.shortTokenPrice;\n        }\n        if (token == market.indexToken) {\n            return prices.indexTokenPrice;\n        }\n\n        revert Errors.UnableToGetCachedTokenPrice(token, market.marketToken);\n    }\n\n    // @dev return the latest prices for the market tokens\n    // the secondary price for market.indexToken is overwritten for certain order\n    // types, use this value instead of the primary price for positions\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPricesForPosition(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getLatestPrice(market.indexToken),\n            oracle.getLatestPrice(market.longToken),\n            oracle.getLatestPrice(market.shortToken)\n        );\n    }\n\n    // @dev return the primary prices for the market tokens\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPrices(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getPrimaryPrice(market.indexToken),\n            oracle.getPrimaryPrice(market.longToken),\n            oracle.getPrimaryPrice(market.shortToken)\n        );\n    }\n\n    // @dev get the usd value of either the long or short tokens in the pool\n    // without accounting for the pnl of open positions\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param prices the prices of the market tokens\n    // @param whether to return the value for the long or short token\n    // @return the usd value of either the long or short tokens in the pool\n    function getPoolUsdWithoutPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketPrices memory prices,\n        bool isLong\n    ) internal view returns (uint256) {\n        address token = isLong ? market.longToken : market.shortToken;\n        uint256 poolAmount = getPoolAmount(dataStore, market, token);\n        uint256 tokenPrice = isLong ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n        return poolAmount * tokenPrice;\n    }\n\n    // @dev get the USD value of a pool\n    // the value of a pool is the worth of the liquidity provider tokens in the pool - pending trader pnl\n    // we use the token index prices to calculate this and ignore price impact since if all positions were closed the\n    // net price impact should be zero\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param longTokenPrice price of the long token\n    // @param shortTokenPrice price of the short token\n    // @param indexTokenPrice price of the index token\n    // @param maximize whether to maximize or minimize the pool value\n    // @return the value information of a pool\n    function getPoolValueInfo(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory indexTokenPrice,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) public view returns (MarketPoolValueInfo.Props memory) {\n        MarketPoolValueInfo.Props memory result;\n\n        result.longTokenAmount = getPoolAmount(dataStore, market, market.longToken);\n        result.shortTokenAmount = getPoolAmount(dataStore, market, market.shortToken);\n\n        result.longTokenUsd = result.longTokenAmount * longTokenPrice.pickPrice(maximize);\n        result.shortTokenUsd = result.shortTokenAmount * shortTokenPrice.pickPrice(maximize);\n\n        uint256 poolValue = result.longTokenUsd + result.shortTokenUsd;\n\n        MarketPrices memory prices = MarketPrices(\n            indexTokenPrice,\n            longTokenPrice,\n            shortTokenPrice\n        );\n\n        result.totalBorrowingFees = getTotalPendingBorrowingFees(\n            dataStore,\n            market,\n            prices,\n            true\n        );\n\n        result.totalBorrowingFees += getTotalPendingBorrowingFees(\n            dataStore,\n            market,\n            prices,\n            false\n        );\n\n        result.borrowingFeePoolFactor = Precision.FLOAT_PRECISION - dataStore.getUint(Keys.BORROWING_FEE_RECEIVER_FACTOR);\n        poolValue += Precision.applyFactor(result.totalBorrowingFees, result.borrowingFeePoolFactor);\n\n        result.impactPoolAmount = getPositionImpactPoolAmount(dataStore, market.marketToken);\n        poolValue -= result.impactPoolAmount * indexTokenPrice.pickPrice(maximize);\n\n        // !maximize should be used for net pnl as a larger pnl leads to a smaller pool value\n        // and a smaller pnl leads to a larger pool value\n\n        result.longPnl = getPnl(\n            dataStore,\n            market,\n            indexTokenPrice,\n            true,\n            !maximize\n        );\n\n        result.longPnl = getCappedPnl(\n            dataStore,\n            market.marketToken,\n            true,\n            result.longPnl,\n            result.longTokenUsd,\n            pnlFactorType\n        );\n\n        result.shortPnl = getPnl(\n            dataStore,\n            market,\n            indexTokenPrice,\n            false,\n            !maximize\n        );\n\n        result.shortPnl = getCappedPnl(\n            dataStore,\n            market.marketToken,\n            false,\n            result.shortPnl,\n            result.shortTokenUsd,\n            pnlFactorType\n        );\n\n        result.netPnl = result.longPnl + result.shortPnl;\n\n        result.poolValue = Calc.sumReturnInt256(poolValue, -result.netPnl);\n        return result;\n    }\n\n    // @dev get the net pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the net pnl\n    // @return the net pending pnl for a market\n    function getNetPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory indexTokenPrice,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 longPnl = getPnl(dataStore, market, indexTokenPrice, true, maximize);\n        int256 shortPnl = getPnl(dataStore, market, indexTokenPrice, false, maximize);\n\n        return longPnl + shortPnl;\n    }\n\n    // @dev get the capped pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param isLong whether to check for the long or short side\n    // @param pnl the uncapped pnl of the market\n    // @param poolUsd the USD value of the pool\n    // @param pnlFactorType the pnl factor type to use\n    function getCappedPnl(\n        DataStore dataStore,\n        address market,\n        bool isLong,\n        int256 pnl,\n        uint256 poolUsd,\n        bytes32 pnlFactorType\n    ) internal view returns (int256) {\n        if (pnl < 0) { return pnl; }\n\n        uint256 maxPnlFactor = getMaxPnlFactor(dataStore, pnlFactorType, market, isLong);\n        int256 maxPnl = Precision.applyFactor(poolUsd, maxPnlFactor).toInt256();\n\n        return pnl > maxPnl ? maxPnl : pnl;\n    }\n\n    // @dev get the pending pnl for a market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param isLong whether to check for the long or short side\n    // @param maximize whether to maximize or minimize the pnl\n    function getPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        uint256 indexTokenPrice,\n        bool isLong,\n        bool maximize\n    ) internal view returns (int256) {\n        Price.Props memory _indexTokenPrice = Price.Props(indexTokenPrice, indexTokenPrice);\n\n        return getPnl(\n            dataStore,\n            market,\n            _indexTokenPrice,\n            isLong,\n            maximize\n        );\n    }\n\n    // @dev get the pending pnl for a market for either longs or shorts\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param indexTokenPrice the price of the index token\n    // @param isLong whether to get the pnl for longs or shorts\n    // @param maximize whether to maximize or minimize the net pnl\n    // @return the pending pnl for a market for either longs or shorts\n    function getPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory indexTokenPrice,\n        bool isLong,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 openInterest = getOpenInterest(dataStore, market, isLong).toInt256();\n        uint256 openInterestInTokens = getOpenInterestInTokens(dataStore, market, isLong);\n        if (openInterest == 0 || openInterestInTokens == 0) {\n            return 0;\n        }\n\n        uint256 price = indexTokenPrice.pickPriceForPnl(isLong, maximize);\n\n        // openInterest is the cost of all positions, openInterestValue is the current worth of all positions\n        int256 openInterestValue = (openInterestInTokens * price).toInt256();\n        int256 pnl = isLong ? openInterestValue - openInterest : openInterest - openInterestValue;\n\n        return pnl;\n    }\n\n    // @dev get the amount of tokens in the pool\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param token the token to check\n    // @return the amount of tokens in the pool\n    function getPoolAmount(DataStore dataStore, Market.Props memory market, address token) internal view returns (uint256) {\n        /* Market.Props memory market = MarketStoreUtils.get(dataStore, marketAddress); */\n        // if the longToken and shortToken are the same, return half of the token amount, so that\n        // calculations of pool value, etc would be correct\n        uint256 divisor = getPoolDivisor(market.longToken, market.shortToken);\n        return dataStore.getUint(Keys.poolAmountKey(market.marketToken, token)) / divisor;\n    }\n\n    // @dev get the max amount of tokens allowed to be in the pool\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param token the token to check\n    // @return the max amount of tokens that are allowed in the pool\n    function getMaxPoolAmount(DataStore dataStore, address market, address token) internal view returns (uint256) {\n        return dataStore.getUint(Keys.maxPoolAmountKey(market, token));\n    }\n\n    // @dev get the max open interest allowed for the market\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param isLong whether this is for the long or short side\n    // @return the max open interest allowed for the market\n    function getMaxOpenInterest(DataStore dataStore, address market, bool isLong) internal view returns (uint256) {\n        return dataStore.getUint(Keys.maxOpenInterestKey(market, isLong));\n    }\n\n    // @dev increment the claimable collateral amount\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to increment the claimable collateral for\n    // @param token the claimable token\n    // @param account the account to increment the claimable collateral for\n    // @param delta the amount to increment\n    function incrementClaimableCollateralAmount(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        address account,\n        uint256 delta\n    ) internal {\n        uint256 divisor = dataStore.getUint(Keys.CLAIMABLE_COLLATERAL_TIME_DIVISOR);\n        uint256 timeKey = Chain.currentTimestamp() / divisor;\n\n        uint256 nextValue = dataStore.incrementUint(\n            Keys.claimableCollateralAmountKey(market, token, timeKey, account),\n            delta\n        );\n\n        uint256 nextPoolValue = dataStore.incrementUint(\n            Keys.claimableCollateralAmountKey(market, token),\n            delta\n        );\n\n        MarketEventUtils.emitClaimableCollateralUpdated(\n            eventEmitter,\n            market,\n            token,\n            timeKey,\n            account,\n            delta,\n            nextValue,\n            nextPoolValue\n        );\n    }\n\n    // @dev increment the claimable funding amount\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the trading market\n    // @param token the claimable token\n    // @param account the account to increment for\n    // @param delta the amount to increment\n    function incrementClaimableFundingAmount(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        address account,\n        uint256 delta\n    ) internal {\n        uint256 nextValue = dataStore.incrementUint(\n            Keys.claimableFundingAmountKey(market, token, account),\n            delta\n        );\n\n        uint256 nextPoolValue = dataStore.incrementUint(\n            Keys.claimableFundingAmountKey(market, token),\n            delta\n        );\n\n        MarketEventUtils.emitClaimableFundingUpdated(\n            eventEmitter,\n            market,\n            token,\n            account,\n            delta,\n            nextValue,\n            nextPoolValue\n        );\n    }\n\n    // @dev claim funding fees\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to claim for\n    // @param token the token to claim\n    // @param account the account to claim for\n    // @param receiver the receiver to send the amount to\n    function claimFundingFees(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        address account,\n        address receiver\n    ) internal {\n        bytes32 key = Keys.claimableFundingAmountKey(market, token, account);\n\n        uint256 claimableAmount = dataStore.getUint(key);\n        dataStore.setUint(key, 0);\n\n        uint256 nextPoolValue = dataStore.decrementUint(\n            Keys.claimableFundingAmountKey(market, token),\n            claimableAmount\n        );\n\n        MarketToken(payable(market)).transferOut(\n            token,\n            receiver,\n            claimableAmount\n        );\n\n        validateMarketTokenBalance(dataStore, market);\n\n        MarketEventUtils.emitFundingFeesClaimed(\n            eventEmitter,\n            market,\n            token,\n            account,\n            receiver,\n            claimableAmount,\n            nextPoolValue\n        );\n    }\n\n    // @dev claim collateral\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to claim for\n    // @param token the token to claim\n    // @param timeKey the time key\n    // @param account the account to claim for\n    // @param receiver the receiver to send the amount to\n    function claimCollateral(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        uint256 timeKey,\n        address account,\n        address receiver\n    ) internal {\n        uint256 claimableAmount = dataStore.getUint(Keys.claimableCollateralAmountKey(market, token, timeKey, account));\n\n        uint256 claimableFactorForTime = dataStore.getUint(Keys.claimableCollateralFactorKey(market, token, timeKey));\n        uint256 claimableFactorForAccount = dataStore.getUint(Keys.claimableCollateralFactorKey(market, token, timeKey, account));\n        uint256 claimableFactor = claimableFactorForTime > claimableFactorForAccount ? claimableFactorForTime : claimableFactorForAccount;\n\n        uint256 claimedAmount = dataStore.getUint(Keys.claimedCollateralAmountKey(market, token, timeKey, account));\n\n        uint256 adjustedClaimableAmount = Precision.applyFactor(claimableAmount, claimableFactor);\n        if (adjustedClaimableAmount <= claimedAmount) {\n            revert Errors.CollateralAlreadyClaimed(adjustedClaimableAmount, claimedAmount);\n        }\n\n        uint256 remainingClaimableAmount = adjustedClaimableAmount - claimedAmount;\n\n        dataStore.setUint(\n            Keys.claimedCollateralAmountKey(market, token, timeKey, account),\n            adjustedClaimableAmount\n        );\n\n        uint256 nextPoolValue = dataStore.decrementUint(\n            Keys.claimableCollateralAmountKey(market, token),\n            remainingClaimableAmount\n        );\n\n        MarketToken(payable(market)).transferOut(\n            token,\n            receiver,\n            remainingClaimableAmount\n        );\n\n        validateMarketTokenBalance(dataStore, market);\n\n        MarketEventUtils.emitCollateralClaimed(\n            eventEmitter,\n            market,\n            token,\n            timeKey,\n            account,\n            receiver,\n            remainingClaimableAmount,\n            nextPoolValue\n        );\n    }\n\n    // @dev apply a delta to the pool amount\n    // validatePoolAmount is not called in this function since applyDeltaToPoolAmount\n    // is called when receiving fees\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param token the token to apply to\n    // @param delta the delta amount\n    function applyDeltaToPoolAmount(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        int256 delta\n    ) internal returns (uint256) {\n        uint256 nextValue = dataStore.applyDeltaToUint(\n            Keys.poolAmountKey(market, token),\n            delta,\n            \"Invalid state, negative poolAmount\"\n        );\n\n        applyDeltaToVirtualInventoryForSwaps(\n            dataStore,\n            eventEmitter,\n            market,\n            token,\n            delta\n        );\n\n        MarketEventUtils.emitPoolAmountUpdated(eventEmitter, market, token, delta, nextValue);\n\n        return nextValue;\n    }\n\n    function getAdjustedSwapImpactFactor(DataStore dataStore, address market, bool isPositive) internal view returns (uint256) {\n        (uint256 positiveImpactFactor, uint256 negativeImpactFactor) = getAdjustedSwapImpactFactors(dataStore, market);\n\n        return isPositive ? positiveImpactFactor : negativeImpactFactor;\n    }\n\n    function getAdjustedSwapImpactFactors(DataStore dataStore, address market) internal view returns (uint256, uint256) {\n        uint256 positiveImpactFactor = dataStore.getUint(Keys.swapImpactFactorKey(market, true));\n        uint256 negativeImpactFactor = dataStore.getUint(Keys.swapImpactFactorKey(market, false));\n\n        // if the positive impact factor is more than the negative impact factor, positions could be opened\n        // and closed immediately for a profit if the difference is sufficient to cover the position fees\n        if (positiveImpactFactor > negativeImpactFactor) {\n            positiveImpactFactor = negativeImpactFactor;\n        }\n\n        return (positiveImpactFactor, negativeImpactFactor);\n    }\n\n    function getAdjustedPositionImpactFactor(DataStore dataStore, address market, bool isPositive) internal view returns (uint256) {\n        (uint256 positiveImpactFactor, uint256 negativeImpactFactor) = getAdjustedPositionImpactFactors(dataStore, market);\n\n        return isPositive ? positiveImpactFactor : negativeImpactFactor;\n    }\n\n    function getAdjustedPositionImpactFactors(DataStore dataStore, address market) internal view returns (uint256, uint256) {\n        uint256 positiveImpactFactor = dataStore.getUint(Keys.positionImpactFactorKey(market, true));\n        uint256 negativeImpactFactor = dataStore.getUint(Keys.positionImpactFactorKey(market, false));\n\n        // if the positive impact factor is more than the negative impact factor, positions could be opened\n        // and closed immediately for a profit if the difference is sufficient to cover the position fees\n        if (positiveImpactFactor > negativeImpactFactor) {\n            positiveImpactFactor = negativeImpactFactor;\n        }\n\n        return (positiveImpactFactor, negativeImpactFactor);\n    }\n\n    // @dev cap the input priceImpactUsd by the available amount in the position\n    // impact pool and the max positive position impact factor\n    // @param dataStore DataStore\n    // @param market the trading market\n    // @param tokenPrice the price of the token\n    // @param priceImpactUsd the calculated USD price impact\n    // @return the capped priceImpactUsd\n    function getCappedPositionImpactUsd(\n        DataStore dataStore,\n        address market,\n        Price.Props memory tokenPrice,\n        int256 priceImpactUsd,\n        uint256 sizeDeltaUsd\n    ) internal view returns (int256) {\n        if (priceImpactUsd < 0) {\n            return priceImpactUsd;\n        }\n\n        uint256 impactPoolAmount = getPositionImpactPoolAmount(dataStore, market);\n        int256 maxPriceImpactUsdBasedOnImpactPool = (impactPoolAmount * tokenPrice.min).toInt256();\n\n        if (priceImpactUsd > maxPriceImpactUsdBasedOnImpactPool) {\n            priceImpactUsd = maxPriceImpactUsdBasedOnImpactPool;\n        }\n\n        uint256 maxPriceImpactFactor = getMaxPositionImpactFactor(dataStore, market, true);\n        int256 maxPriceImpactUsdBasedOnMaxPriceImpactFactor = Precision.applyFactor(sizeDeltaUsd, maxPriceImpactFactor).toInt256();\n\n        if (priceImpactUsd > maxPriceImpactUsdBasedOnMaxPriceImpactFactor) {\n            priceImpactUsd = maxPriceImpactUsdBasedOnMaxPriceImpactFactor;\n        }\n\n        return priceImpactUsd;\n    }\n\n    // @dev get the position impact pool amount\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @return the position impact pool amount\n    function getPositionImpactPoolAmount(DataStore dataStore, address market) internal view returns (uint256) {\n        return dataStore.getUint(Keys.positionImpactPoolAmountKey(market));\n    }\n\n    // @dev get the swap impact pool amount\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param token the token to check\n    // @return the swap impact pool amount\n    function getSwapImpactPoolAmount(DataStore dataStore, address market, address token) internal view returns (uint256) {\n        return dataStore.getUint(Keys.swapImpactPoolAmountKey(market, token));\n    }\n\n    // @dev apply a delta to the swap impact pool\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param market the market to apply to\n    // @param token the token to apply to\n    // @param delta the delta amount\n    function applyDeltaToSwapImpactPool(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        address market,\n        address token,\n        int256 delta\n    )"
    }
  ]
}