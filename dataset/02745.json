{
  "Title": "M-3: WithdrawPeriphery#_convertToToken slippage control is broken for any token other than USDC",
  "Content": "# Issue M-3: WithdrawPeriphery#_convertToToken slippage control is broken for any token other than USDC \n\nSource: https://github.com/sherlock-audit/2022-10-rage-trade-judging/issues/55 \n\n## Found by \n0x52\n\n## Summary\n\nWithdrawPeriphery allows the user to redeem junior share vaults to any token available on GMX, applying a fixed slippage threshold to all redeems. The slippage calculation always returns the number of tokens to 6 decimals. This works fine for USDC but for other tokens like WETH or WBTC that are 18 decimals the slippage protection is completely ineffective and can lead to loss of funds for users that are withdrawing.\n\n## Vulnerability Detail\n\n    function _convertToToken(address token, address receiver) internal returns (uint256 amountOut) {\n        // this value should be whatever glp is received by calling withdraw/redeem to junior vault\n        uint256 outputGlp = fsGlp.balanceOf(address(this));\n\n        // using min price of glp because giving in glp\n        uint256 glpPrice = _getGlpPrice(false);\n\n        // using max price of token because taking token out of gmx\n        uint256 tokenPrice = gmxVault.getMaxPrice(token);\n\n        // apply slippage threshold on top of estimated output amount\n        uint256 minTokenOut = outputGlp.mulDiv(glpPrice * (MAX_BPS - slippageThreshold), tokenPrice * MAX_BPS);\n\n        // will revert if atleast minTokenOut is not received\n        amountOut = rewardRouter.unstakeAndRedeemGlp(address(token), outputGlp, minTokenOut, receiver);\n    }\n\nWithdrawPeriphery allows the user to redeem junior share vaults to any token available on GMX. To prevent users from losing large amounts of value to MEV the contract applies a fixed percentage slippage. minToken out is returned to 6 decimals regardless of the token being requested. This works for tokens with 6 decimals like USDC, but is completely ineffective for the majority of tokens that aren't.  \n\n## Impact\n\nUsers withdrawing tokens other than USDC can suffer huge loss of funds due to virtually no slippage protection\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-rage-trade/blob/main/dn-gmx-vaults/contracts/periphery/WithdrawPeriphery.sol#L147-L161\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdjust minTokenOut to match the decimals of the token:\n\n        uint256 minTokenOut = outputGlp.mulDiv(glpPrice * (MAX_BPS - slippageThreshold), tokenPrice * MAX_BPS);\n    +   minTokenOut = minTokenOut * 10 ** (token.decimals() - 6);\n\n## Discussion\n\n**0xDosa**\n\nAgreed on the issue but the severity level should be medium since loss of funds is not possible. While swapping on GMX, there is min-max spread and fees but no slippage due to them using chainlink oracles for pricing the tokens, so a direct sandwich attack would not work.\n\n**Evert0x**\n\nDowngrading to medium\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/16",
  "Code": [
    {
      "filename": "dn-gmx-vaults/contracts/periphery/WithdrawPeriphery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { IVault } from '../interfaces/gmx/IVault.sol';\nimport { IGlpManager } from '../interfaces/gmx/IGlpManager.sol';\nimport { ISglpExtended } from '../interfaces/gmx/ISglpExtended.sol';\nimport { IRewardRouterV2 } from '../interfaces/gmx/IRewardRouterV2.sol';\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { IERC20 } from '@openzeppelin/contracts/interfaces/IERC20.sol';\n\nimport { IDnGmxJuniorVault } from '../interfaces/IDnGmxJuniorVault.sol';\n\nimport { FullMath } from '@uniswap/v3-core-0.8-support/contracts/libraries/FullMath.sol';\n\n/**\n * @title Periphery to convert junior vault shares to tokens\n * @notice uses a fixed max slippage threshold\n * @notice primarily constructed to be used from frontend\n * @author RageTrade\n **/\n\ncontract WithdrawPeriphery is Ownable {\n    using FullMath for uint256;\n\n    event TokenWithdrawn(\n        address indexed from,\n        address indexed receiver,\n        address token,\n        uint256 sGlpAmount,\n        uint256 tokensRecevied\n    );\n\n    event TokenRedeemed(\n        address indexed from,\n        address indexed receiver,\n        address token,\n        uint256 sharesAmount,\n        uint256 tokensRecevied\n    );\n\n    event SlippageThresholdUpdated(uint256 newSlippageThreshold);\n\n    event AddressesUpdated(address juniorVault, address rewardRouter);\n\n    uint256 internal constant MAX_BPS = 1000;\n    // same price precision is used in gmx's Vault (Vault.sol)\n    uint256 internal constant PRICE_PRECISION = 1e30;\n\n    // max allowed slippage threshold (in bps) when sGlp to output token\n    uint256 public slippageThreshold;\n\n    // gmx's Glp (requird to query totalSupply)\n    IERC20 internal glp;\n    // staked glp tracker is requred to query balanceOf staked glp\n    // since staked glp returns 0 when balanceOf is called on it\n    IERC20 internal fsGlp;\n    // staked glp\n    ISglpExtended internal sGlp;\n\n    // gmx's Vault (vault.sol) contract\n    IVault internal gmxVault;\n    // gmx's GlpManager (GlpManager.sol), which can burn/mint glp\n    IGlpManager internal glpManager;\n    // gmx's RewardRouterV2 (RewardRouterV2.sol) contract\n    IRewardRouterV2 internal rewardRouter;\n\n    // delta neutral junior tranche\n    IDnGmxJuniorVault internal dnGmxJuniorVault;\n\n    /// @notice sets the maximum slippage threshold to be used for converting glp for asset\n    /// @param _slippageThreshold slippage threshold value in bps\n    function setSlippageThreshold(uint256 _slippageThreshold) external onlyOwner {\n        slippageThreshold = _slippageThreshold;\n        emit SlippageThresholdUpdated(_slippageThreshold);\n    }\n\n    /// @notice sets the required external contract address in order to swap glp for tokens\n    /// @dev only owner call this setter function\n    /// @param _dnGmxJuniorVault junior tranche of delta neutral vault\n    /// @param _rewardRouter reward router v2 of gmx protocol\n    function setAddresses(IDnGmxJuniorVault _dnGmxJuniorVault, IRewardRouterV2 _rewardRouter) external onlyOwner {\n        dnGmxJuniorVault = _dnGmxJuniorVault;\n\n        // query sGlp direclty from junior tranche\n        sGlp = ISglpExtended(dnGmxJuniorVault.asset());\n\n        // query glp from sGlp\n        glp = IERC20(sGlp.glp());\n        // query sGlp direclty from junior tranche\n        fsGlp = IERC20(sGlp.stakedGlpTracker());\n\n        rewardRouter = _rewardRouter;\n        // query glpManager from sGlp\n        glpManager = IGlpManager(sGlp.glpManager());\n\n        // query gmxVault from glpManager\n        gmxVault = IVault(glpManager.vault());\n\n        // give allowance to glpManager to pull & burn sGlp\n        sGlp.approve(address(glpManager), type(uint256).max);\n\n        emit AddressesUpdated(address(_dnGmxJuniorVault), address(_rewardRouter));\n    }\n\n    /// @notice allows to withdraw junior vault shares to any token available on gmx\n    /// @param from address which is giving shares\n    /// @param token output token\n    /// @param receiver address of the receiver\n    /// @param sGlpAmount amount of sGLP(asset) to withdraw\n    /// @return amountOut tokens received in exchange of glp\n    function withdrawToken(\n        address from,\n        address token,\n        address receiver,\n        uint256 sGlpAmount\n    ) external returns (uint256 amountOut) {\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.withdraw(sGlpAmount, address(this), from);\n\n        amountOut = _convertToToken(token, receiver);\n\n        emit TokenWithdrawn(from, receiver, token, sGlpAmount, amountOut);\n    }\n\n    /// @notice allows to redeem junior vault shares to any token available on gmx\n    /// @param from address which is giving shares\n    /// @param token output token\n    /// @param receiver address of the receiver\n    /// @param sharesAmount amount of shares to burn\n    /// @return amountOut tokens received in exchange of glp\n    function redeemToken(\n        address from,\n        address token,\n        address receiver,\n        uint256 sharesAmount\n    ) external returns (uint256 amountOut) {\n        // user has approved periphery to use junior vault shares\n        dnGmxJuniorVault.redeem(sharesAmount, address(this), from);\n\n        amountOut = _convertToToken(token, receiver);\n\n        emit TokenRedeemed(from, receiver, token, sharesAmount, amountOut);\n    }\n\n    function _convertToToken(address token, address receiver) internal returns (uint256 amountOut) {\n        // this value should be whatever glp is received by calling withdraw/redeem to junior vault\n        uint256 outputGlp = fsGlp.balanceOf(address(this));\n\n        // using min price of glp because giving in glp\n        uint256 glpPrice = _getGlpPrice(false);\n        // using max price of token because taking token out of gmx\n        uint256 tokenPrice = gmxVault.getMaxPrice(token);\n\n        // apply slippage threshold on top of estimated output amount\n        uint256 minTokenOut = outputGlp.mulDiv(glpPrice * (MAX_BPS - slippageThreshold), tokenPrice * MAX_BPS);\n\n        // will revert if atleast minTokenOut is not received\n        amountOut = rewardRouter.unstakeAndRedeemGlp(address(token), outputGlp, minTokenOut, receiver);\n    }\n\n    function _getGlpPrice(bool maximize) private view returns (uint256) {\n        // aum is in 1e30\n        uint256 aum = glpManager.getAum(maximize);\n        // totalSupply is in 1e18\n        uint256 totalSupply = glp.totalSupply();\n\n        // price per glp token = (total AUM / total supply)\n        // div by 1e24 because of usdc unit (30 - 6)\n        return aum.mulDiv(PRICE_PRECISION, totalSupply * 1e24);\n    }\n}"
    }
  ]
}