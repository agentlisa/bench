{
  "Title": "[L06] Not using SafeMath and SafeCast",
  "Content": "Throughout the codebase there are math operations that are not checked for overflow or underflow using the [`SafeMath` library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/math/SafeMath.sol). Examples can be found in the following locations, however this list is not exhaustive:\n\n\n* The [`Roots` library](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/Roots.sol)\n* The [`LinearTokenTimelock` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/LinearTokenTimelock.sol)\n* The [`alreadyReleasedAmount` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/utils/LinearTokenTimelock.sol#L61)\n* The [`_beforeTokenTransfer` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L172-L173)\n* The [`checkAllocation` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/PCVSplitter.sol#L34)\n* The [`getFinalPrice` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/refs/UniRef.sol#L144-L145)\n\n\nAlthough we did not observe instances which appear at high risk of overflow, consider checking all math operations using `SafeMath` as a best practice. In addition, the [`getFinalPrice` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/refs/UniRef.sol#L139-L148) casts an `int256` value to `uint256` without any checks. Consider using the [`SafeCast` library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/utils/SafeCast.sol) to check casting operations.\n\n\n**Update:** *Partially fixed in [PR#37](https://github.com/fei-protocol/fei-protocol-core/pull/37) and [PR#67](https://github.com/fei-protocol/fei-protocol-core/pull/67). There are still some ocurrencies where `SafeMath` and `SafeCast` are not being used.*\n\n\n#### [L07] `queueTransaction` does not check transaction value\n\n\nThe [`queueTransaction` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/dao/Timelock.sol#L62-L71) uses ETH in the [`Timelock` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/dao/Timelock.sol) to execute transactions. The contract is funded using the [`receive` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/dao/Timelock.sol#L36), which can then be used to execute queued transactions. However, there is no easy way to withdraw ETH from the contract, and `queueTransaction` does not validate that ETH being sent in a queued transaction was provided for that purpose.\n\n\nConsider making `queueTransaction` a `payable` function and validating `msg.value == value` to ensure proper allocation of funds. In addition, consider implementing a way to withdraw any remaining ETH from the contract after confirming success in the [`executeTransaction` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/dao/Timelock.sol#L36).\n\n\n**Update:** *Not fixed. In the words of the Fei Team: “We want to minimize changes to forked DAO contracts”.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utils/LinearTokenTimelock.sol",
      "content": "pragma solidity ^0.6.0;\n\n// Inspired by OpenZeppelin TokenTimelock contract\n// Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/TokenTimelock.sol\n\nimport \"./Timed.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract LinearTokenTimelock is Timed {\n\n    // ERC20 basic token contract being held\n    IERC20 public lockedToken;\n\n    // beneficiary of tokens after they are released\n    address public beneficiary;\n\n    address public pendingBeneficiary;\n\n    uint public initialBalance;\n\n    uint internal lastBalance;\n\n    event Release(address indexed _beneficiary, uint _amount);\n    event BeneficiaryUpdate(address indexed _beneficiary);\n    event PendingBeneficiaryUpdate(address indexed _pendingBeneficiary);\n\n    constructor (address _beneficiary, uint32 _duration) public Timed(_duration) {\n        require(_duration != 0, \"LinearTokenTimelock: duration is 0\");\n        beneficiary = _beneficiary;\n        _initTimed();\n    }\n\n    // Prevents incoming LP tokens from messing up calculations\n    modifier balanceCheck() {\n        if (totalToken() > lastBalance) {\n            uint delta = totalToken() - lastBalance;\n            initialBalance += delta;\n        }\n        _;\n        lastBalance = totalToken();\n    }\n\n    modifier onlyBeneficiary() {\n        require(msg.sender == beneficiary, \"LinearTokenTimelock: Caller is not a beneficiary\");\n        _;\n    }\n\n    function release() external onlyBeneficiary balanceCheck {\n        uint amount = availableForRelease();\n        require(amount != 0, \"LinearTokenTimelock: no tokens to release\");\n\n        lockedToken.transfer(beneficiary, amount);\n        emit Release(beneficiary, amount);\n    }\n\n    function totalToken() public view virtual returns(uint) {\n        return lockedToken.balanceOf(address(this));\n    }\n\n    function alreadyReleasedAmount() public view returns(uint) {\n        return initialBalance - totalToken();\n    }\n\n    function availableForRelease() public view returns(uint) {\n        uint elapsed = timestamp();\n        uint _duration = duration;\n\n        if (elapsed > _duration) {\n            elapsed = _duration;\n        }\n\n        uint totalAvailable = initialBalance * elapsed / _duration;\n        uint netAvailable = totalAvailable - alreadyReleasedAmount();\n        return netAvailable;\n    }\n\n    function setPendingBeneficiary(address _pendingBeneficiary) public onlyBeneficiary {\n        pendingBeneficiary = _pendingBeneficiary;\n        emit PendingBeneficiaryUpdate(_pendingBeneficiary);\n    }\n\n    function acceptBeneficiary() public virtual {\n        _setBeneficiary(msg.sender);\n    }\n\n    function _setBeneficiary(address newBeneficiary) internal {\n        require(newBeneficiary == pendingBeneficiary, \"LinearTokenTimelock: Caller is not pending beneficiary\");\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdate(newBeneficiary);\n        pendingBeneficiary = address(0);\n    }\n\n    function setLockedToken(address tokenAddress) internal {\n        lockedToken = IERC20(tokenAddress);\n    }\n}"
    },
    {
      "filename": "contracts/pool/Pool.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IPool.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../utils/SafeMath128.sol\";\nimport \"../external/SafeMathCopy.sol\";\nimport \"../external/Decimal.sol\";\n\n/// @title abstract implementation of IPool interface\n/// @author Fei Protocol\nabstract contract Pool is IPool, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\tusing SafeMath128 for uint128;\n\tusing SafeCast for uint;\n\n\tbool internal initialized;\n\n\tIERC20 public override rewardToken;\n\tIERC20 public override stakedToken;\n\n\tuint128 public override claimedRewards;\n\tuint128 public override totalStaked;\n\n    mapping (address => uint) public override stakedBalance;\n\n\t/// @notice Pool constructor\n\t/// @param _duration duration of the pool reward distribution\n\t/// @param _name the name of the pool token\n\t/// @param _ticker the token ticker for the pool token\n\tconstructor(\n\t\tuint32 _duration,\n\t\tstring memory _name,\n\t\tstring memory _ticker\n\t) public ERC20(_name, _ticker) Timed(_duration) {}\n\n\tfunction claim(address from, address to) external override returns(uint amountReward) {\n\t\tamountReward = _claim(from, to);\n\t\temit Claim(from, to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction deposit(address to, uint amount) external override {\n\t\taddress from = msg.sender;\n\t\t_deposit(from, to, amount);\n\t\temit Deposit(from, to, amount);\n\t}\n\n\tfunction withdraw(address to) external override returns(uint amountStaked, uint amountReward) {\n\t\taddress from = msg.sender;\n\t\tamountReward = _claim(from, to);\n\t\tamountStaked = _withdraw(from, to);\n\t\temit Withdraw(from, to, amountStaked, amountReward);\n\t\treturn (amountStaked, amountReward);\n\t}\n\n\tfunction init() public override virtual {\n\t\trequire(!initialized, \"Pool: Already initialized\");\n\t\t_initTimed();\n\t\tinitialized = true;\n\t}\n\n    function redeemableReward(address account) public view override returns(uint amountReward, uint amountPool) {\n\t\tamountPool = _redeemablePoolTokens(account);\n\t\treturn (releasedReward() * amountPool / _totalRedeemablePoolTokens(), amountPool);\n    }\n\n\tfunction releasedReward() public view override returns (uint) {\n\t\tuint total = rewardBalance();\n\t\tuint unreleased = unreleasedReward();\n\t\trequire(total >= unreleased, \"Pool: Released Reward underflow\");\n\t\treturn total - unreleased;\n\t}\n\n\tfunction unreleasedReward() public view override returns (uint) {\n\t\tif (isTimeEnded()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn _unreleasedReward(totalReward(), uint(duration), uint(timestamp()));\n\t}\n\n\tfunction totalReward() public view override returns (uint) {\n\t\treturn rewardBalance() + uint(claimedRewards);\n\t}\n\n\tfunction rewardBalance() public view override returns (uint) {\n\t\treturn rewardToken.balanceOf(address(this));\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _totalRedeemablePoolTokens() internal view returns(uint) {\n\t\tuint total = totalSupply();\n\t\tuint balance = _twfb(uint(totalStaked));\n\t\trequire(total >= balance, \"Pool: Total redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _redeemablePoolTokens(address account) internal view returns(uint) {\n\t\tuint total = balanceOf(account);\n\t\tuint balance = _twfb(stakedBalance[account]);\n\t\trequire(total >= balance, \"Pool: Redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _unreleasedReward(uint _totalReward, uint _duration, uint _time) internal view virtual returns (uint);\n\n\tfunction _deposit(address from, address to, uint amount) internal {\n\t\trequire(initialized, \"Pool: Uninitialized\");\n\t\trequire(amount <= stakedToken.balanceOf(from), \"Pool: Balance too low to stake\");\n\n\t\tstakedToken.transferFrom(from, address(this), amount);\n\n\t\tstakedBalance[to] += amount;\n\t\t_incrementStaked(amount);\n\t\t\n\t\tuint poolTokens = _twfb(amount);\n\t\trequire(poolTokens != 0, \"Pool: Window has ended\");\n\n\t\t_mint(to, poolTokens);\n\t}\n\n\tfunction _withdraw(address from, address to) internal returns(uint amountStaked) {\n\t\tamountStaked = stakedBalance[from];\n\t\tstakedBalance[from] = 0;\n\t\tstakedToken.transfer(to, amountStaked);\n\n\t\tuint amountPool = balanceOf(from);\n\t\tif (amountPool != 0) {\n\t\t\t_burn(from, amountPool);\n\t\t}\n\t\treturn amountStaked;\t\n\t}\n\n\tfunction _claim(address from, address to) internal returns(uint) {\n\t\t(uint amountReward, uint amountPool) = redeemableReward(from);\n\t\trequire(amountPool != 0, \"Pool: User has no redeemable pool tokens\");\n\n\t\tburnFrom(from, amountPool);\n\t\t_incrementClaimed(amountReward);\n\n\t\trewardToken.transfer(to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction _incrementClaimed(uint amount) internal {\n\t\tclaimedRewards = claimedRewards.add(amount.toUint128());\n\t}\n\n\tfunction _incrementStaked(uint amount) internal {\n\t\ttotalStaked = totalStaked.add(amount.toUint128());\n\t}\n\n\tfunction _twfb(uint amount) internal view returns(uint) {\n\t\treturn amount * uint(remainingTime());\n\t}\n\n\t// Updates stored staked balance pro-rata for transfer and transferFrom\n\tfunction _beforeTokenTransfer(address from, address to, uint amount) internal override {\n        if (from != address(0) && to != address(0)) {\n \t\t\tDecimal.D256 memory ratio = Decimal.ratio(amount, balanceOf(from));\n \t\t\tuint amountStaked = ratio.mul(stakedBalance[from]).asUint256();\n\t\t\t\n \t\t\tstakedBalance[from] -= amountStaked;\n \t\t\tstakedBalance[to] += amountStaked;\n        }\n    }\n\n\tfunction _setTokens(address _rewardToken, address _stakedToken) internal {\n\t\trewardToken = IERC20(_rewardToken);\n\t\tstakedToken = IERC20(_stakedToken);\t\n\t}\n}"
    },
    {
      "filename": "contracts/pcv/PCVSplitter.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title abstract contract for splitting PCV into different deposits\n/// @author Fei Protocol\nabstract contract PCVSplitter {\n\n\t/// @notice total allocation allowed representing 100%\n\tuint public constant ALLOCATION_GRANULARITY = 10_000; \n\n\tuint[] private ratios;\n\taddress[] private pcvDeposits;\n\n\tevent AllocationUpdate(address[] _pcvDeposits, uint[] _ratios);\n\n\t/// @notice PCVSplitter constructor\n\t/// @param _pcvDeposits list of PCV Deposits to split to\n\t/// @param _ratios ratios for splitting PCV Deposit allocations\n\tconstructor(address[] memory _pcvDeposits, uint[] memory _ratios) public {\n\t\t_setAllocation(_pcvDeposits, _ratios);\n\t}\n\n\t/// @notice make sure an allocation has matching lengths and totals the ALLOCATION_GRANULARITY\n\t/// @param _pcvDeposits new list of pcv deposits to send to\n\t/// @param _ratios new ratios corresponding to the PCV deposits\n\t/// @return true if it is a valid allocation\n\tfunction checkAllocation(address[] memory _pcvDeposits, uint[] memory _ratios) public pure returns (bool) {\n\t\trequire(_pcvDeposits.length == _ratios.length, \"PCVSplitter: PCV Deposits and ratios are different lengths\");\n\n\t\tuint total;\n\t\tfor (uint i; i < _ratios.length; i++) {\n\t\t\ttotal += _ratios[i];\n\t\t}\n\n\t\trequire(total == ALLOCATION_GRANULARITY, \"PCVSplitter: ratios do not total 100%\");\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/// @notice gets the pcvDeposits and ratios of the splitter\n\tfunction getAllocation() public view returns (address[] memory, uint[] memory) {\n\t\treturn (pcvDeposits, ratios);\n\t}\n\n\t/// @notice distribute funds to single PCV deposit\n\t/// @param amount amount of funds to send\n\t/// @param pcvDeposit the pcv deposit to send funds\n\tfunction _allocateSingle(uint amount, address pcvDeposit) internal virtual ;\n\n\t/// @notice sets a new allocation for the splitter\n\t/// @param _pcvDeposits new list of pcv deposits to send to\n\t/// @param _ratios new ratios corresponding to the PCV deposits. Must total ALLOCATION_GRANULARITY\n\tfunction _setAllocation(address[] memory _pcvDeposits, uint[] memory _ratios) internal {\n\t\tcheckAllocation(_pcvDeposits, _ratios);\n\n\t\tpcvDeposits = _pcvDeposits;\n\t\tratios = _ratios;\n\n\t\temit AllocationUpdate(_pcvDeposits, _ratios);\n\t}\n\n\t/// @notice distribute funds to all pcv deposits at specified allocation ratios\n\t/// @param total amount of funds to send\n\tfunction _allocate(uint total) internal {\n\t\tuint granularity = ALLOCATION_GRANULARITY;\n\t\tfor (uint i; i < ratios.length; i++) {\n\t\t\tuint amount = total * ratios[i] / granularity;\n\t\t\t_allocateSingle(amount, pcvDeposits[i]);\n\t\t}\n\t}\n}"
    },
    {
      "filename": "contracts/refs/UniRef.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"./OracleRef.sol\";\nimport \"./IUniRef.sol\";\n\n/// @title UniRef abstract implementation contract\n/// @author Fei Protocol\nabstract contract UniRef is IUniRef, OracleRef {\n\tusing Decimal for Decimal.D256;\n\tusing Babylonian for uint;\n\n\tIUniswapV2Router02 public override router;\n\tIUniswapV2Pair public override pair;\n\n\t/// @notice UniRef constructor\n\t/// @param _core Fei Core to reference\n    /// @param _pair Uniswap pair to reference\n    /// @param _router Uniswap Router to reference\n    /// @param _oracle oracle to reference\n\tconstructor(address _core, address _pair, address _router, address _oracle) \n        public OracleRef(_core, _oracle) \n    {\n        setupPair(_pair);\n\n        router = IUniswapV2Router02(_router);\n\n        approveToken(address(fei()));\n        approveToken(token());\n        approveToken(_pair);\n    }\n\n\tfunction setPair(address _pair) external override onlyGovernor {\n\t\tsetupPair(_pair);\n\n        approveToken(token());\n        approveToken(_pair);\n\t}\n\n\tfunction token() public override view returns (address) {\n\t\taddress token0 = pair.token0();\n\t\tif (address(fei()) == token0) {\n\t\t\treturn pair.token1();\n\t\t}\n\t\treturn token0;\n\t}\n\n\tfunction getReserves() public override view returns (uint feiReserves, uint tokenReserves) {\n        address token0 = pair.token0();\n        (uint reserve0, uint reserve1,) = pair.getReserves();\n        (feiReserves, tokenReserves) = address(fei()) == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        uint feiBalance = fei().balanceOf(address(pair));\n        if(feiBalance > feiReserves) {\n            feiReserves = feiBalance;\n        }\n        return (feiReserves, tokenReserves);\n\t}\n\n\tfunction liquidityOwned() public override view returns (uint) {\n\t\treturn pair.balanceOf(address(this));\n\t}\n\n    /// @notice ratio of all pair liquidity owned by this contract\n\tfunction ratioOwned() internal view returns (Decimal.D256 memory) {\t\n    \tuint balance = liquidityOwned();\n    \tuint total = pair.totalSupply();\n    \treturn Decimal.ratio(balance, total);\n    }\n\n    /// @notice returns true if price is below the peg\n    /// @dev counterintuitively checks if peg < price because price is reported as FEI per X\n    function isBelowPeg(Decimal.D256 memory peg) internal view returns (bool) {\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        return peg.lessThan(price);\n    }\n\n    /// @notice approves a token for the router\n    function approveToken(address _token) internal {\n    \tIERC20(_token).approve(address(router), uint(-1));\n    }\n\n    function setupPair(address _pair) internal {\n    \tpair = IUniswapV2Pair(_pair);\n        emit PairUpdate(_pair);\n    }\n\n    function isPair(address account) internal view returns(bool) {\n        return address(pair) == account;\n    }\n\n    /// @notice utility for calculating absolute distance from peg based on reserves\n    /// @param reserveTarget pair reserves of the asset desired to trade with\n    /// @param reserveOther pair reserves of the non-traded asset\n    /// @param peg the target peg reported as Target per Other \n    function getAmountToPeg(\n        uint reserveTarget, \n        uint reserveOther, \n        Decimal.D256 memory peg\n    ) internal pure returns (uint) {\n        uint radicand = peg.mul(reserveTarget).mul(reserveOther).asUint256();\n        uint root = radicand.sqrt();\n        if (root > reserveTarget) {\n            return root - reserveTarget;\n        }\n        return reserveTarget - root;\n    }\n\n    /// @notice calculate amount of Fei needed to trade back to the peg\n    function getAmountToPegFei() internal view returns (uint) {\n        (uint feiReserves, uint tokenReserves) = getReserves();\n        return getAmountToPeg(feiReserves, tokenReserves, peg());\n    }\n\n    /// @notice calculate amount of the not Fei token needed to trade back to the peg\n    function getAmountToPegOther() internal view returns (uint) {\n        (uint feiReserves, uint tokenReserves) = getReserves();\n        return getAmountToPeg(tokenReserves, feiReserves, invert(peg()));\n    }\n\n    /// @notice get uniswap price and reserves\n    /// @return price reported as Fei per X\n    /// @return reserveFei fei reserves\n    /// @return reserveOther non-fei reserves\n    function getUniswapPrice() internal view returns(\n        Decimal.D256 memory, \n        uint reserveFei, \n        uint reserveOther\n    ) {\n        (reserveFei, reserveOther) = getReserves();\n        return (Decimal.ratio(reserveFei, reserveOther), reserveFei, reserveOther);\n    }\n\n    /// @notice get final uniswap price after hypothetical FEI trade\n    /// @param amountFei a signed integer representing FEI trade. Positive=sell, negative=buy\n    /// @param reserveFei fei reserves\n    /// @param reserveOther non-fei reserves\n    function getFinalPrice(\n    \tint256 amountFei, \n    \tuint reserveFei, \n    \tuint reserveOther\n    ) internal pure returns (Decimal.D256 memory) {\n    \tuint k = reserveFei * reserveOther;\n    \tuint adjustedReserveFei = uint(int256(reserveFei) + amountFei);\n    \tuint adjustedReserveOther = k / adjustedReserveFei;\n    \treturn Decimal.ratio(adjustedReserveFei, adjustedReserveOther); // alt: adjustedReserveFei^2 / k\n    }\n\n    /// @notice return the percent distance from peg before and after a hypothetical trade\n    /// @param amountIn a signed amount of FEI to be traded. Positive=sell, negative=buy \n    /// @return initialDeviation the percent distance from peg before trade\n    /// @return finalDeviation the percent distance from peg after hypothetical trade\n    /// @dev deviations will return Decimal.zero() if above peg\n    function getPriceDeviations(int256 amountIn) internal view returns (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation\n    ) {\n        (Decimal.D256 memory price, uint reserveFei, uint reserveOther) = getUniswapPrice();\n        initialDeviation = calculateDeviation(price, peg());\n\n        Decimal.D256 memory finalPrice = getFinalPrice(amountIn, reserveFei, reserveOther);\n        finalDeviation = calculateDeviation(finalPrice, peg());\n        \n        return (initialDeviation, finalDeviation);\n    }\n\n    /// @notice return current percent distance from peg\n    /// @dev will return Decimal.zero() if above peg\n    function getDistanceToPeg() internal view returns(Decimal.D256 memory distance) {\n        (Decimal.D256 memory price, , ) = getUniswapPrice();\n        return calculateDeviation(price, peg()); \n    }\n\n    /// @notice get deviation from peg as a percent given price\n    /// @dev will return Decimal.zero() if above peg\n    function calculateDeviation(\n        Decimal.D256 memory price, \n        Decimal.D256 memory peg\n    ) internal pure returns (Decimal.D256 memory) {\n        // If price <= peg, then FEI is more expensive and above peg\n        // In this case we can just return zero for deviation\n        if (price.lessThanOrEqualTo(peg)) {\n            return Decimal.zero();\n        }\n        Decimal.D256 memory delta = price.sub(peg, \"UniRef: price exceeds peg\"); // Should never error\n        return delta.div(peg);\n    }\n}"
    },
    {
      "filename": "contracts/refs/UniRef.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"./OracleRef.sol\";\nimport \"./IUniRef.sol\";\n\n/// @title UniRef abstract implementation contract\n/// @author Fei Protocol\nabstract contract UniRef is IUniRef, OracleRef {\n\tusing Decimal for Decimal.D256;\n\tusing Babylonian for uint;\n\n\tIUniswapV2Router02 public override router;\n\tIUniswapV2Pair public override pair;\n\n\t/// @notice UniRef constructor\n\t/// @param _core Fei Core to reference\n    /// @param _pair Uniswap pair to reference\n    /// @param _router Uniswap Router to reference\n    /// @param _oracle oracle to reference\n\tconstructor(address _core, address _pair, address _router, address _oracle) \n        public OracleRef(_core, _oracle) \n    {\n        setupPair(_pair);\n\n        router = IUniswapV2Router02(_router);\n\n        approveToken(address(fei()));\n        approveToken(token());\n        approveToken(_pair);\n    }\n\n\tfunction setPair(address _pair) external override onlyGovernor {\n\t\tsetupPair(_pair);\n\n        approveToken(token());\n        approveToken(_pair);\n\t}\n\n\tfunction token() public override view returns (address) {\n\t\taddress token0 = pair.token0();\n\t\tif (address(fei()) == token0) {\n\t\t\treturn pair.token1();\n\t\t}\n\t\treturn token0;\n\t}\n\n\tfunction getReserves() public override view returns (uint feiReserves, uint tokenReserves) {\n        address token0 = pair.token0();\n        (uint reserve0, uint reserve1,) = pair.getReserves();\n        (feiReserves, tokenReserves) = address(fei()) == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        uint feiBalance = fei().balanceOf(address(pair));\n        if(feiBalance > feiReserves) {\n            feiReserves = feiBalance;\n        }\n        return (feiReserves, tokenReserves);\n\t}\n\n\tfunction liquidityOwned() public override view returns (uint) {\n\t\treturn pair.balanceOf(address(this));\n\t}\n\n    /// @notice ratio of all pair liquidity owned by this contract\n\tfunction ratioOwned() internal view returns (Decimal.D256 memory) {\t\n    \tuint balance = liquidityOwned();\n    \tuint total = pair.totalSupply();\n    \treturn Decimal.ratio(balance, total);\n    }\n\n    /// @notice returns true if price is below the peg\n    /// @dev counterintuitively checks if peg < price because price is reported as FEI per X\n    function isBelowPeg(Decimal.D256 memory peg) internal view returns (bool) {\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        return peg.lessThan(price);\n    }\n\n    /// @notice approves a token for the router\n    function approveToken(address _token) internal {\n    \tIERC20(_token).approve(address(router), uint(-1));\n    }\n\n    function setupPair(address _pair) internal {\n    \tpair = IUniswapV2Pair(_pair);\n        emit PairUpdate(_pair);\n    }\n\n    function isPair(address account) internal view returns(bool) {\n        return address(pair) == account;\n    }\n\n    /// @notice utility for calculating absolute distance from peg based on reserves\n    /// @param reserveTarget pair reserves of the asset desired to trade with\n    /// @param reserveOther pair reserves of the non-traded asset\n    /// @param peg the target peg reported as Target per Other \n    function getAmountToPeg(\n        uint reserveTarget, \n        uint reserveOther, \n        Decimal.D256 memory peg\n    ) internal pure returns (uint) {\n        uint radicand = peg.mul(reserveTarget).mul(reserveOther).asUint256();\n        uint root = radicand.sqrt();\n        if (root > reserveTarget) {\n            return root - reserveTarget;\n        }\n        return reserveTarget - root;\n    }\n\n    /// @notice calculate amount of Fei needed to trade back to the peg\n    function getAmountToPegFei() internal view returns (uint) {\n        (uint feiReserves, uint tokenReserves) = getReserves();\n        return getAmountToPeg(feiReserves, tokenReserves, peg());\n    }\n\n    /// @notice calculate amount of the not Fei token needed to trade back to the peg\n    function getAmountToPegOther() internal view returns (uint) {\n        (uint feiReserves, uint tokenReserves) = getReserves();\n        return getAmountToPeg(tokenReserves, feiReserves, invert(peg()));\n    }\n\n    /// @notice get uniswap price and reserves\n    /// @return price reported as Fei per X\n    /// @return reserveFei fei reserves\n    /// @return reserveOther non-fei reserves\n    function getUniswapPrice() internal view returns(\n        Decimal.D256 memory, \n        uint reserveFei, \n        uint reserveOther\n    ) {\n        (reserveFei, reserveOther) = getReserves();\n        return (Decimal.ratio(reserveFei, reserveOther), reserveFei, reserveOther);\n    }\n\n    /// @notice get final uniswap price after hypothetical FEI trade\n    /// @param amountFei a signed integer representing FEI trade. Positive=sell, negative=buy\n    /// @param reserveFei fei reserves\n    /// @param reserveOther non-fei reserves\n    function getFinalPrice(\n    \tint256 amountFei, \n    \tuint reserveFei, \n    \tuint reserveOther\n    ) internal pure returns (Decimal.D256 memory) {\n    \tuint k = reserveFei * reserveOther;\n    \tuint adjustedReserveFei = uint(int256(reserveFei) + amountFei);\n    \tuint adjustedReserveOther = k / adjustedReserveFei;\n    \treturn Decimal.ratio(adjustedReserveFei, adjustedReserveOther); // alt: adjustedReserveFei^2 / k\n    }\n\n    /// @notice return the percent distance from peg before and after a hypothetical trade\n    /// @param amountIn a signed amount of FEI to be traded. Positive=sell, negative=buy \n    /// @return initialDeviation the percent distance from peg before trade\n    /// @return finalDeviation the percent distance from peg after hypothetical trade\n    /// @dev deviations will return Decimal.zero() if above peg\n    function getPriceDeviations(int256 amountIn) internal view returns (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation\n    ) {\n        (Decimal.D256 memory price, uint reserveFei, uint reserveOther) = getUniswapPrice();\n        initialDeviation = calculateDeviation(price, peg());\n\n        Decimal.D256 memory finalPrice = getFinalPrice(amountIn, reserveFei, reserveOther);\n        finalDeviation = calculateDeviation(finalPrice, peg());\n        \n        return (initialDeviation, finalDeviation);\n    }\n\n    /// @notice return current percent distance from peg\n    /// @dev will return Decimal.zero() if above peg\n    function getDistanceToPeg() internal view returns(Decimal.D256 memory distance) {\n        (Decimal.D256 memory price, , ) = getUniswapPrice();\n        return calculateDeviation(price, peg()); \n    }\n\n    /// @notice get deviation from peg as a percent given price\n    /// @dev will return Decimal.zero() if above peg\n    function calculateDeviation(\n        Decimal.D256 memory price, \n        Decimal.D256 memory peg\n    ) internal pure returns (Decimal.D256 memory) {\n        // If price <= peg, then FEI is more expensive and above peg\n        // In this case we can just return zero for deviation\n        if (price.lessThanOrEqualTo(peg)) {\n            return Decimal.zero();\n        }\n        Decimal.D256 memory delta = price.sub(peg, \"UniRef: price exceeds peg\"); // Should never error\n        return delta.div(peg);\n    }\n}"
    },
    {
      "filename": "contracts/dao/Timelock.sol",
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// Forked from Compound\n// See https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol\ncontract Timelock {\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 1 hours;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) public {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: value}(callData); //solhint-disable avoid-call-value\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp;\n    }\n}"
    },
    {
      "filename": "contracts/dao/Timelock.sol",
      "content": "pragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// Forked from Compound\n// See https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol\ncontract Timelock {\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 1 hours;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) public {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;"
    }
  ]
}