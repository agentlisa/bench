{
  "Title": "M-5: TitlesGraph::acknowledgeEdge() methods do not write acknowledgments to storage",
  "Content": "# Issue M-5: TitlesGraph::acknowledgeEdge() methods do not write acknowledgments to storage \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/212 \n\n## Found by \n4rdiii, AlexCzm, CodeWasp, KupiaSec, alexzoid, brakeless, cducrest-brainbot, den\\_sosnovskyi, fugazzi, i3arba, ironside, kennedy1030, radin200, recursiveEth, ubl4nk\n## Summary\nWhen `acknowledgeEdge()` is called, the downstream call to the `_setAcknowledged()` method caches `edges[edgeId_]` in memory, instead of storage, which does not preserve changes to the `Edge` struct after the transaction concludes. \n\n## Vulnerability Detail\n```solidity\nfunction acknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n    external\n    override\n    returns (Edge memory edge)\n{\n    if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n    return _setAcknowledged(edgeId_, data_, true);\n}\n\nfunction _setAcknowledged(bytes32 edgeId_, bytes calldata data_, bool acknowledged_)\n    internal\n    returns (Edge memory edge)\n{\n    if (!_edgeIds.contains(edgeId_)) revert NotFound();\n    edge = edges[edgeId_];\n    edge.acknowledged = acknowledged_;    // @audit does this actually write to storage? the state isn't saved? \n\n    if (acknowledged_) {\n        emit EdgeAcknowledged(edge, msg.sender, data_);\n    } else {\n        emit EdgeUnacknowledged(edge, msg.sender, data_);\n    }\n}\n```\n\nIn the code snippet above, `edges[edgeId_]` is cached in `edge`, then modified.\n\nThe issue is that `edge`, the return variable, is marked as memory, which does not save the state after the transaction ends.\n\nTherefore, the `acknowledged` value never changes and the `acknowledgeEdge()` methods do not work as intended.\n\nAdd the following test to `TitlesGraph.t.sol`. \n\nRun with the following command: `forge test --match-test test_acknowledgeEdgeFailure -vvvv`\n```solidity\nfunction test_acknowledgeEdgeFailure() public {\n    Node memory from = Node({\n        nodeType: NodeType.COLLECTION_ERC1155,\n        entity: Target({target: address(1), chainId: block.chainid}),\n        creator: Target({target: address(2), chainId: block.chainid}),\n        data: \"\"\n    });\n\n    Node memory to = Node({\n        nodeType: NodeType.TOKEN_ERC1155,\n        entity: Target({target: address(3), chainId: block.chainid}),\n        creator: Target({target: address(4), chainId: block.chainid}),\n        data: abi.encode(42)\n    });\n\n    // Only the `from` node's entity can create the edge.\n    vm.prank(from.entity.target);\n    titlesGraph.createEdge(from, to, \"\");\n\n    vm.expectEmit(true, true, true, true);\n    emit IEdgeManager.EdgeAcknowledged(\n        Edge({from: from, to: to, acknowledged: true, data: \"\"}), to.creator.target, \"\"\n    );\n\n    // Only the `to` node's creator (or the entity itself) can acknowledge it\n    vm.prank(to.creator.target);\n    titlesGraph.acknowledgeEdge(keccak256(abi.encode(from, to)), \"\");\n\n    (Node memory nodeTo,\n        Node memory nodeFrom,\n        bool ack,\n        bytes memory dataResult\n    ) = titlesGraph.edges(titlesGraph.getEdgeId(from, to));\n    console.log(ack);\n\n    // edge[edgeId].acknowledged should be set to true after successful call to titlesGraph.acknowledgeEdge()\n    // However, the value is still false.\n    assert(true == ack);\n}\n```\n\n```solidity\n[FAIL. Reason: panic: assertion failed (0x01)] test_acknowledgeEdgeFailure() (gas: 429897)\nLogs:\n  false\n```\n\n## Impact\nEdges are unable to be acknowledged.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L103-L124\n\n## Tool used\nManual Review\n\n## Recommendation\nThe simplest fix would be to change `memory` to `storage`.\n```solidity\nfunction _setAcknowledged(bytes32 edgeId_, bytes calldata data_, bool acknowledged_)\n     internal\n-    returns (Edge memory edge)\n+    returns (Edge storage edge) \n {\n     if (!_edgeIds.contains(edgeId_)) revert NotFound();\n     edge = edges[edgeId_];\n     edge.acknowledged = acknowledged_;    \n\n     if (acknowledged_) {\n         emit EdgeAcknowledged(edge, msg.sender, data_);\n     } else {\n         emit EdgeUnacknowledged(edge, msg.sender, data_);\n     }\n }\n```\n\n\n\n\n## Discussion\n\n**pqseags**\n\nThis will be fixed\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "wallflower-contract-v2/src/graph/TitlesGraph.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport {EIP712} from \"lib/solady/src/utils/EIP712.sol\";\nimport {SignatureCheckerLib} from \"lib/solady/src/utils/SignatureCheckerLib.sol\";\nimport {UUPSUpgradeable} from \"lib/solady/src/utils/UUPSUpgradeable.sol\";\n\nimport {IOpenGraph} from \"src/interfaces/IOpenGraph.sol\";\nimport {IEdgeManager} from \"src/interfaces/IEdgeManager.sol\";\nimport {ADMIN_ROLE, Edge, Node, Unauthorized} from \"src/shared/Common.sol\";\n\n/// @title TitlesGraph\n/// @notice Titles.xyz implementation of the OpenGraph standard\n/// @dev The TitlesGraph contract implements the OpenGraph standard and is responsible for managing the creation and acknowledgment of {Node}s and {Edge}s in the graph.\ncontract TitlesGraph is IOpenGraph, IEdgeManager, OwnableRoles, EIP712, UUPSUpgradeable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using SignatureCheckerLib for address;\n\n    error Exists();\n    error NotFound();\n\n    /// @notice The set of edge IDs in the graph. Enumerable to enable on-chain graph traversal in the future.\n    EnumerableSet.Bytes32Set private _edgeIds;\n\n    /// @notice Edges are relationships between two nodes in the graph.\n    mapping(bytes32 id => Edge edge) public edges;\n\n    /// @notice An internal mapping to prevent signature reuse.\n    mapping(bytes32 signature => bool used) private _isUsed;\n\n    // @notice The hash of the acknowledgement struct. Used for EIP-712.\n    bytes32 public constant ACK_TYPEHASH = keccak256(\"Ack(bytes32 edgeId,bytes data)\");\n\n    // @notice The EIP-712 domain type hash. (Exposed here for convenience.)\n    bytes32 public constant DOMAIN_TYPEHASH = _DOMAIN_TYPEHASH;\n\n    /// @notice Modified to check the signature for a proxied acknowledgment.\n    modifier checkSignature(bytes32 edgeId, bytes calldata data, bytes calldata signature) {\n        bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));\n        if (\n            !edges[edgeId].to.creator.target.isValidSignatureNowCalldata(digest, signature)\n                || _isUsed[keccak256(signature)]\n        ) {\n            revert Unauthorized();\n        }\n        _;\n        _isUsed[keccak256(signature)] = true;\n    }\n\n    constructor(address owner_, address admin_) {\n        _initializeOwner(owner_);\n        _grantRoles(admin_, ADMIN_ROLE);\n    }\n\n    /// @inheritdoc IOpenGraph\n    /// @notice Create a new {Edge} between two {Node}s in the graph.\n    /// @param from_ The {Node} from which the edge originates.\n    /// @param to_ The {Node} to which the edge points.\n    /// @param data_ Metadata associated with the edge.\n    /// @return edge The created edge.\n    /// @dev This function is used to create a new edge between two nodes in the graph and will revert if not unique or if called by any address other than the contract referenced as the `from` node. A {NodeTouched} event is emitted for each node and an {EdgeCreated} event is emitted for the edge itself.\n    function createEdge(Node calldata from_, Node calldata to_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isEntity(from_, msg.sender)) revert Unauthorized();\n        return _createEdge(from_, to_, data_);\n    }\n\n    /// @notice Create multiple edges within the graph.\n    /// @param edges_ The edges to create.\n    /// @dev This function is used to create multiple edges within the graph and will revert if any of the edges are not unique. It emits a {NodeTouched} event for each node and an {EdgeCreated} event for each edge.\n    function createEdges(Edge[] calldata edges_) external onlyRolesOrOwner(ADMIN_ROLE) {\n        for (uint256 i = 0; i < edges_.length; i++) {\n            _createEdge(edges_[i].from, edges_[i].to, edges_[i].data);\n        }\n    }\n\n    function _createEdge(Node memory from_, Node memory to_, bytes memory data_)\n        internal\n        returns (Edge memory edge)\n    {\n        bytes32 edgeId = keccak256(abi.encode(from_, to_));\n        if (!_edgeIds.add(edgeId)) revert Exists();\n\n        edge = Edge({from: from_, to: to_, acknowledged: false, data: data_});\n        edges[edgeId] = edge;\n\n        emit NodeTouched(from_, data_);\n        emit NodeTouched(to_, data_);\n        emit EdgeCreated(edge, data_);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Acknowledge an edge.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @return edge The acknowledged edge.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @notice Acknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to acknowledge.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to acknowledge an edge that was previously created and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeAcknowledged} event for the edge.\n    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, true);\n    }\n\n    /// @inheritdoc IEdgeManager\n    /// @notice Unacknowledge an edge.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_)\n        external\n        override\n        returns (Edge memory edge)\n    {\n        if (!_isCreatorOrEntity(edges[edgeId_].to, msg.sender)) revert Unauthorized();\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Unacknowledge an edge using an ECDSA signature.\n    /// @param edgeId_ The ID of the edge to unacknowledge.\n    /// @param data_ Additional data to include with the unacknowledgment.\n    /// @param signature_ The ECDSA signature to verify.\n    /// @dev The request is valid if the given signature was produced using the edge ID as the message and the creator of the `to` node as the signer.\n    /// @dev This function is used to unacknowledge an edge that was previously acknowledged and will revert if the edge does not exist or if the signature is invalid. It emits an {EdgeUnacknowledged} event for the edge.\n    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)\n        external\n        checkSignature(edgeId_, data_, signature_)\n        returns (Edge memory edge)\n    {\n        return _setAcknowledged(edgeId_, data_, false);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address to grant the roles.\n    /// @param roles The roles to grant.\n    /// @dev This function is used to grant roles to an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function grantRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _grantRoles(guy, roles);\n    }\n\n    /// @notice Override the {OwnableRoles} implementation to extend access to the `ADMIN_ROLE`.\n    /// @param guy The address from which to revoke the roles.\n    /// @param roles The roles to revoke.\n    /// @dev This function is used to revoke roles from an address and will revert if the caller is not the owner and does not have the `ADMIN_ROLE`.\n    function revokeRoles(address guy, uint256 roles)\n        public\n        payable\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        _removeRoles(guy, roles);\n    }\n\n    /// @notice Get the ID of an edge given the source and target nodes.\n    /// @param from_ The source node of the edge.\n    /// @param to_ The target node of the edge.\n    /// @return edgeId The ID of the edge (i.e. the keccak256 hash of the `from` and `to` nodes).\n    function getEdgeId(Node memory from_, Node memory to_) public pure returns (bytes32) {\n        return keccak256(abi.encode(from_, to_));\n    }\n\n    /// @notice Get the ID of an edge.\n    /// @param edge_ The edge for which to get the ID.\n    /// @return edgeId The ID of the edge (i.e. the keccak256 hash of the `from` and `to` nodes).\n    function getEdgeId(Edge memory edge_) public pure returns (bytes32) {\n        return getEdgeId(edge_.from, edge_.to);\n    }\n\n    /// @notice Set the acknowledged status of an edge.\n    /// @param edgeId_ The ID of the edge to set the acknowledged status for.\n    /// @param data_ Additional data to include with the acknowledgment.\n    /// @param acknowledged_ The new acknowledged status of the edge.\n    /// @return edge The edge with the updated acknowledged status.\n    function _setAcknowledged(bytes32 edgeId_, bytes calldata data_, bool acknowledged_)\n        internal\n        returns (Edge memory edge)\n    {\n        if (!_edgeIds.contains(edgeId_)) revert NotFound();\n        edge = edges[edgeId_];\n        edge.acknowledged = acknowledged_;\n\n        if (acknowledged_) {\n            emit EdgeAcknowledged(edge, msg.sender, data_);\n        } else {\n            emit EdgeUnacknowledged(edge, msg.sender, data_);\n        }\n    }\n\n    /// @notice Allows the admin to upgrade the contract.\n    /// @dev This function overrides the {UUPSUpgradeable} implementation to restrict upgrade rights to the graph owner.\n    function _authorizeUpgrade(address) internal view override onlyOwnerOrRoles(ADMIN_ROLE) {\n        // The modifier handles the authorization.\n    }\n\n    /// @notice Returns the domain name and version for EIP-712.\n    function _domainNameAndVersion()\n        internal\n        pure\n        override\n        returns (string memory name, string memory version)\n    {\n        name = \"TitlesGraph\";\n        version = \"1\";\n    }\n\n    /// @notice Checks if the given address is the creator of a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the creator of the node, false otherwise.\n    function _isCreator(Node memory node, address guy) internal pure returns (bool) {\n        return node.creator.target == guy;\n    }\n\n    /// @notice Checks if the given address is the on-chain entity represented by a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the entity of the node, false otherwise.\n    function _isEntity(Node memory node, address guy) internal pure returns (bool) {\n        return node.entity.target == guy;\n    }\n\n    /// @notice Checks if the given address is either the creator or on-chain entity represented by a node.\n    /// @param node The node to check.\n    /// @param guy The address to check.\n    /// @return True if the address is the creator or entity of the node, false otherwise.\n    function _isCreatorOrEntity(Node memory node, address guy) internal pure returns (bool) {\n        return _isCreator(node, guy) || _isEntity(node, guy);\n    }\n}"
    }
  ]
}