{
  "Title": "[M-17] The gauge status wasn't checked before reducing the user's gauge weight.",
  "Content": "\nGuild holders might have the opportunity to protect themselves from being slashed by reducing their weight on an offboarded gauge; thereby, transferring the loss to other passive holders and all credit token holders.\n\n### Proof of Concept\n\nThe mechanism utilized by the ECG protocol to address loan losses is as follows:\n\n1. In the event of any loss to the lending term triggered by `ProfitManager#notifyPnL()`, all staked guild tokens on this term will be entirely slashed through `GuildToken#notifyGaugeLoss()`, regardless of the magnitude of the loss, as soon as it occurs.\n2. `termSurplusBuffer[gauge]` will be depleted and donate to `surplusBuffer`.\n3. `loss` will decreased from `surplusBuffer` first.\n4. Should the `surplusBuffer` be lower than the `loss`, the remaining loss will be deducted from each credit token by reducing the `creditMultiplier`.\n\nA `term` can be offboarded if it is unsafe. Once offboarded, the redemption function of corresponding `SimplePSM` will be paused:\n\n```solidity\n161:        // pause psm redemptions\n162:        if (\n163:            nOffboardingsInProgress++ == 0 &&\n164:            !SimplePSM(psm).redemptionsPaused()\n165:        ) {\n167:            SimplePSM(psm).setRedemptionsPaused(true);\n168:        }\n```\n\nNo credit token holders can redeem credit tokens for peg tokens at the moment. The redemption function could be unpaused by calling `LendingTermOffboarding#cleanup()` once all loans on `term` are closed:\n\n```solidity\n190:        // unpause psm redemptions\n191:        if (\n192:            --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()\n193:        ) {\n194:            SimplePSM(psm).setRedemptionsPaused(false);\n195:        }\n```\n\nFrom above we can see, the loss may or may not happen to the offboarded `term`, but once it happen, the loss will be marked down to all credit token holders. No one can exit in advance and pass potential loss to others.\n\nHowever, guild holders could have chance to reduce their weight on the offboarded term, transferring the potential loss to other passive holders and all credit token holders.\n\nCopy below codes to [`LendingTermOffboarding.t.sol`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/test/unit/governance/LendingTermOffboarding.t.sol) and run `forge test --match-test testOffboardTermAndDecrementGauge`:\n\n```solidity\n    function testOffboardTermAndDecrementGauge() public {\n        //@audit-info term2 is deployed\n        LendingTerm term2 = LendingTerm(Clones.clone(address(new LendingTerm())));\n        term2.initialize(\n            address(core),\n            LendingTerm.LendingTermReferences({\n                profitManager: address(profitManager),\n                guildToken: address(guild),\n                auctionHouse: address(auctionHouse),\n                creditMinter: address(rlcm),\n                creditToken: address(credit)\n            }),\n            LendingTerm.LendingTermParams({\n                collateralToken: address(collateral),\n                maxDebtPerCollateralToken: _CREDIT_PER_COLLATERAL_TOKEN,\n                interestRate: _INTEREST_RATE,\n                maxDelayBetweenPartialRepay: 0,\n                minPartialRepayPercent: 0,\n                openingFee: 0,\n                hardCap: _HARDCAP\n            })\n        );\n        vm.startPrank(governor);\n        core.grantRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, address(term2));\n        core.grantRole(CoreRoles.GAUGE_PNL_NOTIFIER, address(term2));\n        vm.stopPrank();\n        //@audit-info active term2, which has the same gauge type with term1 \n        guild.addGauge(1, address(term2));\n        //@audit-info mint 2e18 guild token to carol\n        guild.mint(carol, 2e18);\n        vm.startPrank(carol);\n        guild.incrementGauge(address(term), 1e18);\n        guild.incrementGauge(address(term2), 1e18);\n        vm.stopPrank();\n        // prepare (1)\n        guild.mint(bob, _QUORUM);\n        vm.startPrank(bob);\n        guild.delegate(bob);\n        uint256 snapshotBlock = block.number;\n        //@audit-info bob propose to offboard term\n        offboarder.proposeOffboard(address(term));\n        vm.roll(block.number + 1);\n        vm.warp(block.timestamp + 13);\n\n        //@audit-info term is able to be offboarded with enough votes.\n        offboarder.supportOffboard(snapshotBlock, address(term));\n        assertEq(offboarder.polls(snapshotBlock, address(term)), _QUORUM + 1);\n        assertEq(offboarder.canOffboard(address(term)), true);\n\n        assertEq(guild.isGauge(address(term)), true);\n        assertEq(psm.redemptionsPaused(), false);\n        assertEq(offboarder.nOffboardingsInProgress(), 0);\n\n        offboarder.offboard(address(term));\n        //@audit-info term is offboarded\n        assertEq(guild.isGauge(address(term)), false);\n        //@audit-info the redemption function is paused, no one can redeem their credit token\n        assertEq(psm.redemptionsPaused(), true);\n        assertEq(offboarder.nOffboardingsInProgress(), 1);\n        vm.stopPrank();\n        assertEq(guild.getUserGaugeWeight(carol, address(term)), 1e18);\n        vm.prank(carol);\n        //@audit-info however, carol can decrement their gauge weight on term\n        guild.decrementGauge(address(term), 1e18);\n        assertEq(guild.getUserGaugeWeight(carol, address(term)), 0);\n    } \n```\n\n### Recommended Mitigation Steps\n\nCheck if all loans have been closed in `GuildToken#_decrementGaugeWeight()`:\n\n```diff\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        require(\n            _lastGaugeLossApplied >= _lastGaugeLoss,\n            \"GuildToken: pending loss\"\n        );\n+       uint256 issuance = LendingTerm(gauge).issuance();\n+       if (isDeprecatedGauge(gauge)) {\n+           require(issuance == 0, \"GuildToken: not all loans closed\");\n+       }\n        // update the user profit index and claim rewards\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        // check if gauge is currently using its allocated debt ceiling.\n        // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n-       uint256 issuance = LendingTerm(gauge).issuance();\n        if (issuance != 0) {\n            uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n            require(\n                issuance <= debtCeilingAfterDecrement,\n                \"GuildToken: debt ceiling used\"\n            );\n        }\n\n        super._decrementGaugeWeight(user, gauge, weight);\n    }\n```\n\n### Assessed type\n\nContext\n\n**[eswak (Ethereum Credit Guild) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/651#issuecomment-1886995639):**\n > In the provided PoC, the term that is offboarded does not have any active loans, so it cannot create bad debt during liquidation. The mechanism that prevents GUILD holders from decrementing weight and front-running the loss is [in the GuildToken, where current term issuance is checked](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L224-L231). Issuance is decreased only after the auctions conclude, so after bad debt or profit is realized, and that is what prevents GUILD gauge allocators to avoid slashing.\n> \n> Some GUILD holders could still decrement weight during the auction, but not to the extent that it would make the debt ceiling below issuance. I'll let my colleague @OneTrueKirk weigh in on whether we should prevent _all_ gauge weight decrements during liquidations, or if the current implementation is fine, but as described I don't think this is a medium issue, more like an Analysis.\n\n**[OneTrueKirk (Ethereum Credit Guild) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/651#issuecomment-1887832595):**\n > I think it's a good idea to prevent gauge weight deprecation once a lending term has been offboarded. Especially since in the case of the surplus GUILD minter, there is exogenous surplus buffer capital which should help to protect passive lenders, but might escape at this time. Therefore, I think that the severity of Medium is appropriate @eswak.\n\n**[eswak (Ethereum Credit Guild) confirmed](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/651#issuecomment-1888766962)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/tokens/GuildToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {ERC20Gauges} from \"@src/tokens/ERC20Gauges.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {ERC20MultiVotes} from \"@src/tokens/ERC20MultiVotes.sol\";\n\n/** \n@title  GUILD ERC20 Token\n@author eswak\n@notice This is the governance token of the Ethereum Credit Guild.\n    On deploy, this token is non-transferrable.\n    During the non-transferrable period, GUILD can still be minted & burnt, only\n    `transfer` and `transferFrom` are reverting.\n\n    The gauge system is used to define debt ceilings on a set of lending terms.\n    Lending terms can be whitelisted by adding a gauge for their address, if GUILD\n    holders vote for these lending terms in the gauge system, the lending terms will\n    have a non-zero debt ceiling, and borrowing will be available under these terms.\n\n    When a lending term creates bad debt, a loss is notified in a gauge on this\n    contract (`notifyGaugeLoss`). When a loss is notified, all the GUILD token weight voting\n    for this gauge becomes non-transferable and can be permissionlessly slashed. Until the\n    loss is realized (`applyGaugeLoss`), a user cannot transfer their locked tokens or\n    decrease the weight they assign to the gauge that suffered a loss.\n    Even when a loss occur, users can still transfer tokens with which they vote for gauges\n    that did not suffer a loss.\n*/\ncontract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice reference to ProfitManager\n    address public profitManager;\n\n    constructor(\n        address _core,\n        address _profitManager\n    )\n        CoreRef(_core)\n        ERC20(\"Ethereum Credit Guild - GUILD\", \"GUILD\")\n        ERC20Permit(\"Ethereum Credit Guild - GUILD\")\n    {\n        profitManager = _profitManager;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTING MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set `maxDelegates`, the maximum number of addresses any account can delegate voting power to.\n    function setMaxDelegates(\n        uint256 newMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setMaxDelegates(newMax);\n    }\n\n    /// @notice Allow or disallow an address to delegate voting power to more addresses than `maxDelegates`.\n    function setContractExceedMaxDelegates(\n        address account,\n        bool canExceedMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setContractExceedMaxDelegates(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n    function addGauge(\n        uint256 _type,\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) {\n        return _addGauge(_type, gauge);\n    }\n\n    function removeGauge(\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) {\n        _removeGauge(gauge);\n    }\n\n    function setMaxGauges(\n        uint256 max\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setMaxGauges(max);\n    }\n\n    function setCanExceedMaxGauges(\n        address who,\n        bool can\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setCanExceedMaxGauges(who, can);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LOSS MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when a loss in a gauge is notified.\n    event GaugeLoss(address indexed gauge, uint256 indexed when);\n    /// @notice emitted when a loss in a gauge is applied (for each user).\n    event GaugeLossApply(\n        address indexed gauge,\n        address indexed who,\n        uint256 weight,\n        uint256 when\n    );\n\n    /// @notice last block.timestamp when a loss occurred in a given gauge\n    mapping(address => uint256) public lastGaugeLoss;\n\n    /// @notice last block.timestamp when a user apply a loss that occurred in a given gauge\n    mapping(address => mapping(address => uint256)) public lastGaugeLossApplied;\n\n    /// @notice notify loss in a given gauge\n    function notifyGaugeLoss(address gauge) external {\n        require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n        // save gauge loss\n        lastGaugeLoss[gauge] = block.timestamp;\n        emit GaugeLoss(gauge, block.timestamp);\n    }\n\n    /// @notice apply a loss that occurred in a given gauge\n    /// anyone can apply the loss on behalf of anyone else\n    function applyGaugeLoss(address gauge, address who) external {\n        // check preconditions\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];\n        require(\n            _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,\n            \"GuildToken: no loss to apply\"\n        );\n\n        // read user weight allocated to the lossy gauge\n        uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];\n\n        // remove gauge weight allocation\n        lastGaugeLossApplied[gauge][who] = block.timestamp;\n        _decrementGaugeWeight(who, gauge, _userGaugeWeight);\n        if (!_deprecatedGauges.contains(gauge)) {\n            totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;\n            totalWeight -= _userGaugeWeight;\n        }\n\n        // apply loss\n        _burn(who, uint256(_userGaugeWeight));\n        emit GaugeLossApply(\n            gauge,\n            who,\n            uint256(_userGaugeWeight),\n            block.timestamp\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TRANSFERABILITY\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice at deployment, tokens are not transferable (can only mint/burn).\n    /// Governance can enable transfers with `enableTransfers()`.\n    bool public transferable; // default = false\n\n    /// @notice emitted when transfers are enabled.\n    event TransfersEnabled(uint256 block, uint256 timestamp);\n\n    /// @notice permanently enable token transfers.\n    function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) {\n        transferable = true;\n        emit TransfersEnabled(block.number, block.timestamp);\n    }\n\n    /// @dev prevent transfers if they are not globally enabled.\n    /// mint and burn (transfers to and from address 0) are accepted.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* amount*/\n    ) internal view override {\n        require(\n            transferable || from == address(0) || to == address(0),\n            \"GuildToken: transfers disabled\"\n        );\n    }\n\n    /// @notice emitted when reference to ProfitManager is updated\n    event ProfitManagerUpdated(uint256 timestamp, address newValue);\n\n    /// @notice set reference to ProfitManager\n    function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        profitManager = _newProfitManager;\n        emit ProfitManagerUpdated(block.timestamp, _newProfitManager);\n    }\n\n    /// @dev prevent outbound token transfers (_decrementWeightUntilFree) and gauge weight decrease\n    /// (decrementGauge, decrementGauges) for users who have an unrealized loss in a gauge, or if the\n    /// gauge is currently using its allocated debt ceiling. To decrement gauge weight, guild holders\n    /// might have to call loans if the debt ceiling is used.\n    /// Also update the user profit index and claim rewards.\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        require(\n            _lastGaugeLossApplied >= _lastGaugeLoss,\n            \"GuildToken: pending loss\"\n        );\n\n        // update the user profit index and claim rewards\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        // check if gauge is currently using its allocated debt ceiling.\n        // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n        uint256 issuance = LendingTerm(gauge).issuance();\n        if (issuance != 0) {\n            uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n            require(\n                issuance <= debtCeilingAfterDecrement,\n                \"GuildToken: debt ceiling used\"\n            );\n        }\n\n        super._decrementGaugeWeight(user, gauge, weight);\n    }\n\n    /// @dev prevent weight increment for gauge if user has an unapplied loss.\n    /// If the user has 0 weight (i.e. no loss to realize), allow incrementing\n    /// gauge weight & update lastGaugeLossApplied to current time.\n    /// Also update the user profit index an claim rewards.\n    /// @dev note that users voting for a gauge that is not a proper lending term could result in this\n    /// share of the user's tokens to be frozen, due to being unable to decrement weight.\n    function _incrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        if (getUserGaugeWeight[user][gauge] == 0) {\n            lastGaugeLossApplied[gauge][user] = block.timestamp;\n        } else {\n            require(\n                _lastGaugeLossApplied >= _lastGaugeLoss,\n                \"GuildToken: pending loss\"\n            );\n        }\n\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        super._incrementGaugeWeight(user, gauge, weight);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        MINT / BURN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice mint new tokens to the target address\n    function mint(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {\n        _mint(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Inheritance reconciliation\n    //////////////////////////////////////////////////////////////*/\n\n    function _burn(\n        address from,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        ERC20._burn(from, amount);\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(msg.sender, amount);\n        _decrementVotesUntilFree(msg.sender, amount);\n        return ERC20.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        return ERC20.transferFrom(from, to, amount);\n    }\n}"
    }
  ]
}