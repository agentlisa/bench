{
  "Title": "M-4: WooFi oracle can fail to validate its price with Chainlink price feed",
  "Content": "# Issue M-4: WooFi oracle can fail to validate its price with Chainlink price feed \n\nSource: https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/41 \n\n## Found by \nAvci, Bandit, Dliteofficial, infect3d, klaus, mstpr-brainbot\n## Summary\nThe price precision that the WooOracle uses is 8. However, if the quote token is an expensive token or the base token is a very cheap token, then the price will be too less in decimals and even \"0\" in some cases. This will lead to inefficient trades or inability to compare the woofi price with chainlink price due to chainlink price return with \"0\" value. \n## Vulnerability Detail\nFirst, let's see how the chainlink price is calculated:\n```solidity\nfunction _cloPriceInQuote(address _fromToken, address _toToken)\n        internal\n        view\n        returns (uint256 refPrice, uint256 refTimestamp)\n    {\n        address baseOracle = clOracles[_fromToken].oracle;\n        if (baseOracle == address(0)) {\n            return (0, 0);\n        }\n        address quoteOracle = clOracles[_toToken].oracle;\n        uint8 quoteDecimal = clOracles[_toToken].decimal;\n\n        (, int256 rawBaseRefPrice, , uint256 baseUpdatedAt, ) = AggregatorV3Interface(baseOracle).latestRoundData();\n        (, int256 rawQuoteRefPrice, , uint256 quoteUpdatedAt, ) = AggregatorV3Interface(quoteOracle).latestRoundData();\n        uint256 baseRefPrice = uint256(rawBaseRefPrice);\n        uint256 quoteRefPrice = uint256(rawQuoteRefPrice);\n\n        // NOTE: Assume wooracle token decimal is same as chainlink token decimal.\n        uint256 ceoff = uint256(10)**quoteDecimal;\n        refPrice = (baseRefPrice * ceoff) / quoteRefPrice;\n        refTimestamp = baseUpdatedAt >= quoteUpdatedAt ? quoteUpdatedAt : baseUpdatedAt;\n    }\n```\n\nNow, let's assume the quote token is WBTC price of 60,000$ and the baseToken is tokenX that has the price of 0.0001$. When the final price is calculated at`refPrice` because of the divisions in solidity, the result will be \"0\" as follows:\n60_000 * 1e8 * 1e8 / 0.0001 * 1e8\n= 0\n\nso the return amount will be \"0\".\n\nWhen the derived chainlink price is compared with woofi oracle if the chainlink price is \"0\" then the `woPriceInBound` will be set to \"true\" assuming the chainlink price is not set. However, in our case that's not the case, the price returnt \"0\" because of divisions:\n```solidity\n-> bool woPriceInBound = cloPrice_ == 0 ||\n            ((cloPrice_ * (1e18 - bound)) / 1e18 <= woPrice_ && woPrice_ <= (cloPrice_ * (1e18 + bound)) / 1e18);\n\n        if (woFeasible) {\n            priceOut = woPrice_;\n            feasible = woPriceInBound;\n        }\n```\n\nIn such scenario, the chainlink comparison between woofi and chainlink price will not give correct results. The oracle will not be able to detect whether the chainlink price is in \"bound\" with the woofi's returnt price. \n\nThis also applies if a baseToken price crushes. If the token price gets very less due to market, regardless of the quoteToken being WBTC or USDC the above scenario can happen.\n## Impact\nOracle will fail to do a validation of its price with the chainlink price. \n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/wooracle/WooracleV2_2.sol#L348-L369\n\nhttps://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/wooracle/WooracleV2_2.sol#L243-L261\n## Tool used\n\nManual Review\n\n## Recommendation\nPrecision of \"8\" is not enough on most of the cases. I'd suggest return the oracle price in \"18\" decimals to get more room on rounding.\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**WangAudit** commented:\n> the calculation is incorrect; turn on the terminal; start chisel; copy+paste the calculation (60000 * 1e8 * 1e8) / (0.0001 * 1e8) (added brackets so it will be calculated correctly) and the answer is indeed 60000000000000000 (60_000e12 which is correct) and not 0\n\n\n\n**fb-alexcq**\n\nThanks for filing this issue.\n\nOur WooPP only selects the mainstream tokens (actually, only native, btc, usdc, usdt), so it won't face this extreme case. And it's not engineering efficient to update price decimal to `18` for the impossible case above.\n\n**WangSecurity**\n\nFirstly, here's a comment from tapir:\n\nI made a typo in math calculation. I say quote token is wbtc and base token is a token with low price but doing the math opposite. @Wang Security  comment is right here because of my typo. \n\nthe price is:\n(baseRefPrice * ceoff) / quoteRefPrice;\n\nbaseRefPrice = 0.0001 * 1e8;\nquoteRefPrice = 60_000 * 1e8;\nceoff = 1e8 (WBTC decimals)\n\nand the result is \"0\"\n\nI asked Head of Judging and he allowed me to use the new context.\n\nMoreover, the information about which tokens will be used (the ones mentioned in the above comment) was unavailable to watsons, and README says any token. On top of it, it's infact unientended design. Therefore, Medium -> core functionality break -> the `price` function will validate 0 price from chainlink when it shouldn't do this.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/277",
  "Code": [
    {
      "filename": "WooPoolV2/contracts/wooracle/WooracleV2_2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n/*\n\n░██╗░░░░░░░██╗░█████╗░░█████╗░░░░░░░███████╗██╗\n░██║░░██╗░░██║██╔══██╗██╔══██╗░░░░░░██╔════╝██║\n░╚██╗████╗██╔╝██║░░██║██║░░██║█████╗█████╗░░██║\n░░████╔═████║░██║░░██║██║░░██║╚════╝██╔══╝░░██║\n░░╚██╔╝░╚██╔╝░╚█████╔╝╚█████╔╝░░░░░░██║░░░░░██║\n░░░╚═╝░░░╚═╝░░░╚════╝░░╚════╝░░░░░░░╚═╝░░░░░╚═╝\n\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 WooTrade\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport \"../interfaces/IWooracleV2.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n// OpenZeppelin contracts\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title Wooracle V2.2 contract for WooPPV2\n/// subversion 1 change: no timestamp update for posting price from WooPP.\n/// subversion 2 change: support legacy postState utilizing block.timestamp\ncontract WooracleV2_2 is Ownable, IWooracleV2 {\n    /* ----- State variables ----- */\n\n    // 128 + 64 + 64 = 256 bits (slot size)\n    struct TokenInfo {\n        uint128 price; // as chainlink oracle (e.g. decimal = 8)                zip: 32 bits = (27, 5)\n        uint64 coeff; // k: decimal = 18.    18.4 * 1e18                        zip: 16 bits = (11, 5), 2^11 = 2048\n        uint64 spread; // s: decimal = 18.   spread <= 2e18   18.4 * 1e18       zip: 16 bits = (11, 5)\n    }\n\n    struct CLOracle {\n        address oracle;\n        uint8 decimal;\n        bool cloPreferred;\n    }\n\n    mapping(address => TokenInfo) public infos;\n    mapping(address => CLOracle) public clOracles;\n\n    address public quoteToken;\n    uint256 public timestamp;\n\n    uint256 public staleDuration;\n    uint64 public bound;\n\n    address public wooPP;\n\n    mapping(address => bool) public isAdmin;\n\n    mapping(uint8 => address) public basesMap;\n\n    constructor() {\n        staleDuration = uint256(120); // default: 2 mins\n        bound = uint64(1e16); // 1%\n    }\n\n    modifier onlyAdmin() {\n        require(owner() == msg.sender || isAdmin[msg.sender], \"WooracleV2_2: !Admin\");\n        _;\n    }\n\n    /* ----- External Functions ----- */\n\n    function setWooPP(address _wooPP) external onlyAdmin {\n        wooPP = _wooPP;\n    }\n\n    function setAdmin(address _addr, bool _flag) external onlyOwner {\n        isAdmin[_addr] = _flag;\n    }\n\n    /// @dev Set the quote token address.\n    /// @param _oracle the token address\n    function setQuoteToken(address _quote, address _oracle) external onlyAdmin {\n        quoteToken = _quote;\n        CLOracle storage cloRef = clOracles[_quote];\n        cloRef.oracle = _oracle;\n        cloRef.decimal = AggregatorV3Interface(_oracle).decimals();\n    }\n\n    function setBound(uint64 _bound) external onlyOwner {\n        bound = _bound;\n    }\n\n    function setCLOracle(\n        address _token,\n        address _oracle,\n        bool _cloPreferred\n    ) external onlyAdmin {\n        CLOracle storage cloRef = clOracles[_token];\n        cloRef.oracle = _oracle;\n        cloRef.decimal = AggregatorV3Interface(_oracle).decimals();\n        cloRef.cloPreferred = _cloPreferred;\n    }\n\n    function setCloPreferred(address _token, bool _cloPreferred) external onlyAdmin {\n        CLOracle storage cloRef = clOracles[_token];\n        cloRef.cloPreferred = _cloPreferred;\n    }\n\n    /// @dev Set the staleDuration.\n    /// @param _staleDuration the new stale duration\n    function setStaleDuration(uint256 _staleDuration) external onlyAdmin {\n        staleDuration = _staleDuration;\n    }\n\n    /// @dev Update the base token prices.\n    /// @param _base the baseToken address\n    /// @param _price the new prices for the base token\n    function postPrice(address _base, uint128 _price) external onlyAdmin {\n        infos[_base].price = _price;\n        if (msg.sender != wooPP) {\n            timestamp = block.timestamp;\n        }\n    }\n\n    /// @dev Update the base token prices.\n    /// @param _base the baseToken address\n    /// @param _price the new prices for the base token\n    function postPrice(\n        address _base,\n        uint128 _price,\n        uint256 _ts\n    ) external onlyAdmin {\n        infos[_base].price = _price;\n        timestamp = _ts;\n    }\n\n    /// @dev batch update baseTokens prices\n    /// @param _bases list of baseToken address\n    /// @param _prices the updated prices list\n    function postPriceList(\n        address[] calldata _bases,\n        uint128[] calldata _prices,\n        uint256 _ts\n    ) external onlyAdmin {\n        uint256 length = _bases.length;\n        require(length == _prices.length, \"WooracleV2_2: length_INVALID\");\n\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                infos[_bases[i]].price = _prices[i];\n            }\n        }\n\n        timestamp = _ts;\n    }\n\n    /// @dev update the state of the given base token.\n    /// @param _base baseToken address\n    /// @param _price the new prices\n    /// @param _spread the new spreads\n    /// @param _coeff the new slippage coefficent\n    function postState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff\n    ) external onlyAdmin {\n        _setState(_base, _price, _spread, _coeff);\n        timestamp = block.timestamp;\n    }\n\n    /// @dev update the state of the given base token with the offchain timestamp.\n    /// @param _base baseToken address\n    /// @param _price the new prices\n    /// @param _spread the new spreads\n    /// @param _coeff the new slippage coefficent\n    /// @param _ts the local timestamp\n    function postState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff,\n        uint256 _ts\n    ) external onlyAdmin {\n        _setState(_base, _price, _spread, _coeff);\n        timestamp = _ts;\n    }\n\n    /// @dev batch update the prices, spreads and slipagge coeffs info.\n    /// @param _bases list of baseToken address\n    /// @param _prices the prices list\n    /// @param _spreads the spreads list\n    /// @param _coeffs the slippage coefficent list\n    function postStateList(\n        address[] calldata _bases,\n        uint128[] calldata _prices,\n        uint64[] calldata _spreads,\n        uint64[] calldata _coeffs,\n        uint256 _ts\n    ) external onlyAdmin {\n        uint256 length = _bases.length;\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                _setState(_bases[i], _prices[i], _spreads[i], _coeffs[i]);\n            }\n        }\n        timestamp = _ts;\n    }\n\n    /*\n        Price logic:\n        - woPrice: wooracle price\n        - cloPrice: chainlink price\n\n        woFeasible is, price > 0 and price timestamp NOT stale\n\n        when woFeasible && priceWithinBound     -> woPrice, feasible\n        when woFeasible && !priceWithinBound    -> woPrice, infeasible\n        when !woFeasible && clo_preferred       -> cloPrice, feasible\n        when !woFeasible && !clo_preferred      -> cloPrice, infeasible\n    */\n    function price(address _base) public view override returns (uint256 priceOut, bool feasible) {\n        uint256 woPrice_ = uint256(infos[_base].price);\n        uint256 woPriceTimestamp = timestamp;\n\n        (uint256 cloPrice_, ) = _cloPriceInQuote(_base, quoteToken);\n\n        bool woFeasible = woPrice_ != 0 && block.timestamp <= (woPriceTimestamp + staleDuration);\n        bool woPriceInBound = cloPrice_ == 0 ||\n            ((cloPrice_ * (1e18 - bound)) / 1e18 <= woPrice_ && woPrice_ <= (cloPrice_ * (1e18 + bound)) / 1e18);\n\n        if (woFeasible) {\n            priceOut = woPrice_;\n            feasible = woPriceInBound;\n        } else {\n            priceOut = clOracles[_base].cloPreferred ? cloPrice_ : 0;\n            feasible = priceOut != 0;\n        }\n    }\n\n    /// @notice the price decimal for the specified base token\n    function decimals(address) external pure override returns (uint8) {\n        return 8;\n    }\n\n    function cloPrice(address _base) external view override returns (uint256 refPrice, uint256 refTimestamp) {\n        return _cloPriceInQuote(_base, quoteToken);\n    }\n\n    function isWoFeasible(address _base) external view override returns (bool) {\n        return infos[_base].price != 0 && block.timestamp <= (timestamp + staleDuration);\n    }\n\n    function syncTS() external onlyAdmin {\n        timestamp = block.timestamp;\n    }\n\n    function syncTS(uint256 _ts) external onlyAdmin {\n        timestamp = _ts;\n    }\n\n    function debugTS()\n        external\n        view\n        returns (\n            uint256 n,\n            uint256 bs,\n            uint256 ts,\n            bool f\n        )\n    {\n        n = block.number;\n        bs = block.timestamp;\n        ts = timestamp;\n        f = block.timestamp <= (timestamp + staleDuration);\n    }\n\n    function woSpread(address _base) external view override returns (uint64) {\n        return infos[_base].spread;\n    }\n\n    function woCoeff(address _base) external view override returns (uint64) {\n        return infos[_base].coeff;\n    }\n\n    // Wooracle price of the base token\n    function woPrice(address _base) external view override returns (uint128 priceOut, uint256 priceTimestampOut) {\n        priceOut = infos[_base].price;\n        priceTimestampOut = timestamp;\n    }\n\n    function woState(address _base) external view override returns (State memory) {\n        TokenInfo memory info = infos[_base];\n        return\n            State({\n                price: info.price,\n                spread: info.spread,\n                coeff: info.coeff,\n                woFeasible: (info.price != 0 && block.timestamp <= (timestamp + staleDuration))\n            });\n    }\n\n    function state(address _base) external view override returns (State memory) {\n        TokenInfo memory info = infos[_base];\n        (uint256 basePrice, bool feasible) = price(_base);\n        return State({price: uint128(basePrice), spread: info.spread, coeff: info.coeff, woFeasible: feasible});\n    }\n\n    function cloAddress(address _base) external view override returns (address clo) {\n        clo = clOracles[_base].oracle;\n    }\n\n    /* ----- Private Functions ----- */\n\n    function _setState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff\n    ) internal {\n        TokenInfo storage info = infos[_base];\n        info.price = _price;\n        info.spread = _spread;\n        info.coeff = _coeff;\n    }\n\n    function _cloPriceInQuote(address _fromToken, address _toToken)\n        internal\n        view\n        returns (uint256 refPrice, uint256 refTimestamp)\n    {\n        address baseOracle = clOracles[_fromToken].oracle;\n        if (baseOracle == address(0)) {\n            return (0, 0);\n        }\n        address quoteOracle = clOracles[_toToken].oracle;\n        uint8 quoteDecimal = clOracles[_toToken].decimal;\n\n        (, int256 rawBaseRefPrice, , uint256 baseUpdatedAt, ) = AggregatorV3Interface(baseOracle).latestRoundData();\n        (, int256 rawQuoteRefPrice, , uint256 quoteUpdatedAt, ) = AggregatorV3Interface(quoteOracle).latestRoundData();\n        uint256 baseRefPrice = uint256(rawBaseRefPrice);\n        uint256 quoteRefPrice = uint256(rawQuoteRefPrice);\n\n        // NOTE: Assume wooracle token decimal is same as chainlink token decimal.\n        uint256 ceoff = uint256(10)**quoteDecimal;\n        refPrice = (baseRefPrice * ceoff) / quoteRefPrice;\n        refTimestamp = baseUpdatedAt >= quoteUpdatedAt ? quoteUpdatedAt : baseUpdatedAt;\n    }\n\n    /* ----- Zip Related Functions ----- */\n\n    function setBase(uint8 _id, address _base) external onlyAdmin {\n        require(getBase(_id) == address(0), \"WooracleV2_2: !id_SET_ALREADY\");\n        basesMap[_id] = _base;\n    }\n\n    function getBase(uint8 _id) public view returns (address) {\n        address[5] memory CONST_BASES = [\n            // mload\n            // NOTE: Update token address for different chains\n            0x82aF49447D8a07e3bd95BD0d56f35241523fBab1, // WETH\n            0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f, // WBTC\n            0xcAFcD85D8ca7Ad1e1C6F82F651fA15E33AEfD07b, // WOO\n            0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9, // USDT\n            0x912CE59144191C1204E64559FE8253a0e49E6548 // ARB\n        ];\n\n        return _id < CONST_BASES.length ? CONST_BASES[_id] : basesMap[_id];\n    }\n\n    // https://docs.soliditylang.org/en/v0.8.12/contracts.html#fallback-function\n    // prettier-ignore\n    fallback (bytes calldata _input) external onlyAdmin returns (bytes memory _output) {\n        /*\n            2 bit:  0: post prices,\n                    1: post states,\n                    2: post prices with local timestamp\n                    3: post states with local timestamp\n            6 bits: length\n\n            post prices:\n               [price] -->\n                  base token: 8 bites (1 byte)\n                  price data: 32 bits = (27, 5)\n\n            post states:\n               [states] -->\n                  base token: 8 bites (1 byte)\n                  price:      32 bits (4 bytes) = (27, 5)\n                  k coeff:    16 bits (2 bytes) = (11, 5)\n                  s spread:   16 bits (2 bytes) = (11, 5)\n\n            4 bytes (32bits): timestamp\n                MAX: 2^32-1 = 4,294,967,295 = Feb 7, 2106 6:28:15 AM (~83 years away)\n        */\n\n        uint256 x = _input.length;\n        require(x > 0, \"WooracleV2_2: !calldata\");\n\n        uint8 firstByte = uint8(bytes1(_input[0]));\n        uint8 op = firstByte >> 6; // 11000000\n        uint8 len = firstByte & 0x3F; // 00111111\n\n        if (op == 0 || op == 2) {\n            // post prices list\n            address base;\n            uint128 p;\n\n            for (uint256 i = 0; i < len; ++i) {\n                base = getBase(uint8(bytes1(_input[1 + i * 5:1 + i * 5 + 1])));\n                p = _decodePrice(uint32(bytes4(_input[1 + i * 5 + 1:1 + i * 5 + 5])));\n                infos[base].price = p;\n            }\n\n            timestamp = (op == 0) ? block.timestamp : uint256(uint32(bytes4(_input[1 + len * 5:1 + len * 5 + 4])));\n        } else if (op == 1 || op == 3) {\n            // post states list\n            address base;\n            uint128 p;\n            uint64 s;\n            uint64 k;\n\n            for (uint256 i = 0; i < len; ++i) {\n                base = getBase(uint8(bytes1(_input[1 + i * 9:1 + i * 9 + 1])));\n                p = _decodePrice(uint32(bytes4(_input[1 + i * 9 + 1:1 + i * 9 + 5])));\n                s = _decodeKS(uint16(bytes2(_input[1 + i * 9 + 5:1 + i * 9 + 7])));\n                k = _decodeKS(uint16(bytes2(_input[1 + i * 9 + 7:1 + i * 9 + 9])));\n                _setState(base, p, s, k);\n            }\n\n            timestamp = (op == 1) ? block.timestamp : uint256(uint32(bytes4(_input[1 + len * 9:1 + len * 9 + 4])));\n        } else {\n            revert(\"WooracleV2_2: !op\");\n        }\n    }\n\n    function _decodePrice(uint32 b) internal pure returns (uint128) {\n        return uint128((b >> 5) * (10**(b & 0x1F))); // 0x1F = 00011111\n    }\n\n    function _decodeKS(uint16 b) internal pure returns (uint64) {\n        return uint64((b >> 5) * (10**(b & 0x1F)));\n    }\n\n    function inCaseTokenGotStuck(address stuckToken) external onlyAdmin {\n        if (stuckToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            TransferHelper.safeTransferETH(owner(), address(this).balance);\n        } else {\n            uint256 amount = IERC20(stuckToken).balanceOf(address(this));\n            TransferHelper.safeTransfer(stuckToken, owner(), amount);\n        }\n    }\n}"
    },
    {
      "filename": "WooPoolV2/contracts/wooracle/WooracleV2_2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n/*\n\n░██╗░░░░░░░██╗░█████╗░░█████╗░░░░░░░███████╗██╗\n░██║░░██╗░░██║██╔══██╗██╔══██╗░░░░░░██╔════╝██║\n░╚██╗████╗██╔╝██║░░██║██║░░██║█████╗█████╗░░██║\n░░████╔═████║░██║░░██║██║░░██║╚════╝██╔══╝░░██║\n░░╚██╔╝░╚██╔╝░╚█████╔╝╚█████╔╝░░░░░░██║░░░░░██║\n░░░╚═╝░░░╚═╝░░░╚════╝░░╚════╝░░░░░░░╚═╝░░░░░╚═╝\n\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 WooTrade\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport \"../interfaces/IWooracleV2.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n// OpenZeppelin contracts\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title Wooracle V2.2 contract for WooPPV2\n/// subversion 1 change: no timestamp update for posting price from WooPP.\n/// subversion 2 change: support legacy postState utilizing block.timestamp\ncontract WooracleV2_2 is Ownable, IWooracleV2 {\n    /* ----- State variables ----- */\n\n    // 128 + 64 + 64 = 256 bits (slot size)\n    struct TokenInfo {\n        uint128 price; // as chainlink oracle (e.g. decimal = 8)                zip: 32 bits = (27, 5)\n        uint64 coeff; // k: decimal = 18.    18.4 * 1e18                        zip: 16 bits = (11, 5), 2^11 = 2048\n        uint64 spread; // s: decimal = 18.   spread <= 2e18   18.4 * 1e18       zip: 16 bits = (11, 5)\n    }\n\n    struct CLOracle {\n        address oracle;\n        uint8 decimal;\n        bool cloPreferred;\n    }\n\n    mapping(address => TokenInfo) public infos;\n    mapping(address => CLOracle) public clOracles;\n\n    address public quoteToken;\n    uint256 public timestamp;\n\n    uint256 public staleDuration;\n    uint64 public bound;\n\n    address public wooPP;\n\n    mapping(address => bool) public isAdmin;\n\n    mapping(uint8 => address) public basesMap;\n\n    constructor() {\n        staleDuration = uint256(120); // default: 2 mins\n        bound = uint64(1e16); // 1%\n    }\n\n    modifier onlyAdmin() {\n        require(owner() == msg.sender || isAdmin[msg.sender], \"WooracleV2_2: !Admin\");\n        _;\n    }\n\n    /* ----- External Functions ----- */\n\n    function setWooPP(address _wooPP) external onlyAdmin {\n        wooPP = _wooPP;\n    }\n\n    function setAdmin(address _addr, bool _flag) external onlyOwner {\n        isAdmin[_addr] = _flag;\n    }\n\n    /// @dev Set the quote token address.\n    /// @param _oracle the token address\n    function setQuoteToken(address _quote, address _oracle) external onlyAdmin {\n        quoteToken = _quote;\n        CLOracle storage cloRef = clOracles[_quote];\n        cloRef.oracle = _oracle;\n        cloRef.decimal = AggregatorV3Interface(_oracle).decimals();\n    }\n\n    function setBound(uint64 _bound) external onlyOwner {\n        bound = _bound;\n    }\n\n    function setCLOracle(\n        address _token,\n        address _oracle,\n        bool _cloPreferred\n    ) external onlyAdmin {\n        CLOracle storage cloRef = clOracles[_token];\n        cloRef.oracle = _oracle;\n        cloRef.decimal = AggregatorV3Interface(_oracle).decimals();\n        cloRef.cloPreferred = _cloPreferred;\n    }\n\n    function setCloPreferred(address _token, bool _cloPreferred) external onlyAdmin {\n        CLOracle storage cloRef = clOracles[_token];\n        cloRef.cloPreferred = _cloPreferred;\n    }\n\n    /// @dev Set the staleDuration.\n    /// @param _staleDuration the new stale duration\n    function setStaleDuration(uint256 _staleDuration) external onlyAdmin {\n        staleDuration = _staleDuration;\n    }\n\n    /// @dev Update the base token prices.\n    /// @param _base the baseToken address\n    /// @param _price the new prices for the base token\n    function postPrice(address _base, uint128 _price) external onlyAdmin {\n        infos[_base].price = _price;\n        if (msg.sender != wooPP) {\n            timestamp = block.timestamp;\n        }\n    }\n\n    /// @dev Update the base token prices.\n    /// @param _base the baseToken address\n    /// @param _price the new prices for the base token\n    function postPrice(\n        address _base,\n        uint128 _price,\n        uint256 _ts\n    ) external onlyAdmin {\n        infos[_base].price = _price;\n        timestamp = _ts;\n    }\n\n    /// @dev batch update baseTokens prices\n    /// @param _bases list of baseToken address\n    /// @param _prices the updated prices list\n    function postPriceList(\n        address[] calldata _bases,\n        uint128[] calldata _prices,\n        uint256 _ts\n    ) external onlyAdmin {\n        uint256 length = _bases.length;\n        require(length == _prices.length, \"WooracleV2_2: length_INVALID\");\n\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                infos[_bases[i]].price = _prices[i];\n            }\n        }\n\n        timestamp = _ts;\n    }\n\n    /// @dev update the state of the given base token.\n    /// @param _base baseToken address\n    /// @param _price the new prices\n    /// @param _spread the new spreads\n    /// @param _coeff the new slippage coefficent\n    function postState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff\n    ) external onlyAdmin {\n        _setState(_base, _price, _spread, _coeff);\n        timestamp = block.timestamp;\n    }\n\n    /// @dev update the state of the given base token with the offchain timestamp.\n    /// @param _base baseToken address\n    /// @param _price the new prices\n    /// @param _spread the new spreads\n    /// @param _coeff the new slippage coefficent\n    /// @param _ts the local timestamp\n    function postState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff,\n        uint256 _ts\n    ) external onlyAdmin {\n        _setState(_base, _price, _spread, _coeff);\n        timestamp = _ts;\n    }\n\n    /// @dev batch update the prices, spreads and slipagge coeffs info.\n    /// @param _bases list of baseToken address\n    /// @param _prices the prices list\n    /// @param _spreads the spreads list\n    /// @param _coeffs the slippage coefficent list\n    function postStateList(\n        address[] calldata _bases,\n        uint128[] calldata _prices,\n        uint64[] calldata _spreads,\n        uint64[] calldata _coeffs,\n        uint256 _ts\n    ) external onlyAdmin {\n        uint256 length = _bases.length;\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                _setState(_bases[i], _prices[i], _spreads[i], _coeffs[i]);\n            }\n        }\n        timestamp = _ts;\n    }\n\n    /*\n        Price logic:\n        - woPrice: wooracle price\n        - cloPrice: chainlink price\n\n        woFeasible is, price > 0 and price timestamp NOT stale\n\n        when woFeasible && priceWithinBound     -> woPrice, feasible\n        when woFeasible && !priceWithinBound    -> woPrice, infeasible\n        when !woFeasible && clo_preferred       -> cloPrice, feasible\n        when !woFeasible && !clo_preferred      -> cloPrice, infeasible\n    */\n    function price(address _base) public view override returns (uint256 priceOut, bool feasible) {\n        uint256 woPrice_ = uint256(infos[_base].price);\n        uint256 woPriceTimestamp = timestamp;\n\n        (uint256 cloPrice_, ) = _cloPriceInQuote(_base, quoteToken);\n\n        bool woFeasible = woPrice_ != 0 && block.timestamp <= (woPriceTimestamp + staleDuration);\n        bool woPriceInBound = cloPrice_ == 0 ||\n            ((cloPrice_ * (1e18 - bound)) / 1e18 <= woPrice_ && woPrice_ <= (cloPrice_ * (1e18 + bound)) / 1e18);\n\n        if (woFeasible) {\n            priceOut = woPrice_;\n            feasible = woPriceInBound;\n        } else {\n            priceOut = clOracles[_base].cloPreferred ? cloPrice_ : 0;\n            feasible = priceOut != 0;\n        }\n    }\n\n    /// @notice the price decimal for the specified base token\n    function decimals(address) external pure override returns (uint8) {\n        return 8;\n    }\n\n    function cloPrice(address _base) external view override returns (uint256 refPrice, uint256 refTimestamp) {\n        return _cloPriceInQuote(_base, quoteToken);\n    }\n\n    function isWoFeasible(address _base) external view override returns (bool) {\n        return infos[_base].price != 0 && block.timestamp <= (timestamp + staleDuration);\n    }\n\n    function syncTS() external onlyAdmin {\n        timestamp = block.timestamp;\n    }\n\n    function syncTS(uint256 _ts) external onlyAdmin {\n        timestamp = _ts;\n    }\n\n    function debugTS()\n        external\n        view\n        returns (\n            uint256 n,\n            uint256 bs,\n            uint256 ts,\n            bool f\n        )\n    {\n        n = block.number;\n        bs = block.timestamp;\n        ts = timestamp;\n        f = block.timestamp <= (timestamp + staleDuration);\n    }\n\n    function woSpread(address _base) external view override returns (uint64) {\n        return infos[_base].spread;\n    }\n\n    function woCoeff(address _base) external view override returns (uint64) {\n        return infos[_base].coeff;\n    }\n\n    // Wooracle price of the base token\n    function woPrice(address _base) external view override returns (uint128 priceOut, uint256 priceTimestampOut) {\n        priceOut = infos[_base].price;\n        priceTimestampOut = timestamp;\n    }\n\n    function woState(address _base) external view override returns (State memory) {\n        TokenInfo memory info = infos[_base];\n        return\n            State({\n                price: info.price,\n                spread: info.spread,\n                coeff: info.coeff,\n                woFeasible: (info.price != 0 && block.timestamp <= (timestamp + staleDuration))\n            });\n    }\n\n    function state(address _base) external view override returns (State memory) {\n        TokenInfo memory info = infos[_base];\n        (uint256 basePrice, bool feasible) = price(_base);\n        return State({price: uint128(basePrice), spread: info.spread, coeff: info.coeff, woFeasible: feasible});\n    }\n\n    function cloAddress(address _base) external view override returns (address clo) {\n        clo = clOracles[_base].oracle;\n    }\n\n    /* ----- Private Functions ----- */\n\n    function _setState(\n        address _base,\n        uint128 _price,\n        uint64 _spread,\n        uint64 _coeff\n    ) internal {\n        TokenInfo storage info = infos[_base];\n        info.price = _price;\n        info.spread = _spread;\n        info.coeff = _coeff;\n    }\n\n    function _cloPriceInQuote(address _fromToken, address _toToken)\n        internal\n        view\n        returns (uint256 refPrice, uint256 refTimestamp)\n    {\n        address baseOracle = clOracles[_fromToken].oracle;\n        if (baseOracle == address(0)) {\n            return (0, 0);\n        }\n        address quoteOracle = clOracles[_toToken].oracle;\n        uint8 quoteDecimal = clOracles[_toToken].decimal;\n\n        (, int256 rawBaseRefPrice, , uint256 baseUpdatedAt, ) = AggregatorV3Interface(baseOracle).latestRoundData();\n        (, int256 rawQuoteRefPrice, , uint256 quoteUpdatedAt, ) = AggregatorV3Interface(quoteOracle).latestRoundData();\n        uint256 baseRefPrice = uint256(rawBaseRefPrice);\n        uint256 quoteRefPrice = uint256(rawQuoteRefPrice);\n\n        // NOTE: Assume wooracle token decimal is same as chainlink token decimal.\n        uint256 ceoff = uint256(10)**quoteDecimal;\n        refPrice = (baseRefPrice * ceoff) / quoteRefPrice;\n        refTimestamp = baseUpdatedAt >= quoteUpdatedAt ? quoteUpdatedAt : baseUpdatedAt;\n    }\n\n    /* ----- Zip Related Functions ----- */\n\n    function setBase(uint8 _id, address _base) external onlyAdmin {\n        require(getBase(_id) == address(0), \"WooracleV2_2: !id_SET_ALREADY\");\n        basesMap[_id] = _base;\n    }\n\n    function getBase(uint8 _id) public view returns (address) {\n        address[5] memory CONST_BASES = [\n            // mload\n            // NOTE: Update token address for different chains\n            0x82aF49447D8a07e3bd95BD0d56f35241523fBab1, // WETH\n            0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f, // WBTC\n            0xcAFcD85D8ca7Ad1e1C6F82F651fA15E33AEfD07b, // WOO\n            0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9, // USDT\n            0x912CE59144191C1204E64559FE8253a0e49E6548 // ARB\n        ];\n\n        return _id < CONST_BASES.length ? CONST_BASES[_id] : basesMap[_id];\n    }\n\n    // https://docs.soliditylang.org/en/v0.8.12/contracts.html#fallback-function\n    // prettier-ignore\n    fallback (bytes calldata _input) external onlyAdmin returns (bytes memory _output) {\n        /*\n            2 bit:  0: post prices,\n                    1: post states,\n                    2: post prices with local timestamp\n                    3: post states with local timestamp\n            6 bits: length\n\n            post prices:\n               [price] -->\n                  base token: 8 bites (1 byte)\n                  price data: 32 bits = (27, 5)\n\n            post states:\n               [states] -->\n                  base token: 8 bites (1 byte)\n                  price:      32 bits (4 bytes) = (27, 5)\n                  k coeff:    16 bits (2 bytes) = (11, 5)\n                  s spread:   16 bits (2 bytes) = (11, 5)\n\n            4 bytes (32bits): timestamp\n                MAX: 2^32-1 = 4,294,967,295 = Feb 7, 2106 6:28:15 AM (~83 years away)\n        */\n\n        uint256 x = _input.length;\n        require(x > 0, \"WooracleV2_2: !calldata\");\n\n        uint8 firstByte = uint8(bytes1(_input[0]));\n        uint8 op = firstByte >> 6; // 11000000\n        uint8 len = firstByte & 0x3F; // 00111111\n\n        if (op == 0 || op == 2) {\n            // post prices list\n            address base;\n            uint128 p;\n\n            for (uint256 i = 0; i < len; ++i) {\n                base = getBase(uint8(bytes1(_input[1 + i * 5:1 + i * 5 + 1])));\n                p = _decodePrice(uint32(bytes4(_input[1 + i * 5 + 1:1 + i * 5 + 5])));\n                infos[base].price = p;\n            }\n\n            timestamp = (op == 0) ? block.timestamp : uint256(uint32(bytes4(_input[1 + len * 5:1 + len * 5 + 4])));\n        } else if (op == 1 || op == 3) {\n            // post states list\n            address base;\n            uint128 p;\n            uint64 s;\n            uint64 k;\n\n            for (uint256 i = 0; i < len; ++i) {\n                base = getBase(uint8(bytes1(_input[1 + i * 9:1 + i * 9 + 1])));\n                p = _decodePrice(uint32(bytes4(_input[1 + i * 9 + 1:1 + i * 9 + 5])));\n                s = _decodeKS(uint16(bytes2(_input[1 + i * 9 + 5:1 + i * 9 + 7])));\n                k = _decodeKS(uint16(bytes2(_input[1 + i * 9 + 7:1 + i * 9 + 9])));\n                _setState(base, p, s, k);\n            }\n\n            timestamp = (op == 1) ? block.timestamp : uint256(uint32(bytes4(_input[1 + len * 9:1 + len * 9 + 4])));\n        } else {\n            revert(\"WooracleV2_2: !op\");\n        }\n    }\n\n    function _decodePrice(uint32 b) internal pure returns (uint128) {\n        re"
    }
  ]
}