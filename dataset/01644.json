{
  "Title": "M-2: D3Oracle.getPrice() and D3Oracle.getOriginalPrice() doesn't check If Arbitrum sequencer is down for Chainlink feeds",
  "Content": "# Issue M-2: D3Oracle.getPrice() and D3Oracle.getOriginalPrice() doesn't check If Arbitrum sequencer is down for Chainlink feeds \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/62 \n\n## Found by \n0xHati, 0xNoodleDon, 0xdice91, Avci, MohammedRizwan, PNS, PRAISE, bitsurfer, jprod15, kutugu, qckhp, seeques, shogoki, shtesesamoubiq, skyge, tsvetanovv\n## Summary\nWhen utilizing Chainlink in L2 chains like Arbitrum, it's important to ensure that the prices provided are not falsely perceived as fresh, even when the sequencer is down. This vulnerability could potentially be exploited by malicious actors to gain an unfair advantage.\n\n## Vulnerability Detail\nThere is no check in D3Oracle.getPrice()\n```solidity\n function getPrice(address token) public view override returns (uint256) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        return uint256(price) * 10 ** (36 - priceSources[token].priceDecimal - priceSources[token].tokenDecimal);\n    }\n```\n\nno check in D3Oracle.getOriginalPrice() too\n```solidity\n function getOriginalPrice(address token) public view override returns (uint256, uint8) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        uint8 priceDecimal = priceSources[token].priceDecimal;\n        return (uint256(price), priceDecimal);\n    }\n```\n\n## Impact\ncould potentially be exploited by malicious actors to gain an unfair advantage.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol#L48\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol#L58\n## Tool used\n\nManual Review\n\n## Recommendation\ncode example of Chainlink:\nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ID3Oracle} from \"../../intf/ID3Oracle.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nstruct PriceSource {\n    address oracle;\n    bool isWhitelisted;\n    uint256 priceTolerance;\n    uint8 priceDecimal;\n    uint8 tokenDecimal;\n    uint256 heartBeat;\n}\n\ncontract D3Oracle is ID3Oracle, InitializableOwnable {\n    // originToken => priceSource\n    mapping(address => PriceSource) public priceSources;\n\n    /// @notice Onwer is set in constructor\n    constructor() {\n        initOwner(msg.sender);\n    }\n\n    /// @notice Set the price source for a token\n    /// @param token The token address\n    /// @param source The price source for the token\n    function setPriceSource(address token, PriceSource calldata source) external onlyOwner {\n        priceSources[token] = source;\n        require(source.priceTolerance <= DecimalMath.ONE && source.priceTolerance >= 1e10, \"INVALID_PRICE_TOLERANCE\");\n    }\n\n    /// @notice Enable or disable oracle for a token\n    /// @dev Owner could stop oracle feed price in emergency\n    /// @param token The token address\n    /// @param isAvailable Whether the oracle is available for the token\n    function setTokenOracleFeasible(address token, bool isAvailable) external onlyOwner {\n        priceSources[token].isWhitelisted = isAvailable;\n    }\n\n    /// @notice Get the price for a token\n    /// @dev The price definition is: how much virtual USD the token values if token amount is 1e18.\n    /// @dev Example 1: if the token decimals is 18, and worth 2 USD, then price is 2e18.\n    /// @dev Example 2: if the token decimals is 8, and worth 2 USD, then price is 2e28.\n    /// @param token The token address\n    function getPrice(address token) public view override returns (uint256) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        return uint256(price) * 10 ** (36 - priceSources[token].priceDecimal - priceSources[token].tokenDecimal);\n    }\n\n    function getOriginalPrice(address token) public view override returns (uint256, uint8) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        uint8 priceDecimal = priceSources[token].priceDecimal;\n        return (uint256(price), priceDecimal);\n    }\n\n    /// @notice Return if oracle is feasible for a token\n    /// @param token The token address\n    function isFeasible(address token) external view override returns (bool) {\n        return priceSources[token].isWhitelisted;\n    }\n\n    /// @notice Given certain amount of fromToken, get the max return amount of toToken\n    /// @param fromToken The from token address\n    /// @param toToken The to token address\n    /// @param fromAmount The from token amount\n    function getMaxReceive(address fromToken, address toToken, uint256 fromAmount) external view returns (uint256) {\n        uint256 fromTlr = priceSources[fromToken].priceTolerance;\n        uint256 toTlr = priceSources[toToken].priceTolerance;\n\n        return DecimalMath.div((fromAmount * getPrice(fromToken)) / getPrice(toToken), DecimalMath.mul(fromTlr, toTlr));\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ID3Oracle} from \"../../intf/ID3Oracle.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nstruct PriceSource {\n    address oracle;\n    bool isWhitelisted;\n    uint256 priceTolerance;\n    uint8 priceDecimal;\n    uint8 tokenDecimal;\n    uint256 heartBeat;\n}\n\ncontract D3Oracle is ID3Oracle, InitializableOwnable {\n    // originToken => priceSource\n    mapping(address => PriceSource) public priceSources;\n\n    /// @notice Onwer is set in constructor\n    constructor() {\n        initOwner(msg.sender);\n    }\n\n    /// @notice Set the price source for a token\n    /// @param token The token address\n    /// @param source The price source for the token\n    function setPriceSource(address token, PriceSource calldata source) external onlyOwner {\n        priceSources[token] = source;\n        require(source.priceTolerance <= DecimalMath.ONE && source.priceTolerance >= 1e10, \"INVALID_PRICE_TOLERANCE\");\n    }\n\n    /// @notice Enable or disable oracle for a token\n    /// @dev Owner could stop oracle feed price in emergency\n    /// @param token The token address\n    /// @param isAvailable Whether the oracle is available for the token\n    function setTokenOracleFeasible(address token, bool isAvailable) external onlyOwner {\n        priceSources[token].isWhitelisted = isAvailable;\n    }\n\n    /// @notice Get the price for a token\n    /// @dev The price definition is: how much virtual USD the token values if token amount is 1e18.\n    /// @dev Example 1: if the token decimals is 18, and worth 2 USD, then price is 2e18.\n    /// @dev Example 2: if the token decimals is 8, and worth 2 USD, then price is 2e28.\n    /// @param token The token address\n    function getPrice(address token) public view override returns (uint256) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        return uint256(price) * 10 ** (36 - priceSources[token].priceDecimal - priceSources[token].tokenDecimal);\n    }\n\n    function getOriginalPrice(address token) public view override returns (uint256, uint8) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        uint8 priceDecimal = priceSources[token].priceDecimal;\n        return (uint256(price), priceDecimal);\n    }\n\n    /// @notice Return if oracle is feasible for a token\n    /// @param token The token address\n    function isFeasible(address token) external view override returns (bool) {\n        return priceSources[token].isWhitelisted;\n    }\n\n    /// @notice Given certain amount of fromToken, get the max return amount of toToken\n    /// @param fromToken The from token address\n    /// @param toToken The to token address\n    /// @param fromAmount The from token amount\n    function getMaxReceive(address fromToken, address toToken, uint256 fromAmount) external view returns (uint256) {\n        uint256 fromTlr = priceSources[fromToken].priceTolerance;\n        uint256 toTlr = priceSources[toToken].priceTolerance;\n\n        return DecimalMath.div((fromAmount * getPrice(fromToken)) / getPrice(toToken), DecimalMath.mul(fromTlr, toTlr));\n    }\n}"
    }
  ]
}