{
  "Title": "H-3: Reentrancy in Vesting.sol:claim() will allow users to drain the contract due to executing .call() on user's address before setting s.index = uint128(i)",
  "Content": "# Issue H-3: Reentrancy in Vesting.sol:claim() will allow users to drain the contract due to executing .call() on user's address before setting s.index = uint128(i) \n\nSource: https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/157 \n\n## Found by \n0x4non, 0xR360, 0xhashiman, 404666, AMOW, BengalCatBalu, HonorLt, Silvermist, UbiquitousComputing, Varun\\_05, ZdravkoHr., aman, bughuntoor, cats, cawfree, denzi\\_, dipp, enfrasico, klaus, mike-watson, nilay27, no, novaman33, psb01, s1ce, thank\\_you, turvec\n## Summary\nReentrancy in Vesting.sol:claim() will allow users to drain the contract due to executing .call() on user's address before setting s.index = uint128(I)\n\n## Vulnerability Detail\nHere is the Vesting.sol:claim() function:\n```solidity\nfunction claim() external {\n        address sender = msg.sender;\n\n        UserDetails storage s = userdetails[sender];\n        require(s.userDeposit != 0, \"No Deposit\");\n@>      require(s.index != vestingPoints.length, \"already claimed\");\n        uint256 pctAmount;\n        uint256 i = s.index;\n        for (i; i <= vestingPoints.length - 1; i++) {\n            if (block.timestamp >= vestingPoints[i][0]) {\n                pctAmount += (s.userDeposit * vestingPoints[i][1]) / 10000;\n            } else {\n                break;\n            }\n        }\n        if (pctAmount != 0) {\n            if (address(token) == address(1)) {\n@>              (bool sent, ) = payable(sender).call{value: pctAmount}(\"\");\n                require(sent, \"Failed to send BNB to receiver\");\n            } else {\n                token.safeTransfer(sender, pctAmount);\n            }\n@>          s.index = uint128(i);\n            s.amountClaimed += pctAmount;\n        }\n    }\n```\nFrom the above, You'll notice the claim() function checks if the caller already claimed by checking if the s.index has already been set to vestingPoints.length. You'll also notice the claim() function executes .call() and transfer the amount to the caller before setting the s.index = uint128(i), thereby allowing reentrancy.\n\nLet's consider this sample scenario:\n- An attacker contract(alice) has some native pctAmount to claim and calls `claim()`.\n- \"already claimed\" check will pass since it's the first time she's calling `claim()` so her s.index hasn't been set\n- However before updating Alice s.index, the Vesting contract performs external .call() to Alice with the amount sent as well\n- Alice reenters `claim()` again on receive of the amount\n- bypass index \"already claimed\" check since this hasn't been updated yet\n- contract performs external .call() to Alice with the amount sent as well again,\n- Same thing happens again\n- Alice ends up draining the Vesting contract\n\n## Impact\nReentrancy in Vesting.sol:claim() will allow users to drain the contract\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-zap-protocol/blob/main/zap-contracts-labs/contracts/Vesting.sol#L84\nhttps://github.com/sherlock-audit/2024-03-zap-protocol/blob/main/zap-contracts-labs/contracts/Vesting.sol#L89\n\n## Tool used\n\nManual Review\n\n## Recommendation\nHere is the recommended fix:\n```diff\nif (pctAmount != 0) {\n+           s.index = uint128(i);\n            if (address(token) == address(1)) {\n                (bool sent, ) = payable(sender).call{value: pctAmount}(\"\");\n                require(sent, \"Failed to send BNB to receiver\");\n            } else {\n                token.safeTransfer(sender, pctAmount);\n            }\n-           s.index = uint128(i);\n            s.amountClaimed += pctAmount;\n        }\n```\nI'll also recommend using reentrancyGuard.\n\n\n\n## Discussion\n\n**midori-fuse**\n\nEscalate \n\nPer Sherlock's [duplication rule](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules):\n\n> In the above example if the root issue A is one of the following generic vulnerabilities:\n> - Reentrancy\n> - Access control\n> - Front-running\n>\n> Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.\n> - B is a valid issue\n> - C is low\n\nThe following submissions fail to and/or incorrectly identify the root cause that enables the attack path: #6 #34 #66 #68 #79 #90 #98 #132 #149  . \n- The issues in this category should be Low.\n\nThe following submissions are somewhat vague, but did manage to identify the erroneous storage variable that leads to re-entrancy (`s.index`): #10 #53 #104 #138 #186 (and a few more). \n- While they did not (or vaguely) described the \"attack path\", the attack path here is just \"directly calling `claim()` in your `receive()`\", so I suppose one can be ok with just spelling out the function and the wrong storage variable.\n- Since submission quality is subjective, I am flagging these issues so the judges can help with reviewing dupes. Personally I think these submissions are still acceptable, but leaving to the judges to decide the where the bar is.\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Per Sherlock's [duplication rule](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules):\n> \n> > In the above example if the root issue A is one of the following generic vulnerabilities:\n> > - Reentrancy\n> > - Access control\n> > - Front-running\n> >\n> > Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.\n> > - B is a valid issue\n> > - C is low\n> \n> The following submissions fail to and/or incorrectly identify the root cause that enables the attack path: #6 #34 #66 #68 #79 #90 #98 #132 #149  . \n> - The issues in this category should be Low.\n> \n> The following submissions are somewhat vague, but did manage to identify the erroneous storage variable that leads to re-entrancy (`s.index`): #10 #53 #104 #138 #186 (and a few more). \n> - While they did not (or vaguely) described the \"attack path\", the attack path here is just \"directly calling `claim()` in your `receive()`\", so I suppose one can be ok with just spelling out the function and the wrong storage variable.\n> - Since submission quality is subjective, I am flagging these issues so the judges can help with reviewing dupes. Personally I think these submissions are still acceptable, but leaving to the judges to decide the where the bar is.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Nilay27**\n\n> Escalate\n> \n> Per Sherlock's [duplication rule](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules):\n> \n> > In the above example if the root issue A is one of the following generic vulnerabilities:\n> > \n> > * Reentrancy\n> > * Access control\n> > * Front-running\n> > \n> > Then the submissions with valid attack paths and higher vulnerability are considered valid. If the submission is vague or does not identify the attack path with higher severity clearly it will be considered low.\n> > \n> > * B is a valid issue\n> > * C is low\n> \n> The following submissions fail to and/or incorrectly identify the root cause that enables the attack path: #6 #34 #66 #68 #79 #90 #98 #132 #134 #149 .\n> \n> * The issues in this category should be Low.\n> \n> The following submissions are somewhat vague, but did manage to identify the erroneous storage variable that leads to re-entrancy (`s.index`): #10 #53 #104 #138 #186 (and a few more).\n> \n> * While they did not (or vaguely) described the \"attack path\", the attack path here is just \"directly calling `claim()` in your `receive()`\", so I suppose one can be ok with just spelling out the function and the wrong storage variable.\n> * Since submission quality is subjective, I am flagging these issues so the judges can help with reviewing dupes. Personally I think these submissions are still acceptable, but leaving to the judges to decide the where the bar is.\n\n#134 identifies the issue of how the re-entrance occurs and suggests the same remediation.\nIt clearly explains the following:\n\"The vulnerability arises from the contract's failure to update a user's claim state (s.index and s.amountClaimed) before transferring funds to the user, which allows a malicious contract to receive the funds and re-enter the claim function before the original call completes, potentially claiming more funds repeatedly.\"\n\nThe recommendation suggests updating the state before or using a reentrancy guard.\n\n I am unsure why that has been included in the `low` category per your escalation?  \n\n**midori-fuse**\n\n@Nilay27 I suppose you are right. Sorry about that, there are just too many dupes here, I might have confused it with another issue that got lost somewhere.\n\nBut be assured that unless the head of judging downright disagrees with me, all dupes will be reviewed and judged accordingly. Once again I'm sorry for my mistake.\n\n**novaman33**\n\nMy issue - #10 does show the root cause clearly and does suggest a thorough recommendation for the mitigation. I do not agree it is vague. \n\n**keesmark**\n\nIt is the same as this one, but why is it considered invalid? #119 \n\n**novaman33**\n\nProbably because #119 says that reentrancy will occur when transferring erc20 tokens while call is used to transfer eth.\n\n\n**ZdravkoHr**\n\nAlso, BNB is out of scope\n\n**Hash01011122**\n\nAcknowledging that every mentioned issue accurately identifies both the root cause of the vulnerability and the correct attack paths, yet noting the straightforward nature of the issue as a reason for minimal effort in Watson's issue, suggests a potential oversight in the importance of comprehensive reporting. \n\n**shubham-antier**\n\nIssue resolved: Moved the updations above the transfers. Also, added a reentrancy guard to better the security.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Lithium-Ventures/zap-contracts-labs/pull/2.\n\n**Evert0x**\n\n@Hash01011122 what's your proposal on the exact family for this issue? Which reports should be excluded/included?\n\n**Hash01011122**\n\n@Evert0x Had a indepth review of this family of issues:\nIssues which can be excluded are: #6, #10, #34, #66, #79, #90, #132, #138, #149.\nThe pinpoint the root cause but fail to explain any attack vector.\n\n**armormadeofwoe**\n\n> @Evert0x Had a indepth review of this family of issues: Issues which can be excluded are: #6, #10, #34, #66, #79, #90, #132, #138, #149. The pinpoint the root cause but fail to explain any attack vector.\n\nHi @Hash01011122, with all due respect, I believe #138 should remain valid since it showcases:\nroot cause - sending funds before updating variables (breach of CEI pattern)\nattack path - the ability to trigger an arbitrary fallback function due to sending native ETH that could re-enter the same function and continue claiming funds due to the unchanged variables. \n\nI do agree that my report is a little short as this is arguably the most known and recognizable issue in this space, decided to spare the judges some extra reading.\n\n\n\n**Hash01011122**\n\nImao #138 should be excluded as I mentioned above,\n\n**0x3agle**\n\n@Hash01011122 \n#6 accurately identifies the root cause and the attack path.\nRoot cause:\n> If the token == address(1) (i.e. the native token) it performs an external call which sends the token to msg.sender and then updates the storage variable.\n\nAttack Path:\n> This allows an attacker to reenter the claim function until the contract is drained completely.\n\n**Hash01011122**\n\n@0x3agle with all due respect your report doesn't mention any appropriate Attack Path.\n\n**0x3agle**\n\n@Hash01011122 \n\nIssue: storage variable updated after external call\nAttack path: reentering the claim function\nImpact: Contract drained\nMitigation: Follow CEI, add non-reentrant\n\nIsn't this enough for this issue to be considered a valid one? \n\nThis issue is so obvious I didn't feel the need for a PoC to convey my point. \n\nHaving said that, I respect your decision and will accept it. \n\n**Hash01011122**\n\nHey, if we look from that lens even issues like #10, #34, #66, #132 and #138 should be valid too. I understand what you are pointing even I don't want to invalidate any of the issues as I understand watson's would not spend more effort on writing low hanging fruit issues, However, I'm just adhering to Sherlock's rulebook. Do you want to add anything here @0x3agle?\n\n**Evert0x**\n\n> @Evert0x Had a indepth review of this family of issues: Issues which can be excluded are: #6, #10, #34, #66, #79, #90, #132, #138, #149. The pinpoint the root cause but fail to explain any attack vector.\n\nPlanning to accept escalation and move remove the reports mentioned by the Lead Judge as duplicates\n\n**0x3agle**\n\n@Hash01011122 @Evert0x \nYou missed #53 and #104\n\n*P.S. I'm not a fan of pulling down other reports but if a selected portion of reports are being disqualified because they didn't mention a \"detailed\" attack path for an obvious issue, then every report that did not include a detailed description/PoC should be considered for disqualification.*\n\n**novaman33**\n\n@Evert0x could you please identify how #10 fails to explain the attack vector. I believe the attack path is stated clearly and that the solution is also very detailed. \n\n\n**Hash01011122**\n\nAgreed, @0x3agle we can add those issues in our list. Updated issues to get excluded will be:\n#6, #10, #34, #53, #66, #79, #90, #104, #132, #138, #149 \n\n**Hash01011122**\n\n@novaman33 I don't see any valid attack path mentioned in #10 report.\n\n**Evert0x**\n\nI believe #10 identified the attack pack and shows a good understanding of the issue.\n\nAfter taken a detailed look at all reports, I believe only the following ones should be excluded as all other reports pinpoint the exact logic in the code that allows the reentrancy to happen. \n\nhttps://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/6, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/34, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/66, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/79, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/90, https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/132,  https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/149\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [midori-fuse](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/157/#issuecomment-2025184779): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/243",
  "Code": [
    {
      "filename": "zap-contracts-labs/contracts/Vesting.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"./interfaces/IAdmin.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract Vesting is Initializable, AccessControl {\n    using SafeERC20 for IERC20;\n\n    uint256[2][] public vestingPoints;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address public tokensale;\n    address public distributionWallet;\n\n    IERC20 public token;\n\n    struct UserDetails {\n        uint256 amountClaimed;\n        uint256 userDeposit;\n        uint256 index;\n    }\n\n    mapping(address => UserDetails) public userdetails;\n\n    modifier validation(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    function initialize(\n        address operator,\n        address _tokenSale,\n        IERC20 _token,\n        address _distributionWallet,\n        uint128[2][] memory _vestingPoints\n    ) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, operator);\n        tokensale = _tokenSale;\n        (vestingPoints, ) = ascendingSort(_vestingPoints);\n        token = _token;\n        distributionWallet = _distributionWallet;\n    }\n\n    function setDistributionWallet(\n        address _distributionWallet\n    ) external validation(_distributionWallet) onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributionWallet = _distributionWallet;\n    }\n\n    function updateUserDeposit(\n        address[] memory _users,\n        uint256[] memory _amount\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_users.length <= 250, \"array length should be less than 250\");\n        require(_users.length == _amount.length, \"array length should match\");\n        uint256 amount;\n        for (uint256 i = 0; i < _users.length; i++) {\n            userdetails[_users[i]].userDeposit = _amount[i];\n            amount += _amount[i];\n        }\n        token.safeTransferFrom(distributionWallet, address(this), amount);\n    }\n\n    function claim() external {\n        address sender = msg.sender;\n\n        UserDetails storage s = userdetails[sender];\n        require(s.userDeposit != 0, \"No Deposit\");\n        require(s.index != vestingPoints.length, \"already claimed\");\n        uint256 pctAmount;\n        uint256 i = s.index;\n        for (i; i <= vestingPoints.length - 1; i++) {\n            if (block.timestamp >= vestingPoints[i][0]) {\n                pctAmount += (s.userDeposit * vestingPoints[i][1]) / 10000;\n            } else {\n                break;\n            }\n        }\n        if (pctAmount != 0) {\n            if (address(token) == address(1)) {\n                (bool sent, ) = payable(sender).call{value: pctAmount}(\"\");\n                require(sent, \"Failed to send BNB to receiver\");\n            } else {\n                token.safeTransfer(sender, pctAmount);\n            }\n            s.index = uint128(i);\n            s.amountClaimed += pctAmount;\n        }\n    }\n\n    function updateVestingPoints(\n        uint128[2][] memory _vestingPoints\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 sum;\n        (vestingPoints, sum) = ascendingSort(_vestingPoints);\n        require(sum == 10000, \"sum not 10000\");\n        require(block.timestamp <= _vestingPoints[0][0], \"Time lapsed\");\n    }\n\n    function getVestingPoints() external view returns (uint256[2][] memory) {\n        return vestingPoints;\n    }\n\n    function setTokenSaleContract(\n        address _address\n    ) external validation(_address) onlyRole(DEFAULT_ADMIN_ROLE) {\n        tokensale = _address;\n    }\n\n    function takeLockedBNB() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(address(this).balance > 0, \"No BNB amount\");\n        (bool sent, ) = payable(distributionWallet).call{\n            value: address(this).balance\n        }(\"\");\n        require(sent, \"Failed to send BNB\");\n    }\n\n    function removeOtherERC20Tokens(\n        address _tokenAddress\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        IERC20(_tokenAddress).safeTransfer(\n            distributionWallet,\n            IERC20(_tokenAddress).balanceOf(address(this))\n        );\n    }\n\n    function ascendingSort(\n        uint128[2][] memory arr\n    ) internal pure returns (uint128[2][] memory, uint256) {\n        uint256 l = arr.length;\n        uint256 sum;\n        for (uint256 i = 0; i < l; i++) {\n            for (uint256 j = i + 1; j < l; j++) {\n                if (arr[i][0] > arr[j][0]) {\n                    uint128[2] memory temp = arr[j];\n                    arr[j] = arr[i];\n                    arr[i] = temp;\n                }\n            }\n            sum += arr[i][1];\n        }\n        return (arr, sum);\n    }\n}"
    },
    {
      "filename": "zap-contracts-labs/contracts/Vesting.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"./interfaces/IAdmin.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract Vesting is Initializable, AccessControl {\n    using SafeERC20 for IERC20;\n\n    uint256[2][] public vestingPoints;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address public tokensale;\n    address public distributionWallet;\n\n    IERC20 public token;\n\n    struct UserDetails {\n        uint256 amountClaimed;\n        uint256 userDeposit;\n        uint256 index;\n    }\n\n    mapping(address => UserDetails) public userdetails;\n\n    modifier validation(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    function initialize(\n        address operator,\n        address _tokenSale,\n        IERC20 _token,\n        address _distributionWallet,\n        uint128[2][] memory _vestingPoints\n    ) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, operator);\n        tokensale = _tokenSale;\n        (vestingPoints, ) = ascendingSort(_vestingPoints);\n        token = _token;\n        distributionWallet = _distributionWallet;\n    }\n\n    function setDistributionWallet(\n        address _distributionWallet\n    ) external validation(_distributionWallet) onlyRole(DEFAULT_ADMIN_ROLE) {\n        distributionWallet = _distributionWallet;\n    }\n\n    function updateUserDeposit(\n        address[] memory _users,\n        uint256[] memory _amount\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_users.length <= 250, \"array length should be less than 250\");\n        require(_users.length == _amount.length, \"array length should match\");\n        uint256 amount;\n        for (uint256 i = 0; i < _users.length; i++) {\n            userdetails[_users[i]].userDeposit = _amount[i];\n            amount += _amount[i];\n        }\n        token.safeTransferFrom(distributionWallet, address(this), amount);\n    }\n\n    function claim() external {\n        address sender = msg.sender;\n\n        UserDetails storage s = userdetails[sender];\n        require(s.userDeposit != 0, \"No Deposit\");\n        require(s.index != vestingPoints.length, \"already claimed\");\n        uint256 pctAmount;\n        uint256 i = s.index;\n        for (i; i <= vestingPoints.length - 1; i++) {\n            if (block.timestamp >= vestingPoints[i][0]) {\n                pctAmount += (s.userDeposit * vestingPoints[i][1]) / 10000;\n            } else {\n                break;\n            }\n        }\n        if (pctAmount != 0) {\n            if (address(token) == address(1)) {\n                (bool sent, ) = payable(sender).call{value: pctAmount}(\"\");\n                require(sent, \"Failed to send BNB to receiver\");\n            } else {\n                token.safeTransfer(sender, pctAmount);\n            }\n            s.index = uint128(i);\n            s.amountClaimed += pctAmount;\n        }\n    }\n\n    function updateVestingPoints(\n        uint128[2][] memory _vestingPoints\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 sum;\n        (vestingPoints, sum) = ascendingSort(_vestingPoints);\n        require(sum == 10000, \"sum not 10000\");\n        require(block.timestamp <= _vestingPoints[0][0], \"Time lapsed\");\n    }\n\n    function getVestingPoints() external view returns (uint256[2][] memory) {\n        return vestingPoints;\n    }\n\n    function setTokenSaleContract(\n        address _address\n    ) external validation(_address) onlyRole(DEFAULT_ADMIN_ROLE) {\n        tokensale = _address;\n    }\n\n    function takeLockedBNB() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(address(this).balance > 0, \"No BNB amount\");\n        (bool sent, ) = payable(distributionWallet).call{\n            value: address(this).balance\n        }(\"\");\n        require(sent, \"Failed to send BNB\");\n    }\n\n    function removeOtherERC20Tokens(\n        address _tokenAddress\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        IERC20(_tokenAddress).safeTransfer(\n            distributionWallet,\n            IERC20(_tokenAddress).balanceOf(address(this))\n        );\n    }\n\n    function ascendingSort(\n        uint128[2][] memory arr\n    ) internal pure returns (uint128[2][] memory, uint256) {\n        uint256 l = arr.length;\n        uint256 sum;\n        for (uint256 i = 0; i < l; i++) {\n            for (uint256 j = i + 1; j < l; j++) {\n                if (arr[i][0] > arr[j][0]) {\n                    uint128[2] memory temp = arr[j];\n                    arr[j] = arr[i];\n                    arr[i] = temp;\n                }\n            }\n            sum += arr[i][1];\n        }\n        return (arr, sum);\n    }\n}"
    }
  ]
}