{
  "Title": "[H-03] `_handleRepay` of `MoneyMarketHook` does not consider the actual debt shares of the `posId` inside the position manager and could lead to a user's tokens getting stuck inside the hook",
  "Content": "\nWhen users construct repay operations via `MoneyMarketHook`, it doesn't consider the actual debt shares of the position inside the `InitCore` and `PosManager`. This could lead to users' tokens getting stuck inside the `MoneyMarketHook` contract.\n\n### Proof of Concept\n\nWhen users want to repay his positions in `MoneyMarketHook`, they can provide the parameters inside `repayParams`, and `MoneyMarketHook` will construct the operation via `_handleRepay` function.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L145-L159>\n\n```solidity\n    function _handleRepay(uint _offset, bytes[] memory _data, uint _initPosId, RepayParams[] memory _params)\n        internal\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            address uToken = ILendingPool(_params[i].pool).underlyingToken();\n>>>         uint repayAmt = ILendingPool(_params[i].pool).debtShareToAmtCurrent(_params[i].shares);\n            _ensureApprove(uToken, repayAmt);\n>>>         IERC20(uToken).safeTransferFrom(msg.sender, address(this), repayAmt);\n            _data[_offset] =\n                abi.encodeWithSelector(IInitCore.repay.selector, _params[i].pool, _params[i].shares, _initPosId);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n```\n\nIt can be observed that it calculates the `repayAmt` based on the shares provided by the users and transfers the corresponding amount of tokens from the sender to the hook. However, the actual debt shares of the position can be less than the `_params[i].shares` provided by users. This means that the actual repay amount of tokens needed could be less than the calculated `repayAmt`.\n\n<https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L530-L551>\n\n```solidity\n    function _repay(IConfig _config, uint16 _mode, uint _posId, address _pool, uint _shares)\n        internal\n        returns (address tokenToRepay, uint amt)\n    {\n        // check status\n        _require(_config.getPoolConfig(_pool).canRepay && _config.getModeStatus(_mode).canRepay, Errors.REPAY_PAUSED);\n        // get position debt share\n>>>     uint positionDebtShares = IPosManager(POS_MANAGER).getPosDebtShares(_posId, _pool);\n>>>     uint sharesToRepay = _shares < positionDebtShares ? _shares : positionDebtShares;\n        // get amtToRepay (accrue interest)\n>>>     uint amtToRepay = ILendingPool(_pool).debtShareToAmtCurrent(sharesToRepay);\n        // take token from msg.sender to pool\n        tokenToRepay = ILendingPool(_pool).underlyingToken();\n>>>     IERC20(tokenToRepay).safeTransferFrom(msg.sender, _pool, amtToRepay);\n        // update debt on the position\n        IPosManager(POS_MANAGER).updatePosDebtShares(_posId, _pool, -sharesToRepay.toInt256());\n        // call repay on the pool\n        amt = ILendingPool(_pool).repay(sharesToRepay);\n        // update debt on mode\n        IRiskManager(riskManager).updateModeDebtShares(_mode, _pool, -sharesToRepay.toInt256());\n        emit Repay(_pool, _posId, msg.sender, _shares, amt);\n    }\n```\n\nConsider a scenario where the user's positions are currently liquidatable, and the user wishes to repay all of the position's debt inside the `MoneyMarketHook`. However, a liquidator front-runs the operation by liquidating the user's position. Now, when the repayment operation executes from `MoneyMarketHook`, it transfers the `repayAmt` to the `MoneyMarketHook` but the amount is not used/fully utilized and becomes stuck inside the contract.\n\n### Recommended Mitigation Steps\n\nConsider to also check the provided shares against the actual debt shares inside the `InitCore`/`PosManager`.\n\n**[fez-init (INIT) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/28#issuecomment-1870322481):**\n > The issue should be medium, since the funds cannot be retrieved by someone else. The hook will be upgradeable, so if funds actually get stuck, it is still retrievable.\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/28#issuecomment-1871745239):**\n > I agree that this issue is in the middle of Medium and High.\n> Users might face a temporary lock on their funds, and the hook should be upgraded every time to unlock them.\n>\n> Given the high probability of this scenario occurring, I will keep this issue as a valid High.\n\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-initcapital",
  "Code": [
    {
      "filename": "contracts/hook/MoneyMarketHook.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {IMulticall} from '../interfaces/common/IMulticall.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IWNative} from '../interfaces/common/IWNative.sol';\nimport {IRebaseHelper} from '../interfaces/helper/rebase_helper/IRebaseHelper.sol';\nimport {IMoneyMarketHook} from '../interfaces/hook/IMoneyMarketHook.sol';\n\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin-contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC721HolderUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\n// NOTE: only support normal money market actions (deposit, withdraw, borrow, repay, change position mode)\ncontract MoneyMarketHook is IMoneyMarketHook, ERC721HolderUpgradeable {\n    using UncheckedIncrement for uint;\n    using SafeERC20 for IERC20;\n\n    // immutables\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable CORE;\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable POS_MANAGER;\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable WNATIVE;\n\n    // storages\n    /// @inheritdoc IMoneyMarketHook\n    mapping(address => uint) public lastPosIds;\n    /// @inheritdoc IMoneyMarketHook\n    mapping(address => mapping(uint => uint)) public initPosIds;\n\n    // constructor\n    constructor(address _initCore, address _wNative) {\n        CORE = _initCore;\n        POS_MANAGER = IInitCore(_initCore).POS_MANAGER();\n        WNATIVE = _wNative;\n        _disableInitializers();\n    }\n\n    // initialize\n    /// @dev initialize the contract\n    function initialize() external initializer {}\n\n    // functions\n    /// @inheritdoc IMoneyMarketHook\n    function execute(OperationParams calldata _params)\n        external\n        payable\n        returns (uint posId, uint initPosId, bytes[] memory results)\n    {\n        // create position if not exist\n        if (_params.posId == 0) {\n            (posId, initPosId) = createPos(_params.mode, _params.viewer);\n        } else {\n            // for existing position, only owner can execute\n            posId = _params.posId;\n            initPosId = initPosIds[msg.sender][posId];\n            _require(IERC721(POS_MANAGER).ownerOf(initPosId) == address(this), Errors.NOT_OWNER);\n        }\n        results = _handleMulticall(initPosId, _params);\n        // check slippage\n        _require(_params.minHealth_e18 <= IInitCore(CORE).getPosHealthCurrent_e18(initPosId), Errors.SLIPPAGE_CONTROL);\n        // unwrap token if needed\n        for (uint i; i < _params.withdrawParams.length; i = i.uinc()) {\n            address helper = _params.withdrawParams[i].rebaseHelperParams.helper;\n            if (helper != address(0)) IRebaseHelper(helper).unwrap(_params.withdrawParams[i].to);\n        }\n        // return native token\n        if (_params.returnNative) {\n            IWNative(WNATIVE).withdraw(IERC20(WNATIVE).balanceOf(address(this)));\n            (bool success,) = payable(msg.sender).call{value: address(this).balance}('');\n            _require(success, Errors.CALL_FAILED);\n        }\n    }\n\n    /// @inheritdoc IMoneyMarketHook\n    function createPos(uint16 _mode, address _viewer) public returns (uint posId, uint initPosId) {\n        posId = ++lastPosIds[msg.sender];\n        initPosId = IInitCore(CORE).createPos(_mode, _viewer);\n        initPosIds[msg.sender][posId] = initPosId;\n    }\n\n    /// @dev approve token for init core if needed\n    /// @param _token token address\n    /// @param _amt token amount to spend\n    function _ensureApprove(address _token, uint _amt) internal {\n        if (IERC20(_token).allowance(address(this), CORE) < _amt) {\n            IERC20(_token).safeApprove(CORE, type(uint).max);\n        }\n    }\n\n    // @dev prepare and execute multicall\n    // @param _initPosId init position id (nft id)\n    // @param _params operation parameters\n    // @return results results of multicall\n    function _handleMulticall(uint _initPosId, OperationParams calldata _params)\n        internal\n        returns (bytes[] memory results)\n    {\n        // prepare data for multicall\n        // 1. repay (if needed)\n        // 2. withdraw (if needed)\n        // 3. change position mode (if needed)\n        // 4. borrow (if needed)\n        // 5. deposit (if needed)\n        bool changeMode = _params.mode != 0 && _params.mode != IPosManager(POS_MANAGER).getPosMode(_initPosId);\n        bytes[] memory data;\n        {\n            uint dataLength = _params.repayParams.length + (2 * _params.withdrawParams.length) + (changeMode ? 1 : 0)\n                + _params.borrowParams.length + (2 * _params.depositParams.length);\n            data = new bytes[](dataLength);\n        }\n        uint offset;\n        // 1. repay\n        (offset, data) = _handleRepay(offset, data, _initPosId, _params.repayParams);\n        // 2. withdraw\n        (offset, data) = _handleWithdraw(offset, data, _initPosId, _params.withdrawParams);\n        // 3. change position mode\n        if (changeMode) {\n            data[offset] = abi.encodeWithSelector(IInitCore.setPosMode.selector, _initPosId, _params.mode);\n            offset = offset.uinc();\n        }\n        // 4. borrow\n        (offset, data) = _handleBorrow(offset, data, _initPosId, _params.borrowParams);\n        // 5. deposit\n        (offset, data) = _handleDeposit(offset, data, _initPosId, _params.depositParams);\n        // execute multicall\n        results = IMulticall(CORE).multicall(data);\n    }\n\n    /// @dev generate repay data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params repay params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleRepay(uint _offset, bytes[] memory _data, uint _initPosId, RepayParams[] memory _params)\n        internal\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            address uToken = ILendingPool(_params[i].pool).underlyingToken();\n            uint repayAmt = ILendingPool(_params[i].pool).debtShareToAmtCurrent(_params[i].shares);\n            _ensureApprove(uToken, repayAmt);\n            IERC20(uToken).safeTransferFrom(msg.sender, address(this), repayAmt);\n            _data[_offset] =\n                abi.encodeWithSelector(IInitCore.repay.selector, _params[i].pool, _params[i].shares, _initPosId);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate withdraw data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params withdraw params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleWithdraw(uint _offset, bytes[] memory _data, uint _initPosId, WithdrawParams[] calldata _params)\n        internal\n        view\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            // decollateralize to pool\n            _data[_offset] = abi.encodeWithSelector(\n                IInitCore.decollateralize.selector, _initPosId, _params[i].pool, _params[i].shares, _params[i].pool\n            );\n            _offset = _offset.uinc();\n            // burn collateral to underlying token\n            address helper = _params[i].rebaseHelperParams.helper;\n            address uTokenReceiver = _params[i].to;\n            // if need to unwrap to rebase token\n            if (helper != address(0)) {\n                address uToken = ILendingPool(_params[i].pool).underlyingToken();\n                _require(\n                    _params[i].rebaseHelperParams.tokenIn == uToken\n                        && IRebaseHelper(_params[i].rebaseHelperParams.helper).YIELD_BEARING_TOKEN() == uToken,\n                    Errors.INVALID_TOKEN_IN\n                );\n                uTokenReceiver = helper;\n            }\n            _data[_offset] = abi.encodeWithSelector(IInitCore.burnTo.selector, _params[i].pool, uTokenReceiver);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate borrow data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params borrow params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleBorrow(uint _offset, bytes[] memory _data, uint _initPosId, BorrowParams[] calldata _params)\n        internal\n        pure\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            _data[_offset] = abi.encodeWithSelector(\n                IInitCore.borrow.selector, _params[i].pool, _params[i].amt, _initPosId, _params[i].to\n            );\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate deposit data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params deposit params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleDeposit(uint _offset, bytes[] memory _data, uint _initPosId, DepositParams[] calldata _params)\n        internal\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            address pool = _params[i].pool;\n            uint amt = _params[i].amt;\n            address uToken = ILendingPool(pool).underlyingToken();\n            address helper = _params[i].rebaseHelperParams.helper;\n            // 1. deposit native token\n            // NOTE: use msg.value for native token\n            // amt > 0 mean user want to use wNative too\n            if (uToken == WNATIVE) {\n                IWNative(WNATIVE).deposit{value: msg.value}();\n                IERC20(WNATIVE).safeTransfer(pool, msg.value);\n                // transfer wNative to pool will user want to use wNative\n                if (amt != 0) {\n                    IERC20(WNATIVE).safeTransferFrom(msg.sender, pool, amt);\n                }\n            }\n            // 2. wrap rebase token to non-rebase token and deposit\n            else if (helper != address(0)) {\n                address tokenIn = _params[i].rebaseHelperParams.tokenIn;\n                _require(\n                    IRebaseHelper(_params[i].rebaseHelperParams.helper).REBASE_TOKEN() == tokenIn,\n                    Errors.INVALID_TOKEN_IN\n                );\n                _require(\n                    IRebaseHelper(_params[i].rebaseHelperParams.helper).YIELD_BEARING_TOKEN() == uToken,\n                    Errors.INVALID_TOKEN_OUT\n                );\n                IERC20(tokenIn).safeTransferFrom(msg.sender, helper, amt);\n                IRebaseHelper(helper).wrap(pool);\n            }\n            // 3. deposit normal erc20 token\n            else {\n                IERC20(uToken).safeTransferFrom(msg.sender, pool, amt);\n            }\n            // mint to position\n            _data[_offset] = abi.encodeWithSelector(IInitCore.mintTo.selector, pool, POS_MANAGER);\n            _offset = _offset.uinc();\n            // collateralize\n            _data[_offset] = abi.encodeWithSelector(IInitCore.collateralize.selector, _initPosId, pool);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n}"
    },
    {
      "filename": "contracts/core/InitCore.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport {Multicall} from '../common/Multicall.sol';\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ModeConfig, PoolConfig, TokenFactors, ModeStatus, IConfig} from '../interfaces/core/IConfig.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IBaseWrapLp} from '../interfaces/wrapper/IBaseWrapLp.sol';\nimport {IInitOracle} from '../interfaces/oracle/IInitOracle.sol';\nimport {ILiqIncentiveCalculator} from '../interfaces/core/ILiqIncentiveCalculator.sol';\nimport {ICallbackReceiver} from '../interfaces/receiver/ICallbackReceiver.sol';\nimport {IFlashReceiver} from '../interfaces/receiver/IFlashReceiver.sol';\nimport {IRiskManager} from '../interfaces/risk_manager/IRiskManager.sol';\n\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport {SafeCast} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {MathUpgradeable} from '@openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin-contracts/token/ERC721/IERC721.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\n\ncontract InitCore is IInitCore, Multicall, ReentrancyGuardUpgradeable, UnderACM {\n    using SafeCast for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using MathUpgradeable for uint;\n    using UncheckedIncrement for uint;\n\n    // constants\n    uint private constant ONE_E18 = 1e18;\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n    bytes32 private constant GOVERNOR = keccak256('governor');\n\n    // immutables\n    address public immutable POS_MANAGER;\n\n    // storages\n    address public config; // @inheritdoc IInitCore\n    address public oracle; // @inheritdoc IInitCore\n    address public liqIncentiveCalculator; // @inheritdoc IInitCore\n    address public riskManager; // @inheritdoc IInitCore\n    bool internal isMulticallTx;\n    EnumerableSet.UintSet internal uncheckedPosIds; // posIds that need to be checked after multicall\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyGovernor() {\n        ACM.checkRole(GOVERNOR, msg.sender);\n        _;\n    }\n\n    modifier onlyAuthorized(uint _posId) {\n        _require(IPosManager(POS_MANAGER).isAuthorized(msg.sender, _posId), Errors.NOT_AUTHORIZED);\n        _;\n    }\n\n    /// @dev keep track of the position and ensure that the position is healthy at the very end\n    /// @param _posId pos id to ensure health\n    modifier ensurePositionHealth(uint _posId) {\n        if (isMulticallTx) uncheckedPosIds.add(_posId);\n        _;\n        if (!isMulticallTx) _require(_isPosHealthy(_posId), Errors.POSITION_NOT_HEALTHY);\n    }\n\n    // constructor\n    constructor(address _posManager, address _accessControlManager) UnderACM(_accessControlManager) {\n        POS_MANAGER = _posManager;\n        _disableInitializers();\n    }\n\n    // initalize\n    /// @dev initialize contract and setup config, oracle, incentive calculator and risk manager addresses\n    /// @param _config config address\n    /// @param _oracle oracle address\n    /// @param _liqIncentiveCalculator liquidation incentive calculator address\n    /// @param _riskManager risk manager address\n    function initialize(address _config, address _oracle, address _liqIncentiveCalculator, address _riskManager)\n        external\n        initializer\n    {\n        __ReentrancyGuard_init();\n        _setConfig(_config);\n        _setOracle(_oracle);\n        _setLiqIncentiveCalculator(_liqIncentiveCalculator);\n        _setRiskManager(_riskManager);\n    }\n\n    // functions\n    /// @inheritdoc IInitCore\n    function mintTo(address _pool, address _to) public virtual nonReentrant returns (uint shares) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canMint, Errors.MINT_PAUSED);\n        // call mint at pool using _to\n        shares = ILendingPool(_pool).mint(_to);\n        // check supply cap after mint\n        _require(ILendingPool(_pool).totalAssets() <= poolConfig.supplyCap, Errors.SUPPLY_CAP_REACHED);\n    }\n\n    /// @inheritdoc IInitCore\n    function burnTo(address _pool, address _to) public virtual nonReentrant returns (uint amt) {\n        // check pool status\n        PoolConfig memory poolConfig = IConfig(config).getPoolConfig(_pool);\n        _require(poolConfig.canBurn, Errors.REDEEM_PAUSED);\n        // call burn at pool using _to\n        amt = ILendingPool(_pool).burn(_to);\n    }\n\n    /// @inheritdoc IInitCore\n    function borrow(address _pool, uint _amt, uint _posId, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n        returns (uint shares)\n    {\n        IConfig _config = IConfig(config);\n        // check pool and mode status\n        PoolConfig memory poolConfig = _config.getPoolConfig(_pool);\n        uint16 mode = _getPosMode(_posId);\n        _require(poolConfig.canBorrow && _config.getModeStatus(mode).canBorrow, Errors.BORROW_PAUSED);\n        // check if the position mode supports _pool\n        _require(_config.isAllowedForBorrow(mode, _pool), Errors.INVALID_MODE);\n        // get borrow shares (accrue interest)\n        shares = ILendingPool(_pool).debtAmtToShareCurrent(_amt);\n        // check shares != 0\n        _require(shares != 0, Errors.ZERO_VALUE);\n        // check borrow cap after borrow\n        _require(ILendingPool(_pool).totalDebt() + _amt <= poolConfig.borrowCap, Errors.BORROW_CAP_REACHED);\n        // update debt on the position\n        IPosManager(POS_MANAGER).updatePosDebtShares(_posId, _pool, shares.toInt256());\n        // call borrow from the pool with target _to\n        ILendingPool(_pool).borrow(_to, _amt);\n        // update debt on mode\n        IRiskManager(riskManager).updateModeDebtShares(mode, _pool, shares.toInt256());\n        emit Borrow(_pool, _posId, _to, _amt, shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function repay(address _pool, uint _shares, uint _posId)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        nonReentrant\n        returns (uint amt)\n    {\n        (, amt) = _repay(IConfig(config), _getPosMode(_posId), _posId, _pool, _shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function createPos(uint16 _mode, address _viewer) public virtual nonReentrant returns (uint posId) {\n        _require(_mode != 0, Errors.INVALID_MODE);\n        posId = IPosManager(POS_MANAGER).createPos(msg.sender, _mode, _viewer);\n        emit CreatePosition(msg.sender, posId, _mode, _viewer);\n    }\n\n    /// @inheritdoc IInitCore\n    function setPosMode(uint _posId, uint16 _mode)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // get current collaterals in the position\n        (address[] memory pools,, address[] memory wLps, uint[][] memory ids,) =\n            IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n        uint16 currentMode = _getPosMode(_posId);\n        ModeStatus memory currentModeStatus = _config.getModeStatus(currentMode);\n        ModeStatus memory newModeStatus = _config.getModeStatus(_mode);\n        if (pools.length != 0 || wLps.length != 0) {\n            _require(newModeStatus.canCollateralize, Errors.COLLATERALIZE_PAUSED);\n            _require(currentModeStatus.canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        }\n        // check that each position collateral belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForCollateral(_mode, pools[i]), Errors.INVALID_MODE);\n        }\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                _require(_config.isAllowedForCollateral(_mode, IBaseWrapLp(wLps[i]).lp(ids[i][j])), Errors.INVALID_MODE);\n            }\n        }\n        // get current debts in the position\n        uint[] memory shares;\n        (pools, shares) = IPosManager(POS_MANAGER).getPosBorrInfo(_posId);\n        IRiskManager _riskManager = IRiskManager(riskManager);\n        // check that each position debt belongs to the _mode\n        for (uint i; i < pools.length; i = i.uinc()) {\n            _require(_config.isAllowedForBorrow(_mode, pools[i]), Errors.INVALID_MODE);\n            _require(newModeStatus.canBorrow, Errors.BORROW_PAUSED);\n            _require(currentModeStatus.canRepay, Errors.REPAY_PAUSED);\n            // update debt on current mode\n            _riskManager.updateModeDebtShares(currentMode, pools[i], -shares[i].toInt256());\n            // update debt on new mode\n            _riskManager.updateModeDebtShares(_mode, pools[i], shares[i].toInt256());\n        }\n        // update position mode\n        IPosManager(POS_MANAGER).updatePosMode(_posId, _mode);\n        emit SetPositionMode(_posId, _mode);\n    }\n\n    /// @inheritdoc IInitCore\n    function collateralize(uint _posId, address _pool) public virtual onlyAuthorized(_posId) nonReentrant {\n        IConfig _config = IConfig(config);\n        // check mode status\n        uint16 mode = _getPosMode(_posId);\n        _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the position mode supports _pool\n        _require(_config.isAllowedForCollateral(mode, _pool), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateral(_posId, _pool);\n        emit Collateralize(_posId, _pool, amtColl);\n    }\n\n    /// @inheritdoc IInitCore\n    function decollateralize(uint _posId, address _pool, uint _shares, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        // check mode status\n        _require(IConfig(config).getModeStatus(_getPosMode(_posId)).canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        // take _pool from position to _to\n        uint amtDecoll = IPosManager(POS_MANAGER).removeCollateralTo(_posId, _pool, _shares, _to);\n        emit Decollateralize(_posId, _pool, _to, amtDecoll);\n    }\n\n    /// @inheritdoc IInitCore\n    function collateralizeWLp(uint _posId, address _wLp, uint _tokenId)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // check mode status\n        _require(_config.getModeStatus(mode).canCollateralize, Errors.COLLATERALIZE_PAUSED);\n        // check if the wLp is whitelisted\n        _require(_config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED);\n        // check if the position mode supports _wLp\n        _require(_config.isAllowedForCollateral(mode, IBaseWrapLp(_wLp).lp(_tokenId)), Errors.INVALID_MODE);\n        // update collateral on the position\n        uint amtColl = IPosManager(POS_MANAGER).addCollateralWLp(_posId, _wLp, _tokenId);\n        emit CollateralizeWLp(_wLp, _tokenId, _posId, amtColl);\n    }\n\n    /// @inheritdoc IInitCore\n    function decollateralizeWLp(uint _posId, address _wLp, uint _tokenId, uint _amt, address _to)\n        public\n        virtual\n        onlyAuthorized(_posId)\n        ensurePositionHealth(_posId)\n        nonReentrant\n    {\n        IConfig _config = IConfig(config);\n        // check mode status\n        _require(_config.getModeStatus(_getPosMode(_posId)).canDecollateralize, Errors.DECOLLATERALIZE_PAUSED);\n        // check wLp is whitelisted\n        _require(_config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED);\n        // update and take _wLp from position to _to\n        uint amtDecoll = IPosManager(POS_MANAGER).removeCollateralWLpTo(_posId, _wLp, _tokenId, _amt, _to);\n        emit Decollateralize(_wLp, _posId, _to, amtDecoll);\n    }\n\n    /// @inheritdoc IInitCore\n    function liquidate(uint _posId, address _poolToRepay, uint _repayShares, address _poolOut, uint _minShares)\n        public\n        virtual\n        nonReentrant\n        returns (uint shares)\n    {\n        LiquidateLocalVars memory vars = _liquidateInternal(_posId, _poolToRepay, _repayShares);\n\n        _require(vars.config.isAllowedForCollateral(vars.mode, _poolOut), Errors.TOKEN_NOT_WHITELISTED); // config and mode are already stored\n\n        vars.collToken = ILendingPool(_poolOut).underlyingToken();\n        vars.liqIncentive_e18 = ILiqIncentiveCalculator(liqIncentiveCalculator).getLiqIncentiveMultiplier_e18(\n            vars.mode, vars.health_e18, vars.repayToken, vars.collToken\n        );\n        vars.repayAmtWithLiqIncentive = (vars.repayAmt * vars.liqIncentive_e18) / ONE_E18;\n        {\n            uint[] memory prices_e36; // prices = [repayTokenPrice, collToken]\n            address[] memory tokens = new address[](2);\n            (tokens[0], tokens[1]) = (vars.repayToken, vars.collToken);\n            prices_e36 = IInitOracle(oracle).getPrices_e36(tokens);\n            // calculate _tokenOut amt to return to liquidator\n            shares = ILendingPool(_poolOut).toShares((vars.repayAmtWithLiqIncentive * prices_e36[0]) / prices_e36[1]);\n            // take min of what's available (for bad debt repayment)\n            shares = shares.min(IPosManager(POS_MANAGER).getCollAmt(_posId, _poolOut)); // take min of what's available\n            _require(shares >= _minShares, Errors.SLIPPAGE_CONTROL);\n        }\n        // take _tokenOut from position to msg.sender\n        IPosManager(POS_MANAGER).removeCollateralTo(_posId, _poolOut, shares, msg.sender);\n        // check that position's health <= maxHealth\n        // NOTE: bypass this for underwater position\n        if (vars.health_e18 != 0) _ensurePosHealthAfterLiq(vars.config, _posId, vars.mode);\n        emit Liquidate(_posId, msg.sender, _poolOut, shares);\n    }\n\n    /// @inheritdoc IInitCore\n    function liquidateWLp(\n        uint _posId,\n        address _poolToRepay,\n        uint _repayShares,\n        address _wLp,\n        uint _tokenId,\n        uint _minlpOut\n    ) external virtual nonReentrant returns (uint lpAmtOut) {\n        LiquidateLocalVars memory vars = _liquidateInternal(_posId, _poolToRepay, _repayShares);\n\n        _require(vars.config.whitelistedWLps(_wLp), Errors.TOKEN_NOT_WHITELISTED); // config is already stored\n\n        vars.collToken = IBaseWrapLp(_wLp).lp(_tokenId);\n\n        vars.liqIncentive_e18 = ILiqIncentiveCalculator(liqIncentiveCalculator).getLiqIncentiveMultiplier_e18(\n            vars.mode, vars.health_e18, vars.repayToken, vars.collToken\n        );\n        vars.repayAmtWithLiqIncentive = (vars.repayAmt * vars.liqIncentive_e18) / ONE_E18;\n\n        uint wLpAmtToBurn;\n        {\n            address _oracle = oracle;\n            uint wLpAmt = IPosManager(POS_MANAGER).getCollWLpAmt(_posId, _wLp, _tokenId);\n            wLpAmtToBurn = IInitOracle(_oracle).getPrice_e36(vars.repayToken).mulDiv(\n                vars.repayAmtWithLiqIncentive, IBaseWrapLp(_wLp).calculatePrice_e36(_tokenId, _oracle)\n            );\n            // take min of what's available (for bad debt repayment)\n            wLpAmtToBurn = wLpAmtToBurn.min(wLpAmt);\n        }\n        // reduce and burn wLp to underlying for liquidator\n        lpAmtOut = IPosManager(POS_MANAGER).removeCollateralWLpTo(_posId, _wLp, _tokenId, wLpAmtToBurn, msg.sender);\n        _require(lpAmtOut >= _minlpOut, Errors.SLIPPAGE_CONTROL);\n        // check that position's health <= maxHealth\n        // NOTE: bypass this for underwater position\n        if (vars.health_e18 != 0) _ensurePosHealthAfterLiq(vars.config, _posId, vars.mode);\n        emit LiquidateWLp(_posId, msg.sender, _wLp, _tokenId, wLpAmtToBurn);\n    }\n\n    /// @inheritdoc IInitCore\n    function flash(address[] calldata _pools, uint[] calldata _amts, bytes calldata _data)\n        public\n        virtual\n        nonReentrant\n    {\n        // validate _pools and _amts length & validate _pools contain distinct addresses to avoid paying less flash fees\n        _require(_validateFlash(_pools, _amts), Errors.INVALID_FLASHLOAN);\n        // check that is not multicall tx\n        _require(!isMulticallTx, Errors.LOCKED_MULTICALL);\n        uint[] memory balanceBefores = new uint[](_pools.length);\n        uint[] memory fees = new uint[](_pools.length);\n        IConfig _config = IConfig(config);\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            PoolConfig memory poolConfig = _config.getPoolConfig(_pools[i]);\n            // check that flash is enabled\n            _require(poolConfig.canFlash, Errors.FLASH_PAUSED);\n            address token = ILendingPool(_pools[i]).underlyingToken();\n            // calculate return amt\n            balanceBefores[i] = IERC20(token).balanceOf(_pools[i]);\n            fees[i] = (_amts[i] * poolConfig.flashFee_e18).ceilDiv(ONE_E18); // round up\n            // take _amts[i] of _pools[i] to msg.sender\n            IERC20(token).safeTransferFrom(_pools[i], msg.sender, _amts[i]);\n        }\n        // execute callback\n        IFlashReceiver(msg.sender).flashCallback(_pools, _amts, fees, _data);\n        // sync cash\n        for (uint i; i < _pools.length; i = i.uinc()) {\n            uint poolCash = ILendingPool(_pools[i]).syncCash();\n            _require(poolCash >= balanceBefores[i] + fees[i], Errors.INVALID_AMOUNT_TO_REPAY);\n        }\n    }\n\n    /// @dev multicall function with health check after all call\n    function multicall(bytes[] calldata data) public payable virtual override returns (bytes[] memory results) {\n        _require(!isMulticallTx, Errors.LOCKED_MULTICALL);\n        isMulticallTx = true;\n        // multicall\n        results = super.multicall(data);\n        // === loop uncheckedPosIds ===\n        uint[] memory posIds = uncheckedPosIds.values();\n        for (uint i; i < posIds.length; i = i.uinc()) {\n            // check position health\n            _require(_isPosHealthy(posIds[i]), Errors.POSITION_NOT_HEALTHY);\n            uncheckedPosIds.remove(posIds[i]);\n        }\n        // clear uncheckedPosIds\n        isMulticallTx = false;\n    }\n\n    /// @inheritdoc IInitCore\n    function setConfig(address _config) external onlyGovernor {\n        _setConfig(_config);\n    }\n\n    /// @inheritdoc IInitCore\n    function setOracle(address _oracle) external onlyGovernor {\n        _setOracle(_oracle);\n    }\n\n    /// @inheritdoc IInitCore\n    function setLiqIncentiveCalculator(address _liqIncentiveCalculator) external onlyGuardian {\n        _setLiqIncentiveCalculator(_liqIncentiveCalculator);\n    }\n\n    /// @inheritdoc IInitCore\n    function setRiskManager(address _riskManager) external onlyGuardian {\n        _setRiskManager(_riskManager);\n    }\n\n    /// @dev set config\n    function _setConfig(address _config) internal {\n        config = _config;\n        emit SetConfig(_config);\n    }\n\n    /// @dev set oracle\n    function _setOracle(address _oracle) internal {\n        oracle = _oracle;\n        emit SetOracle(_oracle);\n    }\n\n    /// @dev set liquidation incentive calculator\n    function _setLiqIncentiveCalculator(address _liqIncentiveCalculator) internal {\n        liqIncentiveCalculator = _liqIncentiveCalculator;\n        emit SetIncentiveCalculator(_liqIncentiveCalculator);\n    }\n\n    /// @dev set risk manager\n    function _setRiskManager(address _riskManager) internal {\n        riskManager = _riskManager;\n        emit SetRiskManager(_riskManager);\n    }\n\n    /// @inheritdoc IInitCore\n    function getCollateralCreditCurrent_e36(uint _posId) public virtual returns (uint collCredit_e36) {\n        address _oracle = oracle;\n        IConfig _config = IConfig(config);\n        uint16 mode = _getPosMode(_posId);\n        // get position collateral\n        (address[] memory pools, uint[] memory shares, address[] memory wLps, uint[][] memory ids, uint[][] memory amts)\n        = IPosManager(POS_MANAGER).getPosCollInfo(_posId);\n        // calculate collateralCredit\n        uint collCredit_e54;\n        for (uint i; i < pools.length; i = i.uinc()) {\n            address token = ILendingPool(pools[i]).underlyingToken();\n            uint tokenPrice_e36 = IInitOracle(_oracle).getPrice_e36(token);\n            uint tokenValue_e36 = ILendingPool(pools[i]).toAmtCurrent(shares[i]) * tokenPrice_e36;\n            TokenFactors memory factors = _config.getTokenFactors(mode, pools[i]);\n            collCredit_e54 += tokenValue_e36 * factor"
    }
  ]
}