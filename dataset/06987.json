{
  "Title": "[M-03] ReaperBaseStrategyv4.harvest() might revert in an emergency.",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L109\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperStrategyGranarySupplyOnly.sol#L200\n\n\n# Vulnerability details\n\n## Impact\n`ReaperBaseStrategyv4.harvest()` might revert in an emergency if there is no position on the lending pool.\n\nAs a result, the funds might be locked inside the strategy.\n\n## Proof of Concept\nThe main problem is that [Aave lending pool doesn't allow 0 withdrawals](https://github.com/aave/protocol-v2/blob/554a2ed7ca4b3565e2ceaea0c454e5a70b3a2b41/contracts/protocol/libraries/logic/ValidationLogic.sol#L60-L70).\n\n```solidity\n  function validateWithdraw(\n    address reserveAddress,\n    uint256 amount,\n    uint256 userBalance,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n```\n\nSo the below scenario would be possible.\n\n1. After depositing and withdrawing from the Aave lending pool, the current position is 0 and the strategy is in debt.\n2. It's possible that the strategy has some want balance in the contract but no position on the lending pool.\nIt's because `_adjustPosition()` remains the debt during reinvesting and also, there is an `authorizedWithdrawUnderlying()` for `STRATEGIST` to withdraw from the lending pool.\n3. If the strategy is in an emergency, `harvest()` tries to liquidate all positions(=0 actually) and it will revert because of 0 withdrawal from Aave.\n4. Also, `withdraw()` will revert at [L98](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L98) as the strategy is in the debt.\n\nAs a result, the funds might be locked inside the strategy unless the `emergency` mode is canceled.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nWe should check 0 withdrawal in `_withdrawUnderlying()`.\n\n```solidity\n    function _withdrawUnderlying(uint256 _withdrawAmount) internal {\n        uint256 withdrawable = balanceOfPool();\n        _withdrawAmount = MathUpgradeable.min(_withdrawAmount, withdrawable);\n\n        if(_withdrawAmount != 0) {\n            ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).withdraw(address(want), _withdrawAmount, address(this));\n        }\n    }\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../libraries/ReaperMathUtils.sol\";\nimport \"../mixins/ReaperAccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nabstract contract ReaperBaseStrategyv4 is\n    ReaperAccessControl,\n    IStrategy,\n    UUPSUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    using ReaperMathUtils for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant PERCENT_DIVISOR = 10_000;\n    uint256 public constant UPGRADE_TIMELOCK = 48 hours; // minimum 48 hours for RF\n    uint256 public constant FUTURE_NEXT_PROPOSAL_TIME = 365 days * 100;\n\n    // The token the strategy wants to operate\n    address public want;\n\n    bool public emergencyExit;\n    uint256 public lastHarvestTimestamp;\n\n    uint256 public upgradeProposalTime;\n\n    /**\n     * Reaper Roles in increasing order of privilege.\n     * {KEEPER} - Stricly permissioned trustless access for off-chain programs or third party keepers.\n     * {STRATEGIST} - Role conferred to authors of the strategy, allows for tweaking non-critical params.\n     * {GUARDIAN} - Multisig requiring 2 signatures for emergency measures such as pausing and panicking.\n     * {ADMIN}- Multisig requiring 3 signatures for unpausing.\n     *\n     * The DEFAULT_ADMIN_ROLE (in-built access control role) will be granted to a multisig requiring 4\n     * signatures. This role would have upgrading capability, as well as the ability to grant any other\n     * roles.\n     *\n     * Also note that roles are cascading. So any higher privileged role should be able to perform all the functions\n     * of any lower privileged role.\n     */\n    bytes32 public constant KEEPER = keccak256(\"KEEPER\");\n    bytes32 public constant STRATEGIST = keccak256(\"STRATEGIST\");\n    bytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    /**\n     * @dev Reaper contracts:\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address public vault;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function __ReaperBaseStrategy_init(\n        address _vault,\n        address _want,\n        address[] memory _strategists,\n        address[] memory _multisigRoles\n    ) internal onlyInitializing {\n        __UUPSUpgradeable_init();\n        __AccessControlEnumerable_init();\n\n        vault = _vault;\n        want = _want;\n        IERC20Upgradeable(want).safeApprove(vault, type(uint256).max);\n\n        uint256 numStrategists = _strategists.length;\n        for (uint256 i = 0; i < numStrategists; i = i.uncheckedInc()) {\n            _grantRole(STRATEGIST, _strategists[i]);\n        }\n\n        require(_multisigRoles.length == 3, \"Invalid number of multisig roles\");\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(DEFAULT_ADMIN_ROLE, _multisigRoles[0]);\n        _grantRole(ADMIN, _multisigRoles[1]);\n        _grantRole(GUARDIAN, _multisigRoles[2]);\n\n        clearUpgradeCooldown();\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault. Can only\n     *      be called by the vault. _amount must be valid and security fee\n     *      is deducted up-front.\n     */\n    function withdraw(uint256 _amount) external override returns (uint256 loss) {\n        require(msg.sender == vault, \"Only vault can withdraw\");\n        require(_amount != 0, \"Amount cannot be zero\");\n        require(_amount <= balanceOf(), \"Ammount must be less than balance\");\n\n        uint256 amountFreed = 0;\n        (amountFreed, loss) = _liquidatePosition(_amount);\n        IERC20Upgradeable(want).safeTransfer(vault, amountFreed);\n    }\n\n    /**\n     * @dev harvest() function that takes care of logging. Subcontracts should\n     *      override _harvestCore() and implement their specific logic in it.\n     */\n    function harvest() external override returns (int256 roi) {\n        _atLeastRole(KEEPER);\n        int256 availableCapital = IVault(vault).availableCapital();\n        uint256 debt = 0;\n        if (availableCapital < 0) {\n            debt = uint256(-availableCapital);\n        }\n\n        uint256 repayment = 0;\n        if (emergencyExit) {\n            uint256 amountFreed = _liquidateAllPositions();\n            if (amountFreed < debt) {\n                roi = -int256(debt - amountFreed);\n            } else if (amountFreed > debt) {\n                roi = int256(amountFreed - debt);\n            }\n\n            repayment = debt;\n            if (roi < 0) {\n                repayment -= uint256(-roi);\n            }\n        } else {\n            (roi, repayment) = _harvestCore(debt);\n        }\n\n        debt = IVault(vault).report(roi, repayment);\n        _adjustPosition(debt);\n\n        lastHarvestTimestamp = block.timestamp;\n    }\n\n    /**\n     * @dev Function to calculate the total {want} held by the strat.\n     *      It takes into account both the funds in hand, plus the funds in external contracts.\n     */\n    function balanceOf() public view virtual override returns (uint256);\n\n    /**\n     * @notice\n     *  Activates emergency exit. Once activated, the Strategy will exit its\n     *  position upon the next harvest, depositing all funds into the Vault as\n     *  quickly as is reasonable given on-chain conditions.\n     *\n     *  This may only be called by GUARDIAN or higher privileged roles.\n     * @dev\n     *  See `vault.setEmergencyShutdown()` and `harvest()` for further details.\n     */\n    function setEmergencyExit() external {\n        _atLeastRole(GUARDIAN);\n        emergencyExit = true;\n        IVault(vault).revokeStrategy(address(this));\n    }\n\n    /**\n     * @dev This function must be called prior to upgrading the implementation.\n     *      It's required to wait UPGRADE_TIMELOCK seconds before executing the upgrade.\n     *      Strategists and roles with higher privilege can initiate this cooldown.\n     */\n    function initiateUpgradeCooldown() external {\n        _atLeastRole(STRATEGIST);\n        upgradeProposalTime = block.timestamp;\n    }\n\n    /**\n     * @dev This function is called:\n     *      - in initialize()\n     *      - as part of a successful upgrade\n     *      - manually to clear the upgrade cooldown.\n     * Guardian and roles with higher privilege can clear this cooldown.\n     */\n    function clearUpgradeCooldown() public {\n        _atLeastRole(GUARDIAN);\n        upgradeProposalTime = block.timestamp + FUTURE_NEXT_PROPOSAL_TIME;\n    }\n\n    /**\n     * @dev This function must be overriden simply for access control purposes.\n     *      Only DEFAULT_ADMIN_ROLE can upgrade the implementation once the timelock\n     *      has passed.\n     */\n    function _authorizeUpgrade(address) internal override {\n        _atLeastRole(DEFAULT_ADMIN_ROLE);\n        require(\n            upgradeProposalTime + UPGRADE_TIMELOCK < block.timestamp,\n            \"Upgrade cooldown not initiated or still ongoing\"\n        );\n        clearUpgradeCooldown();\n    }\n\n    /**\n     * @dev Returns an array of all the relevant roles arranged in descending order of privilege.\n     *      Subclasses should override this to specify their unique roles arranged in the correct\n     *      order, for example, [SUPER-ADMIN, ADMIN, GUARDIAN, STRATEGIST].\n     */\n    function _cascadingAccessRoles() internal view override returns (bytes32[] memory) {\n        bytes32[] memory cascadingAccessRoles = new bytes32[](5);\n        cascadingAccessRoles[0] = DEFAULT_ADMIN_ROLE;\n        cascadingAccessRoles[1] = ADMIN;\n        cascadingAccessRoles[2] = GUARDIAN;\n        cascadingAccessRoles[3] = STRATEGIST;\n        cascadingAccessRoles[4] = KEEPER;\n        return cascadingAccessRoles;\n    }\n\n    /**\n     * @dev Returns {true} if {_account} has been granted {_role}. Subclasses should override\n     *      this to specify their unique role-checking criteria.\n     */\n    function _hasRole(bytes32 _role, address _account) internal view override returns (bool) {\n        return hasRole(_role, _account);\n    }\n\n    /**\n     * Perform any adjustments to the core position(s) of this Strategy given\n     * what change the Vault made in the \"investable capital\" available to the\n     * Strategy. Note that all \"free capital\" in the Strategy after the report\n     * was made is available for reinvestment. Also note that this number\n     * could be 0, and you should handle that scenario accordingly.\n     */\n    function _adjustPosition(uint256 _debt) internal virtual;\n\n    /**\n     * Liquidate up to `_amountNeeded` of `want` of this strategy's positions,\n     * irregardless of slippage. Any excess will be re-invested with `_adjustPosition()`.\n     * This function should return the amount of `want` tokens made available by the\n     * liquidation. If there is a difference between them, `loss` indicates whether the\n     * difference is due to a realized loss, or if there is some other sitution at play\n     * (e.g. locked funds) where the amount made available is less than what is needed.\n     *\n     * NOTE: The invariant `liquidatedAmount + loss <= _amountNeeded` should always be maintained\n     */\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        virtual\n        returns (uint256 liquidatedAmount, uint256 loss);\n\n    /**\n     * Liquidate everything and returns the amount that got freed.\n     * This function is used during emergency exit instead of `_harvestCore()` to\n     * liquidate all of the Strategy's positions back to the Vault.\n     */\n    function _liquidateAllPositions() internal virtual returns (uint256 amountFreed);\n\n    /**\n     * Perform any Strategy unwinding or other calls necessary to capture the\n     * \"free return\" this Strategy has generated since the last time its core\n     * position(s) were adjusted. Examples include unwrapping extra rewards.\n     * This call is only used during \"normal operation\" of a Strategy, and\n     * should be optimized to minimize losses as much as possible.\n     *\n     * This method returns any realized profits and/or realized losses\n     * incurred, and should return the total amounts of profits/losses/debt\n     * payments (in `want` tokens) for the Vault's accounting.\n     *\n     * `_debt` will be 0 if the Strategy is not past the configured\n     * allocated capital, otherwise its value will be how far past the allocation\n     * the Strategy is. The Strategy's allocation is configured in the Vault.\n     *\n     * NOTE: `repayment` should be less than or equal to `_debt`.\n     *       It is okay for it to be less than `_debt`, as that\n     *       should only used as a guide for how much is left to pay back.\n     *       Payments should be made to minimize loss from slippage, debt,\n     *       withdrawal fees, etc.\n     * @dev subclasses should add their custom harvesting logic in this function\n     *      including charging any fees. The amount of fee that is remitted to the\n     *      caller must be returned.\n     */\n    function _harvestCore(uint256 _debt) internal virtual returns (int256 roi, uint256 repayment);\n}"
    },
    {
      "filename": "Ethos-Vault/contracts/ReaperStrategyGranarySupplyOnly.sol",
      "content": "// SPDX-License-Identifier: BUSL1.1\n\npragma solidity ^0.8.0;\n\nimport \"./abstract/ReaperBaseStrategyv4.sol\";\nimport \"./interfaces/IAToken.sol\";\nimport \"./interfaces/IAaveProtocolDataProvider.sol\";\nimport \"./interfaces/ILendingPool.sol\";\nimport \"./interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"./interfaces/IRewardsController.sol\";\nimport \"./libraries/ReaperMathUtils.sol\";\nimport \"./mixins/VeloSolidMixin.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n/**\n * @dev This strategy will deposit a token on Granary to maximize yield\n */\ncontract ReaperStrategyGranarySupplyOnly is ReaperBaseStrategyv4, VeloSolidMixin {\n    using ReaperMathUtils for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // 3rd-party contract addresses\n    address public constant VELO_ROUTER = 0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9;\n    ILendingPoolAddressesProvider public constant ADDRESSES_PROVIDER =\n        ILendingPoolAddressesProvider(0xdDE5dC81e40799750B92079723Da2acAF9e1C6D6);\n    IAaveProtocolDataProvider public constant DATA_PROVIDER =\n        IAaveProtocolDataProvider(0x9546F673eF71Ff666ae66d01Fd6E7C6Dae5a9995);\n    IRewardsController public constant REWARDER = IRewardsController(0x6A0406B8103Ec68EE9A713A073C7bD587c5e04aD);\n\n    // this strategy's configurable tokens\n    IAToken public gWant;\n\n    // Misc constants\n    uint16 private constant LENDER_REFERRAL_CODE_NONE = 0;\n\n    /**\n     * @dev Tokens Used:\n     * {rewardClaimingTokens} - Array containing gWant, used for claiming rewards\n     */\n    address[] public rewardClaimingTokens;\n\n    /**\n     * We break down the harvest logic into the following operations:\n     * 1. Claiming rewards\n     * 2. A series of swaps as required\n     * 3. Creating more of the strategy's underlying token, if necessary.\n     *\n     * #1 and #3 are specific to each protocol.\n     * #2 however is mostly the same across all strats. So to make things more generic, we\n     * will execute #2 by iterating through a series of pre-defined \"steps\".\n     *\n     * This array holds all the swapping operations in sequence.\n     * {ADMIN} role or higher will be able to set this array.\n     */\n    address[2][] public steps;\n\n    /**\n     * @dev Initializes the strategy. Sets parameters, saves routes, and gives allowances.\n     * @notice see documentation for each variable above its respective declaration.\n     */\n    function initialize(\n        address _vault,\n        address[] memory _strategists,\n        address[] memory _multisigRoles,\n        IAToken _gWant\n    ) public initializer {\n        gWant = _gWant;\n        want = _gWant.UNDERLYING_ASSET_ADDRESS();\n        __ReaperBaseStrategy_init(_vault, want, _strategists, _multisigRoles);\n        rewardClaimingTokens = [address(_gWant)];\n    }\n\n    function _adjustPosition(uint256 _debt) internal override {\n        if (emergencyExit) {\n            return;\n        }\n\n        uint256 wantBalance = balanceOfWant();\n        if (wantBalance > _debt) {\n            uint256 toReinvest = wantBalance - _debt;\n            _deposit(toReinvest);\n        }\n    }\n\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 liquidatedAmount, uint256 loss)\n    {\n        uint256 wantBal = balanceOfWant();\n        if (wantBal < _amountNeeded) {\n            _withdraw(_amountNeeded - wantBal);\n            liquidatedAmount = balanceOfWant();\n        } else {\n            liquidatedAmount = _amountNeeded;\n        }\n\n        if (_amountNeeded > liquidatedAmount) {\n            loss = _amountNeeded - liquidatedAmount;\n        }\n    }\n\n    function _liquidateAllPositions() internal override returns (uint256 amountFreed) {\n        _withdrawUnderlying(balanceOfPool());\n        return balanceOfWant();\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and swapping rewards\n     *      to produce more want.\n     * @notice Assumes the deposit will take care of resupplying excess want.\n     */\n    function _harvestCore(uint256 _debt) internal override returns (int256 roi, uint256 repayment) {\n        _claimRewards();\n        uint256 numSteps = steps.length;\n        for (uint256 i = 0; i < numSteps; i = i.uncheckedInc()) {\n            address[2] storage step = steps[i];\n            IERC20Upgradeable startToken = IERC20Upgradeable(step[0]);\n            uint256 amount = startToken.balanceOf(address(this));\n            if (amount == 0) {\n                continue;\n            }\n            _swapVelo(step[0], step[1], amount, VELO_ROUTER);\n        }\n\n        uint256 allocated = IVault(vault).strategies(address(this)).allocated;\n        uint256 totalAssets = balanceOf();\n        uint256 toFree = _debt;\n\n        if (totalAssets > allocated) {\n            uint256 profit = totalAssets - allocated;\n            toFree += profit;\n            roi = int256(profit);\n        } else if (totalAssets < allocated) {\n            roi = -int256(allocated - totalAssets);\n        }\n\n        (uint256 amountFreed, uint256 loss) = _liquidatePosition(toFree);\n        repayment = MathUpgradeable.min(_debt, amountFreed);\n        roi -= int256(loss);\n    }\n\n    /**\n     * Only {STRATEGIST} or higher roles may update the swap path for a token.\n     */\n    function updateVeloSwapPath(\n        address _tokenIn,\n        address _tokenOut,\n        address[] calldata _path\n    ) external override {\n        _atLeastRole(STRATEGIST);\n        _updateVeloSwapPath(_tokenIn, _tokenOut, _path);\n    }\n\n    /**\n     * Only {ADMIN} or higher roles may set the array\n     * of steps executed as part of harvest.\n     */\n    function setHarvestSteps(address[2][] calldata _newSteps) external {\n        _atLeastRole(ADMIN);\n        delete steps;\n\n        uint256 numSteps = _newSteps.length;\n        for (uint256 i = 0; i < numSteps; i = i.uncheckedInc()) {\n            address[2] memory step = _newSteps[i];\n            require(step[0] != address(0));\n            require(step[1] != address(0));\n            steps.push(step);\n        }\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     */\n    function _deposit(uint256 toReinvest) internal {\n        if (toReinvest != 0) {\n            address lendingPoolAddress = ADDRESSES_PROVIDER.getLendingPool();\n            IERC20Upgradeable(want).safeIncreaseAllowance(lendingPoolAddress, toReinvest);\n            ILendingPool(lendingPoolAddress).deposit(want, toReinvest, address(this), LENDER_REFERRAL_CODE_NONE);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds from external contracts and brings them back to this contract.\n     */\n    function _withdraw(uint256 _amount) internal {\n        if (_amount != 0) {\n            _withdrawUnderlying(_amount);\n        }\n    }\n\n    /**\n     * @dev Attempts to Withdraw {_withdrawAmount} from pool. Withdraws max amount that can be\n     *      safely withdrawn if {_withdrawAmount} is too high.\n     */\n    function _withdrawUnderlying(uint256 _withdrawAmount) internal {\n        uint256 withdrawable = balanceOfPool();\n        _withdrawAmount = MathUpgradeable.min(_withdrawAmount, withdrawable);\n        ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).withdraw(address(want), _withdrawAmount, address(this));\n    }\n\n    /**\n     * @dev Claim rewards for supply.\n     */\n    function _claimRewards() internal {\n        IRewardsController(REWARDER).claimAllRewardsToSelf(rewardClaimingTokens);\n    }\n\n    /**\n     * @dev Attempts to safely withdraw {_amount} from the pool.\n     */\n    function authorizedWithdrawUnderlying(uint256 _amount) external {\n        _atLeastRole(STRATEGIST);\n        _withdrawUnderlying(_amount);\n    }\n\n    /**\n     * @dev Function to calculate the total {want} held by the strat.\n     * It takes into account both the funds in hand, plus the funds in the lendingPool.\n     */\n    function balanceOf() public view override returns (uint256) {\n        return balanceOfPool() + balanceOfWant();\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20Upgradeable(want).balanceOf(address(this));\n    }\n\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 supply, , , , , , , , ) = IAaveProtocolDataProvider(DATA_PROVIDER).getUserReserveData(\n            address(want),\n            address(this)\n        );\n        return supply;\n    }\n}"
    }
  ]
}