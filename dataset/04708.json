{
  "Title": "[M-01] In case a gauge weight reduction is performed via `GaugeController::change_gauge_weight`, it is possible that all functions will stop functioning permanently for that gauge",
  "Content": "\nIf the weight of a given gauge has been manually changed using the `GaugeController::change_gauge_weight` function, all functions related to that gauge might become permanently DoSed.\n\n### Proof of Concept\n\nThis issue has been reported in [this](https://github.com/code-423n4/2023-08-verwa-findings/issues/206) and [this](https://github.com/code-423n4/2023-08-verwa-findings/issues/386) report from the previous Code4rena audit of the codebase. However, by the looks of it, no fix has been applied in order to mitigate it, so it is still present.\n\n### Recommended Mitigation Steps\n\nWhenever `pt.slope` is less than `d.slope`, set the value of `pt.slope` to `0`:\n\n```diff\n        if (pt.bias > d_bias) {\n            pt.bias -= d_bias;\n            uint256 d_slope = changes_weight[_gauge_addr][t];\n-           pt.slope -= d_slope;\n+           if(pt.slope >= d.slope) {\n+               pt.slope -= d_slope;\n+           } else {\n+               pt.slope = 0;\n+           }\n        } else {\n            pt.bias = 0;\n            pt.slope = 0;\n        }\n```\n\n### Assessed type\n\nUnder/Overflow\n\n**[zjesko (Neobase) confirmed](https://github.com/code-423n4/2024-03-neobase-findings/issues/25#issuecomment-2040758698)**\n\n**[0xTheC0der (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-neobase-findings/issues/25#issuecomment-2041580331):**\n > Assets not at direct risk, but the function of the protocol or its availability could be impacted. `change_gauge_weight` is only callable by the governance, but no admin mistake is required for this to happen.\n\n**[Arabadzhiev (warden) commented](https://github.com/code-423n4/2024-03-neobase-findings/issues/25#issuecomment-2047423805):**\n > This issue will actually lead to an absolutely certain loss of funds in the event where a gauge weight reduction is performed via `GaugeController::change_gauge_weight`. This is because inside of the `LendingLedger::update_market` function ,which is called inside of both `LendingLedger::claim` and `LendingLedger::sync_ledger` there is [a call to `GaugeController::gauge_relative_weight_write`](https://github.com/code-423n4/2024-03-neobase/blob/d6e6127e6763b93c23ee95cdf7622fe950d9ed30/src/LendingLedger.sol#L83):\n> \n> ```solidity\n>     market.accCantoPerShare += uint128(\n>         (blockDelta *\n>             cantoPerBlock[epoch] *\n>             gaugeController.gauge_relative_weight_write(_market, epochTime)) / marketSupply\n>     );\n> ```\n> \n> What this means is that since `GaugeController::gauge_relative_weight_write` calls `GaugeController::_get_weight` internally, whenever a gauge weight reduction is performed, all of those functions will become permanently DoSed; making it impossible for users to claim their rewards for a given market/gauge from the `LendingLedger`. Also, if the gauge that the weight reduction is performed on uses a `LiquidityGauge`, the users that have deposited into that liquidity gauge won't be able to withdraw their underlying assets from it, since in the `LiquidityGauge::_afterTokenTransfer` hook there are calls to `LendingLedger::sync_ledger`.\n> \n> Because of that, I believe that this issue deserves to be judged as one of a High severity, rather than a Medium.\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-03-neobase-findings/issues/25#issuecomment-2048167848):**\n > @Arabadzhiev - From a judging perspective my reasoning is as follows:  \n> The original report, which is already quite minimalist, states:  \n> > ... , all functions related to that gauge might become permanently DoSed.\n> \n> Furthermore, we have a [verdict about additional warden output during PJQA](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-standardization-of-additional-warden-output-during-qa):\n> > No new information should be introduced and considered in PJQA. Elaborations of the already introduced information can be considered (e.g. tweaking a POC), from either the Judge or the Warden, but they will only count towards the validity of the issue, not its quality score.\n> \n> Although the underlying issue might qualify for High severity in case more elaboration of impacts and/or a PoC was provided in the original report, it seems to be fair and most in line with our present ruling to maintain Medium severity.\n\n**[Arabadzhiev (warden) commented](https://github.com/code-423n4/2024-03-neobase-findings/issues/25#issuecomment-2049373949):**\n > I have one final note to make. In [this report](https://github.com/code-423n4/2023-08-verwa-findings/issues/206) from the previous audit of the codebase that I have linked to in my report, the following is stated in its impact section:\n> \n> > ... the impact is that the entire gauge is useless, voting powers are permanently locked there and its weight is impossible to change, so the impact is high.\n> \n> Given that this is actually a part of the original report and that issue #18 was judged as a High under pretty much the same reasoning, doesn't this issue also fall within the High severity category because of that?\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-03-neobase-findings/issues/25#issuecomment-2049522460):**\n > I treat it as a supporting reference but not as a \"replacement\" for your report.  \n> \n> Although the PoC and reasoning there *might* fully apply to this audit's code in scope, it's reasonable & fair to expect the present report to include impact-based reasoning for High severity and/or a coded PoC which undoubtedly applies to the current audit/code in scope.  \n> \n> In contrast, [#18](https://github.com/code-423n4/2024-03-neobase-findings/issues/18) clearly argues and proves in the original report that voting power will be lost/locked.\n> \n> I understand if you have reservations about my judgement as this one is definitely a narrow path to walk. Nevertheless, your input is legit and appreciated.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-neobase",
  "Code": [
    {
      "filename": "src/LendingLedger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {GaugeController} from \"./GaugeController.sol\";\nimport {LiquidityGauge} from \"./LiquidityGauge.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract LendingLedger {\n    // Constants\n    uint256 public constant BLOCK_EPOCH = 100_000; // 100000 blocks, roughly 1 week\n    uint256 public averageBlockTime = 5700; // Average block time in milliseconds\n    uint256 public referenceBlockNumber;\n    uint256 public referenceBlockTime; // Used to convert block numbers to timestamps together with averageBlockTime\n\n    // State\n    address public governance;\n    GaugeController public gaugeController;\n    mapping(address => bool) public lendingMarketWhitelist;\n\n    /// @dev Info for each user.\n    struct UserInfo {\n        uint256 amount; // Amount of cNOTE that the user has provided.\n        int256 rewardDebt; // Amount of CANTO entitled to the user.\n        int256 secRewardDebt; // Amount of secondary rewards entitled to the user.\n    }\n\n    /// @dev Info of each lending market.\n    struct MarketInfo {\n        uint128 accCantoPerShare;\n        uint128 secRewardsPerShare;\n        uint64 lastRewardBlock;\n    }\n\n    mapping(address => mapping(address => UserInfo)) public userInfo; // Info of each user for the different lending markets\n    mapping(address => MarketInfo) public marketInfo; // Info of each lending market\n\n    mapping(uint256 => uint256) public cantoPerBlock; // CANTO per block for each epoch\n\n    /// @dev Lending Market => Epoch => Balance\n    mapping(address => uint256) public lendingMarketTotalBalance; // Total balance locked within the market\n\n    mapping(address => address) public liquidityGauges; // Two way mapping for markets with liquidity gauge enabled\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    constructor(address _gaugeController, address _governance) {\n        gaugeController = GaugeController(_gaugeController);\n        governance = _governance;\n        referenceBlockNumber = block.number;\n        referenceBlockTime = block.timestamp;\n    }\n\n    /// @notice Set governance address\n    /// @param _governance New governance address\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n    }\n\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = epoch + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    // May not be the exact time, but will ensure that it is equal for all users and epochs.\n                    // If this ever drifts significantly, the average block time and / or reference block time & number can be updated. However, update_market needs to be called for all markets beforehand.\n                    uint256 epochTime = referenceBlockTime +\n                        ((block.number - referenceBlockNumber) * averageBlockTime) /\n                        1000;\n                    market.accCantoPerShare += uint128(\n                        (blockDelta *\n                            cantoPerBlock[epoch] *\n                            gaugeController.gauge_relative_weight_write(_market, epochTime)) / marketSupply\n                    );\n                    market.secRewardsPerShare += uint128((blockDelta * 1e36) / marketSupply); // Scale by 1e18, consumers need to divide by it\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Function that is called by the lending market on cNOTE deposits / withdrawals\n    /// @param _lender The address of the lender\n    /// @param _delta The amount of cNote deposited (positive) or withdrawn (negative)\n    function sync_ledger(address _lender, int256 _delta) external {\n        address lendingMarket = msg.sender;\n        // check if liquidity gauge is being used for the market\n        if (liquidityGauges[lendingMarket] != address(0)) lendingMarket = liquidityGauges[lendingMarket];\n\n        update_market(lendingMarket); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[lendingMarket];\n        UserInfo storage user = userInfo[lendingMarket][_lender];\n\n        if (_delta >= 0) {\n            user.amount += uint256(_delta);\n            user.rewardDebt += int256((uint256(_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt += int256((uint256(_delta) * market.secRewardsPerShare) / 1e18);\n        } else {\n            user.amount -= uint256(-_delta);\n            user.rewardDebt -= int256((uint256(-_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt -= int256((uint256(-_delta) * market.secRewardsPerShare) / 1e18);\n        }\n        int256 updatedMarketBalance = int256(lendingMarketTotalBalance[lendingMarket]) + _delta;\n        require(updatedMarketBalance >= 0, \"Market balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketTotalBalance[lendingMarket] = uint256(updatedMarketBalance);\n    }\n\n    /// @notice Claim the CANTO for a given market. Can only be performed for prior (i.e. finished) epochs, not the current one\n    /// @param _market Address of the market\n    function claim(address _market) external {\n        update_market(_market); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n\n    /// @notice Used by governance to set the overall CANTO rewards per epoch\n    /// @param _fromEpoch From which epoch (provided as block number) to set the rewards from\n    /// @param _toEpoch Until which epoch (provided as block number) to set the rewards to\n    /// @param _amountPerBlock The amount per block\n    function setRewards(\n        uint256 _fromEpoch,\n        uint256 _toEpoch,\n        uint256 _amountPerBlock\n    ) external onlyGovernance {\n        require(_fromEpoch % BLOCK_EPOCH == 0 && _toEpoch % BLOCK_EPOCH == 0, \"Invalid block number\");\n        for (uint256 i = _fromEpoch; i <= _toEpoch; i += BLOCK_EPOCH) {\n            cantoPerBlock[i] = _amountPerBlock;\n        }\n    }\n\n    /// @notice Used by governance to whitelist a lending market\n    /// @param _market Address of the market to whitelist\n    /// @param _isWhiteListed Whether the market is whitelisted or not\n    function whiteListLendingMarket(\n        address _market,\n        bool _isWhiteListed,\n        bool _hasGauge\n    ) external onlyGovernance {\n        require(lendingMarketWhitelist[_market] != _isWhiteListed, \"No change\");\n        if (_hasGauge && liquidityGauges[_market] == address(0)) {\n            LiquidityGauge liquidityGauge = new LiquidityGauge(_market, address(this));\n            liquidityGauges[_market] = address(liquidityGauge);\n            // add reverse also for reference in sync_ledger\n            liquidityGauges[address(liquidityGauge)] = _market;\n        }\n\n        lendingMarketWhitelist[_market] = _isWhiteListed;\n        if (_isWhiteListed) {\n            marketInfo[_market].lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Used by governance to set the block time parameters if the drift is too large\n    /// @param _averageBlockTime The average block time in milliseconds\n    /// @param _referenceBlockTime The reference block time\n    /// @param _referenceBlockNumber The reference block number\n    function setBlockTimeParameters(\n        uint256 _averageBlockTime,\n        uint256 _referenceBlockTime,\n        uint256 _referenceBlockNumber\n    ) external onlyGovernance {\n        averageBlockTime = _averageBlockTime;\n        referenceBlockTime = _referenceBlockTime;\n        referenceBlockNumber = _referenceBlockNumber;\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}