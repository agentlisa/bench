{
  "Title": "[M-03] `USDMPegRecovery.sol#withdraw()` withdraw may often fail",
  "Content": "_Submitted by WatchPug_\n\nPer the doc:\n\n> USDM deposits are locked based on the KPIâ€™s from carrot.eth.\n\n> 3Crv deposits are not locked.\n\n[USDMPegRecovery.sol#L110-L128](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110-L128)<br>\n\n```solidity\nfunction withdraw(Liquidity calldata _withdrawal) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_withdrawal.usdm > 0) {\n            require(unlockable, \"!unlock usdm\");\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\n            total.usdm -= _withdrawal.usdm;\n            user.usdm -= _withdrawal.usdm;\n        }\n\n        if(_withdrawal.pool3 > 0) {\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\n            total.pool3 -= _withdrawal.pool3;\n            user.pool3 -= _withdrawal.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Withdraw(msg.sender, _withdrawal);\n    }\n```\n\nHowever, because the `withdraw()` function takes funds from the balance of the contract, once the majority of the funds are added to the curve pool via `provide()`. The `withdraw()` may often fail due to insufficient funds in the balance.\n\n### Proof of Concept\n\n1.  Alice deposits `4M` USDM and `4M` pool3 tokens;\n2.  Guardian calls `provide()` and all the `usdm` and `pool3` to `usdm3crv`;\n3.  Alice calls `withdraw()`, the tx will fail, due to insufficient balance.\n\n### Recommended Mitigation Steps\n\nConsider calling `usdm3crv.remove_liquidity_one_coin()` when the balance is insufficient for the user's withdrawal.\n\n**[leekt (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/212)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/212#issuecomment-1088104169):**\n > The warden has identified a specific scenario in which user funds would not be withdrawable\n> \n> Because the code uses internal storage for accounting rather than \"value\" this scenario can happen fairly reliably.\n> \n> I believe mitigation requires further thought than just withdrawing and ideally it would be best to setup a system similar to Vault Shares so that a withdrawal could be triggered either by available liquidity or via a withdrawal from the pool.\n> \n> I think Medium severity is appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/USDMPegRecovery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ICurveMetaPool } from \"./external/CurveInterfaces.sol\";\n\ncontract USDMPegRecovery is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    IERC20 public immutable usdm;\n\n    IERC20 public immutable pool3;\n\n    ICurveMetaPool public immutable usdm3crv;\n\n    address public immutable kpiOracle;\n\n    uint256 public step;\n\n    uint256 public startLiquidity;\n\n    struct Liquidity {\n        uint128 usdm;\n        uint128 pool3;\n    }\n\n    event Deposit(address indexed depositor, Liquidity deposits);\n\n    event Withdraw(address indexed withdrawer, Liquidity withdrawals);\n\n    Liquidity public totalLiquidity;\n\n    mapping(address => Liquidity) public userLiquidity;\n\n    mapping(address => bool) public isGuardian;\n\n    bool public unlockable;\n\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"!guardian\");\n        _;\n    }\n\n    constructor(\n        uint256 _startLiquidity,\n        address _kpiOracle\n    ) Ownable() {\n        startLiquidity = _startLiquidity;\n        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);\n        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);\n        step = 250000e18;\n        kpiOracle = _kpiOracle;\n    }\n\n    function addGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = true;\n    }\n\n    function removeGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = false;\n    }\n\n    function enableUnlock() external {\n        require(msg.sender == kpiOracle, \"!oracle\");\n        unlockable = true;\n    }\n\n    function provide(uint256 _minimumLP) external onlyGuardian {\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n        // truncate amounts under step\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n        // match usdm : pool3 = 1 : 1\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n        usdm.approve(address(usdm3crv), addingLiquidity);\n        pool3.approve(address(usdm3crv), addingLiquidity);\n        usdm3crv.add_liquidity(amounts, _minimumLP);\n    }\n\n    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {\n        uint256 removingLiquidity = _steps * step;\n        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];\n        usdm3crv.remove_liquidity(_burningLPs, amounts);\n    }\n\n    function deposit(Liquidity calldata _deposits) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_deposits.usdm > 0) {\n            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));\n            total.usdm += _deposits.usdm;\n            user.usdm += _deposits.usdm;\n        }\n\n        if(_deposits.pool3 > 0) {\n            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");\n            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));\n            total.pool3 += _deposits.pool3;\n            user.pool3 += _deposits.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Deposit(msg.sender, _deposits);\n    }\n\n    function withdraw(Liquidity calldata _withdrawal) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_withdrawal.usdm > 0) {\n            require(unlockable, \"!unlock usdm\");\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\n            total.usdm -= _withdrawal.usdm;\n            user.usdm -= _withdrawal.usdm;\n        }\n\n        if(_withdrawal.pool3 > 0) {\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\n            total.pool3 -= _withdrawal.pool3;\n            user.pool3 -= _withdrawal.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Withdraw(msg.sender, _withdrawal);\n    }\n}"
    }
  ]
}