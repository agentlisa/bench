{
  "Title": "M-11: New creators unable to update the royalty target and the fee route for their works",
  "Content": "# Issue M-11: New creators unable to update the royalty target and the fee route for their works \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/283 \n\n## Found by \n0x73696d616f, BengalCatBalu, BiasedMerc, CodeWasp, KupiaSec, Varun\\_05, alexzoid, cu5t0mPe0, jennifer37, mt030d, sammy, xiaoming90, y4y, zoyi\n## Summary\n\nThe new creators are unable to update the royalty target and the fee route for their works. As a result, it could lead to a loss of assets for the new creator due to the following:\n\n- The work's royalty target still points to the previous creator, so the royalty fee is routed to the previous creator instead of the current creator.\n- The work's fee is still routed to the recipients, which included the previous creator instead of the current creator.\n\n## Vulnerability Detail\n\nThe creator can call the `transferWork` to transfer the work to another creator. However, it was observed that after the transfer, there is still much information about the work pointing to the previous creator instead of the new creator.\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/editions/Edition.sol#L412\n\n```solidity\nFile: Edition.sol\n412:     function transferWork(address to_, uint256 tokenId_) external {\n413:         Work storage work = works[tokenId_];\n414:         if (msg.sender != work.creator) revert Unauthorized();\n415: \n416:         // Transfer the work to the new creator\n417:         work.creator = to_;\n418: \n419:         emit WorkTransferred(address(this), tokenId_, to_);\n420:     }\n```\n\nFollowing are some instances of the issues:\n\n- The work's royalty target still points to the previous creator, so the royalty fee is routed to the previous creator instead of the current creator.\n- The work's fee is still routed to the recipients, which included the previous creator instead of the current creator.\n\nTo aggravate the issues, creators cannot call the `Edition.setRoyaltyTarget` and `FeeManager.createRoute` as these functions can only executed by EDITION_MANAGER_ROLE and [Owner, Admin], respectively.\n\nSpecifically for the `Edition.setRoyaltyTarget` function that can only be executed by EDITION_MANAGER_ROLE, which is restricted and not fully trusted in the context of this audit. The new creator could have purchased the work from the previous creator, but only to find out that the malicious edition manager decided not to update the royalty target to point to the new creator's address for certain reasons, leading to the royalty fee continuing to be routed to the previous creator. In this case, it negatively impacts the new creator as it leads to a loss of royalty fee for the new creator.\n\n> [!NOTE]\n>\n> The following is an extract from the contest's README stating that the EDITION_MANAGER_ROLE is restricted. This means that any issue related to EDITION_MANAGER_ROLE that could affect TITLES protocol/users negatively will be considered valid in this audit contest.\n>\n> > EDITION_MANAGER_ROLE (Restricted) =>\n\n## Impact\n\nLoss of assets for the new creator due to the following:\n\n- The work's royalty target still points to the previous creator, so the royalty fee is routed to the previous creator instead of the current creator.\n- The work's fee is still routed to the recipients, which included the previous creator instead of the current creator.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/editions/Edition.sol#L412\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider allowing the creators themselves to have the right to update the royalty target and the fee route for their works.\n\n\n\n## Discussion\n\n**pqseags**\n\nWhile this is unintuitive, we do not intend to update the fee splits when ownership of a work is changed after publishing\n\n**cducrest**\n\nEscalate\n\nShould be low/info as this is just un-intuitive behaviour of the protocol and does not represent a real threat / loss of funds. \n\nThe team does not intend to update the behaviour confirming that this is intended.\n\nThe problem arises when users transfer a work to another user while also believing it will transfer the ownership of the fees. This is a user mistake / misuse of the protocol and not an attack / exploit of a vulnerability.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> Should be low/info as this is just un-intuitive behaviour of the protocol and does not represent a real threat / loss of funds. \n> \n> The team does not intend to update the behaviour confirming that this is intended.\n> \n> The problem arises when users transfer a work to another user while also believing it will transfer the ownership of the fees. This is a user mistake / misuse of the protocol and not an attack / exploit of a vulnerability.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Hash01011122**\n\n@pqseags @cducrest can you please elaborate on how this issue just un-intuitive behavior of the protocol? Also where was it mentioned at the time of contest that protocol does not intend to update the fee splits when ownership of a work is changed after publishing\n\n**pqseags**\n\nIt was not documented, but there isn't any logic in the code that makes an attempt to modify the fee route. In our minds, changing the creator on a work is more for the sake of changing who has admin responsibility. As this wasn't documented clearly in the read-me, I'll leave it to the judges to determine severity level given the context. \n\n**cducrest**\n\nIt is not possible to change the fee split whether before or after ownership of a work is changed. To me, this is an optional feature request. It is not like it was possible to change the fee / royalty target before the work was transferred to a new creator and it becomes no longer possible. It is never possible to update it.\n\nAlso it makes little sense to update the \"creator\" of a work. If a \"creator\" (in the English literal understanding) publishes a work (a book, a picture, an NFT, anything) they remain the \"creator\" forever. Shakespeare cannot transfer authorship of Hamlet. As mentioned by @pqseags the `transferWork()` function serves more administrative purpose and delegating admin rights. It does not necessarily need to transfer fee/royalty rights.\n\n**WangSecurity**\n\nThank you for these responses and insightful examples, but I agree that this design is actuall counter-intuitive and it wasn't documented anywhere. Also, I believe examples of how it works somewhere else are irrelevent. The watsons couldn't know what was the correct design for this function or it's known that when you transfer ownership the royalty is sent to the previous owner, hence, I believe it's fair to keep it valid. \n\nPlanning to reject the escalation and leave the issue as it is.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [cducrest](https://github.com/sherlock-audit/2024-04-titles-judging/issues/283/#issuecomment-2107317521): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "wallflower-contract-v2/src/editions/Edition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Ownable} from \"lib/solady/src/auth/Ownable.sol\";\nimport {ERC2981} from \"lib/solady/src/tokens/ERC2981.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\n\nimport {ERC1155} from \"solady/tokens/ERC1155.sol\";\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\nimport {Node, NodeType, Target, Strategy} from \"src/shared/Common.sol\";\n\nimport {\n    EDITION_MANAGER_ROLE,\n    EDITION_MINTER_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    Metadata,\n    Node,\n    Strategy,\n    Comment,\n    FeeStrategyUpdated,\n    MaxSupplyReached,\n    Minted,\n    NotImplemented,\n    NotOpen,\n    Published,\n    TimeframeUpdated,\n    WorkTransferred\n} from \"src/shared/Common.sol\";\n\n/// @title Edition\n/// @notice An ERC1155 contract representing a collection of related works. Each work is represented by a token ID.\ncontract Edition is IEdition, ERC1155, ERC2981, Initializable, OwnableRoles {\n    using SafeTransferLib for address;\n\n    /// @notice An individual work within the Edition.\n    /// @param creator The creator of the work.\n    /// @param maxSupply The maximum number of mintable tokens for the work.\n    /// @param totalSupply The total number of minted tokens for the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable. If `0`, there is no closing time.\n    /// @param strategy The fee strategy for the work.\n    struct Work {\n        address creator;\n        uint256 maxSupply;\n        uint256 totalSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n    }\n\n    /// @notice The total number of works in the Edition. Also the ID of the latest work.\n    uint256 public totalWorks;\n\n    /// @notice The collection of works in the Edition.\n    mapping(uint256 => Work) public works;\n\n    /// @notice The metadata for the Edition and its works.\n    /// @dev The Edition key is 0, while the work keys are the token IDs.\n    mapping(uint256 => Metadata) public _metadata;\n\n    /// @notice The fee manager contract.\n    FeeManager public FEE_MANAGER;\n\n    /// @notice The TitlesGraph contract.\n    TitlesGraph public GRAPH;\n\n    /// @notice Initialize the Edition contract.\n    /// @param feeManager_ The fee manager contract.\n    /// @param graph_ The TitlesGraph contract.\n    /// @param owner_ The owner of the Edition contract.\n    /// @param controller_ The controller of the Edition contract.\n    /// @dev This function is called by the {EditionFactory} when creating a new Edition to set the fee manager and owner.\n    /// @dev The controller is granted the {EDITION_MANAGER_ROLE} to allow management of the Edition contract.\n    function initialize(\n        FeeManager feeManager_,\n        TitlesGraph graph_,\n        address owner_,\n        address controller_,\n        Metadata calldata metadata_\n    ) external initializer {\n        _initializeOwner(owner_);\n        FEE_MANAGER = feeManager_;\n        GRAPH = graph_;\n\n        _grantRoles(controller_, EDITION_MANAGER_ROLE);\n        _grantRoles(owner_, EDITION_PUBLISHER_ROLE);\n\n        _metadata[0] = metadata_;\n    }\n\n    /// @notice Create a new work in the Edition.\n    /// @param creator_ The creator of the work.\n    /// @param maxSupply_ The maximum number of mintable tokens for the work.\n    /// @param opensAt_ The timestamp after which the work is mintable.\n    /// @param closesAt_ The timestamp after which the work is no longer mintable.\n    /// @param attributions_ The attributions for the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @param metadata_ The metadata for the work.\n    function publish(\n        address creator_,\n        uint256 maxSupply_,\n        uint64 opensAt_,\n        uint64 closesAt_,\n        Node[] calldata attributions_,\n        Strategy calldata strategy_,\n        Metadata calldata metadata_\n    ) external override onlyRoles(EDITION_MANAGER_ROLE) returns (uint256 tokenId) {\n        tokenId = ++totalWorks;\n\n        _metadata[tokenId] = metadata_;\n        works[tokenId] = Work({\n            creator: creator_,\n            totalSupply: 0,\n            maxSupply: maxSupply_,\n            opensAt: opensAt_,\n            closesAt: closesAt_,\n            strategy: FEE_MANAGER.validateStrategy(strategy_)\n        });\n\n        Node memory _node = node(tokenId);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            // wake-disable-next-line reentrancy, unchecked-return-value\n            GRAPH.createEdge(_node, attributions_[i], attributions_[i].data);\n        }\n\n        emit Published(address(this), tokenId);\n    }\n\n    /// @notice Get the name of the Edition.\n    /// @return The name of the Edition.\n    function name() public view override returns (string memory) {\n        return _metadata[0].label;\n    }\n\n    /// @notice Get the name for a given Work.\n    /// @param tokenId The ID of the work.\n    /// @return The name of the work.\n    function name(uint256 tokenId) public view returns (string memory) {\n        return _metadata[tokenId].label;\n    }\n\n    /// @notice Get the owner of the Edition.\n    /// @return The owner of the Edition.\n    /// @dev The owner of the Edition contract has the right to manage roles.\n    function owner() public view override(IEdition, Ownable) returns (address) {\n        return super.owner();\n    }\n\n    function uri() public view returns (string memory) {\n        return _metadata[0].uri;\n    }\n\n    /// @notice Get the URI for the given token ID.\n    /// @param tokenId_ The ID of the token.\n    /// @return The URI for the token.\n    function uri(uint256 tokenId_)\n        public\n        view\n        virtual\n        override(IEdition, ERC1155)\n        returns (string memory)\n    {\n        return _metadata[tokenId_].uri;\n    }\n\n    /// @notice Get the creator of the Edition. Alias for {owner}.\n    /// @return The creator of the Edition.\n    function creator() public view override returns (address) {\n        return owner();\n    }\n\n    /// @notice Get the creator of the given work.\n    /// @param tokenId The ID of the work.\n    /// @return The creator of the work.\n    function creator(uint256 tokenId) public view override returns (address) {\n        return works[tokenId].creator;\n    }\n\n    /// @notice Get the {Node} for the collection.\n    /// @return The node for the edition.\n    function node() public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.COLLECTION_ERC1155,\n            creator: Target({target: owner(), chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: \"\"\n        });\n    }\n\n    /// @notice Get the {Node} for the given work.\n    /// @param tokenId The token ID of the work.\n    /// @return The node for the work.\n    function node(uint256 tokenId) public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.TOKEN_ERC1155,\n            creator: Target({target: works[tokenId].creator, chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: abi.encode(tokenId)\n        });\n    }\n\n    /// @notice Get the mint fee for one token for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The mint fee for the token.\n    function mintFee(uint256 tokenId_) public view returns (uint256) {\n        return mintFee(tokenId_, 1);\n    }\n\n    /// @notice Get the mint fee for an `amount` of tokens for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param amount_ The amount of tokens to mint.\n    /// @return The mint fee for the tokens.\n    function mintFee(uint256 tokenId_, uint256 amount_) public view returns (uint256) {\n        if (tokenId_ == 0 || tokenId_ > totalWorks) return 0;\n        return FEE_MANAGER.getMintFee(works[tokenId_].strategy, amount_).amount;\n    }\n\n    /// @notice Mint a new token for the given work.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mint(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_\n    ) external payable override {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a new token for the given work with a public comment.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @param comment_ The public comment associated with the mint. Emitted as an event.\n    /// @dev This function is used to mint a token with a public comment, allowing the mint to be associated with a message which will be emitted as an event.\n    function mintWithComment(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_,\n        string calldata comment_\n    ) external payable {\n        Strategy memory strategy = works[tokenId_].strategy;\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n\n        emit Comment(address(this), tokenId_, to_, comment_);\n    }\n\n    /// @notice Mint multiple tokens for the given works.\n    /// @param to_ The address to mint the tokens to.\n    /// @param tokenIds_ The IDs of the works to mint.\n    /// @param amounts_ The amounts of each work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address to_,\n        uint256[] calldata tokenIds_,\n        uint256[] calldata amounts_,\n        bytes calldata data_\n    ) external payable {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            Work storage work = works[tokenIds_[i]];\n\n            // wake-disable-next-line reentrancy\n            FEE_MANAGER.collectMintFee{value: msg.value}(\n                this, tokenIds_[i], amounts_[i], msg.sender, address(0), work.strategy\n            );\n\n            _checkTime(work.opensAt, work.closesAt);\n            _updateSupply(work, amounts_[i]);\n        }\n\n        _batchMint(to_, tokenIds_, amounts_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a token to a set of receivers for the given work.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address[] calldata receivers_,\n        uint256 tokenId_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external payable {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, address(0), works[tokenId_].strategy\n        );\n\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, amount_, data_);\n        }\n\n        _refundExcess();\n    }\n\n    /// @notice Mint a token from the given work to a set of receivers.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @dev This function is used to mint one token for each receiver of a given work, bypassing mint fees. It is intended for promotional purposes.\n    function promoMint(address[] calldata receivers_, uint256 tokenId_, bytes calldata data_)\n        external\n        onlyOwnerOrRoles(EDITION_MANAGER_ROLE | EDITION_MINTER_ROLE)\n    {\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, 1, data_);\n        }\n    }\n\n    /// @notice Get the metadata for the given ID.\n    /// @param id_ The ID of the work, or `0` for the Edition.\n    /// @return The metadata for the ID.\n    function metadata(uint256 id_) external view returns (Metadata memory) {\n        return _metadata[id_];\n    }\n\n    /// @notice Get the maximum supply for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The maximum supply for the work.\n    function maxSupply(uint256 tokenId_) external view override returns (uint256) {\n        return works[tokenId_].maxSupply;\n    }\n\n    /// @notice Get the total supply for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The total supply for the work.\n    function totalSupply(uint256 tokenId_) external view override returns (uint256) {\n        return works[tokenId_].totalSupply;\n    }\n\n    /// @notice Get the fee strategy for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The fee strategy for the work.\n    function feeStrategy(uint256 tokenId_) external view override returns (Strategy memory) {\n        return works[tokenId_].strategy;\n    }\n\n    /// @notice Set the fee strategy for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @dev This function only updates the strategy locally and will NOT change the fee route.\n    function setFeeStrategy(uint256 tokenId_, Strategy calldata strategy_) external {\n        if (msg.sender != works[tokenId_].creator) revert Unauthorized();\n        works[tokenId_].strategy = FEE_MANAGER.validateStrategy(strategy_);\n    }\n\n    /// @notice Set the metadata for a given ID.\n    /// @param id_ The ID of the work, or `0` for the Edition\n    /// @param metadata_ The new metadata.\n    function setMetadata(uint256 id_, Metadata calldata metadata_) external {\n        // Only the owner can update the Edition metadata\n        if (id_ == 0 && msg.sender != owner()) revert Unauthorized();\n\n        // Only the creator can update the work metadata\n        if (id_ > 0 && msg.sender != works[id_].creator) revert Unauthorized();\n\n        _metadata[id_] = metadata_;\n    }\n\n    /// @notice Set the ERC2981 royalty target for the given work.\n    /// @param tokenId The ID of the work.\n    /// @param target The address to receive royalties.\n    function setRoyaltyTarget(uint256 tokenId, address target)\n        external\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _setTokenRoyalty(tokenId, target, works[tokenId].strategy.royaltyBps);\n    }\n\n    /// @notice Sets the open and close times for the given work.\n    /// @param tokenId The ID of the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable.\n    /// @dev Only the creator of the work can call this function.\n    function setTimeframe(uint256 tokenId, uint64 opensAt, uint64 closesAt) external {\n        Work storage work = works[tokenId];\n        if (msg.sender != work.creator) revert Unauthorized();\n\n        // Update the open and close times for the work\n        work.opensAt = opensAt;\n        work.closesAt = closesAt;\n\n        emit TimeframeUpdated(address(this), tokenId, opensAt, closesAt);\n    }\n\n    function transferWork(address to_, uint256 tokenId_) external {\n        Work storage work = works[tokenId_];\n        if (msg.sender != work.creator) revert Unauthorized();\n\n        // Transfer the work to the new creator\n        work.creator = to_;\n\n        emit WorkTransferred(address(this), tokenId_, to_);\n    }\n\n    /// @inheritdoc OwnableRoles\n    function grantRoles(address user_, uint256 roles_)\n        public\n        payable\n        override\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _grantRoles(user_, roles_);\n    }\n\n    /// @inheritdoc OwnableRoles\n    function revokeRoles(address user_, uint256 roles_)\n        public\n        payable\n        override\n        onlyRoles(EDITION_MANAGER_ROLE)\n    {\n        _removeRoles(user_, roles_);\n    }\n\n    /// @notice Grant the publisher role to the given address, allowing it to publish new works within the Edition.\n    /// @param publisher_ The address to grant the role to.\n    /// @dev This function is used by the owner or manager to grant the {EDITION_PUBLISHER_ROLE} to an address, allowing it to publish new works within the Edition.\n    function grantPublisherRole(address publisher_)\n        external\n        onlyRolesOrOwner(EDITION_MANAGER_ROLE)\n    {\n        _grantRoles(publisher_, EDITION_PUBLISHER_ROLE);\n    }\n\n    /// @notice Revoke the publisher role from the given address, preventing it from publishing new works. Does not affect existing works.\n    /// @param publisher_ The address to revoke the role from.\n    /// @dev This function is used by the owner or manager to revoke the {EDITION_PUBLISHER_ROLE} from an address, preventing it from publishing new works within the Edition.\n    function revokePublisherRole(address publisher_)\n        external\n        onlyRolesOrOwner(EDITION_MANAGER_ROLE)\n    {\n        _removeRoles(publisher_, EDITION_PUBLISHER_ROLE);\n    }\n\n    /// @notice Check if the contract supports the given interface.\n    /// @param interfaceId The interface ID to check.\n    /// @return True if the contract supports the interface, false otherwise.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(IEdition, ERC1155, ERC2981)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Issue tokens for the given work.\n    /// @param to_ The address to issue the tokens to.\n    /// @param tokenId_ The ID of the work to issue.\n    /// @param amount_ The amount of tokens to issue.\n    /// @param data_ The data associated with the issuance. Reserved for future use.\n    /// @dev This function is used by the {mint} and {mintBatch} functions to mint tokens and reverts if the new total supply would exceed the maximum supply.\n    function _issue(address to_, uint256 tokenId_, uint256 amount_, bytes calldata data_)\n        internal\n    {\n        Work storage work = works[tokenId_];\n        _checkTime(work.opensAt, work.closesAt);\n        _updateSupply(work, amount_);\n        _mint(to_, tokenId_, amount_, data_);\n        emit Minted(address(this), tokenId_, to_, amount_, data_);\n    }\n\n    /// @notice Update the total supply for the given work.\n    /// @param work The work to update.\n    /// @param amount_ The amount to add to the total supply.\n    /// @dev This function increments the total supply for a given work and reverts if the new total exceeds the maximum supply.\n    function _updateSupply(Work storage work, uint256 amount_) internal {\n        if ((work.totalSupply += amount_) > work.maxSupply) {\n            revert MaxSupplyReached();\n        }\n    }\n\n    /// @notice Checks that the current block time falls within the given range.\n    /// @param start_ The timestamp after which the work is mintable.\n    /// @param end_ The timestamp after which the work is no longer mintable.\n    /// @dev This function is used to check that the current block time falls within the given range and reverts if not.\n    function _checkTime(uint64 start_, uint64 end_) internal view {\n        if (block.timestamp < start_ || (end_ != 0 && block.timestamp > end_)) {\n            revert NotOpen(start_, end_);\n        }\n    }\n\n    /// @notice Refund any excess ETH sent to the contract.\n    /// @dev This function is called after minting tokens to refund any ETH left in the contract after all fees have been collected.\n    function _refundExcess() internal {\n        if (msg.value > 0 && address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n}"
    },
    {
      "filename": "wallflower-contract-v2/src/editions/Edition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Ownable} from \"lib/solady/src/auth/Ownable.sol\";\nimport {ERC2981} from \"lib/solady/src/tokens/ERC2981.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\n\nimport {ERC1155} from \"solady/tokens/ERC1155.sol\";\nimport {IEdition} from \"src/interfaces/IEdition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\nimport {Node, NodeType, Target, Strategy} from \"src/shared/Common.sol\";\n\nimport {\n    EDITION_MANAGER_ROLE,\n    EDITION_MINTER_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    Metadata,\n    Node,\n    Strategy,\n    Comment,\n    FeeStrategyUpdated,\n    MaxSupplyReached,\n    Minted,\n    NotImplemented,\n    NotOpen,\n    Published,\n    TimeframeUpdated,\n    WorkTransferred\n} from \"src/shared/Common.sol\";\n\n/// @title Edition\n/// @notice An ERC1155 contract representing a collection of related works. Each work is represented by a token ID.\ncontract Edition is IEdition, ERC1155, ERC2981, Initializable, OwnableRoles {\n    using SafeTransferLib for address;\n\n    /// @notice An individual work within the Edition.\n    /// @param creator The creator of the work.\n    /// @param maxSupply The maximum number of mintable tokens for the work.\n    /// @param totalSupply The total number of minted tokens for the work.\n    /// @param opensAt The timestamp after which the work is mintable.\n    /// @param closesAt The timestamp after which the work is no longer mintable. If `0`, there is no closing time.\n    /// @param strategy The fee strategy for the work.\n    struct Work {\n        address creator;\n        uint256 maxSupply;\n        uint256 totalSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n    }\n\n    /// @notice The total number of works in the Edition. Also the ID of the latest work.\n    uint256 public totalWorks;\n\n    /// @notice The collection of works in the Edition.\n    mapping(uint256 => Work) public works;\n\n    /// @notice The metadata for the Edition and its works.\n    /// @dev The Edition key is 0, while the work keys are the token IDs.\n    mapping(uint256 => Metadata) public _metadata;\n\n    /// @notice The fee manager contract.\n    FeeManager public FEE_MANAGER;\n\n    /// @notice The TitlesGraph contract.\n    TitlesGraph public GRAPH;\n\n    /// @notice Initialize the Edition contract.\n    /// @param feeManager_ The fee manager contract.\n    /// @param graph_ The TitlesGraph contract.\n    /// @param owner_ The owner of the Edition contract.\n    /// @param controller_ The controller of the Edition contract.\n    /// @dev This function is called by the {EditionFactory} when creating a new Edition to set the fee manager and owner.\n    /// @dev The controller is granted the {EDITION_MANAGER_ROLE} to allow management of the Edition contract.\n    function initialize(\n        FeeManager feeManager_,\n        TitlesGraph graph_,\n        address owner_,\n        address controller_,\n        Metadata calldata metadata_\n    ) external initializer {\n        _initializeOwner(owner_);\n        FEE_MANAGER = feeManager_;\n        GRAPH = graph_;\n\n        _grantRoles(controller_, EDITION_MANAGER_ROLE);\n        _grantRoles(owner_, EDITION_PUBLISHER_ROLE);\n\n        _metadata[0] = metadata_;\n    }\n\n    /// @notice Create a new work in the Edition.\n    /// @param creator_ The creator of the work.\n    /// @param maxSupply_ The maximum number of mintable tokens for the work.\n    /// @param opensAt_ The timestamp after which the work is mintable.\n    /// @param closesAt_ The timestamp after which the work is no longer mintable.\n    /// @param attributions_ The attributions for the work.\n    /// @param strategy_ The fee strategy for the work.\n    /// @param metadata_ The metadata for the work.\n    function publish(\n        address creator_,\n        uint256 maxSupply_,\n        uint64 opensAt_,\n        uint64 closesAt_,\n        Node[] calldata attributions_,\n        Strategy calldata strategy_,\n        Metadata calldata metadata_\n    ) external override onlyRoles(EDITION_MANAGER_ROLE) returns (uint256 tokenId) {\n        tokenId = ++totalWorks;\n\n        _metadata[tokenId] = metadata_;\n        works[tokenId] = Work({\n            creator: creator_,\n            totalSupply: 0,\n            maxSupply: maxSupply_,\n            opensAt: opensAt_,\n            closesAt: closesAt_,\n            strategy: FEE_MANAGER.validateStrategy(strategy_)\n        });\n\n        Node memory _node = node(tokenId);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            // wake-disable-next-line reentrancy, unchecked-return-value\n            GRAPH.createEdge(_node, attributions_[i], attributions_[i].data);\n        }\n\n        emit Published(address(this), tokenId);\n    }\n\n    /// @notice Get the name of the Edition.\n    /// @return The name of the Edition.\n    function name() public view override returns (string memory) {\n        return _metadata[0].label;\n    }\n\n    /// @notice Get the name for a given Work.\n    /// @param tokenId The ID of the work.\n    /// @return The name of the work.\n    function name(uint256 tokenId) public view returns (string memory) {\n        return _metadata[tokenId].label;\n    }\n\n    /// @notice Get the owner of the Edition.\n    /// @return The owner of the Edition.\n    /// @dev The owner of the Edition contract has the right to manage roles.\n    function owner() public view override(IEdition, Ownable) returns (address) {\n        return super.owner();\n    }\n\n    function uri() public view returns (string memory) {\n        return _metadata[0].uri;\n    }\n\n    /// @notice Get the URI for the given token ID.\n    /// @param tokenId_ The ID of the token.\n    /// @return The URI for the token.\n    function uri(uint256 tokenId_)\n        public\n        view\n        virtual\n        override(IEdition, ERC1155)\n        returns (string memory)\n    {\n        return _metadata[tokenId_].uri;\n    }\n\n    /// @notice Get the creator of the Edition. Alias for {owner}.\n    /// @return The creator of the Edition.\n    function creator() public view override returns (address) {\n        return owner();\n    }\n\n    /// @notice Get the creator of the given work.\n    /// @param tokenId The ID of the work.\n    /// @return The creator of the work.\n    function creator(uint256 tokenId) public view override returns (address) {\n        return works[tokenId].creator;\n    }\n\n    /// @notice Get the {Node} for the collection.\n    /// @return The node for the edition.\n    function node() public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.COLLECTION_ERC1155,\n            creator: Target({target: owner(), chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: \"\"\n        });\n    }\n\n    /// @notice Get the {Node} for the given work.\n    /// @param tokenId The token ID of the work.\n    /// @return The node for the work.\n    function node(uint256 tokenId) public view returns (Node memory) {\n        return Node({\n            nodeType: NodeType.TOKEN_ERC1155,\n            creator: Target({target: works[tokenId].creator, chainId: block.chainid}),\n            entity: Target({target: address(this), chainId: block.chainid}),\n            data: abi.encode(tokenId)\n        });\n    }\n\n    /// @notice Get the mint fee for one token for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @return The mint fee for the token.\n    function mintFee(uint256 tokenId_) public view returns (uint256) {\n        return mintFee(tokenId_, 1);\n    }\n\n    /// @notice Get the mint fee for an `amount` of tokens for the given work.\n    /// @param tokenId_ The ID of the work.\n    /// @param amount_ The amount of tokens to mint.\n    /// @return The mint fee for the tokens.\n    function mintFee(uint256 tokenId_, uint256 amount_) public view returns (uint256) {\n        if (tokenId_ == 0 || tokenId_ > totalWorks) return 0;\n        return FEE_MANAGER.getMintFee(works[tokenId_].strategy, amount_).amount;\n    }\n\n    /// @notice Mint a new token for the given work.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mint(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_\n    ) external payable override {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a new token for the given work with a public comment.\n    /// @param to_ The address to mint the token to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param referrer_ The address of the referrer.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    /// @param comment_ The public comment associated with the mint. Emitted as an event.\n    /// @dev This function is used to mint a token with a public comment, allowing the mint to be associated with a message which will be emitted as an event.\n    function mintWithComment(\n        address to_,\n        uint256 tokenId_,\n        uint256 amount_,\n        address referrer_,\n        bytes calldata data_,\n        string calldata comment_\n    ) external payable {\n        Strategy memory strategy = works[tokenId_].strategy;\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, referrer_, strategy\n        );\n\n        _issue(to_, tokenId_, amount_, data_);\n        _refundExcess();\n\n        emit Comment(address(this), tokenId_, to_, comment_);\n    }\n\n    /// @notice Mint multiple tokens for the given works.\n    /// @param to_ The address to mint the tokens to.\n    /// @param tokenIds_ The IDs of the works to mint.\n    /// @param amounts_ The amounts of each work to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address to_,\n        uint256[] calldata tokenIds_,\n        uint256[] calldata amounts_,\n        bytes calldata data_\n    ) external payable {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            Work storage work = works[tokenIds_[i]];\n\n            // wake-disable-next-line reentrancy\n            FEE_MANAGER.collectMintFee{value: msg.value}(\n                this, tokenIds_[i], amounts_[i], msg.sender, address(0), work.strategy\n            );\n\n            _checkTime(work.opensAt, work.closesAt);\n            _updateSupply(work, amounts_[i]);\n        }\n\n        _batchMint(to_, tokenIds_, amounts_, data_);\n        _refundExcess();\n    }\n\n    /// @notice Mint a token to a set of receivers for the given work.\n    /// @param receivers_ The addresses to mint the tokens to.\n    /// @param tokenId_ The ID of the work to mint.\n    /// @param amount_ The amount of tokens to mint.\n    /// @param data_ The data associated with the mint. Reserved for future use.\n    function mintBatch(\n        address[] calldata receivers_,\n        uint256 tokenId_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external payable {\n        // wake-disable-next-line reentrancy\n        FEE_MANAGER.collectMintFee{value: msg.value}(\n            this, tokenId_, amount_, msg.sender, address(0), works[tokenId_].strategy\n        );\n\n        for (uint256 i = 0; i < receivers_.length; i++) {\n            _issue(receivers_[i], tokenId_, amount_, data_);\n        }\n\n        _refundExcess();\n    }\n\n    /// @notice Mint a token from the giv"
    }
  ]
}