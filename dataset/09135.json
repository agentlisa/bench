{
  "Title": "[M-19] `CrvDepositor.sol` Wrong implementation of the 2-week buffer for lock",
  "Content": "_Submitted by WatchPug_\n\n[CrvDepositor.sol#L127-L134](https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L127-L134)<br>\n\n```solidity\nuint256 unlockAt = block.timestamp + MAXTIME;\nuint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;\n\n//increase time too if over 2 week buffer\nif(unlockInWeeks.sub(unlockTime) > 2){\n    IStaker(staker).increaseTime(unlockAt);\n    unlockTime = unlockInWeeks;\n}\n```\n\nIn `_lockCurve()`, `unlockInWeeks - unlockTime` is being used as a number in weeks, while it actually is a number in seconds.\n\nThus, comparing it with `2` actually means a 2 seconds buffer instead of a 2 weeks buffer.\n\nThe intention is to wait for 2 weeks before extending the lock time again, but the current implementation allows the extension of the lock once a new week begins.\n\n### Recommended Mitigation Steps\n\nConsider changing the name of `unlockTime` to `unlockTimeInWeeks`, and:\n\n1.  Change L94-102 to:\n\n[CrvDepositor.sol#L94-L102](https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L94-L102)<br>\n\n```solidity\nuint256 unlockAt = block.timestamp + MAXTIME;\nuint256 unlockInWeeks = unlockAt / WEEK;\n\n//release old lock if exists\nIStaker(staker).release();\n//create new lock\nuint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);\nIStaker(staker).createLock(crvBalanceStaker, unlockAt);\nunlockTimeInWeeks = unlockInWeeks;\n```\n\n2.  Change L127-L134 to:\n\n```solidity\nuint256 unlockAt = block.timestamp + MAXTIME;\nuint256 unlockInWeeks = unlockAt / WEEK;\n\n//increase time too if over 2 week buffer\nif(unlockInWeeks.sub(unlockTime) > 2){\n    IStaker(staker).increaseTime(unlockAt);\n    unlockTimeInWeeks = unlockInWeeks;\n}\n```\n\n**[0xMaharishi (Aura Finance) confirmed and resolved](https://github.com/code-423n4/2022-05-aura-findings/issues/343#issuecomment-1141475468):**\n > [code-423n4/2022-05-aura#6](https://github.com/code-423n4/2022-05-aura/pull/6)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "convex-platform/contracts/contracts/CrvDepositor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\n/**\n * @title   CrvDepositor\n * @author  ConvexFinance\n * @notice  This is the entry point for CRV > cvxCRV wrapping. It accepts CRV, sends to 'staler'\n *          for depositing into Curves VotingEscrow, and then mints cvxCRV at 1:1 via the 'minter' (cCrv) minus\n *          the lockIncentive (initially 1%) which is used to basically compensate users who call the `lock` function on Curves\n *          system (larger depositors would likely want to lock).\n */\ncontract CrvDepositor{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crvBpt;\n    address public immutable escrow;\n    uint256 private constant MAXTIME = 1 * 364 * 86400;\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public lockIncentive = 10; //incentive to users who spend gas to lock crvBpt\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public feeManager;\n    address public daoOperator;\n    address public immutable staker;\n    address public immutable minter;\n    uint256 public incentiveCrv = 0;\n    uint256 public unlockTime;\n\n    bool public cooldown;\n\n    /**\n     * @param _staker   CVX VoterProxy (0x989AEb4d175e16225E39E87d0D97A3360524AD80)\n     * @param _minter   cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _crvBpt   crvBPT for veCRV deposits\n     * @param _escrow   CRV VotingEscrow (0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2)\n     */\n    constructor(\n        address _staker,\n        address _minter,\n        address _crvBpt,\n        address _escrow,\n        address _daoOperator\n    ) public {\n        staker = _staker;\n        minter = _minter;\n        crvBpt = _crvBpt;\n        escrow = _escrow;\n        feeManager = msg.sender;\n        daoOperator = _daoOperator;\n    }\n\n    function setFeeManager(address _feeManager) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeManager;\n    }\n\n    function setDaoOperator(address _daoOperator) external {\n        require(msg.sender == daoOperator, \"!auth\");\n        daoOperator = _daoOperator;\n    }\n\n    function setFees(uint256 _lockIncentive) external{\n        require(msg.sender==feeManager, \"!auth\");\n\n        if(_lockIncentive >= 0 && _lockIncentive <= 30){\n            lockIncentive = _lockIncentive;\n       }\n    }\n\n    function setCooldown(bool _cooldown) external {\n      require(msg.sender == daoOperator, \"!auth\");\n      cooldown = _cooldown;\n    }\n\n    /**\n     * @notice Called once to deposit the balance of CRV in this contract to the VotingEscrow\n     */\n    function initialLock() external{\n        require(!cooldown, \"cooldown\");\n        require(msg.sender==feeManager, \"!auth\");\n\n        uint256 vecrv = IERC20(escrow).balanceOf(staker);\n        if(vecrv == 0){\n            uint256 unlockAt = block.timestamp + MAXTIME;\n            uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;\n\n            //release old lock if exists\n            IStaker(staker).release();\n            //create new lock\n            uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);\n            IStaker(staker).createLock(crvBalanceStaker, unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n    }\n\n    //lock curve\n    function _lockCurve() internal {\n        if(cooldown) {\n          return;\n        }\n\n        uint256 crvBalance = IERC20(crvBpt).balanceOf(address(this));\n        if(crvBalance > 0){\n            IERC20(crvBpt).safeTransfer(staker, crvBalance);\n        }\n        \n        //increase ammount\n        uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);\n        if(crvBalanceStaker == 0){\n            return;\n        }\n        \n        //increase amount\n        IStaker(staker).increaseAmount(crvBalanceStaker);\n        \n\n        uint256 unlockAt = block.timestamp + MAXTIME;\n        uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;\n\n        //increase time too if over 2 week buffer\n        if(unlockInWeeks.sub(unlockTime) > 2){\n            IStaker(staker).increaseTime(unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n    }\n\n    /**\n     * @notice Locks the balance of CRV, and gives out an incentive to the caller\n     */\n    function lockCurve() external {\n        require(!cooldown, \"cooldown\");\n        _lockCurve();\n\n        //mint incentives\n        if(incentiveCrv > 0){\n            ITokenMinter(minter).mint(msg.sender,incentiveCrv);\n            incentiveCrv = 0;\n        }\n    }\n\n    /**\n     * @notice Deposit crvBpt for cvxCrv on behalf of another user\n     * @dev    See depositFor(address, uint256, bool, address) \n     */\n    function deposit(uint256 _amount, bool _lock, address _stakeAddress) public {\n        depositFor(msg.sender, _amount, _lock, _stakeAddress);\n    }\n\n    /**\n     * @notice Deposit crvBpt for cvxCrv\n     * @dev    Can locking immediately or defer locking to someone else by paying a fee.\n     *         while users can choose to lock or defer, this is mostly in place so that\n     *         the cvx reward contract isnt costly to claim rewards.\n     * @param _amount        Units of CRV to deposit\n     * @param _lock          Lock now? or pay ~1% to the locker\n     * @param _stakeAddress  Stake in cvxCrv staking?\n     */\n    function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {\n        require(_amount > 0,\"!>0\");\n        \n        if(_lock){\n            //lock immediately, transfer directly to staker to skip an erc20 transfer\n            IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);\n            _lockCurve();\n            if(incentiveCrv > 0){\n                //add the incentive tokens here so they can be staked together\n                _amount = _amount.add(incentiveCrv);\n                incentiveCrv = 0;\n            }\n        }else{\n            //move tokens here\n            IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);\n            //defer lock cost to another user\n            uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);\n            _amount = _amount.sub(callIncentive);\n\n            //add to a pool for lock caller\n            incentiveCrv = incentiveCrv.add(callIncentive);\n        }\n\n        bool depositOnly = _stakeAddress == address(0);\n        if(depositOnly){\n            //mint for to\n            ITokenMinter(minter).mint(to,_amount);\n        }else{\n            //mint here \n            ITokenMinter(minter).mint(address(this),_amount);\n            //stake for to\n            IERC20(minter).safeApprove(_stakeAddress,0);\n            IERC20(minter).safeApprove(_stakeAddress,_amount);\n            IRewards(_stakeAddress).stakeFor(to,_amount);\n        }\n    }\n\n    function deposit(uint256 _amount, bool _lock) external {\n        deposit(_amount,_lock,address(0));\n    }\n\n    function depositAll(bool _lock, address _stakeAddress) external{\n        uint256 crvBal = IERC20(crvBpt).balanceOf(msg.sender);\n        deposit(crvBal,_lock,_stakeAddress);\n    }\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/CrvDepositor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\n/**\n * @title   CrvDepositor\n * @author  ConvexFinance\n * @notice  This is the entry point for CRV > cvxCRV wrapping. It accepts CRV, sends to 'staler'\n *          for depositing into Curves VotingEscrow, and then mints cvxCRV at 1:1 via the 'minter' (cCrv) minus\n *          the lockIncentive (initially 1%) which is used to basically compensate users who call the `lock` function on Curves\n *          system (larger depositors would likely want to lock).\n */\ncontract CrvDepositor{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crvBpt;\n    address public immutable escrow;\n    uint256 private constant MAXTIME = 1 * 364 * 86400;\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public lockIncentive = 10; //incentive to users who spend gas to lock crvBpt\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public feeManager;\n    address public daoOperator;\n    address public immutable staker;\n    address public immutable minter;\n    uint256 public incentiveCrv = 0;\n    uint256 public unlockTime;\n\n    bool public cooldown;\n\n    /**\n     * @param _staker   CVX VoterProxy (0x989AEb4d175e16225E39E87d0D97A3360524AD80)\n     * @param _minter   cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _crvBpt   crvBPT for veCRV deposits\n     * @param _escrow   CRV VotingEscrow (0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2)\n     */\n    constructor(\n        address _staker,\n        address _minter,\n        address _crvBpt,\n        address _escrow,\n        address _daoOperator\n    ) public {\n        staker = _staker;\n        minter = _minter;\n        crvBpt = _crvBpt;\n        escrow = _escrow;\n        feeManager = msg.sender;\n        daoOperator = _daoOperator;\n    }\n\n    function setFeeManager(address _feeManager) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeManager;\n    }\n\n    function setDaoOperator(address _daoOperator) external {\n        require(msg.sender == daoOperator, \"!auth\");\n        daoOperator = _daoOperator;\n    }\n\n    function setFees(uint256 _lockIncentive) external{\n        require(msg.sender==feeManager, \"!auth\");\n\n        if(_lockIncentive >= 0 && _lockIncentive <= 30){\n            lockIncentive = _lockIncentive;\n       }\n    }\n\n    function setCooldown(bool _cooldown) external {\n      require(msg.sender == daoOperator, \"!auth\");\n      cooldown = _cooldown;\n    }\n\n    /**\n     * @notice Called once to deposit the balance of CRV in this contract to the VotingEscrow\n     */\n    function initialLock() external{\n        require(!cooldown, \"cooldown\");\n        require(msg.sender==feeManager, \"!auth\");\n\n        uint256 vecrv = IERC20(escrow).balanceOf(staker);\n        if(vecrv == 0){\n            uint256 unlockAt = block.timestamp + MAXTIME;\n            uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;\n\n            //release old lock if exists\n            IStaker(staker).release();\n            //create new lock\n            uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);\n            IStaker(staker).createLock(crvBalanceStaker, unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n    }\n\n    //lock curve\n    function _lockCurve() internal {\n        if(cooldown) {\n          return;\n        }\n\n        uint256 crvBalance = IERC20(crvBpt).balanceOf(address(this));\n        if(crvBalance > 0){\n            IERC20(crvBpt).safeTransfer(staker, crvBalance);\n        }\n        \n        //increase ammount\n        uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);\n        if(crvBalanceStaker == 0){\n            return;\n        }\n        \n        //increase amount\n        IStaker(staker).increaseAmount(crvBalanceStaker);\n        \n\n        uint256 unlockAt = block.timestamp + MAXTIME;\n        uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;\n\n        //increase time too if over 2 week buffer\n        if(unlockInWeeks.sub(unlockTime) > 2){\n            IStaker(staker).increaseTime(unlockAt);\n            unlockTime = unlockInWeeks;\n        }\n    }\n\n    /**\n     * @notice Locks the balance of CRV, and gives out an incentive to the caller\n     */\n    function lockCurve() external {\n        require(!cooldown, \"cooldown\");\n        _lockCurve();\n\n        //mint incentives\n        if(incentiveCrv > 0){\n            ITokenMinter(minter).mint(msg.sender,incentiveCrv);\n            incentiveCrv = 0;\n        }\n    }\n\n    /**\n     * @notice Deposit crvBpt for cvxCrv on behalf of another user\n     * @dev    See depositFor(address, uint256, bool, address) \n     */\n    function deposit(uint256 _amount, bool _lock, address _stakeAddress) public {\n        depositFor(msg.sender, _amount, _lock, _stakeAddress);\n    }\n\n    /**\n     * @notice Deposit crvBpt for cvxCrv\n     * @dev    Can locking immediately or defer locking to someone else by paying a fee.\n     *         while users can choose to lock or defer, this is mostly in place so that\n     *         the cvx reward contract isnt costly to claim rewards.\n     * @param _amount        Units of CRV to deposit\n     * @param _lock          Lock now? or pay ~1% to the locker\n     * @param _stakeAddress  Stake in cvxCrv staking?\n     */\n    function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {\n        require(_amount > 0,\"!>0\");\n        \n        if(_lock){\n            //lock immediately, transfer directly to staker to skip an erc20 transfer\n            IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);\n            _lockCurve();\n            if(incentiveCrv > 0){\n                //add the incentive tokens here so they can be staked together\n                _amount = _amount.add(incentiveCrv);\n                incentiveCrv = 0;\n            }\n        }else{\n            //move tokens here\n            IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);\n            //defer lock cost to another user\n            uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);\n            _amount = _amount.sub(callIncentive);\n\n            //add to a pool for lock caller\n            incentiveCrv = incentiveCrv.add(callIncentive);\n        }\n\n        bool depositOnly = _stakeAddress == address(0);\n        if(depositOnly){\n            //mint for to\n            ITokenMinter(minter).mint(to,_amount);\n        }else{\n            //mint here \n            ITokenMinter(minter).mint(address(this),_amount);\n            //stake for to\n            IERC20(minter).safeApprove(_stakeAddress,0);\n            IERC20(minter).safeApprove(_stakeAddress,_amount);\n            IRewards(_stakeAddress).stakeFor(to,_amount);\n        }\n    }\n\n    function deposit(uint256 _amount, bool _lock) external {\n        deposit(_amount,_lock,address(0));\n    }\n\n    function depositAll(bool _lock, address _stakeAddress) external{\n        uint256 crvBal = IERC20(crvBpt).balanceOf(msg.sender);\n        deposit(crvBal,_lock,_stakeAddress);\n    }\n}"
    }
  ]
}