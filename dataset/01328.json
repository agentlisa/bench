{
  "Title": "Creation of a new Pod order in place of an existing order requires excess Beans",
  "Content": "When creating a new Pod order, a user needs to send the Beans required to fulfill the order. If an order already exists with the same sender, `pricePerPod`, `maxPlaceInLine`, and `minFillAmount`, this order must first be canceled, which implies a refund of the previously sent Beans.\n\nOne issue with this workflow, which applies to both [v1](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Order.sol#L62-L68) and [v2](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Order.sol#L80-L83) orders, is that if the user overrides an existing order, they must send additional Beans because those for the previous order are not considered. Instead, it would make more sense to first cancel the existing order, then try to fulfill the Bean requirement with that of the canceled order, and only if this is not sufficient require the caller send additional Beans.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/market/MarketplaceFacet/Order.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./Listing.sol\";\n\n/**\n * @author Beanjoyer, Malteasy\n * @title Pod Marketplace v2\n **/\n\ncontract Order is Listing {\n\n    using SafeMath for uint256;\n\n    struct PodOrder {\n        address account;\n        uint24 pricePerPod;\n        uint256 maxPlaceInLine;\n        uint256 minFillAmount;\n    }\n\n    event PodOrderCreated(\n        address indexed account,\n        bytes32 id,\n        uint256 amount,\n        uint24 pricePerPod,\n        uint256 maxPlaceInLine,\n        uint256 minFillAmount,\n        bytes pricingFunction,\n        LibPolynomial.PriceType priceType\n    );\n\n    event PodOrderFilled(\n        address indexed from,\n        address indexed to,\n        bytes32 id,\n        uint256 index,\n        uint256 start,\n        uint256 amount,\n        uint256 costInBeans\n    );\n\n    event PodOrderCancelled(address indexed account, bytes32 id);\n\n    /*\n    * Create\n    */\n    // Note: Orders changed and now can accept an arbitary amount of beans, possibly higher than the value of the order\n    /* Note: Fixed pod orders store at s.podOrders[id] the amount of pods that they order \n    * whereas dynamic orders store the amount of beans used to make the order \n    */\n    function _createPodOrder(\n        uint256 beanAmount,\n        uint24 pricePerPod,\n        uint256 maxPlaceInLine,\n        uint256 minFillAmount\n    ) internal returns (bytes32 id) {\n        require(beanAmount > 0, \"Marketplace: Order amount must be > 0.\");\n        require(pricePerPod > 0, \"Marketplace: Pod price must be greater than 0.\");\n\n        id = createOrderId(msg.sender, pricePerPod, maxPlaceInLine, minFillAmount);\n\n        if (s.podOrders[id] > 0) _cancelPodOrder(pricePerPod, maxPlaceInLine, minFillAmount, LibTransfer.To.INTERNAL);\n        s.podOrders[id] = beanAmount;\n\n        bytes memory emptyPricingFunction;\n        emit PodOrderCreated(msg.sender, id, beanAmount, pricePerPod, maxPlaceInLine, minFillAmount, emptyPricingFunction, LibPolynomial.PriceType.Fixed);\n    }\n\n    function _createPodOrderV2(\n        uint256 beanAmount,\n        uint256 maxPlaceInLine,\n        uint256 minFillAmount,\n        bytes calldata pricingFunction\n    ) internal returns (bytes32 id) {\n        require(beanAmount > 0, \"Marketplace: Order amount must be > 0.\");\n        id = createOrderIdV2(msg.sender, 0, maxPlaceInLine, minFillAmount, pricingFunction);\n        if (s.podOrders[id] > 0) _cancelPodOrderV2(maxPlaceInLine, minFillAmount, pricingFunction, LibTransfer.To.INTERNAL);\n        s.podOrders[id] = beanAmount;\n\n        emit PodOrderCreated(msg.sender, id, beanAmount, 0, maxPlaceInLine, minFillAmount, pricingFunction, LibPolynomial.PriceType.Dynamic);\n    }\n\n\n    /*\n     * Fill\n     */\n    function _fillPodOrder(\n        PodOrder calldata o,\n        uint256 index,\n        uint256 start,\n        uint256 amount,\n        LibTransfer.To mode\n    ) internal {\n\n        require(amount >= o.minFillAmount, \"Marketplace: Fill must be >= minimum amount.\");\n        require(s.a[msg.sender].field.plots[index] >= (start.add(amount)), \"Marketplace: Invalid Plot.\");\n        require(index.add(start).add(amount).sub(s.f.harvestable) <= o.maxPlaceInLine, \"Marketplace: Plot too far in line.\");\n        \n        bytes32 id = createOrderId(o.account, o.pricePerPod, o.maxPlaceInLine, o.minFillAmount);\n        uint256 costInBeans = amount.mul(o.pricePerPod).div(1000000);\n        s.podOrders[id] = s.podOrders[id].sub(costInBeans, \"Marketplace: Not enough beans in order.\");\n\n        LibTransfer.sendToken(C.bean(), costInBeans, msg.sender, mode);\n        \n        if (s.podListings[index] != bytes32(0)) _cancelPodListing(msg.sender, index);\n        \n        _transferPlot(msg.sender, o.account, index, start, amount);\n\n        if (s.podOrders[id] == 0) delete s.podOrders[id];\n        \n        emit PodOrderFilled(msg.sender, o.account, id, index, start, amount, costInBeans);\n    }\n\n    function _fillPodOrderV2(\n        PodOrder calldata o,\n        uint256 index,\n        uint256 start,\n        uint256 amount,\n        bytes calldata pricingFunction,\n        LibTransfer.To mode\n    ) internal {\n\n        require(amount >= o.minFillAmount, \"Marketplace: Fill must be >= minimum amount.\");\n        require(s.a[msg.sender].field.plots[index] >= (start.add(amount)), \"Marketplace: Invalid Plot.\");\n        require(index.add(start).add(amount).sub(s.f.harvestable) <= o.maxPlaceInLine, \"Marketplace: Plot too far in line.\");\n        \n        bytes32 id = createOrderIdV2(o.account, 0, o.maxPlaceInLine, o.minFillAmount, pricingFunction);\n        uint256 costInBeans = getAmountBeansToFillOrderV2(index.add(start).sub(s.f.harvestable), amount, pricingFunction);\n        s.podOrders[id] = s.podOrders[id].sub(costInBeans, \"Marketplace: Not enough beans in order.\");\n        \n        LibTransfer.sendToken(C.bean(), costInBeans, msg.sender, mode);\n        \n        if (s.podListings[index] != bytes32(0)) _cancelPodListing(msg.sender, index);\n        \n        _transferPlot(msg.sender, o.account, index, start, amount);\n\n        if (s.podOrders[id] == 0) delete s.podOrders[id];\n        \n        emit PodOrderFilled(msg.sender, o.account, id, index, start, amount, costInBeans);\n    }\n\n    /*\n     * Cancel\n     */\n    function _cancelPodOrder(\n        uint24 pricePerPod,\n        uint256 maxPlaceInLine,\n        uint256 minFillAmount,\n        LibTransfer.To mode\n    ) internal {\n        bytes32 id = createOrderId(msg.sender, pricePerPod, maxPlaceInLine, minFillAmount);\n        uint256 amountBeans = s.podOrders[id];\n        LibTransfer.sendToken(C.bean(), amountBeans, msg.sender, mode);\n        delete s.podOrders[id];\n        emit PodOrderCancelled(msg.sender, id);\n    }\n\n    function _cancelPodOrderV2(\n        uint256 maxPlaceInLine,\n        uint256 minFillAmount,\n        bytes calldata pricingFunction,\n        LibTransfer.To mode\n    ) internal {\n        bytes32 id = createOrderIdV2(msg.sender, 0, maxPlaceInLine, minFillAmount, pricingFunction);\n        uint256 amountBeans = s.podOrders[id];\n        LibTransfer.sendToken(C.bean(), amountBeans, msg.sender, mode);\n        delete s.podOrders[id];\n        \n        emit PodOrderCancelled(msg.sender, id);\n    }\n\n    /*\n    * PRICING\n    */\n\n\n    /**\n        Consider a piecewise with the following breakpoints: [b0, b1, b2, b3, b4]\n        Let us say the start  of our integration falls in the range [b0, b1], and the end of our integration falls in the range [b3, b4].\n        Then our integration splits into: I(start, b1) + I(b1, b2) + I(b2, b3) + I(b3, end).\n    */\n    /**\n    * @notice Calculates the amount of beans needed to fill an order.\n    * @dev Integration over a range that falls within piecewise domain.\n    */\n    function getAmountBeansToFillOrderV2(\n        uint256 placeInLine, \n        uint256 amountPodsFromOrder,\n        bytes calldata pricingFunction\n    ) public pure returns (uint256 beanAmount) { \n        beanAmount = LibPolynomial.evaluatePolynomialIntegrationPiecewise(pricingFunction, placeInLine, placeInLine.add(amountPodsFromOrder));\n        beanAmount = beanAmount.div(1000000);\n    }\n\n    /*\n     * Helpers\n     */\n     function createOrderId(\n        address account,\n        uint24 pricePerPod,\n        uint256 maxPlaceInLine,\n        uint256 minFillAmount\n    ) internal pure returns (bytes32 id) {\n        if(minFillAmount > 0) id = keccak256(abi.encodePacked(account, pricePerPod, maxPlaceInLine, minFillAmount));\n        else id = keccak256(abi.encodePacked(account, pricePerPod, maxPlaceInLine));\n    }\n\n    function createOrderIdV2(\n        address account,\n        uint24 pricePerPod,\n        uint256 maxPlaceInLine,\n        uint256 minFillAmount,\n        bytes calldata pricingFunction\n    ) internal pure returns (bytes32 id) {\n        require(pricingFunction.length == LibPolynomial.getNumPieces(pricingFunction).mul(168).add(32), \"Marketplace: Invalid pricing function.\");\n        id = keccak256(abi.encodePacked(account, pricePerPod, maxPlaceInLine, minFillAmount, pricingFunction));\n    }\n}"
    }
  ]
}