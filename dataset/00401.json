{
  "Title": "M-9: No slippage control on maker LP `deposit()`/`withdraw()`",
  "Content": "# Issue M-9: No slippage control on maker LP `deposit()`/`withdraw()` \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/121 \n\n## Found by \n0xRobocop, Bauer, IllIllI, PUSH0, ni8mare\n## Summary\n\nThere are no slippage control arguments for maker LP `deposit()`/`withdraw()`\n\n\n## Vulnerability Detail\n\nThere are no arguments to the `deposit()`/`withdraw()` functions to limit the amount of collateral lost to market movements, and there are no preview functions to allow a UI to show how much collateral would be received when shares are redeemed.\n\n\n## Impact\n\nA user may submit a transaction to redeem approximately $100 worth of shares given base price X, but when the block gets mined two seconds later, the price is at 0.5X due to a flash crash. By the time the user sees what they got, the crash has been arbitraged away, and the base price is back at price X, with the user having gotten half the amount they should have.\n\n\n## Code Snippet\n\nUsers can only specify inputs, not expected outputs:\n```solidity\n// File: src/maker/OracleMaker.sol : OracleMaker.deposit()   #1\n\n175:        function deposit(uint256 amountXCD) external onlyWhitelistLp returns (uint256) {\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/OracleMaker.sol#L165-L185\n\n```solidity\n// File: src/maker/OracleMaker.sol : OracleMaker.withdraw()   #2\n\n228:        function withdraw(uint256 shares) external onlyWhitelistLp returns (uint256) {\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/OracleMaker.sol#L218-L238\n\nand the value received is based on the Pyth [oracle](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/OracleMaker.sol#L439-L443).\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nProvide slippage parameters\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium\n\n**takarez** commented:\n>  no need of slippage.\n\n\n\n**lnxrp**\n\n- Invalid, known issue\n- We will add protection in the future to both makers ([link](https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/src/maker/OracleMaker.sol#L196-L198))([link](https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L270-L272)) against volatility, but it is consider non-urgent since deposit/withdraw is whitelisted at the beginning\n\n**lnxrp**\n\nClarification: we knew there is currently not enough protection as commented in the two links above\n\n**IllIllI000**\n\nEscalate\n\nAs is pointed out [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/140#issuecomment-2037788941), the hierarchy says this should be valid, and if that escalation is right about the rule, this one should be valid because it's a loss of funds to the LP without any way to avoid it. See also [this](https://discord.com/channels/812037309376495636/1211689150663622707/1225550119651377304)\n\n**sherlock-admin2**\n\n> Escalate\n> \n> As is pointed out [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/140#issuecomment-2037788941), the hierarchy says this should be valid, and if that escalation is right about the rule, this one should be valid because it's a loss of funds to the LP without any way to avoid it. See also [this](https://discord.com/channels/812037309376495636/1211689150663622707/1225550119651377304)\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nI believe this issue should remain invalid given it is a known issue based on code comments within contract, unless I have misinterpreted what the hierachy of truth is meant to represent.\n\n**WangSecurity**\n\nI believe this should remain invalid. The hierarchy of truth is used when there's a conflicting information between the README, rules or comments, which is not the case when we talk about intended design/known issues. Hence, planning to reject the escalation and leave the issue as it is.\n\n**Evert0x**\n\nResult:\nInvalid\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IllIllI000](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/121/#issuecomment-2039394011): rejected\n\n**Evert0x**\n\n#121 and duplicates will become Medium. The hierachy of truth will be interpreted as stated here https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/65#issuecomment-2077966086.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/maker/OracleMaker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { IMaker } from \"./IMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { IPythOracleAdapter } from \"../oracle/pythOracleAdapter/IPythOracleAdapter.sol\";\nimport { IWhitelistLpManager } from \"./IWhitelistLpManager.sol\";\n\n// Price from Pyth is predictable due to the latency between prices arriving at Pyth price service\n// and those prices appearing on-chain.\n// See https://sips.synthetix.io/sips/sip-285/#rationale\n//\n// This predictable price can be exploited by a front-runner, so any trade on OracleMaker must be 2-step, aka \"delayed\",\n// and can only be interacted with through OrderGateway and OrderGatewayV2. This is configurable\n// via OracleMaker.setValidSender().\ncontract OracleMaker is ContextBase, AddressResolverUpgradeable, Ownable2StepUpgradeable, ERC20Upgradeable, IMaker {\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for uint256;\n    using LibFormatter for uint256;\n    using LibFormatter for int256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.oracleMaker\n    struct OracleMakerStorage {\n        uint256 marketId;\n        bytes32 priceFeedId;\n        /// @notice the minimum margin ratio required for trade or withdrawal\n        uint256 minMarginRatio; // Min. marign ratio required by the maker at all time.\n        /// @notice max spread ratio is the \"given\" in stoikov maker\n        /// @dev price = maxSpreadRatio * positionRate\n        /// @dev when maker has long, positionRate = min(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        /// @dev when maker has short, positionRate = max(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        uint256 maxSpreadRatio;\n        mapping(address => bool) validSenderMap;\n    }\n\n    event Deposited(\n        address depositor,\n        uint256 shares, // Amount of share minted\n        uint256 underlying // Amount of underlying token deposited\n    );\n\n    event Withdrawn(\n        address withdrawer,\n        uint256 shares, // Amount of shares burnt\n        uint256 underlying // Amount of underlying tokens withdrawn\n    );\n\n    /// @notice Emitted when an order is being filled by a Pyth Oracle Maker.\n    ///         It reveals all information associated to the trade price.\n    event OMOrderFilled(\n        uint256 marketId,\n        uint256 oraclePrice, // In quote asset as wei, assume price >= 0\n        int256 baseAmount, // Base token amount filled (from taker's perspective)\n        int256 quoteAmount // Quote token amount filled (from taker's perspective)\n    );\n\n    event PriceFeedIdSet(bytes32 newPriceFeedId, bytes32 oldPriceFeedId);\n\n    event MinMarginRatioSet(uint256 newMinMarginRatio, uint256 oldMinMarginRatio);\n    event MaxSpreadRatioSet(uint256 newMaxSpreadRatio, uint256 oldMaxSpreadRatio);\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.oracleMaker\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _ORACLE_MAKER_STORAGE_LOCATION =\n        0x49404affd0747f1de28f32f44120f8f18db1aa69644f83b133007475ed402e00;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyClearingHouse() {\n        if (msg.sender != address(getAddressManager().getClearingHouse())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyWhitelistLp() {\n        IWhitelistLpManager whitelistManager = getAddressManager().getWhitelistLpManager();\n        if (address(whitelistManager) != address(0)) {\n            if (!whitelistManager.isLpWhitelisted(_sender())) revert LibError.Unauthorized();\n        }\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 marketId_,\n        string memory name_,\n        string memory symbol_,\n        address addressManager_,\n        bytes32 priceFeedId_,\n        uint256 minMarginRatio_\n    ) external initializer {\n        __AddressResolver_init(addressManager_);\n        __Ownable2Step_init();\n        __Ownable_init(msg.sender);\n        __ERC20_init(name_, symbol_);\n\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(priceFeedId_))\n            revert LibError.IllegalPriceFeed(priceFeedId_);\n\n        _getOracleMakerStorage().marketId = marketId_;\n        setPriceFeedId(priceFeedId_);\n        setMinMarginRatio(minMarginRatio_);\n    }\n\n    function setPriceFeedId(bytes32 _priceFeedId) public onlyOwner {\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(_priceFeedId))\n            revert LibError.IllegalPriceFeed(_priceFeedId);\n\n        bytes32 oldPriceFeedId = _getOracleMakerStorage().priceFeedId;\n        _getOracleMakerStorage().priceFeedId = _priceFeedId;\n\n        emit PriceFeedIdSet(_priceFeedId, oldPriceFeedId);\n    }\n\n    function setMinMarginRatio(uint256 _minMarginRatio) public onlyOwner {\n        if (_minMarginRatio > WAD) {\n            revert LibError.InvalidRatio(_minMarginRatio);\n        }\n        if (_minMarginRatio == 0) {\n            revert LibError.ZeroRatio();\n        }\n        uint256 oldMinMarginRatio = _getOracleMakerStorage().minMarginRatio;\n        _getOracleMakerStorage().minMarginRatio = _minMarginRatio;\n\n        emit MinMarginRatioSet(_minMarginRatio, oldMinMarginRatio);\n    }\n\n    function setMaxSpreadRatio(uint256 _maxSpreadRatio) public onlyOwner {\n        if (_maxSpreadRatio > WAD) {\n            revert LibError.InvalidRatio(_maxSpreadRatio);\n        }\n        uint256 oldMaxSpreadRatio = _getOracleMakerStorage().maxSpreadRatio;\n        _getOracleMakerStorage().maxSpreadRatio = _maxSpreadRatio;\n\n        emit MaxSpreadRatioSet(_maxSpreadRatio, oldMaxSpreadRatio);\n    }\n\n    function setValidSender(address user, bool isValid) public onlyOwner {\n        _getOracleMakerStorage().validSenderMap[user] = isValid;\n    }\n\n    function deposit(uint256 amountXCD) external onlyWhitelistLp returns (uint256) {\n        address depositor = _sender();\n        address maker = address(this);\n\n        if (amountXCD == 0) revert LibError.ZeroAmount();\n\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        IAddressManager addressManager = getAddressManager();\n        IVault vault = addressManager.getVault();\n\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amountXCD;\n        } else {\n            uint256 price = _getPrice();\n\n            // TODO Should consider slippage once maker has spread or other pricing logic.\n            // For now, we will just get account value from ClearingHouse (assume no slippages).\n            // shares per asset = share (share token precision) / accountValue (INTERNAL_DECIMALS)\n            // shares (share token precision) = assets (base token precision) * shares per asset\n\n            // TODO: We should add protections to prevent attackers from manipulating the share price by manipulating oracle reported price.\n            // This is because the attacker could potentially mint large amount of shares by forcing the account value low.\n            // Possible protections like rate limiting share price, or any kind of volatility check.\n\n            uint8 shareDecimals = decimals();\n            uint256 vaultValueXShareDecimals = _getVaultValueSafe(vault, price).formatDecimals(\n                INTERNAL_DECIMALS,\n                shareDecimals\n            );\n            uint256 amountXShareDecimals = amountXCD.formatDecimals(collateralToken.decimals(), shareDecimals);\n            shares = (amountXShareDecimals * totalSupply()) / vaultValueXShareDecimals;\n        }\n\n        uint256 balanceBefore = collateralToken.balanceOf(maker);\n        collateralToken.safeTransferFrom(_sender(), maker, amountXCD);\n        uint256 transferredAmount = collateralToken.balanceOf(maker) - balanceBefore;\n\n        if (transferredAmount != amountXCD) {\n            revert LibError.WrongTransferAmount(transferredAmount, amountXCD);\n        }\n\n        collateralToken.approve(address(vault), amountXCD);\n        vault.deposit(maker, amountXCD);\n        vault.transferFundToMargin(_getOracleMakerStorage().marketId, amountXCD);\n\n        _mint(depositor, shares);\n\n        emit Deposited(depositor, shares, amountXCD);\n\n        return shares;\n    }\n\n    function withdraw(uint256 shares) external onlyWhitelistLp returns (uint256) {\n        address withdrawer = _sender();\n\n        if (shares == 0) revert LibError.ZeroAmount();\n\n        // Must done before burn.\n        uint256 redeemedRatio = shares.divWad(totalSupply());\n\n        // Revert early if shares amount exceeds balance\n        _burn(withdrawer, shares);\n\n        IVault vault = _getVault();\n\n        uint256 price = _getPrice();\n        uint256 vaultValue = _getVaultValueSafe(vault, price);\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        uint256 withdrawnAmountXCD = vaultValue.mulWad(redeemedRatio).formatDecimals(\n            INTERNAL_DECIMALS,\n            collateralToken.decimals()\n        );\n\n        // It may not be possible to withdraw the required amount, due to unsettledPnl that cannot be settled totally.\n        vault.transferMarginToFund(_getOracleMakerStorage().marketId, withdrawnAmountXCD);\n        vault.withdraw(withdrawnAmountXCD);\n        collateralToken.safeTransfer(withdrawer, withdrawnAmountXCD);\n\n        _checkMinMarginRatio(price);\n\n        emit Withdrawn(withdrawer, shares, withdrawnAmountXCD);\n\n        return withdrawnAmountXCD;\n    }\n\n    function fillOrderCallback(bytes calldata) external view onlyClearingHouse {\n        _checkMinMarginRatio(_getPrice());\n    }\n\n    function fillOrder(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bytes calldata\n    ) external onlyClearingHouse returns (uint256, bytes memory) {\n        uint256 basePrice = _getPrice();\n        uint256 basePriceWithSpread = _getBasePriceWithSpread(basePrice, isBaseToQuote);\n\n        // - `amount` base -> `amount * basePrice` quote\n        //   (isBaseToQuote=true, isExactInput=true, openNotional = `amount * basePrice`)\n        // - `amount` base <- `amount * basePrice` quote\n        //   (isBaseToQuote=false, isExactInput=false, openNotional = -`amount * basePrice`)\n        // - `amount / basePrice` base -> `amount` quote\n        //   (isBaseToQuote=true, isExactInput=false, openNotional = `amount`)\n        // - `amount / basePrice` base <- `amount` quote\n        //   (isBaseToQuote=false, isExactInput=true, openNotional = -`amount`)\n\n        int256 baseAmount;\n        int256 quoteAmount;\n        uint256 oppositeAmount;\n        if (isBaseToQuote) {\n            if (isExactInput) {\n                // TODO: Should use configed decimal number instead of hard-coding\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = -amount.toInt256();\n                quoteAmount = oppositeAmount.toInt256();\n            } else {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = -oppositeAmount.toInt256();\n                quoteAmount = amount.toInt256();\n            }\n        } else {\n            if (isExactInput) {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = oppositeAmount.toInt256();\n                quoteAmount = -amount.toInt256();\n            } else {\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = amount.toInt256();\n                quoteAmount = -oppositeAmount.toInt256();\n            }\n        }\n        emit OMOrderFilled(_getOracleMakerStorage().marketId, basePrice, baseAmount, quoteAmount);\n        return (oppositeAmount, new bytes(0));\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function getUtilRatio() external view returns (uint256, uint256) {\n        if (totalSupply() == 0) {\n            return (0, 0);\n        }\n\n        IVault vault = _getVault();\n        int256 positionSize = vault.getPositionSize(_getOracleMakerStorage().marketId, address(this));\n\n        if (positionSize == 0) {\n            return (0, 0);\n        }\n\n        uint256 price = _getPrice();\n        int256 positionRate = _getPositionRate(price);\n        // position rate > 0, maker has long position, set long util ratio to 0 so taker tends to long\n        // position rate < 0, maker has short position, set short util ratio to 0 so taker tends to short\n        return positionRate > 0 ? (uint256(0), positionRate.toUint256()) : ((-positionRate).toUint256(), uint256(0));\n    }\n\n    function isValidSender(address sender) external view returns (bool) {\n        return _getOracleMakerStorage().validSenderMap[sender];\n    }\n\n    function getAsset() external view returns (address) {\n        return _getAsset();\n    }\n\n    function getTotalAssets(uint256 price) external view returns (int256) {\n        IVault vault = _getVault();\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        return _getVaultValue(vault, price).formatDecimals(INTERNAL_DECIMALS, collateralToken.decimals());\n    }\n\n    // For backward-compatibility\n    function marketId() external view returns (uint256) {\n        return _getOracleMakerStorage().marketId;\n    }\n\n    // For backward-compatibility\n    function priceFeedId() external view returns (bytes32) {\n        return _getOracleMakerStorage().priceFeedId;\n    }\n\n    // For backward-compatibility\n    function minMarginRatio() external view returns (uint256) {\n        return _getOracleMakerStorage().minMarginRatio;\n    }\n\n    // For backward-compatibility\n    function maxSpreadRatio() external view returns (uint256) {\n        return _getOracleMakerStorage().maxSpreadRatio;\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    // FIXME: when over minMarginRatio, should allow reduce maker position\n    function _checkMinMarginRatio(uint256 price) internal view {\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        int256 marginRatio = _getVault().getMarginRatio(marketId_, address(this), price);\n        int256 minMarginRatio_ = _getOracleMakerStorage().minMarginRatio.toInt256();\n        if (marginRatio < minMarginRatio_) revert LibError.MinMarginRatioExceeded(marginRatio, minMarginRatio_);\n    }\n\n    function _getAsset() internal view returns (address) {\n        return getAddressManager().getVault().getCollateralToken();\n    }\n\n    function _getVaultValue(IVault vault, uint256 price) internal view returns (int256) {\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        return vault.getAccountValue(marketId_, address(this), price);\n    }\n\n    function _getVaultValueSafe(IVault vault, uint256 price) internal view returns (uint256) {\n        // Revert early since we don't allow deposit/withdraw when the vault's value is negative or zero.\n        int256 vaultValue = _getVaultValue(vault, price);\n        if (vaultValue <= 0) revert LibError.NegativeOrZeroVaultValueInQuote(vaultValue);\n\n        return vaultValue.toUint256();\n    }\n\n    function _getBasePriceWithSpread(uint256 basePrice, bool isBaseToQuote) internal view returns (uint256) {\n        int256 positionRate = _getPositionRate(basePrice);\n        int256 spreadRatio = (_getOracleMakerStorage().maxSpreadRatio.toInt256() * positionRate) / 1 ether;\n        uint256 reservationPrice = (basePrice * (1 ether - spreadRatio).toUint256()) / 1 ether;\n        return\n            isBaseToQuote\n                ? FixedPointMathLib.min(basePrice, reservationPrice)\n                : FixedPointMathLib.max(basePrice, reservationPrice);\n    }\n\n    function _getPositionRate(uint256 price) internal view returns (int256) {\n        IVault vault = _getVault();\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        int256 accountValue = vault.getAccountValue(marketId_, address(this), price);\n        int256 unrealizedPnl = vault.getUnrealizedPnl(marketId_, address(this), price);\n        int256 unsettledMargin = accountValue - unrealizedPnl;\n        int256 collateralForOpen = FixedPointMathLib.min(unsettledMargin, accountValue);\n        // TODO: use positionMarginRequirement\n        //int256 collateralForOpen = positionMarginRequirement + freeCollateralForOpen;\n        if (collateralForOpen <= 0) {\n            revert LibError.NegativeOrZeroMargin();\n        }\n\n        int256 maxPositionNotional = (collateralForOpen * 1 ether) / _getOracleMakerStorage().minMarginRatio.toInt256();\n\n        // if maker has long position, positionRate > 0\n        // if maker has short position, positionRate < 0\n        int256 openNotional = vault.getOpenNotional(marketId_, address(this));\n        int256 uncappedPositionRate = (-openNotional * 1 ether) / maxPositionNotional;\n\n        // util ratio: 0 ~ 1\n        // position rate: -1 ~ 1\n        return\n            uncappedPositionRate > 0\n                ? FixedPointMathLib.min(uncappedPositionRate, 1 ether)\n                : FixedPointMathLib.max(uncappedPositionRate, -1 ether);\n    }\n\n    function _getPrice() internal view returns (uint256) {\n        IPythOracleAdapter pythOracleAdapter = getAddressManager().getPythOracleAdapter();\n        (uint256 price, ) = pythOracleAdapter.getPrice(_getOracleMakerStorage().priceFeedId);\n        return price;\n    }\n\n    //\n    // PRIVATE\n    //\n\n    function _getOracleMakerStorage() private pure returns (OracleMakerStorage storage $) {\n        assembly {\n            $.slot := _ORACLE_MAKER_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/maker/OracleMaker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { IMaker } from \"./IMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { IPythOracleAdapter } from \"../oracle/pythOracleAdapter/IPythOracleAdapter.sol\";\nimport { IWhitelistLpManager } from \"./IWhitelistLpManager.sol\";\n\n// Price from Pyth is predictable due to the latency between prices arriving at Pyth price service\n// and those prices appearing on-chain.\n// See https://sips.synthetix.io/sips/sip-285/#rationale\n//\n// This predictable price can be exploited by a front-runner, so any trade on OracleMaker must be 2-step, aka \"delayed\",\n// and can only be interacted with through OrderGateway and OrderGatewayV2. This is configurable\n// via OracleMaker.setValidSender().\ncontract OracleMaker is ContextBase, AddressResolverUpgradeable, Ownable2StepUpgradeable, ERC20Upgradeable, IMaker {\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for uint256;\n    using LibFormatter for uint256;\n    using LibFormatter for int256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.oracleMaker\n    struct OracleMakerStorage {\n        uint256 marketId;\n        bytes32 priceFeedId;\n        /// @notice the minimum margin ratio required for trade or withdrawal\n        uint256 minMarginRatio; // Min. marign ratio required by the maker at all time.\n        /// @notice max spread ratio is the \"given\" in stoikov maker\n        /// @dev price = maxSpreadRatio * positionRate\n        /// @dev when maker has long, positionRate = min(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        /// @dev when maker has short, positionRate = max(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        uint256 maxSpreadRatio;\n        mapping(address => bool) validSenderMap;\n    }\n\n    event Deposited(\n        address depositor,\n        uint256 shares, // Amount of share minted\n        uint256 underlying // Amount of underlying token deposited\n    );\n\n    event Withdrawn(\n        address withdrawer,\n        uint256 shares, // Amount of shares burnt\n        uint256 underlying // Amount of underlying tokens withdrawn\n    );\n\n    /// @notice Emitted when an order is being filled by a Pyth Oracle Maker.\n    ///         It reveals all information associated to the trade price.\n    event OMOrderFilled(\n        uint256 marketId,\n        uint256 oraclePrice, // In quote asset as wei, assume price >= 0\n        int256 baseAmount, // Base token amount filled (from taker's perspective)\n        int256 quoteAmount // Quote token amount filled (from taker's perspective)\n    );\n\n    event PriceFeedIdSet(bytes32 newPriceFeedId, bytes32 oldPriceFeedId);\n\n    event MinMarginRatioSet(uint256 newMinMarginRatio, uint256 oldMinMarginRatio);\n    event MaxSpreadRatioSet(uint256 newMaxSpreadRatio, uint256 oldMaxSpreadRatio);\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.oracleMaker\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _ORACLE_MAKER_STORAGE_LOCATION =\n        0x49404affd0747f1de28f32f44120f8f18db1aa69644f83b133007475ed402e00;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyClearingHouse() {\n        if (msg.sender != address(getAddressManager().getClearingHouse())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyWhitelistLp() {\n        IWhitelistLpManager whitelistManager = getAddressManager().getWhitelistLpManager();\n        if (address(whitelistManager) != address(0)) {\n            if (!whitelistManager.isLpWhitelisted(_sender())) revert LibError.Unauthorized();\n        }\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 marketId_,\n        string memory name_,\n        string memory symbol_,\n        address addressManager_,\n        bytes32 priceFeedId_,\n        uint256 minMarginRatio_\n    ) external initializer {\n        __AddressResolver_init(addressManager_);\n        __Ownable2Step_init();\n        __Ownable_init(msg.sender);\n        __ERC20_init(name_, symbol_);\n\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(priceFeedId_))\n            revert LibError.IllegalPriceFeed(priceFeedId_);\n\n        _getOracleMakerStorage().marketId = marketId_;\n        setPriceFeedId(priceFeedId_);\n        setMinMarginRatio(minMarginRatio_);\n    }\n\n    function setPriceFeedId(bytes32 _priceFeedId) public onlyOwner {\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(_priceFeedId))\n            revert LibError.IllegalPriceFeed(_priceFeedId);\n\n        bytes32 oldPriceFeedId = _getOracleMakerStorage().priceFeedId;\n        _getOracleMakerStorage().priceFeedId = _priceFeedId;\n\n        emit PriceFeedIdSet(_priceFeedId, oldPriceFeedId);\n    }\n\n    function setMinMarginRatio(uint256 _minMarginRatio) public onlyOwner {\n        if (_minMarginRatio > WAD) {\n            revert LibError.InvalidRatio(_minMarginRatio);\n        }\n        if (_minMarginRatio == 0) {\n            revert LibError.ZeroRatio();\n        }\n        uint256 oldMinMarginRatio = _getOracleMakerStorage().minMarginRatio;\n        _getOracleMakerStorage().minMarginRatio = _minMarginRatio;\n\n        emit MinMarginRatioSet(_minMarginRatio, oldMinMarginRatio);\n    }\n\n    function setMaxSpreadRatio(uint256 _maxSpreadRatio) public onlyOwner {\n        if (_maxSpreadRatio > WAD) {\n            revert LibError.InvalidRatio(_maxSpreadRatio);\n        }\n        uint256 oldMaxSpreadRatio = _getOracleMakerStorage().maxSpreadRatio;\n        _getOracleMakerStorage().maxSpreadRatio = _maxSpreadRatio;\n\n        emit MaxSpreadRatioSet(_maxSpreadRatio, oldMaxSpreadRatio);\n    }\n\n    function setValidSender(address user, bool isValid) public onlyOwner {\n        _getOracleMakerStorage().validSenderMap[user] = isValid;\n    }\n\n    function deposit(uint256 amountXCD) external onlyWhitelistLp returns (uint256) {\n        address depositor = _sender();\n        address maker = address(this);\n\n        if (amountXCD == 0) revert LibError.ZeroAmount();\n\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        IAddressManager addressManager = getAddressManager();\n        IVault vault = addressManager.getVault();\n\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amountXCD;\n        } else {\n            uint256 price = _getPrice();\n\n            // TODO Should consider slippage once maker has spread or other pricing logic.\n            // For now, we will just get account value from ClearingHouse (assume no slippages).\n            // shares per asset = share (share token precision) / accountValue (INTERNAL_DECIMALS)\n            // shares (share token precision) = assets (base token precision) * shares per asset\n\n            // TODO: We should add protections to prevent attackers from manipulating the share price by manipulating oracle reported price.\n            // This is because the attacker could potentially mint large amount of shares by forcing the account value low.\n            // Possible protections like rate limiting share price, or any kind of volatility check.\n\n            uint8 shareDecimals = decimals();\n            uint256 vaultValueXShareDecimals = _getVaultValueSafe(vault, price).formatDecimals(\n                INTERNAL_DECIMALS,\n                shareDecimals\n            );\n            uint256 amountXShareDecimals = amountXCD.formatDecimals(collateralToken.decimals(), shareDecimals);\n            shares = (amountXShareDecimals * totalSupply()) / vaultValueXShareDecimals;\n        }\n\n        uint256 balanceBefore = collateralToken.balanceOf(maker);\n        collateralToken.safeTransferFrom(_sender(), maker, amountXCD);\n        uint256 transferredAmount = collateralToken.balanceOf(maker) - balanceBefore;\n\n        if (transferredAmount != amountXCD) {\n            revert LibError.WrongTransferAmount(transferredAmount, amountXCD);\n        }\n\n        collateralToken.approve(address(vault), amountXCD);\n        vault.deposit(maker, amountXCD);\n        vault.transferFundToMargin(_getOracleMakerStorage().marketId, amountXCD);\n\n        _mint(depositor, shares);\n\n        emit Deposited(depositor, shares, amountXCD);\n\n        return shares;\n    }\n\n    function withdraw(uint256 shares) external onlyWhitelistLp returns (uint256) {\n        address withdrawer = _sender();\n\n        if (shares == 0) revert LibError.ZeroAmount();\n\n        // Must done before burn.\n        uint256 redeemedRatio = shares.divWad(totalSupply());\n\n        // Revert early if shares amount exceeds balance\n        _burn(withdrawer, shares);\n\n        IVault vault = _getVault();\n\n        uint256 price = _getPrice();\n        uint256 vaultValue = _getVaultValueSafe(vault, price);\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        uint256 withdrawnAmountXCD = vaultValue.mulWad(redeemedRatio).formatDecimals(\n            INTERNAL_DECIMALS,\n            collateralToken.decimals()\n        );\n\n        // It may not be possible to withdraw the required amount, due to unsettledPnl that cannot be settled totally.\n        vault.transferMarginToFund(_getOracleMakerStorage().marketId, withdrawnAmountXCD);\n        vault.withdraw(withdrawnAmountXCD);\n        collateralToken.safeTransfer(withdrawer, withdrawnAmountXCD);\n\n        _checkMinMarginRatio(price);\n\n        emit Withdrawn(withdrawer, shares, withdrawnAmountXCD);\n\n        return withdrawnAmountXCD;\n    }\n\n    function fillOrderCallback(bytes calldata) external view onlyClearingHouse {\n        _checkMinMarginRatio(_getPrice());\n    }\n\n    function fillOrder(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bytes calldata\n    ) external onlyClearingHouse returns (uint256, bytes memory) {\n        uint256 basePrice = _getPrice();\n        uint256 basePriceWithSpread = _getBasePriceWithSpread(basePrice, isBaseToQuote);\n\n        // - `amount` base -> `amount * basePrice` quote\n        //   (isBaseToQuote=true, isExactInput=true, openNotional = `amount * basePrice`)\n        // - `amount` base <- `amount * basePrice` quote\n        //   (isBaseToQuote=false, isExactInput=false, openNotional = -`amount * basePrice`)\n        // - `amount / basePrice` base -> `amount` quote\n        //   (isBaseToQuote=true, isExactInput=false, openNotional = `amount`)\n        // - `amount / basePrice` base <- `amount` quote\n        //   (isBaseToQuote=false, isExactInput=true, openNotional = -`amount`)\n\n        int256 baseAmount;\n        int256 quoteAmount;\n        uint256 oppositeAmount;\n        if (isBaseToQuote) {\n            if (isExactInput) {\n                // TODO: Should use configed decimal number instead of hard-coding\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = -amount.toInt256();\n                quoteAmount = oppositeAmount.toInt256();\n            } else {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = -oppositeAmount.toInt256();\n                quoteAmount = amount.toInt256();\n            }\n        } else {\n            if (isExactInput) {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = oppositeAmount.toInt256();\n                quoteAmount = -amount.toInt256();\n            } else {\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = amount.toInt256();\n                quoteAmount = -oppositeAmount.toInt256();\n            }\n        }\n        emit OMOrderFilled(_getOracleMakerStorage().marketId, basePrice, baseAmount, quoteAmount);\n        return (oppositeAmount, new bytes(0));\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function getUtilRatio() external view returns (uint256, uint256) {\n        if (totalSupply() == 0) {\n            return (0, 0);\n        }\n\n        IVault vault = _getVault();\n        int256 positionSize = vault.getPositionSize(_getOracleMakerStorage().marketId, address(this));\n\n        if (positionSize == 0) {\n            return (0, 0);\n        }\n\n        uint256 price = _getPrice();\n        int256 positionRate = _getPositionRate(price);\n        // position rate > 0, maker has long position, set long util ratio to 0 so taker tends to long\n        // position rate < 0, maker has short position, set short util ratio to 0 so taker tends to short\n        return positionRate > 0 ? (uint256(0), positionRa"
    }
  ]
}