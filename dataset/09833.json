{
  "Title": "[M-07] Updating the hubâ€™s token contract address may lead to incorrect undelegation amount",
  "Content": "\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/config.rs#L90-L97>\n\nThe hub contract allows config updates to the `token_contract` config values in `anchor-bAsset-contracts/contracts/anchor_basset_hub/src/config.rs`.<br>\nSuch updates can cause wrong amounts of tokens to be calculated during processing of undelegations, since the amount of unbonded bLuna tokens is stored for batched unbonding as `requested_with_fee`.\n\n### Proof of Concept\n\nContract : anchor-bAsset-contracts/contracts/anchor\\_basset\\_hub/src/config.rs<br>\nFunction : pub fn execute\\_update\\_config(...)<br>\nLine 90 :<br>\n\n        if let Some(token) = token_contract {\n            let token_raw = deps.api.addr_canonicalize(token.as_str())?;\n\n            CONFIG.update(deps.storage, |mut last_config| -> StdResult<Config> {\n                last_config.token_contract = Some(token_raw);\n                Ok(last_config)\n            })?;\n        }\n\n### Recommended Mitigation Steps\n\nIts recommended to remove the ability to update `token_contract` config value, or asserting that `requested_with_fee` is zero before allowing an update of the `token_contract` address.\n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/62#issuecomment-1207279889):**\n > Looks like Admin Privilege so Medium seems appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/config.rs",
      "content": "use crate::state::{\n    read_validators, remove_white_validators, store_white_validators, Parameters, CONFIG,\n    PARAMETERS,\n};\nuse basset::hub::{Config, ExecuteMsg};\nuse cosmwasm_std::{\n    attr, to_binary, Addr, CosmosMsg, Decimal, DepsMut, DistributionMsg, Env, MessageInfo,\n    Response, StakingMsg, StdError, StdResult, WasmMsg,\n};\n\nuse rand::{Rng, SeedableRng, XorShiftRng};\n\n/// Update general parameters\n/// Only creator/owner is allowed to execute\n#[allow(clippy::too_many_arguments)]\npub fn execute_update_params(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    epoch_period: Option<u64>,\n    unbonding_period: Option<u64>,\n    peg_recovery_fee: Option<Decimal>,\n    er_threshold: Option<Decimal>,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = CONFIG.load(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    if sender_raw != config.creator {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let params: Parameters = PARAMETERS.load(deps.storage)?;\n\n    let new_params = Parameters {\n        epoch_period: epoch_period.unwrap_or(params.epoch_period),\n        underlying_coin_denom: params.underlying_coin_denom,\n        unbonding_period: unbonding_period.unwrap_or(params.unbonding_period),\n        peg_recovery_fee: peg_recovery_fee.unwrap_or(params.peg_recovery_fee),\n        er_threshold: er_threshold.unwrap_or(params.er_threshold),\n        reward_denom: params.reward_denom,\n    };\n\n    PARAMETERS.save(deps.storage, &new_params)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"update_params\")]))\n}\n\n/// Update the config. Update the owner, reward and token contracts.\n/// Only creator/owner is allowed to execute\npub fn execute_update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: Option<String>,\n    reward_contract: Option<String>,\n    token_contract: Option<String>,\n    airdrop_registry_contract: Option<String>,\n) -> StdResult<Response> {\n    // only owner must be able to send this message.\n    let conf = CONFIG.load(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    if sender_raw != conf.creator {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut messages: Vec<CosmosMsg> = vec![];\n\n    if let Some(o) = owner {\n        let owner_raw = deps.api.addr_canonicalize(o.as_str())?;\n\n        CONFIG.update(deps.storage, |mut last_config| -> StdResult<Config> {\n            last_config.creator = owner_raw;\n            Ok(last_config)\n        })?;\n    }\n    if let Some(reward) = reward_contract {\n        let reward_raw = deps.api.addr_canonicalize(reward.as_str())?;\n\n        CONFIG.update(deps.storage, |mut last_config| -> StdResult<Config> {\n            last_config.reward_contract = Some(reward_raw);\n            Ok(last_config)\n        })?;\n\n        // register the reward contract for automate reward withdrawal.\n        messages.push(CosmosMsg::Distribution(\n            DistributionMsg::SetWithdrawAddress { address: reward },\n        ));\n    }\n\n    if let Some(token) = token_contract {\n        let token_raw = deps.api.addr_canonicalize(token.as_str())?;\n\n        CONFIG.update(deps.storage, |mut last_config| -> StdResult<Config> {\n            last_config.token_contract = Some(token_raw);\n            Ok(last_config)\n        })?;\n    }\n\n    if let Some(airdrop) = airdrop_registry_contract {\n        let airdrop_raw = deps.api.addr_canonicalize(airdrop.as_str())?;\n        CONFIG.update(deps.storage, |mut last_config| -> StdResult<Config> {\n            last_config.airdrop_registry_contract = Some(airdrop_raw);\n            Ok(last_config)\n        })?;\n    }\n\n    Ok(Response::new()\n        .add_messages(messages)\n        .add_attributes(vec![attr(\"action\", \"update_config\")]))\n}\n\n/// Register a white listed validator.\n/// Only creator/owner is allowed to execute\npub fn execute_register_validator(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    validator: String,\n) -> StdResult<Response> {\n    let hub_conf = CONFIG.load(deps.storage)?;\n\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    let contract_raw = deps.api.addr_canonicalize(env.contract.address.as_str())?;\n    if hub_conf.creator != sender_raw && contract_raw != sender_raw {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    // given validator must be first a validator in the system.\n    let exists = deps\n        .querier\n        .query_all_validators()?\n        .iter()\n        .any(|val| val.address == validator);\n    if !exists {\n        return Err(StdError::generic_err(\n            \"The specified address is not a validator\",\n        ));\n    }\n\n    store_white_validators(deps.storage, validator.clone())?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"register_validator\"),\n        attr(\"validator\", validator),\n    ]))\n}\n\n/// Deregister a previously-whitelisted validator.\n/// Only creator/owner is allowed to execute\npub fn execute_deregister_validator(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    validator: String,\n) -> StdResult<Response> {\n    let token = CONFIG.load(deps.storage)?;\n\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    if token.creator != sender_raw {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n    let validators_before_remove = read_validators(deps.storage)?;\n\n    if validators_before_remove.len() == 1 {\n        return Err(StdError::generic_err(\n            \"Cannot remove the last whitelisted validator\",\n        ));\n    }\n\n    remove_white_validators(deps.storage, validator.to_string())?;\n\n    let query = deps\n        .querier\n        .query_delegation(env.contract.address.clone(), validator.clone());\n\n    let mut replaced_val = Addr::unchecked(\"\");\n    let mut messages: Vec<CosmosMsg> = vec![];\n\n    if let Ok(q) = query {\n        let delegated_amount = q;\n        let validators = read_validators(deps.storage)?;\n\n        // redelegate the amount to a random validator.\n        let block_height = env.block.height;\n        let mut rng = XorShiftRng::seed_from_u64(block_height);\n        let random_index = rng.gen_range(0, validators.len());\n        replaced_val = Addr::unchecked(validators.get(random_index).unwrap().as_str());\n\n        if let Some(delegation) = delegated_amount {\n            messages.push(CosmosMsg::Staking(StakingMsg::Redelegate {\n                src_validator: validator.to_string(),\n                dst_validator: replaced_val.to_string(),\n                amount: delegation.amount,\n            }));\n\n            let msg = ExecuteMsg::UpdateGlobalIndex {\n                airdrop_hooks: None,\n            };\n            messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: env.contract.address.to_string(),\n                msg: to_binary(&msg)?,\n                funds: vec![],\n            }));\n        }\n    }\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"de_register_validator\"),\n        attr(\"validator\", validator),\n        attr(\"new-validator\", replaced_val),\n    ]))\n}"
    }
  ]
}