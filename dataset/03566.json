{
  "Title": "Unnecessary assert on immutable variable",
  "Content": "##### Description\nAssertion `address(investmentToken) != address(want)` in `_buyInvestmentTokenWithWant` is not necessary during contract execution\n\nhttps://github.com/therealmonoloco/maker-dai-delegate/blob/97949a51062df956fd0172b7b1c778f66844b634/contracts/Strategy.sol#L855\n##### Recommendation\nIt is recommended to make this assertion in `initialize` function",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Strategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {BaseStrategy} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport {\n    SafeERC20,\n    SafeMath,\n    IERC20,\n    Address\n} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./libraries/MakerDaiDelegateLib.sol\";\n\nimport \"../interfaces/chainlink/AggregatorInterface.sol\";\nimport \"../interfaces/swap/ISwap.sol\";\nimport \"../interfaces/yearn/IOSMedianizer.sol\";\nimport \"../interfaces/yearn/IVault.sol\";\n\ncontract Strategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // Units used in Maker contracts\n    uint256 internal constant WAD = 10**18;\n    uint256 internal constant RAY = 10**27;\n\n    // DAI token\n    IERC20 internal constant investmentToken =\n        IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n\n    // 100%\n    uint256 internal constant MAX_BPS = WAD;\n\n    // Maximum loss on withdrawal from yVault\n    uint256 internal constant MAX_LOSS_BPS = 10000;\n\n    // Wrapped Ether - Used for swaps routing\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // SushiSwap router\n    ISwap internal constant sushiswapRouter =\n        ISwap(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n\n    // Uniswap router\n    ISwap internal constant uniswapRouter =\n        ISwap(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    // Token Adapter Module for collateral\n    address public gemJoinAdapter;\n\n    // Maker Oracle Security Module\n    IOSMedianizer public wantToUSDOSMProxy;\n\n    // Use Chainlink oracle to obtain latest want/ETH price\n    AggregatorInterface public chainlinkWantToETHPriceFeed;\n\n    // Use Chainlink oracle to obtain latest want/USD price\n    AggregatorInterface public chainlinkWantToUSDPriceFeed;\n\n    // DAI yVault\n    IVault public yVault;\n\n    // Router used for swaps\n    ISwap public router;\n\n    // Collateral type\n    bytes32 public ilk;\n\n    // Our vault identifier\n    uint256 public cdpId;\n\n    // Our desired collaterization ratio\n    uint256 public collateralizationRatio;\n\n    // Allow the collateralization ratio to drift a bit in order to avoid cycles\n    uint256 public rebalanceTolerance;\n\n    // Maximum acceptable loss on withdrawal. Default to 0.01%.\n    uint256 public maxLoss;\n\n    // If set to true the strategy will never try to repay debt by selling want\n    bool public leaveDebtBehind;\n\n    // Name of the strategy\n    string internal strategyName;\n\n    // ----------------- INIT FUNCTIONS TO SUPPORT CLONING -----------------\n\n    constructor(\n        address _vault,\n        address _yVault,\n        string memory _strategyName,\n        bytes32 _ilk,\n        address _gemJoin,\n        address _wantToUSDOSMProxy,\n        address _chainlinkWantToUSDPriceFeed,\n        address _chainlinkWantToETHPriceFeed\n    ) public BaseStrategy(_vault) {\n        _initializeThis(\n            _yVault,\n            _strategyName,\n            _ilk,\n            _gemJoin,\n            _wantToUSDOSMProxy,\n            _chainlinkWantToUSDPriceFeed,\n            _chainlinkWantToETHPriceFeed\n        );\n    }\n\n    function initialize(\n        address _vault,\n        address _yVault,\n        string memory _strategyName,\n        bytes32 _ilk,\n        address _gemJoin,\n        address _wantToUSDOSMProxy,\n        address _chainlinkWantToUSDPriceFeed,\n        address _chainlinkWantToETHPriceFeed\n    ) public {\n        // Make sure we only initialize one time\n        require(address(yVault) == address(0)); // dev: strategy already initialized\n\n        address sender = msg.sender;\n\n        // Initialize BaseStrategy\n        _initialize(_vault, sender, sender, sender);\n\n        // Initialize cloned instance\n        _initializeThis(\n            _yVault,\n            _strategyName,\n            _ilk,\n            _gemJoin,\n            _wantToUSDOSMProxy,\n            _chainlinkWantToUSDPriceFeed,\n            _chainlinkWantToETHPriceFeed\n        );\n    }\n\n    function _initializeThis(\n        address _yVault,\n        string memory _strategyName,\n        bytes32 _ilk,\n        address _gemJoin,\n        address _wantToUSDOSMProxy,\n        address _chainlinkWantToUSDPriceFeed,\n        address _chainlinkWantToETHPriceFeed\n    ) internal {\n        yVault = IVault(_yVault);\n        strategyName = _strategyName;\n        ilk = _ilk;\n        gemJoinAdapter = _gemJoin;\n        wantToUSDOSMProxy = IOSMedianizer(_wantToUSDOSMProxy);\n        chainlinkWantToUSDPriceFeed = AggregatorInterface(\n            _chainlinkWantToUSDPriceFeed\n        );\n        chainlinkWantToETHPriceFeed = AggregatorInterface(\n            _chainlinkWantToETHPriceFeed\n        );\n\n        // Set default router to SushiSwap\n        router = sushiswapRouter;\n\n        // Set health check to health.ychad.eth\n        healthCheck = 0xDDCea799fF1699e98EDF118e0629A974Df7DF012;\n\n        cdpId = MakerDaiDelegateLib.openCdp(ilk);\n        require(cdpId > 0); // dev: error opening cdp\n\n        // Current ratio can drift (collateralizationRatio - rebalanceTolerance, collateralizationRatio + rebalanceTolerance)\n        // Allow additional 15% in any direction (210, 240) by default\n        rebalanceTolerance = (15 * MAX_BPS) / 100;\n\n        // Minimum collaterization ratio on YFI-A is 175%\n        // Use 225% as target\n        collateralizationRatio = (225 * MAX_BPS) / 100;\n\n        // If we lose money in yvDAI then we are not OK selling want to repay it\n        leaveDebtBehind = true;\n\n        // Define maximum acceptable loss on withdrawal to be 0.01%.\n        maxLoss = 1;\n    }\n\n    // ----------------- SETTERS & MIGRATION -----------------\n\n    // Target collateralization ratio to maintain within bounds\n    function setCollateralizationRatio(uint256 _collateralizationRatio)\n        external\n        onlyEmergencyAuthorized\n    {\n        require(\n            _collateralizationRatio.sub(rebalanceTolerance) >\n                MakerDaiDelegateLib.getLiquidationRatio(ilk).mul(MAX_BPS).div(\n                    RAY\n                )\n        ); // dev: desired collateralization ratio is too low\n        collateralizationRatio = _collateralizationRatio;\n    }\n\n    // Rebalancing bands (collat ratio - tolerance, collat_ratio + tolerance)\n    function setRebalanceTolerance(uint256 _rebalanceTolerance)\n        external\n        onlyEmergencyAuthorized\n    {\n        require(\n            collateralizationRatio.sub(_rebalanceTolerance) >\n                MakerDaiDelegateLib.getLiquidationRatio(ilk).mul(MAX_BPS).div(\n                    RAY\n                )\n        ); // dev: desired rebalance tolerance makes allowed ratio too low\n        rebalanceTolerance = _rebalanceTolerance;\n    }\n\n    // Max slippage to accept when withdrawing from yVault\n    function setMaxLoss(uint256 _maxLoss) external onlyVaultManagers {\n        require(_maxLoss <= MAX_LOSS_BPS); // dev: invalid value for max loss\n        maxLoss = _maxLoss;\n    }\n\n    // If set to true the strategy will never sell want to repay debts\n    function setLeaveDebtBehind(bool _leaveDebtBehind)\n        external\n        onlyEmergencyAuthorized\n    {\n        leaveDebtBehind = _leaveDebtBehind;\n    }\n\n    // Required to move funds to a new cdp and use a different cdpId after migration\n    // Should only be called by governance as it will move funds\n    function shiftToCdp(uint256 newCdpId) external onlyGovernance {\n        MakerDaiDelegateLib.shiftCdp(cdpId, newCdpId);\n        cdpId = newCdpId;\n    }\n\n    // Move yvDAI funds to a new yVault\n    function migrateToNewDaiYVault(IVault newYVault) external onlyGovernance {\n        uint256 balanceOfYVault = yVault.balanceOf(address(this));\n        if (balanceOfYVault > 0) {\n            yVault.withdraw(balanceOfYVault, address(this), maxLoss);\n        }\n        investmentToken.safeApprove(address(yVault), 0);\n\n        yVault = newYVault;\n        _depositInvestmentTokenInYVault();\n    }\n\n    // Allow address to manage Maker's CDP\n    function grantCdpManagingRightsToUser(address user, bool allow)\n        external\n        onlyGovernance\n    {\n        MakerDaiDelegateLib.allowManagingCdp(cdpId, user, allow);\n    }\n\n    // Allow switching between Uniswap and SushiSwap\n    function switchDex(bool isUniswap) external onlyVaultManagers {\n        if (isUniswap) {\n            router = uniswapRouter;\n        } else {\n            router = sushiswapRouter;\n        }\n    }\n\n    // ******** OVERRIDEN METHODS FROM BASE CONTRACT ************\n\n    function name() external view override returns (string memory) {\n        return strategyName;\n    }\n\n    function delegatedAssets() external view override returns (uint256) {\n        return _convertInvestmentTokenToWant(_valueOfInvestment());\n    }\n\n    function estimatedTotalAssets() public view override returns (uint256) {\n        return\n            balanceOfWant()\n                .add(balanceOfMakerVault())\n                .add(_convertInvestmentTokenToWant(balanceOfInvestmentToken()))\n                .add(_convertInvestmentTokenToWant(_valueOfInvestment()))\n                .sub(_convertInvestmentTokenToWant(balanceOfDebt()));\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\n\n        // Claim rewards from yVault\n        _takeYVaultProfit();\n\n        uint256 totalAssetsAfterProfit = estimatedTotalAssets();\n\n        _profit = totalAssetsAfterProfit > totalDebt\n            ? totalAssetsAfterProfit.sub(totalDebt)\n            : 0;\n\n        uint256 _amountFreed;\n        (_amountFreed, _loss) = liquidatePosition(\n            _debtOutstanding.add(_profit)\n        );\n        _debtPayment = Math.min(_debtOutstanding, _amountFreed);\n\n        if (_loss > _profit) {\n            // Example:\n            // debtOutstanding 100, profit 50, _amountFreed 100, _loss 50\n            // loss should be 0, (50-50)\n            // profit should endup in 0\n            _loss = _loss.sub(_profit);\n            _profit = 0;\n        } else {\n            // Example:\n            // debtOutstanding 100, profit 50, _amountFreed 140, _loss 10\n            // _profit should be 40, (50 profit - 10 loss)\n            // loss should end up in be 0\n            _profit = _profit.sub(_loss);\n            _loss = 0;\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        MakerDaiDelegateLib.keepBasicMakerHygiene(ilk);\n\n        // If we have enough want to deposit more into the maker vault, we do it\n        // Do not skip the rest of the function as it may need to repay or take on more debt\n        uint256 wantBalance = balanceOfWant();\n        if (wantBalance > _debtOutstanding) {\n            uint256 amountToDeposit = wantBalance.sub(_debtOutstanding);\n            _depositToMakerVault(amountToDeposit);\n        }\n\n        // Allow the ratio to move a bit in either direction to avoid cycles\n        uint256 currentRatio = getCurrentMakerVaultRatio();\n        if (currentRatio < collateralizationRatio.sub(rebalanceTolerance)) {\n            _repayDebt(currentRatio);\n        } else if (\n            currentRatio > collateralizationRatio.add(rebalanceTolerance)\n        ) {\n            _mintMoreInvestmentToken();\n        }\n\n        // If we have anything left to invest then deposit into the yVault\n        _depositInvestmentTokenInYVault();\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _liquidatedAmount, uint256 _loss)\n    {\n        uint256 balance = balanceOfWant();\n\n        // Check if we can handle it without freeing collateral\n        if (balance >= _amountNeeded) {\n            return (_amountNeeded, 0);\n        }\n\n        // We only need to free the amount of want not readily available\n        uint256 amountToFree = _amountNeeded.sub(balance);\n\n        uint256 price = _getWantTokenPrice();\n        uint256 collateralBalance = balanceOfMakerVault();\n\n        // We cannot free more than what we have locked\n        amountToFree = Math.min(amountToFree, collateralBalance);\n\n        uint256 totalDebt = balanceOfDebt();\n\n        // If for some reason we do not have debt, make sure the operation does not revert\n        if (totalDebt == 0) {\n            totalDebt = 1;\n        }\n\n        uint256 toFreeIT = amountToFree.mul(price).div(WAD);\n        uint256 collateralIT = collateralBalance.mul(price).div(WAD);\n        uint256 newRatio =\n            collateralIT.sub(toFreeIT).mul(MAX_BPS).div(totalDebt);\n\n        // Attempt to repay necessary debt to restore the target collateralization ratio\n        _repayDebt(newRatio);\n\n        // Unlock as much collateral as possible while keeping the target ratio\n        amountToFree = Math.min(amountToFree, _maxWithdrawal());\n        _freeCollateralAndRepayDai(amountToFree, 0);\n\n        // If we still need more want to repay, we may need to unlock some collateral to sell\n        if (\n            !leaveDebtBehind &&\n            balanceOfWant() < _amountNeeded &&\n            balanceOfDebt() > 0\n        ) {\n            _sellCollateralToRepayRemainingDebtIfNeeded();\n        }\n\n        uint256 looseWant = balanceOfWant();\n        if (_amountNeeded > looseWant) {\n            _liquidatedAmount = looseWant;\n            _loss = _amountNeeded.sub(looseWant);\n        } else {\n            _liquidatedAmount = _amountNeeded;\n            _loss = 0;\n        }\n    }\n\n    function liquidateAllPositions()\n        internal\n        override\n        returns (uint256 _amountFreed)\n    {\n        (_amountFreed, ) = liquidatePosition(estimatedTotalAssets());\n    }\n\n    function tendTrigger(uint256 callCostInWei)\n        public\n        view\n        override\n        returns (bool)\n    {\n        // Nothing to adjust if there is no collateral locked\n        if (balanceOfMakerVault() == 0) {\n            return false;\n        }\n\n        uint256 currentRatio = getCurrentMakerVaultRatio();\n\n        // If we need to repay debt and are outside the tolerance bands,\n        // we do it regardless of the call cost\n        if (currentRatio < collateralizationRatio.sub(rebalanceTolerance)) {\n            return true;\n        }\n\n        // If we could mint more DAI, check that there is DAI available to mint\n        // Otherwise do not adjust the position\n        return\n            (currentRatio > collateralizationRatio.add(rebalanceTolerance)) &&\n            MakerDaiDelegateLib.isDaiAvailableToMint(ilk);\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        // Transfer Maker Vault ownership to the new startegy\n        MakerDaiDelegateLib.transferCdp(cdpId, _newStrategy);\n\n        // Move yvDAI balance to the new strategy\n        IERC20(yVault).safeTransfer(\n            _newStrategy,\n            yVault.balanceOf(address(this))\n        );\n    }\n\n    function protectedTokens()\n        internal\n        view\n        override\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](2);\n        protected[0] = address(investmentToken);\n        protected[1] = address(yVault);\n        return protected;\n    }\n\n    function ethToWant(uint256 _amtInWei)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        if (address(want) == address(WETH)) {\n            return _amtInWei;\n        }\n\n        uint256 price = uint256(chainlinkWantToETHPriceFeed.latestAnswer());\n        return _amtInWei.mul(WAD).div(price);\n    }\n\n    // ----------------- INTERNAL FUNCTIONS SUPPORT -----------------\n\n    function _repayDebt(uint256 currentRatio) internal {\n        uint256 currentDebt = balanceOfDebt();\n\n        // Nothing to repay if we are over the collateralization ratio\n        // or there is no debt\n        if (currentRatio > collateralizationRatio || currentDebt == 0) {\n            return;\n        }\n\n        // ratio = collateral / debt\n        // collateral = current_ratio * current_debt\n        // collateral amount is invariant here so we want to find new_debt\n        // so that new_debt * desired_ratio = current_debt * current_ratio\n        // new_debt = current_debt * current_ratio / desired_ratio\n        // and the amount to repay is the difference between current_debt and new_debt\n        uint256 newDebt =\n            currentDebt.mul(currentRatio).div(collateralizationRatio);\n\n        uint256 amountToRepay;\n\n        // Maker will revert if the outstanding debt is less than a debt floor\n        // called 'dust'. If we are there we need to either pay the debt in full\n        // or leave at least 'dust' balance (10,000 DAI for YFI-A)\n        uint256 debtFloor = MakerDaiDelegateLib.debtFloor(ilk);\n        if (newDebt <= debtFloor) {\n            // If we sold want to repay debt we will have DAI readily available in the strategy\n            // This means we need to count both yvDAI shares and current DAI balance\n            uint256 totalInvestmentAvailableToRepay =\n                _valueOfInvestment().add(balanceOfInvestmentToken());\n\n            if (totalInvestmentAvailableToRepay >= currentDebt) {\n                // Pay the entire debt if we have enough investment token\n                amountToRepay = currentDebt;\n            } else {\n                // Pay just 0.1 cent above debtFloor (best effort without liquidating want)\n                amountToRepay = currentDebt.sub(debtFloor).sub(1e15);\n            }\n        } else {\n            // If we are not near the debt floor then just pay the exact amount\n            // needed to obtain a healthy collateralization ratio\n            amountToRepay = currentDebt.sub(newDebt);\n        }\n\n        uint256 balanceIT = balanceOfInvestmentToken();\n        if (amountToRepay > balanceIT) {\n            _withdrawFromYVault(amountToRepay.sub(balanceIT));\n        }\n        _repayInvestmentTokenDebt(amountToRepay);\n    }\n\n    function _sellCollateralToRepayRemainingDebtIfNeeded() internal {\n        uint256 currentInvestmentValue = _valueOfInvestment();\n\n        uint256 investmentLeftToAcquire =\n            balanceOfDebt().sub(currentInvestmentValue);\n\n        uint256 investmentLeftToAcquireInWant =\n            _convertInvestmentTokenToWant(investmentLeftToAcquire);\n\n        if (investmentLeftToAcquireInWant <= balanceOfWant()) {\n            _buyInvestmentTokenWithWant(investmentLeftToAcquire);\n            _repayDebt(0);\n            _freeCollateralAndRepayDai(balanceOfMakerVault(), 0);\n        }\n    }\n\n    // Mint the maximum DAI possible for the locked collateral\n    function _mintMoreInvestmentToken() internal {\n        uint256 price = _getWantTokenPrice();\n        uint256 amount = balanceOfMakerVault();\n\n        uint256 daiToMint =\n            amount.mul(price).mul(MAX_BPS).div(collateralizationRatio).div(WAD);\n        daiToMint = daiToMint.sub(balanceOfDebt());\n        _lockCollateralAndMintDai(0, daiToMint);\n    }\n\n    function _withdrawFromYVault(uint256 _amountIT) internal returns (uint256) {\n        if (_amountIT == 0) {\n            return 0;\n        }\n        // No need to check allowance because the contract == token\n        uint256 balancePrior = balanceOfInvestmentToken();\n        uint256 sharesToWithdraw =\n            Math.min(\n                _investmentTokenToYShares(_amountIT),\n                yVault.balanceOf(address(this))\n            );\n        if (sharesToWithdraw == 0) {\n            return 0;\n        }\n        yVault.withdraw(sharesToWithdraw, address(this), maxLoss);\n        return balanceOfInvestmentToken().sub(balancePrior);\n    }\n\n    function _depositInvestmentTokenInYVault() internal {\n        uint256 balanceIT = balanceOfInvestmentToken();\n        if (balanceIT > 0) {\n            _checkAllowance(\n                address(yVault),\n                address(investmentToken),\n                balanceIT\n            );\n\n            yVault.deposit();\n        }\n    }\n\n    function _repayInvestmentTokenDebt(uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        uint256 debt = balanceOfDebt();\n        uint256 balanceIT = balanceOfInvestmentToken();\n\n        // We cannot pay more than loose balance\n        amount = Math.min(amount, balanceIT);\n\n        // We cannot pay more than we owe\n        amount = Math.min(amount, debt);\n\n        _checkAllowance(\n            MakerDaiDelegateLib.daiJoinAddress(),\n            address(investmentToken),\n            amount\n        );\n\n        if (amount > 0) {\n            // When repaying the full debt it is very common to experience Vat/dust\n            // reverts due to the debt being non-zero and less than the debt floor.\n            // This can happen due to rounding when _wipeAndFreeGem() divides\n            // the DAI amount by the accumulated stability fee rate.\n            // To circumvent this issue we will add 1 Wei to the amount to be paid\n            // if there is enough investment token balance (DAI) to do it.\n            if (debt.sub(amount) == 0 && balanceIT.sub(amount) >= 1) {\n                amount = amount.add(1);\n            }\n\n            // Repay debt amount without unlocking collateral\n            _freeCollateralAndRepayDai(0, amount);\n        }\n    }\n\n    function _checkAllowance(\n        address _contract,\n        address _token,\n        uint256 _amount\n    ) internal {\n        if (IERC20(_token).allowance(address(this), _contract) < _amount) {\n            IERC20(_token).safeApprove(_contract, 0);\n            IERC20(_token).safeApprove(_contract, type(uint256).max);\n        }\n    }\n\n    function _takeYVaultProfit() internal {\n        uint256 _debt = balanceOfDebt();\n        uint256 _valueInVault = _valueOfInvestment();\n        if (_debt >= _valueInVault) {\n            return;\n        }\n\n        uint256 profit = _valueInVault.sub(_debt);\n        uint256 ySharesToWithdraw = _investmentTokenToYShares(profit);\n        if (ySharesToWithdraw > 0) {\n            yVault.withdraw(ySharesToWithdraw, address(this), maxLoss);\n            _sellAForB(\n                balanceOfInvestmentToken(),\n                address(investmentToken),\n                address(want)\n            );\n        }\n    }\n\n    function _depositToMakerVault(uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        _checkAllowance(gemJoinAdapter, address(want), amount);\n\n        uint256 price = _getWantTokenPrice();\n        uint256 daiToMint =\n            amount.mul(price).mul(MAX_BPS).div(collateralizationRatio).div(WAD);\n\n        _lockCollateralAndMintDai(amount, daiToMint);\n    }\n\n    // Returns maximum collateral to withdraw while maintaining the target collateralization ratio\n    function _maxWithdrawal() internal view returns (uint256) {\n        // Denominated in want\n        uint256 totalCollateral = balanceOfMakerVault();\n\n        // Denominated in investment token\n        uint256 totalDebt = balanceOfDebt();\n\n        // If there is no debt to repay we can withdraw all the locked collateral\n        if (totalDebt == 0) {\n            return totalCollateral;\n        }\n\n        uint256 price = _getWantTokenPrice();\n\n        // Min collateral in want that needs to be locked with the outstanding debt\n        // Allow going to the lower rebalancing band\n        uint256 minCollateral =\n            collateralizationRatio\n                .sub(rebalanceTolerance)\n                .mul(totalDebt)\n                .mul(WAD)\n                .div(price)\n                .div(MAX_BPS);\n\n        // If we are under collateralized then it is not safe for us to withdraw anything\n        if (minCollateral > totalCollateral) {\n            return 0;\n        }\n\n        return totalCollateral.sub(minCollateral);\n    }\n\n    // ----------------- PUBLIC BALANCES -----------------\n\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfInvestmentToken() public view returns (uint256) {\n        return investmentToken.balanceOf(address(this));\n    }\n\n    function balanceOfDebt() public view returns (uint256) {\n        return MakerDaiDelegateLib.debtForCdp(cdpId, ilk);\n    }\n\n    // Returns collateral balance in the vault\n    function balanceOfMakerVault() public view returns (uint256) {\n        return MakerDaiDelegateLib.balanceOfCdp(cdpId, ilk);\n    }\n\n    // Effective collateralization ratio of the vault\n    function getCurrentMakerVaultRatio() public view returns (uint256) {\n        return\n            MakerDaiDelegateLib.getPessimisticRatioOfCdpWithExternalPrice(\n                cdpId,\n                ilk,\n                _getWantTokenPrice(),\n                MAX_BPS\n            );\n    }\n\n    // ----------------- INTERNAL CALCS -----------------\n\n    function _getWantTokenPrice() internal view returns (uint256) {\n        uint256 minPrice;\n\n        // Assume we are white-listed in the OSM\n        (uint256 current, ) = wantToUSDOSMProxy.read();\n        (uint256 future, ) = wantToUSDOSMProxy.foresight();\n\n        minPrice = Math.min(future, current);\n\n        // Non-ETH pairs have 8 decimals, so we need to adjust it to 18\n        uint256 chainLinkPrice =\n            uint256(chainlinkWantToUSDPriceFeed.latestAnswer()).mul(1e10);\n\n        // Return the worst price available in [wad]\n        // par is crucial to this calculation as it defines the relationship between DAI and\n        // 1 unit of value in the price\n        minPrice = Math.min(minPrice, chainLinkPrice).mul(RAY).div(\n            MakerDaiDelegateLib.getDaiPar()\n        );\n\n        // If peek() or peep() return a price of 0 or an error then we are\n        // dealing with an invalid price or Maker Protocol Emergency Shutdown\n        require(minPrice > 0); // dev: invalid price returned from oracle\n        return minPrice;\n    }\n\n    function _valueOfInvestment() internal view returns (uint256) {\n        return\n            yVault.balanceOf(address(this)).mul(yVault.pricePerShare()).div(\n                10**yVault.decimals()\n            );\n    }\n\n    function _investmentTokenToYShares(uint256 amount)\n        internal\n        view\n        returns (uint256)\n    {\n        return amount.mul(10**yVault.decimals()).div(yVault.pricePerShare());\n    }\n\n    function _lockCollateralAndMintDai(\n        uint256 collateralAmount,\n        uint256 daiToMint\n    ) internal {\n        MakerDaiDelegateLib.lockGemAndDraw(\n            gemJoinAdapter,\n            cdpId,\n            collateralAmount,\n            daiToMint,\n            balanceOfDebt()\n        );\n    }\n\n    function _freeCollateralAndRepayDai(\n        uint256 collateralAmount,\n        uint256 daiToRepay\n    ) internal {\n        MakerDaiDelegateLib.wipeAndFreeGem(\n            gemJoinAdapter,\n            cdpId,\n            collateralAmount,\n            daiToRepay\n        );\n    }\n\n    // ----------------- TOKEN CONVERSIONS -----------------\n\n    function _convertInvestmentTokenToWant(uint256 amount)\n        internal\n        view\n        returns (uint256)\n    {\n        return amount.mul(WAD).div(_getWantTokenPrice());\n    }\n\n    function _getTokenOutPath(address _token_in, address _token_out)\n        internal\n        pure\n        returns (address[] memory _path)\n    {\n        bool is_weth =\n            _token_in == address(WETH) || _token_out == address(WETH);\n        _path = new address[](is_weth ? 2 : 3);\n        _path[0] = _token_in;\n\n        if (is_weth) {\n            _path[1] = _token_out;\n        } else {\n            _path[1] = address(WETH);\n            _path[2] = _token_out;\n        }\n    }\n\n    function _sellAForB(\n        uint256 _amount,\n        address tokenA,\n        address tokenB\n    ) internal {\n        if (_amount == 0 || tokenA == tokenB) {\n            return;\n        }\n\n        _checkAllowance(address(router), tokenA, _amount);\n        router.swapExactTokensForTokens(\n            _amount,\n            0,\n            _getTokenOutPath(tokenA, tokenB),\n            address(this),\n            now\n        );\n    }\n\n    function _buyInvestmentTokenWithWant(uint256 _amount) internal {\n        if (_amount == 0 || address(investmentToken) == address(want)) {\n            return;\n        }\n\n        _checkAllowance(address(router), address(want), _amount);\n        router.swapTokensForExactTokens(\n            _amount,\n            type(uint256).max,\n            _getTokenOutPath(address(want), address(investmentToken)),\n            address(this),\n            now\n        );\n    }\n}"
    }
  ]
}