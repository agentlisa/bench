{
  "Title": "M-4: Griefing attack is possible via TrueFi borrowing",
  "Content": "# Issue M-4: Griefing attack is possible via TrueFi borrowing \n\nSource: https://github.com/sherlock-audit/2022-09-sherlock-judging/tree/main/017-M \n\n## Found by \nhyh\n\n## Summary\n\nAs TrueFiStrategy net asset value reported with _balanceOf() depends on the TrueFi liquidity situation, which can be modified by any user eligible for TrueFi loans, a griefing attack of borrowing right ahead of Sherlock requesting NAV figure from the strategy is possible.\n\n## Vulnerability Detail\n\nOn observing a Sherlock's redeemNFT() or arbRestake() from Bob the target user, Alice the attacker will front run his transaction with borrow() call, reducing the amount of liquid funds a TrueFiPool2 has, immediately repaying her debt right afterwards. I.e. Alice will become a short term debtor for sandwiching Bob's redeemNFT(). Alice needs to be whitelisted as a borrower, which is achievable, and her status will not be affected by this attack and examined alone her actions are legitimate, i.e. she only takes are repays short-term loan, which is valid usage of TrueFi.\n\nAs loan term is small the overall cost of the attack (that consists of the loan interest along with gas costs for borrow and repay transactions) isn't substantial for Alice, while Bob can incur big enough slippage as TrueFiStrategy's _balanceOf() will observe low `liquidValue()` and thus high `liquidExitPenalty(totalAmount)` of the TrueFiPool2, diminishing the value of the Bob's withdrawal. Alice can repeat this many times over with various Sherlock users.\n\n## Impact\n\nSherlock stakers who unstaked will incur higher fees proportionally to the current TrueFi liquidity situation and the budget Alice have for the attack (with increased budget she can do it more frequently and take bigger loans, moving liquidity more substantially).\n\n## Code Snippet\n\nThere are two agencies that can be used for borrowing, FixedTermLoanAgency and LineOfCreditAgency, and Alice needs to become an allowed borrower in either of them:\n\nFixedTermLoanAgency:\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/FixedTermLoanAgency.sol#L288-L291\n\n```solidity\n    function allowBorrower(address who) external onlyOwner {\n        isBorrowerAllowed[who] = true;\n        emit BorrowerAllowed(who);\n    }\n```\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/FixedTermLoanAgency.sol#L327-L351\n\n```solidity\n    function borrow(\n        ITrueFiPool2 pool,\n        uint256 amount,\n        uint256 term,\n        uint256 _maxApy\n    ) external onlyAllowedBorrowers {\n        require(poolFactory.isSupportedPool(pool), \"FixedTermLoanAgency: Pool not supported by the factory\");\n        require(poolLoans[pool].length < maxLoans, \"FixedTermLoanAgency: Loans number has reached the limit\");\n\n        address borrower = msg.sender;\n        require(borrowingMutex.isUnlocked(borrower), \"FixedTermLoanAgency: There is an ongoing loan or credit line\");\n        require(\n            creditOracle.status(borrower) == ITrueFiCreditOracle.Status.Eligible,\n            \"FixedTermLoanAgency: Sender is not eligible for loan\"\n        );\n\n        require(amount > 0, \"FixedTermLoanAgency: Loans of amount 0, will not be approved\");\n        require(\n            pool.oracle().tokenToUsd(amount) <= borrowLimit(pool, borrower),\n            \"FixedTermLoanAgency: Loan amount cannot exceed borrow limit\"\n        );\n\n        require(term > 0, \"FixedTermLoanAgency: Loans cannot have instantaneous term of repay\");\n        require(isTermBelowMax(term), \"FixedTermLoanAgency: Loan's term is too long\");\n        require(isCredibleForTerm(term), \"FixedTermLoanAgency: Credit score is too low for loan's term\");\n```\n\nLineOfCreditAgency:\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/LineOfCreditAgency.sol#L236-L240\n\n```solidity\n    /// @dev set borrower `who` to whitelist status `isAllowed`\n    function allowBorrower(address who, bool isAllowed) external onlyOwner {\n        isBorrowerAllowed[who] = isAllowed;\n        emit BorrowerAllowed(who, isAllowed);\n    }\n```\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/LineOfCreditAgency.sol#L380-L395\n\n```solidity\n    /**\n     * @dev Borrow from `pool` for `amount` using lines of credit\n     * Only whitelisted borrowers that meet all requirements can borrow\n     * @param pool Pool to borrow from\n     * @param amount Amount of tokens to borrow\n     */\n    function borrow(ITrueFiPool2 pool, uint256 amount) external onlyAllowedBorrowers {\n        require(poolFactory.isSupportedPool(pool), \"LineOfCreditAgency: The pool is not supported for borrowing\");\n        require(amount > 0, \"LineOfCreditAgency: Borrowed amount has to be greater than 0\");\n        require(\n            creditOracle.status(msg.sender) == ITrueFiCreditOracle.Status.Eligible,\n            \"LineOfCreditAgency: Sender not eligible to borrow\"\n        );\n        require(!_hasOverdueInterest(pool, msg.sender), \"LineOfCreditAgency: Sender has overdue interest in this pool\");\n        uint8 rawScore = creditOracle.score(msg.sender);\n        require(rawScore >= minCreditScore, \"LineOfCreditAgency: Borrower has credit score below minimum\");\n```\n\nHowever, this is one time requirement and the attack itself doesn't look malicious, i.e. Alice uses ultra short term borrowing in a flash loan manner, paying the interest, there is no violation in Truefi2 use cases, so becoming an allowed borrower once Alice can perform the attack many times over an extended period of time.\n\nAs Alice will seek the easiest path, the FixedTermLoanAgency that doesn't require credit scores for short term borrowing looks the most suitable:\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/FixedTermLoanAgency.sol#L525-L527\n\n```solidity\n    function isCredibleForTerm(uint256 term) internal view returns (bool) {\n        return term <= longTermLoanThreshold || creditOracle.score(msg.sender) >= longTermLoanScoreThreshold;\n    }\n```\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/FixedTermLoanAgency.sol#L206\n\n```solidity\n        longTermLoanThreshold = 90 days;\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAs this is design specifics only partial remediation looks viable. As an example, some delay can be introduced in the TrueFi between loan request and funds transfer. It will not impact valid use cases, but close this attack surface.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/5",
  "Code": [
    {
      "filename": "contracts/truefi2/FixedTermLoanAgency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {ERC20} from \"../common/UpgradeableERC20.sol\";\nimport {UpgradeableClaimable} from \"../common/UpgradeableClaimable.sol\";\nimport {OneInchExchange} from \"./libraries/OneInchExchange.sol\";\n\nimport {IFixedTermLoan} from \"./interface/IFixedTermLoan.sol\";\nimport {ILoanFactory2} from \"./interface/ILoanFactory2.sol\";\nimport {IStakingPool} from \"../truefi/interface/IStakingPool.sol\";\nimport {IFixedTermLoanAgency} from \"./interface/IFixedTermLoanAgency.sol\";\nimport {ITrueFiPool2} from \"./interface/ITrueFiPool2.sol\";\nimport {I1Inch3} from \"./interface/I1Inch3.sol\";\nimport {IPoolFactory} from \"./interface/IPoolFactory.sol\";\nimport {IERC20WithDecimals} from \"./interface/IERC20WithDecimals.sol\";\nimport {ITrueFiCreditOracle} from \"./interface/ITrueFiCreditOracle.sol\";\nimport {IRateModel} from \"./interface/IRateModel.sol\";\nimport {IBorrowingMutex} from \"./interface/IBorrowingMutex.sol\";\nimport {IStakingVault} from \"./interface/IStakingVault.sol\";\n\ninterface ITrueFiPool2WithDecimals is ITrueFiPool2 {\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @title FixedTermLoanAgency\n * @dev Loans management helper\n * This contract is a bridge that helps to transfer funds from pool to the loans and back\n * FixedTermLoanAgency holds all LoanTokens\n */\ncontract FixedTermLoanAgency is IFixedTermLoanAgency, UpgradeableClaimable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IERC20WithDecimals;\n    using SafeERC20 for ITrueFiPool2;\n    using OneInchExchange for I1Inch3;\n\n    // basis point for ratio\n    uint256 private constant BASIS_RATIO = 10000;\n\n    uint256 private constant ONE_INCH_PARTIAL_FILL_FLAG = 0x01;\n\n    // ================ WARNING ==================\n    // ===== THIS CONTRACT IS INITIALIZABLE ======\n    // === STORAGE VARIABLES ARE DECLARED BELOW ==\n    // REMOVAL OR REORDER OF VARIABLES WILL RESULT\n    // ========= IN STORAGE CORRUPTION ===========\n\n    mapping(ITrueFiPool2 => IFixedTermLoan[]) public poolLoans;\n\n    // maximum amount of loans agency can handle at once\n    uint256 public maxLoans;\n\n    // which part of interest should be paid to the stakers\n    uint256 public fee;\n\n    IStakingPool public stakingPool;\n\n    IPoolFactory public poolFactory;\n\n    I1Inch3 public _1inch;\n\n    // Loan fees should be swapped for this token, deposited into the feePool\n    // and pool's LP tokens should be sent to the stakers\n    IERC20WithDecimals public feeToken;\n    ITrueFiPool2 public feePool;\n\n    // Minimal possible fee swap slippage\n    // basis precision: 10000 = 100%\n    uint256 public swapFeeSlippage;\n\n    ITrueFiCreditOracle public creditOracle;\n\n    uint256 public maxLoanTerm;\n\n    uint256 public longTermLoanThreshold;\n\n    uint8 public longTermLoanScoreThreshold;\n\n    IRateModel public rateModel;\n\n    // mutex ensuring there's only one running loan or credit line for borrower\n    IBorrowingMutex public borrowingMutex;\n\n    ILoanFactory2 public loanFactory;\n\n    mapping(address => bool) public isBorrowerAllowed;\n\n    IStakingVault public stakingVault;\n\n    // ======= STORAGE DECLARATION END ============\n\n    /**\n     * @dev Emitted when loans limit is changed\n     * @param maxLoans new maximum amount of loans\n     */\n    event LoansLimitChanged(uint256 maxLoans);\n\n    /**\n     * @dev Emitted when max loan term changed\n     * @param maxLoanTerm New max loan term\n     */\n    event MaxLoanTermChanged(uint256 maxLoanTerm);\n\n    /**\n     * @dev Emitted when long term loan's minimal term changed\n     * @param longTermLoanThreshold New long term loan minimal term\n     */\n    event LongTermLoanThresholdChanged(uint256 longTermLoanThreshold);\n\n    /**\n     * @dev Emitted when minimal credit score threshold for long term loan changed\n     * @param longTermLoanScoreThreshold New minimal credit score threshold for long term loan\n     */\n    event LongTermLoanScoreThresholdChanged(uint256 longTermLoanScoreThreshold);\n\n    /**\n     * @dev Emitted when loan fee is changed\n     * @param newFee New fee value in basis points\n     */\n    event FeeChanged(uint256 newFee);\n\n    /**\n     * @dev Emitted when fee pool is changed\n     * @param newFeePool New fee pool address\n     */\n    event FeePoolChanged(ITrueFiPool2 newFeePool);\n\n    /**\n     * @dev Emitted when credit oracle is changed\n     * @param newCreditOracle New credit oracle address\n     */\n    event CreditOracleChanged(ITrueFiCreditOracle newCreditOracle);\n\n    /**\n     * @dev Emitted when a loan is funded\n     * @param loanToken LoanToken contract which was funded\n     * @param amount Amount funded\n     */\n    event Funded(address indexed pool, address loanToken, uint256 amount);\n\n    /**\n     * @dev Emitted when funds are reclaimed from the LoanToken contract\n     * @param loanToken LoanToken from which funds were reclaimed\n     * @param amount Amount repaid\n     */\n    event Reclaimed(address indexed pool, address loanToken, uint256 amount);\n\n    /**\n     * @dev Emitted when borrowingMutex address is changed\n     * @param borrowingMutex new borrowingMutex address\n     */\n    event BorrowingMutexChanged(IBorrowingMutex borrowingMutex);\n\n    event BorrowerAllowed(address indexed who);\n    event BorrowerBlocked(address indexed who);\n\n    /**\n     * @dev Can be only called by a pool\n     */\n    modifier onlySupportedPool() {\n        require(poolFactory.isSupportedPool(ITrueFiPool2(msg.sender)), \"FixedTermLoanAgency: Pool not supported by the factory\");\n        _;\n    }\n\n    modifier onlyAllowedBorrowers() {\n        require(isBorrowerAllowed[msg.sender], \"FixedTermLoanAgency: Sender is not allowed to borrow\");\n        _;\n    }\n\n    /**\n     * @dev Initialize the contract with parameters\n     * @param _stakingPool stkTRU address\n     * @param _poolFactory PoolFactory address\n     * @param __1inch 1Inch exchange address (0x11111112542d85b3ef69ae05771c2dccff4faa26 for mainnet)\n     */\n    function initialize(\n        IStakingPool _stakingPool,\n        IPoolFactory _poolFactory,\n        I1Inch3 __1inch,\n        ITrueFiCreditOracle _creditOracle,\n        IRateModel _rateModel,\n        IBorrowingMutex _borrowingMutex,\n        ILoanFactory2 _loanFactory,\n        IStakingVault _stakingVault\n    ) public initializer {\n        UpgradeableClaimable.initialize(msg.sender);\n\n        stakingPool = _stakingPool;\n        poolFactory = _poolFactory;\n        _1inch = __1inch;\n        creditOracle = _creditOracle;\n        rateModel = _rateModel;\n        borrowingMutex = _borrowingMutex;\n        loanFactory = _loanFactory;\n        stakingVault = _stakingVault;\n\n        swapFeeSlippage = 100; // 1%\n        fee = 1000;\n        maxLoans = 100;\n        maxLoanTerm = 180 days;\n        longTermLoanThreshold = 90 days;\n        longTermLoanScoreThreshold = 200;\n    }\n\n    /**\n     * @dev Set new credit oracle address.\n     * Only owner can change credit oracle\n     * @param _creditOracle new credit oracle\n     */\n    function setCreditOracle(ITrueFiCreditOracle _creditOracle) external onlyOwner {\n        require(address(_creditOracle) != address(0), \"FixedTermLoanAgency: CreditOracle cannot be set to zero address\");\n        creditOracle = _creditOracle;\n        emit CreditOracleChanged(_creditOracle);\n    }\n\n    /**\n     * @dev set borrowingMutex\n     * @param newMutex borrowing mutex address to be set\n     */\n    function setBorrowingMutex(IBorrowingMutex newMutex) public onlyOwner {\n        require(address(newMutex) != address(0), \"FixedTermLoanAgency: BorrowingMutex cannot be set to zero address\");\n        borrowingMutex = newMutex;\n        emit BorrowingMutexChanged(newMutex);\n    }\n\n    /**\n     * @dev Set max loan term. Only owner can change parameters.\n     * @param _maxLoanTerm New maxLoanTerm\n     */\n    function setMaxLoanTerm(uint256 _maxLoanTerm) external onlyOwner {\n        maxLoanTerm = _maxLoanTerm;\n        emit MaxLoanTermChanged(_maxLoanTerm);\n    }\n\n    /**\n     * @dev Set minimal term of a long term loan. Only owner can change parameters.\n     * @param _longTermLoanThreshold New longTermLoanThreshold\n     */\n    function setLongTermLoanThreshold(uint256 _longTermLoanThreshold) external onlyOwner {\n        longTermLoanThreshold = _longTermLoanThreshold;\n        emit LongTermLoanThresholdChanged(_longTermLoanThreshold);\n    }\n\n    /**\n     * @dev Set long term loan credit score threshold. Only owner can change parameters.\n     * @param _longTermLoanScoreThreshold New longTermLoanScoreThreshold\n     */\n    function setLongTermLoanScoreThreshold(uint8 _longTermLoanScoreThreshold) external onlyOwner {\n        longTermLoanScoreThreshold = _longTermLoanScoreThreshold;\n        emit LongTermLoanScoreThresholdChanged(_longTermLoanScoreThreshold);\n    }\n\n    /**\n     * @dev Set new loans limit. Only owner can change parameters.\n     * @param newLoansLimit New loans limit\n     */\n    function setLoansLimit(uint256 newLoansLimit) external onlyOwner {\n        maxLoans = newLoansLimit;\n        emit LoansLimitChanged(maxLoans);\n    }\n\n    /**\n     * @dev Set new fee pool and fee token.\n     * Only owner can change parameters\n     * @param newFeePool new pool address\n     */\n    function setFeePool(ITrueFiPool2 newFeePool) external onlyOwner {\n        feeToken = IERC20WithDecimals(address(newFeePool.token()));\n        feePool = newFeePool;\n        emit FeePoolChanged(newFeePool);\n    }\n\n    /**\n     * @dev Set loan interest fee that goes to the stakers.\n     * @param newFee New loans limit\n     */\n    function setFee(uint256 newFee) external onlyOwner {\n        require(newFee <= BASIS_RATIO, \"FixedTermLoanAgency: fee cannot be more than 100%\");\n        fee = newFee;\n        emit FeeChanged(newFee);\n    }\n\n    function allowBorrower(address who) external onlyOwner {\n        isBorrowerAllowed[who] = true;\n        emit BorrowerAllowed(who);\n    }\n\n    function blockBorrower(address who) external onlyOwner {\n        isBorrowerAllowed[who] = false;\n        emit BorrowerBlocked(who);\n    }\n\n    /**\n     * @dev Get currently funded loans for a pool\n     * @param pool pool address\n     * @return result Array of loans currently funded\n     */\n    function loans(ITrueFiPool2 pool) public view returns (IFixedTermLoan[] memory result) {\n        result = poolLoans[pool];\n    }\n\n    function rate(\n        ITrueFiPool2 pool,\n        address borrower,\n        uint256 amount,\n        uint256 term\n    ) public view returns (uint256) {\n        uint8 rawScore = creditOracle.score(borrower);\n        uint256 stakedAmount = stakingVault.stakedAmount(borrower);\n        uint8 effectiveScore = rateModel.effectiveScore(pool, rawScore, stakedAmount, amount);\n        uint256 fixedTermLoanAdjustment = rateModel.fixedTermLoanAdjustment(term);\n        return rateModel.rate(pool, effectiveScore, amount).add(fixedTermLoanAdjustment);\n    }\n\n    /**\n     * @dev Create and fund a loan via LoanFactory for a pool supported by PoolFactory\n     * Method should be called by the loan borrower\n     *\n     * When called, agency takes funds from the pool, gives it to the loan and holds all LoanTokens\n     * Origination fee is transferred to the stake\n     */\n    function borrow(\n        ITrueFiPool2 pool,\n        uint256 amount,\n        uint256 term,\n        uint256 _maxApy\n    ) external onlyAllowedBorrowers {\n        require(poolFactory.isSupportedPool(pool), \"FixedTermLoanAgency: Pool not supported by the factory\");\n        require(poolLoans[pool].length < maxLoans, \"FixedTermLoanAgency: Loans number has reached the limit\");\n\n        address borrower = msg.sender;\n        require(borrowingMutex.isUnlocked(borrower), \"FixedTermLoanAgency: There is an ongoing loan or credit line\");\n        require(\n            creditOracle.status(borrower) == ITrueFiCreditOracle.Status.Eligible,\n            \"FixedTermLoanAgency: Sender is not eligible for loan\"\n        );\n\n        require(amount > 0, \"FixedTermLoanAgency: Loans of amount 0, will not be approved\");\n        require(\n            pool.oracle().tokenToUsd(amount) <= borrowLimit(pool, borrower),\n            \"FixedTermLoanAgency: Loan amount cannot exceed borrow limit\"\n        );\n\n        require(term > 0, \"FixedTermLoanAgency: Loans cannot have instantaneous term of repay\");\n        require(isTermBelowMax(term), \"FixedTermLoanAgency: Loan's term is too long\");\n        require(isCredibleForTerm(term), \"FixedTermLoanAgency: Credit score is too low for loan's term\");\n\n        uint256 apy = rate(pool, borrower, amount, term);\n        require(apy <= _maxApy, \"FixedTermLoanAgency: Calculated apy is higher than max apy\");\n\n        IFixedTermLoan loanToken = loanFactory.createLoanToken(pool, borrower, amount, term, apy);\n        borrowingMutex.lock(borrower, address(loanToken));\n        poolLoans[pool].push(loanToken);\n        pool.borrow(amount);\n        pool.token().safeTransfer(borrower, amount);\n\n        emit Funded(address(pool), address(loanToken), amount);\n    }\n\n    /**\n     * @dev Loop through loan tokens for the pool and calculate theoretical value of all loans\n     * There should never be too many loans in the pool to run out of gas\n     * @param pool pool address\n     * @return Theoretical value of all the loans funded by this strategy\n     */\n    function value(ITrueFiPool2 pool) external view override returns (uint256) {\n        IFixedTermLoan[] memory _loans = poolLoans[pool];\n        uint256 totalValue;\n        for (uint256 index = 0; index < _loans.length; index++) {\n            totalValue = totalValue.add(_loans[index].currentValue(address(this)));\n        }\n        return totalValue;\n    }\n\n    /**\n     * @dev For settled loans, redeem LoanTokens for underlying funds\n     * @param loanToken Loan to reclaim capital from (must be previously funded)\n     */\n    function reclaim(IFixedTermLoan loanToken, bytes calldata data) external {\n        IFixedTermLoan.Status status = loanToken.status();\n        require(\n            status == IFixedTermLoan.Status.Settled || status == IFixedTermLoan.Status.Defaulted,\n            \"FixedTermLoanAgency: LoanToken is not closed yet\"\n        );\n        if (status == IFixedTermLoan.Status.Defaulted) {\n            require(msg.sender == owner(), \"FixedTermLoanAgency: Only owner can reclaim from defaulted loan\");\n        }\n\n        // find the token, repay loan and remove loan from loan array\n        ITrueFiPool2 pool = loanToken.pool();\n        IFixedTermLoan[] storage _loans = poolLoans[pool];\n        uint256 loansLength = _loans.length;\n        for (uint256 index = 0; index < loansLength; index++) {\n            if (_loans[index] == loanToken) {\n                _loans[index] = _loans[loansLength - 1];\n                _loans.pop();\n\n                uint256 fundsReclaimed = _redeemAndRepay(loanToken, pool, data);\n                emit Reclaimed(address(pool), address(loanToken), fundsReclaimed);\n                return;\n            }\n        }\n        // If we reach this, it means loanToken was not present in _loans array\n        // This prevents invalid loans from being reclaimed\n        revert(\"FixedTermLoanAgency: This loan has not been funded by the agency\");\n    }\n\n    /**\n     * @dev Get total amount borrowed for `borrower` from fixed term loans in USD\n     * Total borrowed amount would be 0 if no Fixed Term Loan is taken by the borrower at the moment\n     * And total loan amount + interest otherwise.\n     * @param borrower Borrower to get amount borrowed for\n     * @param decimals Precision to use when calculating total borrowed\n     * @return Total amount borrowed for `borrower` in USD\n     */\n    function totalBorrowed(address borrower, uint8 decimals) public view returns (uint256) {\n        IFixedTermLoan loan = IFixedTermLoan(borrowingMutex.locker(borrower));\n        if (!loanFactory.isLoanToken(loan)) {\n            return 0;\n        }\n        uint256 borrowed = loan.debt();\n        uint256 resultPrecision = uint256(10)**decimals;\n\n        return loan.pool().oracle().tokenToUsd(borrowed).mul(resultPrecision).div(1 ether);\n    }\n\n    /**\n     * @dev Get borrow limit for `borrower` in `pool` using rate model\n     * @param pool Pool to get borrow limit for\n     * @param borrower Borrower to get borrow limit for\n     * @return borrow limit for `borrower` in `pool`\n     */\n    function borrowLimit(ITrueFiPool2 pool, address borrower) public view returns (uint256) {\n        uint8 poolDecimals = ITrueFiPool2WithDecimals(address(pool)).decimals();\n        return\n            rateModel.borrowLimit(\n                pool,\n                creditOracle.score(borrower),\n                creditOracle.maxBorrowerLimit(borrower),\n                stakingVault.stakedAmount(borrower),\n                totalBorrowed(borrower, poolDecimals)\n            );\n    }\n\n    /**\n     * @dev Helper function to redeem funds from `loanToken` and repay them into the `pool`\n     * @param loanToken Loan to reclaim capital from\n     * @param pool Pool from which the loan was funded\n     */\n    function _redeemAndRepay(\n        IFixedTermLoan loanToken,\n        ITrueFiPool2 pool,\n        bytes calldata data\n    ) internal returns (uint256) {\n        // call redeem function on LoanToken\n        uint256 balanceBefore = pool.token().balanceOf(address(this));\n        loanToken.redeem();\n        uint256 balanceAfter = pool.token().balanceOf(address(this));\n\n        // gets reclaimed amount and pays back to pool\n        uint256 fundsReclaimed = balanceAfter.sub(balanceBefore);\n\n        uint256 feeAmount;\n        if (address(feeToken) != address(0)) {\n            // swap fee for feeToken\n            feeAmount = _swapFee(pool, loanToken, data);\n        }\n\n        pool.token().safeApprove(address(pool), fundsReclaimed.sub(feeAmount));\n        pool.repay(fundsReclaimed.sub(feeAmount));\n\n        if (address(feeToken) != address(0)) {\n            // join pool and reward stakers\n            _transferFeeToStakers();\n        }\n        return fundsReclaimed;\n    }\n\n    /// @dev Swap `token` for `feeToken` on 1inch\n    function _swapFee(\n        ITrueFiPool2 pool,\n        IFixedTermLoan loanToken,\n        bytes calldata data\n    ) internal returns (uint256) {\n        uint256 feeAmount = loanToken.interest().mul(fee).div(BASIS_RATIO);\n        IERC20WithDecimals token = IERC20WithDecimals(address(pool.token()));\n        if (token == feeToken) {\n            return feeAmount;\n        }\n        if (feeAmount == 0) {\n            return 0;\n        }\n        (I1Inch3.SwapDescription memory swap, uint256 balanceDiff) = _1inch.exchange(data);\n        uint256 expectedDiff = pool.oracle().tokenToUsd(feeAmount).mul(uint256(10)**feeToken.decimals()).div(1 ether);\n\n        require(swap.srcToken == address(token), \"FixedTermLoanAgency: Source token is not same as pool's token\");\n        require(swap.dstToken == address(feeToken), \"FixedTermLoanAgency: Destination token is not fee token\");\n        require(swap.dstReceiver == address(this), \"FixedTermLoanAgency: Receiver is not agency\");\n        require(swap.amount == feeAmount, \"FixedTermLoanAgency: Incorrect fee swap amount\");\n        require(swap.flags & ONE_INCH_PARTIAL_FILL_FLAG == 0, \"FixedTermLoanAgency: Partial fill is not allowed\");\n        require(\n            balanceDiff >= expectedDiff.mul(BASIS_RATIO.sub(swapFeeSlippage)).div(BASIS_RATIO),\n            \"FixedTermLoanAgency: Fee returned from swap is too small\"\n        );\n\n        return feeAmount;\n    }\n\n    /// @dev Deposit feeToken to pool and transfer LP tokens to the stakers\n    function _transferFeeToStakers() internal {\n        uint256 amount = feeToken.balanceOf(address(this));\n        if (amount == 0) {\n            return;\n        }\n        feeToken.safeApprove(address(feePool), amount);\n        feePool.join(amount);\n        feePool.safeTransfer(address(stakingPool), feePool.balanceOf(address(this)));\n    }\n\n    function isCredibleForTerm(uint256 term) internal view returns (bool) {\n        return term <= longTermLoanThreshold || creditOracle.score(msg.sender) >= longTermLoanScoreThreshold;\n    }\n\n    function isTermBelowMax(uint256 term) internal view returns (bool) {\n        return term <= maxLoanTerm;\n    }\n}"
    },
    {
      "filename": "contracts/truefi2/FixedTermLoanAgency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {ERC20} from \"../common/UpgradeableERC20.sol\";\nimport {UpgradeableClaimable} from \"../common/UpgradeableClaimable.sol\";\nimport {OneInchExchange} from \"./libraries/OneInchExchange.sol\";\n\nimport {IFixedTermLoan} from \"./interface/IFixedTermLoan.sol\";\nimport {ILoanFactory2} from \"./interface/ILoanFactory2.sol\";\nimport {IStakingPool} from \"../truefi/interface/IStakingPool.sol\";\nimport {IFixedTermLoanAgency} from \"./interface/IFixedTermLoanAgency.sol\";\nimport {ITrueFiPool2} from \"./interface/ITrueFiPool2.sol\";\nimport {I1Inch3} from \"./interface/I1Inch3.sol\";\nimport {IPoolFactory} from \"./interface/IPoolFactory.sol\";\nimport {IERC20WithDecimals} from \"./interface/IERC20WithDecimals.sol\";\nimport {ITrueFiCreditOracle} from \"./interface/ITrueFiCreditOracle.sol\";\nimport {IRateModel} from \"./interface/IRateModel.sol\";\nimport {IBorrowingMutex} from \"./interface/IBorrowingMutex.sol\";\nimport {IStakingVault} from \"./interface/IStakingVault.sol\";\n\ninterface ITrueFiPool2WithDecimals is ITrueFiPool2 {\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @title FixedTermLoanAgency\n * @dev Loans management helper\n * This contract is a bridge that helps to transfer funds from pool to the loans and back\n * FixedTermLoanAgency holds all LoanTokens\n */\ncontract FixedTermLoanAgency is IFixedTermLoanAgency, UpgradeableClaimable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IERC20WithDecimals;\n    using SafeERC20 for ITrueFiPool2;\n    using OneInchExchange for I1Inch3;\n\n    // basis point for ratio\n    uint256 private constant BASIS_RATIO = 10000;\n\n    uint256 private constant ONE_INCH_PARTIAL_FILL_FLAG = 0x01;\n\n    // ================ WARNING ==================\n    // ===== THIS CONTRACT IS INITIALIZABLE ======\n    // === STORAGE VARIABLES ARE DECLARED BELOW ==\n    // REMOVAL OR REORDER OF VARIABLES WILL RESULT\n    // ========= IN STORAGE CORRUPTION ===========\n\n    mapping(ITrueFiPool2 => IFixedTermLoan[]) public poolLoans;\n\n    // maximum amount of loans agency can handle at once\n    uint256 public maxLoans;\n\n    // which part of interest should be paid to the stakers\n    uint256 public fee;\n\n    IStakingPool public stakingPool;\n\n    IPoolFactory public poolFactory;\n\n    I1Inch3 public _1inch;\n\n    // Loan fees should be swapped for this token, deposited into the feePool\n    // and pool's LP tokens should be sent to the stakers\n    IERC20WithDecimals public feeToken;\n    ITrueFiPool2 public feePool;\n\n    // Minimal possible fee swap slippage\n    // basis precision: 10000 = 100%\n    uint256 public swapFeeSlippage;\n\n    ITrueFiCreditOracle public creditOracle;\n\n    uint256 public maxLoanTerm;\n\n    uint256 public longTermLoanThreshold;\n\n    uint8 public longTermLoanScoreThreshold;\n\n    IRateModel public rateModel;\n\n    // mutex ensuring there's only one running loan or credit line for borrower\n    IBorrowingMutex public borrowingMutex;\n\n    ILoanFactory2 public loanFactory;\n\n    mapping(address => bool) public isBorrowerAllowed;\n\n    IStakingVault public stakingVault;\n\n    // ======= STORAGE DECLARATION END ============\n\n    /**\n     * @dev Emitted when loans limit is changed\n     * @param maxLoans new maximum amount of loans\n     */\n    event LoansLimitChanged(uint256 maxLoans);\n\n    /**\n     * @dev Emitted when max loan term changed\n     * @param maxLoanTerm New max loan term\n     */\n    event MaxLoanTermChanged(uint256 maxLoanTerm);\n\n    /**\n     * @dev Emitted when long term loan's minimal term changed\n     * @param longTermLoanThreshold New long term loan minimal term\n     */\n    event LongTermLoanThresholdChanged(uint256 longTermLoanThreshold);\n\n    /**\n     * @dev Emitted when minimal credit score threshold for long term loan changed\n     * @param longTermLoanScoreThreshold New minimal credit score threshold for long term loan\n     */\n    event LongTermLoanScoreThresholdChanged(uint256 longTermLoanScoreThreshold);\n\n    /**\n     * @dev Emitted when loan fee is changed\n     * @param newFee New fee value in basis points\n     */\n    event FeeChanged(uint256 newFee);\n\n    /**\n     * @dev Emitted when fee pool is changed\n     * @param newFeePool New fee pool address\n     */\n    event FeePoolChanged(ITrueFiPool2 newFeePool);\n\n    /**\n     * @dev Emitted when credit oracle is changed\n     * @param newCreditOracle New credit oracle address\n     */\n    event CreditOracleChanged(ITrueFiCreditOracle newCreditOracle);\n\n    /**\n     * @dev Emitted when a loan is funded\n     * @param loanToken LoanToken contract which was funded\n     * @param amount Amount funded\n     */\n    event Funded(address indexed pool, address loanToken, uint256 amount);\n\n    /**\n     * @dev Emitted when funds are reclaimed from the LoanToken contract\n     * @param loanToken LoanToken from which funds were reclaimed\n     * @param amount Amount repaid\n     */\n    event Reclaimed(address indexed pool, address loanToken, uint256 amount);\n\n    /**\n     * @dev Emitted when borrowingMutex address is changed\n     * @param borrowingMutex new borrowingMutex address\n     */\n    event BorrowingMutexChanged(IBorrowingMutex borrowingMutex);\n\n    event BorrowerAllowed(address indexed who);\n    event BorrowerBlocked(address indexed who);\n\n    /**\n     * @dev Can be only called by a pool\n     */\n    modifier onlySupportedPool() {\n        require(poolFactory.isSupportedPool(ITrueFiPool2(msg.sender)), \"FixedTermLoanAgency: Pool not supported by the factory\");\n        _;\n    }\n\n    modifier onlyAllowedBorrowers() {\n        require(isBorrowerAllowed[msg.sender], \"FixedTermLoanAgency: Sender is not allowed to borrow\");\n        _;\n    }\n\n    /**\n     * @dev Initialize the contract with parameters\n     * @param _stakingPool stkTRU address\n     * @param _poolFactory PoolFactory address\n     * @param __1inch 1Inch exchange address (0x11111112542d85b3ef69ae05771c2dccff4faa26 for mainnet)\n     */\n    function initialize(\n        IStakingPool _stakingPool,\n        IPoolFactory _poolFactory,\n        I1Inch3 __1inch,\n        ITrueFiCreditOracle _creditOracle,\n        IRateModel _rateModel,\n        IBorrowingMutex _borrowingMutex,\n        ILoanFactory2 _loanFactory,\n        IStakingVault _stakingVault\n    ) public initializer {\n        UpgradeableClaimable.initialize(msg.sender);\n\n        stakingPool = _stakingPool;\n        poolFactory = _poolFactory;\n        _1inch = __1inch;\n        creditOracle = _creditOracle;\n        rateModel = _rateModel;\n        borrowingMutex = _borrowingMutex;\n        loanFactory = _loanFactory;\n        stakingVault = _stakingVault;\n\n        swapFeeSlippage = 100; // 1%\n        fee = 1000;\n        maxLoans = 100;\n        maxLoanTerm = 180 days;\n        longTermLoanThreshold = 90 days;\n        longTermLoanScoreThreshold = 200;\n    }\n\n    /**\n     * @dev Set new credit oracle address.\n     * Only owner can change credit oracle\n     * @param _creditOracle new credit oracle\n     */\n    function setCreditOracle(ITrueFiCreditOracle _creditOracle) external onlyOwner {\n        require(address(_creditOracle) != address(0), \"FixedTermLoanAgency: CreditOracle cannot be set to zero address\");\n        creditOracle = _creditOracle;\n        emit CreditOracleChanged(_creditOracle);\n    }\n\n    /**\n     * @dev set borrowingMutex\n     * @param newMutex borrowing mutex address to be set\n     */\n    function setBorrowingMutex(IBorrowingMutex newMutex) public onlyOwner {\n        require(address(newMutex) != address(0), \"FixedTermLoanAgency: BorrowingMutex cannot be set to zero address\");\n        borrowingMutex = newMutex;\n        emit BorrowingMutexChanged(newMutex);\n    }\n\n    /**\n     * @dev Set max loan term. Only owner can change parameters.\n     * @param _maxLoanTerm New maxLoanTerm\n     */\n    function setMaxLoanTerm(uint256 _maxLoanTerm) external onlyOwner {\n        maxLoanTerm = _maxLoanTerm;\n        emit MaxLoanTermChanged(_maxLoanTerm);\n    }\n\n    /**\n     * @dev Set minimal term of a long term loan. Only owner can change parameters.\n     * @param _longTermLoanThreshold New longTermLoanThreshold\n     */\n    function setLongTermLoanThreshold(uint256 _longTermLoanThreshold) external onlyOwner {\n        longTermLoanThreshold = _longTermLoanThreshold;\n        emit LongTermLoanThresholdChanged(_longTermLoanThreshold);\n    }\n\n    /**\n     * @dev Set long term loan credit score threshold. Only owner can change parameters.\n     * @param _longTermLoanScoreThreshold New longTermLoanScoreThreshold\n     */\n    function setLongTermLoanScoreThreshold(uint8 _longTermLoanScoreThreshold) external onlyOwner {\n        longTermLoanScoreThreshold = _longTermLoanScoreThreshold;\n        emit LongTermLoanScoreThresholdChanged(_longTermLoanScoreThreshold);\n    }\n\n    /**\n     * @dev Set new loans limit. Only owner can change parameters.\n     * @param newLoansLimit New loans limit\n     */\n    function setLoansLimit(uint256 newLoansLimit) external onlyOwner {\n        maxLoans = newLoansLimit;\n        emit LoansLimitChanged(maxLoans);\n    }\n\n    /**\n     * @dev Set new fee pool and fee token.\n     * Only owner can change parameters\n     * @param newFeePool new pool address\n     */\n    function setFeePool(ITrueFiPool2 newFeePool) external onlyOwner {\n        feeToken = IERC20WithDecimals(address(newFeePool.token()));\n        feePool = newFeePool;\n        emit FeePoolChanged(newFeePool);\n    }\n\n    /**\n     * @dev Set loan interest fee that goes to the stakers.\n     * @param newFee New loans limit\n     */\n    function setFee(uint256 newFee) external onlyOwner {\n        require(newFee <= BASIS_RATIO, \"FixedTermLoanAgency: fee cannot be more than 100%\");\n        fee = newFee;\n        emit FeeChanged(newFee);\n    }\n\n    function allowBorrower(address who) external onlyOwner {\n        isBorrowerAllowed[who] = true;\n        emit BorrowerAllowed(who);\n    }\n\n    function blockBorrower(address who) external onlyOwner {\n        isBorrowerAllowed[who] = false;\n        emit BorrowerBlocked(who);\n    }\n\n    /**\n     * @dev Get currently funded loans for a pool\n     * @param pool pool address\n     * @return result Array of loans currently funded\n     */\n    function loans(ITrueFiPool2 pool) public view returns (IFixedTermLoan[] memory result) {\n        result = poolLoans[pool];\n    }\n\n    function rate(\n        ITrueFiPool2 pool,\n        address borrower,\n        uint256 amount,\n        uint256 term\n    ) public view returns (uint256) {\n        uint8 rawScore = creditOracle.score(borrower);\n        uint256 stakedAmount = stakingVault.stakedAmount(borrower);\n        uint8 effectiveScore = rateModel.effectiveScore(pool, rawScore, stakedAmount, amount);\n        uint256 fixedTermLoanAdjustment = rateModel.fixedTermLoanAdjustment(term);\n        return rateModel.rate(pool, effectiveScore, amount).add(fixedTermLoanAdjustment);\n    }\n\n    /**\n     * @dev Create and fund a loan via LoanFactory for a pool supported by PoolFactory\n     * Method should be called by the loan borrower\n     *\n     * When called, agency takes funds from the pool, gives it to the loan and holds all LoanTokens\n     * Origination fee is transferred to the stake\n     */\n    function borrow(\n        ITrueFiPool2 pool,\n        uint256 amount,\n        uint256 term,\n        uint256 _maxApy\n    ) external onlyAllowedBorrowers {\n        require(poolFactory.isSupportedPool(pool), \"FixedTermLoanAgency: Pool not supported by the factory\");\n        require(poolLoans[pool].length < maxLoans, \"FixedTermLoanAgency: Loans number has reached the limit\");\n\n        address borrower = msg.sender;\n        require(borrowingMutex.isUnlocked(borrower), \"FixedTermLoanAgency: There is an ongoing loan or credit line\");\n        require(\n            creditOracle.status(borrower) == ITrueFiCreditOracle.Status.Eligible,\n            \"FixedTermLoanAgency: Sender is not eligible for loan\"\n        );\n\n        require(amount > 0, \"FixedTermLoanAgency: Loans of amount 0, will not be approved\");\n        require(\n            pool.oracle().tokenToUsd(amount) <= borrowLimit(pool, borrower),\n            \"FixedTermLoanAgency: Loan amount cannot exceed borrow limit\"\n        );\n\n        require(term > 0, \"FixedTermLoanAgency: Loans cannot hav"
    }
  ]
}