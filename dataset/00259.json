{
  "Title": "Protocol unintentionally implements an asymmetric method of calculating the  price difference ",
  "Content": "# Protocol unintentionally implements an asymmetric method of calculating the  price difference \n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Oracle/LibOracleHelpers.sol#L25-L32\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Oracle/LibOracleHelpers.sol#L25-L32</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol#L68-L98\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol#L68-L98</a>\n\n\n## Summary\n\nThe protocol exhibits a disparity in the calculation of price differences due to the current implementation in `LibOracleHelpers::getPercentDifference()`. This affects `LibWstethEthOracle::getWstethEthPrice()`, since the present implementation causes unintended returns of `0` for price queries. The discrepancy arises from the flawed calculation logic as explained in the report, causing the protocol to incorrectly assume _price manipulation_ in certain **valid scenarios**. This flaw undermines the reliability of price queries and cwould result in denial-of-service unintended implementation\n\n## Vulnerability Details\n\nFirst take a look at https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Oracle/LibOracleHelpers.sol#L25-L32\n\n```solidity\n    function getPercentDifference(\n        uint x,\n        uint y\n    ) internal pure returns (uint256 percentDifference) {\n        percentDifference = x.mul(ONE).div(y);\n        percentDifference = x > y ? percentDifference - ONE : ONE - percentDifference; // SafeMath unnecessary due to conditional check\n    }\n}\n```\n\nThis function is used to get the percent difference between two values, keep in mind that \"values\" in this context are \"prices\" provided by different oracle sources, protocol hardcodes the numerator and denominator of getting the percentage as x and y respectively `x.mul(ONE).div(y)`, but evidently we can see that the percentage of the price difference is finalized depending on if x > y or not, causing the equation to be flawed, cause `percentDifference - ONE ` & `ONE - percentDifference` would yield different results in the context for two same x and y price.\n\nTo deduce the differences in the formular, we can see that\n\n- If `x > y ` then the percentDifference is gotten as ( ( (1e18 \\* X ) / Y ) - 1e18), however\n- If `x < y ` then the percentDifference is gotten as (1e18 - ( ( 1e18 \\* X ) / Y ) )\n\nUsing generic values of 5 and 6... and assuming 1e18 as `1000` just for POC sake, i.e instances of `1e18 * X` is now `1000X`.\n\nFor the first case (X = 5, Y = 6), we get a percentDifference of 166,67 ~ 16,7%\nFor the second case (X = 6, Y = 5), we get a percentDifference of 200 = 20%\n\nNow, take a look at the only instance where this check is implemented in scope, https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol#L68-L98\n\n```solidity\n    function getWstethEthPrice(uint256 lookback) internal view returns (uint256 wstethEthPrice) {\n\n        uint256 chainlinkPrice = lookback == 0 ?\n            LibChainlinkOracle.getPrice(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT) :\n            LibChainlinkOracle.getTwap(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT, lookback);\n\n        // Check if the chainlink price is broken or frozen.\n        if (chainlinkPrice == 0) return 0;\n\n        uint256 stethPerWsteth = IWsteth(C.WSTETH).stEthPerToken();\n\n        chainlinkPrice = chainlinkPrice.mul(stethPerWsteth).div(CHAINLINK_DENOMINATOR);\n\n\n        // Uniswap V3 only supports a uint32 lookback.\n        if (lookback > type(uint32).max) return 0;\n        uint256 uniswapPrice = LibUniswapOracle.getTwap(\n            lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES :\n            uint32(lookback),\n            WSTETH_ETH_UNIV3_01_POOL, C.WSTETH, C.WETH, ONE\n        );\n\n        // Check if the uniswapPrice oracle fails.\n        if (uniswapPrice == 0) return 0;\n        //@audit `getPercentDifference` is queried with `MAX_DIFFERENCE`\n        if (LibOracleHelpers.getPercentDifference(chainlinkPrice, uniswapPrice) < MAX_DIFFERENCE) {\n            wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);\n            if (wstethEthPrice > stethPerWsteth) wstethEthPrice = stethPerWsteth;\n            wstethEthPrice = wstethEthPrice.div(PRECISION_DENOMINATOR);\n        }\n    }\n```\n\nThis function is used to get the `wstEth` price, but the `MAX_DIFFERENCE` check is applied here and in a case where the price discrepancy is more than `MAX_DIFFERENCE` this function returns 0.\n\nThe above explained case means that the current implementation of `getPercentDifference` would cause protocol assuming the price has been manipulated for the same difference just dependent on if the chainlink price is higher/lower than the uniswap returned price, causing `0` to be returned in some valid cases and considering the fact that the `MAX_DIFFERENCE` has been set very low, this would frequently occur, to use a real life case a sa POC, as at the time of writing this report, the value of wstEth in comparison to eth is `1,16323`, so assuming the queried price X from chainlink returns 1,17490, and uniswap price Y returns 1,16323, the `getPercentDifference()` check fails, since the difference in percentage is = `1,0032409755594 * 1e18` i.e > `MAX_DIFFERENCE`, however if we swap which provider provides which, i.e now chainlink X returns 1,16323 and uniswap price Y returns 1,17490, the `getPercentDifference()` check passes since the difference in percentage would be = `0.99327602349136 * 1e18` i.e < `MAX_DIFFERENCE` proving the disparity and this calculation `wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);` would be the same for the two cases irrespective of `(x > y)?` i.e in our highlighted case above for both instances the calculation would equal `((1,17490, + 1,16323 ) / 2) = 1,169065` and should be considered valid in both cases.\n\n## Impact\n\nDesynchronization of price queries and this directly affects all instances in protocol where `LibWstethEthOracle.sol`'s `getWstethEthPrice()` is called, i.e in two same cases where the provided prices are the same, the attempt to query the price correctly works with one where as it doesn't with the other, leading to unintended return of `0` for price essentially a DOS to `LibWstethEthOracle.sol`'s `getWstethEthPrice()` since protocol would now assume that the price has been manipulated, keep in mind that in real sense this calculation `wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);` would always return the same value for both cases and as such the price should be valid and accepted in both cases.\n\n## Tool Used\n\nManual review\n\n## Recommended Mitigation Steps.\n\nMake the check to always be in sync, this can be by ensuring that the divisor is always the lower/greater price and then maybe reimplementing the value of `MAX_DIFFERENCE` to take this into consideration, the former alone is sufficient, i.e reimplement https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Oracle/LibOracleHelpers.sol#L25-L32 to:\n\n```solidity\n        function getPercentDifference(\n            uint x,\n            uint y\n        ) internal pure returns (uint256 percentDifference) {\n            if (x == y) {\n                percentDifference = 0;\n            } else if (x < y) {\n                percentDifference = x.mul(ONE).div(y);\n                percentDifference = ONE - percentDifference;\n            } else {\n                percentDifference = y.mul(ONE).div(x);\n                percentDifference = ONE - percentDifference;\n            }\n            return percentDifference;\n        }\n\n```\n\nHere we are always using the bigger price as the denominator, thereby making sure that in whichever of the two cases explained in report, i.e if x > y or not a fixed `percentDifference` is provided and this can then be accurately checked against protocol's set `MAX_DIFFERENCE` value.\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clu7665bs0001fmt5yahc8tyh",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Oracle/LibOracleHelpers.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n/**\n * @title Oracle Helpers Library\n * @author brendan\n * @notice Contains functionalty common to multiple Oracle libraries.\n **/\nlibrary LibOracleHelpers {\n\n    using SafeMath for uint256;\n\n    uint256 constant ONE = 1e18;\n\n    /**\n     * Gets the percent difference between two values with 18 decimal precision.\n     * @dev If x == 0 (Such as in the case of Uniswap Oracle failure), then the percent difference is calculated as 100%.\n     */\n    function getPercentDifference(\n        uint x,\n        uint y\n    ) internal pure returns (uint256 percentDifference) {\n        percentDifference = x.mul(ONE).div(y);\n        percentDifference = x > y ? percentDifference - ONE : ONE - percentDifference; // SafeMath unnecessary due to conditional check\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibChainlinkOracle} from \"./LibChainlinkOracle.sol\";\nimport {LibUniswapOracle} from \"./LibUniswapOracle.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibAppStorage, AppStorage} from \"contracts/libraries/LibAppStorage.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {LibOracleHelpers} from \"contracts/libraries/Oracle/LibOracleHelpers.sol\";\n\ninterface IWsteth {\n    function stEthPerToken() external view returns (uint256);\n}\n\n/**\n * @title Wsteth Eth Oracle Library\n * @author brendan\n * @notice Computes the wstETH:ETH price.\n * @dev\n * The oracle reads from 4 data sources:\n * a. wstETH:stETH Redemption Rate: (0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)\n * b. stETH:ETH Chainlink Oracle: (0x86392dC19c0b719886221c78AB11eb8Cf5c52812)\n * c. wstETH:ETH Uniswap Pool: (0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa)\n * d. stETH:ETH Redemption: (1:1)\n *\n * It then computes the wstETH:ETH price in 3 ways:\n * 1. wstETH -> ETH via Chainlink: a * b\n * 2. wstETH -> ETH via wstETH:ETH Uniswap Pool: c * 1\n * 3. wstETH -> ETH via stETH redemption: a * d\n *\n * It then computes a wstETH:ETH price by taking the minimum of (3) and either the average of (1) and (2)\n * if (1) and (2) are within `MAX_DIFFERENCE` from each other or (1).\n **/\nlibrary LibWstethEthOracle {\n    using SafeMath for uint256;\n\n    // The maximum percent difference such that the oracle assumes no manipulation is occuring.\n    uint256 constant MAX_DIFFERENCE = 0.01e18; // 1%\n    uint256 constant CHAINLINK_DENOMINATOR = 1e6;\n    uint128 constant ONE = 1e18;\n    uint128 constant AVERAGE_DENOMINATOR = 2;\n    uint128 constant PRECISION_DENOMINATOR = 1e12;\n\n    /////////////////// ORACLES ///////////////////\n    address constant WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR =\n        0x86392dC19c0b719886221c78AB11eb8Cf5c52812;\n    address internal constant WSTETH_ETH_UNIV3_01_POOL = 0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa; // 0.01% pool\n    ///////////////////////////////////////////////\n\n    /**\n     * @dev Returns the instantaneous wstETH/ETH price\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice() internal view returns (uint256) {\n        return getWstethEthPrice(0);\n    }\n\n    /**\n     * @dev Returns the wstETH/ETH price with the option of using a TWA lookback.\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice(uint256 lookback) internal view returns (uint256 wstethEthPrice) {\n\n        uint256 chainlinkPrice = lookback == 0 ? \n            LibChainlinkOracle.getPrice(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT) :\n            LibChainlinkOracle.getTwap(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT, lookback);\n\n        // Check if the chainlink price is broken or frozen.\n        if (chainlinkPrice == 0) return 0;\n\n        uint256 stethPerWsteth = IWsteth(C.WSTETH).stEthPerToken();\n        \n        chainlinkPrice = chainlinkPrice.mul(stethPerWsteth).div(CHAINLINK_DENOMINATOR);\n\n\n        // Uniswap V3 only supports a uint32 lookback.\n        if (lookback > type(uint32).max) return 0;\n        uint256 uniswapPrice = LibUniswapOracle.getTwap(\n            lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES :\n            uint32(lookback),\n            WSTETH_ETH_UNIV3_01_POOL, C.WSTETH, C.WETH, ONE\n        );\n\n        // Check if the uniswapPrice oracle fails.\n        if (uniswapPrice == 0) return 0;\n\n        if (LibOracleHelpers.getPercentDifference(chainlinkPrice, uniswapPrice) < MAX_DIFFERENCE) {\n            wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);\n            if (wstethEthPrice > stethPerWsteth) wstethEthPrice = stethPerWsteth;\n            wstethEthPrice = wstethEthPrice.div(PRECISION_DENOMINATOR);\n        }\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Oracle/LibOracleHelpers.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n/**\n * @title Oracle Helpers Library\n * @author brendan\n * @notice Contains functionalty common to multiple Oracle libraries.\n **/\nlibrary LibOracleHelpers {\n\n    using SafeMath for uint256;\n\n    uint256 constant ONE = 1e18;\n\n    /**\n     * Gets the percent difference between two values with 18 decimal precision.\n     * @dev If x == 0 (Such as in the case of Uniswap Oracle failure), then the percent difference is calculated as 100%.\n     */\n    function getPercentDifference(\n        uint x,\n        uint y\n    ) internal pure returns (uint256 percentDifference) {\n        percentDifference = x.mul(ONE).div(y);\n        percentDifference = x > y ? percentDifference - ONE : ONE - percentDifference; // SafeMath unnecessary due to conditional check\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibChainlinkOracle} from \"./LibChainlinkOracle.sol\";\nimport {LibUniswapOracle} from \"./LibUniswapOracle.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibAppStorage, AppStorage} from \"contracts/libraries/LibAppStorage.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {LibOracleHelpers} from \"contracts/libraries/Oracle/LibOracleHelpers.sol\";\n\ninterface IWsteth {\n    function stEthPerToken() external view returns (uint256);\n}\n\n/**\n * @title Wsteth Eth Oracle Library\n * @author brendan\n * @notice Computes the wstETH:ETH price.\n * @dev\n * The oracle reads from 4 data sources:\n * a. wstETH:stETH Redemption Rate: (0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)\n * b. stETH:ETH Chainlink Oracle: (0x86392dC19c0b719886221c78AB11eb8Cf5c52812)\n * c. wstETH:ETH Uniswap Pool: (0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa)\n * d. stETH:ETH Redemption: (1:1)\n *\n * It then computes the wstETH:ETH price in 3 ways:\n * 1. wstETH -> ETH via Chainlink: a * b\n * 2. wstETH -> ETH via wstETH:ETH Uniswap Pool: c * 1\n * 3. wstETH -> ETH via stETH redemption: a * d\n *\n * It then computes a wstETH:ETH price by taking the minimum of (3) and either the average of (1) and (2)\n * if (1) and (2) are within `MAX_DIFFERENCE` from each other or (1).\n **/\nlibrary LibWstethEthOracle {\n    using SafeMath for uint256;\n\n    // The maximum percent difference such that the oracle assumes no manipulation is occuring.\n    uint256 constant MAX_DIFFERENCE = 0.01e18; // 1%\n    uint256 constant CHAINLINK_DENOMINATOR = 1e6;\n    uint128 constant ONE = 1e18;\n    uint128 constant AVERAGE_DENOMINATOR = 2;\n    uint128 constant PRECISION_DENOMINATOR = 1e12;\n\n    /////////////////// ORACLES ///////////////////\n    address constant WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR =\n        0x86392dC19c0b719886221c78AB11eb8Cf5c52812;\n    address internal constant WSTETH_ETH_UNIV3_01_POOL = 0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa; // 0.01% pool\n    ///////////////////////////////////////////////\n\n    /**\n     * @dev Returns the instantaneous wstETH/ETH price\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice() internal view returns (uint256) {\n        return getWstethEthPrice(0);\n    }\n\n    /**\n     * @dev Returns the wstETH/ETH price with the option of using a TWA lookback.\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice(uint256 lookback) internal view returns (uint256 wstethEthPrice) {\n\n        uint256 chainlinkPrice = lookback == 0 ? \n            LibChainlinkOracle.getPrice(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT) :\n            LibChainlinkOracle.getTwap(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT, lookback);\n\n        // Check if the chainlink price is broken or frozen.\n        if (chainlinkPrice == 0) return 0;\n\n        uint256 stethPerWsteth = IWsteth(C.WSTETH).stEthPerToken();\n        \n        chainlinkPrice = chainlinkPrice.mul(stethPerWsteth).div(CHAINLINK_DENOMINATOR);\n\n\n        // Uniswap V3 only supports a uint32 lookback.\n        if (lookback > type(uint32).max) return 0;\n        uint256 uniswapPrice = LibUniswapOracle.getTwap(\n            lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES :\n            uint32(lookback),\n            WSTETH_ETH_UNIV3_01_POOL, C.WSTETH, C.WETH, ONE\n        );\n\n        // Check if the uniswapPrice oracle fails.\n        if (uniswapPrice == 0) return 0;\n\n        if (LibOracleHelpers.getPercentDifference(chainlinkPrice, uniswapPrice) < MAX_DIFFERENCE) {\n            wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);\n            if (wstethEthPrice > stethPerWsteth) wstethEthPrice = stethPerWsteth;\n            wstethEthPrice = wstethEthPrice.div(PRECISION_DENOMINATOR);\n        }\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Oracle/LibOracleHelpers.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n/**\n * @title Oracle Helpers Library\n * @author brendan\n * @notice Contains functionalty common to multiple Oracle libraries.\n **/\nlibrary LibOracleHelpers {\n\n    using SafeMath for uint256;\n\n    uint256 constant ONE = 1e18;\n\n    /**\n     * Gets the percent difference between two values with 18 decimal precision.\n     * @dev If x == 0 (Such as in the case of Uniswap Oracle failure), then the percent difference is calculated as 100%.\n     */\n    function getPercentDifference(\n        uint x,\n        uint y\n    ) internal pure returns (uint256 percentDifference) {\n        percentDifference = x.mul(ONE).div(y);\n        percentDifference = x > y ? percentDifference - ONE : ONE - percentDifference; // SafeMath unnecessary due to conditional check\n    }\n}"
    }
  ]
}