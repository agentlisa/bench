{
  "Title": "[G-08] Emitting storage values instead of the memory one.",
  "Content": "Here, the values emitted shouldn’t be read from storage. The existing memory values should be used instead:\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/JumpRateModelV2.sol#L171-L190\n\n```solidity\nFile: /contracts/lending/JumpRateModelV2.sol\n 171: function updateJumpRateModelInternal(\n\n182:    kink = kink_;\n\n184:    emit NewInterestParams(\n185:      baseRatePerBlock,\n186:      multiplierPerBlock,\n187:      jumpMultiplierPerBlock,\n188:      kink\n189:    );\n190:  }\n```\n\n```diff\ndiff --git a/contracts/lending/JumpRateModelV2.sol b/contracts/lending/JumpRateModelV2.sol\nindex a3971c6..cc525bb 100644\n--- a/contracts/lending/JumpRateModelV2.sol\n+++ b/contracts/lending/JumpRateModelV2.sol\n@@ -185,7 +185,7 @@ contract JumpRateModelV2 is InterestRateModel {\n       baseRatePerBlock,\n       multiplierPerBlock,\n       jumpMultiplierPerBlock,\n-      kink\n+      kink_\n     );\n   }\n }\n```\n\n**Other instances**\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L817-L823\n\n```solidity\nFile: /contracts/cash/CashManager.sol\n\n//@audit: we should emit newRedeemMinimum instead of minimumRedeemAmount\n817:  function setRedeemMinimum(\n818:    uint256 newRedeemMinimum\n819:  ) external onlyRole(MANAGER_ADMIN) {\n820:    uint256 oldRedeemMin = minimumRedeemAmount;\n821:    minimumRedeemAmount = newRedeemMinimum;\n822:    emit MinimumRedeemAmountSet(oldRedeemMin, minimumRedeemAmount);\n823:  }\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cErc20ModifiedDelegator.sol#L720-L747\n\n```solidity\nFile: /contracts/lending/tokens/cErc20ModifiedDelegator.sol\n\n//@audit: We should emit implementation_ instead of implementation\n720:  function _setImplementation(\n721:    address implementation_,\n722:    bool allowResign,\n723:    bytes memory becomeImplementationData\n724:  ) public {\n\n736:    address oldImplementation = implementation;\n737:    implementation = implementation_;\n\n746:    emit NewImplementation(oldImplementation, implementation);\n747:  }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/lending/JumpRateModelV2.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./compound/InterestRateModel.sol\";\nimport \"./compound/SafeMath.sol\";\n\n/**\n * @title Ondo's modified JumpRateModel Contract V2\n * @author Compound (modified by Dharma Labs)\n * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n */\ncontract JumpRateModelV2 is InterestRateModel {\n  using SafeMath for uint;\n\n  event NewInterestParams(\n    uint baseRatePerBlock,\n    uint multiplierPerBlock,\n    uint jumpMultiplierPerBlock,\n    uint kink\n  );\n\n  /**\n   * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n   */\n  address public owner;\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n   */\n  uint public constant blocksPerYear = 2628000;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n   */\n  uint public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n   */\n  uint public baseRatePerBlock;\n\n  /**\n   * @notice The multiplierPerBlock after hitting a specified utilization point\n   */\n  uint public jumpMultiplierPerBlock;\n\n  /**\n   * @notice The utilization point at which the jump multiplier is applied\n   */\n  uint public kink;\n\n  /**\n   * @notice Construct an interest rate model\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n   */\n  constructor(\n    uint baseRatePerYear,\n    uint multiplierPerYear,\n    uint jumpMultiplierPerYear,\n    uint kink_,\n    address owner_\n  ) public {\n    owner = owner_;\n\n    updateJumpRateModelInternal(\n      baseRatePerYear,\n      multiplierPerYear,\n      jumpMultiplierPerYear,\n      kink_\n    );\n  }\n\n  /**\n   * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   */\n  function updateJumpRateModel(\n    uint baseRatePerYear,\n    uint multiplierPerYear,\n    uint jumpMultiplierPerYear,\n    uint kink_\n  ) external {\n    require(msg.sender == owner, \"only the owner may call this function.\");\n\n    updateJumpRateModelInternal(\n      baseRatePerYear,\n      multiplierPerYear,\n      jumpMultiplierPerYear,\n      kink_\n    );\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market (currently unused)\n   * @return The utilization rate as a mantissa between [0, 1e18]\n   */\n  function utilizationRate(\n    uint cash,\n    uint borrows,\n    uint reserves\n  ) public pure returns (uint) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint cash,\n    uint borrows,\n    uint reserves\n  ) public view returns (uint) {\n    uint util = utilizationRate(cash, borrows, reserves);\n\n    if (util <= kink) {\n      return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n    } else {\n      uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(\n        baseRatePerBlock\n      );\n      uint excessUtil = util.sub(kink);\n      return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n    }\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @param reserveFactorMantissa The current reserve factor for the market\n   * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint cash,\n    uint borrows,\n    uint reserves,\n    uint reserveFactorMantissa\n  ) public view returns (uint) {\n    uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\n    uint borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n    return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n  }\n\n  /**\n   * @notice Internal function to update the parameters of the interest rate model\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   */\n  function updateJumpRateModelInternal(\n    uint baseRatePerYear,\n    uint multiplierPerYear,\n    uint jumpMultiplierPerYear,\n    uint kink_\n  ) internal {\n    baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n    multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(\n      blocksPerYear.mul(kink_)\n    );\n    jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n    kink = kink_;\n\n    emit NewInterestParams(\n      baseRatePerBlock,\n      multiplierPerBlock,\n      jumpMultiplierPerBlock,\n      kink\n    );\n  }\n}"
    },
    {
      "filename": "contracts/cash/CashManager.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\nimport \"contracts/cash/interfaces/ICashManager.sol\";\nimport \"contracts/cash/interfaces/IMulticall.sol\";\nimport \"contracts/cash/token/Cash.sol\";\nimport \"contracts/cash/kyc/KYCRegistryClientConstructable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/SafeERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract CashManager is\n  ICashManager,\n  IMulticall,\n  AccessControlEnumerable,\n  KYCRegistryClientConstructable,\n  Pausable,\n  ReentrancyGuard\n{\n  using SafeERC20 for IERC20;\n\n  /// @dev Tokens\n  // ERC20 token used to Mint CASH with\n  IERC20 public immutable collateral;\n\n  // CASH contract\n  Cash public immutable cash;\n\n  /// @dev Collateral Recipients\n  // The address to which the `collateral` is sent\n  address public assetRecipient;\n\n  // The address to which fees are sent\n  address public feeRecipient;\n\n  // The address from which redemptions are processed\n  address public assetSender;\n\n  /// @dev Mint/Redeem Parameters\n  // Minimum amount that must be deposited to mint CASH\n  // Denoted in decimals of `collateral`\n  uint256 public minimumDepositAmount = 10_000;\n\n  // Minimum amount that must be redeemed for a withdraw request\n  uint256 public minimumRedeemAmount;\n\n  // Minting fee specified in basis points\n  uint256 public mintFee = 0;\n\n  // Limit for how far `exchangeRate` can stray from\n  // `lastSetMintExchangeRate` within an epoch (in basis points)\n  uint256 public exchangeRateDeltaLimit = 100;\n\n  // Struct representing all redemption requests in an epoch\n  struct RedemptionRequests {\n    // Total CASH burned in the epoch\n    uint256 totalBurned;\n    // Mapping from address to amount of CASH address burned\n    mapping(address => uint256) addressToBurnAmt;\n  }\n\n  // Mapping from epoch to redemption info struct for that epoch\n  mapping(uint256 => RedemptionRequests) public redemptionInfoPerEpoch;\n\n  // Mapping used for getting the exchange rate during a given epoch\n  mapping(uint256 => uint256) public epochToExchangeRate;\n\n  // Nested mapping containing mint requests for an epoch\n  // { <epoch> : {<user> : <collateralAmount> }\n  mapping(uint256 => mapping(address => uint256)) public mintRequestsPerEpoch;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Decimal multiplier representing the difference between `CASH` decimals\n  // In `collateral` token decimals\n  uint256 public immutable decimalsMultiplier;\n\n  /// @dev Epoch Parameters\n  // Epoch that contract is currently in\n  uint256 public currentEpoch;\n\n  // Duration of an epoch in seconds\n  uint256 public epochDuration;\n\n  // Timestamp of the start of `currentEpoch`\n  uint256 public currentEpochStartTimestamp;\n\n  // `exchangeRate` at start of `currentEpoch`\n  uint256 public lastSetMintExchangeRate = 1e6;\n\n  /// @dev Mint/Redeem Limit Parameters\n  // Maximum amount that can be minted during an epoch\n  uint256 public mintLimit;\n\n  // Amount already minted during the `currentEpoch`\n  uint256 public currentMintAmount;\n\n  // Maximum amount that can be redeemed during an epoch\n  uint256 public redeemLimit;\n\n  // Amount already redeemed during the `currentEpoch`\n  uint256 public currentRedeemAmount;\n\n  /// @dev Role Based Access control members\n  bytes32 public constant MANAGER_ADMIN = keccak256(\"MANAGER_ADMIN\");\n  bytes32 public constant PAUSER_ADMIN = keccak256(\"PAUSER_ADMIN\");\n  bytes32 public constant SETTER_ADMIN = keccak256(\"SETTER_ADMIN\");\n\n  /// @notice constructor\n  constructor(\n    address _collateral,\n    address _cash,\n    address managerAdmin,\n    address pauser,\n    address _assetRecipient,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _mintLimit,\n    uint256 _redeemLimit,\n    uint256 _epochDuration,\n    address _kycRegistry,\n    uint256 _kycRequirementGroup\n  ) KYCRegistryClientConstructable(_kycRegistry, _kycRequirementGroup) {\n    if (_collateral == address(0)) {\n      revert CollateralZeroAddress();\n    }\n    if (_cash == address(0)) {\n      revert CashZeroAddress();\n    }\n    if (_assetRecipient == address(0)) {\n      revert AssetRecipientZeroAddress();\n    }\n    if (_assetSender == address(0)) {\n      revert AssetSenderZeroAddress();\n    }\n    if (_feeRecipient == address(0)) {\n      revert FeeRecipientZeroAddress();\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, managerAdmin);\n    _grantRole(MANAGER_ADMIN, managerAdmin);\n    _setRoleAdmin(PAUSER_ADMIN, MANAGER_ADMIN);\n    _setRoleAdmin(SETTER_ADMIN, MANAGER_ADMIN);\n    _grantRole(PAUSER_ADMIN, pauser);\n\n    collateral = IERC20(_collateral);\n    cash = Cash(_cash);\n    feeRecipient = _feeRecipient;\n    assetRecipient = _assetRecipient;\n    assetSender = _assetSender;\n    currentEpoch = currentEpoch;\n\n    mintLimit = _mintLimit;\n    redeemLimit = _redeemLimit;\n    epochDuration = _epochDuration;\n\n    currentEpochStartTimestamp =\n      block.timestamp -\n      (block.timestamp % epochDuration);\n\n    // Implicit constraint: cash decimals >= collateral decimals.\n    decimalsMultiplier =\n      10 **\n        (IERC20Metadata(_cash).decimals() -\n          IERC20Metadata(_collateral).decimals());\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Mint Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function used by users to submit a request to mint\n   *\n   * @param collateralAmountIn The amount of collateral one wishes to deposit\n   *                           to mint CASH tokens\n   */\n  function requestMint(\n    uint256 collateralAmountIn\n  )\n    external\n    override\n    updateEpoch\n    nonReentrant\n    whenNotPaused\n    checkKYC(msg.sender)\n  {\n    if (collateralAmountIn < minimumDepositAmount) {\n      revert MintRequestAmountTooSmall();\n    }\n\n    uint256 feesInCollateral = _getMintFees(collateralAmountIn);\n    uint256 depositValueAfterFees = collateralAmountIn - feesInCollateral;\n\n    _checkAndUpdateMintLimit(depositValueAfterFees);\n\n    collateral.safeTransferFrom(msg.sender, feeRecipient, feesInCollateral);\n    collateral.safeTransferFrom(\n      msg.sender,\n      assetRecipient,\n      depositValueAfterFees\n    );\n\n    mintRequestsPerEpoch[currentEpoch][msg.sender] += depositValueAfterFees;\n\n    emit MintRequested(\n      msg.sender,\n      currentEpoch,\n      collateralAmountIn,\n      depositValueAfterFees,\n      feesInCollateral\n    );\n  }\n\n  /**\n   * @notice Function used by users to claim an airdrop for a given epoch\n   *\n   * @param user       The user who requested to mint\n   * @param epochToClaim The epoch in which the mint was requested\n   *\n   * @dev We perform KYC check on the user destined to receive `cash`, not the\n   *      msg.sender\n   */\n  function claimMint(\n    address user,\n    uint256 epochToClaim\n  ) external override updateEpoch nonReentrant whenNotPaused checkKYC(user) {\n    uint256 collateralDeposited = mintRequestsPerEpoch[epochToClaim][user];\n    if (collateralDeposited == 0) {\n      revert NoCashToClaim();\n    }\n    if (epochToExchangeRate[epochToClaim] == 0) {\n      revert ExchangeRateNotSet();\n    }\n\n    // Get the amount of CASH due at a given rate per epoch\n    uint256 cashOwed = _getMintAmountForEpoch(\n      collateralDeposited,\n      epochToClaim\n    );\n\n    mintRequestsPerEpoch[epochToClaim][user] = 0;\n    cash.mint(user, cashOwed);\n\n    emit MintCompleted(\n      user,\n      cashOwed,\n      collateralDeposited,\n      epochToExchangeRate[epochToClaim],\n      epochToClaim\n    );\n  }\n\n  /**\n   * @notice Sets mint exchange rate\n   *\n   * @param exchangeRate New mint exchange rate (in 6 decimals)\n   * @param epochToSet   The epoch we want to set the exchange rate for\n   *\n   * @dev If the exchange rate differs more than `exchangeRateDeltaLimit`\n   *      from the last exchange rate set, the entire contract will be paused.\n   *      See `overrideExchangeRate` should this check need to be bypassed\n   */\n  function setMintExchangeRate(\n    uint256 exchangeRate,\n    uint256 epochToSet\n  ) external override updateEpoch onlyRole(SETTER_ADMIN) {\n    if (exchangeRate == 0) {\n      revert ZeroExchangeRate();\n    }\n    if (epochToSet >= currentEpoch) {\n      revert EpochNotElapsed();\n    }\n    if (epochToExchangeRate[epochToSet] != 0) {\n      revert EpochExchangeRateAlreadySet();\n    }\n\n    uint256 rateDifference;\n    if (exchangeRate > lastSetMintExchangeRate) {\n      rateDifference = exchangeRate - lastSetMintExchangeRate;\n    } else if (exchangeRate < lastSetMintExchangeRate) {\n      rateDifference = lastSetMintExchangeRate - exchangeRate;\n    }\n\n    uint256 maxDifferenceThisEpoch = (lastSetMintExchangeRate *\n      exchangeRateDeltaLimit) / BPS_DENOMINATOR;\n\n    if (rateDifference > maxDifferenceThisEpoch) {\n      epochToExchangeRate[epochToSet] = exchangeRate;\n      _pause();\n      emit MintExchangeRateCheckFailed(\n        epochToSet,\n        lastSetMintExchangeRate,\n        exchangeRate\n      );\n    } else {\n      uint256 oldExchangeRate = lastSetMintExchangeRate;\n      epochToExchangeRate[epochToSet] = exchangeRate;\n      lastSetMintExchangeRate = exchangeRate;\n      emit MintExchangeRateSet(epochToSet, oldExchangeRate, exchangeRate);\n    }\n  }\n\n  /**\n   * @notice Override admin function for changing the representation of the\n   *         amount of collateral a user has deposited to kick off minting\n   *         process\n   *\n   * @param user       The user whose balance is being set\n   * @param epoch      The epoch in which to set user balance for\n   * @param oldBalance The user's previous balance\n   * @param newBalance The user's new balance to set\n   *\n   * @dev The total burned amount for the epoch must be set appropriately\n   *      in order to correctly calculate redemptions.\n   * @dev `oldBalance` is provided to prevent front running attacks where a\n   *      user could attempt to claim before and after this is set.\n   */\n  function setPendingMintBalance(\n    address user,\n    uint256 epoch,\n    uint256 oldBalance,\n    uint256 newBalance\n  ) external updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (oldBalance != mintRequestsPerEpoch[epoch][user]) {\n      revert UnexpectedMintBalance();\n    }\n    if (epoch > currentEpoch) {\n      revert CannotServiceFutureEpoch();\n    }\n    mintRequestsPerEpoch[epoch][user] = newBalance;\n    emit PendingMintBalanceSet(user, epoch, oldBalance, newBalance);\n  }\n\n  /**\n   * @notice Allows for the `MANAGER_ADMIN` to arbitrarily set an exchange\n   *         rate for a given epoch\n   *\n   * @param correctExchangeRate      The exchange rate we wish to update to\n   * @param epochToSet               The epoch for which we want to set the rate\n   * @param _lastSetMintExchangeRate Value to set `lastSetMintExchangeRate` to\n   *                                 if not equal to 0\n   *\n   * @dev This function allows the caller to also update the\n   *      `lastSetMintExchangeRate`, which is compared against\n   *      when calling `setMintExchangeRate` to prevent large\n   *      swings in prices.\n   */\n  function overrideExchangeRate(\n    uint256 correctExchangeRate,\n    uint256 epochToSet,\n    uint256 _lastSetMintExchangeRate\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (epochToSet >= currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    uint256 incorrectRate = epochToExchangeRate[epochToSet];\n    epochToExchangeRate[epochToSet] = correctExchangeRate;\n    if (_lastSetMintExchangeRate != 0) {\n      lastSetMintExchangeRate = _lastSetMintExchangeRate;\n    }\n    emit MintExchangeRateOverridden(\n      epochToSet,\n      incorrectRate,\n      correctExchangeRate,\n      lastSetMintExchangeRate\n    );\n  }\n\n  /**\n   * @notice Sets mint exchange rate delta limit\n   *\n   * @param _exchangeRateDeltaLimit New mint exchange rate delta limit (in bps)\n   */\n  function setMintExchangeRateDeltaLimit(\n    uint256 _exchangeRateDeltaLimit\n  ) external override onlyRole(MANAGER_ADMIN) {\n    uint256 oldExchangeRateDeltaLimit = exchangeRateDeltaLimit;\n    exchangeRateDeltaLimit = _exchangeRateDeltaLimit;\n    emit ExchangeRateDeltaLimitSet(\n      oldExchangeRateDeltaLimit,\n      _exchangeRateDeltaLimit\n    );\n  }\n\n  /**\n   * @notice Sets mint fee\n   *\n   * @param _mintFee new mint fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setMintFee(\n    uint256 _mintFee\n  ) external override onlyRole(MANAGER_ADMIN) {\n    if (_mintFee >= BPS_DENOMINATOR) {\n      revert MintFeeTooLarge();\n    }\n    uint256 oldMintFee = mintFee;\n    mintFee = _mintFee;\n    emit MintFeeSet(oldMintFee, _mintFee);\n  }\n\n  /**\n   * @notice Sets minimum deposit amount\n   *\n   * @param _minimumDepositAmount New minimum deposit amount\n   *                              (in decimals specified by `collateral`)\n   *\n   * @dev Must be larger than BPS_DENOMINATOR due to keep our `_getMintFees`\n   *      calculation correct. For example, if a deposit amount is less than\n   *      BPS_DENOMINAOR (say 9999) and `mintFee` = 1,\n   *      (collateralAmount * mintFee) / BPS_DENOMINATOR will incorrectly\n   *      return 0.\n   */\n  function setMinimumDepositAmount(\n    uint256 _minimumDepositAmount\n  ) external override onlyRole(MANAGER_ADMIN) {\n    if (_minimumDepositAmount < BPS_DENOMINATOR) {\n      revert MinimumDepositAmountTooSmall();\n    }\n    uint256 oldMinimumDepositAmount = minimumDepositAmount;\n    minimumDepositAmount = _minimumDepositAmount;\n    emit MinimumDepositAmountSet(\n      oldMinimumDepositAmount,\n      _minimumDepositAmount\n    );\n  }\n\n  /**\n   * @notice Sets fee recipient\n   *\n   * @param _feeRecipient New fee recipient address\n   */\n  function setFeeRecipient(\n    address _feeRecipient\n  ) external override onlyRole(MANAGER_ADMIN) {\n    address oldFeeRecipient = feeRecipient;\n    feeRecipient = _feeRecipient;\n    emit FeeRecipientSet(oldFeeRecipient, _feeRecipient);\n  }\n\n  /**\n   * @notice Sets asset recipient\n   *\n   * @param _assetRecipient New asset recipient address\n   */\n  function setAssetRecipient(\n    address _assetRecipient\n  ) external override onlyRole(MANAGER_ADMIN) {\n    address oldAssetRecipient = assetRecipient;\n    assetRecipient = _assetRecipient;\n    emit AssetRecipientSet(oldAssetRecipient, _assetRecipient);\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much CASH should be\n   *         minted\n   *\n   * @param collateralAmountIn Amount of `collateral` to exchange\n   *                           (in 18 decimals)\n   * @param epoch              The epoch we want to set the rate\n   *                           for\n   *\n   * @return cashAmountOut The amount of cash to be returned\n   *\n   * @dev Scales to 24 decimals to divide by exchange rate in 6 decimals,\n   *      bringing us down to 18 decimals of precision\n   */\n  function _getMintAmountForEpoch(\n    uint256 collateralAmountIn,\n    uint256 epoch\n  ) private view returns (uint256 cashAmountOut) {\n    uint256 amountE24 = _scaleUp(collateralAmountIn) * 1e6;\n    cashAmountOut = amountE24 / epochToExchangeRate[epoch];\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how\n   *\n   *\n   * @param collateralAmount Amount `collateral` to exchange\n   *                         (in decimals of `collateral`)\n   */\n  function _getMintFees(\n    uint256 collateralAmount\n  ) private view returns (uint256) {\n    return (collateralAmount * mintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Scale provided amount up by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting the collateral's decimals\n   *      representation to the CASH amount decimals representation.\n   */\n  function _scaleUp(uint256 amount) private view returns (uint256) {\n    return amount * decimalsMultiplier;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Pause Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Will pause minting functionality of this contract\n   *\n   */\n  function pause() external onlyRole(PAUSER_ADMIN) {\n    _pause();\n  }\n\n  /**\n   * @notice Will unpause minting functionality of this contract\n   */\n  function unpause() external onlyRole(MANAGER_ADMIN) {\n    _unpause();\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Epoch and Rate Limiting Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Update the duration of one epoch\n   *\n   * @param _epochDuration The epoch duration in seconds\n   */\n  function setEpochDuration(\n    uint256 _epochDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldEpochDuration = epochDuration;\n    epochDuration = _epochDuration;\n    emit EpochDurationSet(oldEpochDuration, _epochDuration);\n  }\n\n  /**\n   * @notice Modifier to transition epoch\n   */\n  modifier updateEpoch() {\n    transitionEpoch();\n    _;\n  }\n\n  /**\n   * @notice Transition to another epoch\n   *\n   * @dev Should be called prior to `_checkAndUpdateRedeemLimit`\n   *      and `_checkAndUpdateMintLimit`\n   * @dev Epochs do not always have to be incremented by 1\n   *\n   * @notice If this function determines to transition the epoch\n   *         1) The total supply at the end of the epoch is stored\n   *         2) `currentRedeemAmount` & `currentMintAmount` are set to 0\n   *         3) `currentEpoch` is incremented by number of epochs that\n   *            have elapsed\n   *         4) `currentEpochStartTimestamp` is set.\n   */\n  function transitionEpoch() public {\n    uint256 epochDifference = (block.timestamp - currentEpochStartTimestamp) /\n      epochDuration;\n    if (epochDifference > 0) {\n      currentRedeemAmount = 0;\n      currentMintAmount = 0;\n      currentEpoch += epochDifference;\n      currentEpochStartTimestamp =\n        block.timestamp -\n        (block.timestamp % epochDuration);\n    }\n  }\n\n  /**\n   * @notice Update the amount of token that can be minted during one epoch\n   *\n   * @param _mintLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function setMintLimit(uint256 _mintLimit) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldMintLimit = mintLimit;\n    mintLimit = _mintLimit;\n    emit MintLimitSet(oldMintLimit, _mintLimit);\n  }\n\n  /**\n   * @notice Update the amount of token that can be redeemed during one epoch\n   *\n   * @param _redeemLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function setRedeemLimit(\n    uint256 _redeemLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldRedeemLimit = redeemLimit;\n    redeemLimit = _redeemLimit;\n    emit RedeemLimitSet(oldRedeemLimit, _redeemLimit);\n  }\n\n  /**\n   * @notice Checks the requested mint amount against the rate limiter\n   *\n   * @param collateralAmountIn The requested mint amount\n   *\n   * @dev Reverts if the requested mint amount exceeds the current limit\n   * @dev Should only be called w/n functions w/ `updateEpoch` modifier\n   */\n  function _checkAndUpdateMintLimit(uint256 collateralAmountIn) private {\n    if (collateralAmountIn > mintLimit - currentMintAmount) {\n      revert MintExceedsRateLimit();\n    }\n\n    currentMintAmount += collateralAmountIn;\n  }\n\n  /**\n   * @notice Checks the requested redeem amount against the rate limiter\n   *\n   * @param amount The requested redeem amount\n   *\n   * @dev Reverts if the requested redeem amount exceeds the current limit\n   * @dev Should only be called w/n function w/ `updateEpoch` modifier\n   */\n  function _checkAndUpdateRedeemLimit(uint256 amount) private {\n    if (amount == 0) {\n      revert RedeemAmountCannotBeZero();\n    }\n    if (amount > redeemLimit - currentRedeemAmount) {\n      revert RedeemExceedsRateLimit();\n    }\n\n    currentRedeemAmount += amount;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Redeem Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a RedemptionRequests member to the current epoch array &\n   *         burns tokens\n   *\n   * @param amountCashToRedeem The requested redeem amount\n   */\n  function requestRedemption(\n    uint256 amountCashToRedeem\n  )\n    external\n    override\n    updateEpoch\n    nonReentrant\n    whenNotPaused\n    checkKYC(msg.sender)\n  {\n    if (amountCashToRedeem < minimumRedeemAmount) {\n      revert WithdrawRequestAmountTooSmall();\n    }\n\n    _checkAndUpdateRedeemLimit(amountCashToRedeem);\n\n    redemptionInfoPerEpoch[currentEpoch].addressToBurnAmt[\n        msg.sender\n      ] += amountCashToRedeem;\n    redemptionInfoPerEpoch[currentEpoch].totalBurned += amountCashToRedeem;\n\n    cash.burnFrom(msg.sender, amountCashToRedeem);\n\n    emit RedemptionRequested(msg.sender, amountCashToRedeem, currentEpoch);\n  }\n\n  /**\n   * @notice Allows for an admin account to distribute collateral to users\n   *         based off of the total amount of cash tokens burned w/n a given\n   *         epoch. This function also allows for an admin to refund redemption\n   *         requests w/n an epoch provided that the redemption cannot be\n   *         serviced\n   *\n   * @param redeemers              List of addresses to which we want to\n   *                               issue redemptions to\n   * @param refundees              List of addresses to which we want to issue\n   *                               refunds to in the form of cash tokens\n   * @param collateralAmountToDist The total amount to distribute for redemptions\n   *                               including fees to accrue to Ondo\n   *                               (In units of collateral)\n   * @param epochToService         The epoch number we wish to issue redemptions/\n   *                               refunds for\n   * @param fees                   The amount of fees to send to Ondo\n   *                               (In units of collateral)\n   */\n  function completeRedemptions(\n    address[] calldata redeemers,\n    address[] calldata refundees,\n    uint256 collateralAmountToDist,\n    uint256 epochToService,\n    uint256 fees\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    _checkAddressesKYC(redeemers);\n    _checkAddressesKYC(refundees);\n    if (epochToService >= currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    // Calculate the total quantity of shares tokens burned w/n an epoch\n    uint256 refundedAmt = _processRefund(refundees, epochToService);\n    uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n      .totalBurned - refundedAmt;\n    uint256 amountToDist = collateralAmountToDist - fees;\n    _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n    collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n    emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n  }\n\n  /**\n   * @notice Will iterate over the array of `addressToWithdraw` calculate\n   *         the proportion of burned tokens w/n a given epoch and will\n   *         then distribute collateral based off this % of burned tokens\n   *\n   * @param redeemers      List of addresses we are issuing redemptions too\n   * @param amountToDist   The amount to distribute to clients minus the\n   *                       the fee amount taken by Ondo\n   * @param quantityBurned The total amount of tokens burned in an epoch\n   *                       minus those burned by users who are issued a\n   *                       refund\n   * @param epochToService The epoch we wish to service redemptions and\n   *                       redemptions for\n   */\n  function _processRedemption(\n    address[] calldata redeemers,\n    uint256 amountToDist,\n    uint256 quantityBurned,\n    uint256 epochToService\n  ) private {\n    uint256 size = redeemers.length;\n    for (uint256 i = 0; i < size; ++i) {\n      address redeemer = redeemers[i];\n      uint256 cashAmountReturned = redemptionInfoPerEpoch[epochToService]\n        .addressToBurnAmt[redeemer];\n      redemptionInfoPerEpoch[epochToService].addressToBurnAmt[redeemer] = 0;\n      uint256 collateralAmountDue = (amountToDist * cashAmountReturned) /\n        quantityBurned;\n\n      if (collateralAmountDue == 0) {\n        revert CollateralRedemptionTooSmall();\n      }\n\n      collateral.safeTransferFrom(assetSender, redeemer, collateralAmountDue);\n      emit RedemptionCompleted(\n        redeemer,\n        cashAmountReturned,\n        collateralAmountDue,\n        epochToService\n      );\n    }\n  }\n\n  /**\n   * @notice Iterates over the array of `addressToRefund` and mint them\n   *         back the same quantity of cash tokens burned.\n   *\n   * @param refundees      List of addresses we are issuing refunds for\n   * @param epochToService The epoch we wish to service redemptions for\n   *\n   * @return totalCashAmountRefunded The total amount of cash refunded for `epochToService`.\n   */\n  function _processRefund(\n    address[] calldata refundees,\n    uint256 epochToService\n  ) private returns (uint256 totalCashAmountRefunded) {\n    uint256 size = refundees.length;\n    for (uint256 i = 0; i < size; ++i) {\n      address refundee = refundees[i];\n      uint256 cashAmountBurned = redemptionInfoPerEpoch[epochToService]\n        .addressToBurnAmt[refundee];\n      redemptionInfoPerEpoch[epochToService].addressToBurnAmt[refundee] = 0;\n      cash.mint(refundee, cashAmountBurned);"
    }
  ]
}