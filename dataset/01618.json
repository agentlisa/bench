{
  "Title": "M-6: `partyA` can inflate the uPnL with no cost",
  "Content": "# Issue M-6: `partyA` can inflate the uPnL with no cost \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/181 \n\n## Found by \nshaka\n## Summary\n\n`partyA` can inflate the uPnL with no cost by opening a long position of order type limit with an `openedPrice` of 0, using a `partyB` account that is also controlled by `partyA`.\n\n## Vulnerability Detail\n\nIn the `PartyBFacetImpl:openPosition` function, when the position type is long there is no minimum for the `openedPrice`. Also, if the `openedPrice` is lower than the `requestedOpenPrice`, the proportional locked values are unlocked. This means that for a long position of order type limit party B can send an `openedPrice` of 0 and result in no locked values.\n\nThis could be done by a partyA to inflate the uPnL with no cost. See the following example:\n\n1. Party A creates a quote with the following parameters:\n    - partyBsWhiteList: [bob]\n    - positionType: LONG\n    - orderType: LIMIT\n    - price: 100e18\n    - quantity: 1e18\n    - cva: 22e18,\n    - mm: 75e18\n    - lf: 3e18\n\n2. Party A also controls the bob account and uses it to open a position with the following parameters:\n    - filledAmount: 1e18\n    - requestedOpenPrice: 0\n\n3. As a result, there is no locked values and the uPnL of party A is inflated by `(currentPrice - 0) * 1e18`.\n\nThis temporary inflation of the uPnL will be corrected when party B is liquidated. However, there are two things to consider:\n- There is no incentive for liquidators to liquidate the position, since the liquidation fee is 0. So it will have to be done by the liquidator bot.\n- There is a liquidation timeout that will delay the liquidation process. Currently this value is set to 1 day in the Fantom mainnet.\n\nParty A can also repeat the process with different accounts to keep the uPnL inflated.\n\n## Impact\n\nParty A can inflate the uPnL with no cost, which could be used to avoid liquidations and wait until the prices on other positions are favorable.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L136-L167\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nA possible solution would be checking that the `openedPrice` is inside a certain range.\n\n\n\n\n## Discussion\n\n**shaka0x**\n\nEscalate.\n\nThe issue has been marked incorrectly as a duplicate of #350. That issue is about how submitting a very large value for `openPrice` can cause overflow/underflow in forward calculations.\n\nThis issue shows how passing an `openPrice` of 0 can be used to inflate the uPnL of another account. So I think this one should be considered as a valid issue.\n\n**sherlock-admin2**\n\n > Escalate.\n> \n> The issue has been marked incorrectly as a duplicate of #350. That issue is about how submitting a very large value for `openPrice` can cause overflow/underflow in forward calculations.\n> \n> This issue shows how passing an `openPrice` of 0 can be used to inflate the uPnL of another account. So I think this one should be considered as a valid issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\n@ctf-sec \n\n**panprog**\n\nThis looks like a duplicate of #225 to me. The core reason is the same (scaled balances for LIMIT orders). The impact, as I see it, is that due to lockedBalances = 0, **any** market price change will make either party liquidatable with bad debt, meaning that the profit for the other party will be slightly reduced due to bad debt. I see no other benefit to either party:\nPartyA upnl is inflated by PartyB loss: PartyB will not be allowed to openPosition if it doesn't have enough allocatedBalance to cover PartyA profit. So in the example from the report:\n- PartyA will have unrealized profit of 100\n- PartyB will have unrealized loss of -100, and it can only openPosition if it has allocatedBalance = 100\n\nSo it's not like PartyA has unrealized profit for free - partyB must have the same amount allocated to open the position.\nI'm not sure if this impact is high enough to be medium. It's hard to use this self-inflicted bad debt. So either this is duplicate of #225 or low impact.\n\n**shaka0x**\n\n> This looks like a duplicate of #225 to me. The core reason is the same (scaled balances for LIMIT orders). The impact, as I see it, is that due to lockedBalances = 0, **any** market price change will make either party liquidatable with bad debt, meaning that the profit for the other party will be slightly reduced due to bad debt. I see no other benefit to either party: PartyA upnl is inflated by PartyB loss: PartyB will not be allowed to openPosition if it doesn't have enough allocatedBalance to cover PartyA profit. So in the example from the report:\n\n> * PartyA will have unrealized profit of 100\n> * PartyB will have unrealized loss of -100, and it can only openPosition if it has allocatedBalance = 100\n\n> So it's not like PartyA has unrealized profit for free - partyB must have the same amount allocated to open the position. I'm not sure if this impact is high enough to be medium. It's hard to use this self-inflicted bad debt. So either this is duplicate of #225 or low impact.\n\nThis issue differs completely from #255. Neither the root cause, nor the impact or the fix are similar.\n\nPartyA does have an unrealized profit for free. Once partyB is liquidated, the 100 will go to partyA so, as both accounts are controlled by the same person and there is no liquidation fee involved, there is no cost to perform the operation. Until the liquidation process for partyB is completed (remember that there is a minimum delay and that there are no economic incentives for liquidators) partyA has managed to inflate his global uPnL, avoiding a potential liquidation.\n\n\n**panprog**\n\n@shaka0x I don't understand why you call this inflated upnl if it's just funds of the user. Can you describe better?\nScenario 1:\nUser has $200. He deposits and allocates all $200 into partyA account. He has allocated balance of 200 + 0 (unrealized pnl) - total of 200 available for the positions.\n\nScenario 2:\nUser has $200. He deposits and allocates 100 to partyA and 100 to controlled partyB account. He then opens the position described in this report between partyA and partyB. Now partyA has 100 (balance) + 100 (upnl) = 200 available for positions, while partyB has 100 (balance) - 100 (upnl) = 0 available. If partyB is liquidated, the situation will be exactly as in scenario 1: PartyA balance will be 200, upnl 0, PartyB balance will be 0.\n\nSo what's the difference between scenario 1 and 2? Why partyA needs to deposit funds to partyB and create upnl with it, when it can simply deposit these funds directly to partyA account?\n\n**shaka0x**\n\n> @shaka0x I don't understand why you call this inflated upnl if it's just funds of the user. Can you describe better? Scenario 1: User has $200. He deposits and allocates all $200 into partyA account. He has allocated balance of 200 + 0 (unrealized pnl) - total of 200 available for the positions.\n> \n> Scenario 2: User has $200. He deposits and allocates 100 to partyA and 100 to controlled partyB account. He then opens the position described in this report between partyA and partyB. Now partyA has 100 (balance) + 100 (upnl) = 200 available for positions, while partyB has 100 (balance) - 100 (upnl) = 0 available. If partyB is liquidated, the situation will be exactly as in scenario 1: PartyA balance will be 200, upnl 0, PartyB balance will be 0.\n> \n> So what's the difference between scenario 1 and 2? Why partyA needs to deposit funds to partyB and create upnl with it, when it can simply deposit these funds directly to partyA account?\n\nIn scenario 1 uPnL is 0, as uPnL is calculated based on the open positions. In the difference between the opened price and the current price to be more precise.\n\n**hrishibhat**\n\nSponsor comment:\n>  the auditor has identified a valid bug. We must verify locked values at the time of opening. While we do check it for partial fillings, we overlooked it for complete fillings.\n\n**panprog**\n\nSponsor's response implies the fix is to verify that locked values are not less than `minAcceptableQuoteValue` and this can only happen due to `lockedValues` being scaled.\n- The fix for #225 is adding solvency check after `lockedValues` are scaled\n- The fix for this issue is adding `lockedValues > minAcceptableQuoteValue` check after `lockedValues` are scaled\n- The impact of both #225 and this one are probably medium (scenarios are completely different, but the impact is still medium)\n\nI still think this is duplicate of #225 because core reason is that scaled `lockedValues` are not accounted for. However, since the condition which should be checked is different, this might be a separate issue.\n\n**MoonKnightDev**\n\nFixed code PR link: \nhttps://github.com/SYMM-IO/symmio-core/pull/25\n\n**hrishibhat**\n\n@shaka0x \nLet me know what you think of this comment: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/181#issuecomment-1685204613\n\n**shaka0x**\n\n@hrishibhat this are my thoughts\n\n> Sponsor's response implies the fix is to verify that locked values are not less than `minAcceptableQuoteValue` and this can only happen due to `lockedValues` being scaled.\n> \n> * The fix for [xiaoming90 - Users might immediately be liquidated after position opening leading to a loss of CVA and Liquidation fee #225](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/225) is adding solvency check after `lockedValues` are scaled\n> * The fix for this issue is adding `lockedValues > minAcceptableQuoteValue` check after `lockedValues` are scaled\n\nAgree, the fix is different, as seen in the PRs shown by the sponsor.\n\n> * The impact of both [xiaoming90 - Users might immediately be liquidated after position opening leading to a loss of CVA and Liquidation fee #225](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/225) and this one are probably medium (scenarios are completely different, but the impact is still medium)\n\nAgree that the impact scenarios are different (instant liquidation of user vs user avoiding liquidation by inflating his uPnL). However, I do think that a user being able to avoid liquidation by manipulating his uPnL is a high severity issue.\n\n> I still think this is duplicate of #225 because core reason is that scaled `lockedValues` are not accounted for. However, since the condition which should be checked is different, this might be a separate issue.\n\nI do not see the root cause of the issues to be the same at all. #255 's is that the check for solvency is done before the adjustment on `lockedValues`. The root cause of this issue is that a party B can inflate the uPnL of party A, and if they are the same person, this will have no cost, as `lockedValue` = 0.\n\nIn fact, although the fix https://github.com/SYMM-IO/symmio-core/pull/25 is a good addition, I would argue that is still not enough to mitigate the issue. By checking that `lockedValue` is above `minAcceptableQuoteValue`, the uPnL manipulation is not free anymore. But depending on the value of `minAcceptableQuoteValue`, the amount subject to liquidation for party A and the liquidation timeout, a user might still be incentiviced to inflate his uPnL though this operation. That is why my recommendation was checking that the `openedPrice` is inside a certain range.\n\n\n\n**panprog**\n\n> However, I do think that a user being able to avoid liquidation by manipulating his uPnL is a high severity issue.\n\nThe scenario presented uses controlled partyB account which is whitelisted by the protocol and any malicious actions with it are at most medium (as seen from many other issues with partyBs).\n\n> the amount subject to liquidation for party A and the liquidation timeout, a user might still be incentiviced to inflate his uPnL though this operation.\n\nLiquidation timeout doesn't delay the liquidation process, it's just the time acceptable between liquidation steps, so it has nothing to do with this issue here.\nI can only see the impact of user inflating his upnl via partyB when the locked values = 0: then as soon as the price moves, the one side (partyB) will have bad debt and once liquidated, the other side (partyA) will have it's unrealized profit reduce immediately by bad debt, which can in turn make partyA liquidatable with bad debt (highly unlikely scenario, but still possible). Additionally, liquidators are not incentivized to liquidate such partyB due to locked balance = 0 and no profit for the liquidator.\n\nIf locked balances are enforced to be minAcceptableQuoteValue: what is the impact that the user can make his partyA account in large profit? I don't see any impact here. If partyB is liquidated, partyA will realize its profit (+cva), so no other party can lose funds due to this. And unrealized profit by itself is not an issue: it can happen naturally as well, what's the benefit for the user to have unrealized profit rather than balance? The original issue was exactly due to locked balance = 0.\n\n**shaka0x**\n\n> > However, I do think that a user being able to avoid liquidation by manipulating his uPnL is a high severity issue.\n> \n> The scenario presented uses controlled partyB account which is whitelisted by the protocol and any malicious actions with it are at most medium (as seen from many other issues with partyBs).\n\n[Message 1](https://discord.com/channels/812037309376495636/1118917849482793071/1121341606746931260)\n`for partyB it can also be assumed that anyone can be one (eventually that is the goal)`\n\n[Message 2](https://discord.com/channels/812037309376495636/1118917849482793071/1122523839277039617)\n`the system will be permissionless (anyone can become a counterparty), so consider them not trusted`\n`neither party should have any special privileges in the system`\n\n> > the amount subject to liquidation for party A and the liquidation timeout, a user might still be incentiviced to inflate his uPnL though this operation.\n> \n> Liquidation timeout doesn't delay the liquidation process, it's just the time acceptable between liquidation steps, so it has nothing to do with this issue here. \n\nYou are right. I was mistakenly interpreting it as a cooldown period.\n\n>I can only see the impact of user inflating his upnl via partyB when the locked values = 0: then as soon as the price moves, the one side (partyB) will have bad debt and once liquidated, the other side (partyA) will have it's unrealized profit reduce immediately by bad debt, which can in turn make partyA liquidatable with bad debt (highly unlikely scenario, but still possible). Additionally, liquidators are not incentivized to liquidate such partyB due to locked balance = 0 and no profit for the liquidator.\n>\n> If locked balances are enforced to be minAcceptableQuoteValue: what is the impact that the user can make his partyA account in large profit? I don't see any impact here. If partyB is liquidated, partyA will realize its profit (+cva), so no other party can lose funds due to this. And unrealized profit by itself is not an issue: it can happen naturally as well, what's the benefit for the user to have unrealized profit rather than balance? The original issue was exactly due to locked balance = 0.\n\nFrom the moment party B opens the position until the moment party B is liquidated, party A manages to avoid liquidation. So basically party A is buying time for his positions to recover (the market prices can change in his favor). It is true that being an incentive for liquidators (`lockedValue` not zero) it is likely that this time window will not be as long as in the case when there is not such incentive. But depending on the amount party A has at risk of liquidation and his expectations about the market, might still be interested in paying the cost of the `lockedValue` in order to freeze his liquidation process for longer.\n\nAnyway, that comment was just about my thoughts of the sponsor's fix. With the current code I think that the potential damage is clear.\n\n\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nBased on the above discussion considering its a valid medium \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [shaka0x](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/181/#issuecomment-1653986507): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyBFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        }\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n        quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n\n    function unlockQuote(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.LOCKED, \"PartyBFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            QuoteStatus result = LibQuote.expireQuote(quoteId);\n            return result;\n        } else {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.PENDING;\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyBPendingQuotes(quote);\n            quote.partyB = address(0);\n            return QuoteStatus.PENDING;\n        }\n    }\n\n    function acceptCancelRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyBFacet: Invalid state\");\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function checkPartyBValidationToLockQuote(uint256 quoteId, int256 upnl) internal view {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.PENDING, \"PartyBFacet: Invalid state\");\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(quoteId <= quoteLayout.lastId, \"PartyBFacet: Invalid quoteId\");\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnl,\n            msg.sender,\n            quote.partyA\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >= quote.lockedValues.total(),\n            \"PartyBFacet: insufficient available balance\"\n        );\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][quote.partyA],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        bool isValidPartyB;\n        if (quote.partyBsWhiteList.length == 0) {\n            require(msg.sender != quote.partyA, \"PartyBFacet: PartyA can't be partyB too\");\n            isValidPartyB = true;\n        } else {\n            for (uint8 index = 0; index < quote.partyBsWhiteList.length; index++) {\n                if (msg.sender == quote.partyBsWhiteList[index]) {\n                    isValidPartyB = true;\n                    break;\n                }\n            }\n        }\n        require(isValidPartyB, \"PartyBFacet: Sender isn't whitelisted\");\n    }\n\n    function openPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.orderType == OrderType.LIMIT) {\n            require(\n                quote.quantity >= filledAmount && filledAmount > 0,\n                \"PartyBFacet: Invalid filledAmount\"\n            );\n        } else {\n            require(quote.quantity == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                openedPrice <= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        } else {\n            require(\n                openedPrice >= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        }\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n\n        quote.openedPrice = openedPrice;\n        LibSolvency.isSolventAfterOpenPosition(quoteId, filledAmount, upnlSig);\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n\n        LibQuote.removeFromPendingQuotes(quote);\n\n        if (quote.quantity == filledAmount) {\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n            if (quote.orderType == OrderType.LIMIT) {\n                quote.lockedValues.mul(openedPrice).div(quote.requestedOpenPrice);\n            }\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        // partially fill\n        else {\n            currentId = ++quoteLayout.lastId;\n            QuoteStatus newStatus;\n            if (quote.quoteStatus == QuoteStatus.CANCEL_PENDING) {\n                newStatus = QuoteStatus.CANCELED;\n            } else {\n                newStatus = QuoteStatus.PENDING;\n                quoteLayout.partyAPendingQuotes[quote.partyA].push(currentId);\n            }\n            LockedValues memory filledLockedValues = LockedValues(\n                (quote.lockedValues.cva * filledAmount) / quote.quantity,\n                (quote.lockedValues.mm * filledAmount) / quote.quantity,\n                (quote.lockedValues.lf * filledAmount) / quote.quantity\n            );\n            LockedValues memory appliedFilledLockedValues = filledLockedValues;\n            appliedFilledLockedValues = appliedFilledLockedValues.mulMem(openedPrice);\n            appliedFilledLockedValues = appliedFilledLockedValues.divMem(quote.requestedOpenPrice);\n            // check that opened position is not minor position\n            require(\n                appliedFilledLockedValues.total() >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n            // check that new pending position is not minor position\n            require(\n                (quote.lockedValues.total() - filledLockedValues.total()) >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n\n            Quote memory q = Quote({\n                id: currentId,\n                partyBsWhiteList: quote.partyBsWhiteList,\n                symbolId: quote.symbolId,\n                positionType: quote.positionType,\n                orderType: quote.orderType,\n                openedPrice: 0,\n                requestedOpenPrice: quote.requestedOpenPrice,\n                marketPrice: quote.marketPrice,\n                quantity: quote.quantity - filledAmount,\n                closedAmount: 0,\n                lockedValues: LockedValues(0, 0, 0),\n                initialLockedValues: LockedValues(0, 0, 0),\n                maxInterestRate: quote.maxInterestRate,\n                partyA: quote.partyA,\n                partyB: address(0),\n                quoteStatus: newStatus,\n                avgClosedPrice: 0,\n                requestedClosePrice: 0,\n                parentId: quote.id,\n                createTimestamp: quote.createTimestamp,\n                modifyTimestamp: block.timestamp,\n                quantityToClose: 0,\n                deadline: quote.deadline\n            });\n\n            quoteLayout.quoteIdsOf[quote.partyA].push(currentId);\n            quoteLayout.quotes[currentId] = q;\n            Quote storage newQuote = quoteLayout.quotes[currentId];\n\n            if (newStatus == QuoteStatus.CANCELED) {\n                // send trading Fee back to partyA\n                LibQuote.returnTradingFee(currentId);\n                // part of quote has been filled and part of it has been canceled\n                accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n            } else {\n                accountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].sub(\n                    filledLockedValues\n                );\n            }\n            newQuote.lockedValues = quote.lockedValues.sub(filledLockedValues);\n            newQuote.initialLockedValues = newQuote.lockedValues;\n            quote.quantity = filledAmount;\n            quote.lockedValues = appliedFilledLockedValues;\n\n            // lock with amount of filledAmount\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        quote.quoteStatus = QuoteStatus.OPENED;\n        LibQuote.addToOpenPositions(quoteId);\n    }\n\n    function fillCloseRequest(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                closedPrice >= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        } else {\n            require(\n                closedPrice <= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        }\n        if (quote.orderType == OrderType.LIMIT) {\n            require(quote.quantityToClose >= filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        } else {\n            require(quote.quantityToClose == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, closedPrice, upnlSig);\n\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, closedPrice);\n    }\n\n    function acceptCancelCloseRequest(uint256 quoteId) internal {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        AccountStorage.layout().partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function emergencyClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyBFacet: Invalid state\");\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        uint256 filledAmount = LibQuote.quoteOpenAmount(quote);\n        quote.quantityToClose = filledAmount;\n        quote.requestedClosePrice = upnlSig.price;\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, upnlSig.price, upnlSig);\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, upnlSig.price);\n    }\n\n}"
    }
  ]
}