{
  "Title": "GMXVault can stop working in case if GMX will change `Keys.MAX_CALLBACK_GAS_LIMIT` to smaller than 2 millions",
  "Content": "# GMXVault can stop working in case if GMX will change `Keys.MAX_CALLBACK_GAS_LIMIT` to smaller than 2 millions\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXWorker.sol#L60\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXWorker.sol#L60</a>\n\n\n## Summary\nKeys.MAX_CALLBACK_GAS_LIMIT is configurable param inside GMX protocol, which can be changed to value that is smaller than 2 millions. As Steadefi doesn't callback gas limit is hardcoded, deposits and withdraws can fail.\n## Vulnerability Details\nGMXWorker library is used to send requests directly to GMX protocol. It contains `addLiquidity` and `removeLiquidity` functions that will create request on GMX and will be waiting for execution. Both these functions [set 2 millions of gas](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXWorker.sol#L102) as `callbackGasLimit`.\n\nWhen deposit or withdraw request is handled on GMX side, then [`callbackGasLimit` is validated](https://github.com/gmx-io/gmx-synthetics/blob/main/contracts/deposit/DepositUtils.sol#L126) to be [not bigger than it's allowed](https://github.com/gmx-io/gmx-synthetics/blob/main/contracts/callback/CallbackUtils.sol#L54-L57). `Keys.MAX_CALLBACK_GAS_LIMIT` value is configurable and can be changed by GMX team. And in case if it will be less than 2 million, then all deposits and withdraws requests from steadefi will be reverted.\n\nI leave this as medium severity, because of the fact that callback limit should be decreased first in order to create problems.\n## Impact\nDeposits and withdraws from steadefi will be blocked.\n## Tools Used\nVsCode\n## Recommendations\nMake `callbackGasLimit` to be configurable.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXWorker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IExchangeRouter } from  \"../../interfaces/protocols/gmx/IExchangeRouter.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\n\nlibrary GMXWorker {\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @dev Add strategy's tokens for liquidity and receive LP tokens\n    * @param self Vault store data\n    * @param alp GMXTypes.AddLiquidityParams\n    * @return depositKey Hashed key of created deposit in bytes32\n  */\n  function addLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.AddLiquidityParams memory alp\n  ) external returns (bytes32) {\n    // Send native token for execution fee\n    self.exchangeRouter.sendWnt{ value: alp.executionFee }(\n      self.depositVault,\n      alp.executionFee\n    );\n\n    // Send tokens\n    self.exchangeRouter.sendTokens(\n      address(self.tokenA),\n      self.depositVault,\n      alp.tokenAAmt\n    );\n\n    self.exchangeRouter.sendTokens(\n      address(self.tokenB),\n      self.depositVault,\n      alp.tokenBAmt\n    );\n\n    // Create deposit\n    IExchangeRouter.CreateDepositParams memory _cdp =\n      IExchangeRouter.CreateDepositParams({\n        receiver: address(this),\n        callbackContract: self.callback,\n        uiFeeReceiver: self.refundee,\n        market: address(self.lpToken),\n        initialLongToken: address(self.tokenA),\n        initialShortToken: address(self.tokenB),\n        longTokenSwapPath: new address[](0),\n        shortTokenSwapPath: new address[](0),\n        minMarketTokens: alp.minMarketTokenAmt,\n        shouldUnwrapNativeToken: false,\n        executionFee: alp.executionFee,\n        callbackGasLimit: 2000000\n      });\n\n    return self.exchangeRouter.createDeposit(_cdp);\n  }\n\n  /**\n    * @dev Remove liquidity of strategy's LP token and receive underlying tokens\n    * @param self Vault store data\n    * @param rlp GMXTypes.RemoveLiquidityParams\n    * @return withdrawKey Hashed key of created withdraw in bytes32\n  */\n  function removeLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.RemoveLiquidityParams memory rlp\n  ) external returns (bytes32) {\n    // Send native token for execution fee\n    self.exchangeRouter.sendWnt{value: rlp.executionFee }(\n      self.withdrawalVault,\n      rlp.executionFee\n    );\n\n    // Send GM LP tokens\n    self.exchangeRouter.sendTokens(\n      address(self.lpToken),\n      self.withdrawalVault,\n      rlp.lpAmt\n    );\n\n    // Create withdrawal\n    IExchangeRouter.CreateWithdrawalParams memory _cwp =\n      IExchangeRouter.CreateWithdrawalParams({\n        receiver: address(this),\n        callbackContract: self.callback,\n        uiFeeReceiver: self.refundee,\n        market: address(self.lpToken),\n        longTokenSwapPath: rlp.tokenASwapPath,\n        shortTokenSwapPath: rlp.tokenBSwapPath,\n        minLongTokenAmount: rlp.minTokenAAmt,\n        minShortTokenAmount: rlp.minTokenBAmt,\n        shouldUnwrapNativeToken: false,\n        executionFee: rlp.executionFee,\n        callbackGasLimit: 2000000\n      });\n\n    return self.exchangeRouter.createWithdrawal(_cwp);\n  }\n\n  /**\n    * @dev Swap exact amount of tokenIn for as many amount of tokenOut\n    * @param self Vault store data\n    * @param sp ISwap.SwapParams\n    * @return amountOut Amount of tokens out in token decimals\n  */\n  function swapExactTokensForTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    IERC20(sp.tokenIn).approve(address(self.swapRouter), sp.amountIn);\n\n    return self.swapRouter.swapExactTokensForTokens(sp);\n  }\n\n  /**\n    * @dev Swap as little tokenIn for exact amount of tokenOut\n    * @param self Vault store data\n    * @param sp ISwap.SwapParams\n    * @return amountIn Amount of tokens in in token decimals\n  */\n  function swapTokensForExactTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    IERC20(sp.tokenIn).approve(address(self.swapRouter), sp.amountIn);\n\n    return self.swapRouter.swapTokensForExactTokens(sp);\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXWorker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IExchangeRouter } from  \"../../interfaces/protocols/gmx/IExchangeRouter.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\n\nlibrary GMXWorker {\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @dev Add strategy's tokens for liquidity and receive LP tokens\n    * @param self Vault store data\n    * @param alp GMXTypes.AddLiquidityParams\n    * @return depositKey Hashed key of created deposit in bytes32\n  */\n  function addLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.AddLiquidityParams memory alp\n  ) external returns (bytes32) {\n    // Send native token for execution fee\n    self.exchangeRouter.sendWnt{ value: alp.executionFee }(\n      self.depositVault,\n      alp.executionFee\n    );\n\n    // Send tokens\n    self.exchangeRouter.sendTokens(\n      address(self.tokenA),\n      self.depositVault,\n      alp.tokenAAmt\n    );\n\n    self.exchangeRouter.sendTokens(\n      address(self.tokenB),\n      self.depositVault,\n      alp.tokenBAmt\n    );\n\n    // Create deposit\n    IExchangeRouter.CreateDepositParams memory _cdp =\n      IExchangeRouter.CreateDepositParams({\n        receiver: address(this),\n        callbackContract: self.callback,\n        uiFeeReceiver: self.refundee,\n        market: address(self.lpToken),\n        initialLongToken: address(self.tokenA),\n        initialShortToken: address(self.tokenB),\n        longTokenSwapPath: new address[](0),\n        shortTokenSwapPath: new address[](0),\n        minMarketTokens: alp.minMarketTokenAmt,\n        shouldUnwrapNativeToken: false,\n        executionFee: alp.executionFee,\n        callbackGasLimit: 2000000\n      });\n\n    return self.exchangeRouter.createDeposit(_cdp);\n  }\n\n  /**\n    * @dev Remove liquidity of strategy's LP token and receive underlying tokens\n    * @param self Vault store data\n    * @param rlp GMXTypes.RemoveLiquidityParams\n    * @return withdrawKey Hashed key of created withdraw in bytes32\n  */\n  function removeLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.RemoveLiquidityParams memory rlp\n  ) external returns (bytes32) {\n    // Send native token for execution fee\n    self.exchangeRouter.sendWnt{value: rlp.executionFee }(\n      self.withdrawalVault,\n      rlp.executionFee\n    );\n\n    // Send GM LP tokens\n    self.exchangeRouter.sendTokens(\n      address(self.lpToken),\n      self.withdrawalVault,\n      rlp.lpAmt\n    );\n\n    // Create withdrawal\n    IExchangeRouter.CreateWithdrawalParams memory _cwp =\n      IExchangeRouter.CreateWithdrawalParams({\n        receiver: address(this),\n        callbackContract: self.callback,\n        uiFeeReceiver: self.refundee,\n        market: address(self.lpToken),\n        longTokenSwapPath: rlp.tokenASwapPath,\n        shortTokenSwapPath: rlp.tokenBSwapPath,\n        minLongTokenAmount: rlp.minTokenAAmt,\n        minShortTokenAmount: rlp.minTokenBAmt,\n        shouldUnwrapNativeToken: false,\n        executionFee: rlp.executionFee,\n        callbackGasLimit: 2000000\n      });\n\n    return self.exchangeRouter.createWithdrawal(_cwp);\n  }\n\n  /**\n    * @dev Swap exact amount of tokenIn for as many amount of tokenOut\n    * @param self Vault store data\n    * @param sp ISwap.SwapParams\n    * @return amountOut Amount of tokens out in token decimals\n  */\n  function swapExactTokensForTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    IERC20(sp.tokenIn).approve(address(self.swapRouter), sp.amountIn);\n\n    return self.swapRouter.swapExactTokensForTokens(sp);\n  }\n\n  /**\n    * @dev Swap as little tokenIn for exact amount of tokenOut\n    * @param self Vault store data\n    * @param sp ISwap.SwapParams\n    * @return amountIn Amount of tokens in in token decimals\n  */\n  function swapTokensForExactTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    IERC20(sp.tokenIn).approve(address(self.swapRouter), sp.amountIn);\n\n    return self.swapRouter.swapTokensForExactTokens(sp);\n  }\n}"
    },
    {
      "filename": "contracts/deposit/DepositUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"./DepositVault.sol\";\nimport \"./DepositStoreUtils.sol\";\nimport \"./DepositEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\nimport \"../utils/AccountUtils.sol\";\n\n// @title DepositUtils\n// @dev Library for deposit functions, to help with the depositing of liquidity\n// into a market in return for market tokens\nlibrary DepositUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Price for Price.Props;\n    using Deposit for Deposit.Props;\n\n    // @dev CreateDepositParams struct used in createDeposit to avoid stack\n    // too deep errors\n    //\n    // @param receiver the address to send the market tokens to\n    // @param callbackContract the callback contract\n    // @param uiFeeReceiver the ui fee receiver\n    // @param market the market to deposit into\n    // @param minMarketTokens the minimum acceptable number of liquidity tokens\n    // @param shouldUnwrapNativeToken whether to unwrap the native token when\n    // sending funds back to the user in case the deposit gets cancelled\n    // @param executionFee the execution fee for keepers\n    // @param callbackGasLimit the gas limit for the callbackContract\n    struct CreateDepositParams {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minMarketTokens;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    // @dev creates a deposit\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param depositVault DepositVault\n    // @param account the depositing account\n    // @param params CreateDepositParams\n    function createDeposit(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        DepositVault depositVault,\n        address account,\n        CreateDepositParams memory params\n    ) external returns (bytes32) {\n        AccountUtils.validateAccount(account);\n\n        Market.Props memory market = MarketUtils.getEnabledMarket(dataStore, params.market);\n        MarketUtils.validateSwapPath(dataStore, params.longTokenSwapPath);\n        MarketUtils.validateSwapPath(dataStore, params.shortTokenSwapPath);\n\n        // if the initialLongToken and initialShortToken are the same, only the initialLongTokenAmount would\n        // be non-zero, the initialShortTokenAmount would be zero\n        uint256 initialLongTokenAmount = depositVault.recordTransferIn(params.initialLongToken);\n        uint256 initialShortTokenAmount = depositVault.recordTransferIn(params.initialShortToken);\n\n        address wnt = TokenUtils.wnt(dataStore);\n\n        if (params.initialLongToken == wnt) {\n            initialLongTokenAmount -= params.executionFee;\n        } else if (params.initialShortToken == wnt) {\n            initialShortTokenAmount -= params.executionFee;\n        } else {\n            uint256 wntAmount = depositVault.recordTransferIn(wnt);\n            if (wntAmount < params.executionFee) {\n                revert Errors.InsufficientWntAmountForExecutionFee(wntAmount, params.executionFee);\n            }\n\n            params.executionFee = wntAmount;\n        }\n\n        if (initialLongTokenAmount == 0 && initialShortTokenAmount == 0) {\n            revert Errors.EmptyDepositAmounts();\n        }\n\n        AccountUtils.validateReceiver(params.receiver);\n\n        Deposit.Props memory deposit = Deposit.Props(\n            Deposit.Addresses(\n                account,\n                params.receiver,\n                params.callbackContract,\n                params.uiFeeReceiver,\n                market.marketToken,\n                params.initialLongToken,\n                params.initialShortToken,\n                params.longTokenSwapPath,\n                params.shortTokenSwapPath\n            ),\n            Deposit.Numbers(\n                initialLongTokenAmount,\n                initialShortTokenAmount,\n                params.minMarketTokens,\n                Chain.currentBlockNumber(),\n                params.executionFee,\n                params.callbackGasLimit\n            ),\n            Deposit.Flags(\n                params.shouldUnwrapNativeToken\n            )\n        );\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, deposit.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteDepositGasLimit(dataStore, deposit);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, params.executionFee);\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        DepositStoreUtils.set(dataStore, key, deposit);\n\n        DepositEventUtils.emitDepositCreated(eventEmitter, key, deposit);\n\n        return key;\n    }\n\n    // @dev cancels a deposit, funds are sent back to the user\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param depositVault DepositVault\n    // @param key the key of the deposit to cancel\n    // @param keeper the address of the keeper\n    // @param startingGas the starting gas amount\n    function cancelDeposit(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        DepositVault depositVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        // 63/64 gas is forwarded to external calls, reduce the startingGas to account for this\n        startingGas -= gasleft() / 63;\n\n        Deposit.Props memory deposit = DepositStoreUtils.get(dataStore, key);\n        if (deposit.account() == address(0)) {\n            revert Errors.EmptyDeposit();\n        }\n\n        if (\n            deposit.initialLongTokenAmount() == 0 &&\n            deposit.initialShortTokenAmount() == 0\n        ) {\n            revert Errors.EmptyDepositAmounts();\n        }\n\n        DepositStoreUtils.remove(dataStore, key, deposit.account());\n\n        if (deposit.initialLongTokenAmount() > 0) {\n            depositVault.transferOut(\n                deposit.initialLongToken(),\n                deposit.account(),\n                deposit.initialLongTokenAmount(),\n                deposit.shouldUnwrapNativeToken()\n            );\n        }\n\n        if (deposit.initialShortTokenAmount() > 0) {\n            depositVault.transferOut(\n                deposit.initialShortToken(),\n                deposit.account(),\n                deposit.initialShortTokenAmount(),\n                deposit.shouldUnwrapNativeToken()\n            );\n        }\n\n        DepositEventUtils.emitDepositCancelled(\n            eventEmitter,\n            key,\n            deposit.account(),\n            reason,\n            reasonBytes\n        );\n\n        EventUtils.EventLogData memory eventData;\n        CallbackUtils.afterDepositCancellation(key, deposit, eventData);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            deposit.executionFee(),\n            startingGas,\n            keeper,\n            deposit.account()\n        );\n    }\n}"
    }
  ]
}