{
  "Title": "[H01] Inconsistencies in stored data may lead to incorrect median price",
  "Content": "The `DelFiPrice` contract has a [public `prices` mapping](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/DelFiPrice.sol#L28) intended to store the median price for each asset. Following the specification, an asset is referenced by its symbol (a string in uppercase letters) and the corresponding median price is stored as a `uint64` value. Anyone can post prices on chain, but only those signed by trusted sources are taken into account when calculating the median price. There are two ways to post an asset’s price on chain.\n\n\nThe first method is via the external [`put` function](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/OpenOraclePriceData.sol#L34) of the `OpenOraclePriceData` contract. Given a signature and the associated message containing the price and the asset’s symbol (among other things), the function will first recover the source from the message and signature, and then update the asset’s price for this particular source. Price data for each source and symbol is kept in the contract’s storage in [private `data` mapping](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/OpenOraclePriceData.sol#L26). Note that prices updated via this method *do not* trigger a recalculation of the official (median) price hold in the public `prices` mapping of the `DelFiPrice` contract. As a consequence, if at this point a user queries an asset’s price reading the `prices` mapping, the returned median price will be incorrect. Furthermore, if the user queries the asset’s price using the [`medianPrice` function](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/DelFiPrice.sol#L86), the returned median price may be inaccurate as well, since it will not be compared against the anchor price to validate it.\n\n\nThe other way to submit prices is via the external [`postPrices` function](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/DelFiPrice.sol#L49) of the `DelFiPrice`, which allows to report a batch of prices (with associated signatures) of one or more assets in a single transaction. Internally, [`postPrices` calls the `put` function](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/DelFiPrice.sol#L54). In this case, the `postPrices` function also correctly [recalculates the median price](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/DelFiPrice.sol#L58-L77) of each asset passed in the `symbols` parameter, updating the corresponding entries in the `prices` mapping [if the median is within safe bounds](https://github.com/compound-finance/open-oracle/blob/e7a928334e5e454a88eec38e4ee1be5ee3b13f08/contracts/DelFiPrice.sol#L66-L67). However, if there is a mismatch between the assets referenced in the `symbols` array and the assets which prices were updated, then some median prices will not be recalculated.\n\n\nAccording to the specification, *“Whenever a post happens, the official (median) price is recalculated”*. This is not strictly followed by the current implementation, leaving the door open for potential data inconsistencies in the registered prices and their medians. Taking into account that reporting accurate median prices is the fundamental purpose of the system, we understand this to be a High severity issue. Consider applying the necessary modifications to strictly follow the specification. In particular, there should be a single reliable way to post prices on chain, and a single reliable way to query the median price for an asset.\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/DelFiPrice.sol",
      "content": "pragma solidity ^0.5.12;\npragma experimental ABIEncoderV2;\n\nimport \"./OpenOraclePriceData.sol\";\nimport \"./OpenOracleView.sol\";\n\n/**\n * @notice The DelFi Price Feed View\n * @author Compound Labs, Inc.\n */\ncontract DelFiPrice is OpenOracleView {\n    /// @notice The event emitted when the median price is updated\n    event PriceUpdated(string symbol, uint64 price);\n\n    /// @notice The event emitted when new prices are posted but the median price is not updated due to the anchor\n    event PriceGuarded(string symbol, uint64 median, uint64 anchor);\n\n    /// @notice The reporter address whose prices checked against the median for safety\n    address anchor;\n\n    /// @notice The highest ratio of the new median price to the anchor price that will still trigger the median price to be updated\n    uint256 upperBoundAnchorRatio;\n\n    /// @notice The lowest ratio of the new median price to the anchor price that will still trigger the median price to be updated\n    uint256 lowerBoundAnchorRatio;\n\n    /// @notice The mapping of medianized prices per symbol\n    mapping(string => uint64) public prices;\n\n    /**\n     * @param data_ Address of the Oracle Data contract\n     * @param sources_ The reporter addresses whose prices will be used to calculate the median\n     * @param anchor_ The reporter address whose prices checked against the median for safety\n     * @param anchorToleranceMantissa_ The tolerance allowed between the anchor and median. A tolerance of 10e16 means a new median that is 10% off from the anchor will still be saved\n     */\n    constructor(OpenOraclePriceData data_, address[] memory sources_, address anchor_, uint anchorToleranceMantissa_) public OpenOracleView(data_, sources_) {\n        anchor = anchor_;\n        require(anchorToleranceMantissa_ < 100e16, \"Anchor Tolerance is too high\");\n        upperBoundAnchorRatio = 100e16 + anchorToleranceMantissa_;\n        lowerBoundAnchorRatio = 100e16 - anchorToleranceMantissa_;\n    }\n\n    /**\n     * @notice Primary entry point to post and recalculate prices\n     * @dev We let anyone pay to post anything, but only sources count for prices\n     * @param messages The messages to post to the oracle\n     * @param signatures The signatures for the corresponding messages\n     */\n    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external {\n        require(messages.length == signatures.length, \"messages and signatures must be 1:1\");\n\n        // Save the prices\n        for (uint i = 0; i < messages.length; i++) {\n            OpenOraclePriceData(address(data)).put(messages[i], signatures[i]);\n        }\n\n        // Try to update the median\n        for (uint i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint64 medianPrice = medianPrice(symbol, sources);\n            uint64 anchorPrice = OpenOraclePriceData(address(data)).getPrice(anchor, symbol);\n            if (anchorPrice == 0) {\n                emit PriceGuarded(symbol, medianPrice, anchorPrice);\n            } else {\n                uint256 anchorRatioMantissa = uint256(medianPrice) * 100e16 / anchorPrice;\n                // Only update the view's price if the median of the sources is within a bound, and it is a new median\n                if (anchorRatioMantissa <= upperBoundAnchorRatio && anchorRatioMantissa >= lowerBoundAnchorRatio) {\n                    // only update and emit event if the median price is new, otherwise do nothing\n                    if (prices[symbol] != medianPrice) {\n                        prices[symbol] = medianPrice;\n                        emit PriceUpdated(symbol, medianPrice);\n                    }\n                } else {\n                    emit PriceGuarded(symbol, medianPrice, anchorPrice);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the median price over any set of sources\n     * @param symbol The symbol to calculate the median price of\n     * @param sources_ The sources to use when calculating the median price\n     * @return median The median price over the set of sources\n     */\n    function medianPrice(string memory symbol, address[] memory sources_) public view returns (uint64 median) {\n        require(sources_.length > 0, \"sources list must not be empty\");\n\n        uint N = sources_.length;\n        uint64[] memory postedPrices = new uint64[](N);\n        for (uint i = 0; i < N; i++) {\n            postedPrices[i] = OpenOraclePriceData(address(data)).getPrice(sources_[i], symbol);\n        }\n\n        uint64[] memory sortedPrices = sort(postedPrices);\n        // if N is even, get the left and right medians and average them\n        if (N % 2 == 0) {\n            uint64 left = sortedPrices[(N / 2) - 1];\n            uint64 right = sortedPrices[N / 2];\n            uint128 sum = uint128(left) + uint128(right);\n            return uint64(sum / 2);\n        } else {\n            // if N is odd, just return the median\n            return sortedPrices[N / 2];\n        }\n    }\n\n    /**\n     * @notice Helper to sort an array of uints\n     * @param array Array of integers to sort\n     * @return The sorted array of integers\n     */\n    function sort(uint64[] memory array) private pure returns (uint64[] memory) {\n        uint N = array.length;\n        for (uint i = 0; i < N; i++) {\n            for (uint j = i + 1; j < N; j++) {\n                if (array[i] > array[j]) {\n                    uint64 tmp = array[i];\n                    array[i] = array[j];\n                    array[j] = tmp;\n                }\n            }\n        }\n        return array;\n    }\n}"
    },
    {
      "filename": "contracts/OpenOraclePriceData.sol",
      "content": "pragma solidity ^0.5.12;\n\nimport \"./OpenOracleData.sol\";\n\n/**\n * @title The Open Oracle Price Data Contract\n * @notice Values stored in this contract should represent a USD price with 6 decimals precision\n * @author Compound Labs, Inc.\n */\ncontract OpenOraclePriceData is OpenOracleData {\n    ///@notice The event emitted when a source writes to its storage\n    event Write(address indexed source, string key, uint64 timestamp, uint64 value);\n    ///@notice The event emitted when the timestamp on a price is invalid and it is not written to storage\n    event NotWritten(uint64 priorTimestamp, uint256 messageTimestamp, uint256 blockTimestamp);\n\n    ///@notice The fundamental unit of storage for a reporter source\n    struct Datum {\n        uint64 timestamp;\n        uint64 value;\n    }\n\n    /**\n     * @notice The most recent authenticated data from all sources\n     * @dev This is private because dynamic mapping keys preclude auto-generated getters.\n     */\n    mapping(address => mapping(string => Datum)) private data;\n\n    /**\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\n     * @param message The payload containing the timestamp, and (key, value) pairs\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\n     * @return The keys that were written\n     */\n    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {\n        // Recover the source address\n        address source = source(message, signature);\n\n        // Decode the message and check the kind\n        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));\n        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked(\"prices\")), \"Kind of data must be 'prices'\");\n\n        // Only update if newer than stored, according to source\n        Datum storage prior = data[source][key];\n        if (timestamp > prior.timestamp && timestamp < block.timestamp + 60 minutes) {\n            data[source][key] = Datum(timestamp, value);\n            emit Write(source, key, timestamp, value);\n        } else {\n            emit NotWritten(prior.timestamp, timestamp, block.timestamp);\n        }\n\n        return key;\n    }\n\n    /**\n     * @notice Read a single key from an authenticated source\n     * @param source The verifiable author of the data\n     * @param key The selector for the value to return\n     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))\n     */\n    function get(address source, string calldata key) external view returns (uint64, uint64) {\n        Datum storage datum = data[source][key];\n        return (datum.timestamp, datum.value);\n    }\n\n    /**\n     * @notice Read only the value for a single key from an authenticated source\n     * @param source The verifiable author of the data\n     * @param key The selector for the value to return\n     * @return The price value (defaults to 0)\n     */\n    function getPrice(address source, string calldata key) external view returns (uint64) {\n        return data[source][key].value;\n    }\n}"
    },
    {
      "filename": "contracts/DelFiPrice.sol",
      "content": "pragma solidity ^0.5.12;\npragma experimental ABIEncoderV2;\n\nimport \"./OpenOraclePriceData.sol\";\nimport \"./OpenOracleView.sol\";\n\n/**\n * @notice The DelFi Price Feed View\n * @author Compound Labs, Inc.\n */\ncontract DelFiPrice is OpenOracleView {\n    /// @notice The event emitted when the median price is updated\n    event PriceUpdated(string symbol, uint64 price);\n\n    /// @notice The event emitted when new prices are posted but the median price is not updated due to the anchor\n    event PriceGuarded(string symbol, uint64 median, uint64 anchor);\n\n    /// @notice The reporter address whose prices checked against the median for safety\n    address anchor;\n\n    /// @notice The highest ratio of the new median price to the anchor price that will still trigger the median price to be updated\n    uint256 upperBoundAnchorRatio;\n\n    /// @notice The lowest ratio of the new median price to the anchor price that will still trigger the median price to be updated\n    uint256 lowerBoundAnchorRatio;\n\n    /// @notice The mapping of medianized prices per symbol\n    mapping(string => uint64) public prices;\n\n    /**\n     * @param data_ Address of the Oracle Data contract\n     * @param sources_ The reporter addresses whose prices will be used to calculate the median\n     * @param anchor_ The reporter address whose prices checked against the median for safety\n     * @param anchorToleranceMantissa_ The tolerance allowed between the anchor and median. A tolerance of 10e16 means a new median that is 10% off from the anchor will still be saved\n     */\n    constructor(OpenOraclePriceData data_, address[] memory sources_, address anchor_, uint anchorToleranceMantissa_) public OpenOracleView(data_, sources_) {\n        anchor = anchor_;\n        require(anchorToleranceMantissa_ < 100e16, \"Anchor Tolerance is too high\");\n        upperBoundAnchorRatio = 100e16 + anchorToleranceMantissa_;\n        lowerBoundAnchorRatio = 100e16 - anchorToleranceMantissa_;\n    }\n\n    /**\n     * @notice Primary entry point to post and recalculate prices\n     * @dev We let anyone pay to post anything, but only sources count for prices\n     * @param messages The messages to post to the oracle\n     * @param signatures The signatures for the corresponding messages\n     */\n    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external {\n        require(messages.length == signatures.length, \"messages and signatures must be 1:1\");\n\n        // Save the prices\n        for (uint i = 0; i < messages.length; i++) {\n            OpenOraclePriceData(address(data)).put(messages[i], signatures[i]);\n        }\n\n        // Try to update the median\n        for (uint i = 0; i < symbols.length; i++) {\n            string memory symbol = symbols[i];\n            uint64 medianPrice = medianPrice(symbol, sources);\n            uint64 anchorPrice = OpenOraclePriceData(address(data)).getPrice(anchor, symbol);\n            if (anchorPrice == 0) {\n                emit PriceGuarded(symbol, medianPrice, anchorPrice);\n            } else {\n                uint256 anchorRatioMantissa = uint256(medianPrice) * 100e16 / anchorPrice;\n                // Only update the view's price if the median of the sources is within a bound, and it is a new median\n                if (anchorRatioMantissa <= upperBoundAnchorRatio && anchorRatioMantissa >= lowerBoundAnchorRatio) {\n                    // only update and emit event if the median price is new, otherwise do nothing\n                    if (prices[symbol] != medianPrice) {\n                        prices[symbol] = medianPrice;\n                        emit PriceUpdated(symbol, medianPrice);\n                    }\n                } else {\n                    emit PriceGuarded(symbol, medianPrice, anchorPrice);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the median price over any set of sources\n     * @param symbol The symbol to calculate the median price of\n     * @param sources_ The sources to use when calculating the median price\n     * @return median The median price over the set of sources\n     */\n    function medianPrice(string memory symbol, address[] memory sources_) public view returns (uint64 median) {\n        require(sources_.length > 0, \"sources list must not be empty\");\n\n        uint N = sources_.length;\n        uint64[] memory postedPrices = new uint64[](N);\n        for (uint i = 0; i < N; i++) {\n            postedPrices[i] = OpenOraclePriceData(address(data)).getPrice(sources_[i], symbol);\n        }\n\n        uint64[] memory sortedPrices = sort(postedPrices);\n        // if N is even, get the left and right medians and average them\n        if (N % 2 == 0) {\n            uint64 left = sortedPrices[(N / 2) - 1];\n            uint64 right = sortedPrices[N / 2];\n            uint128 sum = uint128(left) + uint128(right);\n            return uint64(sum / 2);\n        } else {\n            // if N is odd, just return the median\n            return sortedPrices[N / 2];\n        }\n    }\n\n    /**\n     * @notice Helper to sort an array of uints\n     * @param array Array of integers to sort\n     * @return The sorted array of integers\n     */\n    function sort(uint64[] memory array) private pure returns (uint64[] memory) {\n        uint N = array.length;\n        for (uint i = 0; i < N; i++) {\n            for (uint j = i + 1; j < N; j++) {\n                if (array[i] > array[j]) {\n                    uint64 tmp = array[i];\n                    array[i] = array[j];\n                    array[j] = tmp;\n                }\n            }\n        }\n        return array;\n    }\n}"
    }
  ]
}