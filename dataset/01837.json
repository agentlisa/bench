{
  "Title": "TRST-M-6 Pending fees calculations don’t allow overflowing/underflowing",
  "Content": "**Description:**\nWhen computing pending fees in the UniswapV3PositionViewer. \n`_computePendingFeesToBeEarned()` function, the calculations of **feeGrowthBelowX128**, \n**feeGrowthAboveX128**, and **feeGrowthInsideX128** don’t allow under- and overflowing. \nHowever, the respective calculations in Uniswap V3 are designed to underflow and overflow \n(for more information, refer to https://github.com/Uniswap/v3-core/issues/573 issue and this https://github.com/Jeiwan/uniswapv3-book/issues/45). As a result, executing \n_computePendingFeesToBeEarned() can revert in some situations, causing transaction \nreverts.\n\n**Recommended Mitigation:**\nIn the `_computePendingFeesToBeEarned()` function, consider wrapping the fee growth \ncalculations in **unchecked**. This is what Uniswap does in the 0.8 branch(https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/Tick.sol#L69-L97).\n\n**Team response:**\nFixed\n\n**Mitigation Review:**\nThe team addressed this issue by wrapping the fee growth calculations in **unchecked** in \n`_computePendingFeesToBeEarned()`.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/Tick.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {SafeCast} from './SafeCast.sol';\n\nimport {TickMath} from './TickMath.sol';\n\n/// @title Tick\n/// @notice Contains functions for managing tick processes and relevant calculations\nlibrary Tick {\n    error LO();\n\n    using SafeCast for int256;\n\n    // info stored for each initialized individual tick\n    struct Info {\n        // the total position liquidity that references this tick\n        uint128 liquidityGross;\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n        int128 liquidityNet;\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint256 feeGrowthOutside0X128;\n        uint256 feeGrowthOutside1X128;\n        // the cumulative tick value on the other side of the tick\n        int56 tickCumulativeOutside;\n        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint160 secondsPerLiquidityOutsideX128;\n        // the seconds spent on the other side of the tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint32 secondsOutside;\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n        bool initialized;\n    }\n\n    /// @notice Derives max liquidity per tick from given tick spacing\n    /// @dev Executed within the pool constructor\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n    /// @return The max liquidity per tick\n    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {\n        unchecked {\n            int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;\n            int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;\n            uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;\n            return type(uint128).max / numTicks;\n        }\n    }\n\n    /// @notice Retrieves fee growth data\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @param tickCurrent The current tick\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function getFeeGrowthInside(\n        mapping(int24 => Tick.Info) storage self,\n        int24 tickLower,\n        int24 tickUpper,\n        int24 tickCurrent,\n        uint256 feeGrowthGlobal0X128,\n        uint256 feeGrowthGlobal1X128\n    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        unchecked {\n            Info storage lower = self[tickLower];\n            Info storage upper = self[tickUpper];\n\n            // calculate fee growth below\n            uint256 feeGrowthBelow0X128;\n            uint256 feeGrowthBelow1X128;\n            if (tickCurrent >= tickLower) {\n                feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;\n                feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;\n            } else {\n                feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;\n                feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;\n            }\n\n            // calculate fee growth above\n            uint256 feeGrowthAbove0X128;\n            uint256 feeGrowthAbove1X128;\n            if (tickCurrent < tickUpper) {\n                feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;\n                feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;\n            } else {\n                feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;\n                feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;\n            }\n\n            feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;\n            feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;\n        }\n    }\n\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The tick that will be updated\n    /// @param tickCurrent The current tick\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool\n    /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n    /// @param time The current block timestamp cast to a uint32\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n    /// @param maxLiquidity The maximum liquidity allocation for a single tick\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n    function update(\n        mapping(int24 => Tick.Info) storage self,\n        int24 tick,\n        int24 tickCurrent,\n        int128 liquidityDelta,\n        uint256 feeGrowthGlobal0X128,\n        uint256 feeGrowthGlobal1X128,\n        uint160 secondsPerLiquidityCumulativeX128,\n        int56 tickCumulative,\n        uint32 time,\n        bool upper,\n        uint128 maxLiquidity\n    ) internal returns (bool flipped) {\n        Tick.Info storage info = self[tick];\n\n        uint128 liquidityGrossBefore = info.liquidityGross;\n        uint128 liquidityGrossAfter = liquidityDelta < 0\n            ? liquidityGrossBefore - uint128(-liquidityDelta)\n            : liquidityGrossBefore + uint128(liquidityDelta);\n\n        if (liquidityGrossAfter > maxLiquidity) revert LO();\n\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n        if (liquidityGrossBefore == 0) {\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n            if (tick <= tickCurrent) {\n                info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;\n                info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;\n                info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;\n                info.tickCumulativeOutside = tickCumulative;\n                info.secondsOutside = time;\n            }\n            info.initialized = true;\n        }\n\n        info.liquidityGross = liquidityGrossAfter;\n\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n        info.liquidityNet = upper ? info.liquidityNet - liquidityDelta : info.liquidityNet + liquidityDelta;\n    }\n\n    /// @notice Clears tick data\n    /// @param self The mapping containing all initialized tick information for initialized ticks\n    /// @param tick The tick that will be cleared\n    function clear(mapping(int24 => Tick.Info) storage self, int24 tick) internal {\n        delete self[tick];\n    }\n\n    /// @notice Transitions to next tick as needed by price movement\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The destination tick of the transition\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity\n    /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n    /// @param time The current block.timestamp\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n    function cross(\n        mapping(int24 => Tick.Info) storage self,\n        int24 tick,\n        uint256 feeGrowthGlobal0X128,\n        uint256 feeGrowthGlobal1X128,\n        uint160 secondsPerLiquidityCumulativeX128,\n        int56 tickCumulative,\n        uint32 time\n    ) internal returns (int128 liquidityNet) {\n        unchecked {\n            Tick.Info storage info = self[tick];\n            info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;\n            info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;\n            info.secondsPerLiquidityOutsideX128 =\n                secondsPerLiquidityCumulativeX128 -\n                info.secondsPerLiquidityOutsideX128;\n            info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;\n            info.secondsOutside = time - info.secondsOutside;\n            liquidityNet = info.liquidityNet;\n        }\n    }\n}"
    }
  ]
}