{
  "Title": "M-7: Users are unable to collect their yield if tranche is paused",
  "Content": "# Issue M-7: Users are unable to collect their yield if tranche is paused \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/97 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nxiaoming90\n## Summary\n\nUsers are unable to collect their yield if Tranche is paused, resulting in a loss of assets for the victims.\n\n## Vulnerability Detail\n\nPer the contest's README page, it stated that the admin/owner is \"RESTRICTED\". Thus, any finding showing that the owner/admin can steal a user's funds, cause loss of funds or harm to the users, or cause the user's fund to be struck is valid in this audit contest.\n\n> Q: Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n>\n> RESTRICTED\n\nThe admin of the protocol has the ability to pause the Tranche contract, and no one except for the admin can unpause it. If a malicious admin paused the Tranche contract, the users will not be able to collect their yield earned, leading to a loss of assets for them.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/Tranche.sol#L605\n\n```solidity\nFile: Tranche.sol\n603:     /// @notice Pause issue, collect and updateUnclaimedYield\n604:     /// @dev only callable by management\n605:     function pause() external onlyManagement {\n606:         _pause();\n607:     }\n608: \n609:     /// @notice Unpause issue, collect and updateUnclaimedYield\n610:     /// @dev only callable by management\n611:     function unpause() external onlyManagement {\n612:         _unpause();\n613:     }\n```\n\nThe following shows that the `collect` function can only be executed when the system is not paused.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/Tranche.sol#L399\n\n```solidity\nFile: Tranche.sol\n399:     function collect() public nonReentrant whenNotPaused returns (uint256) {\n400:         uint256 _lscale = lscales[msg.sender];\n401:         uint256 accruedInTarget = unclaimedYields[msg.sender];\n```\n\n## Impact\n\nUsers are unable to collect their yield if Tranche is paused, resulting in a loss of assets for the victims.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/Tranche.sol#L605\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider allowing the users to collect yield even when the system is paused.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nEscalate\n\nAs mentioned by the watson, any issue that can causes a possible DoS/loss of funds by protocols admin not arising from external contract pauses/emergency withdrawals should be a valid medium severity issues due to centralization risks. In this case, protocol admins can block collection of yield permanently. In fact, it also blocks reinvestment of yield via `issue()`\n\n**sherlock-admin2**\n\n> Escalate\n> \n> As mentioned by the watson, any issue that can causes a possible DoS/loss of funds by protocols admin not arising from external contract pauses/emergency withdrawals should be a valid medium severity issues due to centralization risks. In this case, protocol admins can block collection of yield permanently. In fact, it also blocks reinvestment of yield via `issue()`\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\nAgree with the escalation by Nevi. The report highlighted a way for the admin to pause the contract, resulting in the users not being able to collect their yield earned, leading to a loss of assets for them. Per the contest rules, such an issue is considered valid.\n\n> Q: Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\n>\n> RESTRICTED\n\n\n\n**cvetanovv**\n\nThe reason I left it invalid is that I consider the pausing mechanism a design decision. \n\nAlso, they have written in the readme that it is acceptable to have contracts pausing. Yes, I know this applies to External integrations, but I think it may be valid for them as well. \n\nApart from that pausing only stops users from collecting their rewards, doesn't mean the protocol will steal them. We have a sentence in the rules that gives the judge in this situation some flexibility to decide: \"Please note that these restrictions must be explicitly described by the protocol and will be considered case by case.\"\n\n**xiaoming9090**\n\n> The reason I left it invalid is that I consider the pausing mechanism a design decision.\n> \n> Also, they have written in the readme that it is acceptable to have contracts pausing. Yes, I know this applies to External integrations, but I think it may be valid for them as well.\n> \n> Apart from that pausing only stops users from collecting their rewards, doesn't mean the protocol will steal them. We have a sentence in the rules that gives the judge in this situation some flexibility to decide: \"Please note that these restrictions must be explicitly described by the protocol and will be considered case by case.\"\n\nI agree that having a pausing mechanism is a design choice by the protocol team. However, that does not mean the malicious admin will not use this pausing mechanism to block users from collecting their yields, causing harm to them.\n\nThe contest's README stated that pausing by external protocols is fine, but that does not mean that internal pausing is out-of-scope during the contest.\n\nWhen users cannot collect their earned yield due to malicious admin activities, it is basically the same as a loss of assets for them. Loss of assets for either users or protocols is considered a valid issue here.\n\nNote: Admin is restricted in this contest.\n\n\n\n**Czar102**\n\nI agree that this is a Medium severity issue, planning to accept the escalation. It is clear that when the protocol team considers the admins \"RESTRICTED\" and doesn't post the restrictions, the owners should not be able to cause losses to users.\n\n@cvetanovv\nThe pausing mechanism is a design decision, but when it starts to allow to cause loss of funds by an untrusted actor, then it becomes a vulnerability, too.\nThey are fine with external integration pausing, meaning that they trust the protocols to do it with the good of users in mind. This has an odd relation with the fact that external admins are restricted, but luckily we are not considering external admins here.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2024-01-napier-judging/issues/97/#issuecomment-1984824534): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "napier-v1/src/Tranche.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n// interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IERC5095} from \"./interfaces/IERC5095.sol\";\nimport {ITranche} from \"./interfaces/ITranche.sol\";\nimport {IYieldToken} from \"./interfaces/IYieldToken.sol\";\nimport {ITrancheFactory} from \"./interfaces/ITrancheFactory.sol\";\nimport {IBaseAdapter} from \"./interfaces/IBaseAdapter.sol\";\n// libs\nimport {Math} from \"@openzeppelin/contracts@4.9.3/utils/math/Math.sol\";\nimport {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {SafeERC20Namer} from \"./utils/SafeERC20Namer.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {MAX_BPS} from \"./Constants.sol\";\n// inheriting\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC20Permit.sol\";\nimport {Pausable} from \"@openzeppelin/contracts@4.9.3/security/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\nimport {BaseToken} from \"./BaseToken.sol\";\n\n/// @title Tranche\n/// @author Napier Labs\n/// @author 0xbakuchi\n/// @notice Tranche divides a yield-bearing token into two tokens: principal token and yield token.\n/// This contract itself is a principal token.\n/// Users can interact with this contract to issue, redeem tokens, and gather yield.\n/// Both the Principal and Yield tokens share the same decimal notation as the underlying token.\n/// Math:\n/// - Yield Stripping Math paper: https://github.com/Napier-Lab/napier-v1/blob/main/assets/Yield_Stripping_Math__1_.pdf\n/// - Hackmd: https://hackmd.io/W2mPhP7YRjGxqnAc93omLg?both\n/// PT/YT and Target token conversion is defined as:\n/// P = T * scale / 1e18\n///   = T * price * 10^(18 + uDecimals - tDecimals) / 1e18\n/// Where P is amount of PT and T is amount of Target.\n/// @dev Supported Tokens:\n/// - Underlying token can be rebased token.\n/// - Underlying must not be ERC777 token.\n/// - Target token can not be rebased token.\ncontract Tranche is BaseToken, ReentrancyGuard, Pausable, ITranche {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n    using SafeCast for uint256;\n\n    uint8 internal immutable uDecimals;\n\n    /// @notice Represents the underlying token where users deposit (e.g. DAI)\n    IERC20 internal immutable _underlying;\n\n    /// @notice Represents the yield-bearing token (e.g. cDAI)\n    IERC20 internal immutable _target;\n\n    /// @notice Represents the Yield token that represents the right to claim the yield\n    IYieldToken internal immutable _yt;\n\n    /// @notice An adapter that interacts with the yield source (e.g. Compound)\n    IBaseAdapter public immutable adapter;\n\n    /// @notice Address of the management account\n    address public immutable management;\n\n    // Principal token Parameters\n\n    /// @inheritdoc IERC5095\n    /// @notice The timestamp of maturity in unix seconds\n    uint256 public immutable override(BaseToken, IERC5095) maturity;\n\n    /// @notice Percentage of underlying principal reserved for YTs.\n    /// YT holders can claim this after maturity. (10000 = 100%)\n    uint256 internal immutable tilt;\n\n    /// @notice 10_000 - tilt (10000 = 100%) for gas savings\n    uint256 internal immutable oneSubTilt;\n\n    /// @notice The fee for issuing new tokens (10000 = 100%)\n    uint256 internal immutable issuanceFeeBps;\n\n    //////////////////////////////////////////////////\n    // State Variables\n    //////////////////////////////////////////////////\n\n    /// @notice Variables tracking the yield-bearing token's scales\n    /// @dev This is used to calculate the claimable yield and is updated on every issue, collect, and redeemYT action.\n    ///  - `mscale` represents the scale of the yield-bearing token at or after maturity,\n    /// it is set only at the time of users redeeming, redeemingYT and collecting at/after maturity.\n    ///  - `maxscale` represents the maximum scale of the yield-bearing token since the Tranche's creation till now.\n    GlobalScales internal gscales;\n\n    /// @dev Accumulated issuance fees charged (in units of target token). The management can withdraw this fees.\n    uint256 public issuanceFees;\n\n    /// @dev The address that receives the issuance fees. This address can be changed by the `management`.\n    address public feeRecipient;\n\n    /// @notice Keeps track of the scale of the target token at the last user action.\n    /// @dev It is used for calculating the yield that can be claimed. It gets updated on every user action.\n    /// user -> lscale (last scale)\n    /// See \"Yield Stripping Math\" for more details.\n    mapping(address => uint256) public lscales;\n\n    /// @notice Keeps track of the yield not claimed by each user in units of the target token.\n    /// @dev This value is reset to 0 on every issue, collect and redeemYT action. Every YT transfer also increases this value.\n    mapping(address => uint256) public unclaimedYields;\n\n    /* ================== MODIFIERS =================== */\n\n    /// @notice Revert if timestamp is before maturity\n    modifier expired() {\n        if (block.timestamp < maturity) revert TimestampBeforeMaturity();\n        _;\n    }\n\n    /// @notice Revert if timestamp is at or after maturity\n    modifier notExpired() {\n        if (block.timestamp >= maturity) revert TimestampAfterMaturity();\n        _;\n    }\n\n    /// @notice Revert if reentrancy guard is already set to `entered`\n    modifier notEntered() {\n        if (_reentrancyGuardEntered()) revert ReentrancyGuarded();\n        _;\n    }\n\n    /// @notice Revert if msg sender is not management address\n    modifier onlyManagement() {\n        if (msg.sender != management) revert Unauthorized();\n        _;\n    }\n\n    /// @dev Assume Tranche is deployed from a factory.\n    /// Doesn't take constructor arguments directly so that CREATE2 address is independent of the constructor arguments.\n    /// The arguments are fetched through a callback to the factory.\n    /// @custom:param _args The arguments for the Tranche contract.\n    ///\n    /// The constructor is `payable` to remove msg.value check and reduce about 198 gas cost at deployment time.\n    /// This is acceptable because the factory contract doesn't deploy Tranche with ETH.\n    constructor() payable ERC20(\"Napier Principal Token\", \"ePT\") ERC20Permit(\"Napier Principal Token\") {\n        // Retrieve constructor arguments from the factory\n        ITrancheFactory.TrancheInitArgs memory args = ITrancheFactory(msg.sender).args();\n        address underlying_ = IBaseAdapter(args.adapter).underlying();\n        address target_ = IBaseAdapter(args.adapter).target();\n\n        // Initialize immutable and state variables\n        feeRecipient = args.management;\n        management = args.management;\n\n        _underlying = IERC20(underlying_);\n        _target = IERC20(target_);\n        _yt = IYieldToken(args.yt);\n        adapter = IBaseAdapter(args.adapter);\n        tilt = args.tilt;\n        oneSubTilt = MAX_BPS - tilt; // 10_000 - tilt\n        issuanceFeeBps = args.issuanceFee;\n        maturity = args.maturity;\n        uDecimals = ERC20(underlying_).decimals();\n        // Set maxscale to the current scale\n        gscales.maxscale = IBaseAdapter(args.adapter).scale().toUint128();\n\n        emit SeriesCreated(args.adapter, args.maturity, args.tilt, args.issuanceFee);\n    }\n\n    /* ================== MUTATIVE METHODS =================== */\n\n    /// @inheritdoc ITranche\n    /// @notice This function issues Principal Token (PT) and Yield Token (YT) to `to` in exchange for `underlyingAmount` of underlying token.\n    /// Issued PT and YT is the sum of:\n    /// - amount derived from the deposited underlying token\n    /// - amount derived from reinveted unclaimed yield\n    /// - amount derived from reinvested accrued yield from last time when YT balance was updated to now\n    ///\n    /// Issuance Fee is charged on the amount of Target Token used to issue PT and YT.\n    /// @dev The function will be reverted if the maturity has passed.\n    /// @param to The recipient of PT and YT\n    /// @param underlyingAmount The amount of underlying token to be deposited. (in units of underlying token)\n    /// @return issued The amount of PT and YT minted\n    function issue(\n        address to,\n        uint256 underlyingAmount\n    ) external nonReentrant whenNotPaused notExpired returns (uint256 issued) {\n        uint256 _lscale = lscales[to];\n        uint256 accruedInTarget = unclaimedYields[to];\n        uint256 _maxscale = gscales.maxscale;\n\n        // NOTE: Updating mscale/maxscale in the cache before the issue to determine the accrued yield.\n        uint256 cscale = adapter.scale();\n\n        if (cscale > _maxscale) {\n            // If the current scale is greater than the maxscale, update scales\n            _maxscale = cscale;\n            gscales.maxscale = cscale.toUint128();\n        }\n        // Updating user's last scale to the latest maxscale\n        lscales[to] = _maxscale;\n        delete unclaimedYields[to];\n\n        uint256 yBal = _yt.balanceOf(to);\n        // If recipient has unclaimed interest, claim it and then reinvest it to issue more PT and YT.\n        // Reminder: lscale is the last scale when the YT balance of the user was updated.\n        if (_lscale != 0) {\n            accruedInTarget += _computeAccruedInterestInTarget(_maxscale, _lscale, yBal);\n        }\n\n        // Transfer underlying from user to adapter and deposit it into adapter to get target token\n        _underlying.safeTransferFrom(msg.sender, address(adapter), underlyingAmount);\n        (, uint256 sharesMinted) = adapter.prefundedDeposit();\n\n        // Deduct the issuance fee from the amount of target token minted + reinvested yield\n        // Fee should be rounded up towards the protocol (against the user) so that issued principal is rounded down\n        // Hackmd: F0\n        // ptIssued\n        // = (u/s + y - fee) * S\n        // = (sharesUsed - fee) * S\n        // where u = underlyingAmount, s = current scale, y = reinvested yield, S = maxscale\n        uint256 sharesUsed = sharesMinted + accruedInTarget;\n        uint256 fee = sharesUsed.mulDivUp(issuanceFeeBps, MAX_BPS);\n        issued = (sharesUsed - fee).mulWadDown(_maxscale);\n\n        // Accumulate issueance fee in units of target token\n        issuanceFees += fee;\n        // Mint PT and YT to user\n        _mint(to, issued);\n        _yt.mint(to, issued);\n\n        emit Issue(msg.sender, to, issued, sharesUsed);\n    }\n\n    /// @inheritdoc ITranche\n    /// @notice Withdraws underlying tokens from the caller in exchange for `amount` of PT and YT.\n    /// 1 PT + 1 YT = 1 Target token (e.g. 1 wstETH). This equation is always true\n    /// because PT represents the principal amount of the Target token and YT represents the yield of the Target token.\n    /// Basically, anyone can burn `x` PT and `x` YT to withdraw `x` Target tokens anytime.\n    ///\n    /// Withdrawn amount will be the sum of the following:\n    /// - amount derived from PT + YT burn\n    /// - amount of unclaimed yield\n    /// - amount of accrued yield from the last time when the YT balance was updated to now\n    /// @notice If the caller is not `from`, `from` must have approved the caller to spend `pyAmount` for PT and YT prior to calling this function.\n    /// @dev Reverts if the caller does not have enough PT and YT.\n    /// @param from The owner of PT and YT.\n    /// @param to The recipient of the redeemed underlying tokens.\n    /// @param pyAmount The amount of principal token (and yield token) to redeem in units of underlying tokens.\n    /// @return (uint256) The amount of underlying tokens redeemed.\n    function redeemWithYT(address from, address to, uint256 pyAmount) external nonReentrant returns (uint256) {\n        uint256 _lscale = lscales[from];\n        uint256 accruedInTarget = unclaimedYields[from];\n\n        // Calculate the accrued interest in Target token\n        // The lscale should not be 0 because the user should have some YT balance\n        if (_lscale == 0) revert NoAccruedYield();\n\n        GlobalScales memory _gscales = gscales;\n        _updateGlobalScalesCache(_gscales);\n\n        // Compute the accrued yield from the time when the YT balance is updated last to now\n        // The accrued yield in units of target is computed as:\n        // Formula: yield = ytBalance * (1/lscale - 1/maxscale)\n        // Sum up the accrued yield, plus the unclaimed yield from the last time to now\n        accruedInTarget += _computeAccruedInterestInTarget(\n            _gscales.maxscale,\n            _lscale,\n            // Use yt balance instead of `pyAmount`\n            // because we'll update the user's lscale to the current maxscale after this line\n            // regardless of whether the user redeems all of their yt or not.\n            // Otherwise, the user will lose some accrued yield from the last time to now.\n            _yt.balanceOf(from)\n        );\n        // Compute shares equivalent to the amount of principal token to redeem\n        uint256 sharesRedeemed = pyAmount.divWadDown(_gscales.maxscale);\n\n        // Update the local scale and accrued yield of `from`\n        lscales[from] = _gscales.maxscale;\n        delete unclaimedYields[from];\n        gscales = _gscales;\n\n        // Burn PT and YT tokens from `from`\n        _burnFrom(from, pyAmount);\n        _yt.burnFrom(from, msg.sender, pyAmount);\n\n        // Withdraw underlying tokens from the adapter and transfer them to the user\n        _target.safeTransfer(address(adapter), sharesRedeemed + accruedInTarget);\n        (uint256 amountWithdrawn, ) = adapter.prefundedRedeem(to);\n\n        emit RedeemWithYT(from, to, amountWithdrawn);\n        return amountWithdrawn;\n    }\n\n    /// @inheritdoc IERC5095\n    /// @notice If the sender is not `from`, it must have approval from `from` to redeem `principalAmount` PT.\n    /// Redeems `principalAmount` PT from `from` and transfers underlying tokens to `to`.\n    /// @dev Reverts if maturity has not passed.\n    /// @param principalAmount The amount of principal tokens to redeem in units of underlying tokens.\n    /// @param to The recipient of the redeemed underlying tokens.\n    /// @param from The owner of the PT.\n    /// @return (uint256) The amount of underlying tokens redeemed.\n    function redeem(\n        uint256 principalAmount,\n        address to,\n        address from\n    ) external override nonReentrant expired returns (uint256) {\n        GlobalScales memory _gscales = gscales;\n        _updateGlobalScalesCache(_gscales);\n\n        // Compute the shares to be redeemed\n        uint256 shares = _computeSharesRedeemed(_gscales, principalAmount);\n\n        gscales = _gscales;\n        // Burn PT tokens from `from`\n        _burnFrom(from, principalAmount);\n        // Withdraw underlying tokens from the adapter and transfer them to `to`\n        _target.safeTransfer(address(adapter), shares);\n        (uint256 underlyingWithdrawn, ) = adapter.prefundedRedeem(to);\n\n        emit Redeem(from, to, underlyingWithdrawn);\n        return underlyingWithdrawn;\n    }\n\n    /// @inheritdoc IERC5095\n    /// @notice If the sender is not `from`, it must have approval from `from` to redeem an equivalent amount of principal tokens.\n    /// Redeems PT equivalent to `underlyingAmount` underlying tokens from `from` and transfers underlying tokens to `to`.\n    /// @dev Reverts if maturity has not passed.\n    /// @param underlyingAmount The amount of underlying tokens to redeem in units of underlying tokens.\n    /// @param to The recipient of the redeemed underlying tokens.\n    /// @param from The owner of the PT.\n    /// @return (uint256) The amount of principal tokens redeemed.\n    function withdraw(\n        uint256 underlyingAmount,\n        address to,\n        address from\n    ) external override nonReentrant expired returns (uint256) {\n        GlobalScales memory _gscales = gscales;\n        uint256 cscale = _updateGlobalScalesCache(_gscales);\n\n        // Compute the shares to be redeemed\n        uint256 sharesRedeem = underlyingAmount.divWadDown(cscale);\n        uint256 principalAmount = _computePrincipalTokenRedeemed(_gscales, sharesRedeem);\n\n        // Update the global scales\n        gscales = _gscales;\n        // Burn PT tokens from `from`\n        _burnFrom(from, principalAmount);\n        // Withdraw underlying tokens from the adapter and transfer them to `to`\n        _target.safeTransfer(address(adapter), sharesRedeem);\n        (uint256 underlyingWithdrawn, ) = adapter.prefundedRedeem(to);\n\n        emit Redeem(from, to, underlyingWithdrawn);\n        return principalAmount;\n    }\n\n    /// @notice Before transferring YT, update the accrued yield for the sender and receiver.\n    /// NOTE: Every YT transfer will trigger this function to track accrued yield for each user.\n    /// @dev This function is only callable by the Yield Token contract when the user transfers YT to another user.\n    /// NOTE: YT is not burned in this function even if the maturity has passed.\n    /// @param from The address to transfer the Yield Token from.\n    /// @param to The address to transfer the Yield Token to (CAN be the same as `from`).\n    /// NOTE: `from` and `to` SHOULD NOT be zero addresses.\n    /// @param value The amount of Yield Token transferred to `to` (CAN be 0).\n    function updateUnclaimedYield(address from, address to, uint256 value) external nonReentrant whenNotPaused {\n        if (msg.sender != address(_yt)) revert OnlyYT();\n        if (from == address(0) || to == address(0)) revert ZeroAddress();\n        if (value == 0) return;\n\n        GlobalScales memory _gscales = gscales;\n        uint256 _lscaleFrom = lscales[from];\n\n        // If the lscale is 0, it means the user have never hold any YT before\n        // because the lscale is always set to maxscale when the YT is transferrred or minted.\n        // This doesn't mean current YT balance is 0 because the user could have transferred all YT out or burned YT.\n        // Thus there is no accrued interest for the user.\n        if (_lscaleFrom == 0) revert NoAccruedYield();\n\n        _updateGlobalScalesCache(_gscales);\n\n        // Calculate the accrued interest in Target token for `from`\n        unclaimedYields[from] += _computeAccruedInterestInTarget(_gscales.maxscale, _lscaleFrom, _yt.balanceOf(from));\n        lscales[from] = _gscales.maxscale;\n\n        // Calculate the accrued interest in Target token for `to`. `from` and `to` can be equal.\n        uint256 _lscaleReceiver = lscales[to];\n        if (_lscaleReceiver != 0) {\n            unclaimedYields[to] +=\n                _computeAccruedInterestInTarget(_gscales.maxscale, _lscaleReceiver, _yt.balanceOf(to)); // prettier-ignore\n        }\n        lscales[to] = _gscales.maxscale;\n        // update global scales\n        gscales = _gscales;\n    }\n\n    /// @notice Collects yield for `msg.sender` and converts it to underlying token and transfers it to `msg.sender`.\n    /// NOTE: If the maturity has passed, YT will be burned, and some of the principal will be transferred to `msg.sender` based on the `tilt` parameter.\n    /// The withdrwan amount of underlying token is the sum of the following:\n    /// - Amount of unclaimed yield\n    /// - Amount of accrued yield from the time when the YT balance was updated to now\n    /// - Amount of principal reserved for YT holders if the maturity has passed\n    /// @dev Anyone can call this function to collect yield for themselves.\n    /// @return The collected yield in underlying token.\n    function collect() public nonReentrant whenNotPaused returns (uint256) {\n        uint256 _lscale = lscales[msg.sender];\n        uint256 accruedInTarget = unclaimedYields[msg.sender];\n\n        if (_lscale == 0) revert NoAccruedYield();\n\n        GlobalScales memory _gscales = gscales;\n        _updateGlobalScalesCache(_gscales);\n\n        uint256 yBal = _yt.balanceOf(msg.sender);\n        accruedInTarget += _computeAccruedInterestInTarget(_gscales.maxscale, _lscale, yBal);\n        lscales[msg.sender] = _gscales.maxscale;\n        delete unclaimedYields[msg.sender];\n        gscales = _gscales;\n\n        if (block.timestamp >= maturity) {\n            // If matured, burn YT and add the principal portion to the accrued yield\n            accruedInTarget += _computeTargetBelongsToYT(_gscales, yBal);\n            _yt.burn(msg.sender, yBal);\n        }\n\n        // Convert the accrued yield in Target token to underlying token and transfer it to the `msg.sender`\n        // Target token may revert if zero-amount transfer is not allowed.\n        _target.safeTransfer(address(adapter), accruedInTarget);\n        (uint256 accrued, ) = adapter.prefundedRedeem(msg.sender);\n        emit Collect(msg.sender, accruedInTarget);\n        return accrued;\n    }\n\n    /* ================== VIEW METHODS =================== */\n\n    /// @inheritdoc ITranche\n    /// @dev This function is useful for off-chain services to get the accrued yield of a user.\n    /// @dev This function must not revert in any case.\n    function previewCollect(address account) external view returns (uint256) {\n        uint256 _lscale = lscales[account];\n        uint256 accruedInTarget = unclaimedYields[account];\n\n        // If the lscale is 0, it means the user have never hold any YT before\n        if (_lscale == 0) return 0;\n\n        GlobalScales memory _gscales = gscales;\n        uint256 cscale = _updateGlobalScalesCache(_gscales);\n\n        // At this point, the scales cache is up to date.\n        // Calculate the accrued yield in Target token for `account`\n\n        uint256 yBal = _yt.balanceOf(account);\n        accruedInTarget += _computeAccruedInterestInTarget(_gscales.maxscale, _lscale, yBal);\n\n        if (block.timestamp >= maturity) {\n            // If matured, add the principal portion to the accrued yield\n            accruedInTarget += _computeTargetBelongsToYT(_gscales, yBal);\n        }\n        // Convert the accrued yield to underlying token\n        return accruedInTarget.mulWadDown(cscale);\n    }\n\n    /// @inheritdoc IERC5095\n    function maxRedeem(address owner) external view override notEntered returns (uint256) {\n        // Before maturity, PT can't be redeemed. Return 0.\n        if (block.timestamp < maturity) return 0;\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC5095\n    function maxWithdraw(address owner) external view override returns (uint256 maxUnderlyingAmount) {\n        if (block.timestamp < maturity) return 0;\n        return convertToUnderlying(balanceOf(owner));\n    }\n\n    /// @inheritdoc IERC5095\n    function previewRedeem(uint256 principalAmount) external view override returns (uint256 underlyingAmount) {\n        if (block.timestamp < maturity) return 0;\n        return convertToUnderlying(principalAmount);\n    }\n\n    /// @inheritdoc IERC5095\n    function previewWithdraw(uint256 underlyingAmount) external view override returns (uint256 principalAmount) {\n        if (block.timestamp < maturity) return 0;\n        return convertToPrincipal(underlyingAmount);\n    }\n\n    /// @inheritdoc IERC5095\n    /// @dev Before maturity, the amount of underlying returned is as if the PTs would be at maturity.\n    function convertToUnderlying(\n        uint256 principalAmount\n    ) public view override notEntered returns (uint256 underlyingAmount) {\n        GlobalScales memory _gscales = gscales; // Load gscales into memory\n        uint128 cscale = adapter.scale().toUint128();\n        if (_gscales.mscale == 0) {\n            // Simulate the settlement as if it is settled now\n            _gscales.mscale = cscale;\n            if (cscale > _gscales.maxscale) {\n                _gscales.maxscale = cscale;\n            }\n        }\n        uint256 shares = _computeSharesRedeemed(_gscales, principalAmount);\n\n        return shares.mulWadDown(cscale);\n    }\n\n    /// @inheritdoc IERC5095\n    /// @dev Before maturity, the amount of underlying returned is as if the PTs would be at maturity.\n    function convertToPrincipal(uint256 underlyingAmount) public view override notEntered returns (uint256) {\n        GlobalScales memory _gscales = gscales; // Load gscales into memory\n        uint128 cscale = adapter.scale().toUint128();\n        if (_gscales.mscale == 0) {\n            // Simulate the settlement as if it is settled now\n            _gscales.mscale = cscale;\n            if (cscale > _gscales.maxscale) {\n                _gscales.maxscale = cscale;\n            }\n        }\n        return _computePrincipalTokenRedeemed(_gscales, underlyingAmount.divWadDown(cscale));\n    }\n\n    /* ================== METADATA =================== */\n\n    /// @inheritdoc ITranche\n    /// @dev We return the address type instead of IERC20 to avoid additional dependencies for integrators.\n    function yieldToken() external view returns (address) {\n        return address(_yt);\n    }\n\n    /// @inheritdoc IERC5095\n    /// @dev We return the address type instead of IERC20 to avoid additional dependencies for integrators.\n    function underlying() external view returns (address) {\n        return address(_underlying);\n    }\n\n    /// @inheritdoc BaseToken\n    /// @dev We return the address type instead of IERC20 to avoid additional dependencies for integrators.\n    function target() external view override returns (address) {\n        return address(_target);\n    }\n\n    /// @inheritdoc ERC20\n    function name() public view override returns (string memory) {\n        string memory tokenName = SafeERC20Namer.tokenName(address(_target));\n        return string.concat(\"Napier Principal Token \", tokenName, \"@\", _toDateString(maturity));\n    }\n\n    /// @inheritdoc ERC20\n    function symbol() public view override returns (string memory) {\n        string memory tokenSymbol = SafeERC20Namer.tokenSymbol(address(_target));\n        return string.concat(\"eP-\", tokenSymbol, \"@\", _toDateString(maturity));\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view override returns (uint8) {\n        return uDecimals;\n    }\n\n    /// @notice get the global scales\n    function getGlobalScales() external view notEntered returns (GlobalScales memory) {\n        return gscales;\n    }\n\n    /// @inheritdoc ITranche\n    /// @notice This function is useful for off-chain services to get the series information.\n    function getSeries() external view notEntered returns (Series memory) {\n        GlobalScales memory _gscales = gscales;\n        return\n            Series({\n                underlying: address(_underlying),\n                target: address(_target),\n                yt: address(_yt),\n                adapter: address(adapter),\n                mscale: _gscales.mscale,\n                maxscale: _gscales.maxscale,\n                tilt: tilt.toUint64(),\n                issuanceFee: issuanceFeeBps.toUint64(),\n                maturity: maturity.toUint64()\n            });\n    }\n\n    /* ================== PERMISSIONED METHODS =================== */\n\n    /// @notice Claim accumulated issuance fees. Redeem the fees in underlying.\n    /// @dev Only callable by management\n    /// @return Issuance fees in units of underlying token (e.g DAI)\n    function claimIssuanceFees() external onlyManagement returns (uint256) {\n        uint256 fees = issuanceFees - 1; // Ensure that the slot is not cleared, for gas savings\n        issuanceFees = 1;\n        _target.safeTransfer(address(adapter), fees);\n        (uint256 feesInUnderlying, ) = adapter.prefundedRedeem(feeRecipient);\n        return feesInUnderlying;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyManagement {\n        if (_feeRecipient == address(0)) revert ZeroAddress();\n        feeRecipient = _feeRecipient;\n    }\n\n    /// @notice Rescue a token from the contract. Usually used for tokens sent by a mistake.\n    /// @param token erc20 token\n    /// @param recipient recipient of the tokens\n    function recoverERC20(address token, address recipient) external onlyManagement {\n        if (token == address(_target)) revert ProtectedToken();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(recipient, balance);\n    }\n\n    /// @notice Pause issue, collect and updateUnclaimedYield\n    /// @dev only callable by management\n    function pause() external onlyManagement {\n        _pause();\n    }\n\n    /// @notice Unpause issue, collect and updateUnclaimedYield\n    /// @dev only callable by management\n    function unpause() external onlyManagement {\n        _unpause();\n    }\n\n    /* ================== INTERNAL METHODS =================== */\n    /* ================== UTIL METHODS =================== */\n\n    function _burnFrom(address owner, uint256 amount) internal {\n        if (owner != msg.sender) {\n            _spendAllowance(owner, msg.sender, amount);\n        }\n        _burn(owner, amount);\n    }\n\n    /// @notice Updates the global scales cache.\n    /// If the maturity has passed, updates the maturity scale `mscale` if it's not updated yet. (Settlement)\n    /// @return cscale The current scale of the adapter.\n    function _updateGlobalScalesCache(GlobalScales memory _cache) internal view returns (uint256) {\n        // Get the current scale of the adapter\n        uint256 cscale = adapter.scale();\n        if (_cache.mscale != 0) return cscale; // Skip if already settled\n\n        // If mscale == 0 and maturity has passed, settle the _cache.\n        if (block.timestamp >= maturity) {\n            _cache.mscale = cscale.toUint128();\n        }\n        // Update the _cache's maxscale\n        if (cscale > _cache.maxscale) {\n            _cache.maxscale = cscale.toUint128();\n        }\n        return cscale;\n    }\n\n    /// @notice Computes the amount of Target tokens to be redeemed for the given PT amount.\n    /// @dev This function is responsible for the logic of computing the amount of Target tokens to be redeemed.\n    /// The logic is as follows: 1) sunny day (ideal case), 2) not sunny day.\n    /// @param _gscales Local cache of global scales.\n    /// @param _principalAmount PT amount to redeem in units of underlying tokens.\n    function _computeSharesRedeemed(\n        GlobalScales memory _gscales,\n        uint256 _principalAmount\n    ) internal view returns (uint256) {\n        // Hackmd: F1\n        // If it's a sunny day, PT holders lose `tilt` % of the principal amount.\n        if ((_gscales.mscale * MAX_BPS) / _gscales.maxscale >= oneSubTilt) {\n            // Formula: shares = principalAmount * (1 - tilt) / mscale\n            return ((_principalAmount * oneSubTilt) / MAX_BPS).divWadDown(_gscales.mscale);\n        } else {\n            // If it's not a sunny day,\n            // Formula: shares = principalAmount / maxscale\n            return _principalAmount.divWadDown(_gscales.maxscale);\n        }\n    }\n\n    /// @notice Computes the amount of PT to be redeemed for the given shares amount.\n    /// @param _gscales Local cache of global scales.\n    /// @param _shares Amount of Target tokens equivalent to the amount of PT to be redeemed (in units of Target tokens).\n    function _computePrincipalTokenRedeemed(\n        GlobalScales memory _gscales,\n        uint256 _shares\n    ) internal view returns (uint256) {\n        // Hackmd: F1\n        // If it's a sunny day, PT holders lose `tilt` % of the principal amount.\n        if ((_gscales.mscale * MAX_BPS) / _gscales.maxscale >= oneSubTilt) {\n            // Formula: principalAmount = (shares * mscale * MAX_BPS) / oneSubTilt\n            return (_shares.mulWadDown(_gscales.mscale) * MAX_BPS) / oneSubTilt;\n        }\n        // If it's not a sunny day,\n        // Formula: principalAmount = shares * maxscale\n        return _shares.mulWadDown(_gscales.maxscale);\n    }\n\n    /// @notice Computes the amount of Target token that belongs to YT.\n    /// @param _gscales Local cache of global scales.\n    /// @param _yBal The balance of YT for the user.\n    function _computeTargetBelongsToYT(GlobalScales memory _gscales, uint256 _yBal) internal view returns (uint256) {\n        // Hackmd: F3\n        // If it's a sunny day, PT holders lose `tilt` % of the principal amount and YT holders get the amount.\n        if ((_gscales.mscale * MAX_BPS) / _gscales.maxscale >= oneSubTilt) {\n            // Formula: targetBelongsToYT = yBal / maxscale - (1 - tilt) * yBal / mscale\n            return _yBal.divWadDown(_gscales.maxscale) - ((_yBal * oneSubTilt) / MAX_BPS).divWadDown(_gscales.mscale);\n        }\n        return 0;\n    }\n\n    /// @notice Computes the amount of accrued interest in the Target.\n    /// e.g. if the Target scale increases by 5% since the last time the account collected and the account has 100 YT,\n    /// then the account will receive 100 * 5% = 5 Target as interest, which is equivalent"
    }
  ]
}