{
  "Title": "[M-17] Discrepancy in ECRECOVER Precompile when Using `Delegatecall`",
  "Content": "\nThe discrepancy in `delegatecall` behavior with the ECRECOVER precompile contract in zkSync Era can have significant impact leading to incorrect signature validation, potentially compromising data integrity and user funds.\n\n### Proof of Concept\n\nIn the context of zkSync Era, there exists a noticeable inconsistency in how the ECRECOVER precompile contract (located at address 0x01) behaves when accessed via `delegatecall`. This behavior differs from the standard Ethereum Virtual Machine (EVM) behavior, where the outcomes remain uniform across `call`, `staticcall`, and `delegatecall`.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/precompiles/Ecrecover.yul#L7>\n\nIn zkSync Era, when the ECRECOVER precompile contract is invoked using `delegatecall`, it diverges from the usual behavior by delegating the call to the contract itself and executing its code within the caller's context. This results in a returned value that does not align with the anticipated outcome of a `precompileCall`. Instead, it yields `bytes32(0)`.\n\nTo illustrate, in the following example, when executing the provided code in the EVM, the returned `bytes32` value consistently appears as `0x000000000000000000000000759389e8e5c1aa1f511e9ea98b6caedd262bff0b` for all three scenarios: `ecrecoverStaticcall`, `ecrecoverCall`, and `ecrecoverDelegatecall`. However, in the zkSync Era, while `ecrecoverStaticcall` and `ecrecoverCall` maintain the same results as in the EVM, `ecrecoverDelegatecall` produces an incorrect outcome:\n\n    // SPDX-License-Identifier: MIT\n\n    pragma solidity >=0.8.20;\n\n    contract PoC {\n        bytes32 h = keccak256(\"\");\n        uint8 v = 27;\n        bytes32 r = bytes32(uint256(1));\n        bytes32 s = bytes32(uint256(2));\n\n        function ecrecoverStaticcall() public returns (bytes32) {\n            bytes memory data = abi.encode(h, v, r, s);\n            assembly {\n                pop(staticcall(gas(), 0x01, add(data, 0x20), mload(data), 0, 0x20))\n                return(0, 0x20)\n            }\n        }\n\n        function ecrecoverCall() public returns (bytes32) {\n            bytes memory data = abi.encode(h, v, r, s);\n            assembly {\n                pop(call(gas(), 0x01, 0x00, add(data, 0x20), mload(data), 0, 0x20))\n                return(0, 0x20)\n            }\n        }\n\n        function ecrecoverDelegatecall() public returns (bytes32) {\n            bytes memory data = abi.encode(h, v, r, s);\n            assembly {\n                pop(\n                    delegatecall(gas(), 0x01, add(data, 0x20), mload(data), 0, 0x20)\n                )\n                return(0, 0x20)\n            }\n        }\n    }\n\nThis discrepancy is critical in its impact because it introduces a divergence from the expected EVM response. While the likelihood of encountering this issue is not high, as precompile contracts are typically invoked through `staticcall` rather than `delegatecall`.\n\n### Recommended Mitigation Steps\n\nThe following revised code is recommended:\n\n    function delegateCall(\n            uint256 _gas,\n            address _address,\n            bytes calldata _data\n        ) internal returns (bytes memory returnData) {\n            bool success;\n            if(_address == address(0x01){\n                success = rawStaticCall(_gas, _address, _data);\n            } else {\n                success = rawDelegateCall(_gas, _address, _data);\n            }\n            returnData = _verifyCallResult(success);\n        }\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/libraries/EfficientCall.sol#L88>\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/175#issuecomment-1794968351):**\n > It has high impact (we do not know in which context it will be used, so its wrong result can have critical impact), but low probability. So, medium is fair.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/175#issuecomment-1826878542):**\n > The Warden has shown an inconsistency in the behaviour of ecrecover when using `delegatecall`. Because the goal of the zkSync EVM is to be the EVM compatible, Medium Severity seems appropriate.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/175#issuecomment-1849019163):**\n > I have verified my statement through testing via the zksync-foundry code repo as well as reviewing both the Precompile as well as the Rust code.\n>\n>*Note: to view the provided image, please see the original comment [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/175#issuecomment-1849019163).*\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/175).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/precompiles/Ecrecover.yul",
      "content": "/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The contract used to emulate EVM's ecrecover precompile.\n * @dev It uses `precompileCall` to call the zkEVM built-in precompiles.\n */\nobject \"Ecrecover\" {\n    code {\n        return(0, 0)\n    }\n    object \"Ecrecover_deployed\" {\n        code {\n            ////////////////////////////////////////////////////////////////\n            //                      CONSTANTS\n            ////////////////////////////////////////////////////////////////\n\n            // Group order of secp256k1, see https://en.bitcoin.it/wiki/Secp256k1\n            function SECP256K1_GROUP_SIZE() -> ret {\n                ret := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n            }\n\n            /// @dev The gas cost of processing ecrecover circuit precompile.\n            function ECRECOVER_GAS_COST() -> ret {\n                ret := 1112\n            }\n\n            ////////////////////////////////////////////////////////////////\n            //                      HELPER FUNCTIONS\n            ////////////////////////////////////////////////////////////////\n            \n            // @dev Packs precompile parameters into one word.\n            // Note: functions expect to work with 32/64 bits unsigned integers.\n            // Caller should ensure the type matching before!\n            function unsafePackPrecompileParams(\n                uint32_inputOffsetInWords,\n                uint32_inputLengthInWords,\n                uint32_outputOffsetInWords,\n                uint32_outputLengthInWords,\n                uint64_perPrecompileInterpreted\n            ) -> rawParams {\n                rawParams := uint32_inputOffsetInWords\n                rawParams := or(rawParams, shl(32, uint32_inputLengthInWords))\n                rawParams := or(rawParams, shl(64, uint32_outputOffsetInWords))\n                rawParams := or(rawParams, shl(96, uint32_outputLengthInWords))\n                rawParams := or(rawParams, shl(192, uint64_perPrecompileInterpreted))\n            }\n\n            /// @dev Executes the `precompileCall` opcode.\n            function precompileCall(precompileParams, gasToBurn) -> ret {\n                // Compiler simulation for calling `precompileCall` opcode\n                ret := verbatim_2i_1o(\"precompile\", precompileParams, gasToBurn)\n            }\n\n            ////////////////////////////////////////////////////////////////\n            //                      FALLBACK\n            ////////////////////////////////////////////////////////////////\n\n            let digest := calldataload(0)\n            let v := calldataload(32)\n            let r := calldataload(64)\n            let s := calldataload(96)\n\n            // Validate the input by the yellow paper rules (Appendix E. Precompiled contracts)\n            let vIsInvalid := iszero(or(eq(v, 27), eq(v, 28)))\n            let sIsInvalid := or(eq(s, 0), gt(s, sub(SECP256K1_GROUP_SIZE(), 1)))\n            let rIsInvalid := or(eq(r, 0), gt(r, sub(SECP256K1_GROUP_SIZE(), 1)))\n\n            if or(vIsInvalid, or(sIsInvalid, rIsInvalid)) {\n                return(0, 0)\n            }\n\n            // Store the data in memory, so the ecrecover circuit will read it \n            mstore(0, digest)\n            mstore(32, sub(v, 27))\n            mstore(64, r)\n            mstore(96, s)\n\n            let precompileParams := unsafePackPrecompileParams(\n                0, // input offset in words\n                4, // input length in words (the signed digest, v, r, s)\n                0, // output offset in words\n                2, // output length in words (success, signer)\n                0  // No special meaning, ecrecover circuit doesn't check this value\n            )\n            let gasToPay := ECRECOVER_GAS_COST()\n\n            // Check whether the call is successfully handled by the ecrecover circuit\n            let success := precompileCall(precompileParams, gasToPay)\n            let internalSuccess := mload(0)\n\n            switch and(success, internalSuccess)\n            case 0 {\n                return(0, 0)\n            }\n            default {\n                return(32, 32)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/libraries/EfficientCall.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./SystemContractHelper.sol\";\nimport \"./Utils.sol\";\nimport {SHA256_SYSTEM_CONTRACT, KECCAK256_SYSTEM_CONTRACT, MSG_VALUE_SYSTEM_CONTRACT} from \"../Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice This library is used to perform ultra-efficient calls using zkEVM-specific features.\n * @dev EVM calls always accept a memory slice as input and return a memory slice as output.\n * Therefore, even if the user has a ready-made calldata slice, they still need to copy it to memory\n * before calling. This is especially inefficient for large inputs (proxies, multi-calls, etc.).\n * In turn, zkEVM operates over a fat pointer, which is a set of (memory page, offset, start, length) in the memory/calldata/returndata.\n * This allows forwarding the calldata slice as is, without copying it to memory.\n * @dev Fat pointer is not just an integer, it is an extended data type supported on the VM level.\n * zkEVM creates the wellformed fat pointers for all the calldata/returndata regions, later\n * the contract may manipulate the already created fat pointers to forward a slice of the data, but not\n * to create new fat pointers!\n * @dev The allowed operation on fat pointers are:\n * 1. `ptr.add` - Transforms `ptr.offset` into `ptr.offset + u32(_value)`. If overflow happens then it panics.\n * 2. `ptr.sub` - Transforms `ptr.offset` into `ptr.offset - u32(_value)`. If underflow happens then it panics.\n * 3. `ptr.pack` - Do the concatenation between the lowest 128 bits of the pointer itself and the highest 128 bits of `_value`. It is typically used to prepare the ABI for external calls.\n * 4. `ptr.shrink` - Transforms `ptr.length` into `ptr.length - u32(_shrink)`. If underflow happens then it panics.\n * @dev The call opcodes accept the fat pointer and change it to its canonical form before passing it to the child call\n * 1. `ptr.start` is transformed into `ptr.offset + ptr.start`\n * 2. `ptr.length` is transformed into `ptr.length - ptr.offset`\n * 3. `ptr.offset` is transformed into `0`\n */\nlibrary EfficientCall {\n    /// @notice Call the `keccak256` without copying calldata to memory.\n    /// @param _data The preimage data.\n    /// @return The `keccak256` hash.\n    function keccak(bytes calldata _data) internal view returns (bytes32) {\n        bytes memory returnData = staticCall(gasleft(), KECCAK256_SYSTEM_CONTRACT, _data);\n        require(returnData.length == 32, \"keccak256 returned invalid data\");\n        return bytes32(returnData);\n    }\n\n    /// @notice Call the `sha256` precompile without copying calldata to memory.\n    /// @param _data The preimage data.\n    /// @return The `sha256` hash.\n    function sha(bytes calldata _data) internal view returns (bytes32) {\n        bytes memory returnData = staticCall(gasleft(), SHA256_SYSTEM_CONTRACT, _data);\n        require(returnData.length == 32, \"sha returned invalid data\");\n        return bytes32(returnData);\n    }\n\n    /// @notice Perform a `call` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _value The `msg.value` to send.\n    /// @param _data The calldata to use for the call.\n    /// @param _isSystem Whether the call should contain the `isSystem` flag.\n    /// @return returnData The copied to memory return data.\n    function call(\n        uint256 _gas,\n        address _address,\n        uint256 _value,\n        bytes calldata _data,\n        bool _isSystem\n    ) internal returns (bytes memory returnData) {\n        bool success = rawCall(_gas, _address, _value, _data, _isSystem);\n        returnData = _verifyCallResult(success);\n    }\n\n    /// @notice Perform a `staticCall` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @return returnData The copied to memory return data.\n    function staticCall(\n        uint256 _gas,\n        address _address,\n        bytes calldata _data\n    ) internal view returns (bytes memory returnData) {\n        bool success = rawStaticCall(_gas, _address, _data);\n        returnData = _verifyCallResult(success);\n    }\n\n    /// @notice Perform a `delegateCall` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @return returnData The copied to memory return data.\n    function delegateCall(\n        uint256 _gas,\n        address _address,\n        bytes calldata _data\n    ) internal returns (bytes memory returnData) {\n        bool success = rawDelegateCall(_gas, _address, _data);\n        returnData = _verifyCallResult(success);\n    }\n\n    /// @notice Perform a `mimicCall` (a call with custom msg.sender) without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @param _whoToMimic The `msg.sender` for the next call.\n    /// @param _isConstructor Whether the call should contain the `isConstructor` flag.\n    /// @param _isSystem Whether the call should contain the `isSystem` flag.\n    /// @return returnData The copied to memory return data.\n    function mimicCall(\n        uint256 _gas,\n        address _address,\n        bytes calldata _data,\n        address _whoToMimic,\n        bool _isConstructor,\n        bool _isSystem\n    ) internal returns (bytes memory returnData) {\n        bool success = rawMimicCall(_gas, _address, _data, _whoToMimic, _isConstructor, _isSystem);\n        returnData = _verifyCallResult(success);\n    }\n\n    /// @notice Perform a `call` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _value The `msg.value` to send.\n    /// @param _data The calldata to use for the call.\n    /// @param _isSystem Whether the call should contain the `isSystem` flag.\n    /// @return success whether the call was successful.\n    function rawCall(\n        uint256 _gas,\n        address _address,\n        uint256 _value,\n        bytes calldata _data,\n        bool _isSystem\n    ) internal returns (bool success) {\n        if (_value == 0) {\n            _loadFarCallABIIntoActivePtr(_gas, _data, false, _isSystem);\n\n            address callAddr = RAW_FAR_CALL_BY_REF_CALL_ADDRESS;\n            assembly {\n                success := call(_address, callAddr, 0, 0, 0xFFFF, 0, 0)\n            }\n        } else {\n            _loadFarCallABIIntoActivePtr(_gas, _data, false, true);\n\n            // If there is provided `msg.value` call the `MsgValueSimulator` to forward ether.\n            address msgValueSimulator = MSG_VALUE_SYSTEM_CONTRACT;\n            address callAddr = SYSTEM_CALL_BY_REF_CALL_ADDRESS;\n            // We need to supply the mask to the MsgValueSimulator to denote\n            // that the call should be a system one.\n            uint256 forwardMask = _isSystem ? MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT : 0;\n\n            assembly {\n                success := call(msgValueSimulator, callAddr, _value, _address, 0xFFFF, forwardMask, 0)\n            }\n        }\n    }\n\n    /// @notice Perform a `staticCall` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @return success whether the call was successful.\n    function rawStaticCall(uint256 _gas, address _address, bytes calldata _data) internal view returns (bool success) {\n        _loadFarCallABIIntoActivePtr(_gas, _data, false, false);\n\n        address callAddr = RAW_FAR_CALL_BY_REF_CALL_ADDRESS;\n        assembly {\n            success := staticcall(_address, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Perform a `delegatecall` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @return success whether the call was successful.\n    function rawDelegateCall(uint256 _gas, address _address, bytes calldata _data) internal returns (bool success) {\n        _loadFarCallABIIntoActivePtr(_gas, _data, false, false);\n\n        address callAddr = RAW_FAR_CALL_BY_REF_CALL_ADDRESS;\n        assembly {\n            success := delegatecall(_address, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Perform a `mimicCall` (call with custom msg.sender) without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @param _whoToMimic The `msg.sender` for the next call.\n    /// @param _isConstructor Whether the call should contain the `isConstructor` flag.\n    /// @param _isSystem Whether the call should contain the `isSystem` flag.\n    /// @return success whether the call was successful.\n    /// @dev If called not in kernel mode, it will result in a revert (enforced by the VM)\n    function rawMimicCall(\n        uint256 _gas,\n        address _address,\n        bytes calldata _data,\n        address _whoToMimic,\n        bool _isConstructor,\n        bool _isSystem\n    ) internal returns (bool success) {\n        _loadFarCallABIIntoActivePtr(_gas, _data, _isConstructor, _isSystem);\n\n        address callAddr = MIMIC_CALL_BY_REF_CALL_ADDRESS;\n        uint256 cleanupMask = ADDRESS_MASK;\n        assembly {\n            // Clearing values before usage in assembly, since Solidity\n            // doesn't do it by default\n            _whoToMimic := and(_whoToMimic, cleanupMask)\n\n            success := call(_address, callAddr, 0, 0, _whoToMimic, 0, 0)\n        }\n    }\n\n    /// @dev Verify that a low-level call was successful, and revert if it wasn't, by bubbling the revert reason.\n    /// @param _success Whether the call was successful.\n    /// @return returnData The copied to memory return data.\n    function _verifyCallResult(bool _success) private pure returns (bytes memory returnData) {\n        if (_success) {\n            uint256 size;\n            assembly {\n                size := returndatasize()\n            }\n\n            returnData = new bytes(size);\n            assembly {\n                returndatacopy(add(returnData, 0x20), 0, size)\n            }\n        } else {\n            propagateRevert();\n        }\n    }\n\n    /// @dev Propagate the revert reason from the current call to the caller.\n    function propagateRevert() internal pure {\n        assembly {\n            let size := returndatasize()\n            returndatacopy(0, 0, size)\n            revert(0, size)\n        }\n    }\n\n    /// @dev Load the far call ABI into active ptr, that will be used for the next call by reference.\n    /// @param _gas The gas to be passed to the call.\n    /// @param _data The calldata to be passed to the call.\n    /// @param _isConstructor Whether the call is a constructor call.\n    /// @param _isSystem Whether the call is a system call.\n    function _loadFarCallABIIntoActivePtr(\n        uint256 _gas,\n        bytes calldata _data,\n        bool _isConstructor,\n        bool _isSystem\n    ) private view {\n        SystemContractHelper.loadCalldataIntoActivePtr();\n\n        uint256 dataOffset;\n        assembly {\n            dataOffset := _data.offset\n        }\n\n        // Safe to cast, offset is never bigger than `type(uint32).max`\n        SystemContractHelper.ptrAddIntoActive(uint32(dataOffset));\n        // Safe to cast, `data.length` is never bigger than `type(uint32).max`\n        uint32 shrinkTo = uint32(msg.data.length - (_data.length + dataOffset));\n        SystemContractHelper.ptrShrinkIntoActive(shrinkTo);\n\n        uint32 gas = Utils.safeCastToU32(_gas);\n        uint256 farCallAbi = SystemContractsCaller.getFarCallABIWithEmptyFatPointer(\n            gas,\n            // Only rollup is supported for now\n            0,\n            CalldataForwardingMode.ForwardFatPointer,\n            _isConstructor,\n            _isSystem\n        );\n        SystemContractHelper.ptrPackIntoActivePtr(farCallAbi);\n    }\n}"
    }
  ]
}