{
  "Title": "Incorrect Hook Parameter",
  "Content": "Any storage hook that implements the [`onBeforeSpliceDynamicData` function](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/IStoreHook.sol#L104) should receive the state of the record before the update. However, it will receive the [updated encoded lengths](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/StoreCore.sol#L1024) instead, which may cause the hook to respond incorrectly.\n\n\nConsider passing the [original encoded lengths](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/StoreCore.sol#L967).\n\n\n***Update:** Resolved in [pull request #2020](https://github.com/latticexyz/mud/pull/2020#pullrequestreview-1800639377).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/store/src/IStoreHook.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { FieldLayout } from \"./FieldLayout.sol\";\nimport { IERC165, ERC165_INTERFACE_ID } from \"./IERC165.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { ResourceId } from \"./ResourceId.sol\";\n\n// ERC-165 Interface ID (see https://eips.ethereum.org/EIPS/eip-165)\nbytes4 constant STORE_HOOK_INTERFACE_ID = IStoreHook.onBeforeSetRecord.selector ^\n  IStoreHook.onAfterSetRecord.selector ^\n  IStoreHook.onBeforeSpliceStaticData.selector ^\n  IStoreHook.onAfterSpliceStaticData.selector ^\n  IStoreHook.onBeforeSpliceDynamicData.selector ^\n  IStoreHook.onAfterSpliceDynamicData.selector ^\n  IStoreHook.onBeforeDeleteRecord.selector ^\n  IStoreHook.onAfterDeleteRecord.selector ^\n  ERC165_INTERFACE_ID;\n\ninterface IStoreHook is IERC165 {\n  /// @notice Error emitted when a function is not implemented.\n  error StoreHook_NotImplemented();\n\n  /**\n   * @notice Called before setting a record in the store.\n   * @param tableId The ID of the table where the record is to be set.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   * @param fieldLayout The layout of the field, see FieldLayout.sol.\n   */\n  function onBeforeSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  /**\n   * @notice Called after setting a record in the store.\n   * @param tableId The ID of the table where the record was set.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   * @param fieldLayout The layout of the field, see FieldLayout.sol.\n   */\n  function onAfterSetRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) external;\n\n  /**\n   * @notice Called before splicing static data in the store.\n   * @dev Splice operations in static data always overwrite data starting at the start position,\n   * so the total length of the data remains the same and no data is shifted.\n   * @param tableId The ID of the table where the data is to be spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start byte position for splicing.\n   * @param data The data to be written to the static data of the record at the start byte.\n   */\n  function onBeforeSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  /**\n   * @notice Called after splicing static data in the store.\n   * @dev Splice operations in static data always overwrite data starting at the start position,\n   * so the total length of the data remains the same and no data is shifted.\n   * @param tableId The ID of the table where the data was spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start byte position for splicing.\n   * @param data The data written to the static data of the record at the start byte.\n   */\n  function onAfterSpliceStaticData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint48 start,\n    bytes memory data\n  ) external;\n\n  /**\n   * @notice Called before splicing dynamic data in the store.\n   * @dev Splice operations in dynamic data always reach the end of the dynamic data\n   * to avoid shifting data after the inserted or deleted data.\n   * @param tableId The ID of the table where the data is to be spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field.\n   * @param startWithinField The start byte position within the field for splicing.\n   * @param deleteCount The number of bytes to delete in the dynamic data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param data The data to be inserted into the dynamic data of the record at the start byte.\n   */\n  function onBeforeSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes memory data\n  ) external;\n\n  /**\n   * @notice Called after splicing dynamic data in the store.\n   * @dev Splice operations in dynamic data always reach the end of the dynamic data\n   * to avoid shifting data after the inserted or deleted data.\n   * @param tableId The ID of the table where the data was spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field.\n   * @param startWithinField The start byte position within the field for splicing.\n   * @param deleteCount The number of bytes deleted in the dynamic data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param data The data inserted into the dynamic data of the record at the start byte.\n   */\n  function onAfterSpliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes memory data\n  ) external;\n\n  /**\n   * @notice Called before deleting a record from the store.\n   * @param tableId The ID of the table where the record is to be deleted.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldLayout The layout of the field, see FieldLayout.sol.\n   */\n  function onBeforeDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n\n  /**\n   * @notice Called after deleting a record from the store.\n   * @param tableId The ID of the table where the record was deleted.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldLayout The layout of the field, see FieldLayout.sol.\n   */\n  function onAfterDeleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) external;\n}"
    },
    {
      "filename": "packages/store/src/StoreCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { STORE_VERSION } from \"./version.sol\";\nimport { Bytes } from \"./Bytes.sol\";\nimport { Storage } from \"./Storage.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { FieldLayout, FieldLayoutLib } from \"./FieldLayout.sol\";\nimport { Schema, SchemaLib } from \"./Schema.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { Slice, SliceLib } from \"./Slice.sol\";\nimport { StoreHooks, Tables, TablesTableId, ResourceIds, StoreHooksTableId } from \"./codegen/index.sol\";\nimport { _fieldLayout as TablesTableFieldLayout } from \"./codegen/tables/Tables.sol\";\nimport { IStoreErrors } from \"./IStoreErrors.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { StoreSwitch } from \"./StoreSwitch.sol\";\nimport { Hook, HookLib } from \"./Hook.sol\";\nimport { BEFORE_SET_RECORD, AFTER_SET_RECORD, BEFORE_SPLICE_STATIC_DATA, AFTER_SPLICE_STATIC_DATA, BEFORE_SPLICE_DYNAMIC_DATA, AFTER_SPLICE_DYNAMIC_DATA, BEFORE_DELETE_RECORD, AFTER_DELETE_RECORD } from \"./storeHookTypes.sol\";\nimport { ResourceId, ResourceIdInstance } from \"./ResourceId.sol\";\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\n\n/**\n * @title StoreCore Library\n * @notice This library includes implementations for all IStore methods and events related to the store actions.\n */\nlibrary StoreCore {\n  using ResourceIdInstance for ResourceId;\n  /**\n   * @notice Emitted when a new record is set in the store.\n   * @param tableId The ID of the table where the record is set.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   */\n  event Store_SetRecord(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    bytes staticData,\n    PackedCounter encodedLengths,\n    bytes dynamicData\n  );\n\n  /**\n   * @notice Emitted when static data in the store is spliced.\n   * @dev In static data, data is always overwritten starting at the start position,\n   * so the total length of the data remains the same and no data is shifted.\n   * @param tableId The ID of the table where the data is spliced.\n   * @param keyTuple An array representing the key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param data The data to write to the static data of the record at the start byte.\n   */\n  event Store_SpliceStaticData(ResourceId indexed tableId, bytes32[] keyTuple, uint48 start, bytes data);\n\n  /**\n   * @notice Emitted when dynamic data in the store is spliced.\n   * @param tableId The ID of the table where the data is spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param deleteCount The number of bytes to delete in the splice operation.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param data The data to insert into the dynamic data of the record at the start byte.\n   */\n  event Store_SpliceDynamicData(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    uint48 start,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes data\n  );\n\n  /**\n   * @notice Emitted when a record is deleted from the store.\n   * @param tableId The ID of the table where the record is deleted.\n   * @param keyTuple An array representing the composite key for the record.\n   */\n  event Store_DeleteRecord(ResourceId indexed tableId, bytes32[] keyTuple);\n\n  /**\n   * @notice Initialize the store address in StoreSwitch.\n   * @dev Consumers must call this function in their constructor.\n   * StoreSwitch uses the storeAddress to decide where to write data to.\n   * If StoreSwitch is called in the context of a Store contract (storeAddress == address(this)),\n   * StoreSwitch uses internal methods to write data instead of external calls.\n   */\n  function initialize() internal {\n    StoreSwitch.setStoreAddress(address(this));\n  }\n\n  /**\n   * @notice Register core tables in the store.\n   * @dev Consumers must call this function in their constructor before setting\n   * any table data to allow indexers to decode table events.\n   */\n  function registerCoreTables() internal {\n    // Register core tables\n    Tables.register();\n    StoreHooks.register();\n    ResourceIds.register();\n  }\n\n  /************************************************************************\n   *\n   *    SCHEMA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Get the field layout for the given table ID.\n   * @param tableId The ID of the table for which to get the field layout.\n   * @return The field layout for the given table ID.\n   */\n  function getFieldLayout(ResourceId tableId) internal view returns (FieldLayout) {\n    // Explicit check for the Tables table to solve the bootstraping issue\n    // of the Tables table not having a field layout before it is registered\n    // since the field layout is stored in the Tables table.\n    if (ResourceId.unwrap(tableId) == ResourceId.unwrap(TablesTableId)) {\n      return TablesTableFieldLayout;\n    }\n    return\n      FieldLayout.wrap(\n        Storage.loadField({\n          storagePointer: StoreCoreInternal._getStaticDataLocation(TablesTableId, ResourceId.unwrap(tableId)),\n          length: 32,\n          offset: 0\n        })\n      );\n  }\n\n  /**\n   * @notice Get the key schema for the given table ID.\n   * @dev Reverts if the table ID is not registered.\n   * @param tableId The ID of the table for which to get the key schema.\n   * @return keySchema The key schema for the given table ID.\n   */\n  function getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    keySchema = Tables._getKeySchema(tableId);\n    // key schemas can be empty for singleton tables, so we can't depend on key schema for table check\n    if (!ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * @notice Get the value schema for the given table ID.\n   * @dev Reverts if the table ID is not registered.\n   * @param tableId The ID of the table for which to get the value schema.\n   * @return valueSchema The value schema for the given table ID.\n   */\n  function getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    valueSchema = Tables._getValueSchema(tableId);\n    if (valueSchema.isEmpty()) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * @notice Register a new table with the given configuration.\n   * @dev This method reverts if\n   * - The table ID is not of type RESOURCE_TABLE or RESOURCE_OFFCHAIN_TABLE.\n   * - The field layout is invalid.\n   * - The key schema is invalid.\n   * - The value schema is invalid.\n   * - The number of key names does not match the number of key schema types.\n   * - The number of field names does not match the number of field layout fields.\n   * @param tableId The ID of the table to register.\n   * @param fieldLayout The field layout of the table.\n   * @param keySchema The key schema of the table.\n   * @param valueSchema The value schema of the table.\n   * @param keyNames The names of the keys in the table.\n   * @param fieldNames The names of the fields in the table.\n   */\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] memory keyNames,\n    string[] memory fieldNames\n  ) internal {\n    // Verify the table ID is of type RESOURCE_TABLE\n    if (tableId.getType() != RESOURCE_TABLE && tableId.getType() != RESOURCE_OFFCHAIN_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Verify the field layout is valid\n    fieldLayout.validate({ allowEmpty: false });\n\n    // Verify the schema is valid\n    keySchema.validate({ allowEmpty: true });\n    valueSchema.validate({ allowEmpty: false });\n\n    // Verify the number of key names matches the number of key schema types\n    if (keyNames.length != keySchema.numFields()) {\n      revert IStoreErrors.Store_InvalidKeyNamesLength(keySchema.numFields(), keyNames.length);\n    }\n\n    // Verify the number of value names\n    if (fieldNames.length != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidFieldNamesLength(fieldLayout.numFields(), fieldNames.length);\n    }\n\n    // Verify the number of value schema types\n    if (valueSchema.numFields() != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidValueSchemaLength(fieldLayout.numFields(), valueSchema.numFields());\n    }\n\n    // Verify there is no resource with this ID yet\n    if (ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableAlreadyExists(tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Register the table metadata\n    Tables._set(tableId, fieldLayout, keySchema, valueSchema, abi.encode(keyNames), abi.encode(fieldNames));\n\n    // Register the table ID\n    ResourceIds._setExists(tableId, true);\n  }\n\n  /************************************************************************\n   *\n   *    REGISTER HOOKS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Register hooks to be called when a record or field is set or deleted.\n   * @dev This method reverts for all resource IDs other than tables.\n   * Hooks are not supported for offchain tables.\n   * @param tableId The ID of the table to register the hook for.\n   * @param hookAddress The address of the hook contract to register.\n   * @param enabledHooksBitmap The bitmap of enabled hooks.\n   */\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) internal {\n    // Hooks are only supported for tables, not for offchain tables\n    if (tableId.getType() != RESOURCE_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    StoreHooks.push(tableId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregister a hook from the given table ID.\n   * @param tableId The ID of the table to unregister the hook from.\n   * @param hookAddress The address of the hook to unregister.\n   */\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) internal {\n    HookLib.filterListByAddress(StoreHooksTableId, tableId, address(hookAddress));\n  }\n\n  /************************************************************************\n   *\n   *    SET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Set a full record for the given table ID and key tuple.\n   * @dev Calling this method emits a Store_SetRecord event.\n   * This method internally calls another overload of setRecord by fetching the field layout for the given table ID.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * @param tableId The ID of the table to set the record for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData\n  ) internal {\n    setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Set a full data record for the given table ID, key tuple, and field layout.\n   * @dev For onchain tables, the method emits a `Store_SetRecord` event, updates the data in storage,\n   * calls `onBeforeSetRecord` hooks before actually modifying the state, and calls `onAfterSetRecord`\n   * hooks after modifying the state. For offchain tables, the method returns early after emitting the\n   * event without calling hooks or modifying the state.\n   * @param tableId The ID of the table to set the record for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) internal {\n    // Emit event to notify indexers\n    emit Store_SetRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeSetRecord hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SET_RECORD)) {\n        IStoreHook(hook.getAddress()).onBeforeSetRecord(\n          tableId,\n          keyTuple,\n          staticData,\n          encodedLengths,\n          dynamicData,\n          fieldLayout\n        );\n      }\n    }\n\n    // Store the static data at the static data location\n    uint256 staticDataLocation = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n    uint256 memoryPointer = Memory.dataPointer(staticData);\n    Storage.store({\n      storagePointer: staticDataLocation,\n      offset: 0,\n      memoryPointer: memoryPointer,\n      length: staticData.length\n    });\n\n    // Set the dynamic data if there are dynamic fields\n    if (fieldLayout.numDynamicFields() > 0) {\n      // Store the dynamic data length at the dynamic data length location\n      uint256 dynamicDataLengthLocation = StoreCoreInternal._getDynamicDataLengthLocation(tableId, keyTuple);\n      Storage.store({ storagePointer: dynamicDataLengthLocation, data: encodedLengths.unwrap() });\n\n      // Move the memory pointer to the start of the dynamic data\n      memoryPointer = Memory.dataPointer(dynamicData);\n\n      // For every dynamic element, slice off the dynamic data and store it at the dynamic location\n      uint256 dynamicDataLocation;\n      uint256 dynamicDataLength;\n      for (uint8 i; i < fieldLayout.numDynamicFields(); ) {\n        dynamicDataLocation = StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, i);\n        dynamicDataLength = encodedLengths.atIndex(i);\n        Storage.store({\n          storagePointer: dynamicDataLocation,\n          offset: 0,\n          memoryPointer: memoryPointer,\n          length: dynamicDataLength\n        });\n        memoryPointer += dynamicDataLength; // move the memory pointer to the start of the next dynamic data\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    // Call onAfterSetRecord hooks (after modifying the state)\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SET_RECORD)) {\n        IStoreHook(hook.getAddress()).onAfterSetRecord(\n          tableId,\n          keyTuple,\n          staticData,\n          encodedLengths,\n          dynamicData,\n          fieldLayout\n        );\n      }\n    }\n  }\n\n  /**\n   * @notice Splice the static data for the given table ID and key tuple.\n   * @dev This method emits a `Store_SpliceStaticData` event, updates the data in storage, and calls\n   * `onBeforeSpliceStaticData` and `onAfterSpliceStaticData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to splice the static data for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param data The data to write to the static data of the record at the start byte.\n   */\n  function spliceStaticData(ResourceId tableId, bytes32[] memory keyTuple, uint48 start, bytes memory data) internal {\n    uint256 location = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n\n    // Emit event to notify offchain indexers\n    emit StoreCore.Store_SpliceStaticData({ tableId: tableId, keyTuple: keyTuple, start: start, data: data });\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeSpliceStaticData hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SPLICE_STATIC_DATA)) {\n        IStoreHook(hook.getAddress()).onBeforeSpliceStaticData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          start: start,\n          data: data\n        });\n      }\n    }\n\n    // Store the provided value in storage\n    Storage.store({ storagePointer: location, offset: start, data: data });\n\n    // Call onAfterSpliceStaticData hooks\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SPLICE_STATIC_DATA)) {\n        IStoreHook(hook.getAddress()).onAfterSpliceStaticData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          start: start,\n          data: data\n        });\n      }\n    }\n  }\n\n  /**\n   * @notice Splice the dynamic data for the given table ID, key tuple, and dynamic field index.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage, and calls\n   * `onBeforeSpliceDynamicData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to splice the dynamic data for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to splice. (Dynamic field index = field index - number of static fields)\n   * @param startWithinField The start position within the field for the splice operation.\n   * @param deleteCount The number of bytes to delete in the splice operation.\n   * @param data The data to insert into the dynamic data of the record at the start byte.\n   */\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes memory data\n  ) internal {\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: startWithinField,\n      deleteCount: deleteCount,\n      data: data,\n      previousEncodedLengths: StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple)\n    });\n  }\n\n  /**\n   * @notice Set data for a field at the given index in a table with the given tableId, key tuple, and value field layout.\n   * @dev This method internally calls another overload of setField by fetching the field layout for the given table ID.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * This function emits a `Store_SpliceStaticData` or `Store_SpliceDynamicData` event and calls the corresponding hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the field for.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the field.\n   */\n  function setField(ResourceId tableId, bytes32[] memory keyTuple, uint8 fieldIndex, bytes memory data) internal {\n    setField(tableId, keyTuple, fieldIndex, data, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Set data for a field at the given index in a table with the given tableId, key tuple, and value field layout.\n   * @dev This method internally calls to `setStaticField` or `setDynamicField` based on the field index and layout.\n   * Calling `setStaticField` or `setDynamicField` directly is recommended if the caller is aware of the field layout.\n   * This function emits a `Store_SpliceStaticData` or `Store_SpliceDynamicData` event, updates the data in storage,\n   * and calls the corresponding hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the field for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the field.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    if (fieldIndex < fieldLayout.numStaticFields()) {\n      setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    } else {\n      setDynamicField(tableId, keyTuple, fieldIndex - uint8(fieldLayout.numStaticFields()), data);\n    }\n  }\n\n  /**\n   * @notice Set a static field for the given table ID, key tuple, field index, and field layout.\n   * @dev This method emits a `Store_SpliceStaticData` event, updates the data in storage and calls the\n   * `onBeforeSpliceStaticData` and `onAfterSpliceStaticData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the static field for.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the static field.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    spliceStaticData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      start: uint48(StoreCoreInternal._getStaticDataOffset(fieldLayout, fieldIndex)),\n      data: data\n    });\n  }\n\n  /**\n   * @notice Set a dynamic field for the given table ID, key tuple, and dynamic field index.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage and calls the\n   * `onBeforeSpliceDynamicaData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the dynamic field for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to set. (Dynamic field index = field index - number of static fields).\n   * @param data The data to set for the dynamic field.\n   */\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory data\n  ) internal {\n    // Load the previous length of the field to set from storage to compute how much data to delete\n    PackedCounter previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: 0,\n      deleteCount: previousFieldLength,\n      data: data,\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /**\n   * @notice Delete a record for the given table ID and key tuple.\n   * @dev This method internally calls another overload of deleteRecord by fetching the field layout for the given table ID.\n   * This method deletes static data and sets the dynamic data length to 0, but does not\n   * actually modify the dynamic data. It emits a `Store_DeleteRecord` event and emits the\n   * `onBeforeDeleteRecord` and `onAfterDeleteRecord` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to delete the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple) internal {\n    deleteRecord(tableId, keyTuple, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Delete a record for the given table ID and key tuple.\n   * @dev This method deletes static data and sets the dynamic data length to 0, but does not\n   * actually modify the dynamic data. It emits a `Store_DeleteRecord` event and emits the\n   * `onBeforeDeleteRecord` and `onAfterDeleteRecord` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to delete the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldLayout The field layout for the record.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) internal {\n    // Emit event to notify indexers\n    emit Store_DeleteRecord(tableId, keyTuple);\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeDeleteRecord hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_DELETE_RECORD)) {\n        IStoreHook(hook.getAddress()).on"
    }
  ]
}