{
  "Title": "[M-07] In important libraries of PoolTogether, the `pow()` function of PRBMath is used, which exhibits inconsistent return values",
  "Content": "\n### Lines of code\n\n<https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/4bc8a12b857856828c018510b5500d722b79ca3a/src/libraries/DrawAccumulatorLib.sol#L406-L407>\n<https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/4bc8a12b857856828c018510b5500d722b79ca3a/src/libraries/TierCalculationLib.sol#L26>\n\n### Impact\n\nThe `DrawAccumulatorLib.sol` and `TierCalculationLib.sol` libraries inherit a version of `PRBMath` that contains a critical vulnerability in the `pow()` function, which can return inconsistent values. This vulnerability is of great importance to the PoolTogether protocol, as the `pow()` function is used in the computation of `TierCalculationLib.getTierOdds` and `DrawAccumulatorLib.computeC`.\n\nRecently, another protocol has also experienced the same bug and the creators of the `PRBMath` have acknowledged this situation. Here is the corresponding [request](https://github.com/sablier-labs/v2-core/pull/432). Due to time constraints, we were unable to thoroughly address certain rounding errors with the `mul` and `div` functions of `SD59x18`. However, these errors have been corrected in PRBMath [V4](https://github.com/PaulRBerg/prb-math/releases/tag/v4.0.0).\n\n### Proof of Concept\n\n[Proof of the bug acknowledgment by the creator of the PRBMath](https://github.com/sablier-labs/v2-core/pull/432)\n\nThis PR makes four significant changes:\n\n- Upgrades to PRBMath v4.\n- Bumps all other submodules to their most recent versions.\n- Increases the minimum Solidity pragma to v0.8.19, since this is a requirement of PRBMath V4.\n\n### Recommended Mitigation Steps\n\nTo mitigate this issue, please update the contracts to `0.8.19` and upgrade the `PRBMath` to version `V4`.\n\n### Assessed type\n\nMath\n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/423#issuecomment-1644733812)**\n\n**[Picodes (judge) decreased severity to Medium](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/423#issuecomment-1666618858)**\n\n**[PoolTogether mitigated](https://github.com/code-423n4/2023-08-pooltogether-mitigation#individual-prs):**\n> Upgrade PRBMath to v4 and Solidity to 0.8.19.<br>\n> PR: https://github.com/GenerationSoftware/pt-v5-prize-pool/commit/ba56ea8bac3bce06f1e08ae071a19954dd720b1f\n\n**Status**: Mitigation confirmed. Full details in reports from [0xStalin](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/84), [dirk\\_y](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/13) and [rvierdiiev](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/47).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-pooltogether",
  "Code": [
    {
      "filename": "src/libraries/DrawAccumulatorLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport { RingBufferLib } from \"ring-buffer-lib/RingBufferLib.sol\";\nimport { E, SD59x18, sd, unwrap, toSD59x18, fromSD59x18 } from \"prb-math/SD59x18.sol\";\n\n/// @notice Emitted when adding balance for draw zero.\nerror AddToDrawZero();\n\n/// @notice Emitted when an action can't be done on a closed draw.\n/// @param drawId The ID of the closed draw\n/// @param newestDrawId The newest draw ID\nerror DrawClosed(uint16 drawId, uint16 newestDrawId);\n\n/// @notice Emitted when a draw range is not strictly increasing.\n/// @param startDrawId The start draw ID of the range\n/// @param endDrawId The end draw ID of the range\nerror InvalidDrawRange(uint16 startDrawId, uint16 endDrawId);\n\n/// @notice Emitted when the end draw ID for a disbursed range is invalid (too old).\n/// @param endDrawId The end draw ID for the range\nerror InvalidDisbursedEndDrawId(uint16 endDrawId);\n\nstruct Observation {\n  // track the total amount available as of this Observation\n  uint96 available;\n  // track the total accumulated previously\n  uint168 disbursed;\n}\n\n/// @title Draw Accumulator Lib\n/// @author PoolTogether Inc. Team\n/// @notice This contract distributes tokens over time according to an exponential weighted average. Time is divided into discrete \"draws\", of which each is allocated tokens.\nlibrary DrawAccumulatorLib {\n  /// @notice The maximum number of observations that can be recorded.\n  uint24 internal constant MAX_CARDINALITY = 366;\n\n  /// @notice The metadata for using the ring buffer.\n  struct RingBufferInfo {\n    uint16 nextIndex;\n    uint16 cardinality;\n  }\n\n  /// @notice An accumulator for a draw.\n  struct Accumulator {\n    RingBufferInfo ringBufferInfo;\n    uint16[366] drawRingBuffer;\n    mapping(uint256 => Observation) observations;\n  }\n\n  /// @notice A pair of uint16s.\n  struct Pair32 {\n    uint16 first;\n    uint16 second;\n  }\n\n  /// @notice Adds balance for the given draw id to the accumulator.\n  /// @param accumulator The accumulator to add to\n  /// @param _amount The amount of balance to add\n  /// @param _drawId The draw id to which to add balance to. This must be greater than or equal to the previous addition's draw id.\n  /// @param _alpha The alpha value to use for the exponential weighted average.\n  /// @return True if a new observation was created, false otherwise.\n  function add(\n    Accumulator storage accumulator,\n    uint256 _amount,\n    uint16 _drawId,\n    SD59x18 _alpha\n  ) internal returns (bool) {\n    if (_drawId == 0) {\n      revert AddToDrawZero();\n    }\n    RingBufferInfo memory ringBufferInfo = accumulator.ringBufferInfo;\n\n    uint256 newestIndex = RingBufferLib.newestIndex(ringBufferInfo.nextIndex, MAX_CARDINALITY);\n    uint16 newestDrawId_ = accumulator.drawRingBuffer[newestIndex];\n\n    if (_drawId < newestDrawId_) {\n      revert DrawClosed(_drawId, newestDrawId_);\n    }\n\n    Observation memory newestObservation_ = accumulator.observations[newestDrawId_];\n    if (_drawId != newestDrawId_) {\n      uint256 relativeDraw = _drawId - newestDrawId_;\n\n      uint256 remainingAmount = integrateInf(_alpha, relativeDraw, newestObservation_.available);\n      uint256 disbursedAmount = integrate(_alpha, 0, relativeDraw, newestObservation_.available);\n      uint256 remainder = newestObservation_.available - (remainingAmount + disbursedAmount);\n\n      accumulator.drawRingBuffer[ringBufferInfo.nextIndex] = _drawId;\n      accumulator.observations[_drawId] = Observation({\n        available: uint96(_amount + remainingAmount),\n        disbursed: uint168(newestObservation_.disbursed + disbursedAmount + remainder)\n      });\n      uint16 nextIndex = uint16(RingBufferLib.nextIndex(ringBufferInfo.nextIndex, MAX_CARDINALITY));\n      uint16 cardinality = ringBufferInfo.cardinality;\n      if (ringBufferInfo.cardinality < MAX_CARDINALITY) {\n        cardinality += 1;\n      }\n      accumulator.ringBufferInfo = RingBufferInfo({\n        nextIndex: nextIndex,\n        cardinality: cardinality\n      });\n      return true;\n    } else {\n      accumulator.observations[newestDrawId_] = Observation({\n        available: uint96(newestObservation_.available + _amount),\n        disbursed: newestObservation_.disbursed\n      });\n      return false;\n    }\n  }\n\n  /// @notice Gets the total remaining balance after and including the given start draw id. This is the sum of all draw balances from start draw id to infinity.\n  /// The start draw id must be greater than or equal to the newest draw id.\n  /// @param accumulator The accumulator to sum\n  /// @param _startDrawId The draw id to start summing from, inclusive\n  /// @param _alpha The alpha value to use for the exponential weighted average\n  /// @return The sum of draw balances from start draw to infinity\n  function getTotalRemaining(\n    Accumulator storage accumulator,\n    uint16 _startDrawId,\n    SD59x18 _alpha\n  ) internal view returns (uint256) {\n    RingBufferInfo memory ringBufferInfo = accumulator.ringBufferInfo;\n    if (ringBufferInfo.cardinality == 0) {\n      return 0;\n    }\n    uint256 newestIndex = RingBufferLib.newestIndex(ringBufferInfo.nextIndex, MAX_CARDINALITY);\n    uint16 newestDrawId_ = accumulator.drawRingBuffer[newestIndex];\n    if (_startDrawId < newestDrawId_) {\n      revert DrawClosed(_startDrawId, newestDrawId_);\n    }\n    Observation memory newestObservation_ = accumulator.observations[newestDrawId_];\n    return integrateInf(_alpha, _startDrawId - newestDrawId_, newestObservation_.available);\n  }\n\n  /// @notice Returns the newest draw id from the accumulator.\n  /// @param accumulator The accumulator to get the newest draw id from\n  /// @return The newest draw id\n  function newestDrawId(Accumulator storage accumulator) internal view returns (uint256) {\n    return\n      accumulator.drawRingBuffer[\n        RingBufferLib.newestIndex(accumulator.ringBufferInfo.nextIndex, MAX_CARDINALITY)\n      ];\n  }\n\n  /// @notice Retrieves the newest observation from the accumulator.\n  /// @param accumulator The accumulator to retrieve the newest observation from\n  /// @return The newest observation\n  function newestObservation(\n    Accumulator storage accumulator\n  ) internal view returns (Observation memory) {\n    return accumulator.observations[newestDrawId(accumulator)];\n  }\n\n  /// @notice Gets the balance that was disbursed between the given start and end draw ids, inclusive.\n  /// This function has an intentional limitation on the value of `_endDrawId` to save gas, but\n  /// prevents historical disbursement queries that end more than one draw before the last\n  /// accumulator observation.\n  /// @param _accumulator The accumulator to get the disbursed balance from\n  /// @param _startDrawId The start draw id, inclusive\n  /// @param _endDrawId The end draw id, inclusive (limitation: cannot be more than one draw before the last observed draw)\n  /// @param _alpha The alpha value to use for the exponential weighted average\n  /// @return The disbursed balance between the given start and end draw ids, inclusive\n  function getDisbursedBetween(\n    Accumulator storage _accumulator,\n    uint16 _startDrawId,\n    uint16 _endDrawId,\n    SD59x18 _alpha\n  ) internal view returns (uint256) {\n    if (_startDrawId > _endDrawId) {\n      revert InvalidDrawRange(_startDrawId, _endDrawId);\n    }\n\n    RingBufferInfo memory ringBufferInfo = _accumulator.ringBufferInfo;\n\n    if (ringBufferInfo.cardinality == 0) {\n      return 0;\n    }\n\n    Pair32 memory indexes = computeIndices(ringBufferInfo);\n    Pair32 memory drawIds = readDrawIds(_accumulator, indexes);\n\n    /**\n            This check intentionally limits the `_endDrawId` to be no more than one draw before the\n            latest observation. This allows us to make assumptions on the value of `lastObservationDrawIdOccurringAtOrBeforeEnd` and removes the need to run a additional\n            binary search to find it.\n         */\n    if (_endDrawId < drawIds.second - 1) {\n      revert InvalidDisbursedEndDrawId(_endDrawId);\n    }\n\n    if (_endDrawId < drawIds.first) {\n      return 0;\n    }\n\n    /*\n\n        head: residual accrual from observation before start. (if any)\n        body: if there is more than one observations between start and current, then take the past _accumulator diff\n        tail: accrual between the newest observation and current.  if card > 1 there is a tail (almost always)\n\n        let:\n            - s = start draw id\n            - e = end draw id\n            - o = observation\n            - h = \"head\". residual balance from the last o occurring before s.  head is the disbursed amount between (o, s)\n            - t = \"tail\". the residual balance from the last o occuring before e.  tail is the disbursed amount between (o, e)\n            - b = \"body\". if there are *two* observations between s and e we calculate how much was disbursed. body is (last obs disbursed - first obs disbursed)\n\n        total = head + body + tail\n\n\n        lastObservationOccurringAtOrBeforeEnd\n        firstObservationOccurringAtOrAfterStart\n\n        Like so\n\n           s        e\n        o  <h>  o  <t>  o\n\n           s                 e\n        o  <h> o   <b>  o  <t>  o\n\n         */\n\n    uint16 lastObservationDrawIdOccurringAtOrBeforeEnd;\n    if (_endDrawId >= drawIds.second) {\n      // then it must be the end\n      lastObservationDrawIdOccurringAtOrBeforeEnd = drawIds.second;\n    } else {\n      // otherwise it must be the previous one\n      lastObservationDrawIdOccurringAtOrBeforeEnd = _accumulator.drawRingBuffer[\n        uint16(RingBufferLib.offset(indexes.second, 1, ringBufferInfo.cardinality))\n      ];\n    }\n\n    uint16 observationDrawIdBeforeOrAtStart;\n    uint16 firstObservationDrawIdOccurringAtOrAfterStart;\n    // if there is only one observation, or startId is after the oldest record\n    if (_startDrawId >= drawIds.second) {\n      // then use the last record\n      observationDrawIdBeforeOrAtStart = drawIds.second;\n    } else if (_startDrawId <= drawIds.first) {\n      // if the start is before the newest record\n      // then set to the oldest record.\n      firstObservationDrawIdOccurringAtOrAfterStart = drawIds.first;\n    } else {\n      // The start must be between newest and oldest\n      // binary search\n      (\n        ,\n        observationDrawIdBeforeOrAtStart,\n        ,\n        firstObservationDrawIdOccurringAtOrAfterStart\n      ) = binarySearch(\n        _accumulator.drawRingBuffer,\n        indexes.first,\n        indexes.second,\n        ringBufferInfo.cardinality,\n        _startDrawId\n      );\n    }\n\n    uint256 total;\n\n    // if a \"head\" exists\n    if (\n      observationDrawIdBeforeOrAtStart > 0 &&\n      firstObservationDrawIdOccurringAtOrAfterStart > 0 &&\n      observationDrawIdBeforeOrAtStart != lastObservationDrawIdOccurringAtOrBeforeEnd\n    ) {\n      Observation memory beforeOrAtStart = _accumulator.observations[\n        observationDrawIdBeforeOrAtStart\n      ];\n      uint16 headStartDrawId = _startDrawId - observationDrawIdBeforeOrAtStart;\n      uint16 headEndDrawId = headStartDrawId +\n        (firstObservationDrawIdOccurringAtOrAfterStart - _startDrawId);\n      uint amount = integrate(_alpha, headStartDrawId, headEndDrawId, beforeOrAtStart.available);\n      total += amount;\n    }\n\n    Observation memory atOrBeforeEnd;\n    // if a \"body\" exists\n    if (\n      firstObservationDrawIdOccurringAtOrAfterStart > 0 &&\n      firstObservationDrawIdOccurringAtOrAfterStart < lastObservationDrawIdOccurringAtOrBeforeEnd\n    ) {\n      Observation memory atOrAfterStart = _accumulator.observations[\n        firstObservationDrawIdOccurringAtOrAfterStart\n      ];\n      atOrBeforeEnd = _accumulator.observations[lastObservationDrawIdOccurringAtOrBeforeEnd];\n      uint amount = atOrBeforeEnd.disbursed - atOrAfterStart.disbursed;\n      total += amount;\n    }\n\n    total += _computeTail(\n      _accumulator,\n      _startDrawId,\n      _endDrawId,\n      lastObservationDrawIdOccurringAtOrBeforeEnd,\n      _alpha\n    );\n\n    return total;\n  }\n\n  /// @notice Computes the \"tail\" for the given accumulator and range. The tail is the residual balance from the last observation occurring before the end draw id.\n  /// @param accumulator The accumulator to compute for\n  /// @param _startDrawId The start draw id, inclusive\n  /// @param _endDrawId The end draw id, inclusive\n  /// @param _lastObservationDrawIdOccurringAtOrBeforeEnd The last observation draw id occurring at or before the end draw id\n  /// @return The total balance of the tail of the range.\n  function _computeTail(\n    Accumulator storage accumulator,\n    uint16 _startDrawId,\n    uint16 _endDrawId,\n    uint16 _lastObservationDrawIdOccurringAtOrBeforeEnd,\n    SD59x18 _alpha\n  ) internal view returns (uint256) {\n    Observation memory lastObservation = accumulator.observations[\n      _lastObservationDrawIdOccurringAtOrBeforeEnd\n    ];\n    uint16 tailRangeStartDrawId = (\n      _startDrawId > _lastObservationDrawIdOccurringAtOrBeforeEnd\n        ? _startDrawId\n        : _lastObservationDrawIdOccurringAtOrBeforeEnd\n    ) - _lastObservationDrawIdOccurringAtOrBeforeEnd;\n    uint256 amount = integrate(\n      _alpha,\n      tailRangeStartDrawId,\n      _endDrawId - _lastObservationDrawIdOccurringAtOrBeforeEnd + 1,\n      lastObservation.available\n    );\n    return amount;\n  }\n\n  /// @notice Computes the first and last indices of observations for the given ring buffer info.\n  /// @param ringBufferInfo The ring buffer info to compute for\n  /// @return A pair of indices, where the first is the oldest index and the second is the newest index\n  function computeIndices(\n    RingBufferInfo memory ringBufferInfo\n  ) internal pure returns (Pair32 memory) {\n    return\n      Pair32({\n        first: uint16(\n          RingBufferLib.oldestIndex(\n            ringBufferInfo.nextIndex,\n            ringBufferInfo.cardinality,\n            MAX_CARDINALITY\n          )\n        ),\n        second: uint16(\n          RingBufferLib.newestIndex(ringBufferInfo.nextIndex, ringBufferInfo.cardinality)\n        )\n      });\n  }\n\n  /// @notice Retrieves the draw ids for the given accumulator observation indices.\n  /// @param accumulator The accumulator to retrieve from\n  /// @param indices The indices to retrieve\n  /// @return A pair of draw ids, where the first is the draw id of the pair's first index and the second is the draw id of the pair's second index\n  function readDrawIds(\n    Accumulator storage accumulator,\n    Pair32 memory indices\n  ) internal view returns (Pair32 memory) {\n    return\n      Pair32({\n        first: uint16(accumulator.drawRingBuffer[indices.first]),\n        second: uint16(accumulator.drawRingBuffer[indices.second])\n      });\n  }\n\n  /// @notice Integrates from the given x to infinity for the exponential weighted average.\n  /// @param _alpha The exponential weighted average smoothing parameter.\n  /// @param _x The x value to integrate from.\n  /// @param _k The k value to scale the sum (this is the total available balance).\n  /// @return The integration from x to inf of the EWA for the given parameters.\n  function integrateInf(SD59x18 _alpha, uint _x, uint _k) internal pure returns (uint256) {\n    return uint256(fromSD59x18(computeC(_alpha, _x, _k)));\n  }\n\n  /// @notice Integrates from the given start x to end x for the exponential weighted average.\n  /// @param _alpha The exponential weighted average smoothing parameter.\n  /// @param _start The x value to integrate from.\n  /// @param _end The x value to integrate to\n  /// @param _k The k value to scale the sum (this is the total available balance).\n  /// @return The integration from start to end of the EWA for the given parameters.\n  function integrate(\n    SD59x18 _alpha,\n    uint _start,\n    uint _end,\n    uint _k\n  ) internal pure returns (uint256) {\n    int start = unwrap(computeC(_alpha, _start, _k));\n    int end = unwrap(computeC(_alpha, _end, _k));\n    return uint256(fromSD59x18(sd(start - end)));\n  }\n\n  /// @notice Computes the interim value C for the EWA.\n  /// @param _alpha The exponential weighted average smoothing parameter.\n  /// @param _x The x value to compute for\n  /// @param _k The total available balance\n  /// @return The value C\n  function computeC(SD59x18 _alpha, uint _x, uint _k) internal pure returns (SD59x18) {\n    return toSD59x18(int(_k)).mul(_alpha.pow(toSD59x18(int256(_x))));\n  }\n\n  /// @notice Binary searches an array of draw ids for the given target draw id.\n  /// @param _drawRingBuffer The array of draw ids to search\n  /// @param _oldestIndex The oldest index in the ring buffer\n  /// @param _newestIndex The newest index in the ring buffer\n  /// @param _cardinality The number of items in the ring buffer\n  /// @param _targetLastClosedDrawId The target draw id to search for\n  /// @return beforeOrAtIndex The index of the observation occurring at or before the target draw id\n  /// @return beforeOrAtDrawId The draw id of the observation occurring at or before the target draw id\n  /// @return afterOrAtIndex The index of the observation occurring at or after the target draw id\n  /// @return afterOrAtDrawId The draw id of the observation occurring at or after the target draw id\n  function binarySearch(\n    uint16[366] storage _drawRingBuffer,\n    uint16 _oldestIndex,\n    uint16 _newestIndex,\n    uint16 _cardinality,\n    uint16 _targetLastClosedDrawId\n  )\n    internal\n    view\n    returns (\n      uint16 beforeOrAtIndex,\n      uint16 beforeOrAtDrawId,\n      uint16 afterOrAtIndex,\n      uint16 afterOrAtDrawId\n    )\n  {\n    uint16 leftSide = _oldestIndex;\n    uint16 rightSide = _newestIndex < leftSide ? leftSide + _cardinality - 1 : _newestIndex;\n    uint16 currentIndex;\n\n    while (true) {\n      // We start our search in the middle of the `leftSide` and `rightSide`.\n      // After each iteration, we narrow down the search to the left or the right side while still starting our search in the middle.\n      currentIndex = (leftSide + rightSide) / 2;\n\n      beforeOrAtIndex = uint16(RingBufferLib.wrap(currentIndex, _cardinality));\n      beforeOrAtDrawId = _drawRingBuffer[beforeOrAtIndex];\n\n      afterOrAtIndex = uint16(RingBufferLib.nextIndex(currentIndex, _cardinality));\n      afterOrAtDrawId = _drawRingBuffer[afterOrAtIndex];\n\n      bool targetAtOrAfter = beforeOrAtDrawId <= _targetLastClosedDrawId;\n\n      // Check if we've found the corresponding Observation.\n      if (targetAtOrAfter && _targetLastClosedDrawId <= afterOrAtDrawId) {\n        break;\n      }\n\n      // If `beforeOrAtTimestamp` is greater than `_target`, then we keep searching lower. To the left of the current index.\n      if (!targetAtOrAfter) {\n        rightSide = currentIndex - 1;\n      } else {\n        // Otherwise, we keep searching higher. To the left of the current index.\n        leftSide = currentIndex + 1;\n      }\n    }\n  }\n}"
    },
    {
      "filename": "src/libraries/TierCalculationLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport { E, SD59x18, sd, unwrap, toSD59x18, fromSD59x18, ceil } from \"prb-math/SD59x18.sol\";\nimport { UD60x18, toUD60x18, fromUD60x18 } from \"prb-math/UD60x18.sol\";\n\n/// @title Tier Calculation Library\n/// @author PoolTogether Inc. Team\n/// @notice Provides helper functions to assist in calculating tier prize counts, frequency, and odds.\nlibrary TierCalculationLib {\n  /// @notice Calculates the odds of a tier occurring.\n  /// @param _tier The tier to calculate odds for\n  /// @param _numberOfTiers The total number of tiers\n  /// @param _grandPrizePeriod The number of draws between grand prizes\n  /// @return The odds that a tier should occur for a single draw.\n  function getTierOdds(\n    uint8 _tier,\n    uint8 _numberOfTiers,\n    uint16 _grandPrizePeriod\n  ) internal pure returns (SD59x18) {\n    SD59x18 _k = sd(1).div(sd(int16(_grandPrizePeriod))).ln().div(\n      sd((-1 * int8(_numberOfTiers) + 1))\n    );\n\n    return E.pow(_k.mul(sd(int8(_tier) - (int8(_numberOfTiers) - 1))));\n  }\n\n  /// @notice Estimates the number of draws between a tier occurring.\n  /// @param _tierOdds The odds for the tier to calculate the frequency of\n  /// @return The estimated number of draws between the tier occurring\n  function estimatePrizeFrequencyInDraws(SD59x18 _tierOdds) internal pure returns (uint256) {\n    return uint256(fromSD59x18(sd(1e18).div(_tierOdds).ceil()));\n  }\n\n  /// @notice Computes the number of prizes for a given tier.\n  /// @param _tier The tier to compute for\n  /// @return The number of prizes\n  function prizeCount(uint8 _tier) internal pure returns (uint256) {\n    uint256 _numberOfPrizes = 4 ** _tier;\n\n    return _numberOfPrizes;\n  }\n\n  /// @notice Computes the number of canary prizes as a fraction, based on the share distribution. This is important because the canary prizes should be indicative of the smallest prizes if\n  /// the number of prize tiers was to increase by 1.\n  /// @param _numberOfTiers The number of tiers\n  /// @param _canaryShares The number of shares allocated to canary prizes\n  /// @param _reserveShares The number of shares allocated to the reserve\n  /// @param _tierShares The number of shares allocated to prize tiers\n  /// @return The number of canary prizes, including fractional prizes.\n  function canaryPrizeCount(\n    uint8 _numberOfTiers,\n    uint8 _canaryShares,\n    uint8 _reserveShares,\n    uint8 _tierShares\n  ) internal pure returns (UD60x18) {\n    uint256 numerator = uint256(_canaryShares) *\n      ((_numberOfTiers + 1) * uint256(_tierShares) + _canaryShares + _reserveShares);\n    uint256 denominator = uint256(_tierShares) *\n      ((_numberOfTiers) * uint256(_tierShares) + _canaryShares + _reserveShares);\n    UD60x18 multiplier = toUD60x18(numerator).div(toUD60x18(denominator));\n    return multiplier.mul(toUD60x18(prizeCount(_numberOfTiers)));\n  }\n\n  /// @notice Determines if a user won a prize tier.\n  /// @param _userSpecificRandomNumber The random number to use as entropy\n  /// @param _userTwab The user's time weighted average balance\n  /// @param _vaultTwabTotalSupply The vault's time weighted average total supply\n  /// @param _vaultContributionFraction The portion of the prize that was contributed by the vault\n  /// @param _tierOdds The odds of the tier occurring\n  /// @return True if the user won the tier, false otherwise\n  function isWinner(\n    uint256 _userSpecificRandomNumber,\n    uint128 _userTwab,\n    uint128 _vaultTwabTotalSupply,\n    SD59x18 _vaultContributionFraction,\n    SD59x18 _tierOdds\n  ) internal pure returns (bool) {\n    if (_vaultTwabTotalSupply == 0) {\n      return false;\n    }\n    /*\n            The user-held portion of the total supply is the \"winning zone\". If the above pseudo-random number falls within the winning zone, the user has won this tier\n\n            However, we scale the size of the zone based on:\n                - Odds of the tier occuring\n                - Number of prizes\n                - Portion of prize that was contributed by the vault\n        */\n    // first constrain the random number to be within the vault total supply\n    uint256 constrainedRandomNumber = _userSpecificRandomNumber % (_vaultTwabTotalSupply);\n    uint256 winningZone = calculateWinningZone(_userTwab, _vaultContributionFraction, _tierOdds);\n\n    return constrainedRandomNumber < winningZone;\n  }\n\n  /// @notice Calculates a pseudo-random number that is unique to the user, tier, and winning random number.\n  /// @param _user The user\n  /// @param _tier The tier\n  /// @param _prizeIndex The particular prize index they are checking\n  /// @param _winningRandomNumber The winning random number\n  /// @return A pseudo-random number\n  function calculatePseudoRandomNumber(\n    address _user,\n    uint8 _tier,\n    uint32 _prizeIndex,\n    uint256 _winningRandomNumber\n  ) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encode(_user, _tier, _prizeIndex, _winningRandomNumber)));\n  }\n\n  /// @notice Calculates the winning zone for a user. If their pseudo-random number falls within this zone, they win the tier.\n  /// @param _userTwab The user's time weighted average balance\n  /// @param _vaultContributionFraction The portion of the prize that was contributed by the vault\n  /// @param _tierOdds The odds of the tier occurring\n  /// @return The winning zone for the user.\n  function calculateWinningZone(\n    uint256 _userTwab,\n    SD59x18 _vaultContributionFraction,\n    SD59x18 _tierOdds\n  ) internal pure returns (uint256) {\n    return\n      uint256(\n        fromSD59x18(toSD59x18(int256(_userTwab)).mul(_tierOdds).mul(_vaultContributionFraction))\n      );\n  }\n\n  /// @notice Computes the estimated number of prizes per draw given the number of tiers and the grand prize period.\n  /// @param _numberOfTiers The number of tiers\n  /// @param _grandPrizePeriod The grand prize period\n  /// @return The estimated number of prizes per draw\n  function estimatedClaimCount(\n    uint8 _numberOfTiers,\n    uint16 _grandPrizePeriod\n  ) internal pure returns (uint32) {\n    uint32 count = 0;\n    for (uint8 i = 0; i < _numberOfTiers; i++) {\n      count += uint32(\n        uint256(\n          unwrap(sd(int256(prizeCount(i))).mul(getTierOdds(i, _numberOfTiers, _grandPrizePeriod)))\n        )\n      );\n    }\n    return count;\n  }\n}"
    }
  ]
}