{
  "Title": "M-6: lenderKick incorrectly sets LUP",
  "Content": "# Issue M-6: lenderKick incorrectly sets LUP \n\nSource: https://github.com/sherlock-audit/2023-09-ajna-judging/issues/49 \n\n## Found by \n0xkaden\n\n`KickerActions.lenderKick` retrieves what the LUP would be if the lender's deposit were removed to validate collateralization of the borrower being kicked. The method doesn't actually add to the deposit but returns the incorrect LUP where it is later incorrectly used to update the interest rate.\n\n## Vulnerability Detail\n\nIn `KickerActions.lenderKick`, we compute the `entitledAmount` of quote tokens if the lender were to withdraw their whole position. We pass this value as `additionalDebt_` to `_kick` where it allows us to compute what the LUP would be if the lender removed their position. The function then proceeds to validate that the new LUP would leave the borrower undercollateralized, and if so, kick that borrower. \n\nThe problem is that we then return the computed LUP even though we aren't actually removing the lender's quote tokens. In `Pool.lenderKick`, we then pass this incorrect LUP to `_updateInterestState` where it is used to incorrectly update the `lupt0DebtEma`, which is used to calculate the interest rate, leading to an incorrect rate.\n\n## Impact\n\nBroken core invariant related to interest rate calculation. Impact on interest rate is dependent upon size of lender's position relative to total deposit size.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/KickerActions.sol#L296\n```solidity\n// add amount to remove to pool debt in order to calculate proposed LUP\n// for regular kick this is the currrent LUP in pool\n// for provisional kick this simulates LUP movement with additional debt\nkickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + additionalDebt_);\n```\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/base/Pool.sol#L363\n```solidity\n_updateInterestState(poolState, result.lup);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCalculate the actual LUP as `kickResult_.lup`, then calculate the simulated LUP separately with an unrelated variable.\n\n\n\n## Discussion\n\n**ith-harvey**\n\nDoes not meet validity criteria for `Medium`. Will fix it.\n\n**neeksec**\n\nKeep `Medium` since this issue leads to an incorrect interest rate.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/114",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/external/KickerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { Math }     from '@openzeppelin/contracts/utils/math/Math.sol';\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Lender,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                             from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    KickReserveAuctionParams\n}                             from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    MAX_INFLATED_PRICE,\n    _bondParams,\n    _bpf,\n    _claimableReserves,\n    _isCollateralized,\n    _priceAt,\n    _reserveAuctionPrice\n}                                   from '../helpers/PoolHelper.sol';\nimport {\n    _revertIfPriceDroppedBelowLimit\n}                                   from '../helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auctions kicker actions library\n    @notice External library containing kicker actions involving auctions within pool:\n            - kick undercollateralized loans; start reserve auctions\n */\nlibrary KickerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `kick` function local vars.\n    struct KickLocalVars {\n        uint256 borrowerDebt;       // [WAD] the accrued debt of kicked borrower\n        uint256 borrowerCollateral; // [WAD] amount of kicked borrower collateral\n        uint256 neutralPrice;       // [WAD] neutral price recorded in kick action\n        uint256 htp;                // [WAD] highest threshold price in pool\n        uint256 referencePrice;     // [WAD] used to calculate auction start price\n        uint256 bondFactor;         // [WAD] bond factor of kicked auction\n        uint256 bondSize;           // [WAD] bond size of kicked auction\n    }\n\n    /// @dev Struct used for `lenderKick` function local vars.\n    struct LenderKickLocalVars {\n        uint256 bucketDeposit;  // [WAD] amount of quote tokens in bucket\n        uint256 bucketPrice;    // [WAD] bucket price\n        uint256 entitledAmount; // [WAD] amount that lender is entitled to remove at specified index\n        uint256 lenderLP;       // [WAD] LP of lender in bucket\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event Kick(address indexed borrower, uint256 debt, uint256 collateral, uint256 bond);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);\n    event KickReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice, uint256 currentBurnEpoch);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionActive();\n    error BorrowerOk();\n    error InsufficientLiquidity();\n    error InsufficientLP();\n    error InvalidAmount();\n    error NoReserves();\n    error PriceBelowLUP();\n    error ReserveAuctionTooSoon();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolKickerActions` for descriptions.\n     *  @return The `KickResult` struct result of the kick action.\n     */\n    function kick(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 limitIndex_\n    ) external returns (\n        KickResult memory\n    ) {\n        return _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrowerAddress_,\n            limitIndex_,\n            0\n        );\n    }\n\n    /**\n     *  @notice See `IPoolKickerActions` for descriptions.\n     *  @dev    === Reverts on ===\n     *  @dev    bucket price below current pool `LUP` `PriceBelowLUP()`\n     *  @dev    insufficient deposit to kick auction `InsufficientLiquidity()`\n     *  @return kickResult_ The `KickResult` struct result of the kick action.\n     */\n    function lenderKick(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        mapping(uint256 => Bucket) storage buckets_,\n        LoansState storage loans_,\n        PoolState calldata poolState_,\n        uint256 index_,\n        uint256 limitIndex_\n    ) external returns (\n        KickResult memory kickResult_\n    ) {\n        LenderKickLocalVars memory vars;\n\n        vars.bucketPrice = _priceAt(index_);\n\n        // revert if the bucket price is below current LUP\n        if (vars.bucketPrice < Deposits.getLup(deposits_, poolState_.debt)) revert PriceBelowLUP();\n\n        Bucket storage bucket = buckets_[index_];\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        vars.lenderLP      = bucket.bankruptcyTime < lender.depositTime ? lender.lps : 0;\n        vars.bucketDeposit = Deposits.valueAt(deposits_, index_);\n\n        // calculate amount lender is entitled in current bucket (based on lender LP in bucket)\n        vars.entitledAmount = Buckets.lpToQuoteTokens(\n            bucket.collateral,\n            bucket.lps,\n            vars.bucketDeposit,\n            vars.lenderLP,\n            vars.bucketPrice,\n            Math.Rounding.Down\n        );\n\n        // cap the amount entitled at bucket deposit\n        if (vars.entitledAmount > vars.bucketDeposit) vars.entitledAmount = vars.bucketDeposit;\n\n        // revert if no entitled amount\n        if (vars.entitledAmount == 0) revert InsufficientLiquidity();\n\n        // kick top borrower\n        kickResult_ = _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            Loans.getMax(loans_).borrower,\n            limitIndex_,\n            vars.entitledAmount\n        );\n    }\n\n    /*************************/\n    /***  Reserve Auction  ***/\n    /*************************/\n\n    /**\n     *  @notice See `IPoolKickerActions` for descriptions.\n     *  @dev    === Write state ===\n     *  @dev    update `reserveAuction.unclaimed` accumulator\n     *  @dev    update `reserveAuction.kicked` timestamp state\n     *  @dev    === Reverts on ===\n     *  @dev    no reserves to claim `NoReserves()`\n     *  @dev    === Emit events ===\n     *  @dev    - `KickReserveAuction`\n     */\n    function kickReserveAuction(\n        AuctionsState storage auctions_,\n        ReserveAuctionState storage reserveAuction_,\n        KickReserveAuctionParams calldata params_\n    ) external {\n        // retrieve timestamp of latest burn event and last burn timestamp\n        uint256 latestBurnEpoch   = reserveAuction_.latestBurnEventEpoch;\n        uint256 lastBurnTimestamp = reserveAuction_.burnEvents[latestBurnEpoch].timestamp;\n\n        // check that at least two weeks have passed since the last reserve auction completed, and that the auction was not kicked within the past 72 hours\n        if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {\n            revert ReserveAuctionTooSoon();\n        }\n\n        uint256 curUnclaimedAuctionReserve = reserveAuction_.unclaimed;\n\n        uint256 claimable = _claimableReserves(\n            Maths.wmul(params_.t0PoolDebt, params_.inflator),\n            params_.poolSize,\n            auctions_.totalBondEscrowed,\n            curUnclaimedAuctionReserve,\n            params_.poolBalance\n        );\n\n        curUnclaimedAuctionReserve += claimable;\n\n        if (curUnclaimedAuctionReserve == 0) revert NoReserves();\n\n        reserveAuction_.unclaimed = curUnclaimedAuctionReserve;\n        reserveAuction_.kicked    = block.timestamp;\n\n        // increment latest burn event epoch and update burn event timestamp\n        latestBurnEpoch += 1;\n\n        reserveAuction_.latestBurnEventEpoch = latestBurnEpoch;\n        reserveAuction_.burnEvents[latestBurnEpoch].timestamp = block.timestamp;\n\n        emit KickReserveAuction(\n            curUnclaimedAuctionReserve,\n            _reserveAuctionPrice(block.timestamp),\n            latestBurnEpoch\n        );\n    }\n\n    /***************************/\n    /***  Internal Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Called to start borrower liquidation and to update the auctions queue.\n     *  @dev    === Write state ===\n     *  @dev    - `_recordAuction`:\n     *  @dev      `borrower -> liquidation` mapping update\n     *  @dev      increment `auctions count` accumulator\n     *  @dev      increment `auctions.totalBondEscrowed` accumulator\n     *  @dev      updates auction queue state\n     *  @dev    - `_updateEscrowedBonds`:\n     *  @dev      update `locked` and `claimable` kicker accumulators\n     *  @dev    - `Loans.remove`:\n     *  @dev      delete borrower from `indices => borrower` address mapping\n     *  @dev      remove loan from loans array\n     *  @dev    === Emit events ===\n     *  @dev    - `Kick`\n     *  @param  auctions_        Struct for pool auctions state.\n     *  @param  deposits_        Struct for pool deposits state.\n     *  @param  loans_           Struct for pool loans state.\n     *  @param  poolState_       Current state of the pool.\n     *  @param  borrowerAddress_ Address of the borrower to kick.\n     *  @param  limitIndex_      Index of the lower bound of `NP` tolerated when kicking the auction.\n     *  @param  additionalDebt_  Additional debt to be used when calculating proposed `LUP`.\n     *  @return kickResult_      The `KickResult` struct result of the kick action.\n     */\n    function _kick(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 limitIndex_,\n        uint256 additionalDebt_\n    ) internal returns (\n        KickResult memory kickResult_\n    ) {\n        Liquidation storage liquidation = auctions_.liquidations[borrowerAddress_];\n        // revert if liquidation is active\n        if (liquidation.kickTime != 0) revert AuctionActive();\n\n        Borrower storage borrower = loans_.borrowers[borrowerAddress_];\n\n        kickResult_.t0KickedDebt        = borrower.t0Debt;\n        kickResult_.collateralPreAction = borrower.collateral;\n\n        // add amount to remove to pool debt in order to calculate proposed LUP\n        // for regular kick this is the currrent LUP in pool\n        // for provisional kick this simulates LUP movement with additional debt\n        kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + additionalDebt_);\n\n        KickLocalVars memory vars;\n        vars.borrowerDebt       = Maths.wmul(kickResult_.t0KickedDebt, poolState_.inflator);\n        vars.borrowerCollateral = kickResult_.collateralPreAction;\n\n        // revert if kick on a collateralized borrower\n        if (_isCollateralized(vars.borrowerDebt, vars.borrowerCollateral, kickResult_.lup, poolState_.poolType)) {\n            revert BorrowerOk();\n        }\n\n        // calculate auction params\n        // neutral price = Tp * Np to Tp ratio\n        // neutral price is capped at 50 * max pool price\n        vars.neutralPrice = Maths.min(\n            Math.mulDiv(vars.borrowerDebt, borrower.npTpRatio, vars.borrowerCollateral),\n            MAX_INFLATED_PRICE\n        );\n        // check if NP is not less than price at the limit index provided by the kicker - done to prevent frontrunning kick auction call with a large amount of loan\n        // which will make it harder for kicker to earn a reward and more likely that the kicker is penalized\n        _revertIfPriceDroppedBelowLimit(vars.neutralPrice, limitIndex_);\n\n        vars.htp            = Maths.wmul(Loans.getMax(loans_).thresholdPrice, poolState_.inflator);\n        vars.referencePrice = Maths.min(Maths.max(vars.htp, vars.neutralPrice), MAX_INFLATED_PRICE);\n\n        (vars.bondFactor, vars.bondSize) = _bondParams(\n            vars.borrowerDebt,\n            borrower.npTpRatio\n        );\n\n        // record liquidation info\n        _recordAuction(\n            auctions_,\n            liquidation,\n            borrowerAddress_,\n            vars.bondSize,\n            vars.bondFactor,\n            vars.referencePrice,\n            vars.neutralPrice\n        );\n\n        // update escrowed bonds balances and get the difference needed to cover bond (after using any kick claimable funds if any)\n        kickResult_.amountToCoverBond = _updateEscrowedBonds(auctions_, vars.bondSize);\n\n        // remove kicked loan from heap\n        Loans.remove(loans_, borrowerAddress_, loans_.indices[borrowerAddress_]);\n\n        emit Kick(\n            borrowerAddress_,\n            vars.borrowerDebt,\n            vars.borrowerCollateral,\n            vars.bondSize\n        );\n    }\n\n    /**\n     *  @notice Updates escrowed bonds balances, reuse kicker claimable funds and calculates difference needed to cover new bond.\n     *  @dev    === Write state ===\n     *  @dev    update `locked` and `claimable` kicker accumulators\n     *  @dev    update `totalBondEscrowed` accumulator\n     *  @param  auctions_       Struct for pool auctions state.\n     *  @param  bondSize_       Bond size to cover newly kicked auction.\n     *  @return bondDifference_ The amount that kicker should send to pool to cover auction bond.\n     */\n    function _updateEscrowedBonds(\n        AuctionsState storage auctions_,\n        uint256 bondSize_\n    ) internal returns (uint256 bondDifference_){\n        Kicker storage kicker = auctions_.kickers[msg.sender];\n\n        kicker.locked += bondSize_;\n\n        uint256 kickerClaimable = kicker.claimable;\n\n        if (kickerClaimable >= bondSize_) {\n            // no need to update total bond escrowed as bond is covered by kicker claimable (which is already tracked by accumulator)\n            kicker.claimable -= bondSize_;\n        } else {\n            bondDifference_  = bondSize_ - kickerClaimable;\n            kicker.claimable = 0;\n\n            // increment total bond escrowed by amount needed to cover bond difference\n            auctions_.totalBondEscrowed += bondDifference_;\n        }\n    }\n\n    /**\n     *  @notice Saves in storage a new liquidation that was kicked.\n     *  @dev    === Write state ===\n     *  @dev    `borrower -> liquidation` mapping update\n     *  @dev    increment auctions count accumulator\n     *  @dev    updates auction queue state\n     *  @param  auctions_        Struct for pool auctions state.\n     *  @param  liquidation_     Struct for current auction state.\n     *  @param  borrowerAddress_ Address of the borrower that is kicked.\n     *  @param  bondSize_        Bond size to cover newly kicked auction.\n     *  @param  bondFactor_      Bond factor of the newly kicked auction.\n     *  @param  referencePrice_  Used to calculate auction start price.\n     *  @param  neutralPrice_    Current pool `Neutral Price`.\n     */\n    function _recordAuction(\n        AuctionsState storage auctions_,\n        Liquidation storage liquidation_,\n        address borrowerAddress_,\n        uint256 bondSize_,\n        uint256 bondFactor_,\n        uint256 referencePrice_,\n        uint256 neutralPrice_\n    ) internal {\n        // record liquidation info\n        liquidation_.kicker         = msg.sender;\n        liquidation_.kickTime       = uint96(block.timestamp);\n        liquidation_.referencePrice = SafeCast.toUint96(referencePrice_);\n        liquidation_.bondSize       = SafeCast.toUint160(bondSize_);\n        liquidation_.bondFactor     = SafeCast.toUint96(bondFactor_);\n        liquidation_.neutralPrice   = SafeCast.toUint96(neutralPrice_);\n\n        // increment number of active auctions\n        ++auctions_.noOfAuctions;\n\n        // update auctions queue\n        if (auctions_.head != address(0)) {\n            // other auctions in queue, liquidation doesn't exist or overwriting.\n            auctions_.liquidations[auctions_.tail].next = borrowerAddress_;\n            liquidation_.prev = auctions_.tail;\n        } else {\n            // first auction in queue\n            auctions_.head = borrowerAddress_;\n        }\n        // update liquidation with the new ordering\n        auctions_.tail = borrowerAddress_;\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/base/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { Clone }           from '@clones/Clone.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { SafeERC20 }       from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }          from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {\n    IPool,\n    IPoolImmutables,\n    IPoolBorrowerActions,\n    IPoolLPActions,\n    IPoolLenderActions,\n    IPoolKickerActions,\n    IPoolTakerActions,\n    IPoolSettlerActions,\n    IPoolState,\n    IPoolDerivedState,\n    IERC20Token\n}                                    from '../interfaces/pool/IPool.sol';\nimport {\n    PoolState,\n    AuctionsState,\n    DepositsState,\n    Loan,\n    LoansState,\n    InflatorState,\n    EmaState,\n    InterestState,\n    PoolBalancesState,\n    ReserveAuctionState,\n    Bucket,\n    Lender,\n    Borrower,\n    Kicker,\n    BurnEvent,\n    Liquidation\n}                                   from '../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    SettleResult,\n    TakeResult,\n    RemoveQuoteParams,\n    MoveQuoteParams,\n    AddQuoteParams,\n    KickReserveAuctionParams\n}                                   from '../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _priceAt,\n    _roundToScale\n}                               from '../libraries/helpers/PoolHelper.sol';\nimport {\n    _revertIfAuctionDebtLocked,\n    _revertIfAuctionClearable,\n    _revertAfterExpiry\n}                               from '../libraries/helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../libraries/internal/Buckets.sol';\nimport { Deposits } from '../libraries/internal/Deposits.sol';\nimport { Loans }    from '../libraries/internal/Loans.sol';\nimport { Maths }    from '../libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from '../libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from '../libraries/external/LenderActions.sol';\nimport { LPActions }       from '../libraries/external/LPActions.sol';\nimport { KickerActions }   from '../libraries/external/KickerActions.sol';\nimport { TakerActions }    from '../libraries/external/TakerActions.sol';\nimport { PoolCommons }     from '../libraries/external/PoolCommons.sol';\n\n/**\n *  @title  Pool Contract\n *  @dev    Base contract and entrypoint for commong logic of both `ERC20` and `ERC721` pools.\n */\nabstract contract Pool is Clone, ReentrancyGuard, Multicall, IPool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /// @dev Immutable pool type arg offset.\n    uint256 internal constant POOL_TYPE          = 0;\n    /// @dev Immutable `Ajna` token address arg offset.\n    uint256 internal constant AJNA_ADDRESS       = 1;\n    /// @dev Immutable collateral token address arg offset.\n    uint256 internal constant COLLATERAL_ADDRESS = 21;\n    /// @dev Immutable quote token address arg offset.\n    uint256 internal constant QUOTE_ADDRESS      = 41;\n    /// @dev Immutable quote token scale arg offset.\n    uint256 internal constant QUOTE_SCALE        = 61;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    AuctionsState       internal auctions;\n    DepositsState       internal deposits;\n    LoansState          internal loans;\n    InflatorState       internal inflatorState;\n    EmaState            internal emaState;\n    InterestState       internal interestState;\n    PoolBalancesState   internal poolBalances;\n    ReserveAuctionState internal reserveAuction;\n\n    /// @dev deposit index -> bucket mapping\n    mapping(uint256 => Bucket) internal buckets;\n\n    bool internal isPoolInitialized;\n\n    /// @dev owner address -> new owner address -> deposit index -> allowed amount mapping\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lpAllowances;\n\n    /// @dev owner address -> transferor address -> approved flag mapping\n    mapping(address => mapping(address => bool)) public override approvedTransferors;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IPoolImmutables\n    function poolType() external pure override returns (uint8) {\n        return _getArgUint8(POOL_TYPE);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function collateralAddress() external pure override returns (address) {\n        return _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenAddress() external pure override returns (address) {\n        return _getArgAddress(QUOTE_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenScale() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /// @inheritdoc IPoolLenderActions\n    function addQuoteToken(\n        uint256 amount_,\n        uint256 index_,\n        uint256 expiry_,\n        bool    revertIfBelowLup_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertAfterExpiry(expiry_);\n\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        amount_ = _roundToScale(amount_, poolState.quoteTokenScale);\n\n        uint256 newLup;\n        (bucketLP_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount:           amount_,\n                index:            index_,\n                revertIfBelowLup: revertIfBelowLup_\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from lender to pool\n        _transferQuoteTokenFrom(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmount_,\n        uint256 fromIndex_,\n        uint256 toIndex_,\n        uint256 expiry_,\n        bool    revertIfBelowLup_\n    ) external override nonReentrant returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_) {\n        _revertAfterExpiry(expiry_);\n\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, fromIndex_, poolState.inflator);\n\n        MoveQuoteParams memory moveParams;\n        moveParams.maxAmountToMove  = maxAmount_;\n        moveParams.fromIndex        = fromIndex_;\n        moveParams.toIndex          = toIndex_;\n        moveParams.thresholdPrice   = Loans.getMax(loans).thresholdPrice;\n        moveParams.revertIfBelowLup = revertIfBelowLup_;\n\n        uint256 newLup;\n        (\n            fromBucketLP_,\n            toBucketLP_,\n            movedAmount_,\n            newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            moveParams\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function removeQuoteToken(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLP_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, index_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLP_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            RemoveQuoteParams({\n                maxAmount:      Maths.min(maxAmount_, _availableQuoteToken()),\n                index:          index_,\n                thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from pool to lender\n        _transferQuoteToken(msg.sender, removedAmount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function updateInterest() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n        _updateInterestState(poolState, Deposits.getLup(deposits, poolState.debt));\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /// @inheritdoc IPoolBorrowerActions\n    function stampLoan() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 newLup = BorrowerActions.stampLoan(\n            auctions,\n            deposits,\n            loans,\n            poolState\n        );\n\n        _updateInterestState(poolState, newLup);\n    }\n\n    /*****************************/\n    /*** Liquidation Functions ***/\n    /*****************************/\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `poolBalances.t0DebtInAuction` and `poolBalances.t0Debt` accumulators\n     *  @dev    update `t0Debt2ToCollateral` ratio, debt and collateral post action are considered 0\n     */\n    function kick(\n        address borrower_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n        KickResult memory result = KickerActions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrower_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.t0KickedDebt,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0  // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n        // update pool interest rate state\n        _updateInterestState(poolState, result.lup);\n\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     */\n    function lenderKick(\n        uint256 index_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auctions\n        KickResult memory result = KickerActions.lenderKick(\n            auctions,\n            deposits,\n            buckets,\n            loans,\n            poolState,\n            index_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.t0KickedDebt,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0 // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n\n        // update pool interest rate state\n        _updateInterestState(poolState, result.lup);\n\n        // transfer from kicker to pool the difference to cover bond\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    decrease kicker's `claimable` accumulator\n     *  @dev    decrease auctions `totalBondEscrowed` accumulator\n     */\n    function withdrawBonds(\n        address recipient_,\n        uint256 maxAmount_\n    ) external override nonReentrant {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n\n        // the amount to claim is constrained by the claimable balance of sender\n        // claiming escrowed bonds is not constraiend by the pool balance\n        maxAmount_ = Maths.min(maxAmount_, claimable);\n\n        // revert if no amount to claim\n        if (maxAmount_ == 0) revert InsufficientLiquidity();\n\n        // decrement total bond escrowed\n        auctions.totalBondEscrowed             -= maxAmount_;\n        auctions.kickers[msg.sender].claimable -= maxAmount_;\n\n        emit BondWithdrawn(msg.sender, recipient_, maxAmount_);\n\n        _transferQuoteToken(recipient_, maxAmount_);\n    }\n\n    /*********************************/\n    /*** Reserve Auction Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `latestBurnEpoch` counter\n     *  @dev    update `reserveAuction.latestBurnEventEpoch` and burn event `timestamp` state\n     *  @dev    === Reverts on ===\n     *  @dev    2 weeks not passed `ReserveAuctionTooSoon()`\n     *  @dev    === Emit events ===\n     *  @dev    - `KickReserveAuction`\n     */\n    function kickReserveAuction() external override nonReentrant {\n        // start a new claimable reserve auction, passing in relevant parameters such as the current pool size, debt, balance, and inflator value\n        KickerActions.kickReserveAuction(\n            auctions,\n            reserveAuction,\n            KickReserveAuctionParams({\n                poolSize:    Deposits.treeSum(deposits),\n                t0PoolDebt:  poolBalances.t0Debt,\n                poolBalance: _getNormalizedPoolQuoteTokenBalance(),\n                inflator:    inflatorState.inflator\n            })\n        );\n    }\n\n    /**\n     *  @inheritdoc IPoolTakerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `reserveAuction.totalAjnaBurned` accumulator\n     *  @dev    update burn event `totalInterest` and `totalBurned` accumulators\n     */\n    function takeReserves(\n        uint256 maxAmount_\n    ) external override nonReentrant returns (uint256 amount_) {\n        uint256 ajnaRequired;\n        (amount_, ajnaRequired) = TakerActions.takeReserves(\n            reserveAuction,\n            maxAmount_\n        );\n\n        // burn required number of ajna tokens to take quote from reserves\n        IERC20(_getArgAddress(AJNA_ADDRESS)).safeTransferFrom(msg.sender, address(this), ajnaRequired);\n\n        IERC20Token(_getArgAddress(AJNA_ADDRESS)).burn(ajnaRequired);\n\n        // transfer quote token to caller\n        _transferQuoteToken(msg.sender, amount_);\n    }\n\n    /*****************************/\n    /*** Transfer LP Functions ***/\n    /*****************************/\n\n    /// @inheritdoc IPoolLPActions\n    function increaseLPAllowance(\n        address spender_,\n        uint256[] calldata indexes_,\n        uint256[] calldata amounts_\n    ) external override nonReentrant {\n        LPActions.increaseLPAllowance(\n            _lpAllowances[msg.sender][spender_],\n            spender_,\n            indexes_,\n            amounts_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function decreaseLPAllowance(\n        address spender_,\n        uint256[] calldata indexes_,\n        uint256[] calldata amounts_\n    ) external override nonReentrant {\n        LPActions.decreaseLPAllowance(\n            _lpAllowances[msg.sender][spender_],\n            spender_,\n            indexes_,\n            amounts_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function revokeLPAllowance(\n        address spender_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LPActions.revokeLPAllowance("
    }
  ]
}