{
  "Title": "M-2: Position closure might always revert in some cases due to allocatedBalances being unsigned, preventing the user from closing its positions",
  "Content": "# Issue M-2: Position closure might always revert in some cases due to allocatedBalances being unsigned, preventing the user from closing its positions \n\nSource: https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/10 \n\n## Found by \npanprog\n\nThis is [issue 193](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/193) from the previous audit contest. The liquidation part was fixed, but the main reason described here is still the same.\n\nAllocated balances are stored as unsigned ints. \n\nhttps://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/storages/AccountStorage.sol#L37\n\nhttps://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/storages/AccountStorage.sol#L41\n\nTotal account value is calculated as `allocated balance + unrealized pnl`, for example for liquidation purposes it's calculated as:\n\nhttps://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/libraries/LibAccount.sol#L83-L85\n\nIn the other cases formula is similar. This means that in case of high unrealized profit, allocated balance might be valid to be negative. For example, a simple case is if account has opened position with unrealized profit of 1000 and locked balance of 100, allocated balance can theoretically be `-900` with account being safe from liquidation: `-900 + 1000 = 100 >= lockedBalance(100)`. But since balance is unsigned, transaction to deallocate such balance will revert. This might be expected behaviour.\n\nHowever, there are more complex cases possible where unsigned allocated balance can unexpectedly revert different transactions and block users from doing important actions. For example, if user has 2 opposite positions opened of the same quantity (LONG and SHORT) and price has moved significantly, total user `upnl = 0` (because opposite positions hedge each other completely). But the user will be unable to close either of these positions, because closing any position will subract high loss from the position from either partyA or partyB, which will make allocated balance negative and revert the transaction:\n\nBefore closing position: \n\n`Account Balance = Position 1 UPNL (+1000) + Position 2 UPNL (-1000) + Allocated Balance (100) = +100` (account solvent)\n\nAfter closing position: \n\n`Account Balance should be = Position 1 UPNL (+1000) + Allocated Balance (-900) = +100` (account solvent), but it will revert.\n\nAs such, both partyA and partyB will lose funds deposited into the protocol to keep these positions alive. It will also be impossible to finish liquidation of such positions if any account becomes liquidatable, effectively locking the funds for extended time (until price is in the range where positions can be closed without big loss).\n\n## Vulnerability Detail\n\nThe scenario when user unexpectedly can't close position and loses funds:\n\n1. Open 2 large opposite positions between partyA and partyB such that one of them is in a high loss and the other in the same profit. Use minimal allocated balance both for partyA and partyB (because such opposite positions can't be liquidated by themselves as they perfectly hedge each other).\n2. When price moves significantly, try to close either of these positions, both will revert.\n3. Both partyA and partyB are stuck with the funds in the protocol which they can't take out until price goes back close to initial value.\n\nThere might be the other cases with unexpected reverts and users being unable to close their positions.\n\n## Impact\n\nPartyA and PartyB funds can be unexpectedly locked in the protocol for extended time. PartyA or PartyB can allocate additional funds to be able to close positions, then deallocate and withdraw, however depending on situation, required funds to close such position might be orders of magnitude higher than what parties have or are willing to risk (due to leverage).\n\nThis is High severity, because the situation can happen by itself for users having multiple positions: naturally some of them will be in profit, some in loss, and total upnl can be much smaller than individual positions, allowing a low allocated balance and making it impossible to close some positions.\n\n## Code Snippet\n\nAdd this to any test, for example to `ClosePosition.behavior.ts`.\n\n```ts\nit(\"Unable to close positions due to unsigned allocatedBalances\", async function () {\n  const context: RunContext = this.context;\n\n  this.user_allocated = decimal(82);\n  this.hedger_allocated = decimal(80);\n\n  this.user = new User(this.context, this.context.signers.user);\n  await this.user.setup();\n  await this.user.setBalances(this.user_allocated, this.user_allocated, this.user_allocated);\n\n  this.hedger = new Hedger(this.context, this.context.signers.hedger);\n  await this.hedger.setup();\n  await this.hedger.setBalances(this.hedger_allocated, this.hedger_allocated);\n\n  // open 2 opposite direction positions \n  await this.user.sendQuote(limitQuoteRequestBuilder()\n    .quantity(decimal(100))\n    .price(decimal(1))\n    .cva(decimal(10)).lf(decimal(5)).mm(decimal(15))\n    .build()\n  );\n  await this.hedger.lockQuote(1, 0, decimal(4, 17));\n  await this.hedger.openPosition(1, limitOpenRequestBuilder().filledAmount(decimal(100)).openPrice(decimal(1)).price(decimal(1)).build());\n\n  await this.user.sendQuote(limitQuoteRequestBuilder()\n    .positionType(PositionType.SHORT)\n    .quantity(decimal(100))\n    .price(decimal(1))\n    .cva(decimal(10)).lf(decimal(5)).mm(decimal(15))\n    .build()\n  );\n  await this.hedger.lockQuote(2, 0, decimal(4, 17));\n  await this.hedger.openPosition(2, limitOpenRequestBuilder().filledAmount(decimal(100)).openPrice(decimal(1)).price(decimal(1)).build());\n\n  var info = await this.user.getBalanceInfo();\n  console.log(\"partyA allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n  var info = await this.hedger.getBalanceInfo(this.user.getAddress());\n  console.log(\"partyB allocated: \" + info.allocatedBalances / 1e18 + \" locked: \" + info.totalLocked/1e18 + \" pendingLocked: \" + info.totalPendingLocked / 1e18);\n\n  // now the price doubles, with upnl still 0\n  // try to close LONG position\n\n  await this.user.requestToClosePosition(\n    1,\n    limitCloseRequestBuilder().quantityToClose(decimal(100)).closePrice(decimal(2)).build(),\n  );\n\n  await expect(this.hedger.fillCloseRequest(\n    1,\n    limitFillCloseRequestBuilder()\n      .filledAmount(decimal(100))\n      .closedPrice(decimal(2))\n      .build(),\n  )).to.be.revertedWith(\"LibSolvency: PartyB will be liquidatable\");\n  \n  console.log(\"Attempt to close LONG position failed due to partyB being liquidatable\");\n\n  // try to close SHORT position\n  await expect(this.user.requestToClosePosition(\n    2,\n    limitCloseRequestBuilder().quantityToClose(decimal(100)).closePrice(decimal(2)).build(),\n    )).to.be.revertedWith(\"LibSolvency: partyA will be liquidatable\");\n\n  console.log(\"Attempt to close SHORT position failed due to partyA being liquidatable\");\n\n});\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMake allocated balances signed ints and change all appropriate parts where allocated balances are changed or verified. This will be more user-friendly (less limiting) and will prevent situations described in this bug report.\n\n\n\n## Discussion\n\n**nevillehuang**\n\n@MoonKnightDev, seems possible due to possibility of UPNL being negative causing allocated balance to fall below 0 and reverting since it is an uint. Could you shed some light on why this is disputed?\n\n**MoonKnightDev**\n\n> @MoonKnightDev, seems possible due to possibility of UPNL being negative causing allocated balance to fall below 0 and reverting since it is an uint. Could you shed some light on why this is disputed?\n\nOne of the recognized challenges with cross positions relates to the scenario described above. To navigate this predicament:\n\nIf PartyA wishes to close the winning position, PartyB must allocate funds to fulfill the close request.\nShould PartyB act maliciously, PartyA should first allocate funds to close the losing position and then proceed to close the winning one.\n\n**panprog**\n\nEscalate\n\nI believe this should be valid, because it causes all kinds of nasty underflows, the example I provided is just one scenario. Another scenario is partyA having allocated balance = 0 and positions in loss and profit with different partyBs, and then if partyB tries to call `emergencyClosePosition`, it will revert due to underflow (partyA position is in loss, but partyA allocated balance = 0, so the loss can not be applied).\n\n> One of the recognized challenges with cross positions relates to the scenario described above. To navigate this predicament:\n> \n> If PartyA wishes to close the winning position, PartyB must allocate funds to fulfill the close request. Should PartyB act maliciously, PartyA should first allocate funds to close the losing position and then proceed to close the winning one.\n\nWhile it's possible to allocate and then close for partyA, this is still unexpected behavior for partyA: if it has position 1 in profit and position 2 in a loss, and it only wants to close position 1 (to realize profit), partyA will be unable to do so - all transactions will revert due to partyB allocatedBalance underflow when trying to apply position loss. So partyA **must** close position 2, then position 1.\n\nAnother point to consider is that partyA might simply have not enough funds to allocate, close position 2, close position 1. For example, partyA opens huge long and short positions of similar size when ETH = 1000, with leverage = 10:\nPosition 1: long 100 ETH (entry price = 1000) (cva+lf+mm=10000)\nPosition 2: short 99 ETH (entry price = 1000) (cva+lf+mm=10000)\nNow ETH price shoots up to 2000. Both PartyA and PartyB still have 20000 collateral (which is enough to not be liquidated, because partyB total upnl is just 1000).\npartyA wants to close Position 1. Since it requires to reduce partyB allocatedBalance by 100 * (2000-1000) = 100000, it reverts.\n\nNow if partyA wants to close Position 1, it first has to close Position 2, but in order to close it, partyA must have allocated balance of 99 * (2000 - 1000) = 99000. But partyA only has 20000, it doesn't have access to such huge amount. So it's still stuck.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> I believe this should be valid, because it causes all kinds of nasty underflows, the example I provided is just one scenario. Another scenario is partyA having allocated balance = 0 and positions in loss and profit with different partyBs, and then if partyB tries to call `emergencyClosePosition`, it will revert due to underflow (partyA position is in loss, but partyA allocated balance = 0, so the loss can not be applied).\n> \n> > One of the recognized challenges with cross positions relates to the scenario described above. To navigate this predicament:\n> > \n> > If PartyA wishes to close the winning position, PartyB must allocate funds to fulfill the close request. Should PartyB act maliciously, PartyA should first allocate funds to close the losing position and then proceed to close the winning one.\n> \n> While it's possible to allocate and then close for partyA, this is still unexpected behavior for partyA: if it has position 1 in profit and position 2 in a loss, and it only wants to close position 1 (to realize profit), partyA will be unable to do so - all transactions will revert due to partyB allocatedBalance underflow when trying to apply position loss. So partyA **must** close position 2, then position 1.\n> \n> Another point to consider is that partyA might simply have not enough funds to allocate, close position 2, close position 1. For example, partyA opens huge long and short positions of similar size when ETH = 1000, with leverage = 10:\n> Position 1: long 100 ETH (entry price = 1000) (cva+lf+mm=10000)\n> Position 2: short 99 ETH (entry price = 1000) (cva+lf+mm=10000)\n> Now ETH price shoots up to 2000. Both PartyA and PartyB still have 20000 collateral (which is enough to not be liquidated, because partyB total upnl is just 1000).\n> partyA wants to close Position 1. Since it requires to reduce partyB allocatedBalance by 100 * (2000-1000) = 100000, it reverts.\n> \n> Now if partyA wants to close Position 1, it first has to close Position 2, but in order to close it, partyA must have allocated balance of 99 * (2000 - 1000) = 99000. But partyA only has 20000, it doesn't have access to such huge amount. So it's still stuck.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n> Escalate\n> \n> I believe this should be valid, because it causes all kinds of nasty underflows, the example I provided is just one scenario. Another scenario is partyA having allocated balance = 0 and positions in loss and profit with different partyBs, and then if partyB tries to call `emergencyClosePosition`, it will revert due to underflow (partyA position is in loss, but partyA allocated balance = 0, so the loss can not be applied).\n> \n> > One of the recognized challenges with cross positions relates to the scenario described above. To navigate this predicament:\n> > If PartyA wishes to close the winning position, PartyB must allocate funds to fulfill the close request. Should PartyB act maliciously, PartyA should first allocate funds to close the losing position and then proceed to close the winning one.\n> \n> While it's possible to allocate and then close for partyA, this is still unexpected behavior for partyA: if it has position 1 in profit and position 2 in a loss, and it only wants to close position 1 (to realize profit), partyA will be unable to do so - all transactions will revert due to partyB allocatedBalance underflow when trying to apply position loss. So partyA **must** close position 2, then position 1.\n> \n> Another point to consider is that partyA might simply have not enough funds to allocate, close position 2, close position 1. For example, partyA opens huge long and short positions of similar size when ETH = 1000, with leverage = 10: Position 1: long 100 ETH (entry price = 1000) (cva+lf+mm=10000) Position 2: short 99 ETH (entry price = 1000) (cva+lf+mm=10000) Now ETH price shoots up to 2000. Both PartyA and PartyB still have 20000 collateral (which is enough to not be liquidated, because partyB total upnl is just 1000). partyA wants to close Position 1. Since it requires to reduce partyB allocatedBalance by 100 * (2000-1000) = 100000, it reverts.\n> \n> Now if partyA wants to close Position 1, it first has to close Position 2, but in order to close it, partyA must have allocated balance of 99 * (2000 - 1000) = 99000. But partyA only has 20000, it doesn't have access to such huge amount. So it's still stuck.\n\nThis does seem valid unless it is expected behavior for cross positions, any thoughts @MoonKnightDev ?\n\n**Navid-Fkh**\n\nWe recognize that this is a limitation in our system.\n\n**What are we doing about it?**  \nAt the moment, nothing. PartyB will remain trusted for this version of contracts. As a result, PartyB will ensure that adequate funds are allocated before executing fillClosingPosition. Moreover, users might need to close another position (like the one in a loss, as per your example) before they can close a profitable one.\n\n**Why don't we allow allocatedBalance to go negative?**  \nIn the initial stages of designing the system, we chose to make the allocatedBalance unsigned to prevent further potential security threats. For instance, if \"muon\" were to be compromised, a user would only be able to deallocate up to their allocated amount now. However, if we allowed the allocatedBalance to go negative with a positive UPNL, this could lead to a much more significant challenge. We understand that there are some attack vectors with a compromised version of muon even now, but these are now far more complex, enabling our anomaly detection bots to identify and halt malicious activity more effectively.\n\n**Will the system always operate like this, even in subsequent versions?**  \nNo. Future versions will introduce mechanisms that allow users to convert their unrealized profits into realized ones, providing a more effective solution for such scenarios.\n\n**nevillehuang**\n\n> We recognize that this is a limitation in our system.\n> \n> **What are we doing about it?** At the moment, nothing. PartyB will remain trusted for this version of contracts. As a result, PartyB will ensure that adequate funds are allocated before executing fillClosingPosition. Moreover, users might need to close another position (like the one in a loss, as per your example) before they can close a profitable one.\n> \n> **Why don't we allow allocatedBalance to go negative?** In the initial stages of designing the system, we chose to make the allocatedBalance unsigned to prevent further potential security threats. For instance, if \"muon\" were to be compromised, a user would only be able to deallocate up to their allocated amount now. However, if we allowed the allocatedBalance to go negative with a positive UPNL, this could lead to a much more significant challenge. We understand that there are some attack vectors with a compromised version of muon even now, but these are now far more complex, enabling our anomaly detection bots to identify and halt malicious activity more effectively.\n> \n> **Will the system always operate like this, even in subsequent versions?** No. Future versions will introduce mechanisms that allow users to convert their unrealized profits into realized ones, providing a more effective solution for such scenarios.\n\nVery valid design decisions and concerns. I am now leaning towards Medium severity as I believe this is still a risk that users should be made known of before interacting with the protocol, that is the potential inability to close profiting positions without first closing losing ones.\n\n**panprog**\n\n> **What are we doing about it?** At the moment, nothing. PartyB will remain trusted for this version of contracts. As a result, PartyB will ensure that adequate funds are allocated before executing fillClosingPosition. Moreover, users might need to close another position (like the one in a loss, as per your example) before they can close a profitable one.\n\nThere is still a scenario I've outlined in the escalation comment: `emergencyClosePosition` might always revert for partyB, because partyA might have multiple positions both in profit and in loss with different partyBs so that it doesn't have enough allocated balance to close that position. In this case partyB can't do anything about it and partyA doesn't have any incentive to allocate additional funds to let partyB do emergency close.\n\nI understand sponsor's point and intentions, but it's nonetheless a problem which can pop up in different scenarios unexpectedly, and not all of them might be fixable by actions such as depositing additional funds or closing the other positions first. And making it possible to realize unrealized pnl might also not fix all the problems, like the emergency close (maybe something else too).\n\nIn the contest context, I still think this is a valid issue as it's a real problem, which was perhaps overlooked in the previous contest as it was a duplicate to very similar problem which only listed liquidation as impact, but the problem is more general than just liquidations. \n\nAs for the impact, I leave it up to sherlock to decide. I think it's high as the situation is quite easy to get into during normal trading flow (I've seen a lot of users opening opposite direction positions to \"hedge\", there might be trading strategies like statistical arbitrage - going long one asset and short another similar asset etc) and very unexpected for the users (and not always easily fixable). Also, it was a valid high in previous contest and is not fixed but marked \"will fix\".\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nBased on the points raised in the escalation the underlying issue still persists as a limitation and given the possible cases where the underflow can cause problems as mentioned above. Also, I agree with the Lead judge's points. \nConsidering this issue a valid medium\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [panprog](https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/10/#issuecomment-1723636832): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/108",
  "Code": [
    {
      "filename": "symmio-core/contracts/storages/AccountStorage.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../libraries/LibLockedValues.sol\";\n\nenum LiquidationType {\n    NONE,\n    NORMAL,\n    LATE,\n    OVERDUE\n}\n\nstruct LiquidationDetail {\n    bytes liquidationId;\n    LiquidationType liquidationType;\n    int256 upnl;\n    int256 totalUnrealizedLoss;\n    uint256 deficit;\n    uint256 liquidationFee;\n    uint256 timestamp;\n}\n\nstruct Price {\n    uint256 price;\n    uint256 timestamp;\n}\n\nlibrary AccountStorage {\n    bytes32 internal constant ACCOUNT_STORAGE_SLOT = keccak256(\"diamond.standard.storage.account\");\n\n    struct Layout {\n        // Users deposited amounts\n        mapping(address => uint256) balances;\n        mapping(address => uint256) allocatedBalances;\n        // position value will become pending locked before openPosition and will be locked after that\n        mapping(address => LockedValues) pendingLockedBalances;\n        mapping(address => LockedValues) lockedBalances;\n        mapping(address => mapping(address => uint256)) partyBAllocatedBalances;\n        mapping(address => mapping(address => LockedValues)) partyBPendingLockedBalances;\n        mapping(address => mapping(address => LockedValues)) partyBLockedBalances;\n        mapping(address => uint256) withdrawCooldown;\n        mapping(address => uint256) partyANonces;\n        mapping(address => mapping(address => uint256)) partyBNonces;\n        mapping(address => bool) suspendedAddresses;\n        mapping(address => LiquidationDetail) liquidationDetails;\n        mapping(address => mapping(uint256 => Price)) symbolsPrices;\n        mapping(address => int256) totalUnplForLiquidation;\n        mapping(address => address[]) liquidators;\n        mapping(address => uint256) partyAReimbursement;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = ACCOUNT_STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/storages/AccountStorage.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../libraries/LibLockedValues.sol\";\n\nenum LiquidationType {\n    NONE,\n    NORMAL,\n    LATE,\n    OVERDUE\n}\n\nstruct LiquidationDetail {\n    bytes liquidationId;\n    LiquidationType liquidationType;\n    int256 upnl;\n    int256 totalUnrealizedLoss;\n    uint256 deficit;\n    uint256 liquidationFee;\n    uint256 timestamp;\n}\n\nstruct Price {\n    uint256 price;\n    uint256 timestamp;\n}\n\nlibrary AccountStorage {\n    bytes32 internal constant ACCOUNT_STORAGE_SLOT = keccak256(\"diamond.standard.storage.account\");\n\n    struct Layout {\n        // Users deposited amounts\n        mapping(address => uint256) balances;\n        mapping(address => uint256) allocatedBalances;\n        // position value will become pending locked before openPosition and will be locked after that\n        mapping(address => LockedValues) pendingLockedBalances;\n        mapping(address => LockedValues) lockedBalances;\n        mapping(address => mapping(address => uint256)) partyBAllocatedBalances;\n        mapping(address => mapping(address => LockedValues)) partyBPendingLockedBalances;\n        mapping(address => mapping(address => LockedValues)) partyBLockedBalances;\n        mapping(address => uint256) withdrawCooldown;\n        mapping(address => uint256) partyANonces;\n        mapping(address => mapping(address => uint256)) partyBNonces;\n        mapping(address => bool) suspendedAddresses;\n        mapping(address => LiquidationDetail) liquidationDetails;\n        mapping(address => mapping(uint256 => Price)) symbolsPrices;\n        mapping(address => int256) totalUnplForLiquidation;\n        mapping(address => address[]) liquidators;\n        mapping(address => uint256) partyAReimbursement;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = ACCOUNT_STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibAccount.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/AccountStorage.sol\";\n\nlibrary LibAccount {\n    using LockedValuesOps for LockedValues;\n\n    function partyATotalLockedBalances(address partyA) internal view returns (uint256) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        return\n            accountLayout.pendingLockedBalances[partyA].total() +\n            accountLayout.lockedBalances[partyA].total();\n    }\n\n    function partyBTotalLockedBalances(\n        address partyB,\n        address partyA\n    ) internal view returns (uint256) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        return\n            accountLayout.partyBPendingLockedBalances[partyB][partyA].total() +\n            accountLayout.partyBLockedBalances[partyB][partyA].total();\n    }\n\n    function partyAAvailableForQuote(int256 upnl, address partyA) internal view returns (int256) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        int256 available;\n        if (upnl >= 0) {\n            available =\n                int256(accountLayout.allocatedBalances[partyA]) +\n                upnl -\n                int256(\n                    (accountLayout.lockedBalances[partyA].total() +\n                        accountLayout.pendingLockedBalances[partyA].total())\n                );\n        } else {\n            int256 mm = int256(accountLayout.lockedBalances[partyA].mm);\n            int256 considering_mm = -upnl > mm ? -upnl : mm;\n            available =\n                int256(accountLayout.allocatedBalances[partyA]) -\n                int256(\n                    (accountLayout.lockedBalances[partyA].cva +\n                        accountLayout.lockedBalances[partyA].lf +\n                        accountLayout.pendingLockedBalances[partyA].total())\n                ) -\n                considering_mm;\n        }\n        return available;\n    }\n\n    function partyAAvailableBalance(int256 upnl, address partyA) internal view returns (int256) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        int256 available;\n        if (upnl >= 0) {\n            available =\n                int256(accountLayout.allocatedBalances[partyA]) +\n                upnl -\n                int256(accountLayout.lockedBalances[partyA].total());\n        } else {\n            int256 mm = int256(accountLayout.lockedBalances[partyA].mm);\n            int256 considering_mm = -upnl > mm ? -upnl : mm;\n            available =\n                int256(accountLayout.allocatedBalances[partyA]) -\n                int256(\n                    accountLayout.lockedBalances[partyA].cva +\n                        accountLayout.lockedBalances[partyA].lf\n                ) -\n                considering_mm;\n        }\n        return available;\n    }\n\n    function partyAAvailableBalanceForLiquidation(\n        int256 upnl,\n        address partyA\n    ) internal view returns (int256) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        int256 freeBalance = int256(accountLayout.allocatedBalances[partyA]) -\n            int256(accountLayout.lockedBalances[partyA].cva + accountLayout.lockedBalances[partyA].lf);\n        return freeBalance + upnl;\n    }\n\n    function partyBAvailableForQuote(\n        int256 upnl,\n        address partyB,\n        address partyA\n    ) internal view returns (int256) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        int256 available;\n        if (upnl >= 0) {\n            available =\n                int256(accountLayout.partyBAllocatedBalances[partyB][partyA]) +\n                upnl -\n                int256(\n                    (accountLayout.partyBLockedBalances[partyB][partyA].total() +\n                        accountLayout.partyBPendingLockedBalances[partyB][partyA].total())\n                );\n        } else {\n            int256 mm = int256(accountLayout.partyBLockedBalances[partyB][partyA].mm);\n            int256 considering_mm = -upnl > mm ? -upnl : mm;\n            available =\n                int256(accountLayout.partyBAllocatedBalances[partyB][partyA]) -\n                int256(\n                    (accountLayout.partyBLockedBalances[partyB][partyA].cva +\n                        accountLayout.partyBLockedBalances[partyB][partyA].lf +\n                        accountLayout.partyBPendingLockedBalances[partyB][partyA].total())\n                ) -\n                considering_mm;\n        }\n        return available;\n    }\n\n    function partyBAvailableBalance(\n        int256 upnl,\n        address partyB,\n        address partyA\n    ) internal view returns (int256) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        int256 available;\n        if (upnl >= 0) {\n            available =\n                int256(accountLayout.partyBAllocatedBalances[partyB][partyA]) +\n                upnl -\n                int256(accountLayout.partyBLockedBalances[partyB][partyA].total());\n        } else {\n            int256 mm = int256(accountLayout.partyBLockedBalances[partyB][partyA].mm);\n            int256 considering_mm = -upnl > mm ? -upnl : mm;\n            available =\n                int256(accountLayout.partyBAllocatedBalances[partyB][partyA]) -\n                int256(\n                    accountLayout.partyBLockedBalances[partyB][partyA].cva +\n                        accountLayout.partyBLockedBalances[partyB][partyA].lf\n                ) -\n                considering_mm;\n        }\n        return available;\n    }\n\n    function partyBAvailableBalanceForLiquidation(\n        int256 upnl,\n        address partyB,\n        address partyA\n    ) internal view returns (int256) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        int256 a = int256(accountLayout.partyBAllocatedBalances[partyB][partyA]) -\n            int256(accountLayout.partyBLockedBalances[partyB][partyA].cva +\n                accountLayout.partyBLockedBalances[partyB][partyA].lf);\n        return a + upnl;\n    }\n}"
    }
  ]
}