{
  "Title": "[FIXED] Parameter validation",
  "Content": "##### Location\nFile | Location | Line\n--- | --- | ---\n[FraxApsConvexCurveStratBase.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/strategies/curve/convex/aps/crvFrax/FraxApsConvexCurveStratBase.sol#L46-L47 \"/contracts/strategies/curve/convex/aps/crvFrax/FraxApsConvexCurveStratBase.sol\") | contract `FraxApsConvexCurveStratBase` >  `constructor` | 46-47\n[CrvUsdApsConvexCurveStratBase.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/strategies/curve/convex/aps/crvUSD/CrvUsdApsConvexCurveStratBase.sol#L45-L46 \"/contracts/strategies/curve/convex/aps/crvUSD/CrvUsdApsConvexCurveStratBase.sol\") | contract `CrvUsdApsConvexCurveStratBase` >  `constructor` | 45-46\n[ConvexCurveStratBase.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/strategies/curve/convex/ConvexCurveStratBase.sol#L22-L23 \"/contracts/strategies/curve/convex/ConvexCurveStratBase.sol\") | contract `ConvexCurveStratBase` >  `constructor` | 22-23\n[CurveStratBase.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/strategies/curve/CurveStratBase.sol#L19-L20 \"/contracts/strategies/curve/CurveStratBase.sol\") | contract `CurveStratBase` >  `constructor` | 19-20\n[StakeDaoCurveStratBase.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/strategies/curve/stakeDao/StakeDaoCurveStratBase.sol#L15 \"/contracts/strategies/curve/stakeDao/StakeDaoCurveStratBase.sol\") | contract `StakeDaoCurveStratBase` >  `constructor` | 15\n[RecapitalizationManager.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/staking/RecapitalizationManager.sol#L31 \"/contracts/staking/RecapitalizationManager.sol\") | contract `RecapitalizationManager` > `constructor` | 31\n[StakingRewardDistributor.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/staking/StakingRewardDistributor.sol#L430 \"/contracts/staking/StakingRewardDistributor.sol\") | contract `StakingRewardDistributor` > function `withdrawEmergency` | 430\n[StakingRewardDistributor.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/staking/StakingRewardDistributor.sol#L381 \"/contracts/staking/StakingRewardDistributor.sol\") | contract `StakingRewardDistributor` > function `claim` | 381\n[StakingRewardDistributor.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/staking/StakingRewardDistributor.sol#L300 \"/contracts/staking/StakingRewardDistributor.sol\") | contract `StakingRewardDistributor` > function `updatePool` | 300\n[StakingRewardDistributor.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/blob/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/staking/StakingRewardDistributor.sol#L471 \"/contracts/staking/StakingRewardDistributor.sol\") | contract `StakingRewardDistributor` > function `reallocatePool` | 471\n[StakingRewardDistributor.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/blob/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/staking/StakingRewardDistributor.sol#L152 \"/contracts/staking/StakingRewardDistributor.sol\") | contract `StakingRewardDistributor` > function `addPool` | 152\n[StakingRewardDistributor.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/blob/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/staking/StakingRewardDistributor.sol#L131 \"/contracts/staking/StakingRewardDistributor.sol\") | contract `StakingRewardDistributor` > function `addRewardToken` | 131\n[ZunDistributor.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/blob/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/distributor/ZunDistributor.sol#L78\" \"/contracts/distributor/ZunDistributor.sol\") | contract `ZunDistributor` > function `constructor` | 78\n[GenericOracle.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/lib/ConicOracle/contracts/oracles/GenericOracle.sol#L43 \"/contracts/lib/ConicOracle/contracts/oracles/GenericOracle.sol\") | contract `GenericOracle` > function `setCustomOracle` | 43\n[ZunamiStratBase.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/strategies/ZunamiStratBase.sol#L32 \"/contracts/strategies/ZunamiStratBase.sol\") | contract `ZunamiStratBase` > `constructor` | 32\n[ZunamiStratBase.sol](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/8bc108201bef8c4d341ecd3a29a3b1d975019cec/contracts/strategies/ZunamiStratBase.sol#L33 \"/contracts/strategies/ZunamiStratBase.sol\") | contract `ZunamiStratBase` > `constructor` | 33\n\n##### Description\nIn the locations mentioned above, function parameters are not validated. This lack of validation can lead to unpredictable behavior or the occurrence of panic errors.\n##### Recommendation\nWe recommend implementing validation for function parameters to ensure stable and predictable behavior.\n\n##### Update\nFixed in commit [`9ffa8e1b6128d1ade8459a4e492cee669ed241a1`](https://github.com/ZunamiProtocol/ZunamiProtocolV2/tree/9ffa8e1b6128d1ade8459a4e492cee669ed241a1/).",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/staking/StakingRewardDistributor.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\n\nimport './IERC20Supplied.sol';\nimport './IStakingRewardDistributor.sol';\nimport './IERC20UpdateCallback.sol';\n\ncontract StakingRewardDistributor is\n    IStakingRewardDistributor,\n    IERC20UpdateCallback,\n    UUPSUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    error WrongAmount();\n    error TokenAlreadyAdded();\n    error ZeroAddress();\n    error WrongStakingToken();\n    error WrongPoolId();\n\n    // Create a new role identifier for the distributor role\n    bytes32 public constant DISTRIBUTOR_ROLE = keccak256('DISTRIBUTOR_ROLE');\n    bytes32 public constant RECAPITALIZATION_ROLE = keccak256('RECAPITALIZATION_ROLE');\n\n    uint256 private constant ACC_REWARD_PRECISION = 1e12;\n\n    uint256 public constant EXIT_PERCENT = 150; // 15%\n    uint256 public constant PERCENT_DENOMINATOR = 1e3;\n\n    uint256 public constant BLOCKS_IN_2_WEEKS = (14 * 24 * 60 * 60) / 12; //TODO: decide where replace with variable\n    uint256 public constant BLOCKS_IN_4_MONTHS = (4 * 30 * 24 * 60 * 60) / 12; //TODO: decide where replace with variable\n\n    // Info of each user per pool.\n    struct UserPoolInfo {\n        uint256 amount; // How many tokens the user has provided.\n        mapping(uint256 => uint256) accruedRewards; // Reward accrued.\n        uint256 depositedBlock;\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 token; // Address of token contract.\n        IERC20Supplied stakingToken; // Address of staking token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool.\n        uint256[] accRewardsPerShare; // Accumulated reward token per share, times ACC_REWARD_PRECISION. See below.\n        uint256[] lastRewardBlocks; // Last block number that reward tokens distribution occurs.\n    }\n\n    struct RewardTokenInfo {\n        IERC20 token;\n        uint256 rewardPerBlock; // rewardToken tokens created per block.\n        uint256 distributionBlock; // distribution start block\n    }\n\n    // The reward token token infos\n    RewardTokenInfo[] public rewardTokenInfo;\n    mapping(address => uint256) public rewardTokenTidByAddress;\n\n    // Accumulated rewards\n    // tid => user => claimable balance\n    mapping(uint256 => mapping(address => uint256)) public rewards;\n\n    // Claimed rewards\n    // tid => user => claimed balance\n    mapping(uint256 => mapping(address => uint256)) public claimedRewards;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Pid of each pool by its address\n    mapping(address => uint256) public poolPidByAddress;\n    // Pid of each pool by its staking address\n    mapping(address => uint256) public poolPidByStakingAddress;\n    // Info of each user that stakes tokens.\n    mapping(uint256 => mapping(address => UserPoolInfo)) public userPoolInfo;\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint;\n\n    mapping(uint256 => uint256) public totalAmounts;\n    mapping(uint256 => uint256) public recapitalizedAmounts;\n\n    address public earlyExitReceiver;\n\n    event RewardTokenAdded(address indexed token, uint256 indexed tid);\n    event PoolAdded(address indexed token, uint256 indexed pid, uint256 allocPoint);\n    event Claimed(address indexed user, uint256 amount);\n    event Deposited(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdrawn(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount,\n        uint256 amountAdjusted\n    );\n    event RewardPerBlockSet(uint256 indexed tid, uint256 rewardPerBlock);\n    event PoolSet(address indexed token, uint256 indexed pid, uint256 allocPoint);\n    event Withdrawn(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount,\n        uint256 amountAdjusted\n    );\n    event EarlyExitReceiverChanged(address receiver);\n\n    function initialize() public initializer {\n        __UUPSUpgradeable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    function version() public pure returns (uint256) {\n        return 1;\n    }\n\n    function setEarlyExitReceiver(address _receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_receiver == address(0)) revert ZeroAddress();\n        earlyExitReceiver = _receiver;\n        emit EarlyExitReceiverChanged(_receiver);\n    }\n\n    function addRewardToken(IERC20 _token) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (isRewardTokenAdded(address(_token))) revert TokenAlreadyAdded();\n\n        uint256 tid = rewardTokenInfo.length;\n        rewardTokenInfo.push(\n            RewardTokenInfo({ token: _token, rewardPerBlock: 0, distributionBlock: 0 })\n        );\n        rewardTokenTidByAddress[address(_token)] = tid;\n\n        uint256 length = poolInfo.length;\n        for (uint256 pid; pid < length; ++pid) {\n            poolInfo[pid].lastRewardBlocks.push(0);\n            poolInfo[pid].accRewardsPerShare.push(0);\n        }\n\n        emit RewardTokenAdded(address(_token), tid);\n    }\n\n    // Add a new token to the pool. Can only be called by the owner.\n    function addPool(\n        uint256 _allocPoint,\n        IERC20 _token,\n        IERC20Supplied _stakingToken,\n        bool _withUpdate\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (isPoolAdded(_token)) revert TokenAlreadyAdded();\n\n        if (_withUpdate) {\n            updateAllPools();\n        }\n\n        uint256[] memory lastRewardBlocks = new uint256[](rewardTokenInfo.length);\n        uint256[] memory accRewardsPerShare = new uint256[](rewardTokenInfo.length);\n        uint256 length = rewardTokenInfo.length;\n        for (uint256 tid; tid < length; ++tid) {\n            lastRewardBlocks[tid] = rewardTokenInfo[tid].distributionBlock > 0 &&\n                block.number >= rewardTokenInfo[tid].distributionBlock &&\n                block.number <= rewardTokenInfo[tid].distributionBlock + BLOCKS_IN_2_WEEKS\n                ? block.number\n                : 0;\n            accRewardsPerShare[tid] = 0;\n        }\n\n        totalAllocPoint += _allocPoint;\n\n        uint256 pid = poolInfo.length;\n        poolInfo.push(\n            PoolInfo({\n                token: _token,\n                stakingToken: _stakingToken,\n                allocPoint: _allocPoint,\n                lastRewardBlocks: lastRewardBlocks,\n                accRewardsPerShare: accRewardsPerShare\n            })\n        );\n        poolPidByAddress[address(_token)] = pid;\n\n        if (address(_stakingToken) != address(0)) {\n            poolPidByStakingAddress[address(_stakingToken)] = pid;\n            _stakingToken.setUpdateCallback(address(this));\n        }\n\n        emit PoolAdded(address(_token), pid, _allocPoint);\n    }\n\n    function onERC20Update(address from, address to, uint256 value) external override {\n        if (\n            from != address(0) && to != address(0) && from != address(this) && to != address(this)\n        ) {\n            uint256 pid = poolPidByStakingAddress[msg.sender];\n            PoolInfo memory pool = poolInfo[pid];\n            if (msg.sender != address(pool.stakingToken)) revert WrongStakingToken();\n\n            updatePool(pid);\n\n            uint256 rewardTokenInfoLength = rewardTokenInfo.length;\n            for (uint256 tid; tid < rewardTokenInfoLength; ++tid) {\n                accrueReward(tid, pid);\n            }\n\n            UserPoolInfo storage userPoolFrom = userPoolInfo[pid][from];\n            UserPoolInfo storage userPoolTo = userPoolInfo[pid][to];\n\n            unchecked {\n                userPoolFrom.amount -= value;\n                userPoolTo.amount += value;\n            }\n\n            for (uint256 tid; tid < rewardTokenInfoLength; ++tid) {\n                userPoolFrom.accruedRewards[tid] = calcReward(tid, pool, userPoolFrom);\n                emit Withdrawn(from, pid, value, value);\n\n                userPoolTo.accruedRewards[tid] = calcReward(tid, pool, userPoolTo);\n                userPoolTo.depositedBlock = block.number;\n                emit Deposited(to, pid, value);\n            }\n        }\n    }\n\n    function getPoolTokenRatio(uint256 pid) public view returns (uint256) {\n        return ((totalAmounts[pid] - recapitalizedAmounts[pid]) * 1e18) / totalAmounts[pid];\n    }\n\n    function withdrawPoolToken(\n        address token,\n        uint256 amount\n    ) external onlyRole(RECAPITALIZATION_ROLE) {\n        uint256 pid = poolPidByAddress[token];\n        PoolInfo memory poolInfo_ = poolInfo[pid];\n        if (amount >= totalAmounts[pid] - recapitalizedAmounts[pid]) revert WrongAmount();\n        recapitalizedAmounts[pid] += amount;\n        poolInfo_.token.safeTransfer(msg.sender, amount);\n    }\n\n    function returnPoolToken(\n        address token,\n        uint256 amount\n    ) external onlyRole(RECAPITALIZATION_ROLE) {\n        uint256 pid = poolPidByAddress[token];\n        PoolInfo memory poolInfo_ = poolInfo[pid];\n        if (amount > recapitalizedAmounts[pid]) revert WrongAmount();\n        recapitalizedAmounts[pid] -= amount;\n        poolInfo_.token.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    // Start 2 week per block distribution for stakers\n    function distribute(uint256 tid, uint256 amount) external onlyRole(DISTRIBUTOR_ROLE) {\n        RewardTokenInfo storage reward = rewardTokenInfo[tid];\n\n        reward.token.safeTransferFrom(msg.sender, address(this), amount);\n\n        // finalized previous distribution\n        if (reward.rewardPerBlock > 0) {\n            updateAllPools();\n        }\n\n        if (\n            reward.distributionBlock == 0 ||\n            block.number > reward.distributionBlock + BLOCKS_IN_2_WEEKS\n        ) {\n            reward.distributionBlock = block.number;\n            reward.rewardPerBlock = amount / BLOCKS_IN_2_WEEKS;\n        } else {\n            uint256 remainDistributionBlocks = reward.distributionBlock +\n                BLOCKS_IN_2_WEEKS -\n                block.number;\n\n            reward.rewardPerBlock =\n                (amount + (remainDistributionBlocks * reward.rewardPerBlock)) /\n                BLOCKS_IN_2_WEEKS;\n\n            reward.distributionBlock = block.number;\n        }\n\n        // init a new distribution\n        updateAllPools();\n\n        emit RewardPerBlockSet(tid, reward.rewardPerBlock);\n    }\n\n    // Update reward variables for all pools\n    function updateAllPools() public nonReentrant {\n        uint256 length = poolInfo.length;\n        for (uint256 pid; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        uint256 lpSupply = totalAmounts[_pid];\n\n        uint256 length = rewardTokenInfo.length;\n        for (uint256 tid; tid < length; ++tid) {\n            uint256 currentBlock = block.number;\n\n            RewardTokenInfo memory rewardToken = rewardTokenInfo[tid];\n            uint256 distributionBlock = rewardToken.distributionBlock;\n\n            // distribution hasn't started yet\n            if (distributionBlock == 0) continue;\n\n            // distribution has ended, set last reward block to end block to distribute all\n            if (currentBlock > distributionBlock + BLOCKS_IN_2_WEEKS) {\n                currentBlock = distributionBlock + BLOCKS_IN_2_WEEKS;\n            }\n\n            // if zero supply, set to current block\n            if (lpSupply == 0) {\n                pool.lastRewardBlocks[tid] = currentBlock;\n                continue;\n            }\n\n            // if last reward block is current block, skip\n            if (currentBlock <= pool.lastRewardBlocks[tid]) {\n                continue;\n            }\n\n            if (pool.lastRewardBlocks[tid] == 0) pool.lastRewardBlocks[tid] = currentBlock;\n\n            uint256 blockLasted = currentBlock - pool.lastRewardBlocks[tid];\n            if (blockLasted > BLOCKS_IN_2_WEEKS) blockLasted = BLOCKS_IN_2_WEEKS;\n\n            uint256 reward = (blockLasted * rewardToken.rewardPerBlock * pool.allocPoint) /\n                totalAllocPoint;\n\n            pool.accRewardsPerShare[tid] += (reward * ACC_REWARD_PRECISION) / lpSupply;\n\n            pool.lastRewardBlocks[tid] = currentBlock;\n        }\n    }\n\n    // Deposit tokens to staking for reward token allocation.\n    function deposit(uint256 _pid, uint256 _amount) external nonReentrant {\n        if (_pid >= poolInfo.length) revert WrongPoolId();\n        updatePool(_pid);\n\n        uint256 length = rewardTokenInfo.length;\n        for (uint256 tid; tid < length; ++tid) {\n            accrueReward(tid, _pid);\n        }\n\n        UserPoolInfo storage userPool = userPoolInfo[_pid][msg.sender];\n\n        if (_amount > 0) {\n            poolInfo[_pid].token.safeTransferFrom(address(msg.sender), address(this), _amount);\n\n            userPool.amount += _amount;\n            totalAmounts[_pid] += _amount;\n\n            IERC20Supplied stakingToken = poolInfo[_pid].stakingToken;\n            if (address(stakingToken) != address(0)) {\n                stakingToken.mint(msg.sender, _amount);\n            }\n        }\n\n        for (uint256 tid; tid < length; ++tid) {\n            userPool.accruedRewards[tid] = calcReward(\n                tid,\n                poolInfo[_pid],\n                userPoolInfo[_pid][msg.sender]\n            );\n        }\n\n        userPool.depositedBlock = block.number;\n        emit Deposited(msg.sender, _pid, _amount);\n    }\n\n    // claim rewards\n    function claim(uint256 _tid) external nonReentrant {\n        uint256 i;\n        for (i; i < poolInfo.length; ++i) {\n            updatePool(i);\n            accrueReward(_tid, i);\n            UserPoolInfo storage userPool = userPoolInfo[i][msg.sender];\n            userPool.accruedRewards[_tid] = calcReward(_tid, poolInfo[i], userPool);\n        }\n        uint256 claimable = rewards[_tid][msg.sender] - claimedRewards[_tid][msg.sender];\n        if (claimable > 0) {\n            claimable = _safeRewardTransfer(rewardTokenInfo[_tid].token, msg.sender, claimable);\n        }\n        claimedRewards[_tid][msg.sender] += claimable;\n        emit Claimed(msg.sender, claimable);\n    }\n\n    function accrueReward(uint256 tid, uint256 _pid) internal {\n        UserPoolInfo storage userPool = userPoolInfo[_pid][msg.sender];\n        if (userPool.amount == 0) {\n            return;\n        }\n        rewards[tid][msg.sender] +=\n            calcReward(tid, poolInfo[_pid], userPool) -\n            userPool.accruedRewards[tid];\n    }\n\n    function calcReward(\n        uint256 tid,\n        PoolInfo memory pool,\n        UserPoolInfo storage userPool\n    ) internal view returns (uint256) {\n        return (userPool.amount * pool.accRewardsPerShare[tid]) / ACC_REWARD_PRECISION;\n    }\n\n    // Safe rewardToken transfer function.\n    function _safeRewardTransfer(\n        IERC20 rewardToken,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256 transferred) {\n        uint256 balance = rewardToken.balanceOf(address(this));\n        transferred = _amount;\n        if (transferred > balance) {\n            transferred = balance;\n        }\n        rewardToken.safeTransfer(_to, transferred);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function withdrawEmergency(uint256 _pid) external nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserPoolInfo storage userPool = userPoolInfo[_pid][msg.sender];\n        uint256 amountAdjusted = (userPool.amount * getPoolTokenRatio(_pid)) / 1e18;\n\n        uint256 transferAmount = amountAdjusted;\n\n        if (block.number - userPool.depositedBlock <= BLOCKS_IN_4_MONTHS) {\n            transferAmount =\n                (amountAdjusted * (PERCENT_DENOMINATOR - EXIT_PERCENT)) /\n                PERCENT_DENOMINATOR;\n\n            poolInfo[_pid].token.safeTransfer(earlyExitReceiver, amountAdjusted - transferAmount);\n        }\n\n        IERC20Supplied stakingToken = pool.stakingToken;\n        if (address(stakingToken) != address(0)) {\n            stakingToken.burnFrom(msg.sender, userPool.amount);\n        }\n\n        emit EmergencyWithdrawn(msg.sender, _pid, userPool.amount, amountAdjusted);\n        totalAmounts[_pid] -= userPool.amount;\n        userPool.amount = 0;\n\n        uint256 length = rewardTokenInfo.length;\n        for (uint256 tid; tid < length; ++tid) {\n            userPool.accruedRewards[tid] = 0;\n        }\n\n        pool.token.safeTransfer(address(msg.sender), transferAmount);\n    }\n\n    // Update the given pool's reward token allocation point. Can only be called by the owner.\n    function reallocatePool(\n        uint256 _pid,\n        uint256 _allocPoint,\n        bool _withUpdate\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_withUpdate) {\n            updateAllPools();\n        }\n        totalAllocPoint = totalAllocPoint - poolInfo[_pid].allocPoint + _allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n\n        emit PoolSet(address(poolInfo[_pid].token), _pid, _allocPoint);\n    }\n\n    // Withdraw tokens from rewardToken staking.\n    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {\n        if (userPoolInfo[_pid][msg.sender].amount < _amount) revert WrongAmount();\n\n        updatePool(_pid);\n        uint256 rewardTokenInfoLength = rewardTokenInfo.length;\n        for (uint256 tid; tid < rewardTokenInfoLength; ++tid) {\n            accrueReward(tid, _pid);\n        }\n\n        UserPoolInfo storage userPool = userPoolInfo[_pid][msg.sender];\n        uint256 amountAdjusted = (_amount * getPoolTokenRatio(_pid)) / 1e18;\n        if (_amount > 0) {\n            userPool.amount -= _amount;\n            totalAmounts[_pid] -= _amount;\n\n            uint256 transferAmount = amountAdjusted;\n\n            if (block.number - userPool.depositedBlock <= BLOCKS_IN_4_MONTHS) {\n                transferAmount =\n                    (amountAdjusted * (PERCENT_DENOMINATOR - EXIT_PERCENT)) /\n                    PERCENT_DENOMINATOR;\n\n                poolInfo[_pid].token.safeTransfer(\n                    earlyExitReceiver,\n                    amountAdjusted - transferAmount\n                );\n            }\n            poolInfo[_pid].token.safeTransfer(address(msg.sender), transferAmount);\n\n            IERC20Supplied stakingToken = poolInfo[_pid].stakingToken;\n            if (address(stakingToken) != address(0)) {\n                IERC20(address(stakingToken)).safeTransferFrom(msg.sender, address(this), _amount);\n                stakingToken.burn(_amount);\n            }\n        }\n\n        for (uint256 tid; tid < rewardTokenInfoLength; ++tid) {\n            userPool.accruedRewards[tid] = calcReward(\n                tid,\n                poolInfo[_pid],\n                userPoolInfo[_pid][msg.sender]\n            );\n        }\n        emit Withdrawn(msg.sender, _pid, _amount, amountAdjusted);\n    }\n\n    // Number of pools.\n    function poolCount() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Number of reward tokens.\n    function rewardTokenCount() external view returns (uint256) {\n        return rewardTokenInfo.length;\n    }\n\n    function isPoolAdded(IERC20 _token) public view returns (bool) {\n        uint256 pid = poolPidByAddress[address(_token)];\n        return poolInfo.length > pid && address(poolInfo[pid].token) == address(_token);\n    }\n\n    function isRewardTokenAdded(address _token) public view returns (bool) {\n        uint256 tid = rewardTokenTidByAddress[_token];\n        return rewardTokenInfo.length > tid && address(rewardTokenInfo[tid].token) == _token;\n    }\n\n    function getPendingReward(\n        uint256 _tid,\n        uint256 _pid,\n        address _user\n    ) external view returns (uint256 total) {\n        RewardTokenInfo memory token = rewardTokenInfo[_tid];\n        PoolInfo memory pool = poolInfo[_pid];\n\n        uint256 distributionBlock = token.distributionBlock;\n        uint256 currentBlock = block.number;\n        if (currentBlock > distributionBlock + BLOCKS_IN_2_WEEKS) {\n            currentBlock = distributionBlock + BLOCKS_IN_2_WEEKS;\n        }\n\n        uint256 lpSupply = totalAmounts[_pid];\n        if (lpSupply == 0) {\n            return 0;\n        }\n        uint256 blockLasted = currentBlock - pool.lastRewardBlocks[_tid];\n        if (pool.lastRewardBlocks[_tid] == 0) blockLasted = 0;\n\n        uint256 reward = (blockLasted * token.rewardPerBlock * pool.allocPoint) / totalAllocPoint;\n        uint256 accRewardPerShare = pool.accRewardsPerShare[_tid] +\n            ((reward * ACC_REWARD_PRECISION) / lpSupply);\n\n        UserPoolInfo storage userPool = userPoolInfo[_pid][_user];\n        total =\n            ((userPool.amount * accRewardPerShare) / ACC_REWARD_PRECISION) -\n            userPool.accruedRewards[_tid];\n    }\n\n    function getAllPools() external view returns (PoolInfo[] memory) {\n        return poolInfo;\n    }\n\n    function withdrawStuckToken(IERC20 _token) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 tokenBalance = _token.balanceOf(address(this));\n        if (tokenBalance > 0) {\n            _token.safeTransfer(_msgSender(), tokenBalance);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/staking/StakingRewardDistributor.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\n\nimport './IERC20Supplied.sol';\nimport './IStakingRewardDistributor.sol';\nimport './IERC20UpdateCallback.sol';\n\ncontract StakingRewardDistributor is\n    IStakingRewardDistributor,\n    IERC20UpdateCallback,\n    UUPSUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    error WrongAmount();\n    error TokenAlreadyAdded();\n    error ZeroAddress();\n    error WrongStakingToken();\n    error WrongPoolId();\n\n    // Create a new role identifier for the distributor role\n    bytes32 public constant DISTRIBUTOR_ROLE = keccak256('DISTRIBUTOR_ROLE');\n    bytes32 public constant RECAPITALIZATION_ROLE = keccak256('RECAPITALIZATION_ROLE');\n\n    uint256 private constant ACC_REWARD_PRECISION = 1e12;\n\n    uint256 public constant EXIT_PERCENT = 150; // 15%\n    uint256 public constant PERCENT_DENOMINATOR = 1e3;\n\n    uint256 public constant BLOCKS_IN_2_WEEKS = (14 * 24 * 60 * 60) / 12; //TODO: decide where replace with variable\n    uint256 public constant BLOCKS_IN_4_MONTHS = (4 * 30 * 24 * 60 * 60) / 12; //TODO: decide where replace with variable\n\n    // Info of each user per pool.\n    struct UserPoolInfo {\n        uint256 amount; // How many tokens the user has provided.\n        mapping(uint256 => uint256) accruedRewards; // Reward accrued.\n        uint256 depositedBlock;\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 token; // Address of token contract.\n        IERC20Supplied stakingToken; // Address of staking token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool.\n        uint256[] accRewardsPerShare; // Accumulated reward token per share, times ACC_REWARD_PRECISION. See below.\n        uint256[] lastRewardBlocks; // Last block number that reward tokens distribution occurs.\n    }\n\n    struct RewardTokenInfo {\n        IERC20 token;\n        uint256 rewardPerBlock; // rewardToken tokens created per block.\n        uint256 distributionBlock; // distribution start block\n    }\n\n    // The reward token token infos\n    RewardTokenInfo[] public rewardTokenInfo;\n    mapping(address => uint256) public rewardTokenTidByAddress;\n\n    // Accumulated rewards\n    // tid => user => claimable balance\n    mapping(uint256 => mapping(address => uint256)) public rewards;\n\n    // Claimed rewards\n    // tid => user => claimed balance\n    mapping(uint256 => mapping(address => uint256)) public claimedRewards;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Pid of each pool by its address\n    mapping(address => uint256) public poolPidByAddress;\n    // Pid of each pool by its staking address\n    mapping(address => uint256) public poolPidByStakingAddress;\n    // Info of each user that stakes tokens.\n    mapping(uint256 => mapping(address => UserPoolInfo)) public userPoolInfo;\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint;\n\n    mapping(uint256 => uint256) public totalAmounts;\n    mapping(uint256 => uint256) public recapitalizedAmounts;\n\n    address public earlyExitReceiver;\n\n    event RewardTokenAdded(address indexed token, uint256 indexed tid);\n    event PoolAdded(address indexed token, uint256 indexed pid, uint256 allocPoint);\n    event Claimed(address indexed user, uint256 amount);\n    event Deposited(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdrawn(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount,\n        uint256 amountAdjusted\n    );\n    event RewardPerBlockSet(uint256 indexed tid, uint256 rewardPerBlock);\n    event PoolSet(address indexed token, uint256 indexed pid, uint256 allocPoint);\n    event Withdrawn(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount,\n        uint256 amountAdjusted\n    );\n    event EarlyExitReceiverChanged(address receiver);\n\n    function initialize() public initializer {\n        __UUPSUpgradeable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    function version() public pure returns (uint256) {\n        return 1;\n    }\n\n    function setEarlyExitReceiver(address _receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_receiver == address(0)) revert ZeroAddress();\n        earlyExitReceiver = _receiver;\n        emit EarlyExitReceiverChanged(_receiver);\n    }\n\n    function addRewardToken(IERC20 _token) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (isRewardTokenAdded(address(_token))) revert TokenAlreadyAdded();\n\n        uint256 tid = rewardTokenInfo.length;\n        rewardTokenInfo.push(\n            RewardTokenInfo({ token: _token, rewardPerBlock: 0, distributionBlock: 0 })\n        );\n        rewardTokenTidByAddress[address(_token)] = tid;\n\n        uint256 length = poolInfo.length;\n        for (uint256 pid; pid < length; ++pid) {\n            poolInfo[pid].lastRewardBlocks.push(0);\n            poolInfo[pid].accRewardsPerShare.push(0);\n        }\n\n        emit RewardTokenAdded(address(_token), tid);\n    }\n\n    // Add a new token to the pool. Can only be called by the owner.\n    function addPool(\n        uint256 _allocPoint,\n        IERC20 _token,\n        IERC20Supplied _stakingToken,\n        bool _withUpdate\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (isPoolAdded(_token)) revert TokenAlreadyAdded();\n\n        if (_withUpdate) {\n            updateAllPools();\n        }\n\n        uint256[] memory lastRewardBlocks = new uint256[](rewardTokenInfo.length);\n        uint256[] memory accRewardsPerShare = new uint256[](rewardTokenInfo.length);\n        uint256 length = rewardTokenInfo.length;\n        for (uint256 tid; tid < length; ++tid) {\n            lastRewardBlocks[tid] = rewardTokenInfo[tid].distributionBlock > 0 &&\n                block.number >= rewardTokenInfo[tid].distributionBlock &&\n                block.number <= rewardTokenInfo[tid].distributionBlock + BLOCKS_IN_2_WEEKS\n                ? block.number\n                : 0;\n            accRewardsPerShare[tid] = 0;\n        }\n\n        totalAllocPoint += _allocPoint;\n\n        uint256 pid = poolInfo.length;\n        poolInfo.push(\n            PoolInfo({\n                token: _token,\n                stakingToken: _stakingToken,\n                allocPoint: _allocPoint,\n                lastRewardBlocks: lastRewardBlocks,\n                accRewardsPerShare: accRewardsPerShare\n            })\n        );\n        poolPidByAddress[address(_token)] = pid;\n\n        if (address(_stakingToken) != address(0)) {\n            poolPidByStakingAddress[address(_stakingToken)] = pid;\n            _stakingToken.setUpdateCallback(address(this));\n        }\n\n        emit PoolAdded(address(_token), pid, _allocPoint);\n    }\n\n    function onERC20Update(address from, address to, uint256 value) external override {\n        if (\n            from != address(0) && to != address(0) && from != address(this) && to != address(this)\n        ) {\n            uint256 pid = poolPidByStakingAddress[msg.sender];\n            PoolInfo memory pool = poolInfo[pid];\n            if (msg.sender != address(pool.stakingToken)) revert WrongStakingToken();\n\n            updatePool(pid);\n\n            uint256 rewardTokenInfoLength = rewardTokenInfo.length;\n            for (uint256 tid; tid < rewardTokenInfoLength; ++tid) {\n                accrueReward(tid, pid);\n            }\n\n            UserPoolInfo storage userPoolFrom = userPoolInfo[pid][from];\n            UserPoolInfo storage userPoolTo = userPoolInfo[pid][to];\n\n            unchecked {\n                userPoolFrom.amount -= value;\n                userPoolTo.amount += value;\n            }\n\n            for (uint256 tid; tid < rewardTokenInfoLength; ++tid) {\n                userPoolFrom.accruedRewards[tid] = calcReward(tid, pool, userPoolFrom);\n                emit Withdrawn(from, pid, value, value);\n\n                userPoolTo.accruedRewards[tid] = calcReward(tid, pool, userPoolTo);\n                userPoolTo.depositedBlock = block.number;\n                emit Deposited(to, pid, value);\n            }\n        }\n    }\n\n    function getPoolTokenRatio(uint256 pid) public view returns (uint256) {\n        return ((totalAmounts[pid] - recapitalizedAmounts[pid]) * 1e18) / totalAmounts[pid];\n    }\n\n    function withdrawPoolToken(\n        address token,\n        uint256 amount\n    ) external onlyRole(RECAPITALIZATION_ROLE) {\n        uint256 pid = poolPidByAddress[token];\n        PoolInfo memory poolInfo_ = poolInfo[pid];\n        if (amount >= totalAmounts[pid] - recapitalizedAmounts[pid]) revert WrongAmount();\n        recapitalizedAmounts[pid] += amount;\n        poolInfo_.token.safeTransfer(msg.sender, amount);\n    }\n\n    function returnPoolToken(\n        address token,\n        uint256 amount\n    ) external onlyRole(RECAPITALIZATION_ROLE) {\n        uint256 pid = poolPidByAddress[token];\n        PoolInfo memory poolInfo_ = poolInfo[pid];\n        if (amount > recapitalizedAmounts[pid]) revert WrongAmount();\n        recapitalizedAmounts[pid] -= amount;\n        poolInfo_.token.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    // Start 2 week per block distribution for stakers\n    function distribute(uint256 tid, uint256 amount) external onlyRole(DISTRIBUTOR_ROLE) {\n        RewardTokenInfo storage reward = rewardTokenInfo[tid];\n\n        reward.token.safeTransferFrom(msg.sender, address(this), amount);\n\n        // finalized previous distribution\n        if (reward.rewardPerBlock > 0) {\n            updateAllPools();\n        }\n\n        if (\n            reward.distributionBlock == 0 ||\n            block.number > reward.distributionBlock + BLOCKS_IN_2_WEEKS\n        ) {\n            reward.distributionBlock = block.number;\n            reward.rewardPerBlock = amount / BLOCKS_IN_2_WEEKS;\n        } else {\n            uint256 remainDistributionBlocks = reward.distributionBlock +\n                BLOCKS_IN_2_WEEKS -\n                block.number;\n\n            reward.rewardPerBlock =\n                (amount + (remainDistributionBlocks * reward.rewardPerBlock)) /\n                BLOCKS_IN_2_WEEKS;\n\n            reward.distributionBlock = block.number;\n        }\n\n        // init a new distribution\n        updateAllPools();\n\n        emit RewardPerBlockSet(tid, reward.rewardPerBlock);\n    }\n\n    // Update reward variables for all pools\n    function updateAllPools() public nonReentrant {\n        uint256 length = poolInfo.length;\n        for (uint256 pid; pid < length; ++pid) {\n            updatePo"
    }
  ]
}