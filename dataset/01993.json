{
  "Title": "M-1: SwapperCallbackValidation doesn't do anything, opens up users to having contracts drained",
  "Content": "# Issue M-1: SwapperCallbackValidation doesn't do anything, opens up users to having contracts drained \n\nSource: https://github.com/sherlock-audit/2023-04-splits-judging/issues/9 \n\n## Found by \n0x00ffDa, J4de, alexzoid, nobody2018, obront\n\n## Summary\n\nThe `SwapperCallbackValidation` library that is intended to be used by contracts performing swaps does not provide any protection. As a result, all functions intended to be used only in a callback setting can be called any time by any user. In the provided example of how they expect this library to be used, this would result in the opportunity for all funds to be stolen.\n\n## Vulnerability Detail\n\nThe `SwapperCallbackValidation` library is intended to be used by developers to verify that their contracts are only called in a valid, swapper callback scenario. It contains the following function to be implemented:\n\n```solidity\nfunction verifyCallback(SwapperFactory factory_, SwapperImpl swapper_) internal view returns (bool valid) {\n    return factory_.isSwapper(swapper_);\n}\n```\n\nThis function simply pings the `SwapperFactory` and confirms that the function call is coming from a verified swapper. If it is, we assume that it is from a legitimate callback.\n\nFor an example of how this is used, see the (out of scope) UniV3Swap contract, which serves as a model for developers to build contracts to support Swappers.\n```solidity\nSwapperImpl swapper = SwapperImpl(msg.sender);\nif (!swapperFactory.verifyCallback(swapper)) {\n    revert Unauthorized();\n}\n```\nThe contract goes on to perform swaps (which can be skipped by passing empty `exactInputParams`), and then sends all its ETH (or ERC20s) to `msg.sender`. Clearly, this validation is very important to protect such a contract from losing funds.\n\nHowever, if we look deeper, we can see that this validation is not nearly sufficient.\n\nIn fact, `SwapperImpl` inherits from `WalletImpl`, which contains the following function:\n```solidity\nfunction execCalls(Call[] calldata calls_)\n    external\n    payable\n    onlyOwner\n    returns (uint256 blockNumber, bytes[] memory returnData)\n{\n    blockNumber = block.number;\n    uint256 length = calls_.length;\n    returnData = new bytes[](length);\n\n    bool success;\n    for (uint256 i; i < length;) {\n        Call calldata calli = calls_[i];\n        (success, returnData[i]) = calli.to.call{value: calli.value}(calli.data);\n        require(success, string(returnData[i]));\n\n        unchecked {\n            ++i;\n        }\n    }\n\n    emit ExecCalls(calls_);\n}\n```\nThis function allows the owner of the Swapper to perform arbitrary calls on its behalf.\n\nSince the verification only checks that the caller is, in fact, a Swapper, it is possible for any user to create a Swapper and pass arbitrary calldata into this `execCalls()` function, performing any transaction they would like and passing the `verifyCallback()` check.\n\nIn the generic case, this makes the `verifyCallback()` function useless, as any calldata that could be called without that function could similarly be called by deploying a Swapper and sending identical calldata through that Swapper.\n\nIn the specific case based on the example provided, this would allow a user to deploy a Swapper, call the `swapperFlashCallback()` function directly (not as a callback), and steal all the funds held by the contract.\n\n## Impact\n\nAll funds can be stolen from any contracts using the `SwapperCallbackValidation` library, because the `verifyCallback()` function provides no protection.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-splits/blob/main/splits-swapper/src/peripherals/SwapperCallbackValidation.sol#L11-L19\n\nhttps://github.com/sherlock-audit/2023-04-splits/blob/main/splits-utils/src/WalletImpl.sol#L43-L65\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI do not believe that Swappers require the ability to execute arbitrary calls, so should not inherit from WalletImpl.\n\nAlternatively, the verification checks performed by contracts accepting callbacks should be more substantial — specifically, they should store the Swapper they are interacting with's address for the duration of the transaction, and only allow callbacks from that specific address.\n\n\n\n## Discussion\n\n**zobront**\n\nFixed in https://github.com/0xSplits/splits-swapper/pull/3/ by removing the validation and requiring bots to either (a) not hold funds in the contract or (b) create their own validations.\n\n**MLON33**\n\nConfirming that Splits meant for this fix (3) to be linked to this issue (9):\n\nhttps://github.com/0xSplits/splits-swapper/pull/3#issue-1693205720\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/65",
  "Code": [
    {
      "filename": "splits-swapper/src/peripherals/SwapperCallbackValidation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {SwapperFactory} from \"../SwapperFactory.sol\";\nimport {SwapperImpl} from \"../SwapperImpl.sol\";\n\n/// @title Swapper Callback Validation\n/// @author 0xSplits\n/// @notice Helper library for contracts calling Swapper#flash\n/// @dev inspired by UniswapV3's CallbackValidation\nlibrary SwapperCallbackValidation {\n    /// Returns whether a given swapper address is valid\n    /// @param factory_ Address of SwapperFactory\n    /// @param swapper_ Address of swapper to validate\n    /// @return valid Boolean of whether swapper address is valid\n    function verifyCallback(SwapperFactory factory_, SwapperImpl swapper_) internal view returns (bool valid) {\n        return factory_.isSwapper(swapper_);\n    }\n}"
    },
    {
      "filename": "splits-utils/src/WalletImpl.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {OwnableImpl} from \"./OwnableImpl.sol\";\n\n/// @title Wallet Implementation\n/// @author 0xSplits\n/// @notice Minimal smart wallet clone-implementation\nabstract contract WalletImpl is OwnableImpl {\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    event ExecCalls(Call[] calls);\n\n    /// -----------------------------------------------------------------------\n    /// storage - mutables\n    /// -----------------------------------------------------------------------\n\n    /// slot 0 - 12 bytes free\n\n    /// OwnableImpl storage\n    /// address internal $owner;\n    /// 20 bytes\n\n    /// -----------------------------------------------------------------------\n    /// constructor & initializer\n    /// -----------------------------------------------------------------------\n\n    constructor() {}\n\n    function __initWallet(address owner_) internal {\n        OwnableImpl.__initOwnable(owner_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - external & public - onlyOwner\n    /// -----------------------------------------------------------------------\n\n    /// allow owner to execute arbitrary calls\n    function execCalls(Call[] calldata calls_)\n        external\n        payable\n        onlyOwner\n        returns (uint256 blockNumber, bytes[] memory returnData)\n    {\n        blockNumber = block.number;\n        uint256 length = calls_.length;\n        returnData = new bytes[](length);\n\n        bool success;\n        for (uint256 i; i < length;) {\n            Call calldata calli = calls_[i];\n            (success, returnData[i]) = calli.to.call{value: calli.value}(calli.data);\n            require(success, string(returnData[i]));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ExecCalls(calls_);\n    }\n}"
    }
  ]
}