{
  "Title": "M-3: If unlocked capital in pool falls below minRequiredCapital, then protection can be bought for minimum premium",
  "Content": "# Issue M-3: If unlocked capital in pool falls below minRequiredCapital, then protection can be bought for minimum premium \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/211 \n\n## Found by \njkoppel\n\n## Summary\n\nIf the unlocked capital in a pool falls below the minRequiredCapital, then protection can be bought for minimum premium\n\n## Vulnerability Detail\n\nIn PremiumCalculator.calculatePremium, we see that if the risk factor \"cannot  be calculated,\" it uses the minimum premium.\n\n```solidity\n    if (\n      RiskFactorCalculator.canCalculateRiskFactor(\n        _totalCapital,\n        _leverageRatio,\n        _poolParameters.leverageRatioFloor,\n        _poolParameters.leverageRatioCeiling,\n        _poolParameters.minRequiredCapital\n      )\n    ) {\n      ...\n    } else {\n      /// This means that the risk factor cannot be calculated because of either\n      /// min capital not met or leverage ratio out of range.\n      /// Hence, the premium is the minimum premium\n      _isMinPremium = true;\n    }\n```\n\nIn RiskFactor.canCalculateRiskFactor, we see there are three conditions when this is so:\n\n```solidity\n  function canCalculateRiskFactor(\n    uint256 _totalCapital,\n    uint256 _leverageRatio,\n    uint256 _leverageRatioFloor,\n    uint256 _leverageRatioCeiling,\n    uint256 _minRequiredCapital\n  ) external pure returns (bool _canCalculate) {\n    if (\n      _totalCapital < _minRequiredCapital ||\n      _leverageRatio < _leverageRatioFloor ||\n      _leverageRatio > _leverageRatioCeiling\n    ) {\n      _canCalculate = false;\n    } else {\n      _canCalculate = true;\n    }\n  }\n}\n```\n\nIf the leverage ratio is above the ceiling, then protection should be very cheap, and it is correct to use the minimum premium. If the leverage ratio is above the floor, then protection cannot be purchased.\n\nHowever, we see that the minimum premium is also used if _totalCapital is below _minRequiredCapital. In this case, protection should be very expensive, but it will instead be very cheap.\n\nTotal capital can fall this low in a couple ways. One way is if most sellers withdraw their funds and most protection positions expire. Then the pool can have a very small amount of capital while still having a leverage ratio within the window.  Another is if most of the capital is locked. In that case, the protection likely cannot be bought because the leverage ratio is likely to be too low. However, when capital is locked, the corresponding protection should not count against the leverage ratio, as that can prevent buyers from buying protection even when the pool is very well capitalized ( see https://github.com/sherlock-audit/2023-02-carapace-jkoppel/issues/11 ). If that issue is fixed, then this issue can appear when capital is locked.\n\n## Impact\n\nBuyers can get very cheap protection at a time when it should be expensive.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/PremiumCalculator.sol#L63\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nProhibit protection purchases when capital falls below the minimum required capital\n\n## Discussion\n\n**jkoppel**\n\nEscalate for 26 USDC\n\nThis is not a duplicate of #325. That issue only talks about when the leverage ratio falls below the floor. As @clems4ev3r  pointed out, that case is correctly handled: protection cannot be purchased at all.\n\nThis report talks about when the leverage ratio is within range but most funds are either withdrawn or locked. Then protection should  be very expensive but is instead very cheap. And this will not revert.\n\n**sherlock-admin**\n\n > Escalate for 26 USDC\n> \n> This is not a duplicate of #325. That issue only talks about when the leverage ratio falls below the floor. As @clems4ev3r  pointed out, that case is correctly handled: protection cannot be purchased at all.\n> \n> This report talks about when the leverage ratio is within range but most funds are either withdrawn or locked. Then protection should  be very expensive but is instead very cheap. And this will not revert.\n\nYou've created a valid escalation for 26 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "contracts/core/PremiumCalculator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@prb/math/contracts/PRBMathSD59x18.sol\";\n\nimport {UUPSUpgradeableBase} from \"../UUPSUpgradeableBase.sol\";\nimport {IPremiumCalculator} from \"../interfaces/IPremiumCalculator.sol\";\nimport {ProtectionPoolParams} from \"../interfaces/IProtectionPool.sol\";\n\nimport \"../libraries/Constants.sol\";\nimport \"../libraries/RiskFactorCalculator.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title PremiumCalculator\n * @author Carapace Finance\n * @notice Calculates the premium amount for a protection.\n * @dev This contract is upgradable using the UUPS pattern.\n */\ncontract PremiumCalculator is UUPSUpgradeableBase, IPremiumCalculator {\n  using PRBMathSD59x18 for int256;\n\n  /*** initializer ***/\n\n  /**\n   * @notice Initializes the contract.\n   */\n  function initialize() external initializer {\n    __UUPSUpgradeableBase_init();\n  }\n\n  /// @inheritdoc IPremiumCalculator\n  function calculatePremium(\n    uint256 _protectionDurationInSeconds,\n    uint256 _protectionAmount,\n    uint256 _protectionBuyerApy,\n    uint256 _leverageRatio,\n    uint256 _totalCapital,\n    ProtectionPoolParams calldata _poolParameters\n  )\n    external\n    view\n    virtual\n    override\n    returns (uint256 _premiumAmount, bool _isMinPremium)\n  {\n    console.log(\n      \"Calculating premium... protection duration in seconds: %s, protection amount: %s, leverage ratio: %s\",\n      _protectionDurationInSeconds,\n      _protectionAmount,\n      _leverageRatio\n    );\n\n    int256 _carapacePremiumRate;\n\n    /// Calculate the duration in years\n    uint256 _durationInYears = _calculateDurationInYears(\n      _protectionDurationInSeconds\n    );\n\n    /// Verify if the risk factor can be calculated\n    if (\n      RiskFactorCalculator.canCalculateRiskFactor(\n        _totalCapital,\n        _leverageRatio,\n        _poolParameters.leverageRatioFloor,\n        _poolParameters.leverageRatioCeiling,\n        _poolParameters.minRequiredCapital\n      )\n    ) {\n      int256 _riskFactor = RiskFactorCalculator.calculateRiskFactor(\n        _leverageRatio,\n        _poolParameters.leverageRatioFloor,\n        _poolParameters.leverageRatioCeiling,\n        _poolParameters.leverageRatioBuffer,\n        _poolParameters.curvature\n      );\n\n      /// Calculate the carapace premium rate based on the calculated risk factor\n      _carapacePremiumRate = _calculateCarapacePremiumRate(\n        _durationInYears,\n        _riskFactor\n      );\n      console.logInt(_carapacePremiumRate);\n    } else {\n      /// This means that the risk factor cannot be calculated because of either\n      /// min capital not met or leverage ratio out of range.\n      /// Hence, the premium is the minimum premium\n      _isMinPremium = true;\n    }\n\n    int256 _minCarapaceRiskPremiumPercent = int256(\n      _poolParameters.minCarapaceRiskPremiumPercent\n    );\n\n    /// carapacePremiumRateToUse = max(carapacePremiumRate, minCarapaceRiskPremiumPercent)\n    int256 _carapacePremiumRateToUse = _carapacePremiumRate >\n      _minCarapaceRiskPremiumPercent\n      ? _carapacePremiumRate\n      : _minCarapaceRiskPremiumPercent;\n    console.logInt(_carapacePremiumRateToUse);\n\n    /// Calculate the underlying premium rate based on the protection buyer APY\n    uint256 _underlyingPremiumRate = _calculateUnderlyingPremiumRate(\n      _durationInYears,\n      _protectionBuyerApy,\n      _poolParameters.underlyingRiskPremiumPercent\n    );\n    console.log(\"Underlying premium rate: %s\", _underlyingPremiumRate);\n\n    assert(_carapacePremiumRateToUse > 0);\n    uint256 _premiumRate = uint256(_carapacePremiumRateToUse) +\n      _underlyingPremiumRate;\n    console.log(\"Premium rate: %s\", _premiumRate);\n\n    // need to scale down once because protectionAmount & premiumRate both are in 18 decimals\n    _premiumAmount =\n      (_protectionAmount * _premiumRate) /\n      Constants.SCALE_18_DECIMALS;\n  }\n\n  /**\n   * @dev Calculates the carapace premium rate scaled to 18 decimals.\n   * @dev Formula: carapacePremiumRate = 1 - (e ** (-1 * durationInYears * riskFactor))\n   * @param _durationInYears protection duration in years scaled to 18 decimals.\n   * @param _riskFactor risk factor scaled to 18 decimals.\n   */\n  function _calculateCarapacePremiumRate(\n    uint256 _durationInYears,\n    int256 _riskFactor\n  ) internal pure returns (int256) {\n    /// need to scale down once because durationInYears and riskFactor both are in 18 decimals\n    int256 _power = (-1 * int256(_durationInYears) * _riskFactor) /\n      Constants.SCALE_18_DECIMALS_INT;\n    return Constants.SCALE_18_DECIMALS_INT - (_power.exp()); // 1 - exp\n  }\n\n  /**\n   * @dev calculate underlying premium rate scaled to 18 decimals.\n   * @dev Formula: underlyingPremiumRate = UNDERLYING_RISK_PREMIUM_PERCENT * _protectionBuyerApy * durationInYears\n   * @param _durationInYears protection duration in years scaled to 18 decimals.\n   * @param _protectionBuyerApy protection buyer APY scaled to 18 decimals.\n   * @param _underlyingRiskPremiumPercent underlying risk premium percent scaled to 18 decimals.\n   */\n  function _calculateUnderlyingPremiumRate(\n    uint256 _durationInYears,\n    uint256 _protectionBuyerApy,\n    uint256 _underlyingRiskPremiumPercent\n  ) internal pure returns (uint256) {\n    // need to scale down twice because all 3 params (underlyingRiskPremiumPercent, protectionBuyerApy & duration_in_years) are in 18 decimals\n    return\n      (_underlyingRiskPremiumPercent * _protectionBuyerApy * _durationInYears) /\n      (Constants.SCALE_18_DECIMALS * Constants.SCALE_18_DECIMALS);\n  }\n\n  /**\n   * @dev Calculates protection duration in years scaled to 18 decimals.\n   * Formula used: (_protectionDurationInSeconds / SECONDS_IN_DAY) / 365.24\n   * @param _protectionDurationInSeconds protection duration in seconds.\n   */\n  function _calculateDurationInYears(uint256 _protectionDurationInSeconds)\n    internal\n    pure\n    returns (uint256)\n  {\n    return\n      (_protectionDurationInSeconds * 100 * Constants.SCALE_18_DECIMALS) /\n      (uint256(Constants.SECONDS_IN_DAY) * 36524);\n  }\n}"
    }
  ]
}