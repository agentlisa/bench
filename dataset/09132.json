{
  "Title": "[M-16] DDOS in `BalLiquidityProvider`",
  "Content": "_Submitted by QuantumBrief_\n\nDDOS to liquidity providers in BalLiquidityProvider.\n\n### Proof of Concept\n\n*   bal is equal to the contractâ€™s balance of the asset: [BalLiquidityProvider.sol#L56](https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/BalLiquidityProvider.sol#L56)\n\n*   bal is required to be equal to the input parameter \\_request.maxAmountsIn\\[i]: [BalLiquidityProvider.sol#L57](https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/BalLiquidityProvider.sol#L57)\n\nAn attacker can front-run liquidity providers by sending 1 Wei of the asset to make the balance not equal to the input. This can be repeated and be used to impede the liquidity provider from using the function which will always revert since bal != \\_request.maxAmountsIn\\[i]\n\n### Recommended Mitigation Steps\n\nBalances shouldn't be required to be equal to an input variable. An attacker can always make the balance a little bigger.  This check should be removed or changed to require (bal >=  \\_request.maxAmountsIn\\[i]).\n\n**[0xMaharishi (Aura Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-05-aura-findings/issues/285#issuecomment-1140251794):**\n > Fair report ðŸ‘ \n\n**[0xMaharishi (Aura Finance) resolved](https://github.com/code-423n4/2022-05-aura-findings/issues/285#issuecomment-1141475216):**\n > [code-423n4/2022-05-aura#6](https://github.com/code-423n4/2022-05-aura/pull/6)<br>\n > [code4rena aurafinance/aura-contracts#84](https://github.com/aurafinance/aura-contracts/pull/84)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/BalLiquidityProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IVault } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title   BalLiquidityProvider\n * @notice  Provides initial liquidity to a Balancer pool on behalf of a given DAO\n */\ncontract BalLiquidityProvider {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable startToken;\n    IERC20 public immutable pairToken;\n    uint256 public minPairAmount;\n\n    address private immutable provider;\n    address public immutable dao;\n\n    IVault public immutable bVault;\n\n    event LiquidityProvided(uint256[] input, uint256 output);\n    event MinPairAmountChanged(uint256 oldMinPairAmount, uint256 newMinPairAmount);\n\n    constructor(\n        address _startToken,\n        address _pairToken,\n        uint256 _minPairAmount,\n        address _dao,\n        address _bVault\n    ) {\n        startToken = IERC20(_startToken);\n        pairToken = IERC20(_pairToken);\n        minPairAmount = _minPairAmount;\n        provider = msg.sender;\n        dao = _dao;\n        bVault = IVault(_bVault);\n    }\n\n    /**\n     * @dev Provides liquidity on behalf of the dao, in a non-custodial manner.\n     *      Has protections in place to ensure that no erroneous liquidity data gets added.\n     */\n    function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {\n        require(msg.sender == provider, \"!auth\");\n        require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, \"!valid\");\n        require(pairToken.balanceOf(address(this)) > minPairAmount, \"!minLiq\");\n\n        for (uint256 i = 0; i < 2; i++) {\n            address asset = address(_request.assets[i]);\n            require(asset == address(startToken) || asset == address(pairToken), \"!asset\");\n\n            IERC20 tkn = IERC20(asset);\n            uint256 bal = tkn.balanceOf(address(this));\n            require(bal > 0 && bal == _request.maxAmountsIn[i], \"!bal\");\n\n            tkn.safeApprove(address(bVault), 0);\n            tkn.safeApprove(address(bVault), bal);\n        }\n\n        (address pool, ) = bVault.getPool(_poolId);\n        uint256 supplyBefore = IERC20(pool).totalSupply();\n        require(supplyBefore == 0, \"!init\");\n\n        bVault.joinPool(_poolId, address(this), dao, _request);\n\n        uint256 balAfter = IERC20(pool).balanceOf(dao);\n        require(balAfter > 0, \"!mint\");\n\n        emit LiquidityProvided(_request.maxAmountsIn, balAfter);\n    }\n\n    /**\n     * @dev Allows the DAO to change the minimum amount of the pair token that must be added as liquidity\n     */\n    function changeMinPairAmount(uint256 _newAmount) external {\n        require(msg.sender == dao, \"!auth\");\n        emit MinPairAmountChanged(minPairAmount, _newAmount);\n        minPairAmount = _newAmount;\n    }\n\n    /**\n     * @dev Rescues a given token from the contract.\n     * Only provider or DAO can call this function.\n     */\n    function rescueToken(address _erc20) external {\n        require(msg.sender == provider || msg.sender == dao, \"!auth\");\n        IERC20 tkn = IERC20(_erc20);\n        tkn.safeTransfer(dao, tkn.balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "contracts/BalLiquidityProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IVault } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title   BalLiquidityProvider\n * @notice  Provides initial liquidity to a Balancer pool on behalf of a given DAO\n */\ncontract BalLiquidityProvider {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable startToken;\n    IERC20 public immutable pairToken;\n    uint256 public minPairAmount;\n\n    address private immutable provider;\n    address public immutable dao;\n\n    IVault public immutable bVault;\n\n    event LiquidityProvided(uint256[] input, uint256 output);\n    event MinPairAmountChanged(uint256 oldMinPairAmount, uint256 newMinPairAmount);\n\n    constructor(\n        address _startToken,\n        address _pairToken,\n        uint256 _minPairAmount,\n        address _dao,\n        address _bVault\n    ) {\n        startToken = IERC20(_startToken);\n        pairToken = IERC20(_pairToken);\n        minPairAmount = _minPairAmount;\n        provider = msg.sender;\n        dao = _dao;\n        bVault = IVault(_bVault);\n    }\n\n    /**\n     * @dev Provides liquidity on behalf of the dao, in a non-custodial manner.\n     *      Has protections in place to ensure that no erroneous liquidity data gets added.\n     */\n    function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {\n        require(msg.sender == provider, \"!auth\");\n        require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, \"!valid\");\n        require(pairToken.balanceOf(address(this)) > minPairAmount, \"!minLiq\");\n\n        for (uint256 i = 0; i < 2; i++) {\n            address asset = address(_request.assets[i]);\n            require(asset == address(startToken) || asset == address(pairToken), \"!asset\");\n\n            IERC20 tkn = IERC20(asset);\n            uint256 bal = tkn.balanceOf(address(this));\n            require(bal > 0 && bal == _request.maxAmountsIn[i], \"!bal\");\n\n            tkn.safeApprove(address(bVault), 0);\n            tkn.safeApprove(address(bVault), bal);\n        }\n\n        (address pool, ) = bVault.getPool(_poolId);\n        uint256 supplyBefore = IERC20(pool).totalSupply();\n        require(supplyBefore == 0, \"!init\");\n\n        bVault.joinPool(_poolId, address(this), dao, _request);\n\n        uint256 balAfter = IERC20(pool).balanceOf(dao);\n        require(balAfter > 0, \"!mint\");\n\n        emit LiquidityProvided(_request.maxAmountsIn, balAfter);\n    }\n\n    /**\n     * @dev Allows the DAO to change the minimum amount of the pair token that must be added as liquidity\n     */\n    function changeMinPairAmount(uint256 _newAmount) external {\n        require(msg.sender == dao, \"!auth\");\n        emit MinPairAmountChanged(minPairAmount, _newAmount);\n        minPairAmount = _newAmount;\n    }\n\n    /**\n     * @dev Rescues a given token from the contract.\n     * Only provider or DAO can call this function.\n     */\n    function rescueToken(address _erc20) external {\n        require(msg.sender == provider || msg.sender == dao, \"!auth\");\n        IERC20 tkn = IERC20(_erc20);\n        tkn.safeTransfer(dao, tkn.balanceOf(address(this)));\n    }\n}"
    }
  ]
}