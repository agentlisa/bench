{
  "Title": "[05] Helpers should have their expectations explained in NatSpec/comments",
  "Content": "\nCertain functions with `unchecked` blocks or other \"exotic logic\" have assumptions for certain input values. These assumptions are not documented well. It makes it error prone to validate against possible inputs and/or expected behaviour.\n\nExamples:\n\n1. is `_locateCurrentAmount`/`_applyFraction` which has a strong dependency on `duration != 0` and `startTime < endTime` (and `!=`). There are other cases too.\n2. In [AmountDeriver.sol#L13](https://github.com/ProjectOpenSea/seaport/blob/878121af65be408462f3eae04ab81018b4e199da/contracts/lib/AmountDeriver.sol#L13). The correct word is \"interpolation\", not  \"extrapolation\". Similarly at other places where the word is used.\n3. In [AmountDeriver.sol#L114](https://github.com/ProjectOpenSea/seaport/blob/878121af65be408462f3eae04ab81018b4e199da/contracts/lib/AmountDeriver.sol#L114), there are assumptions about the range of amounts supported in the protocol. This need to be documented well. Protocols such as Uniswap makes such assumptions explicit. More specifically, there are overflow issues when `value >= type(uint).max / type(uint120).max` Around `2**136`. \n\n## Proof of Concept\n**Context:** [lib/AmountDeriver.sol#L33](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/AmountDeriver.sol#L33), [lib/AmountDeriver.sol#L138](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/AmountDeriver.sol#L138)\n\n### Recommended Mitigation Steps\n\nDocument these assumptions.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/AmountDeriver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    AmountDerivationErrors\n} from \"../interfaces/AmountDerivationErrors.sol\";\n\n/**\n * @title AmountDeriver\n * @author 0age\n * @notice AmountDeriver contains pure functions related to deriving item\n *         amounts based on partial fill quantity and on linear extrapolation\n *         based on current time when the start amount and end amount differ.\n */\ncontract AmountDeriver is AmountDerivationErrors {\n    /**\n     * @dev Internal pure function to derive the current amount of a given item\n     *      based on the current price, the starting price, and the ending\n     *      price. If the start and end prices differ, the current price will be\n     *      extrapolated on a linear basis.\n     *\n     * @param startAmount The starting amount of the item.\n     * @param endAmount   The ending amount of the item.\n     * @param elapsed     The time elapsed since the order's start time.\n     * @param remaining   The time left until the order's end time.\n     * @param duration    The total duration of the order.\n     * @param roundUp     A boolean indicating whether the resultant amount\n     *                    should be rounded up or down.\n     *\n     * @return The current amount.\n     */\n    function _locateCurrentAmount(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        // Only modify end amount if it doesn't already equal start amount.\n        if (startAmount != endAmount) {\n            // Leave extra amount to add for rounding at zero (i.e. round down).\n            uint256 extraCeiling = 0;\n\n            // If rounding up, set rounding factor to one less than denominator.\n            if (roundUp) {\n                // Skip underflow check: duration cannot be zero.\n                unchecked {\n                    extraCeiling = duration - 1;\n                }\n            }\n\n            // Aggregate new amounts weighted by time with rounding factor\n            // prettier-ignore\n            uint256 totalBeforeDivision = (\n                (startAmount * remaining) + (endAmount * elapsed) + extraCeiling\n            );\n\n            // Division performed with no zero check as duration cannot be zero.\n            uint256 newAmount;\n            assembly {\n                newAmount := div(totalBeforeDivision, duration)\n            }\n\n            // Return the current amount (expressed as endAmount internally).\n            return newAmount;\n        }\n\n        // Return the original amount (now expressed as endAmount internally).\n        return endAmount;\n    }\n\n    /**\n     * @dev Internal pure function to return a fraction of a given value and to\n     *      ensure the resultant value does not have any fractional component.\n     *      Note that this function assumes that zero will never be supplied as\n     *      the denominator parameter; invalid / undefined behavior will result\n     *      should a denominator of zero be provided.\n     *\n     * @param numerator   A value indicating the portion of the order that\n     *                    should be filled.\n     * @param denominator A value indicating the total size of the order. Note\n     *                    that this value cannot be equal to zero.\n     * @param value       The value for which to compute the fraction.\n     *\n     * @return newValue The value after applying the fraction.\n     */\n    function _getFraction(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 value\n    ) internal pure returns (uint256 newValue) {\n        // Return value early in cases where the fraction resolves to 1.\n        if (numerator == denominator) {\n            return value;\n        }\n\n        // Ensure fraction can be applied to the value with no remainder. Note\n        // that the denominator cannot be zero.\n        bool exact;\n        assembly {\n            // Ensure new value contains no remainder via mulmod operator.\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\n            exact := iszero(mulmod(value, numerator, denominator))\n        }\n\n        // Ensure that division gave a final result with no remainder.\n        if (!exact) {\n            revert InexactFraction();\n        }\n\n        // Multiply the numerator by the value and ensure no overflow occurs.\n        uint256 valueTimesNumerator = value * numerator;\n\n        // Divide and check for remainder. Note that denominator cannot be zero.\n        assembly {\n            // Perform division without zero check.\n            newValue := div(valueTimesNumerator, denominator)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to apply a fraction to a consideration\n     * or offer item.\n     *\n     * @param startAmount     The starting amount of the item.\n     * @param endAmount       The ending amount of the item.\n     * @param numerator       A value indicating the portion of the order that\n     *                        should be filled.\n     * @param denominator     A value indicating the total size of the order.\n     * @param elapsed         The time elapsed since the order's start time.\n     * @param remaining       The time left until the order's end time.\n     * @param duration        The total duration of the order.\n     *\n     * @return amount The received item to transfer with the final amount.\n     */\n    function _applyFraction(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 numerator,\n        uint256 denominator,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // If start amount equals end amount, apply fraction to end amount.\n        if (startAmount == endAmount) {\n            // Apply fraction to end amount.\n            amount = _getFraction(numerator, denominator, endAmount);\n        } else {\n            // Otherwise, apply fraction to both and extrapolate final amount.\n            amount = _locateCurrentAmount(\n                _getFraction(numerator, denominator, startAmount),\n                _getFraction(numerator, denominator, endAmount),\n                elapsed,\n                remaining,\n                duration,\n                roundUp\n            );\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lib/AmountDeriver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    AmountDerivationErrors\n} from \"../interfaces/AmountDerivationErrors.sol\";\n\n/**\n * @title AmountDeriver\n * @author 0age\n * @notice AmountDeriver contains pure functions related to deriving item\n *         amounts based on partial fill quantity and on linear extrapolation\n *         based on current time when the start amount and end amount differ.\n */\ncontract AmountDeriver is AmountDerivationErrors {\n    /**\n     * @dev Internal pure function to derive the current amount of a given item\n     *      based on the current price, the starting price, and the ending\n     *      price. If the start and end prices differ, the current price will be\n     *      extrapolated on a linear basis.\n     *\n     * @param startAmount The starting amount of the item.\n     * @param endAmount   The ending amount of the item.\n     * @param elapsed     The time elapsed since the order's start time.\n     * @param remaining   The time left until the order's end time.\n     * @param duration    The total duration of the order.\n     * @param roundUp     A boolean indicating whether the resultant amount\n     *                    should be rounded up or down.\n     *\n     * @return The current amount.\n     */\n    function _locateCurrentAmount(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        // Only modify end amount if it doesn't already equal start amount.\n        if (startAmount != endAmount) {\n            // Leave extra amount to add for rounding at zero (i.e. round down).\n            uint256 extraCeiling = 0;\n\n            // If rounding up, set rounding factor to one less than denominator.\n            if (roundUp) {\n                // Skip underflow check: duration cannot be zero.\n                unchecked {\n                    extraCeiling = duration - 1;\n                }\n            }\n\n            // Aggregate new amounts weighted by time with rounding factor\n            // prettier-ignore\n            uint256 totalBeforeDivision = (\n                (startAmount * remaining) + (endAmount * elapsed) + extraCeiling\n            );\n\n            // Division performed with no zero check as duration cannot be zero.\n            uint256 newAmount;\n            assembly {\n                newAmount := div(totalBeforeDivision, duration)\n            }\n\n            // Return the current amount (expressed as endAmount internally).\n            return newAmount;\n        }\n\n        // Return the original amount (now expressed as endAmount internally).\n        return endAmount;\n    }\n\n    /**\n     * @dev Internal pure function to return a fraction of a given value and to\n     *      ensure the resultant value does not have any fractional component.\n     *      Note that this function assumes that zero will never be supplied as\n     *      the denominator parameter; invalid / undefined behavior will result\n     *      should a denominator of zero be provided.\n     *\n     * @param numerator   A value indicating the portion of the order that\n     *                    should be filled.\n     * @param denominator A value indicating the total size of the order. Note\n     *                    that this value cannot be equal to zero.\n     * @param value       The value for which to compute the fraction.\n     *\n     * @return newValue The value after applying the fraction.\n     */\n    function _getFraction(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 value\n    ) internal pure returns (uint256 newValue) {\n        // Return value early in cases where the fraction resolves to 1.\n        if (numerator == denominator) {\n            return value;\n        }\n\n        // Ensure fraction can be applied to the value with no remainder. Note\n        // that the denominator cannot be zero.\n        bool exact;\n        assembly {\n            // Ensure new value contains no remainder via mulmod operator.\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\n            exact := iszero(mulmod(value, numerator, denominator))\n        }\n\n        // Ensure that division gave a final result with no remainder.\n        if (!exact) {\n            revert InexactFraction();\n        }\n\n        // Multiply the numerator by the value and ensure no overflow occurs.\n        uint256 valueTimesNumerator = value * numerator;\n\n        // Divide and check for remainder. Note that denominator cannot be zero.\n        assembly {\n            // Perform division without zero check.\n            newValue := div(valueTimesNumerator, denominator)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to apply a fraction to a consideration\n     * or offer item.\n     *\n     * @param startAmount     The starting amount of the item.\n     * @param endAmount       The ending amount of the item.\n     * @param numerator       A value indicating the portion of the order that\n     *                        should be filled.\n     * @param denominator     A value indicating the total size of the order.\n     * @param elapsed         The time elapsed since the order's start time.\n     * @param remaining       The time left until the order's end time.\n     * @param duration        The total duration of the order.\n     *\n     * @return amount The received item to transfer with the final amount.\n     */\n    function _applyFraction(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 numerator,\n        uint256 denominator,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // If start amount equals end amount, apply fraction to end amount.\n        if (startAmount == endAmount) {\n            // Apply fraction to end amount.\n            amount = _getFraction(numerator, denominator, endAmount);\n        } else {\n            // Otherwise, apply fraction to both and extrapolate final amount.\n            amount = _locateCurrentAmount(\n                _getFraction(numerator, denominator, startAmount),\n                _getFraction(numerator, denominator, endAmount),\n                elapsed,\n                remaining,\n                duration,\n                roundUp\n            );\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lib/AmountDeriver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    AmountDerivationErrors\n} from \"../interfaces/AmountDerivationErrors.sol\";\n\n/**\n * @title AmountDeriver\n * @author 0age\n * @notice AmountDeriver contains pure functions related to deriving item\n *         amounts based on partial fill quantity and on linear extrapolation\n *         based on current time when the start amount and end amount differ.\n */\ncontract AmountDeriver is AmountDerivationErrors {\n    /**\n     * @dev Internal pure function to derive the current amount of a given item\n     *      based on the current price, the starting price, and the ending\n     *      price. If the start and end prices differ, the current price will be\n     *      extrapolated on a linear basis.\n     *\n     * @param startAmount The starting amount of the item.\n     * @param endAmount   The ending amount of the item.\n     * @param elapsed     The time elapsed since the order's start time.\n     * @param remaining   The time left until the order's end time.\n     * @param duration    The total duration of the order.\n     * @param roundUp     A boolean indicating whether the resultant amount\n     *                    should be rounded up or down.\n     *\n     * @return The current amount.\n     */\n    function _locateCurrentAmount(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        // Only modify end amount if it doesn't already equal start amount.\n        if (startAmount != endAmount) {\n            // Leave extra amount to add for rounding at zero (i.e. round down).\n            uint256 extraCeiling = 0;\n\n            // If rounding up, set rounding factor to one less than denominator.\n            if (roundUp) {\n                // Skip underflow check: duration cannot be zero.\n                unchecked {\n                    extraCeiling = duration - 1;\n                }\n            }\n\n            // Aggregate new amounts weighted by time with rounding factor\n            // prettier-ignore\n            uint256 totalBeforeDivision = (\n                (startAmount * remaining) + (endAmount * elapsed) + extraCeiling\n            );\n\n            // Division performed with no zero check as duration cannot be zero.\n            uint256 newAmount;\n            assembly {\n                newAmount := div(totalBeforeDivision, duration)\n            }\n\n            // Return the current amount (expressed as endAmount internally).\n            return newAmount;\n        }\n\n        // Return the original amount (now expressed as endAmount internally).\n        return endAmount;\n    }\n\n    /**\n     * @dev Internal pure function to return a fraction of a given value and to\n     *      ensure the resultant value does not have any fractional component.\n     *      Note that this function assumes that zero will never be supplied as\n     *      the denominator parameter; invalid / undefined behavior will result\n     *      should a denominator of zero be provided.\n     *\n     * @param numerator   A value indicating the portion of the order that\n     *                    should be filled.\n     * @param denominator A value indicating the total size of the order. Note\n     *                    that this value cannot be equal to zero.\n     * @param value       The value for which to compute the fraction.\n     *\n     * @return newValue The value after applying the fraction.\n     */\n    function _getFraction(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 value\n    ) internal pure returns (uint256 newValue) {\n        // Return value early in cases where the fraction resolves to 1.\n        if (numerator == denominator) {\n            return value;\n        }\n\n        // Ensure fraction can be applied to the value with no remainder. Note\n        // that the denominator cannot be zero.\n        bool exact;\n        assembly {\n            // Ensure new value contains no remainder via mulmod operator.\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\n            exact := iszero(mulmod(value, numerator, denominator))\n        }\n\n        // Ensure that division gave a final result with no remainder.\n        if (!exact) {\n            revert InexactFraction();\n        }\n\n        // Multiply the numerator by the value and ensure no overflow occurs.\n        uint256 valueTimesNumerator = value * numerator;\n\n        // Divide and check for remainder. Note that denominator cannot be zero.\n        assembly {\n            // Perform division without zero check.\n            newValue := div(valueTimesNumerator, denominator)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to apply a fraction to a consideration\n     * or offer item.\n     *\n     * @param startAmount     The starting amount of the item.\n     * @param endAmount       The ending amount of the item.\n     * @param numerator       A value indicating the portion of the order that\n     *                        should be filled.\n     * @param denominator     A value indicating the total size of the order.\n     * @param elapsed         The time elapsed since the order's start time.\n     * @param remaining       The time left until the order's end time.\n     * @param duration        The total duration of the order.\n     *\n     * @return amount The received item to transfer with the final amount.\n     */\n    function _applyFraction(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 numerator,\n        uint256 denominator,\n        uint256 elapsed,\n        uint256 remaining,\n        uint256 duration,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // If start amount equals end amount, apply fraction to end amount.\n        if (startAmount == endAmount) {\n            // Apply fraction to end amount.\n            amount = _getFraction(numerator, denominator, endAmount);\n        } else {\n            // Otherwise, apply fraction to both and extrapolate final amount.\n            amount = _locateCurrentAmount(\n                _getFraction(numerator, denominator, startAmount),\n                _getFraction(numerator, denominator, endAmount),\n                elapsed,\n                remaining,\n                duration,\n                roundUp\n            );\n        }\n    }\n}"
    }
  ]
}